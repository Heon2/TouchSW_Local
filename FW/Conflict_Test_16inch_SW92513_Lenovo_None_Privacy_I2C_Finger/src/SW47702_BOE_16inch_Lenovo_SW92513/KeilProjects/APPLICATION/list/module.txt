; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\module.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\module.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\module.crf ..\..\Module\module.c]
                          THUMB

                          AREA ||i.MODULE_Initialize||, CODE, READONLY, ALIGN=2

                  MODULE_Initialize PROC
;;;590    
;;;591    void MODULE_Initialize(void)
000000  b510              PUSH     {r4,lr}
;;;592    {
;;;593    	thisFixedConf = module_GetFixedConfig();
000002  f7fffffe          BL       module_GetFixedConfig
000006  4c09              LDR      r4,|L1.44|
;;;594    #if USED_NOISE_HOPPING_FREQ
;;;595    	thisCommonConf = app_GetCommonConfig();
000008  6060              STR      r0,[r4,#4]  ; thisFixedConf
00000a  f7fffffe          BL       app_GetCommonConfig
;;;596    	ptAppInfo = app_GetInfo();
00000e  60a0              STR      r0,[r4,#8]  ; thisCommonConf
000010  f7fffffe          BL       app_GetInfo
;;;597    #endif
;;;598    #if USED_PEN_MODE_OPERATION
;;;599    	module_init_param();
;;;600    #endif
;;;601    //	GPIO_Initialize(); // 시점 변경!!
;;;602    //	initBoardGPIO();
;;;603    
;;;604    	SRIC_Initialize();
000014  60e0              STR      r0,[r4,#0xc]  ; ptAppInfo
000016  f7fffffe          BL       SRIC_Initialize
;;;605    
;;;606    #if !USED_SPI_OFF_ECLK_OFF_vFF09
;;;607    	initECLK();
00001a  f7fffffe          BL       initECLK
;;;608    #endif /* !USED_SPI_OFF_ECLK_OFF_vFF09 */
;;;609    	delay_msec(10);
00001e  e8bd4010          POP      {r4,lr}
000022  f2427010          MOV      r0,#0x2710
000026  f7ffbffe          B.W      delay_us
;;;610    }
;;;611    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      ||.data||

                          AREA ||i.hal_clear_LocalType_flag||, CODE, READONLY, ALIGN=2

                  hal_clear_LocalType_flag PROC
;;;2981   
;;;2982   void hal_clear_LocalType_flag(void)
000000  4901              LDR      r1,|L2.8|
;;;2983   {
;;;2984   	gLocalTypeFlag = PARTIAL_PEN_BEACON;
000002  2000              MOVS     r0,#0
000004  7048              STRB     r0,[r1,#1]
;;;2985   }
000006  4770              BX       lr
;;;2986   
                          ENDP

                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.hal_clear_irq_flag||, CODE, READONLY, ALIGN=2

                  hal_clear_irq_flag PROC
;;;2949   
;;;2950   void hal_clear_irq_flag(int _id)
000000  4a01              LDR      r2,|L3.8|
;;;2951   {
;;;2952   	gbIrqFlag[_id] = 0;
000002  2100              MOVS     r1,#0
000004  5411              STRB     r1,[r2,r0]
;;;2953   }
000006  4770              BX       lr
;;;2954   
                          ENDP

                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.hal_clear_overlap_pen||, CODE, READONLY, ALIGN=2

                  hal_clear_overlap_pen PROC
;;;2965   
;;;2966   void hal_clear_overlap_pen(void)
000000  4901              LDR      r1,|L4.8|
;;;2967   {
;;;2968   	gucOverlapFPend = 0;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;2969   }
000006  4770              BX       lr
;;;2970   
                          ENDP

                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.hal_get_LocalType_flag||, CODE, READONLY, ALIGN=2

                  hal_get_LocalType_flag PROC
;;;2986   
;;;2987   ePartialSensing_t hal_get_LocalType_flag(void)
000000  4801              LDR      r0,|L5.8|
;;;2988   {
;;;2989   	return gLocalTypeFlag;
000002  7840              LDRB     r0,[r0,#1]  ; gLocalTypeFlag
;;;2990   }
000004  4770              BX       lr
;;;2991   
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.hal_get_irq_flag||, CODE, READONLY, ALIGN=2

                  hal_get_irq_flag PROC
;;;2954   
;;;2955   bool_t hal_get_irq_flag(int _id)
000000  4901              LDR      r1,|L6.8|
;;;2956   {
;;;2957   	return gbIrqFlag[_id];
000002  5c08              LDRB     r0,[r1,r0]
;;;2958   }
000004  4770              BX       lr
;;;2959   
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.bss||

                          AREA ||i.hal_get_overlap_pen||, CODE, READONLY, ALIGN=2

                  hal_get_overlap_pen PROC
;;;2970   
;;;2971   uint8_t hal_get_overlap_pen(void)
000000  4801              LDR      r0,|L7.8|
;;;2972   {
;;;2973   	return gucOverlapFPend;
000002  7800              LDRB     r0,[r0,#0]  ; gucOverlapFPend
;;;2974   }
000004  4770              BX       lr
;;;2975   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.hal_set_LocalType_flag||, CODE, READONLY, ALIGN=2

                  hal_set_LocalType_flag PROC
;;;2976   __IO ePartialSensing_t gLocalTypeFlag  = PARTIAL_PEN_BEACON;
;;;2977   void hal_set_LocalType_flag(ePartialSensing_t _id)
000000  4901              LDR      r1,|L8.8|
;;;2978   {
;;;2979   	gLocalTypeFlag = _id;
000002  7048              STRB     r0,[r1,#1]
;;;2980   }
000004  4770              BX       lr
;;;2981   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.hal_set_irq_flag||, CODE, READONLY, ALIGN=2

                  hal_set_irq_flag PROC
;;;2944   __IO bool_t gbIrqFlag[IRQ_ID_MAX] = { 0, };
;;;2945   void hal_set_irq_flag(int _id)
000000  4a01              LDR      r2,|L9.8|
;;;2946   {
;;;2947   	gbIrqFlag[_id] = 1;
000002  2101              MOVS     r1,#1
000004  5411              STRB     r1,[r2,r0]
;;;2948   }
000006  4770              BX       lr
;;;2949   
                          ENDP

                  |L9.8|
                          DCD      ||.bss||

                          AREA ||i.hal_set_overlap_pen||, CODE, READONLY, ALIGN=2

                  hal_set_overlap_pen PROC
;;;2960   __IO uint8_t gucOverlapFPend = 0;
;;;2961   void hal_set_overlap_pen(void)
000000  4901              LDR      r1,|L10.8|
;;;2962   {
;;;2963   	gucOverlapFPend = 1;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;2964   }
000006  4770              BX       lr
;;;2965   
                          ENDP

                  |L10.8|
                          DCD      ||.data||

                          AREA ||i.module_Check_LcdOn||, CODE, READONLY, ALIGN=1

                  module_Check_LcdOn PROC
;;;844    #if USED_TP_LCD_ON_OPERATION
;;;845    bool_t module_Check_LcdOn(void)
000000  b510              PUSH     {r4,lr}
;;;846    {
;;;847    #if USED_OPERATION_STAND_ALONE
;;;848    //	if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x0)
;;;849    //	{
;;;850    //		Hal_VccOff_State();
;;;851    //		return NO;
;;;852    //	}
;;;853    	return YES;
;;;854    #else /* USED_OPERATION_STAND_ALONE */
;;;855    #if USED_FORCE_S3_MODE_OPER
;;;856    //	if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x0)
;;;857    	{
;;;858    //		Hal_VccOff_State();
;;;859    		return NO;
;;;860    	}
;;;861    #else /* USED_FORCE_S3_MODE_OPER */
;;;862    	if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x0)
000002  2035              MOVS     r0,#0x35
000004  f7fffffe          BL       GPIO_Get_IN
000008  2800              CMP      r0,#0
;;;863    	{
;;;864    		Hal_VccOff_State();
;;;865    		return NO;
;;;866    	}
;;;867    #endif /* USED_FORCE_S3_MODE_OPER */
;;;868    
;;;869    	return YES;
00000a  bf1c              ITT      NE
00000c  2001              MOVNE    r0,#1
;;;870    #endif /* USED_OPERATION_STAND_ALONE */
;;;871    }
00000e  bd10              POPNE    {r4,pc}
000010  f7fffffe          BL       Hal_VccOff_State
000014  2000              MOVS     r0,#0                 ;865
000016  bd10              POP      {r4,pc}
;;;872    #endif /* USED_TP_LCD_ON_OPERATION */
                          ENDP


                          AREA ||i.module_Check_SMT_Mode||, CODE, READONLY, ALIGN=1

                  module_Check_SMT_Mode PROC
;;;805    #if USED_SMT_OP_MODE
;;;806    bool_t module_Check_SMT_Mode(void)
000000  b510              PUSH     {r4,lr}
;;;807    {
;;;808    	if(IS_GPIO_PIN(_GPIO_SWCLK) == 0x00 && IS_GPIO_PIN(_GPIO_SWDIO) == 0x00)
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       GPIO_Get_IN
000008  b930              CBNZ     r0,|L12.24|
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       GPIO_Get_IN
000010  2800              CMP      r0,#0
;;;809    	{
;;;810    		return YES;
000012  bf04              ITT      EQ
000014  2001              MOVEQ    r0,#1
;;;811    	}
;;;812    	return NO;
;;;813    }
000016  bd10              POPEQ    {r4,pc}
                  |L12.24|
000018  2000              MOVS     r0,#0                 ;812
00001a  bd10              POP      {r4,pc}
;;;814    
                          ENDP


                          AREA ||i.module_Check_TPEN||, CODE, READONLY, ALIGN=1

                  module_Check_TPEN PROC
;;;883    
;;;884    bool_t module_Check_TPEN(void)
000000  b510              PUSH     {r4,lr}
;;;885    {
;;;886    #if (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3)
;;;887    	#if (!DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN)
;;;888    		if(IS_GPIO_PIN(_GPIO_TP_EN) == 0x0)
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       GPIO_Get_IN
000008  2800              CMP      r0,#0
;;;889    		{
;;;890    			return YES;
00000a  bf0c              ITE      EQ
00000c  2001              MOVEQ    r0,#1
;;;891    		}
;;;892    	#endif /* !DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN */
;;;893    #endif /* (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3) */
;;;894    	return NO;
00000e  2000              MOVNE    r0,#0
;;;895    }
000010  bd10              POP      {r4,pc}
;;;896    
                          ENDP


                          AREA ||i.module_Enter_SMT_Mode||, CODE, READONLY, ALIGN=1

                  module_Enter_SMT_Mode PROC
;;;814    
;;;815    void module_Enter_SMT_Mode(void)
000000  b510              PUSH     {r4,lr}
;;;816    {
;;;817    	GPIO_Init(_GPIO_PWM_SRIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000002  2300              MOVS     r3,#0
000004  461a              MOV      r2,r3
000006  2103              MOVS     r1,#3
000008  202f              MOVS     r0,#0x2f
00000a  f7fffffe          BL       GPIO_Init
;;;818    	GPIO_Init(_GPIO_PWM_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00000e  2300              MOVS     r3,#0
000010  2103              MOVS     r1,#3
000012  e8bd4010          POP      {r4,lr}
000016  461a              MOV      r2,r3
000018  2030              MOVS     r0,#0x30
00001a  f7ffbffe          B.W      GPIO_Init
;;;819    #ifndef MODE_I2C
;;;820    	NVIC_SetPendingIRQ(I2C_SLV_IRQn);
;;;821    	NVIC_DisableIRQ(I2C_SLV_IRQn);    /* Interrupt Disable */
;;;822    
;;;823    	GPIO_Init(_GPIO_SLV_SCL, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;824    	GPIO_Init(_GPIO_SLV_SDA, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;825    	GPIO_Init(_GPIO_TP_INTR, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;826    #endif /* #ifndef MODE_I2C */
;;;827    }
;;;828    
                          ENDP


                          AREA ||i.module_Exit_SMT_Mode||, CODE, READONLY, ALIGN=1

                  module_Exit_SMT_Mode PROC
;;;828    
;;;829    void module_Exit_SMT_Mode(void)
000000  4770              BX       lr
;;;830    {
;;;831    #ifndef MODE_I2C
;;;832    	I2C_Initialize();
;;;833    #endif /* #ifndef MODE_I2C */
;;;834    }
;;;835    
                          ENDP


                          AREA ||i.module_HW_Init||, CODE, READONLY, ALIGN=2

                  module_HW_Init PROC
;;;652    tGPIO_CtrlReg_t * _GPIO;
;;;653    void module_HW_Init(void)
000000  4916              LDR      r1,|L16.92|
;;;654    {
000002  b510              PUSH     {r4,lr}
;;;655    	_GPIO = GPIO;
000004  4814              LDR      r0,|L16.88|
;;;656    	/*
;;;657    	 * For Debug Pin
;;;658    	 */
;;;659    
;;;660    	GPIO_Init(_GPIO_TP_INTR, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
000006  6108              STR      r0,[r1,#0x10]  ; _GPIO
000008  2301              MOVS     r3,#1
00000a  2200              MOVS     r2,#0
00000c  2103              MOVS     r1,#3
00000e  2004              MOVS     r0,#4
000010  f7fffffe          BL       GPIO_Init
000014  2000              MOVS     r0,#0
000016  4602              MOV      r2,r0
                  |L16.24|
000018  f1005100          ADD      r1,r0,#0x20000000
00001c  f5012180          ADD      r1,r1,#0x40000
000020  600a              STR      r2,[r1,#0]
000022  604a              STR      r2,[r1,#4]
000024  3008              ADDS     r0,r0,#8
000026  f5b04fc0          CMP      r0,#0x6000
00002a  dbf5              BLT      |L16.24|
00002c  f7fffffe          BL       SCRB_Initialize
000030  f7fffffe          BL       TIMER_Initialize
000034  200c              MOVS     r0,#0xc
000036  f7fffffe          BL       TimerTick_Initialize
00003a  f7fffffe          BL       USB_DevInit
00003e  f7fffffe          BL       HAL_PendSVHandlerInitialize
000042  f7fffffe          BL       I2C_Initialize
000046  f7fffffe          BL       protocol_init
;;;661    
;;;662    	module_MspiBuff_Init();
;;;663    	module_System_Init();
;;;664    	module_Protocol_Init();
;;;665    	init_DSP_B();
00004a  f7fffffe          BL       init_DSP_B
;;;666    	DSPA_Initialize();
00004e  e8bd4010          POP      {r4,lr}
000052  f7ffbffe          B.W      DSPA_Initialize
;;;667    }
;;;668    
                          ENDP

000056  0000              DCW      0x0000
                  |L16.88|
                          DCD      0x40000100
                  |L16.92|
                          DCD      ||.data||

                          AREA ||i.module_Init_Signal||, CODE, READONLY, ALIGN=2

                  module_Init_Signal PROC
;;;731    
;;;732    bool_t module_Init_Signal(void)
000000  481a              LDR      r0,|L17.108|
;;;733    {
000002  b510              PUSH     {r4,lr}
000004  7800              LDRB     r0,[r0,#0]  ; wdt_init
000006  2800              CMP      r0,#0
000008  bf18              IT       NE
00000a  f7fffffe          BLNE     Hal_WDT_DeInit
00000e  2302              MOVS     r3,#2
000010  2201              MOVS     r2,#1
000012  2103              MOVS     r1,#3
000014  2035              MOVS     r0,#0x35
000016  f7fffffe          BL       GPIO_Init
00001a  2101              MOVS     r1,#1
00001c  2035              MOVS     r0,#0x35
00001e  f7fffffe          BL       GPIO_Set_PE
000022  2302              MOVS     r3,#2
000024  2201              MOVS     r2,#1
000026  2103              MOVS     r1,#3
000028  2005              MOVS     r0,#5
00002a  f7fffffe          BL       GPIO_Init
                  |L17.46|
00002e  2035              MOVS     r0,#0x35
000030  f7fffffe          BL       GPIO_Get_IN
000034  2801              CMP      r0,#1
000036  d005              BEQ      |L17.68|
000038  f7fffffe          BL       protocol_swip_GetMode
00003c  2802              CMP      r0,#2
00003e  bf18              IT       NE
000040  2811              CMPNE    r0,#0x11
000042  d1f4              BNE      |L17.46|
                  |L17.68|
000044  f04f0302          MOV      r3,#2
000048  f04f0201          MOV      r2,#1
00004c  f04f0100          MOV      r1,#0
000050  f04f002e          MOV      r0,#0x2e
000054  f7fffffe          BL       GPIO_Init
000058  2302              MOVS     r3,#2
00005a  2201              MOVS     r2,#1
00005c  2100              MOVS     r1,#0
00005e  202d              MOVS     r0,#0x2d
000060  f7fffffe          BL       GPIO_Init
;;;734    	bool_t bReg = NO;
;;;735    	module_Watch_Disable();
;;;736    
;;;737    #if USED_TP_LCD_ON_OPERATION
;;;738    	module_Init_LcdOn();
;;;739    #endif /* USED_TP_LCD_ON_OPERATION */
;;;740    
;;;741    	module_Init_TPEN();
;;;742    #if USED_TP_RST_OPERATION
;;;743    	module_Init_TPRST();
;;;744    #endif /* USED_TP_RST_OPERATION */
;;;745    
;;;746    #if USED_TOUCH_SLEEP_CTRL_BY_HOST
;;;747    	module_Init_TOUCH_SLEEP();
;;;748    #endif /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;749    
;;;750    #if USED_MNT_S3_MODE_FUNCTION
;;;751    	initMNT_S3_MODE_GPIO();
;;;752    
;;;753    	if(module_Check_S3_Power())
;;;754    	{
;;;755    		module_RollBack_Sync();
;;;756    		bReg = YES;
;;;757    	}
;;;758    
;;;759    	/*
;;;760    	 * S3모드 진입 하게 될 경우 Signal Out이 High여야지만 PMIC가 구동 되면서 LCD_ON이 High가 됨!!
;;;761    	 */
;;;762    #else /* USED_MNT_S3_MODE_FUNCTION */
;;;763    	{
;;;764    	#if USED_TP_RSTnLCDON_DOUBLE_OPERATION
;;;765    		if(module_Wait_TPRST() && module_Wait_LcdOn())
;;;766    		{
;;;767    			module_RollBack_Sync();
;;;768    			GPIO_Set_INT(_GPIO_TP_RST, GPIO_INTEN_DISABLE, GPIO_INTTYPE_DISABLE);
;;;769    			initBoardGPIO();
;;;770    			return YES;
;;;771    		}
;;;772    	#elif USED_TP_RST_OPERATION
;;;773    		if(module_Wait_TPRST())
;;;774    		{
;;;775    			module_RollBack_Sync();
;;;776    			GPIO_Set_INT(_GPIO_TP_RST, GPIO_INTEN_DISABLE, GPIO_INTTYPE_DISABLE);
;;;777    			initBoardGPIO();
;;;778    			return YES;
;;;779    		}
;;;780    	#elif USED_TP_LCD_ON_OPERATION
;;;781    		{
;;;782    		#if USED_TOUCH_SLEEP_CTRL_BY_HOST
;;;783    			if(module_Wait_LcdOn() && module_Wait_TOUCH_SLEEP())
;;;784    			{
;;;785    				module_RollBack_Sync();
;;;786    				GPIO_Set_INT(_GPIO_SLEEP_EN, GPIO_INTEN_DISABLE, GPIO_INTTYPE_DISABLE);
;;;787    				return YES;
;;;788    			}
;;;789    		#else /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;790    			if(module_Wait_LcdOn())
;;;791    			{
;;;792    				module_RollBack_Sync();
;;;793    				initBoardGPIO();
000064  f7fffffe          BL       initBoardGPIO
;;;794    				return YES;
000068  2001              MOVS     r0,#1
;;;795    			}
;;;796    		#endif /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;797    		}
;;;798    	#endif /* USED_TP_RSTnLCDON_DOUBLE_OPERATION */
;;;799    	}
;;;800    #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;801    
;;;802    	return bReg;
;;;803    }
00006a  bd10              POP      {r4,pc}
;;;804    
                          ENDP

                  |L17.108|
                          DCD      wdt_init

                          AREA ||i.module_Init_TPEN||, CODE, READONLY, ALIGN=1

                  module_Init_TPEN PROC
;;;873    
;;;874    bool_t module_Init_TPEN(void) // NOTE : missing return value
000000  b510              PUSH     {r4,lr}
;;;875    {
;;;876    #if (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3)
;;;877    	#if !DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN
;;;878    		GPIO_Init(_GPIO_TP_EN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
000002  2302              MOVS     r3,#2
000004  2201              MOVS     r2,#1
000006  2103              MOVS     r1,#3
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       GPIO_Init
;;;879    	#endif /* DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN */
;;;880    #endif /* (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3) */
;;;881    	return YES;
00000e  2001              MOVS     r0,#1
;;;882    }
000010  bd10              POP      {r4,pc}
;;;883    
                          ENDP


                          AREA ||i.module_Protocol_Init||, CODE, READONLY, ALIGN=1

                  module_Protocol_Init PROC
;;;618    
;;;619    void module_Protocol_Init(void)
000000  b510              PUSH     {r4,lr}
;;;620    {
;;;621    #ifndef MODE_I2C
;;;622    	int bSWreset = 0;
;;;623    	SCRB->USB_CTRL_UC.ulBulk = 0x01;
;;;624    	HW_REG(BASE_USB_SRAM|0xC4) =  HW_REG(BASE_USB_SRAM|0xC4)  | BIT3;
;;;625    //	delay_ms(530); // NEC모델 적용 사항
;;;626    	USB_DevInit();
;;;627    
;;;628    	if(bSWreset)
;;;629    	{
;;;630    		mUsbSoftRstSet();
;;;631    		while (wFOTGPeri_Port(0x100) & BIT4);
;;;632    	}
;;;633    
;;;634    	NVIC_ClearPendingIRQ(USB_IRQn);
;;;635    	SCRB->USB_INTR_CLR.ulBulk = 0x7; // USB CM3 Internal Interrupt clear!!
;;;636    	NVIC_EnableIRQ (USB_IRQn);
;;;637    	NVIC_SetPriority(USB_IRQn, USB_IRQn_Priority);
;;;638    #else
;;;639    	USB_DevInit(); // Must Call this function since include application info initialize.
000002  f7fffffe          BL       USB_DevInit
;;;640    #endif
;;;641    	//ETC
;;;642    	HAL_PendSVHandlerInitialize();
000006  f7fffffe          BL       HAL_PendSVHandlerInitialize
;;;643    
;;;644    	I2C_Initialize();
00000a  f7fffffe          BL       I2C_Initialize
;;;645    #if USED_TPIC_VCOM_LEVEL_I2CM_CONTROL
;;;646    	I2CM_Initialize();
;;;647    #endif /* USED_TPIC_VCOM_LEVEL_I2CM_CONTROL */
;;;648    
;;;649    	protocol_init();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      protocol_init
;;;650    }
;;;651    
                          ENDP


                          AREA ||i.module_SignalOut_SMT_Mode||, CODE, READONLY, ALIGN=1

                  module_SignalOut_SMT_Mode PROC
;;;835    
;;;836    void module_SignalOut_SMT_Mode(void)
000000  b510              PUSH     {r4,lr}
;;;837    {
;;;838    	delay_us(500);
000002  f44f70fa          MOV      r0,#0x1f4
000006  f7fffffe          BL       delay_us
;;;839    	GPIO_Toggle(_GPIO_PWM_SRIC);
00000a  202f              MOVS     r0,#0x2f
00000c  f7fffffe          BL       GPIO_Toggle
;;;840    	GPIO_Toggle(_GPIO_PWM_TPIC);
000010  e8bd4010          POP      {r4,lr}
000014  2030              MOVS     r0,#0x30
000016  f7ffbffe          B.W      GPIO_Toggle
;;;841    }
;;;842    #endif /* USED_SMT_OP_MODE */
                          ENDP


                          AREA ||i.module_Skip_Event||, CODE, READONLY, ALIGN=1

                  module_Skip_Event PROC
;;;1216   
;;;1217   bool_t module_Skip_Event(void)
000000  b510              PUSH     {r4,lr}
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       GPIO_Get_IN
000008  b128              CBZ      r0,|L21.22|
;;;1218   {
;;;1219   #if USED_DO_NOT_TOUCH_REPORT
;;;1220   	return YES;
;;;1221   #else /* USED_DO_NOT_TOUCH_REPORT */
;;;1222   #if USED_TOUCH_REPORT_ON_OFF_CONTROL
;;;1223   	if((module_Check_TPEN() == YES) || (HAL_GetTouchReportEnControl() == NO))
00000a  f7fffffe          BL       HAL_GetTouchReportEnControl
00000e  2800              CMP      r0,#0
;;;1224   #else /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
;;;1225   	if(module_Check_TPEN() == YES)
;;;1226   #endif /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
;;;1227   	{
;;;1228   		return YES;
;;;1229   	}
;;;1230   	return NO;
000010  bf1c              ITT      NE
000012  2000              MOVNE    r0,#0
;;;1231   #endif /* USED_DO_NOT_TOUCH_REPORT */
;;;1232   }
000014  bd10              POPNE    {r4,pc}
                  |L21.22|
000016  2001              MOVS     r0,#1                 ;1228
000018  bd10              POP      {r4,pc}
;;;1233   
                          ENDP


                          AREA ||i.module_Start||, CODE, READONLY, ALIGN=1

                  module_Start PROC
;;;668    
;;;669    bool_t module_Start(void)
000000  2000              MOVS     r0,#0
;;;670    {
;;;671    	bool_t retVal = YES;
;;;672    
;;;673    	retVal = Hal_sric_start(NO);
000002  f7ffbffe          B.W      Hal_sric_start
;;;674    
;;;675    	return retVal;
;;;676    }
;;;677    
                          ENDP


                          AREA ||i.module_Stop||, CODE, READONLY, ALIGN=2

                  module_Stop PROC
;;;677    
;;;678    void module_Stop(bool_t bIsVCCOff)
000000  b510              PUSH     {r4,lr}
;;;679    {
000002  4604              MOV      r4,r0
000004  b08c              SUB      sp,sp,#0x30
;;;680    #if USED_ECLK_ON_OFF_CONTROL
;;;681    	HAL_SetECLKOnOffControl(NO);
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       HAL_SetECLKOnOffControl
;;;682    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;683    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;684    	HAL_SetTPICMuxEnControl(NO, bIsVCCOff);
00000c  4621              MOV      r1,r4
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       HAL_SetTPICMuxEnControl
;;;685    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;686    #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;687    	HAL_SetTPICPenEnControl(NO);
;;;688    #endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;689    #if USED_TOUCH_REPORT_ON_OFF_CONTROL
;;;690    	HAL_SetTouchReportEnControl(NO);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       HAL_SetTouchReportEnControl
;;;691    #endif /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
;;;692    #if USE_FREQ_HOPPING_BASELINE_CONTI_UPDATE
;;;693    	HAL_SetHoppBaselineContinueEnControl(NO);
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       HAL_SetHoppBaselineContinueEnControl
;;;694    #endif /* USE_FREQ_HOPPING_BASELINE_CONTI_UPDATE */
;;;695    //	GPIO_Init(_GPIO_TSYNC_OUT, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;696    
;;;697    	tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
000020  481a              LDR      r0,|L23.140|
000022  f10d0e10          ADD      lr,sp,#0x10
000026  e8b0100e          LDM      r0!,{r1-r3,r12}
00002a  e88d100e          STM      sp,{r1-r3,r12}
00002e  e8b0100e          LDM      r0!,{r1-r3,r12}
000032  e88e100e          STM      lr,{r1-r3,r12}
000036  c80f              LDM      r0,{r0-r3}
000038  f10d0c20          ADD      r12,sp,#0x20
00003c  e88c000f          STM      r12,{r0-r3}
;;;698    	{
;;;699    		{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;700    		{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, DISABLE},
;;;701    		{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, DISABLE},
;;;702    		{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;703    	};
;;;704    	PWMDRV_ITConfig((tPWM_INTR_CFG_t *)&tPWM_INTR_CFG[0], 4);
000040  2104              MOVS     r1,#4
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       PWMDRV_ITConfig
000048  f04f20e0          MOV      r0,#0xe000e000
00004c  f44f7180          MOV      r1,#0x100
000050  f8c01180          STR      r1,[r0,#0x180]
000054  0049              LSLS     r1,r1,#1
000056  f8c01180          STR      r1,[r0,#0x180]
;;;705    
;;;706    	NVIC_DisableIRQ(GPIOA_IRQn);
;;;707    	NVIC_DisableIRQ(GPIOM_IRQn);
;;;708    	MSPI_ITConfig(DISABLE);
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       MSPI_ITConfig
;;;709    	MSPI_Cmd(DISABLE);
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       MSPI_Cmd
;;;710    	PWMDRV_Cmd(DISABLE);
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       PWMDRV_Cmd
;;;711    
;;;712    	SCRB->SYS_RST_CTL.tBit.pwm_rst = 1;
00006c  f04f4080          MOV      r0,#0x40000000
000070  68c1              LDR      r1,[r0,#0xc]
000072  f0410140          ORR      r1,r1,#0x40
000076  60c1              STR      r1,[r0,#0xc]
;;;713    	SCRB->SYS_RST_CTL.tBit.pwm_rst = 0;
000078  68c1              LDR      r1,[r0,#0xc]
00007a  f0210140          BIC      r1,r1,#0x40
00007e  60c1              STR      r1,[r0,#0xc]
;;;714    
;;;715    	PARAM_SetMode(PARAM_MODE_NONE);
000080  f04f30ff          MOV      r0,#0xffffffff
000084  f7fffffe          BL       PARAM_SetMode
;;;716    }
000088  b00c              ADD      sp,sp,#0x30
00008a  bd10              POP      {r4,pc}
;;;717    
                          ENDP

                  |L23.140|
                          DCD      ||.constdata||

                          AREA ||i.module_Switch_Freq||, CODE, READONLY, ALIGN=2

                  module_Switch_Freq PROC
;;;1297   #if USED_NOISE_HOPPING_FREQ
;;;1298   bool_t module_Switch_Freq(eSENSING_FREQ_t _Freq)
000000  4a10              LDR      r2,|L24.68|
;;;1299   {
000002  b510              PUSH     {r4,lr}
;;;1300   	bool_t retVal = FALSE;
;;;1301   	bool_t bFreqUse = thisCommonConf->bUseFreqHopp;
000004  6892              LDR      r2,[r2,#8]  ; thisCommonConf
000006  2100              MOVS     r1,#0                 ;1300
;;;1302   
;;;1303   	if(_Freq == _FREQ_UNKNOWN_ || !bFreqUse)
000008  2800              CMP      r0,#0
00000a  7e53              LDRB     r3,[r2,#0x19]         ;1301
00000c  bf18              IT       NE
00000e  2b00              CMPNE    r3,#0
000010  d00b              BEQ      |L24.42|
000012  490c              LDR      r1,|L24.68|
;;;1304   	{
;;;1305   		retVal = FALSE;
;;;1306   	}
;;;1307   	else
;;;1308   	{
;;;1309   	#if USED_PEN_MODE_OPERATION
;;;1310   		tAlgorithmInfo_t *tAlgorithmInfo = algorithm_GetInfo();
;;;1311   		if(_Freq == thisCommonConf->MainFreq)
;;;1312   		{
;;;1313   			ptAppInfo->eSelectFreq = FREQ_MAIN;
;;;1314   			HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
;;;1315   #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;1316   			if(tAlgorithmInfo->tPenInfo.bSearch_Mode_Flag == 0)
;;;1317   			{
;;;1318   				hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_HOPP_SETTABLE_BEACON);
;;;1319   			}
;;;1320   			else
;;;1321   			{
;;;1322   				hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_SETTABLE_BEACON);
;;;1323   			}
;;;1324   #endif
;;;1325   		}
;;;1326   		else if(_Freq == thisCommonConf->HoppFreq1)
;;;1327   		{
;;;1328   			ptAppInfo->eSelectFreq = FREQ_HOPP1;
;;;1329   			HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_HOP1_MODE);
;;;1330   #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;1331   			if(tAlgorithmInfo->tPenInfo.bSearch_Mode_Flag == 0)
;;;1332   			{
;;;1333   				hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_HOPP_SETTABLE_BEACON);
;;;1334   			}
;;;1335   			else
;;;1336   			{
;;;1337   				hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_SETTABLE_BEACON);
;;;1338   			}
;;;1339   #endif
;;;1340   		}
;;;1341   //		else if(_Freq == thisCommonConf->HoppFreq2)
;;;1342   //		{
;;;1343   //			ptAppInfo->eSelectFreq = FREQ_HOPP2;
;;;1344   //		}
;;;1345   		else
;;;1346   		{
;;;1347   			ptAppInfo->eSelectFreq = FREQ_UNKNOWN;
;;;1348   		}
;;;1349   	#else /* USED_PEN_MODE_OPERATION */
;;;1350   		if(_Freq == thisCommonConf->MainFreq)
000014  7e93              LDRB     r3,[r2,#0x1a]
;;;1351   		{
;;;1352   			ptAppInfo->eSelectFreq = FREQ_MAIN;
000016  68c9              LDR      r1,[r1,#0xc]
000018  4283              CMP      r3,r0                 ;1350
00001a  d108              BNE      |L24.46|
00001c  2001              MOVS     r0,#1
00001e  74c8              STRB     r0,[r1,#0x13]
;;;1353   			HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
000020  f05f0005          MOVS.W   r0,#5
                  |L24.36|
;;;1354   		}
;;;1355   		else if(_Freq == thisCommonConf->HoppFreq1)
;;;1356   		{
;;;1357   			ptAppInfo->eSelectFreq = FREQ_HOPP1;
;;;1358   			HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_HOP1_MODE);
000024  f7fffffe          BL       HAL_SetSensingChangeMode
                  |L24.40|
;;;1359   		}
;;;1360   //		else if(_Freq == thisCommonConf->HoppFreq2)
;;;1361   //		{
;;;1362   //			ptAppInfo->eSelectFreq = FREQ_HOPP2;
;;;1363   //		}
;;;1364   		else
;;;1365   		{
;;;1366   			ptAppInfo->eSelectFreq = FREQ_UNKNOWN;
;;;1367   		}
;;;1368   	#endif /* USED_PEN_MODE_OPERATION */
;;;1369   
;;;1370   		retVal = TRUE;
000028  2101              MOVS     r1,#1
                  |L24.42|
;;;1371   	}
;;;1372   
;;;1373   	return retVal;
00002a  4608              MOV      r0,r1
;;;1374   }
00002c  bd10              POP      {r4,pc}
                  |L24.46|
00002e  7ed2              LDRB     r2,[r2,#0x1b]         ;1355
000030  4282              CMP      r2,r0                 ;1355
000032  bf0c              ITE      EQ                    ;1357
000034  2002              MOVEQ    r0,#2                 ;1357
000036  2000              MOVNE    r0,#0                 ;1366
000038  74c8              STRB     r0,[r1,#0x13]         ;1366
00003a  bf08              IT       EQ                    ;1358
00003c  2006              MOVEQ    r0,#6                 ;1358
00003e  d0f1              BEQ      |L24.36|
000040  e7f2              B        |L24.40|
;;;1375   #endif /* USED_NOISE_HOPPING_FREQ */
                          ENDP

000042  0000              DCW      0x0000
                  |L24.68|
                          DCD      ||.data||

                          AREA ||i.module_Watch_Disable||, CODE, READONLY, ALIGN=2

                  module_Watch_Disable PROC
;;;723    extern __IO bool_t wdt_init;
;;;724    void module_Watch_Disable(void)
000000  4803              LDR      r0,|L25.16|
;;;725    {
;;;726    	if(wdt_init)
000002  7800              LDRB     r0,[r0,#0]  ; wdt_init
000004  2800              CMP      r0,#0                 ;725
;;;727    	{
;;;728    		Hal_WDT_DeInit();
;;;729    	}
;;;730    }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  f7ffbffe          B.W      Hal_WDT_DeInit
;;;731    
                          ENDP

00000e  0000              DCW      0x0000
                  |L25.16|
                          DCD      wdt_init

                          AREA ||i.module_Watch_Enable||, CODE, READONLY, ALIGN=1

                  module_Watch_Enable PROC
;;;717    
;;;718    void module_Watch_Enable(void)
000000  f7ffbffe          B.W      Hal_WDT_Init
;;;719    {
;;;720    	Hal_WDT_Init();
;;;721    }
;;;722    
                          ENDP


                          AREA ||i.module_read_NI_sample_data||, CODE, READONLY, ALIGN=2

                  module_read_NI_sample_data PROC
;;;2906   #if (USED_IDLE_MODE_CONTROL)
;;;2907   void module_read_NI_sample_data(void)
000000  b4f8              PUSH     {r3-r7}
;;;2908   {
;;;2909   	int c, r;
;;;2910   	int width = COL_MAX;
;;;2911   	int height = NI_ROW_MAX;
;;;2912   	volatile unsigned long uiBaseAddr = BASE_RAW_SRAM;
000002  4814              LDR      r0,|L27.84|
;;;2913   
;;;2914   	for (r = 0 ; r < height ; ++r)
;;;2915   	{
;;;2916   		for (c = 0 ; c < width ; ++c)
;;;2917   		{
;;;2918   			HAL_WRITE_RAW_IMAGE(r, c, *((volatile unsigned short *)((thisFixedConf->ulFullSensing_Remap_Table[r][c] + uiBaseAddr))));
000004  9000              STR      r0,[sp,#0]
000006  4814              LDR      r0,|L27.88|
000008  4d14              LDR      r5,|L27.92|
00000a  f04f0c00          MOV      r12,#0                ;2914
00000e  6844              LDR      r4,[r0,#4]  ; thisFixedConf
                  |L27.16|
000010  ebcc01cc          RSB      r1,r12,r12,LSL #3
000014  eb010241          ADD      r2,r1,r1,LSL #1
000018  2000              MOVS     r0,#0                 ;2916
00001a  eb0501c2          ADD      r1,r5,r2,LSL #3
00001e  eb0403c2          ADD      r3,r4,r2,LSL #3
000022  bf00              NOP      
                  |L27.36|
000024  eb030240          ADD      r2,r3,r0,LSL #1
000028  9f00              LDR      r7,[sp,#0]
00002a  8816              LDRH     r6,[r2,#0]
00002c  5bf6              LDRH     r6,[r6,r7]
00002e  f8216010          STRH     r6,[r1,r0,LSL #1]
000032  8852              LDRH     r2,[r2,#2]
000034  9e00              LDR      r6,[sp,#0]
000036  5b92              LDRH     r2,[r2,r6]
000038  eb010640          ADD      r6,r1,r0,LSL #1
00003c  1c80              ADDS     r0,r0,#2
00003e  8072              STRH     r2,[r6,#2]
000040  2854              CMP      r0,#0x54
000042  dbef              BLT      |L27.36|
000044  f10c0c01          ADD      r12,r12,#1
000048  f1bc0f0a          CMP      r12,#0xa
00004c  dbe0              BLT      |L27.16|
;;;2919   		}
;;;2920   	}
;;;2921   }
00004e  bcf8              POP      {r3-r7}
000050  4770              BX       lr
;;;2922   #endif /* (USED_IDLE_MODE_CONTROL) */
                          ENDP

000052  0000              DCW      0x0000
                  |L27.84|
                          DCD      0x20040000
                  |L27.88|
                          DCD      ||.data||
                  |L27.92|
                          DCD      FullSharedBuff

                          AREA ||i.module_read_full_sample_data||, CODE, READONLY, ALIGN=2

                  module_read_full_sample_data PROC
;;;2856   
;;;2857   void module_read_full_sample_data(void)
000000  b4f8              PUSH     {r3-r7}
;;;2858   {
;;;2859   #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;2860   	int c, r;
;;;2861   	int width = COL_MAX;
;;;2862   	int height = ROW_MAX;
;;;2863   	int ulRealRowIdx;
;;;2864   	volatile unsigned long uiBaseAddr = BASE_RAW_SRAM;
000002  482a              LDR      r0,|L28.172|
;;;2865   
;;;2866   	for (r = 0 ; r < height ; ++r)
;;;2867   	{
;;;2868   		ulRealRowIdx = r + (ROIC_ALIGNED_ROW_LEN * FINGER_ESD_SCAN_MUX_NUM);
;;;2869   		for (c = 0 ; c < width ; ++c)
;;;2870   		{
;;;2871   			HAL_WRITE_RAW_IMAGE(r, c, *((volatile unsigned short *)((thisFixedConf->ulFullSensing_Remap_Table[ulRealRowIdx][c] + uiBaseAddr))));
000004  9000              STR      r0,[sp,#0]
000006  482a              LDR      r0,|L28.176|
000008  492a              LDR      r1,|L28.180|
00000a  2200              MOVS     r2,#0                 ;2866
00000c  f8d06004          LDR.W    r6,[r0,#4]
                  |L28.16|
000010  f1020c0a          ADD      r12,r2,#0xa           ;2868
000014  ebc203c2          RSB      r3,r2,r2,LSL #3
000018  ebcc0ccc          RSB      r12,r12,r12,LSL #3
00001c  eb030343          ADD      r3,r3,r3,LSL #1
000020  eb0c044c          ADD      r4,r12,r12,LSL #1
000024  2000              MOVS     r0,#0                 ;2869
000026  eb0103c3          ADD      r3,r1,r3,LSL #3
00002a  eb0604c4          ADD      r4,r6,r4,LSL #3
00002e  bf00              NOP      
                  |L28.48|
000030  eb040c40          ADD      r12,r4,r0,LSL #1
000034  9f00              LDR      r7,[sp,#0]
000036  f8bc5000          LDRH     r5,[r12,#0]
00003a  5bed              LDRH     r5,[r5,r7]
00003c  f8235010          STRH     r5,[r3,r0,LSL #1]
000040  f8bcc002          LDRH     r12,[r12,#2]
000044  9d00              LDR      r5,[sp,#0]
000046  f83cc005          LDRH     r12,[r12,r5]
00004a  eb030540          ADD      r5,r3,r0,LSL #1
00004e  1c80              ADDS     r0,r0,#2
000050  f8a5c002          STRH     r12,[r5,#2]
000054  2854              CMP      r0,#0x54
000056  dbeb              BLT      |L28.48|
000058  1c52              ADDS     r2,r2,#1
00005a  2a30              CMP      r2,#0x30
00005c  dbd8              BLT      |L28.16|
;;;2872   		}
;;;2873   	}
;;;2874   
;;;2875   	for (r = 0 ; r < FINGER_ESD_SCAN_ROW_MAX_NUM ; ++r)
00005e  2300              MOVS     r3,#0
                  |L28.96|
000060  ebc302c3          RSB      r2,r3,r3,LSL #3       ;2871
000064  eb020242          ADD      r2,r2,r2,LSL #1       ;2871
;;;2876   	{
;;;2877   		for (c = 0 ; c < width ; ++c)
000068  2000              MOVS     r0,#0
;;;2878   		{
;;;2879   			HAL_WRITE_ESD_RAW_IMAGE(r, c, *((volatile unsigned short *)((thisFixedConf->ulFullSensing_Remap_Table[r][c] + uiBaseAddr))));
00006a  eb0605c2          ADD      r5,r6,r2,LSL #3
00006e  eb0104c2          ADD      r4,r1,r2,LSL #3       ;2871
000072  bf00              NOP      
                  |L28.116|
000074  eb050c40          ADD      r12,r5,r0,LSL #1
000078  9f00              LDR      r7,[sp,#0]
00007a  f8bc2000          LDRH     r2,[r12,#0]
00007e  5bd7              LDRH     r7,[r2,r7]
000080  eb040240          ADD      r2,r4,r0,LSL #1
000084  f5025280          ADD      r2,r2,#0x1000
000088  f8a27f80          STRH     r7,[r2,#0xf80]
00008c  f8bcc002          LDRH     r12,[r12,#2]
000090  9f00              LDR      r7,[sp,#0]
000092  f83cc007          LDRH     r12,[r12,r7]
000096  1c80              ADDS     r0,r0,#2
000098  f8a2cf82          STRH     r12,[r2,#0xf82]
00009c  2854              CMP      r0,#0x54
00009e  dbe9              BLT      |L28.116|
0000a0  1c5b              ADDS     r3,r3,#1
0000a2  2b0a              CMP      r3,#0xa
0000a4  dbdc              BLT      |L28.96|
;;;2880   		}
;;;2881   	}
;;;2882   
;;;2883   #else
;;;2884   	int c, r;
;;;2885   	int width = COL_MAX;
;;;2886   	int height = ROW_MAX;
;;;2887   	volatile unsigned long uiBaseAddr = BASE_RAW_SRAM;
;;;2888   
;;;2889   	for (r = 0 ; r < height ; ++r)
;;;2890   	{
;;;2891   		for (c = 0 ; c < width ; ++c)
;;;2892   		{
;;;2893   #if ((CUSTOMER == MODEL_DEF_FHD_PLUSE_92510_Dell_Wendy_Finger) || \
;;;2894   		(CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_Finger) || \
;;;2895   		(CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_FLIP_Finger) || \
;;;2896   		(CUSTOMER == MODEL_DEF_QHD_92512_Dell_WGP_PEN))
;;;2897   			HAL_WRITE_RAW_IMAGE(ulRealRowIdx[r], c, *((volatile unsigned short *)((thisFixedConf->ulFullSensing_Remap_Table[r][c] + uiBaseAddr))));
;;;2898   #else /* ((CUSTOMER == MODEL_DEF_FHD_PLUSE_92510_Dell_Wendy_Finger) || (CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_Finger) || (CUSTOMER == MODEL_DEF_QHD_92512_Dell_WGP_PEN)) */
;;;2899   			HAL_WRITE_RAW_IMAGE(r, c, *((volatile unsigned short *)((thisFixedConf->ulFullSensing_Remap_Table[r][c] + uiBaseAddr))));
;;;2900   #endif /* ((CUSTOMER == MODEL_DEF_FHD_PLUSE_92510_Dell_Wendy_Finger) || (CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_Finger) || (CUSTOMER == MODEL_DEF_QHD_92512_Dell_WGP_PEN)) */
;;;2901   		}
;;;2902   	}
;;;2903   #endif
;;;2904   }
0000a6  bcf8              POP      {r3-r7}
0000a8  4770              BX       lr
;;;2905   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L28.172|
                          DCD      0x20040000
                  |L28.176|
                          DCD      ||.data||
                  |L28.180|
                          DCD      FullSharedBuff

                          AREA ||i.module_start_delay||, CODE, READONLY, ALIGN=1

                  module_start_delay PROC
;;;1233   
;;;1234   void module_start_delay(void)
000000  b510              PUSH     {r4,lr}
;;;1235   {
;;;1236   #if USED_OPERATION_STAND_ALONE
;;;1237   	delay_msec(20);
;;;1238   #else /* USED_OPERATION_STAND_ALONE */
;;;1239   	GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
000002  2302              MOVS     r3,#2
000004  2201              MOVS     r2,#1
000006  2103              MOVS     r1,#3
000008  202d              MOVS     r0,#0x2d
00000a  f7fffffe          BL       GPIO_Init
;;;1240   	int i=0;
00000e  2400              MOVS     r4,#0
                  |L29.16|
;;;1241   #if ((USED_MODULE_DEF == MODULE_DEF_INX_1) && \
;;;1242   	(CUSTOMER == MODEL_DEF_FHD_92505_MS_FINGER_VBS))
;;;1243   	for(i=0; i<200; i++)
;;;1244   #else
;;;1245   	for(i=0; i<10; i++)
;;;1246   #endif
;;;1247   	{
;;;1248   		waitVsyncFalling();
000010  202d              MOVS     r0,#0x2d
000012  f7fffffe          BL       GPIO_Get_IN
000016  2800              CMP      r0,#0
000018  d0fa              BEQ      |L29.16|
                  |L29.26|
00001a  202d              MOVS     r0,#0x2d
00001c  f7fffffe          BL       GPIO_Get_IN
000020  2800              CMP      r0,#0
000022  d1fa              BNE      |L29.26|
000024  1c64              ADDS     r4,r4,#1
000026  2c0a              CMP      r4,#0xa               ;1245
000028  dbf2              BLT      |L29.16|
;;;1249   	}
;;;1250   #endif /* USED_OPERATION_STAND_ALONE */
;;;1251   }
00002a  bd10              POP      {r4,pc}
;;;1252   
                          ENDP


                          AREA ||i.module_wait_NI_sample_done||, CODE, READONLY, ALIGN=2

                  module_wait_NI_sample_done PROC
;;;1625   #if (USED_IDLE_MODE_CONTROL || USED_LOCAL_IDLE_MODE_CONTROL)
;;;1626   bool_t module_wait_NI_sample_done(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1627   {
;;;1628   #if USED_TP_LCD_ON_OPERATION
;;;1629   	bool_t sCheckVCC = YES;
;;;1630   #endif /* USED_TP_LCD_ON_OPERATION */
;;;1631   #if USED_TP_RST_OPERATION
;;;1632   	bool_t bCheckTPRST = YES;
;;;1633   #endif /* USED_TP_RST_OPERATION */
;;;1634   #if USED_TOUCH_SLEEP_CTRL_BY_HOST
;;;1635   	bool_t bCheckTOUCH_SLEEP = YES;
;;;1636   #endif /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;1637   	bool_t bLocalSample = YES;
000004  2501              MOVS     r5,#1
000006  2700              MOVS     r7,#0
000008  4c2b              LDR      r4,|L30.184|
00000a  e001              B        |L30.16|
                  |L30.12|
;;;1638   	eProtocolMode_t currMode = M_TOUCH_NORMAL;
;;;1639   //	bool_t bIsOneceWFIFlag = YES;
;;;1640   //	eSENSING_MODE_t eSensingMode;
;;;1641   //	eSensingMode = HAL_GetSensingMode();
;;;1642   
;;;1643   	while(YES)
;;;1644   	{
;;;1645   #if USED_TP_RSTnLCDON_DOUBLE_OPERATION
;;;1646   		if(sCheckVCC && bCheckTPRST)
;;;1647   		{
;;;1648   			if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
;;;1649   			{
;;;1650   				sCheckVCC = YES;
;;;1651   			}
;;;1652   			else
;;;1653   			{
;;;1654   				sCheckVCC = NO;
;;;1655   			}
;;;1656   
;;;1657   			if(IS_GPIO_PIN(_GPIO_TP_RST) == 0x1)
;;;1658   			{
;;;1659   				bCheckTPRST = YES;
;;;1660   			}
;;;1661   			else
;;;1662   			{
;;;1663   				bCheckTPRST = NO;
;;;1664   			}
;;;1665   		}
;;;1666   		else
;;;1667   		{
;;;1668   			if(sCheckVCC == NO)
;;;1669   			{
;;;1670   				Hal_VccOff_State();
;;;1671   			}
;;;1672   			else if(bCheckTPRST == NO)
;;;1673   			{
;;;1674   				Hal_TPRSTOff_State();
;;;1675   			}
;;;1676   			SensingBufferInit();
;;;1677   			bLocalSample = NO;
;;;1678   			break;
;;;1679   		}
;;;1680   
;;;1681   		if(hal_get_irq_flag(IRQ_ID_NI_SAMPLE))
;;;1682   		{
;;;1683   			hal_clear_irq_flag(IRQ_ID_NI_SAMPLE);
;;;1684   			if(sCheckVCC && bCheckTPRST)
;;;1685   			{
;;;1686   				module_read_NI_sample_data();
;;;1687   				break;
;;;1688   			}
;;;1689   		}
;;;1690   #else /* USED_TP_RSTnLCDON_DOUBLE_OPERATION */
;;;1691   	#if USED_TOUCH_SLEEP_CTRL_BY_HOST
;;;1692   		if(sCheckVCC && bCheckTOUCH_SLEEP)
;;;1693   		{
;;;1694   			if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
;;;1695   			{
;;;1696   				sCheckVCC = YES;
;;;1697   			}
;;;1698   			else
;;;1699   			{
;;;1700   				sCheckVCC = NO;
;;;1701   			}
;;;1702   
;;;1703   			if(IS_GPIO_PIN(_GPIO_SLEEP_EN) == 0x1)
;;;1704   			{
;;;1705   				bCheckTOUCH_SLEEP = YES;
;;;1706   			}
;;;1707   			else
;;;1708   			{
;;;1709   				bCheckTOUCH_SLEEP = NO;
;;;1710   			}
;;;1711   		}
;;;1712   		else
;;;1713   		{
;;;1714   			if(sCheckVCC == NO)
;;;1715   			{
;;;1716   				Hal_VccOff_State();
;;;1717   			}
;;;1718   			else if(bCheckTOUCH_SLEEP == NO)
;;;1719   			{
;;;1720   				Hal_TouchSleep_State();
;;;1721   			}
;;;1722   			SensingBufferInit();
;;;1723   			bLocalSample = NO;
;;;1724   			break;
;;;1725   		}
;;;1726   
;;;1727   		if(hal_get_irq_flag(IRQ_ID_NI_SAMPLE))
;;;1728   		{
;;;1729   			hal_clear_irq_flag(IRQ_ID_NI_SAMPLE);
;;;1730   			if(sCheckVCC && bCheckTOUCH_SLEEP)
;;;1731   			{
;;;1732   				module_read_NI_sample_data();
;;;1733   				break;
;;;1734   			}
;;;1735   		}
;;;1736   	#else /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;1737   		#if USED_TP_RST_OPERATION
;;;1738   		{
;;;1739   			if(bCheckTPRST)
;;;1740   			{
;;;1741   				if(IS_GPIO_PIN(_GPIO_TP_RST) == 0x1)
;;;1742   				{
;;;1743   					bCheckTPRST = YES;
;;;1744   				}
;;;1745   				else
;;;1746   				{
;;;1747   					bCheckTPRST = NO;
;;;1748   				}
;;;1749   			}
;;;1750   			else
;;;1751   			{
;;;1752   				Hal_TPRSTOff_State();
;;;1753   				SensingBufferInit();
;;;1754   				bLocalSample = NO;
;;;1755   				break;
;;;1756   			}
;;;1757   
;;;1758   			if(hal_get_irq_flag(IRQ_ID_NI_SAMPLE))
;;;1759   			{
;;;1760   				hal_clear_irq_flag(IRQ_ID_NI_SAMPLE);
;;;1761   				if(bCheckTPRST)
;;;1762   				{
;;;1763   					module_read_NI_sample_data();
;;;1764   					break;
;;;1765   				}
;;;1766   			}
;;;1767   		}
;;;1768   		#elif USED_TP_LCD_ON_OPERATION
;;;1769   		{
;;;1770   			if(sCheckVCC)
00000c  2e00              CMP      r6,#0
00000e  d036              BEQ      |L30.126|
                  |L30.16|
;;;1771   			{
;;;1772   				if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
000010  2035              MOVS     r0,#0x35
000012  f7fffffe          BL       GPIO_Get_IN
000016  2801              CMP      r0,#1
;;;1773   				{
;;;1774   					sCheckVCC = YES;
000018  bf0c              ITE      EQ
00001a  2601              MOVEQ    r6,#1
;;;1775   				}
;;;1776   				else
;;;1777   				{
;;;1778   					sCheckVCC = NO;
00001c  2600              MOVNE    r6,#0
00001e  78a0              LDRB     r0,[r4,#2]
;;;1779   				}
;;;1780   			}
;;;1781   			else
;;;1782   			{
;;;1783   				Hal_VccOff_State();
;;;1784   				SensingBufferInit();
;;;1785   				bLocalSample = NO;
;;;1786   				break;
;;;1787   			}
;;;1788   
;;;1789   			if(hal_get_irq_flag(IRQ_ID_NI_SAMPLE))
000020  2800              CMP      r0,#0
000022  bf1c              ITT      NE
000024  70a7              STRBNE   r7,[r4,#2]
;;;1790   			{
;;;1791   				hal_clear_irq_flag(IRQ_ID_NI_SAMPLE);
;;;1792   				if(sCheckVCC)
000026  2e00              CMPNE    r6,#0
000028  d031              BEQ      |L30.142|
00002a  4824              LDR      r0,|L30.188|
00002c  9000              STR      r0,[sp,#0]            ;1789
00002e  4824              LDR      r0,|L30.192|
000030  4e24              LDR      r6,|L30.196|
000032  f04f0c00          MOV      r12,#0                ;1789
000036  6840              LDR      r0,[r0,#4]            ;1789  ; thisFixedConf
                  |L30.56|
000038  ebcc02cc          RSB      r2,r12,r12,LSL #3     ;1789
00003c  eb020342          ADD      r3,r2,r2,LSL #1       ;1789
000040  f04f0100          MOV      r1,#0                 ;1789
000044  eb0602c3          ADD      r2,r6,r3,LSL #3       ;1789
000048  eb0004c3          ADD      r4,r0,r3,LSL #3       ;1789
                  |L30.76|
00004c  eb040341          ADD      r3,r4,r1,LSL #1       ;1789
000050  f8dd8000          LDR      r8,[sp,#0]            ;1789
000054  881f              LDRH     r7,[r3,#0]            ;1789
000056  f8377008          LDRH     r7,[r7,r8]            ;1789
00005a  f8227011          STRH     r7,[r2,r1,LSL #1]     ;1789
00005e  885b              LDRH     r3,[r3,#2]            ;1789
000060  9f00              LDR      r7,[sp,#0]            ;1789
000062  5bdb              LDRH     r3,[r3,r7]            ;1789
000064  eb020741          ADD      r7,r2,r1,LSL #1       ;1789
000068  f1010102          ADD      r1,r1,#2              ;1789
00006c  807b              STRH     r3,[r7,#2]            ;1789
00006e  2954              CMP      r1,#0x54              ;1789
000070  dbec              BLT      |L30.76|
000072  f10c0c01          ADD      r12,r12,#1            ;1789
000076  f1bc0f0a          CMP      r12,#0xa              ;1789
00007a  dbdd              BLT      |L30.56|
00007c  e004              B        |L30.136|
                  |L30.126|
00007e  f7fffffe          BL       Hal_VccOff_State
000082  f7fffffe          BL       SensingBufferInit
000086  2500              MOVS     r5,#0                 ;1785
                  |L30.136|
;;;1793   				{
;;;1794   					module_read_NI_sample_data();
;;;1795   					break;
;;;1796   				}
;;;1797   			}
;;;1798   		}
;;;1799   		#endif /* USED_TP_LCD_ON_OPERATION */
;;;1800   	#endif /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;1801   #endif /* USED_TP_RSTnLCDON_DOUBLE_OPERATION */
;;;1802   
;;;1803   		if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
;;;1804   		{
;;;1805   			hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;1806   		}
;;;1807   
;;;1808   		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
;;;1809   		{
;;;1810   			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;1811   		}
;;;1812   
;;;1813   #if USED_TOUCH_REPORT_ON_OFF_CONTROL
;;;1814   	#ifdef MODE_I2C
;;;1815   		if(HAL_GetTouchReportEnControl())
;;;1816   		{
;;;1817   			__WFI();
;;;1818   		}
;;;1819   	#endif
;;;1820   #endif /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
;;;1821   
;;;1822   		currMode = protocol_swip_GetMode();
;;;1823   		if(currMode == M_TOUCH_DFUP || currMode == M_WATCH_DOG_RESET)
;;;1824   		{
;;;1825   			break;
;;;1826   		}
;;;1827   	}
;;;1828   
;;;1829   	return bLocalSample;
000088  4628              MOV      r0,r5
;;;1830   }
00008a  e8bd83f8          POP      {r3-r9,pc}
                  |L30.142|
00008e  7860              LDRB     r0,[r4,#1]
000090  2800              CMP      r0,#0                 ;1803
000092  bf18              IT       NE                    ;1803
000094  7067              STRBNE   r7,[r4,#1]            ;1803
000096  7920              LDRB     r0,[r4,#4]            ;1803
000098  2800              CMP      r0,#0                 ;1808
00009a  bf18              IT       NE                    ;1808
00009c  7127              STRBNE   r7,[r4,#4]            ;1808
00009e  f7fffffe          BL       HAL_GetTouchReportEnControl
0000a2  2800              CMP      r0,#0                 ;1815
0000a4  bf18              IT       NE                    ;1817
0000a6  bf30              WFINE                          ;1817
0000a8  f7fffffe          BL       protocol_swip_GetMode
0000ac  2802              CMP      r0,#2                 ;1823
0000ae  bf18              IT       NE                    ;1823
0000b0  2811              CMPNE    r0,#0x11              ;1823
0000b2  d0e9              BEQ      |L30.136|
0000b4  e7aa              B        |L30.12|
;;;1831   #endif /* (USED_IDLE_MODE_CONTROL || USED_LOCAL_IDLE_MODE_CONTROL) */
                          ENDP

0000b6  0000              DCW      0x0000
                  |L30.184|
                          DCD      ||.bss||
                  |L30.188|
                          DCD      0x20040000
                  |L30.192|
                          DCD      ||.data||
                  |L30.196|
                          DCD      FullSharedBuff

                          AREA ||i.module_wait_Vsync_signal||, CODE, READONLY, ALIGN=2

                  module_wait_Vsync_signal PROC
;;;1252   
;;;1253   void module_wait_Vsync_signal(eSensingMode_t _mode, int _waitCnt)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1254   {
;;;1255       int gDiscardFrameCnt = 0;
000004  2600              MOVS     r6,#0
000006  4c61              LDR      r4,|L31.396|
000008  4688              MOV      r8,r1                 ;1254
00000a  4607              MOV      r7,r0                 ;1254
00000c  4635              MOV      r5,r6                 ;1254
                  |L31.14|
;;;1256       bool_t bIsWaitSkip = NO;
;;;1257   	while(1)
;;;1258   	{
;;;1259   		if(_mode == LOCAL_MODE)
00000e  2f01              CMP      r7,#1
000010  bf0c              ITE      EQ
000012  f8df917c          LDREQ    r9,|L31.400|
000016  f8dfa178          LDRNE    r10,|L31.400|
00001a  d128              BNE      |L31.110|
                  |L31.28|
00001c  2035              MOVS     r0,#0x35
00001e  f7fffffe          BL       GPIO_Get_IN
000022  2801              CMP      r0,#1
000024  bf18              IT       NE
000026  2000              MOVNE    r0,#0
000028  f8991004          LDRB     r1,[r9,#4]
00002c  2900              CMP      r1,#0
00002e  bf1c              ITT      NE
000030  f8895004          STRBNE   r5,[r9,#4]
000034  2800              CMPNE    r0,#0
000036  d007              BEQ      |L31.72|
000038  4956              LDR      r1,|L31.404|
00003a  7848              LDRB     r0,[r1,#1]  ; gLocalTypeFlag
00003c  704d              STRB     r5,[r1,#1]
;;;1260   		{
;;;1261   			ePartialSensing_t ePartialSensing;
;;;1262   			ePartialSensing = module_wait_local_sample_done();
;;;1263   			if(ePartialSensing == PARTIAL_MAX)
00003e  281a              CMP      r0,#0x1a
;;;1264   			{
;;;1265   				bIsWaitSkip = YES;
;;;1266   			}
;;;1267   		}
;;;1268   		else
;;;1269   		{
;;;1270   			if(!module_wait_full_sample_done())
;;;1271   			{
;;;1272   				bIsWaitSkip = YES;
;;;1273   			}
;;;1274   		}
;;;1275   
;;;1276   		if(bIsWaitSkip)
;;;1277   		{
;;;1278   			break;
;;;1279   		}
;;;1280   		else if(tHalIntrHandle.ulVSyncFlag)
;;;1281   		{
;;;1282   			tHalIntrHandle.ulVSyncFlag = 0;
;;;1283   
;;;1284   			if(gDiscardFrameCnt == _waitCnt)
;;;1285   			{
;;;1286   				gDiscardFrameCnt = 0;
;;;1287   				break;
;;;1288   			}
;;;1289   			else
;;;1290   			{
;;;1291   				gDiscardFrameCnt++;
;;;1292   			}
;;;1293   		}
;;;1294   	}
;;;1295   }
000040  bf08              IT       EQ
000042  e8bd8ff8          POPEQ    {r3-r11,pc}
000046  e093              B        |L31.368|
                  |L31.72|
000048  f8991001          LDRB     r1,[r9,#1]
00004c  2900              CMP      r1,#0
00004e  bf18              IT       NE
000050  f8895001          STRBNE   r5,[r9,#1]
000054  f8991002          LDRB     r1,[r9,#2]
000058  2900              CMP      r1,#0
00005a  bf18              IT       NE
00005c  f8895002          STRBNE   r5,[r9,#2]
000060  2800              CMP      r0,#0
000062  d1db              BNE      |L31.28|
000064  e06b              B        |L31.318|
000066  bf00              NOP      
                  |L31.104|
000068  f1b90f00          CMP      r9,#0
00006c  d067              BEQ      |L31.318|
                  |L31.110|
00006e  2035              MOVS     r0,#0x35
000070  f7fffffe          BL       GPIO_Get_IN
000074  2801              CMP      r0,#1
000076  bf0c              ITE      EQ
000078  f04f0901          MOVEQ    r9,#1
00007c  f04f0900          MOVNE    r9,#0
000080  f89a0001          LDRB     r0,[r10,#1]
000084  2800              CMP      r0,#0
000086  bf1c              ITT      NE
000088  f88a5001          STRBNE   r5,[r10,#1]
00008c  f1b90f00          CMPNE    r9,#0
000090  d05b              BEQ      |L31.330|
000092  4841              LDR      r0,|L31.408|
000094  9000              STR      r0,[sp,#0]
000096  483f              LDR      r0,|L31.404|
000098  f04f0300          MOV      r3,#0
00009c  f8d0a004          LDR      r10,[r0,#4]  ; thisFixedConf
                  |L31.160|
0000a0  ebc301c3          RSB      r1,r3,r3,LSL #3
0000a4  f103000a          ADD      r0,r3,#0xa
0000a8  eb010141          ADD      r1,r1,r1,LSL #1
0000ac  eb040cc1          ADD      r12,r4,r1,LSL #3
0000b0  ebc000c0          RSB      r0,r0,r0,LSL #3
0000b4  eb000140          ADD      r1,r0,r0,LSL #1
0000b8  f04f0200          MOV      r2,#0
0000bc  eb0a01c1          ADD      r1,r10,r1,LSL #3
                  |L31.192|
0000c0  eb010042          ADD      r0,r1,r2,LSL #1
0000c4  f8ddb000          LDR      r11,[sp,#0]
0000c8  f8b09000          LDRH     r9,[r0,#0]
0000cc  f839900b          LDRH     r9,[r9,r11]
0000d0  f82c9012          STRH     r9,[r12,r2,LSL #1]
0000d4  8840              LDRH     r0,[r0,#2]
0000d6  f8dd9000          LDR      r9,[sp,#0]
0000da  f8300009          LDRH     r0,[r0,r9]
0000de  eb0c0942          ADD      r9,r12,r2,LSL #1
0000e2  f1020202          ADD      r2,r2,#2
0000e6  f8a90002          STRH     r0,[r9,#2]
0000ea  2a54              CMP      r2,#0x54
0000ec  dbe8              BLT      |L31.192|
0000ee  1c5b              ADDS     r3,r3,#1
0000f0  2b30              CMP      r3,#0x30
0000f2  dbd5              BLT      |L31.160|
0000f4  2200              MOVS     r2,#0
                  |L31.246|
0000f6  ebc201c2          RSB      r1,r2,r2,LSL #3
0000fa  eb010141          ADD      r1,r1,r1,LSL #1
0000fe  2000              MOVS     r0,#0
000100  eb0a09c1          ADD      r9,r10,r1,LSL #3
000104  eb040cc1          ADD      r12,r4,r1,LSL #3
                  |L31.264|
000108  eb090340          ADD      r3,r9,r0,LSL #1
00010c  f8ddb000          LDR      r11,[sp,#0]
000110  8819              LDRH     r1,[r3,#0]
000112  f831b00b          LDRH     r11,[r1,r11]
000116  eb0c0140          ADD      r1,r12,r0,LSL #1
00011a  f5015180          ADD      r1,r1,#0x1000
00011e  f8a1bf80          STRH     r11,[r1,#0xf80]
000122  885b              LDRH     r3,[r3,#2]
000124  f8ddb000          LDR      r11,[sp,#0]
000128  f833300b          LDRH     r3,[r3,r11]
00012c  1c80              ADDS     r0,r0,#2
00012e  f8a13f82          STRH     r3,[r1,#0xf82]
000132  2854              CMP      r0,#0x54
000134  dbe8              BLT      |L31.264|
000136  1c52              ADDS     r2,r2,#1
000138  2a0a              CMP      r2,#0xa
00013a  dbdc              BLT      |L31.246|
00013c  e018              B        |L31.368|
                  |L31.318|
00013e  f7fffffe          BL       Hal_VccOff_State
000142  e8bd4ff8          POP      {r3-r11,lr}
000146  f7ffbffe          B.W      SensingBufferInit
                  |L31.330|
00014a  f89a0002          LDRB     r0,[r10,#2]
00014e  2800              CMP      r0,#0
000150  bf18              IT       NE
000152  f88a5002          STRBNE   r5,[r10,#2]
000156  f89a0004          LDRB     r0,[r10,#4]
00015a  2800              CMP      r0,#0
00015c  bf18              IT       NE
00015e  f88a5004          STRBNE   r5,[r10,#4]
000162  f7fffffe          BL       protocol_swip_GetMode
000166  2802              CMP      r0,#2
000168  bf18              IT       NE
00016a  2811              CMPNE    r0,#0x11
00016c  f47faf7c          BNE      |L31.104|
                  |L31.368|
000170  480a              LDR      r0,|L31.412|
000172  6981              LDR      r1,[r0,#0x18]         ;1280  ; tHalIntrHandle
000174  2900              CMP      r1,#0                 ;1280
000176  f43faf4a          BEQ      |L31.14|
00017a  6185              STR      r5,[r0,#0x18]         ;1282  ; tHalIntrHandle
00017c  4546              CMP      r6,r8                 ;1284
00017e  bf18              IT       NE                    ;1284
000180  1c76              ADDNE    r6,r6,#1              ;1284
000182  f47faf44          BNE      |L31.14|
000186  e8bd8ff8          POP      {r3-r11,pc}
;;;1296   
                          ENDP

00018a  0000              DCW      0x0000
                  |L31.396|
                          DCD      FullSharedBuff
                  |L31.400|
                          DCD      ||.bss||
                  |L31.404|
                          DCD      ||.data||
                  |L31.408|
                          DCD      0x20040000
                  |L31.412|
                          DCD      tHalIntrHandle

                          AREA ||i.module_wait_full_sample_done||, CODE, READONLY, ALIGN=2

                  module_wait_full_sample_done PROC
;;;1376   
;;;1377   bool_t module_wait_full_sample_done(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1378   {
;;;1379   #if USED_TP_LCD_ON_OPERATION
;;;1380   	bool_t sCheckVCC = YES;
;;;1381   #endif /* USED_TP_LCD_ON_OPERATION */
;;;1382   #if USED_TP_RST_OPERATION
;;;1383   	bool_t bCheckTPRST = YES;
;;;1384   #endif /* USED_TP_RST_OPERATION */
;;;1385   #if USED_TOUCH_SLEEP_CTRL_BY_HOST
;;;1386   	bool_t bCheckTOUCH_SLEEP = YES;
;;;1387   #endif /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;1388   	bool_t bLocalSample = YES;
000004  2501              MOVS     r5,#1
000006  2700              MOVS     r7,#0
000008  4c3c              LDR      r4,|L32.252|
00000a  e001              B        |L32.16|
                  |L32.12|
;;;1389   //	bool_t bIsOneceWFIFlag = YES;
;;;1390   	eProtocolMode_t currMode = M_TOUCH_NORMAL;
;;;1391   
;;;1392   	while(YES)
;;;1393   	{
;;;1394   #if USED_MNT_S3_MODE_FUNCTION
;;;1395   		if(sCheckVCC)
;;;1396   		{
;;;1397   			if(IS_GPIO_PIN(_GPIO_S3_POWER_IN) == 0x1)
;;;1398   			{
;;;1399   				sCheckVCC = YES;
;;;1400   			}
;;;1401   			else
;;;1402   			{
;;;1403   				sCheckVCC = NO;
;;;1404   			}
;;;1405   		}
;;;1406   		else
;;;1407   		{
;;;1408   //			Hal_VccOff_State();
;;;1409   //			SensingBufferInit();
;;;1410   			bLocalSample = NO;
;;;1411   			break;
;;;1412   		}
;;;1413   
;;;1414   		if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
;;;1415   		{
;;;1416   			hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;1417   			if(sCheckVCC == YES)
;;;1418   			{
;;;1419   				module_read_full_sample_data();
;;;1420   				break;
;;;1421   			}
;;;1422   		}
;;;1423   
;;;1424   		if(hal_get_irq_flag(IRQ_ID_NI_SAMPLE))
;;;1425   		{
;;;1426   			hal_clear_irq_flag(IRQ_ID_NI_SAMPLE);
;;;1427   		}
;;;1428   
;;;1429   		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
;;;1430   		{
;;;1431   			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;1432   		}
;;;1433   
;;;1434   		if(hal_get_irq_flag(IRQ_ID_S3_SAMPLE))
;;;1435   		{
;;;1436   			hal_clear_irq_flag(IRQ_ID_S3_SAMPLE);
;;;1437   		}
;;;1438   #else /* USED_MNT_S3_MODE_FUNCTION */
;;;1439   	#if USED_TP_RSTnLCDON_DOUBLE_OPERATION
;;;1440   		if(sCheckVCC && bCheckTPRST)
;;;1441   		{
;;;1442   			if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
;;;1443   			{
;;;1444   				sCheckVCC = YES;
;;;1445   			}
;;;1446   			else
;;;1447   			{
;;;1448   				sCheckVCC = NO;
;;;1449   			}
;;;1450   
;;;1451   			if(IS_GPIO_PIN(_GPIO_TP_RST) == 0x1)
;;;1452   			{
;;;1453   				bCheckTPRST = YES;
;;;1454   			}
;;;1455   			else
;;;1456   			{
;;;1457   				bCheckTPRST = NO;
;;;1458   			}
;;;1459   		}
;;;1460   		else
;;;1461   		{
;;;1462   			if(sCheckVCC == NO)
;;;1463   			{
;;;1464   				Hal_VccOff_State();
;;;1465   			}
;;;1466   			else if(bCheckTPRST == NO)
;;;1467   			{
;;;1468   				Hal_TPRSTOff_State();
;;;1469   			}
;;;1470   			SensingBufferInit();
;;;1471   			bLocalSample = NO;
;;;1472   			break;
;;;1473   		}
;;;1474   
;;;1475   		if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
;;;1476   		{
;;;1477   			hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;1478   			if(sCheckVCC && bCheckTPRST)
;;;1479   			{
;;;1480   				module_read_full_sample_data();
;;;1481   				break;
;;;1482   			}
;;;1483   		}
;;;1484   	#else /* USED_TP_RSTnLCDON_DOUBLE_OPERATION */
;;;1485   		#if USED_TOUCH_SLEEP_CTRL_BY_HOST
;;;1486   		{
;;;1487   			if(sCheckVCC && bCheckTOUCH_SLEEP)
;;;1488   			{
;;;1489   				if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
;;;1490   				{
;;;1491   					sCheckVCC = YES;
;;;1492   				}
;;;1493   				else
;;;1494   				{
;;;1495   					sCheckVCC = NO;
;;;1496   				}
;;;1497   
;;;1498   				if(IS_GPIO_PIN(_GPIO_SLEEP_EN) == 0x1)
;;;1499   				{
;;;1500   					bCheckTOUCH_SLEEP = YES;
;;;1501   				}
;;;1502   				else
;;;1503   				{
;;;1504   					bCheckTOUCH_SLEEP = NO;
;;;1505   				}
;;;1506   			}
;;;1507   			else
;;;1508   			{
;;;1509   				if(sCheckVCC == NO)
;;;1510   				{
;;;1511   					Hal_VccOff_State();
;;;1512   				}
;;;1513   				else if(bCheckTOUCH_SLEEP == NO)
;;;1514   				{
;;;1515   					Hal_TouchSleep_State();
;;;1516   				}
;;;1517   				SensingBufferInit();
;;;1518   				bLocalSample = NO;
;;;1519   				break;
;;;1520   			}
;;;1521   
;;;1522   			if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
;;;1523   			{
;;;1524   				hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;1525   				if(sCheckVCC && bCheckTOUCH_SLEEP)
;;;1526   				{
;;;1527   					module_read_full_sample_data();
;;;1528   					break;
;;;1529   				}
;;;1530   			}
;;;1531   		}
;;;1532   		#else /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;1533   		{
;;;1534   			#if USED_TP_RST_OPERATION
;;;1535   			if(bCheckTPRST)
;;;1536   			{
;;;1537   				if(IS_GPIO_PIN(_GPIO_TP_RST) == 0x1)
;;;1538   				{
;;;1539   					bCheckTPRST = YES;
;;;1540   				}
;;;1541   				else
;;;1542   				{
;;;1543   					bCheckTPRST = NO;
;;;1544   				}
;;;1545   			}
;;;1546   			else
;;;1547   			{
;;;1548   				Hal_TPRSTOff_State();
;;;1549   				SensingBufferInit();
;;;1550   				bLocalSample = NO;
;;;1551   				break;
;;;1552   			}
;;;1553   
;;;1554   			if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
;;;1555   			{
;;;1556   				hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;1557   				if(bCheckTPRST)
;;;1558   				{
;;;1559   					module_read_full_sample_data();
;;;1560   					break;
;;;1561   				}
;;;1562   			}
;;;1563   
;;;1564   			#elif USED_TP_LCD_ON_OPERATION
;;;1565   			if(sCheckVCC)
00000c  2e00              CMP      r6,#0
00000e  d05e              BEQ      |L32.206|
                  |L32.16|
;;;1566   			{
;;;1567   				if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
000010  2035              MOVS     r0,#0x35
000012  f7fffffe          BL       GPIO_Get_IN
000016  2801              CMP      r0,#1
;;;1568   				{
;;;1569   					sCheckVCC = YES;
000018  bf0c              ITE      EQ
00001a  2601              MOVEQ    r6,#1
;;;1570   				}
;;;1571   				else
;;;1572   				{
;;;1573   					sCheckVCC = NO;
00001c  2600              MOVNE    r6,#0
00001e  7860              LDRB     r0,[r4,#1]
;;;1574   				}
;;;1575   			}
;;;1576   			else
;;;1577   			{
;;;1578   				Hal_VccOff_State();
;;;1579   				SensingBufferInit();
;;;1580   				bLocalSample = NO;
;;;1581   				break;
;;;1582   			}
;;;1583   
;;;1584   			if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
000020  2800              CMP      r0,#0
000022  bf1c              ITT      NE
000024  7067              STRBNE   r7,[r4,#1]
;;;1585   			{
;;;1586   				hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;1587   				if(sCheckVCC)
000026  2e00              CMPNE    r6,#0
000028  d057              BEQ      |L32.218|
00002a  4835              LDR      r0,|L32.256|
00002c  9000              STR      r0,[sp,#0]            ;1584
00002e  4835              LDR      r0,|L32.260|
000030  4a35              LDR      r2,|L32.264|
000032  f04f0300          MOV      r3,#0                 ;1584
000036  6847              LDR      r7,[r0,#4]            ;1584  ; thisFixedConf
                  |L32.56|
000038  f103000a          ADD      r0,r3,#0xa            ;1584
00003c  ebc30cc3          RSB      r12,r3,r3,LSL #3      ;1584
000040  ebc000c0          RSB      r0,r0,r0,LSL #3       ;1584
000044  eb0c0c4c          ADD      r12,r12,r12,LSL #1    ;1584
000048  eb000440          ADD      r4,r0,r0,LSL #1       ;1584
00004c  f04f0100          MOV      r1,#0                 ;1584
000050  eb020ccc          ADD      r12,r2,r12,LSL #3     ;1584
000054  eb0700c4          ADD      r0,r7,r4,LSL #3       ;1584
                  |L32.88|
000058  eb000441          ADD      r4,r0,r1,LSL #1       ;1584
00005c  f8dd8000          LDR      r8,[sp,#0]            ;1584
000060  8826              LDRH     r6,[r4,#0]            ;1584
000062  f8366008          LDRH     r6,[r6,r8]            ;1584
000066  f82c6011          STRH     r6,[r12,r1,LSL #1]    ;1584
00006a  8864              LDRH     r4,[r4,#2]            ;1584
00006c  9e00              LDR      r6,[sp,#0]            ;1584
00006e  5ba4              LDRH     r4,[r4,r6]            ;1584
000070  eb0c0641          ADD      r6,r12,r1,LSL #1      ;1584
000074  f1010102          ADD      r1,r1,#2              ;1584
000078  8074              STRH     r4,[r6,#2]            ;1584
00007a  2954              CMP      r1,#0x54              ;1584
00007c  dbec              BLT      |L32.88|
00007e  1c5b              ADDS     r3,r3,#1              ;1584
000080  2b30              CMP      r3,#0x30              ;1584
000082  dbd9              BLT      |L32.56|
000084  2300              MOVS     r3,#0                 ;1584
                  |L32.134|
000086  ebc300c3          RSB      r0,r3,r3,LSL #3       ;1584
00008a  eb000040          ADD      r0,r0,r0,LSL #1       ;1584
00008e  eb070cc0          ADD      r12,r7,r0,LSL #3      ;1584
000092  2100              MOVS     r1,#0                 ;1584
000094  eb0200c0          ADD      r0,r2,r0,LSL #3       ;1584
                  |L32.152|
000098  eb0c0641          ADD      r6,r12,r1,LSL #1      ;1584
00009c  f8dd8000          LDR      r8,[sp,#0]            ;1584
0000a0  8834              LDRH     r4,[r6,#0]            ;1584
0000a2  f8348008          LDRH     r8,[r4,r8]            ;1584
0000a6  eb000441          ADD      r4,r0,r1,LSL #1       ;1584
0000aa  f5045480          ADD      r4,r4,#0x1000         ;1584
0000ae  f8a48f80          STRH     r8,[r4,#0xf80]        ;1584
0000b2  8876              LDRH     r6,[r6,#2]            ;1584
0000b4  f8dd8000          LDR      r8,[sp,#0]            ;1584
0000b8  f8366008          LDRH     r6,[r6,r8]            ;1584
0000bc  1c89              ADDS     r1,r1,#2              ;1584
0000be  f8a46f82          STRH     r6,[r4,#0xf82]        ;1584
0000c2  2954              CMP      r1,#0x54              ;1584
0000c4  dbe8              BLT      |L32.152|
0000c6  1c5b              ADDS     r3,r3,#1              ;1584
0000c8  2b0a              CMP      r3,#0xa               ;1584
0000ca  dbdc              BLT      |L32.134|
0000cc  e013              B        |L32.246|
                  |L32.206|
0000ce  f7fffffe          BL       Hal_VccOff_State
0000d2  f7fffffe          BL       SensingBufferInit
0000d6  2500              MOVS     r5,#0                 ;1580
0000d8  e00d              B        |L32.246|
                  |L32.218|
0000da  78a0              LDRB     r0,[r4,#2]            ;1581
;;;1588   				{
;;;1589   					module_read_full_sample_data();
;;;1590   					break;
;;;1591   				}
;;;1592   			}
;;;1593   			#endif /* USED_TP_LCD_ON_OPERATION */
;;;1594   		}
;;;1595   		#endif /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
;;;1596   	#endif /* USED_TP_RSTnLCDON_DOUBLE_OPERATION */
;;;1597   
;;;1598   		if(hal_get_irq_flag(IRQ_ID_NI_SAMPLE))
0000dc  2800              CMP      r0,#0
0000de  bf18              IT       NE
0000e0  70a7              STRBNE   r7,[r4,#2]
0000e2  7920              LDRB     r0,[r4,#4]
;;;1599   		{
;;;1600   			hal_clear_irq_flag(IRQ_ID_NI_SAMPLE);
;;;1601   		}
;;;1602   
;;;1603   		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
0000e4  2800              CMP      r0,#0
0000e6  bf18              IT       NE
0000e8  7127              STRBNE   r7,[r4,#4]
;;;1604   		{
;;;1605   			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;1606   		}
;;;1607   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1608   
;;;1609   		currMode = protocol_swip_GetMode();
0000ea  f7fffffe          BL       protocol_swip_GetMode
;;;1610   		if(currMode == M_TOUCH_DFUP || currMode == M_WATCH_DOG_RESET)
0000ee  2802              CMP      r0,#2
0000f0  bf18              IT       NE
0000f2  2811              CMPNE    r0,#0x11
0000f4  d18a              BNE      |L32.12|
                  |L32.246|
;;;1611   		{
;;;1612   			break;
;;;1613   		}
;;;1614   
;;;1615   //		if(bIsOneceWFIFlag)
;;;1616   //		{
;;;1617   //			__WFI();
;;;1618   //		}
;;;1619   //		bIsOneceWFIFlag = NO;
;;;1620   	}
;;;1621   
;;;1622   	return bLocalSample;
0000f6  4628              MOV      r0,r5
;;;1623   }
0000f8  e8bd83f8          POP      {r3-r9,pc}
;;;1624   
                          ENDP

                  |L32.252|
                          DCD      ||.bss||
                  |L32.256|
                          DCD      0x20040000
                  |L32.260|
                          DCD      ||.data||
                  |L32.264|
                          DCD      FullSharedBuff

                          AREA ||i.module_wait_local_sample_done||, CODE, READONLY, ALIGN=2

                  module_wait_local_sample_done PROC
;;;1897   
;;;1898   ePartialSensing_t module_wait_local_sample_done(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4c12              LDR      r4,|L33.76|
;;;1899   {
000004  2500              MOVS     r5,#0
                  |L33.6|
;;;1900   #if USED_TP_LCD_ON_OPERATION
;;;1901   	bool_t sCheckVCC = YES;
;;;1902   #endif /* USED_TP_LCD_ON_OPERATION */
;;;1903   #if USED_TP_RST_OPERATION
;;;1904   	bool_t bCheckTPRST = YES;
;;;1905   #endif /* USED_TP_RST_OPERATION */
;;;1906   	ePartialSensing_t RetVal = PARTIAL_PEN_BEACON;
;;;1907   //	bool_t bIsOneceWFIFlag = YES;
;;;1908   
;;;1909   	while(YES)
;;;1910   	{
;;;1911   #if USED_TP_RSTnLCDON_DOUBLE_OPERATION
;;;1912   		if(sCheckVCC && bCheckTPRST)
;;;1913   		{
;;;1914   			if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
;;;1915   			{
;;;1916   				sCheckVCC = YES;
;;;1917   			}
;;;1918   			else
;;;1919   			{
;;;1920   				sCheckVCC = NO;
;;;1921   			}
;;;1922   
;;;1923   			if(IS_GPIO_PIN(_GPIO_TP_RST) == 0x1)
;;;1924   			{
;;;1925   				bCheckTPRST = YES;
;;;1926   			}
;;;1927   			else
;;;1928   			{
;;;1929   				bCheckTPRST = NO;
;;;1930   			}
;;;1931   		}
;;;1932   		else
;;;1933   		{
;;;1934   			if(sCheckVCC == NO)
;;;1935   			{
;;;1936   				Hal_VccOff_State();
;;;1937   			}
;;;1938   			else if(bCheckTPRST == NO)
;;;1939   			{
;;;1940   				Hal_TPRSTOff_State();
;;;1941   			}
;;;1942   			SensingBufferInit();
;;;1943   			RetVal = PARTIAL_MAX;
;;;1944   			break;
;;;1945   		}
;;;1946   
;;;1947   		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
;;;1948   		{
;;;1949   			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;1950   			if(sCheckVCC && bCheckTPRST)
;;;1951   			{
;;;1952   				RetVal = hal_get_LocalType_flag();
;;;1953   				hal_clear_LocalType_flag();
;;;1954   				break;
;;;1955   			}
;;;1956   		}
;;;1957   #else /* USED_TP_RSTnLCDON_DOUBLE_OPERATION */
;;;1958   	#if USED_TP_RST_OPERATION
;;;1959   		if(bCheckTPRST)
;;;1960   		{
;;;1961   			if(IS_GPIO_PIN(_GPIO_TP_RST) == 0x1)
;;;1962   			{
;;;1963   				bCheckTPRST = YES;
;;;1964   			}
;;;1965   			else
;;;1966   			{
;;;1967   				bCheckTPRST = NO;
;;;1968   			}
;;;1969   		}
;;;1970   		else
;;;1971   		{
;;;1972   			Hal_TPRSTOff_State();
;;;1973   			SensingBufferInit();
;;;1974   			RetVal = PARTIAL_MAX;
;;;1975   			break;
;;;1976   		}
;;;1977   
;;;1978   		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
;;;1979   		{
;;;1980   			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;1981   			if(bCheckTPRST)
;;;1982   			{
;;;1983   				RetVal = hal_get_LocalType_flag();
;;;1984   				hal_clear_LocalType_flag();
;;;1985   				break;
;;;1986   			}
;;;1987   		}
;;;1988   	#elif USED_TP_LCD_ON_OPERATION
;;;1989   		if(sCheckVCC)
;;;1990   		{
;;;1991   			if(IS_GPIO_PIN(_GPIO_LCD_ON) == 0x1)
000006  2035              MOVS     r0,#0x35
000008  f7fffffe          BL       GPIO_Get_IN
00000c  2801              CMP      r0,#1
;;;1992   			{
;;;1993   				sCheckVCC = YES;
;;;1994   			}
;;;1995   			else
;;;1996   			{
;;;1997   				sCheckVCC = NO;
00000e  bf18              IT       NE
000010  2000              MOVNE    r0,#0
000012  7921              LDRB     r1,[r4,#4]
;;;1998   			}
;;;1999   		}
;;;2000   		else
;;;2001   		{
;;;2002   			Hal_VccOff_State();
;;;2003   			SensingBufferInit();
;;;2004   			RetVal = PARTIAL_MAX;
;;;2005   			break;
;;;2006   		}
;;;2007   
;;;2008   		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
000014  2900              CMP      r1,#0
000016  bf1c              ITT      NE
000018  7125              STRBNE   r5,[r4,#4]
;;;2009   		{
;;;2010   			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;2011   			if(sCheckVCC)
00001a  2800              CMPNE    r0,#0
00001c  d00a              BEQ      |L33.52|
00001e  490c              LDR      r1,|L33.80|
000020  7848              LDRB     r0,[r1,#1]            ;2008  ; gLocalTypeFlag
000022  704d              STRB     r5,[r1,#1]            ;2008
;;;2012   			{
;;;2013   				RetVal = hal_get_LocalType_flag();
;;;2014   				hal_clear_LocalType_flag();
;;;2015   				break;
;;;2016   			}
;;;2017   		}
;;;2018   	#endif /* USED_TP_LCD_ON_OPERATION */
;;;2019   #endif /* USED_TP_RSTnLCDON_DOUBLE_OPERATION */
;;;2020   
;;;2021   		if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
;;;2022   		{
;;;2023   			hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;2024   		}
;;;2025   
;;;2026   		if(hal_get_irq_flag(IRQ_ID_NI_SAMPLE))
;;;2027   		{
;;;2028   			hal_clear_irq_flag(IRQ_ID_NI_SAMPLE);
;;;2029   		}
;;;2030   //		if(bIsOneceWFIFlag)
;;;2031   //		{
;;;2032   //			__WFI();
;;;2033   //		}
;;;2034   //		bIsOneceWFIFlag = NO;
;;;2035   	}
;;;2036   
;;;2037   	return RetVal;
;;;2038   }
000024  bd70              POP      {r4-r6,pc}
000026  bf00              NOP                            ;2002
                  |L33.40|
000028  f7fffffe          BL       Hal_VccOff_State
00002c  f7fffffe          BL       SensingBufferInit
000030  201a              MOVS     r0,#0x1a              ;2004
000032  bd70              POP      {r4-r6,pc}
                  |L33.52|
000034  7861              LDRB     r1,[r4,#1]
000036  2900              CMP      r1,#0                 ;2021
000038  bf18              IT       NE                    ;2021
00003a  7065              STRBNE   r5,[r4,#1]            ;2021
00003c  78a1              LDRB     r1,[r4,#2]            ;2021
00003e  2900              CMP      r1,#0                 ;2026
000040  bf18              IT       NE                    ;2026
000042  70a5              STRBNE   r5,[r4,#2]            ;2026
000044  2800              CMP      r0,#0                 ;2021
000046  d1de              BNE      |L33.6|
000048  e7ee              B        |L33.40|
;;;2039   
                          ENDP

00004a  0000              DCW      0x0000
                  |L33.76|
                          DCD      ||.bss||
                  |L33.80|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  gbIrqFlag
                          %        10

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  0a000000          DCB      0x0a,0x00,0x00,0x00
                          DCD      0x00000003
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      0x00000003
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      0x00000003
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x00000003
00002c  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  gucOverlapFPend
000000  00                DCB      0x00
                  gLocalTypeFlag
000001  000000            DCB      0x00,0x00,0x00
                  thisFixedConf
                          DCD      0x00000000
                  thisCommonConf
                          DCD      0x00000000
                  ptAppInfo
                          DCD      0x00000000
                  _GPIO
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Module\\module.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_module_c_d5c75903____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___8_module_c_d5c75903____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_module_c_d5c75903____REVSH|
#line 402
|__asm___8_module_c_d5c75903____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_module_c_d5c75903____RRX|
#line 587
|__asm___8_module_c_d5c75903____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
