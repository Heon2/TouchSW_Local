L 1 "..\..\App\Algorithm\Coord\algorithm_coord.c"
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  algorithm_coord.c
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#include "core_def.h"
L 1 "..\..\App\core_def.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : core_def.h
N * created on : 14. 5. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _CORE_DEF_H_
N#define _CORE_DEF_H_
N
N
N#include "hal_def.h"
L 1 "..\..\Hal\hal_def.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : hal_def.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _HAL_DEF_H_
N#define _HAL_DEF_H_
N
N
N#include "env_def.h"
L 1 "..\..\Env\env_def.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_def.h
N * created on : 14. 5. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_DEF_H_
N#define _ENV_DEF_H_
N
N
N#include "MFTP.h"
L 1 "..\..\Hal\system\MFTP.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : MFTP.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N/** @addtogroup MFTP
N  * @{
N  */
N
N#ifndef _MFTP_H_
N#define _MFTP_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M3 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
N                                                         and No Match                                                          */
N  BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
N                                                         related Fault                                                         */
N  UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N//  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* -----------------------  MFTP Specific Interrupt Numbers  ----------------------- */
N  WDGT_IRQn						=   0,              /*!<   X  WatchDog Timer                                                   */
N  TIMER_IRQn					=   1,              /*!<   X  TIMER                                                            */
N  DBG_I2C_IRQn					=   2,              /*!<   X  Debug I2C Slave                                         		   */
N  FLITF_IRQn					=   3,              /*!<   X  Flash                                                            */
N  DBG_SPI_IRQn					=   4,              /*!<   X  Debug SPI Slave                                                  */
N  AB_ACC_IRQn					=   5,              /*!<   X  Abnormal Access Detection                                        */
N  GDMA_IRQn						=   6,              /*!<   X  GDMA Done                                                        */
N  USER_IRQn						=   7,              /*!<   X  User Interrupt                                                   */
N  GPIOA_IRQn					=   8,              /*!<   X  GPIO A                                                           */
N  GPIOM_IRQn					=   9,              /*!<   X  GPIO M                                                           */
N  VSYNC_IN_IRQn					=  10,              /*!<   X  VSync In                                                         */
N  TSYNC_IN_IRQn					=  11,              /*!<   X  TSync In                                                         */
N  TSYNC_OUT_IRQn				=  12,              /*!<   X  TSync Out                                                        */
N  PWMDRV_IRQn					=  13,              /*!<   X  PWM                                                              */
N  DSP_A_IRQn					=  14,              /*!<   X  DSP A                                                            */
N  DSP_B_IRQn					=  15,              /*!<   X  DSP B                                                            */
N  USB_IRQn						=  16,              /*!<   X  USB                                                              */
N// Reserved						=  17,
N// Reserved						=  18,
N  EXTInterface_IRQn				=  19,          	/*!<   X  MPI / T-LVDS / MSPI											   */
N// Reserved						=  20,
N// Reserved						=  21,
N  I2C_MST_IRQn               	=  22,     			/*!< I2CM0 Interrupt         					                           */
N  I2C_MST_SLEEP_IRQn         	=  23,     			/*!< I2CM0 Sleep Interrupt                                                 */
N  I2C_MST_WAKEUP_IRQn        	=  24,     			/*!< I2CM0 Wakeup Interrupt                                                */
N  I2C_SLV_IRQn               	=  25,     			/*!< I2CM1 Interrupt                                                       */
N  I2C_SLV_SLEEP_IRQn         	=  26,     			/*!< I2CM1 Sleep Interrupt                                                 */
N  I2C_SLV_WAKEUP_IRQn        	=  27,     			/*!< I2CM1 Wakeup Interrupt                                                */
N
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the Cortex-M3 Processor and Core Peripherals---------------- */
N#define __CM3_REV                 0x0201            /*!< Cortex-M3 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               3            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include <core_cm3.h>                               /*!< Cortex-M3 processor and core peripherals                              */
L 1 "..\..\Hal\system\CMSIS\core_cm3.h" 1
N/****************************************************************************
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   0xffffffffU
N#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM3_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x03U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __attribute__ ((packed))
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\..\Hal\system\CMSIS\core_cmInstr.h" 1
N/****************************************************************************
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\Hal\system\CMSIS\cmsis_armcc.h" 1
N/****************************************************************************
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x03U) == 0x04U) || ((0x03U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x03U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\..\Hal\system\CMSIS\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\..\Hal\system\CMSIS\core_cmFunc.h" 1
N/****************************************************************************
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201U)                   /* core r2p1 */
X#if (0x0201 < 0x0201U)                    
S#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
S#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
S
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200U))
X#if ((1L) && (0x0201 >= 0x200U))
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N#else
S        uint32_t RESERVED1[1U];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N#if 0
S/**
S  \brief   System Tick Configuration
S  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
S           Counter is in free running mode to generate periodic interrupts.
S  \param [in]  ticks  Number of ticks between two interrupts.
S  \return          0  Function succeeded.
S  \return          1  Function failed.
S  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S           must contain a vendor-specific implementation of this function.
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
S  {
S    return (1UL);                                                   /* Reload value impossible */
S  }
S
S  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
S  return (0UL);                                                     /* Function successful */
S}
N#endif
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 111 "..\..\Hal\system\MFTP.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#define __BITBAND					__attribute__ ((bitband))
N#define __PACKED                    __attribute__ ((packed))
N#define __ALIGNED4                  __attribute__ ((aligned(4)))
N#define __INTERRUPT                 __attribute__ ((interrupt))
N#define __WEAK                      __attribute__ ((weak))
N#elif defined ( __ICCARM__ )
S#define __NOP           __no_operation                              /*!< no operation intrinsic in IAR Compiler */
S
S#elif defined ( __GNUC__ )
S#define __BITBAND					__attribute__ ((bitband))
S#define __PACKED                    __attribute__ ((packed))
S#define __ALIGNED4                  __attribute__ ((aligned(4)))
S#define __INTERRUPT                 __attribute__ ((interrupt))
S#define __WEAK                      __attribute__ ((weak))
N#endif
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N/*
NCode Memory
NFLASH: 128kB
N0x00000000~0x0001FFFF
N
NCode Memory
NSRAM: 64kB
N0x10000000~0x1000FFFF
N
NSystem Memory
NSRAM: 64kB
N0x20000000~0x2000FFFF
N
NSystem Memory
NSRAM: 32kB
N0x20010000~0x20017FFF
N
NSystem Memory
NSRAM: 32kB
N0x20018000~0x2001FFFF
N
NMSPI Memory
NSRAM: 64kB
N0x20020000~0x2002FFFF
N*/
N#define USED_MSPI_MODIFY				(0)
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N#define BASE_INFO                       0x00020000UL
N
N#define BASE_SRAM1                      0x20000000UL
N#define BASE_SRAM2                      0x20010000UL
N#define BASE_SRAM3                      0x20020000UL
N#define BASE_SRAM_END					0x2002D000UL
N#define BASE_RAW_SRAM					0x20040000UL
N#define BASE_USB_SRAM					0x20100000UL
N
N#define BASE_SCRB                       0x40000000UL
N#define BASE_GPIO                       0x40000100UL
N#define BASE_WDT                       	0x4000017CUL
N#define BASE_TIMER                      0x4000019CUL
N#define BASE_DBGSERIAL                  0x40000200UL
N#define BASE_GDMA	                    0x40000300UL //LFSR + GDMA + CRC
N#define BASE_DSPB						0x40001000UL
N#define BASE_PWMDRV                     0x40002000UL
N#define BASE_DSPA                       0x40003000UL
N#define BASE_MSPI                       0x40004000UL
N#define BASE_TLVDS						0x40006000UL
N#define BASE_I2C_1                      0x40007000UL
N#define BASE_I2C_2                      0x40007080UL
N#define BASE_FLASH						0x40008000UL	// Flash
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N#define INFO                            ((INFO_TypeDef        *) BASE_INFO  )
N#define SCRB                            ((tSCRB_CtrlReg_t     *) BASE_SCRB  )
N#define GPIO                            ((tGPIO_CtrlReg_t     *) BASE_GPIO)
N#define WDT                            	((tWDT_CtrlReg_t      *) BASE_WDT  )
N#define TIMER                           ((tTIMER_CtrlReg_t    *) BASE_TIMER )
N#define DBGSERIAL                       ((tDBGSERIAL_CtrlReg_t*) BASE_DBGSERIAL )
N#define GDMA                            ((tGDMA_CtrlReg_t     *) BASE_GDMA  )
N#define DSP_CON	                        ((tDSPB_CtrlReg_t     *) BASE_DSPB  )
N#define PWMDRV                          ((tPWMDRV_CtrlReg_t   *) BASE_PWMDRV)
N#define DSPA                            ((tDSPA_CtrlReg_t     *) BASE_DSPA  )
N#define MSPI                            ((tMSPI_CtrlReg_t     *) BASE_MSPI  )
N#define TLVDS                           ((tTLVDS_CtrlReg_t    *) BASE_TLVDS )
N#define I2C_1                           ((tI2C_CtrlReg_t      *) BASE_I2C_1   )
N#define I2C_2                           ((tI2C_CtrlReg_t      *) BASE_I2C_2   )
N#define FLASH							((tFLASH_CtrlReg_t    *) BASE_FLASH   )
N
N
N
N/* -------------------  Include System Peripheral CMSIS Definition ------------------ */
N#include "_scrb.h"
L 1 "..\..\Hal\scrb\_scrb.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _scrb.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __SCRB_H_
N#define __SCRB_H_
N
N
Ntypedef union
N{
N	struct {
N		unsigned	wdtclk_en:					1;
N		unsigned	timclk0_en:					1;
N		unsigned	timclk1_en:					1;
N		unsigned	timclk2_en:					1;
N		unsigned	timclk3_en:					1;
N		unsigned	i2cclk_en:					1;
N		unsigned	dspaclk_en:					1;
N		unsigned	tdspclk_en:					1;
N		unsigned	usbcclk_en:					1;
N		unsigned	usbhclk_en:					1;
N		unsigned	pwmclk_en:					1;
N		unsigned	mspiclk_en:					1;
N		unsigned	sscgclk_en:					1;
N		unsigned	mpiclk_en:					1;
N		unsigned	tlvclk_en:					1;
N		unsigned	i2cm0clk_en:				1;
N		unsigned	i2cm0clk_slp_en:			1;
N		unsigned	i2cm1clk_en:				1;
N		unsigned	i2cm1clk_slp_en:			1;
N		unsigned	osc_deglitch_en:			1;
N		unsigned	reserved:					12;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_CLK_CTL;
N
Ntypedef union
N{
N	struct {
N		unsigned	sys_rst:					1;
N		unsigned	cm3_rst:					1;
N		unsigned	serial_rst:					1;
N		unsigned	dspa_rst:					1;
N		unsigned	tdsp_rst:					1;
N		unsigned	usb_rst:					1;
N		unsigned	pwm_rst:					1;
N		unsigned	mspi_rst:					1;
N		unsigned	sscg_rst:					1;
N		unsigned	mpi_rst:					1;
N		unsigned	tlv_rst:					1;
N		unsigned	i2cm_rst:					1;
N		unsigned	reserved:					20;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_RST_CTL;
N
Ntypedef union
N{
N	struct {
N		unsigned	stack_over_int_clr:			1;
N		unsigned	abnormal_addr_int_clr:		1;
N		unsigned	reserved:					30;
N	} tBit;
N	__O uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_INT_CTRL;
N
Ntypedef union
N{
N	struct {
N		unsigned	int_watchdog:				1;
N		unsigned	int_timer0:					1;
N		unsigned	int_timer1:					1;
N		unsigned	int_timer2:					1;
N		unsigned	int_timer3:					1;
N		unsigned	int_i2c_slave:				1;
N		unsigned	int_i2c_report_done:		1;
N		unsigned	int_serial_error:			1;
N		unsigned	int_i2c_mst:				1;
N		unsigned	int_spi_slave:				1;
N		unsigned	int_spi_report_done:		1;
N		unsigned	int_stack_over:				1;
N		unsigned	int_abnormal_addr:			1;
N		unsigned	int_gdma:					1;
N		unsigned	crc_error_int:				1;
N		unsigned	int_user:					1;
N		unsigned	int_gpioa:					1;
N		unsigned	int_gpiom:					1;
N		unsigned	int_vsyncin:				1;
N		unsigned	int_tsyncin:				1;
N		unsigned	int_tsyncout:				1;
N		unsigned	r_pwm_frame_intr:			1;
N		unsigned	r_pwm_ab_intr:				1;
N		unsigned	int_tsync_ab:				1;
N		unsigned	int_dspa:					1;
N		unsigned	int_tdsp:					1;
N		unsigned	int_usb:					1;
N		unsigned	int_usb_lpmen:				1;
N		unsigned	int_usb_susm :				1;
N		unsigned	int_mspi:					1;
N		unsigned	int_tlvds:					1;
N		unsigned	int_mpi:					1;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tSYS_INT_ST;
N
Ntypedef union
N{
N	struct {
N		unsigned	sysrst_req:					1;
N		unsigned	serial_sw_resetn_req:		1;
N		unsigned	reserved:					30;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tSYS_RSTINFO;
N
Ntypedef union
N{
N	struct {
N		unsigned	watchdog:					1;
N		unsigned	abnormal_spck:				1;
N		unsigned	reserved:					30;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tSYS_ERROR_ST;
N
Ntypedef union
N{
N	struct {
N		unsigned	R_OSC12M_PD_N:				1;
N		unsigned	R_MAIN_BIAS_PD_N:			1;
N		unsigned	R_BOD_PD_N:					1;
N		unsigned	reserved:					29;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_OSC_PD_CTL;
N
Ntypedef union
N{
N	struct {
N		unsigned	R_OSC12M_VTRIM:				6;
N		unsigned	R_OSC12M_ITRIM:				3;
N		unsigned	R_LDO_TRIM:					5;
N		unsigned	R_LDO_LL_CTL:				1;
N		unsigned	R_LDO_RZ_SEL:				1;
N		unsigned	R_MAIN_VBGR_CTL:			3;
N		unsigned	R_MAIN_IREF_TRIM:			5;
N		unsigned	R_MAIN_VREF_TRIM:			4;
N		unsigned	reserved:					4;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_ANA_TRIM;
N
Ntypedef union
N{
N	struct {
N		unsigned	R_MAIN_LDOIN_CTL:			2;
N		unsigned	R_MAIN_TLVDS_CTL:			2;
N		unsigned	R_BOD_DLY_CTL:				2;
N		unsigned	R_BOD_VHLS:					2;
N		unsigned	R_BOD_VLHS:					2;
N		unsigned	reserved:					22;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_ANA_CTRL;
N
Ntypedef union
N{
N	struct {
N		unsigned	R_MAIN_VBGR_OBV:			1;
N		unsigned	R_MAIN_VREF1P2V_OBV:		1;
N		unsigned	R_MAIN_IREF_OBV:			1;
N		unsigned	R_OSC12M_LDO_OBV:			1;
N		unsigned	R_FLASH_OBV:				1;
N		unsigned	reserved:					27;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_OSC_TEST;
N
Ntypedef union
N{
N	struct {
N		unsigned	R_DSSC_EN:					1;
N		unsigned	R_DSSC_PDB:					1;
N		unsigned	reserved:					30;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSSCG_PD_CTL;
N
Ntypedef union
N{
N	struct {
N		unsigned	R_DSSC_FRAC_EN:				1;
N		unsigned	R_DSSC_ICP:					2;
N		unsigned	R_DSSC_RSEL:				2;
N		unsigned	R_DSSC_KVC:					1;
N		unsigned	R_DSSC_KVC2:				1;
N		unsigned	R_DSSC_DIG_RSTN:			1;
N		unsigned	R_DSSC_SEL_NRST:			1;
N		unsigned	R_DSSC_INIT:				1;
N		unsigned	R_DSSC_MF:					2;
N		unsigned	R_DSSC_MR:					3;
N		unsigned	R_DSSC_DIG_TST:				1;
N		unsigned	modu_cnt_en:				1;
N		unsigned	reserved:					15;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSSCG_OP_CTRL;
N
Ntypedef union
N{
N	struct {
N		unsigned	sscg_ldo_test:				1;
N		unsigned	sscg_vcont_test:			1;
N		unsigned	reserved:					30;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSSCG_TEST_CTL;		//	ToDo: Delete
N
Ntypedef union
N{
N	struct {
N		unsigned	TLVDS_TPWM0_INV:			1;
N		unsigned	TLVDS_TPWM1_INV:			1;
N		unsigned	TLVDS_TECLK0_INV:			1;
N		unsigned	TLVDS_TECLK1_INV:			1;
N		unsigned	R_TLVDS_ITX_CTL:			3;
N		unsigned	R_TLVDS_IRX_CTL:			3;
N		unsigned	R_reserved:					4;
N		unsigned	reserved:					18;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_TLVDS_CTRL;
N
Ntypedef union
N{
N	struct {
N		unsigned	R_TLVDS_BIAS_PD_N:			1;
N		unsigned	A_TLVDS_PDB_TPWM0:			1;
N		unsigned	A_TLVDS_PDB_TECLK0:			1;
N		unsigned	A_TLVDS_PDB_TPWM1:			1;
N		unsigned	A_TLVDS_PDB_TECLK1:			1;
N		unsigned	A_TLVDS_DRV_TPWM0:			1;
N		unsigned	A_TLVDS_DRV_TECLK0:			1;
N		unsigned	A_TLVDS_DRV_TPWM1:			1;
N		unsigned	A_TLVDS_DRV_TECLK1:			1;
N		unsigned	reserved:					23;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_TLVDS_PD_N;
N
Ntypedef union
N{
N	struct {
N		unsigned	mainclksel:					1;
N		unsigned	hsclksel:					1;
N		unsigned	pllclkdiv:					4;
N		unsigned	usbclkdiv:					4;
N		unsigned	mclkdiv:					6;
N		unsigned	mclksel:					1;
N		unsigned	reserved:					15;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_MAINCLK_CFG;
N
Ntypedef union
N{
N	struct {
N		unsigned	pwmclksel:					1;
N		unsigned	pwmclkdiv:					3;
N		unsigned	pllclkdiv:					4;
N		unsigned	usbclkdiv:					4;
N		unsigned	pwmclkdiv_en:				1;
N		unsigned	pwmclkdiv_num:				3;
N		unsigned	pwmclk_phase_en:			1;
N		unsigned	reserved:					15;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSYS_PWMCLK_CFG;
N
Ntypedef union
N{
N	struct {
N		unsigned	sscgin_sel:					1;
N		unsigned	sscgin_inv:					1;
N		unsigned	sscgplldiv:					3;
N		unsigned	sscgusbdiv:					4;
N		unsigned	sscgclk_sel:				1;
N		unsigned	reserved:					22;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSSCG_IN_CFG;
N
Ntypedef union
N{
N	struct {
N		unsigned	tlvclkpre_sel:				1;
N		unsigned	tlvplldiv:					3;
N		unsigned	tlvusbdiv:					3;
N		unsigned	reserved:					12;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tTLVDSCLK_CFG;
N
Ntypedef union
N{
N	struct {
N		unsigned	dspa_lp_en:					1;
N		unsigned	tdsp_lp_en:					1;
N		unsigned	mspi_lp_en:					1;
N		unsigned	reserved:					29;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCLK_LP_MODE;
N
Ntypedef union
N{
N	struct {
N		unsigned	serial_slv_div:				4;
N		unsigned	i2cm0_div:					4;
N		unsigned	i2cm1_div:					4;
N		unsigned	reserved:					20;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSERIAL_CLK_DIV;
N
Ntypedef union
N{
N	struct {
N		unsigned	refdiv:						3;
N		unsigned	fbdiv:						6;
N		unsigned	outdiv:						2;
N		unsigned	icpsela:					1;
N		unsigned	icpselb:					1;
N		unsigned	pll_stby_i:					1;
N		unsigned	rsel:						3;
N		unsigned	vcosetupsel:				1;
N		unsigned	pllin_sel:					1;
N		unsigned	reserved:					13;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tPLL_CFG;
N
Ntypedef union
N{
N	struct {
N		unsigned	a_modu_clk:					1;
N		unsigned	reserved:					31;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tSSCG_STATUS;
N
Ntypedef union
N{
N	struct {
N		unsigned	modu_low_cnt:				14;
N		unsigned	reserved0:					2;
N		unsigned	modu_high_cnt:				14;
N		unsigned	reserved1:					2;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tSSCG_MODU_CNT;
N
Ntypedef union
N{
N	struct {
N		unsigned	int_en_pwm_ab:				1;
N		unsigned	int_en_pwm_frame:			1;
N		unsigned	int_en_tsync_ab:			1;
N		unsigned	int_en_tsyncin:				2;
N		unsigned	int_en_vsyncin:				2;
N		unsigned	int_en_tsyncout:			2;
N		unsigned	int_tsyncin_src_sel:		1;
N		unsigned	int_en_lhb:					1;
N		unsigned	reserved:					21;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tPWM_INT_CTRL;
N
Ntypedef union
N{
N	struct {
N		unsigned	pwm_ab_int_clr:				1;
N		unsigned	pwm_frame_int_clr:			1;
N		unsigned	tsync_ab_int_clr:			1;
N		unsigned	vsyncin_int_clr:			1;
N		unsigned	tsyncin_int_clr:			1;
N		unsigned	tsyncout_int_clr:			1;
N		unsigned	lhb_int_clr:				1;
N		unsigned	reserved:					25;
N	} tBit;
N	__O uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tPWM_INT_CLR;
N
Ntypedef union
N{
N	struct {
N		unsigned	CACHE_EN:					1;
N		unsigned	CACHE_FLUSH:				1;
N		unsigned	CACHE_BST:					2;
N		unsigned	CACHE_DEN:					1;
N		unsigned	dly_num:					4;
N		unsigned	reserved:					23;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCACHE_CTRL;
N
Ntypedef union
N{
N	struct {
N		unsigned	int_lhb:					1;
N		unsigned	int_fll_done:				1;
N		unsigned	reserved:					30;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tSYS_INT_ST2;
N
Ntypedef union
N{
N	struct {
N		unsigned	usbphyclk_sel:				1;
N		unsigned	reserved:					31;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_CFG;
N
Ntypedef union
N{
N	struct {
N		unsigned	vbusvalid:					1;
N		unsigned	wakeup:						1;
N		unsigned	l1_wakeup:					1;
N		unsigned	sel_wakeup:					1;
N		unsigned	sel_l1_wakeup:				1;
N		unsigned	reserved:					27;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_CTRL_UC;
N
Ntypedef union
N{
N	struct {
N		unsigned	extctrl_suspendm:			1;
N		unsigned	oscouten:					1;
N		unsigned	xtlsel:						1;
N		unsigned	pllaliv:					1;
N		unsigned	ponrst:						1;
N		unsigned	outclksel:					1;
N		unsigned	ta:							1;
N		unsigned	tb:							1;
N		unsigned	tc:							1;
N		unsigned	hstx_sw:					2;
N		unsigned	reserved:					21;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_PHY_FC;
N
Ntypedef union
N{
N	struct {
N		unsigned	susm_intr_en:				1;
N		unsigned	susm_intr_pos:				1;
N		unsigned	susm_intr_neg:				1;
N		unsigned	lpm_intr_en:				1;
N		unsigned	lpm_intr_pos:				1;
N		unsigned	lpm_intr_neg:				1;
N		unsigned	ip_intr_en:					1;
N		unsigned	ip_intr_inv:				1;
N		unsigned	reserved:					24;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_INTR_CTL;
N
Ntypedef union
N{
N	struct {
N		unsigned	susm_intr_clr:				1;
N		unsigned	lpm_intr_clr:				1;
N		unsigned	ip_intr_clr:				1;
N		unsigned	reserved:					29;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_INTR_CLR;
N
Ntypedef union
N{
N	struct {
N		unsigned	boot_crc_check_ok:			1;
N		unsigned	boot_ecc_flag:				1;
N		unsigned	boot_ecc_unknown_err:		1;
N		unsigned	boot_crc_check_busy:		1;
N		unsigned	boot_ecc_cnt:				14;
N		unsigned	reserved:					14;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tBOOT_ST;
N
Ntypedef union
N{
N	struct {
N		unsigned	fll_en:						1;
N		unsigned	clk_en_fll:					1;
N		unsigned	resetn_fll:					1;
N		unsigned	int_en_fll:					1;
N		unsigned	reserved:					28;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tFLL_CTRL;
N
Ntypedef union
N{
N	struct {
N		unsigned	fll_result:					14;
N		unsigned	fll_done:					1;
N		unsigned	reserved:					17;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tFLL_ST;
N
Ntypedef struct{																		// Index
N	__I  uint32_t							SYS_CHIP_ID;							// 0x0000
X	volatile const  uint32_t							SYS_CHIP_ID;							
N	__I  uint32_t                       	SYS_CHIP_VERSION;						// 0x0001
X	volatile const  uint32_t                       	SYS_CHIP_VERSION;						
N	__IO tSYS_CLK_CTL						SYS_CLK_CTL;                            // 0x0002
X	volatile tSYS_CLK_CTL						SYS_CLK_CTL;                            
N	__IO tSYS_RST_CTL                      SYS_RST_CTL;                            // 0x0003
X	volatile tSYS_RST_CTL                      SYS_RST_CTL;                            
N	__IO uint32_t                       	SYS_BOOT_CTL;                           // 0x0004
X	volatile uint32_t                       	SYS_BOOT_CTL;                           
N	__O  tSYS_INT_CTRL                     SYS_INT_CTRL;                           // 0x0005
X	volatile  tSYS_INT_CTRL                     SYS_INT_CTRL;                           
N	__I  tSYS_INT_ST                       SYS_INT_ST;                             // 0x0006
X	volatile const  tSYS_INT_ST                       SYS_INT_ST;                             
N	__IO uint32_t                       	SYS_USERINT_CTRL;                       // 0x0007
X	volatile uint32_t                       	SYS_USERINT_CTRL;                       
N	__I  tSYS_RSTINFO                      SYS_RSTINFO;                            // 0x0008
X	volatile const  tSYS_RSTINFO                      SYS_RSTINFO;                            
N	__I  tSYS_ERROR_ST                     SYS_ERROR_ST;                           // 0x0009
X	volatile const  tSYS_ERROR_ST                     SYS_ERROR_ST;                           
N	__IO tSYS_OSC_PD_CTL                   SYS_OSC_PD_CTL;                         // 0x000A
X	volatile tSYS_OSC_PD_CTL                   SYS_OSC_PD_CTL;                         
N	__IO tSYS_ANA_TRIM                     SYS_ANA_TRIM;                           // 0x000B
X	volatile tSYS_ANA_TRIM                     SYS_ANA_TRIM;                           
N	__IO tSYS_ANA_CTRL                     SYS_ANA_CTRL;                           // 0x000C
X	volatile tSYS_ANA_CTRL                     SYS_ANA_CTRL;                           
N	__IO tSYS_OSC_TEST                     SYS_OSC_TEST;                           // 0x000D
X	volatile tSYS_OSC_TEST                     SYS_OSC_TEST;                           
N	__IO uint32_t                      		SYS_STACK_OVER_ADDR;                    // 0x000E
X	volatile uint32_t                      		SYS_STACK_OVER_ADDR;                    
N	__IO uint32_t                       	SYS_DEBUG_RW_EN;                        // 0x000F
X	volatile uint32_t                       	SYS_DEBUG_RW_EN;                        
N	__IO uint32_t                       	SYS_ABNORMAL_ADDR;                      // 0x0010
X	volatile uint32_t                       	SYS_ABNORMAL_ADDR;                      
N	__IO uint32_t                   		SYS_ABNORMAL_ADDR_M;                    // 0x0011
X	volatile uint32_t                   		SYS_ABNORMAL_ADDR_M;                    
N	__IO uint32_t                       	SYS_DELAY_TICK;                         // 0x0012
X	volatile uint32_t                       	SYS_DELAY_TICK;                         
N	__IO tSSCG_PD_CTL                      SSCG_PD_CTL;                            // 0x0013
X	volatile tSSCG_PD_CTL                      SSCG_PD_CTL;                            
N	__IO tSSCG_OP_CTRL                     SSCG_OP_CTRL;                           // 0x0014
X	volatile tSSCG_OP_CTRL                     SSCG_OP_CTRL;                           
N	__IO tSSCG_TEST_CTL                    SSCG_TEST_CTL;                          // 0x0015
X	volatile tSSCG_TEST_CTL                    SSCG_TEST_CTL;                          
N	__IO tSYS_TLVDS_CTRL                   SYS_TLVDS_CTRL;                         // 0x0016
X	volatile tSYS_TLVDS_CTRL                   SYS_TLVDS_CTRL;                         
N	__IO tSYS_TLVDS_PD_N                   SYS_TLVDS_PD_N;                         // 0x0017
X	volatile tSYS_TLVDS_PD_N                   SYS_TLVDS_PD_N;                         
N	__IO tSYS_MAINCLK_CFG                  SYS_MAINCLK_CFG;                        // 0x0018
X	volatile tSYS_MAINCLK_CFG                  SYS_MAINCLK_CFG;                        
N	__IO tSYS_PWMCLK_CFG                   SYS_PWMCLK_CFG;                         // 0x0019
X	volatile tSYS_PWMCLK_CFG                   SYS_PWMCLK_CFG;                         
N	__IO tSSCG_IN_CFG                      SSCG_IN_CFG;                            // 0x001A
X	volatile tSSCG_IN_CFG                      SSCG_IN_CFG;                            
N	__IO tTLVDSCLK_CFG                     TLVDSCLK_CFG;                           // 0x001B
X	volatile tTLVDSCLK_CFG                     TLVDSCLK_CFG;                           
N	__IO tCLK_LP_MODE                      CLK_LP_MODE;                            // 0x001C
X	volatile tCLK_LP_MODE                      CLK_LP_MODE;                            
N	__IO tSERIAL_CLK_DIV                   SERIAL_CLK_DIV;                         // 0x001D
X	volatile tSERIAL_CLK_DIV                   SERIAL_CLK_DIV;                         
N	__IO tPLL_CFG                          PLL_CFG;                                // 0x001E
X	volatile tPLL_CFG                          PLL_CFG;                                
N	__I  uint32_t                         	PLL_LOCK;                               // 0x001F
X	volatile const  uint32_t                         	PLL_LOCK;                               
N	__I  tSSCG_STATUS                      SSCG_STATUS;                            // 0x0020
X	volatile const  tSSCG_STATUS                      SSCG_STATUS;                            
N	__I  tSSCG_MODU_CNT                    SSCG_MODU_CNT;                          // 0x0021
X	volatile const  tSSCG_MODU_CNT                    SSCG_MODU_CNT;                          
N	__IO tPWM_INT_CTRL                     PWM_INT_CTRL;                           // 0x0022
X	volatile tPWM_INT_CTRL                     PWM_INT_CTRL;                           
N	__O  tPWM_INT_CLR                      PWM_INT_CLR;                            // 0x0023
X	volatile  tPWM_INT_CLR                      PWM_INT_CLR;                            
N	__IO tCACHE_CTRL                       CACHE_CTRL;                             // 0x0024
X	volatile tCACHE_CTRL                       CACHE_CTRL;                             
N	__I  uint32_t                         	CACHE_ST;                               // 0x0025
X	volatile const  uint32_t                         	CACHE_ST;                               
N	__I  tSYS_INT_ST2                      SYS_INT_ST2;                            // 0x0026
X	volatile const  tSYS_INT_ST2                      SYS_INT_ST2;                            
N	__IO uint32_t                       	SYSTEM_RESERVED10;                      // 0x0027
X	volatile uint32_t                       	SYSTEM_RESERVED10;                      
N	__IO tUSB_CFG                          USB_CFG;                                // 0x0028
X	volatile tUSB_CFG                          USB_CFG;                                
N	__IO tUSB_CTRL_UC                      USB_CTRL_UC;                            // 0x0029
X	volatile tUSB_CTRL_UC                      USB_CTRL_UC;                            
N	__IO tUSB_PHY_FC                       USB_PHY_FC;                             // 0x002A
X	volatile tUSB_PHY_FC                       USB_PHY_FC;                             
N	__IO tUSB_INTR_CTL                     USB_INTR_CTL;                           // 0x002B
X	volatile tUSB_INTR_CTL                     USB_INTR_CTL;                           
N	__IO tUSB_INTR_CLR                     USB_INTR_CLR;                           // 0x002C
X	volatile tUSB_INTR_CLR                     USB_INTR_CLR;                           
N	__IO uint32_t                       	SYS_BUS_REMAP;                          // 0x002D
X	volatile uint32_t                       	SYS_BUS_REMAP;                          
N	__I  uint32_t                       	BUS_REMAP_ST;                           // 0x002E
X	volatile const  uint32_t                       	BUS_REMAP_ST;                           
N	__O  uint32_t                       	CM3_REMAP_RESET;                        // 0x002F
X	volatile  uint32_t                       	CM3_REMAP_RESET;                        
N	__I  tBOOT_ST                          BOOT_ST;                                // 0x0030
X	volatile const  tBOOT_ST                          BOOT_ST;                                
N	__IO uint32_t                       	BOOT_CRC_RESULT;                        // 0x0031
X	volatile uint32_t                       	BOOT_CRC_RESULT;                        
N	__IO tFLL_CTRL                         FLL_CTRL;                               // 0x0032
X	volatile tFLL_CTRL                         FLL_CTRL;                               
N	__I  tFLL_ST                           FLL_ST;                                 // 0x0033
X	volatile const  tFLL_ST                           FLL_ST;                                 
N	__O  uint32_t                       	FLL_INT_CLR;                            // 0x0034
X	volatile  uint32_t                       	FLL_INT_CLR;                            
N	__IO uint32_t                       	SYSTEM_RESERVED16;                      // 0x0035
X	volatile uint32_t                       	SYSTEM_RESERVED16;                      
N	__IO uint32_t                        	SYSTEM_RESERVED17;                      // 0x0036
X	volatile uint32_t                        	SYSTEM_RESERVED17;                      
N	__IO uint32_t                        	SYSTEM_RESERVED18;                      // 0x0037
X	volatile uint32_t                        	SYSTEM_RESERVED18;                      
N	__IO uint32_t                        	SYSTEM_RESERVED19;                      // 0x0038
X	volatile uint32_t                        	SYSTEM_RESERVED19;                      
N	__IO uint32_t                        	SYSTEM_RESERVED20;                      // 0x0039
X	volatile uint32_t                        	SYSTEM_RESERVED20;                      
N	__IO uint32_t                        	SYSTEM_RESERVED21;                      // 0x003A
X	volatile uint32_t                        	SYSTEM_RESERVED21;                      
N	__IO uint32_t                        	SYSTEM_RESERVED22;                      // 0x003B
X	volatile uint32_t                        	SYSTEM_RESERVED22;                      
N	__IO uint32_t                        	SYSTEM_RESERVED23;                      // 0x003C
X	volatile uint32_t                        	SYSTEM_RESERVED23;                      
N	__IO uint32_t                        	SYSTEM_RESERVED24;                      // 0x003D
X	volatile uint32_t                        	SYSTEM_RESERVED24;                      
N	__IO uint32_t                           SYS_DUMMY0;                             // 0x003E
X	volatile uint32_t                           SYS_DUMMY0;                             
N	__IO uint32_t                           SYS_DUMMY1;                             // 0x003F
X	volatile uint32_t                           SYS_DUMMY1;                             
N} tSCRB_CtrlReg_t;
N
N
Ntypedef struct
N{
N
N  union {
N    __I  uint32_t  CALIB_OSC  ;
X    volatile const  uint32_t  CALIB_OSC  ;
N
N    struct {
N      __I  uint32_t  R_FINE   :  4;
X      volatile const  uint32_t  R_FINE   :  4;
N      __I  uint32_t  R_COARSE :  4;
X      volatile const  uint32_t  R_COARSE :  4;
N    } CALIB_OSC_b;
N  } ;
N
N
N  union {
N    __I  uint32_t  CALIB_LDO ;
X    volatile const  uint32_t  CALIB_LDO ;
N
N    struct {
N      __I  uint32_t  CAL_SEL :  4;
X      volatile const  uint32_t  CAL_SEL :  4;
N    } CALIB_LDO_b;
N  } ;
N
N
N} INFO_TypeDef;
N
N
N#endif /* __SCRB_H_ */
L 246 "..\..\Hal\system\MFTP.h" 2
N#include "_gpio.h"
L 1 "..\..\Hal\gpio\_gpio.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _gpio.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __GPIO_H_
N#define __GPIO_H_
N
N
N/* ================================================================================ */
N/* ================               GPIO Control Registers           ================ */
N/* ================================================================================ */
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:               1;
N        unsigned    GPIOM01:               1;
N        unsigned    GPIOM02:               1;
N        unsigned    GPIOM03:               1;
N        unsigned    GPIOM04:               1;
N        unsigned    GPIOM05:               1;
N        unsigned    GPIOM06:               1;
N        unsigned    GPIOM07:               1;
N        unsigned    GPIOM08:               1;
N        unsigned    GPIOM09:               1;		//	ToDo: Added by register map
N        unsigned    GPIOM10:               1;		//	ToDo: Added by register map
N        unsigned    reserved:              21;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_IN;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:               1;
N        unsigned    GPIOM01:               1;
N        unsigned    GPIOM02:               1;
N        unsigned    GPIOM03:               1;
N        unsigned    GPIOM04:               1;
N        unsigned    GPIOM05:               1;
N        unsigned    GPIOM06:               1;
N        unsigned    GPIOM07:               1;
N        unsigned    GPIOM08:               1;
N        unsigned    GPIOM09:               1;
N        unsigned    GPIOM10:               1;
N        unsigned    reserved:              21;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_OUT;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:               1;
N        unsigned    GPIOM01:               1;
N        unsigned    GPIOM02:               1;
N        unsigned    GPIOM03:               1;
N        unsigned    GPIOM04:               1;
N        unsigned    GPIOM05:               1;
N        unsigned    GPIOM06:               1;
N        unsigned    GPIOM07:               1;
N        unsigned    GPIOM08:               1;
N        unsigned    GPIOM09:               1;
N        unsigned    GPIOM10:               1;
N        unsigned    reserved:              21;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_OEN;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:                2;
N        unsigned    GPIOM01:                2;
N        unsigned    GPIOM02:                2;
N        unsigned    GPIOM03:                2;
N        unsigned    GPIOM04:                2;
N        unsigned    GPIOM05:                2;
N        unsigned    GPIOM06:                2;
N        unsigned    GPIOM07:                2;
N        unsigned    GPIOM08:                2;
N        unsigned    GPIOM09:                2;
N        unsigned    GPIOM10:                2;
N        unsigned    reserved:               10;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_DS;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:                2;
N        unsigned    GPIOM01:                2;
N        unsigned    GPIOM02:                2;
N        unsigned    GPIOM03:                2;
N        unsigned    GPIOM04:                2;
N        unsigned    GPIOM05:                2;
N        unsigned    GPIOM06:                2;
N        unsigned    GPIOM07:                2;
N        unsigned    GPIOM08:                2;
N        unsigned    GPIOM09:                2;
N        unsigned    GPIOM10:                2;
N        unsigned    reserved:               10;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_PE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:               1;
N        unsigned    GPIOM01:               1;
N        unsigned    GPIOM02:               1;
N        unsigned    GPIOM03:               1;
N        unsigned    GPIOM04:               1;
N        unsigned    GPIOM05:               1;
N        unsigned    GPIOM06:               1;
N        unsigned    GPIOM07:               1;
N        unsigned    GPIOM08:               1;
N        unsigned    GPIOM09:               1;
N        unsigned    GPIOM10:               1;
N        unsigned    reserved:              21;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_SMT;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:              2;
N        unsigned    GPIOM01:              2;
N        unsigned    GPIOM02:              2;
N        unsigned    GPIOM03:              2;
N        unsigned    GPIOM04:              2;
N        unsigned    GPIOM05:              2;
N        unsigned    GPIOM06:              2;
N        unsigned    GPIOM07:              2;
N        unsigned    GPIOM08:              2;
N        unsigned    GPIOM09:              2;
N        unsigned    GPIOM10:              2;
N        unsigned    reserved:             10;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_FUNC;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM00:           2;
N        unsigned    GPIOM01:           2;
N        unsigned    GPIOM02:           2;
N        unsigned    GPIOM03:           2;
N        unsigned    GPIOM04:           2;
N        unsigned    GPIOM05:           2;
N        unsigned    GPIOM06:           2;
N        unsigned    GPIOM07:           2;
N        unsigned    GPIOM08:           2;
N        unsigned    GPIOM09:           2;
N        unsigned    GPIOM10:           2;
N        unsigned    reserved:          10;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOM_INTTYPE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:               1;
N        unsigned    GPIOA01:               1;
N        unsigned    GPIOA02:               1;
N        unsigned    GPIOA03:               1;
N        unsigned    GPIOA04:               1;
N        unsigned    GPIOA05:               1;
N        unsigned    GPIOA06:               1;
N        unsigned    GPIOA07:               1;
N        unsigned    GPIOA08:               1;
N        unsigned    GPIOA09:               1;
N        unsigned    GPIOA10:               1;
N        unsigned    GPIOA11:               1;
N        unsigned    GPIOA12:               1;
N        unsigned    GPIOA13:               1;
N        unsigned    GPIOA14:               1;
N        unsigned    GPIOA15:               1;
N        unsigned    GPIOA16:               1;
N        unsigned    GPIOA17:               1;
N        unsigned    GPIOA18:               1;
N        unsigned    GPIOA19:               1;
N        unsigned    GPIOA20:               1;
N        unsigned    GPIOA21:               1;
N        unsigned    GPIOA22:               1;
N        unsigned    GPIOA23:               1;
N        unsigned    GPIOA24:               1;
N        unsigned    GPIOA25:               1;
N        unsigned    GPIOA26:               1;
N        unsigned    GPIOA27:               1;
N        unsigned    GPIOA28:               1;
N        unsigned    GPIOA29:               1;
N        unsigned    GPIOA30:               1;
N        unsigned    GPIOA31:               1;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAL_IN;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:               1;
N        unsigned    GPIOA01:               1;
N        unsigned    GPIOA02:               1;
N        unsigned    GPIOA03:               1;
N        unsigned    GPIOA04:               1;
N        unsigned    GPIOA05:               1;
N        unsigned    GPIOA06:               1;
N        unsigned    GPIOA07:               1;
N        unsigned    GPIOA08:               1;
N        unsigned    GPIOA09:               1;
N        unsigned    GPIOA10:               1;
N        unsigned    GPIOA11:               1;
N        unsigned    GPIOA12:               1;
N        unsigned    GPIOA13:               1;
N        unsigned    GPIOA14:               1;
N        unsigned    GPIOA15:               1;
N        unsigned    GPIOA16:               1;
N        unsigned    GPIOA17:               1;
N        unsigned    GPIOA18:               1;
N        unsigned    GPIOA19:               1;
N        unsigned    GPIOA20:               1;
N        unsigned    GPIOA21:               1;
N        unsigned    GPIOA22:               1;
N        unsigned    GPIOA23:               1;
N        unsigned    GPIOA24:               1;
N        unsigned    GPIOA25:               1;
N        unsigned    GPIOA26:               1;
N        unsigned    GPIOA27:               1;
N        unsigned    GPIOA28:               1;
N        unsigned    GPIOA29:               1;
N        unsigned    GPIOA30:               1;
N        unsigned    GPIOA31:               1;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAL_OUT;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:               1;
N        unsigned    GPIOA01:               1;
N        unsigned    GPIOA02:               1;
N        unsigned    GPIOA03:               1;
N        unsigned    GPIOA04:               1;
N        unsigned    GPIOA05:               1;
N        unsigned    GPIOA06:               1;
N        unsigned    GPIOA07:               1;
N        unsigned    GPIOA08:               1;
N        unsigned    GPIOA09:               1;
N        unsigned    GPIOA10:               1;
N        unsigned    GPIOA11:               1;
N        unsigned    GPIOA12:               1;
N        unsigned    GPIOA13:               1;
N        unsigned    GPIOA14:               1;
N        unsigned    GPIOA15:               1;
N        unsigned    GPIOA16:               1;
N        unsigned    GPIOA17:               1;
N        unsigned    GPIOA18:               1;
N        unsigned    GPIOA19:               1;
N        unsigned    GPIOA20:               1;
N        unsigned    GPIOA21:               1;
N        unsigned    GPIOA22:               1;
N        unsigned    GPIOA23:               1;
N        unsigned    GPIOA24:               1;
N        unsigned    GPIOA25:               1;
N        unsigned    GPIOA26:               1;
N        unsigned    GPIOA27:               1;
N        unsigned    GPIOA28:               1;
N        unsigned    GPIOA29:               1;
N        unsigned    GPIOA30:               1;
N        unsigned    GPIOA31:               1;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAL_OEN;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:                2;
N        unsigned    GPIOA01:                2;
N        unsigned    GPIOA02:                2;
N        unsigned    GPIOA03:                2;
N        unsigned    GPIOA04:                2;
N        unsigned    GPIOA05:                2;
N        unsigned    GPIOA06:                2;
N        unsigned    GPIOA07:                2;
N        unsigned    GPIOA08:                2;
N        unsigned    GPIOA09:                2;
N        unsigned    GPIOA10:                2;
N        unsigned    GPIOA11:                2;
N        unsigned    GPIOA12:                2;
N        unsigned    GPIOA13:                2;
N        unsigned    GPIOA14:                2;
N        unsigned    GPIOA15:                2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALL_DS;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA16:                2;
N        unsigned    GPIOA17:                2;
N        unsigned    GPIOA18:                2;
N        unsigned    GPIOA19:                2;
N        unsigned    GPIOA20:                2;
N        unsigned    GPIOA21:                2;
N        unsigned    GPIOA22:                2;
N        unsigned    GPIOA23:                2;
N        unsigned    GPIOA24:                2;
N        unsigned    GPIOA25:                2;
N        unsigned    GPIOA26:                2;
N        unsigned    GPIOA27:                2;
N        unsigned    GPIOA28:                2;
N        unsigned    GPIOA29:                2;
N        unsigned    GPIOA30:                2;
N        unsigned    GPIOA31:                2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALH_DS;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:                2;
N        unsigned    GPIOA01:                2;
N        unsigned    GPIOA02:                2;
N        unsigned    GPIOA03:                2;
N        unsigned    GPIOA04:                2;
N        unsigned    GPIOA05:                2;
N        unsigned    GPIOA06:                2;
N        unsigned    GPIOA07:                2;
N        unsigned    GPIOA08:                2;
N        unsigned    GPIOA09:                2;
N        unsigned    GPIOA10:                2;
N        unsigned    GPIOA11:                2;
N        unsigned    GPIOA12:                2;
N        unsigned    GPIOA13:                2;
N        unsigned    GPIOA14:                2;
N        unsigned    GPIOA15:                2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALL_PE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA16:                2;
N        unsigned    GPIOA17:                2;
N        unsigned    GPIOA18:                2;
N        unsigned    GPIOA19:                2;
N        unsigned    GPIOA20:                2;
N        unsigned    GPIOA21:                2;
N        unsigned    GPIOA22:                2;
N        unsigned    GPIOA23:                2;
N        unsigned    GPIOA24:                2;
N        unsigned    GPIOA25:                2;
N        unsigned    GPIOA26:                2;
N        unsigned    GPIOA27:                2;
N        unsigned    GPIOA28:                2;
N        unsigned    GPIOA29:                2;
N        unsigned    GPIOA30:                2;
N        unsigned    GPIOA31:                2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALH_PE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:               1;
N        unsigned    GPIOA01:               1;
N        unsigned    GPIOA02:               1;
N        unsigned    GPIOA03:               1;
N        unsigned    GPIOA04:               1;
N        unsigned    GPIOA05:               1;
N        unsigned    GPIOA06:               1;
N        unsigned    GPIOA07:               1;
N        unsigned    GPIOA08:               1;
N        unsigned    GPIOA09:               1;
N        unsigned    GPIOA10:               1;
N        unsigned    GPIOA11:               1;
N        unsigned    GPIOA12:               1;
N        unsigned    GPIOA13:               1;
N        unsigned    GPIOA14:               1;
N        unsigned    GPIOA15:               1;
N        unsigned    GPIOA16:               1;
N        unsigned    GPIOA17:               1;
N        unsigned    GPIOA18:               1;
N        unsigned    GPIOA19:               1;
N        unsigned    GPIOA20:               1;
N        unsigned    GPIOA21:               1;
N        unsigned    GPIOA22:               1;
N        unsigned    GPIOA23:               1;
N        unsigned    GPIOA24:               1;
N        unsigned    GPIOA25:               1;
N        unsigned    GPIOA26:               1;
N        unsigned    GPIOA27:               1;
N        unsigned    GPIOA28:               1;
N        unsigned    GPIOA29:               1;
N        unsigned    GPIOA30:               1;
N        unsigned    GPIOA31:               1;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAL_SMT;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:              2;
N        unsigned    GPIOA01:              2;
N        unsigned    GPIOA02:              2;
N        unsigned    GPIOA03:              2;
N        unsigned    GPIOA04:              2;
N        unsigned    GPIOA05:              2;
N        unsigned    GPIOA06:              2;
N        unsigned    GPIOA07:              2;
N        unsigned    GPIOA08:              2;
N        unsigned    GPIOA09:              2;
N        unsigned    GPIOA10:              2;
N        unsigned    GPIOA11:              2;
N        unsigned    GPIOA12:              2;
N        unsigned    GPIOA13:              2;
N        unsigned    GPIOA14:              2;
N        unsigned    GPIOA15:              2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALL_FUNC;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA16:              2;
N        unsigned    GPIOA17:              2;
N        unsigned    GPIOA18:              2;
N        unsigned    GPIOA19:              2;
N        unsigned    GPIOA20:              2;
N        unsigned    GPIOA21:              2;
N        unsigned    GPIOA22:              2;
N        unsigned    GPIOA23:              2;
N        unsigned    GPIOA24:              2;
N        unsigned    GPIOA25:              2;
N        unsigned    GPIOA26:              2;
N        unsigned    GPIOA27:              2;
N        unsigned    GPIOA28:              2;
N        unsigned    GPIOA29:              2;
N        unsigned    GPIOA30:              2;
N        unsigned    GPIOA31:              2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALH_FUNC;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA00:           2;
N        unsigned    GPIOA01:           2;
N        unsigned    GPIOA02:           2;
N        unsigned    GPIOA03:           2;
N        unsigned    GPIOA04:           2;
N        unsigned    GPIOA05:           2;
N        unsigned    GPIOA06:           2;
N        unsigned    GPIOA07:           2;
N        unsigned    GPIOA08:           2;
N        unsigned    GPIOA09:           2;
N        unsigned    GPIOA10:           2;
N        unsigned    GPIOA11:           2;
N        unsigned    GPIOA12:           2;
N        unsigned    GPIOA13:           2;
N        unsigned    GPIOA14:           2;
N        unsigned    GPIOA15:           2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALL_INTTYPE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA16:           2;
N        unsigned    GPIOA17:           2;
N        unsigned    GPIOA18:           2;
N        unsigned    GPIOA19:           2;
N        unsigned    GPIOA20:           2;
N        unsigned    GPIOA21:           2;
N        unsigned    GPIOA22:           2;
N        unsigned    GPIOA23:           2;
N        unsigned    GPIOA24:           2;
N        unsigned    GPIOA25:           2;
N        unsigned    GPIOA26:           2;
N        unsigned    GPIOA27:           2;
N        unsigned    GPIOA28:           2;
N        unsigned    GPIOA29:           2;
N        unsigned    GPIOA30:           2;
N        unsigned    GPIOA31:           2;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOALH_INTTYPE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:               1;
N        unsigned    GPIOA33:               1;
N        unsigned    GPIOA34:               1;
N        unsigned    GPIOA35:               1;
N        unsigned    GPIOA36:               1;
N        unsigned    GPIOA37:               1;
N        unsigned    GPIOA38:               1;
N        unsigned    GPIOA39:               1;
N        unsigned    GPIOA40:               1;
N        unsigned    GPIOA41:               1;
N        unsigned    GPIOA42:               1;
N        unsigned    GPIOA43:               1;
N        unsigned    GPIOA44:               1;
N        unsigned    GPIOA45:               1;
N        unsigned    reserved:              18;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_IN;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:               1;
N        unsigned    GPIOA33:               1;
N        unsigned    GPIOA34:               1;
N        unsigned    GPIOA35:               1;
N        unsigned    GPIOA36:               1;
N        unsigned    GPIOA37:               1;
N        unsigned    GPIOA38:               1;
N        unsigned    GPIOA39:               1;
N        unsigned    GPIOA40:               1;
N        unsigned    GPIOA41:               1;
N        unsigned    GPIOA42:               1;
N        unsigned    GPIOA43:               1;
N        unsigned    GPIOA44:               1;
N        unsigned    GPIOA45:               1;
N        unsigned    reserved:              18;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_OUT;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:               1;
N        unsigned    GPIOA33:               1;
N        unsigned    GPIOA34:               1;
N        unsigned    GPIOA35:               1;
N        unsigned    GPIOA36:               1;
N        unsigned    GPIOA37:               1;
N        unsigned    GPIOA38:               1;
N        unsigned    GPIOA39:               1;
N        unsigned    GPIOA40:               1;
N        unsigned    GPIOA41:               1;
N        unsigned    GPIOA42:               1;
N        unsigned    GPIOA43:               1;
N        unsigned    GPIOA44:               1;
N        unsigned    GPIOA45:               1;
N        unsigned    reserved:              18;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_OEN;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:                2;
N        unsigned    GPIOA33:                2;
N        unsigned    GPIOA34:                2;
N        unsigned    GPIOA35:                2;
N        unsigned    GPIOA36:                2;
N        unsigned    GPIOA37:                2;
N        unsigned    GPIOA38:                2;
N        unsigned    GPIOA39:                2;
N        unsigned    GPIOA40:                2;
N        unsigned    GPIOA41:                2;
N        unsigned    GPIOA42:                2;
N        unsigned    GPIOA43:                2;
N        unsigned    GPIOA44:                2;
N        unsigned    GPIOA45:                2;
N        unsigned    reserved:               4;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_DS;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:                2;
N        unsigned    GPIOA33:                2;
N        unsigned    GPIOA34:                2;
N        unsigned    GPIOA35:                2;
N        unsigned    GPIOA36:                2;
N        unsigned    GPIOA37:                2;
N        unsigned    GPIOA38:                2;
N        unsigned    GPIOA39:                2;
N        unsigned    GPIOA40:                2;
N        unsigned    GPIOA41:                2;
N        unsigned    GPIOA42:                2;
N        unsigned    GPIOA43:                2;
N        unsigned    GPIOA44:                2;
N        unsigned    GPIOA45:                2;
N        unsigned    reserved:               4;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_PE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:               1;
N        unsigned    GPIOA33:               1;
N        unsigned    GPIOA34:               1;
N        unsigned    GPIOA35:               1;
N        unsigned    GPIOA36:               1;
N        unsigned    GPIOA37:               1;
N        unsigned    GPIOA38:               1;
N        unsigned    GPIOA39:               1;
N        unsigned    GPIOA40:               1;
N        unsigned    GPIOA41:               1;
N        unsigned    GPIOA42:               1;
N        unsigned    GPIOA43:               1;
N        unsigned    GPIOA44:               1;
N        unsigned    GPIOA45:               1;
N        unsigned    reserved:              18;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_SMT;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:              2;
N        unsigned    GPIOA33:              2;
N        unsigned    GPIOA34:              2;
N        unsigned    GPIOA35:              2;
N        unsigned    GPIOA36:              2;
N        unsigned    GPIOA37:              2;
N        unsigned    GPIOA38:              2;
N        unsigned    GPIOA39:              2;
N        unsigned    GPIOA40:              2;
N        unsigned    GPIOA41:              2;
N        unsigned    GPIOA42:              2;
N        unsigned    GPIOA43:              2;
N        unsigned    GPIOA44:              2;
N        unsigned    GPIOA45:              2;
N        unsigned    reserved:             4;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_FUNC;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOA32:           2;
N        unsigned    GPIOA33:           2;
N        unsigned    GPIOA34:           2;
N        unsigned    GPIOA35:           2;
N        unsigned    GPIOA36:           2;
N        unsigned    GPIOA37:           2;
N        unsigned    GPIOA38:           2;
N        unsigned    GPIOA39:           2;
N        unsigned    GPIOA40:           2;
N        unsigned    GPIOA41:           2;
N        unsigned    GPIOA42:           2;
N        unsigned    GPIOA43:           2;
N        unsigned    GPIOA44:           2;
N        unsigned    GPIOA45:           2;
N        unsigned    reserved:          4;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIOAH_INTTYPE;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM:               1;
N        unsigned    GPIOA:               1;
N        unsigned    reserved:            30;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_GPIO_INTEN;
N
Ntypedef union
N{
N    struct {
N        unsigned    GPIOM:               1;
N        unsigned    GPIOA:               1;
N        unsigned    reserved:            30;
N    } tBit;
N    __O uint32_t w;
X    volatile uint32_t w;
N} t_GPIO_INTCLR;
N
Ntypedef union
N{
N    struct {
N        unsigned    tattn_wdog_en:             1;
N        unsigned    tattn_abspck_en:           1;
N        unsigned    TCH_ATTN_MUX_SEL:          1;
N        unsigned    reserved:                  29;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_SPI_TATTN_OPT_CFG;
N
Ntypedef struct
N{													//Index
N    __I  t_GPIOM_IN         	GPIOM_IN;         	//0x0040 GPIOM 0~10
X    volatile const  t_GPIOM_IN         	GPIOM_IN;         	
N    __IO t_GPIOM_OUT        	GPIOM_OUT;        	//0x0041 GPIOM 0~10
X    volatile t_GPIOM_OUT        	GPIOM_OUT;        	
N    __IO t_GPIOM_OEN        	GPIOM_OEN;        	//0x0042 GPIOM 0~10
X    volatile t_GPIOM_OEN        	GPIOM_OEN;        	
N    __IO t_GPIOM_DS         	GPIOM_DS;         	//0x0043 GPIOM 0~10
X    volatile t_GPIOM_DS         	GPIOM_DS;         	
N    __IO t_GPIOM_PE         	GPIOM_PE;         	//0x0044 GPIOM 0~10
X    volatile t_GPIOM_PE         	GPIOM_PE;         	
N    __IO t_GPIOM_SMT        	GPIOM_SMT;        	//0x0045 GPIOM 0~10
X    volatile t_GPIOM_SMT        	GPIOM_SMT;        	
N    __IO t_GPIOM_FUNC       	GPIOM_FUNC;       	//0x0046 GPIOM 0~10
X    volatile t_GPIOM_FUNC       	GPIOM_FUNC;       	
N    __IO t_GPIOM_INTTYPE    	GPIOM_INTTYPE;    	//0x0047 GPIOM 0~10
X    volatile t_GPIOM_INTTYPE    	GPIOM_INTTYPE;    	
N
N    __I  t_GPIOAL_IN        	GPIOAL_IN;        	//0x0048 GPIOA 0~31
X    volatile const  t_GPIOAL_IN        	GPIOAL_IN;        	
N    __IO t_GPIOAL_OUT       	GPIOAL_OUT;       	//0x0049 GPIOA 0~31
X    volatile t_GPIOAL_OUT       	GPIOAL_OUT;       	
N    __IO t_GPIOAL_OEN       	GPIOAL_OEN;       	//0x004A GPIOA 0~31
X    volatile t_GPIOAL_OEN       	GPIOAL_OEN;       	
N    __IO t_GPIOALL_DS       	GPIOALL_DS;       	//0x004B GPIOA 0~15
X    volatile t_GPIOALL_DS       	GPIOALL_DS;       	
N    __IO t_GPIOALH_DS       	GPIOALH_DS;       	//0x004C GPIOA 16~31
X    volatile t_GPIOALH_DS       	GPIOALH_DS;       	
N    __IO t_GPIOALL_PE       	GPIOALL_PE;       	//0x004D GPIOA 0~15
X    volatile t_GPIOALL_PE       	GPIOALL_PE;       	
N    __IO t_GPIOALH_PE       	GPIOALH_PE;       	//0x004E GPIOA 16~31
X    volatile t_GPIOALH_PE       	GPIOALH_PE;       	
N    __IO t_GPIOAL_SMT       	GPIOAL_SMT;       	//0x004F GPIOA 0~31
X    volatile t_GPIOAL_SMT       	GPIOAL_SMT;       	
N    __IO t_GPIOALL_FUNC     	GPIOALL_FUNC;     	//0x0050 GPIOA 0~15
X    volatile t_GPIOALL_FUNC     	GPIOALL_FUNC;     	
N    __IO t_GPIOALH_FUNC     	GPIOALH_FUNC;     	//0x0051 GPIOA 16~31
X    volatile t_GPIOALH_FUNC     	GPIOALH_FUNC;     	
N    __IO t_GPIOALL_INTTYPE  	GPIOALL_INTTYPE;  	//0x0052 GPIOA 0~15
X    volatile t_GPIOALL_INTTYPE  	GPIOALL_INTTYPE;  	
N    /*
N     * GPIOM Interrupt Type. 0: diable, 1: rising edge, 2: falling edge, 3: rising/falling edge
N     */
N    __IO t_GPIOALH_INTTYPE  	GPIOALH_INTTYPE;  	//0x0053 GPIOA 16~31
X    volatile t_GPIOALH_INTTYPE  	GPIOALH_INTTYPE;  	
N
N    __I  t_GPIOAH_IN        	GPIOAH_IN;        	//0x0054 GPIOA 32~45
X    volatile const  t_GPIOAH_IN        	GPIOAH_IN;        	
N    __IO t_GPIOAH_OUT       	GPIOAH_OUT;       	//0x0055 GPIOA 32~45
X    volatile t_GPIOAH_OUT       	GPIOAH_OUT;       	
N    __IO t_GPIOAH_OEN       	GPIOAH_OEN;       	//0x0056 GPIOA 32~45
X    volatile t_GPIOAH_OEN       	GPIOAH_OEN;       	
N    __IO t_GPIOAH_DS        	GPIOAH_DS;        	//0x0057 GPIOA 32~45
X    volatile t_GPIOAH_DS        	GPIOAH_DS;        	
N    __IO t_GPIOAH_PE        	GPIOAH_PE;        	//0x0058 GPIOA 32~45
X    volatile t_GPIOAH_PE        	GPIOAH_PE;        	
N    __IO t_GPIOAH_SMT       	GPIOAH_SMT;       	//0x0059 GPIOA 32~45
X    volatile t_GPIOAH_SMT       	GPIOAH_SMT;       	
N    __IO t_GPIOAH_FUNC      	GPIOAH_FUNC;      	//0x005A GPIOA 32~45
X    volatile t_GPIOAH_FUNC      	GPIOAH_FUNC;      	
N    __IO t_GPIOAH_INTTYPE   	GPIOAH_INTTYPE;   	//0x005B GPIOA 32~45
X    volatile t_GPIOAH_INTTYPE   	GPIOAH_INTTYPE;   	
N
N    __IO t_GPIO_INTEN       	GPIO_INTEN;       	//0x005C
X    volatile t_GPIO_INTEN       	GPIO_INTEN;       	
N    __O  t_GPIO_INTCLR      	GPIO_INTCLEAR;    	//0x005D
X    volatile  t_GPIO_INTCLR      	GPIO_INTCLEAR;    	
N    __IO t_SPI_TATTN_OPT_CFG	SPI_TATTN_OPT_CFG;	//0x005E
X    volatile t_SPI_TATTN_OPT_CFG	SPI_TATTN_OPT_CFG;	
N} tGPIO_CtrlReg_t;
N
N
N#endif /* __GPIO_H_ */
L 247 "..\..\Hal\system\MFTP.h" 2
N#include "_wdgt.h"
L 1 "..\..\Hal\wdgt\_wdgt.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _wdt.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __WDT_H_
N#define __WDT_H_
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
Ntypedef union
N{
N    struct {
N        unsigned    wdt_int_en:                1;
N        unsigned    wdt_rst_en:                1;
N        unsigned    reserved:                  30;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_WDOG_CONTROL;
N
Ntypedef union
N{
N    struct {
N        unsigned    watchdog_reset_en:         1;
N        unsigned    reserved:                  31;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_WDOG_RSTCTRL;
N
N
Ntypedef struct
N{
N    __IO t_WDOG_CONTROL              WDOG_CONTROL;                   //0x005F
X    volatile t_WDOG_CONTROL              WDOG_CONTROL;                   
N    __IO t_WDOG_RSTCTRL              WDOG_RSTCTRL;                   //0x0060
X    volatile t_WDOG_RSTCTRL              WDOG_RSTCTRL;                   
N    __IO uint32_t                    WDOG_LOAD;                      //0x0061
X    volatile uint32_t                    WDOG_LOAD;                      
N    __O  uint32_t                    WDOG_INTCLR;                    //0x0062
X    volatile  uint32_t                    WDOG_INTCLR;                    
N    __O  uint32_t                    WDOG_RSTCLR;                    //0x0063
X    volatile  uint32_t                    WDOG_RSTCLR;                    
N    __I  uint32_t                    WDOG_VALUE;                     //0x0064
X    volatile const  uint32_t                    WDOG_VALUE;                     
N    __I  uint32_t                    WDOG_RIS;                       //0x0065
X    volatile const  uint32_t                    WDOG_RIS;                       
N    __I  uint32_t                    WDOG_MIS;                       //0x0066
X    volatile const  uint32_t                    WDOG_MIS;                       
N} tWDT_CtrlReg_t;
N
N
N#endif /* __WDT_H_ */
L 248 "..\..\Hal\system\MFTP.h" 2
N#include "_timer.h"
L 1 "..\..\Hal\timer\_timer.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _timer.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __TIMER_H_
N#define __TIMER_H_
N
N
N/* ================================================================================ */
N/* ================           TIMER Control Registers              ================ */
N/* ================================================================================ */
N
N/* ================================================================================ */
N/* ================           TIMER Control Registers              ================ */
N/* ================================================================================ */
Ntypedef union
N{
N    struct {
N        unsigned    timer0_en:                 1;
N        unsigned    int_timer0_en:             1;
N        unsigned    timer1_en:                 1;
N        unsigned    int_timer1_en:             1;
N        unsigned    timer2_en:                 1;
N        unsigned    int_timer2_en:             1;
N        unsigned    timer3_en:                 1;
N        unsigned    int_timer3_en:             1;
N        unsigned    reserved:                  24;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TIMER_CTRL;
N
Ntypedef union
N{
N    struct {
N        unsigned    timer_reload_val:         20;
N        unsigned    timer_prev_val:           3;
N        unsigned    reserved:                 9;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TIMER_RELOAD;
N
Ntypedef union
N{
N    struct {
N        unsigned    timer0_os_start:           1;
N        unsigned    timer1_os_start:           1;
N        unsigned    timer2_os_start:           1;
N        unsigned    timer3_os_start:           1;
N        unsigned    reserved:                  28;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TIMER_OS_START;
N
Ntypedef union
N{
N    struct {
N        unsigned    timer0_int_clr:            1;
N        unsigned    timer1_int_clr:            1;
N        unsigned    timer2_int_clr:            1;
N        unsigned    timer3_int_clr:            1;
N        unsigned    reserved:                  28;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TIMER_INT_CLR;
N
Ntypedef union
N{
N    struct {
N        unsigned    timer0_status:             1;
N        unsigned    timer1_status:             1;
N        unsigned    timer2_status:             1;
N        unsigned    timer3_status:             1;
N        unsigned    reserved:                  28;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TIMER_STATUS;
N
N
N// __PACKED typedef struct
Ntypedef struct
N{
N    __IO t_TIMER_CTRL                TIMER_CTRL;                     //0x0067
X    volatile t_TIMER_CTRL                TIMER_CTRL;                     
N    __IO t_TIMER_RELOAD              TIMER_RELOAD[4];                //0x0068~0x006B
X    volatile t_TIMER_RELOAD              TIMER_RELOAD[4];                
N    __O  t_TIMER_OS_START            TIMER_OS_START;                 //0x006C
X    volatile  t_TIMER_OS_START            TIMER_OS_START;                 
N    __O  t_TIMER_INT_CLR             TIMER_INT_CLR;                  //0x006D
X    volatile  t_TIMER_INT_CLR             TIMER_INT_CLR;                  
N    __I  uint32_t                    TIMER_VALUE[4];                 //0x006E~0x0071
X    volatile const  uint32_t                    TIMER_VALUE[4];                 
N    __I  t_TIMER_STATUS              TIMER_STATUS;                   //0x0072
X    volatile const  t_TIMER_STATUS              TIMER_STATUS;                   
N    __IO uint32_t                    SYS_DUMMY2;                     //0x0073
X    volatile uint32_t                    SYS_DUMMY2;                     
N    __IO uint32_t                    SYS_DUMMY3;                     //0x0074
X    volatile uint32_t                    SYS_DUMMY3;                     
N    __IO uint32_t                    GPIO_RESERVED06;                //0x0075
X    volatile uint32_t                    GPIO_RESERVED06;                
N    __IO uint32_t                    GPIO_RESERVED07;                //0x0076
X    volatile uint32_t                    GPIO_RESERVED07;                
N    __IO uint32_t                    GPIO_RESERVED08;                //0x0077
X    volatile uint32_t                    GPIO_RESERVED08;                
N    __IO uint32_t                    GPIO_RESERVED09;                //0x0078
X    volatile uint32_t                    GPIO_RESERVED09;                
N    __IO uint32_t                    GPIO_RESERVED10;                //0x0079
X    volatile uint32_t                    GPIO_RESERVED10;                
N    __IO uint32_t                    GPIO_RESERVED11;                //0x007A
X    volatile uint32_t                    GPIO_RESERVED11;                
N    __IO uint32_t                    GPIO_RESERVED12;                //0x007B
X    volatile uint32_t                    GPIO_RESERVED12;                
N    __IO uint32_t                    GPIO_RESERVED13;                //0x007C
X    volatile uint32_t                    GPIO_RESERVED13;                
N    __IO uint32_t                    GPIO_RESERVED14;                //0x007D
X    volatile uint32_t                    GPIO_RESERVED14;                
N    __IO uint32_t                    GPIO_RESERVED15;                //0x007E
X    volatile uint32_t                    GPIO_RESERVED15;                
N    __IO uint32_t                    GPIO_RESERVED16;                //0x007F
X    volatile uint32_t                    GPIO_RESERVED16;                
N} tTIMER_CtrlReg_t;
N
N
N#endif /* __TIMER_H_ */
L 249 "..\..\Hal\system\MFTP.h" 2
N#include "_dbgserial.h"
L 1 "..\..\Hal\dbgserial\_dbgserial.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _dbgserial.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __DBGSERIAL_H_
N#define __DBGSERIAL_H_
N
N
Ntypedef union {
N	struct {
N		unsigned i2c_en :1;
N		unsigned spi_en :1;
N		unsigned reserved :30;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSERIAL_CTL_t;
N
Ntypedef union {
N	struct {
N		unsigned int_i2c_en :1;
N		unsigned int_serial_error_en :1;
N		unsigned int_report_done_en :1;
N		unsigned int_spi_en :1;
N		unsigned int_spi_report_done_en :1;
N		unsigned reserved :27;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSERIAL_INT_EN_t;
N
Ntypedef union {
N	struct {
N		unsigned int_i2c_clr :1;
N		unsigned int_serial_error_clr :1;
N		unsigned int_report_done_clr :1;
N		unsigned int_spi_clr :1;
N		unsigned int_spi_report_done_clr :1;
N		unsigned reserved :27;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSERIAL_INT_CLR_t;
N
Ntypedef union {
N	struct {
N		unsigned i2c_degl_len :3;
N		unsigned scl_dly_len :3;
N		unsigned sda_dly_len :3;
N		unsigned spi_cpol :1;
N		unsigned spi_cpha :1;
N		unsigned spi_pre_pha_miso :1;
N		unsigned spi_spck_compval_sel :1;
N		unsigned reserved :19;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSERIAL_CFG_t;
N
Ntypedef union {
N	struct {
N		unsigned i2c_dev_addr1 :7;
N		unsigned i2c_dev_addr2 :7;
N		unsigned reserved :18;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tI2C_DEV_ADDR_t;
N
Ntypedef union {
N	struct {
N		unsigned code :1;
N		unsigned data0 :1;
N		unsigned data1 :1;
N		unsigned data2 :1;
N		unsigned sys :1;
N		unsigned dspa :1;
N		unsigned tdsp :1;
N		unsigned pwm :1;
N		unsigned mspi :1;
N		unsigned mpi :1;
N		unsigned tlvds :1;
N		unsigned usb :1;
N		unsigned report :1;
N		unsigned raw :1;
N		unsigned cmd :1;
N		unsigned extm0 :1;
N		unsigned extm1 :1;
N		unsigned reserved :15;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tI2C_BUS_SEL_t;
N
Ntypedef union {
N	struct {
N		unsigned i2c_access_addr :16;
N		unsigned i2c_rw_cmd :1;
N		unsigned reserved :15;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tI2C_CMD_ADDR_t;
N
Ntypedef union {
N	struct {
N		unsigned code :1;
N		unsigned data0 :1;
N		unsigned data1 :1;
N		unsigned data2 :1;
N		unsigned sys :1;
N		unsigned dspa :1;
N		unsigned tdsp :1;
N		unsigned pwm :1;
N		unsigned mspi :1;
N		unsigned mpi :1;
N		unsigned tlvds :1;
N		unsigned usb :1;
N		unsigned report :1;
N		unsigned raw :1;
N		unsigned cmd :1;
N		unsigned extm0 :1;
N		unsigned extm1 :1;
N		unsigned reserved :15;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSPI_BUS_SEL_t;
N
Ntypedef union {
N	struct {
N		unsigned spi_access_addr :16;
N		unsigned spi_rw_cmd :1;
N		unsigned reserved :15;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSPI_CMD_ADDR_t;
N
Ntypedef union {
N	struct {
N		unsigned i2c_multi_read :1;
N		unsigned spi_multi_read :1;
N		unsigned reserved :30;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSERIAL_RD_STS_t;
N
Ntypedef struct
N{
N	__IO tSERIAL_CTL_t SERIAL_CTL; //0x0080
X	volatile tSERIAL_CTL_t SERIAL_CTL; 
N	__IO tSERIAL_INT_EN_t SERIAL_INT_EN; //0x0081
X	volatile tSERIAL_INT_EN_t SERIAL_INT_EN; 
N	__O tSERIAL_INT_CLR_t SERIAL_INT_CLR; //0x0082
X	volatile tSERIAL_INT_CLR_t SERIAL_INT_CLR; 
N	__IO tSERIAL_CFG_t SERIAL_CFG; //0x0083
X	volatile tSERIAL_CFG_t SERIAL_CFG; 
N	__IO uint32_t SERIAL_CMD_START_ADDR; //0x0084
X	volatile uint32_t SERIAL_CMD_START_ADDR; 
N	__IO uint32_t SERIAL_ENDIAN_SEL; //0x0085
X	volatile uint32_t SERIAL_ENDIAN_SEL; 
N	__IO tI2C_DEV_ADDR_t I2C_DEV_ADDR; //0x0086
X	volatile tI2C_DEV_ADDR_t I2C_DEV_ADDR; 
N	__IO uint32_t I2C_RESERVE00; //0x0087
X	volatile uint32_t I2C_RESERVE00; 
N	__IO tI2C_BUS_SEL_t I2C_BUS_SEL; //0x0088
X	volatile tI2C_BUS_SEL_t I2C_BUS_SEL; 
N	__IO uint32_t I2C_CODE_OFFSET; //0x0089
X	volatile uint32_t I2C_CODE_OFFSET; 
N	__IO uint32_t I2C_REPORT_START; //0x008A
X	volatile uint32_t I2C_REPORT_START; 
N	__IO uint32_t I2C_REPORT_END; //0x008B
X	volatile uint32_t I2C_REPORT_END; 
N	__IO uint32_t I2C_RESERVE01; //0x008C
X	volatile uint32_t I2C_RESERVE01; 
N	__IO uint32_t I2C_RAW_START; //0x008D
X	volatile uint32_t I2C_RAW_START; 
N	__IO uint32_t I2C_DATA0_OFFSET; //0x008E
X	volatile uint32_t I2C_DATA0_OFFSET; 
N	__IO uint32_t I2C_DATA1_OFFSET; //0x008F
X	volatile uint32_t I2C_DATA1_OFFSET; 
N	__IO uint32_t I2C_DATA2_OFFSET; //0x0090
X	volatile uint32_t I2C_DATA2_OFFSET; 
N	__IO uint32_t I2C_RAW_OFFSET; //0x0091
X	volatile uint32_t I2C_RAW_OFFSET; 
N	__IO uint32_t I2C_EXTM0_START; //0x0092
X	volatile uint32_t I2C_EXTM0_START; 
N	__IO uint32_t I2C_EXTM1_START; //0x0093
X	volatile uint32_t I2C_EXTM1_START; 
N	__IO uint32_t I2C_EXTM0_OFFSET; //0x0094
X	volatile uint32_t I2C_EXTM0_OFFSET; 
N	__IO uint32_t I2C_EXTM1_OFFSET; //0x0095
X	volatile uint32_t I2C_EXTM1_OFFSET; 
N	__IO uint32_t I2C_WR_DATA; //0x0096
X	volatile uint32_t I2C_WR_DATA; 
N	__I tI2C_CMD_ADDR_t I2C_CMD_ADDR; //0x0097
X	volatile const tI2C_CMD_ADDR_t I2C_CMD_ADDR; 
N	__I uint32_t I2C_CMD_LENGTH; //0x0098
X	volatile const uint32_t I2C_CMD_LENGTH; 
N	__I uint32_t I2C_RD_DATA; //0x0099
X	volatile const uint32_t I2C_RD_DATA; 
N	__IO tSPI_BUS_SEL_t SPI_BUS_SEL; //0x009A
X	volatile tSPI_BUS_SEL_t SPI_BUS_SEL; 
N	__IO uint32_t SPI_CODE_OFFSET; //0x009B
X	volatile uint32_t SPI_CODE_OFFSET; 
N	__IO uint32_t SPI_REPORT_START; //0x009C
X	volatile uint32_t SPI_REPORT_START; 
N	__IO uint32_t SPI_REPORT_END; //0x009D
X	volatile uint32_t SPI_REPORT_END; 
N	__IO uint32_t SPI_RESERVED0; //0x009E
X	volatile uint32_t SPI_RESERVED0; 
N	__IO uint32_t SPI_RAW_START; //0x009F
X	volatile uint32_t SPI_RAW_START; 
N	__IO uint32_t SPI_DATA0_OFFSET; //0x00A0
X	volatile uint32_t SPI_DATA0_OFFSET; 
N	__IO uint32_t SPI_DATA1_OFFSET; //0x00A1
X	volatile uint32_t SPI_DATA1_OFFSET; 
N	__IO uint32_t SPI_DATA2_OFFSET; //0x00A2
X	volatile uint32_t SPI_DATA2_OFFSET; 
N	__IO uint32_t SPI_RAW_OFFSET; //0x00A3
X	volatile uint32_t SPI_RAW_OFFSET; 
N	__IO uint32_t SPI_EXTM0_START; //0x00A4
X	volatile uint32_t SPI_EXTM0_START; 
N	__IO uint32_t SPI_EXTM1_START; //0x00A5
X	volatile uint32_t SPI_EXTM1_START; 
N	__IO uint32_t SPI_EXTM0_OFFSET; //0x00A6
X	volatile uint32_t SPI_EXTM0_OFFSET; 
N	__IO uint32_t SPI_EXTM1_OFFSET; //0x00A7
X	volatile uint32_t SPI_EXTM1_OFFSET; 
N	__IO uint32_t SPI_WR_DATA; //0x00A8
X	volatile uint32_t SPI_WR_DATA; 
N	__I tSPI_CMD_ADDR_t SPI_CMD_ADDR; //0x00A9
X	volatile const tSPI_CMD_ADDR_t SPI_CMD_ADDR; 
N	__I uint32_t SPI_CMD_LENGTH; //0x00AA
X	volatile const uint32_t SPI_CMD_LENGTH; 
N	__I uint32_t SPI_RD_DATA; //0x00AB
X	volatile const uint32_t SPI_RD_DATA; 
N	__O uint32_t SPI_SPCK_CLR; //0x00AC
X	volatile uint32_t SPI_SPCK_CLR; 
N	__I tSERIAL_RD_STS_t SERIAL_RD_STS; //0x00AD
X	volatile const tSERIAL_RD_STS_t SERIAL_RD_STS; 
N	__I uint32_t SPI_FAULT_TYPE_CFG; //0x00AE
X	volatile const uint32_t SPI_FAULT_TYPE_CFG; 
N	__I uint32_t SPI_RESET_CNT_CFG; //0x00AF
X	volatile const uint32_t SPI_RESET_CNT_CFG; 
N	__IO uint32_t SPI_RESERVED01; //0x00B0
X	volatile uint32_t SPI_RESERVED01; 
N	__IO uint32_t SERIAL_RESERVED01; //0x00B1
X	volatile uint32_t SERIAL_RESERVED01; 
N	__IO uint32_t SERIAL_RESERVED02; //0x00B2
X	volatile uint32_t SERIAL_RESERVED02; 
N	__IO uint32_t SERIAL_RESERVED03; //0x00B3
X	volatile uint32_t SERIAL_RESERVED03; 
N	__IO uint32_t SERIAL_RESERVED04; //0x00B4
X	volatile uint32_t SERIAL_RESERVED04; 
N	__IO uint32_t SERIAL_RESERVED05; //0x00B5
X	volatile uint32_t SERIAL_RESERVED05; 
N	__IO uint32_t SERIAL_RESERVED06; //0x00B6
X	volatile uint32_t SERIAL_RESERVED06; 
N	__IO uint32_t SERIAL_RESERVED07; //0x00B7
X	volatile uint32_t SERIAL_RESERVED07; 
N	__IO uint32_t SERIAL_RESERVED08; //0x00B8
X	volatile uint32_t SERIAL_RESERVED08; 
N	__IO uint32_t SERIAL_RESERVED09; //0x00B9
X	volatile uint32_t SERIAL_RESERVED09; 
N	__IO uint32_t SERIAL_RESERVED10; //0x00BA
X	volatile uint32_t SERIAL_RESERVED10; 
N	__IO uint32_t SERIAL_RESERVED11; //0x00BB
X	volatile uint32_t SERIAL_RESERVED11; 
N	__IO uint32_t SERIAL_RESERVED12; //0x00BC
X	volatile uint32_t SERIAL_RESERVED12; 
N	__IO uint32_t SERIAL_RESERVED14; //0x00BD
X	volatile uint32_t SERIAL_RESERVED14; 
N	__IO uint32_t SERIAL_RESERVED15; //0x00BE
X	volatile uint32_t SERIAL_RESERVED15; 
N	__IO uint32_t SERIAL_RESERVED16; //0x00BF
X	volatile uint32_t SERIAL_RESERVED16; 
N
N} tDBGSERIAL_CtrlReg_t;
N
N
N#endif /* __DBGSERIAL_H_ */
L 250 "..\..\Hal\system\MFTP.h" 2
N#include "_gdma.h"
L 1 "..\..\Hal\gdma\_gdma.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _gdma.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __DMA_H_
N#define __DMA_H_
N
N
Ntypedef union
N{
N    struct {
N        unsigned    lfsr_clear:                1;
N        unsigned    free_running_en:           1;
N        unsigned    lfsr_en:                   1;
N        unsigned    reserved:                  29;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} tLFSRCTRL_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    saddr:                     32;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} tGDMA_SADDR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    daddr:                     32;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} tGDMA_DADDR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    TrSize:                    16;
N        unsigned    Int_En:                    1;
N        unsigned    arbcnt:                    2;
N        unsigned    readonly_en:               1;
N        unsigned    gdma_enable:               1;
N        unsigned    lfsr_mode:                 1;
N        unsigned    writeonly_en:              1;
N        unsigned    error_check_mode:          1;
N        unsigned    crc_area_sel:              3;
N        unsigned    crc_mode:                  2;
N        unsigned    crc_error_int_en:          1;
N        unsigned    event_en:                  1;
N        unsigned    reserved:                  1;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} tGDMA_CTRL_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lfsr_pass_clr:			   1;
N        unsigned    int_gdma_clr:			   1;
N        unsigned    event_gdma_clr:			   1;
N        unsigned    crc_err_int_clr:		   1;
N        unsigned    reserved:                  28;
N    } tBit;
N    __O uint32_t w;
X    volatile uint32_t w;
N} tGDMA_CLR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    status:                    3;
N        unsigned    busy:                      1;
N        unsigned    lfsr_pass:                 1;
N        unsigned    reserved:                  27;
N    } tBit;
N    __I uint32_t w;
X    volatile const uint32_t w;
N} tGDMA_SR_t;
N
N
Ntypedef struct
N{
N	////////////////////////     LFSR     ////////////////////////////////////
N    __IO uint32_t                    LFSRSEED;                       //0x00C0
X    volatile uint32_t                    LFSRSEED;                       
N    __IO tLFSRCTRL_t                 LFSRCTRL;                       //0x00C1
X    volatile tLFSRCTRL_t                 LFSRCTRL;                       
N    __I  uint32_t                    LFSR_DATA;                      //0x00C2
X    volatile const  uint32_t                    LFSR_DATA;                      
N
N    ////////////////////////     GDMA     ////////////////////////////////////
N    __IO tGDMA_SADDR_t               GDMA_SADDR;                     //0x00C3
X    volatile tGDMA_SADDR_t               GDMA_SADDR;                     
N    __IO tGDMA_DADDR_t               GDMA_DADDR;                     //0x00C4
X    volatile tGDMA_DADDR_t               GDMA_DADDR;                     
N    __IO tGDMA_CTRL_t                GDMA_CTRL;                      //0x00C5
X    volatile tGDMA_CTRL_t                GDMA_CTRL;                      
N    __O  uint32_t                    GDMA_START;                     //0x00C6
X    volatile  uint32_t                    GDMA_START;                     
N    __O  tGDMA_CLR_t                 GDMA_CLR;                       //0x00C7
X    volatile  tGDMA_CLR_t                 GDMA_CLR;                       
N    __I  tGDMA_SR_t                  GDMA_SR;                        //0x00C8
X    volatile const  tGDMA_SR_t                  GDMA_SR;                        
N    __IO uint32_t                    GDMA_COMPARE_VALID_BIT;         //0x00C9
X    volatile uint32_t                    GDMA_COMPARE_VALID_BIT;         
N    __I  uint32_t                    CRC_RESULT;                     //0x00CA
X    volatile const  uint32_t                    CRC_RESULT;                     
N    __I  uint32_t                    CRC_PASS;                       //0x00CB
X    volatile const  uint32_t                    CRC_PASS;                       
N    __IO uint32_t                    SYS_DUMMY4;                     //0x00CC
X    volatile uint32_t                    SYS_DUMMY4;                     
N    __IO uint32_t                    SYS_DUMMY5;                     //0x00CD
X    volatile uint32_t                    SYS_DUMMY5;                     
N
N    ////////////////////////     CRC      ////////////////////////////////////
N    __I  uint32_t                    CRC_MEMO0;                      //0x00CE
X    volatile const  uint32_t                    CRC_MEMO0;                      
N    __I  uint32_t                    CRC_MEMO1;                      //0x00CF
X    volatile const  uint32_t                    CRC_MEMO1;                      
N    __I  uint32_t                    CRC_MEMO2;                      //0x00D0
X    volatile const  uint32_t                    CRC_MEMO2;                      
N    __I  uint32_t                    CRC_MEMO3;                      //0x00D1
X    volatile const  uint32_t                    CRC_MEMO3;                      
N    __I  uint32_t                    CRC_MEMO4;                      //0x00D2
X    volatile const  uint32_t                    CRC_MEMO4;                      
N    __I  uint32_t                    CRC_MEMO5;                      //0x00D3
X    volatile const  uint32_t                    CRC_MEMO5;                      
N    __I  uint32_t                    CRC_MEMO6;                      //0x00D4
X    volatile const  uint32_t                    CRC_MEMO6;                      
N    __I  uint32_t                    CRC_MEMO7;                      //0x00D5
X    volatile const  uint32_t                    CRC_MEMO7;                      
N    __I  uint32_t                    CRC_ERROR_STATUS;               //0x00D6
X    volatile const  uint32_t                    CRC_ERROR_STATUS;               
N    __IO uint32_t                    GDMA_FIXED_DATA;                //0x00D7
X    volatile uint32_t                    GDMA_FIXED_DATA;                
N} tGDMA_CtrlReg_t ;
N
N
N#endif /* __DMA_H_ */
L 251 "..\..\Hal\system\MFTP.h" 2
N#include "_dspB.h"
L 1 "..\..\Hal\dspB\_dspB.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _DSPB.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N#ifndef __DSPB_H_
N#define __DSPB_H_
N
N
N/* ================================================================================ */
N/* ================                      TDSP(DSPB)                ================ */
N/* ================================================================================ */
N
Ntypedef union
N{
N    struct {
N        unsigned    DIV:                       16;
N        unsigned    DIVS:                      16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_CYCLE_DIV;
N
Ntypedef union
N{
N    struct {
N        unsigned    MUL:                       16;
N        unsigned    MULS:                      16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_CYCLE_MUL;
N
Ntypedef union
N{
N    struct {
N        unsigned    INT_STAT_CLR:              1;
N        unsigned    RESERVED:                  3;
N        unsigned    INT_MASK:                  1;
N        unsigned    reserved:                  27;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_INTERRUPT;
N
Ntypedef union
N{
N    struct {
N        unsigned    DEBUG_MODE:                2;
N        unsigned    RESERVED:                  2;
N        unsigned    DEBUG_RUN:                 1;
N        unsigned    DEBUG_STEP:                1;
N        unsigned    reserved:                  26;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DEBUG_CON;
N
Ntypedef union
N{
N    struct {
N        unsigned    DEBUG_INST_LSB_PC:         16;
N        unsigned    DEBUG_INST_MSB:            16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DEBUG_INST;
N
Ntypedef union
N{
N    struct {
N        unsigned    BREAK0_DONE:               1;
N        unsigned    BREAK1_DONE:               1;
N        unsigned    BREAK2_DONE:               1;
N        unsigned    BREAK3_DONE:               1;
N        unsigned    SDMA0_STAT:                1;
N        unsigned    SDMA1_STAT:                1;
N        unsigned    SDMA2_STAT:                1;
N        unsigned    SDMA3_STAT:                1;
N        unsigned    WDMA_STAT:                 1;
N        unsigned    RDMAS_STAT:                1;
N        unsigned    RESERVED:                  2;
N        unsigned    CACHE_STAT:                3;
N        unsigned    reserved:                  17;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DEBUG_STAT;
N
N
Ntypedef union
N{
N    struct {
N        unsigned    INST0_LSB_BREAK0:          16;
N        unsigned    INST0_MSB:                 16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DEBUG_BREAK0;
N
N
Ntypedef union
N{
N    struct {
N        unsigned    INST1_LSB_BREAK1:          16;
N        unsigned    INST1_MSB:                 16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DEBUG_BREAK1;
N
N
Ntypedef union
N{
N    struct {
N        unsigned    INST2_LSB_BREAK2:          16;
N        unsigned    INST2_MSB:                 16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DEBUG_BREAK2;
N
N
Ntypedef union
N{
N    struct {
N        unsigned    INST3_LSB_BREAK3:          16;
N        unsigned    INST3_MSB:                 16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DEBUG_BREAK3;
N
Ntypedef union
N{
N    struct {
N        unsigned    XSIZE0:                    8;
N        unsigned    XSIZE1:                    8;
N        unsigned    XSIZE2:                    8;
N        unsigned    XSIZE3:                    8;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DMA_XSIZE;
N
Ntypedef union
N{
N    struct {
N        unsigned    YSIZE0:                    8;
N        unsigned    YSIZE1:                    8;
N        unsigned    YSIZE2:                    8;
N        unsigned    YSIZE3:                    8;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_DMA_YSIZE;
N
N
Ntypedef struct
N{																	 //Index
N    __IO uint32_t                    TDSP_REGA0;                     //0x0000
X    volatile uint32_t                    TDSP_REGA0;                     
N    __IO uint32_t                    TDSP_REGA1;                     //0x0001
X    volatile uint32_t                    TDSP_REGA1;                     
N    __IO uint32_t                    TDSP_REGA2;                     //0x0002
X    volatile uint32_t                    TDSP_REGA2;                     
N    __IO uint32_t                    TDSP_REGA3;                     //0x0003
X    volatile uint32_t                    TDSP_REGA3;                     
N    __IO uint32_t                    TDSP_REGA4;                     //0x0004
X    volatile uint32_t                    TDSP_REGA4;                     
N    __IO uint32_t                    TDSP_REGA5;                     //0x0005
X    volatile uint32_t                    TDSP_REGA5;                     
N    __IO uint32_t                    TDSP_REGA6;                     //0x0006
X    volatile uint32_t                    TDSP_REGA6;                     
N    __IO uint32_t                    TDSP_REGA7;                     //0x0007
X    volatile uint32_t                    TDSP_REGA7;                     
N    __IO uint32_t                    TDSP_REGB0;                     //0x0008
X    volatile uint32_t                    TDSP_REGB0;                     
N    __IO uint32_t                    TDSP_REGB1;                     //0x0009
X    volatile uint32_t                    TDSP_REGB1;                     
N    __IO uint32_t                    TDSP_REGB2;                     //0x000A
X    volatile uint32_t                    TDSP_REGB2;                     
N    __IO uint32_t                    TDSP_REGB3;                     //0x000B
X    volatile uint32_t                    TDSP_REGB3;                     
N    __IO uint32_t                    TDSP_REGB4;                     //0x000C
X    volatile uint32_t                    TDSP_REGB4;                     
N    __IO uint32_t                    TDSP_REGB5;                     //0x000D
X    volatile uint32_t                    TDSP_REGB5;                     
N    __IO uint32_t                    TDSP_REGB6;                     //0x000E
X    volatile uint32_t                    TDSP_REGB6;                     
N    __IO uint32_t                    TDSP_REGB7;                     //0x000F
X    volatile uint32_t                    TDSP_REGB7;                     
N    __IO uint32_t                    TDSP_REGC0;                     //0x0010
X    volatile uint32_t                    TDSP_REGC0;                     
N    __IO uint32_t                    TDSP_REGC1;                     //0x0011
X    volatile uint32_t                    TDSP_REGC1;                     
N    __IO uint32_t                    TDSP_REGC2;                     //0x0012
X    volatile uint32_t                    TDSP_REGC2;                     
N    __IO uint32_t                    TDSP_REGC3;                     //0x0013
X    volatile uint32_t                    TDSP_REGC3;                     
N    __IO uint32_t                    TDSP_REGC4;                     //0x0014
X    volatile uint32_t                    TDSP_REGC4;                     
N    __IO uint32_t                    TDSP_REGC5;                     //0x0015
X    volatile uint32_t                    TDSP_REGC5;                     
N    __IO uint32_t                    TDSP_REGC6;                     //0x0016
X    volatile uint32_t                    TDSP_REGC6;                     
N    __IO uint32_t                    TDSP_REGC7;                     //0x0017
X    volatile uint32_t                    TDSP_REGC7;                     
N    __IO uint32_t                    TDSP_RESERVED00;                //0x0018
X    volatile uint32_t                    TDSP_RESERVED00;                
N    __IO uint32_t                    TDSP_RESERVED01;                //0x0019
X    volatile uint32_t                    TDSP_RESERVED01;                
N    __IO uint32_t                    TDSP_RESERVED02;                //0x001A
X    volatile uint32_t                    TDSP_RESERVED02;                
N    __IO uint32_t                    TDSP_RESERVED03;                //0x001B
X    volatile uint32_t                    TDSP_RESERVED03;                
N    __IO uint32_t                    TDSP_RESERVED04;                //0x001C
X    volatile uint32_t                    TDSP_RESERVED04;                
N    __IO uint32_t                    TDSP_RESERVED05;                //0x001D
X    volatile uint32_t                    TDSP_RESERVED05;                
N    __IO uint32_t                    TDSP_RESERVED06;                //0x001E
X    volatile uint32_t                    TDSP_RESERVED06;                
N    __IO uint32_t                    TDSP_RESERVED07;                //0x001F
X    volatile uint32_t                    TDSP_RESERVED07;                
N    __I  uint32_t                    TDSP_MEM0;                      //0x0020
X    volatile const  uint32_t                    TDSP_MEM0;                      
N    __IO uint32_t                    TDSP_RESERVED08;                //0x0021
X    volatile uint32_t                    TDSP_RESERVED08;                
N    __IO uint32_t                    TDSP_RESERVED09;                //0x0022
X    volatile uint32_t                    TDSP_RESERVED09;                
N    __IO uint32_t                    TDSP_RESERVED10;                //0x0023
X    volatile uint32_t                    TDSP_RESERVED10;                
N    __I  uint32_t                    TDSP_STATUS;                    //0x0024
X    volatile const  uint32_t                    TDSP_STATUS;                    
N    __IO uint32_t                    TDSP_RESERVED11;                //0x0025
X    volatile uint32_t                    TDSP_RESERVED11;                
N    __IO uint32_t                    TDSP_RESERVED12;                //0x0026
X    volatile uint32_t                    TDSP_RESERVED12;                
N    __IO uint32_t                    TDSP_RESERVED13;                //0x0027
X    volatile uint32_t                    TDSP_RESERVED13;                
N    __IO uint32_t                    TDSP_RESERVED14;                //0x0028
X    volatile uint32_t                    TDSP_RESERVED14;                
N    __IO uint32_t                    TDSP_RESERVED15;                //0x0029
X    volatile uint32_t                    TDSP_RESERVED15;                
N    __IO uint32_t                    TDSP_RESERVED16;                //0x002A
X    volatile uint32_t                    TDSP_RESERVED16;                
N    __IO uint32_t                    TDSP_RESERVED17;                //0x002B
X    volatile uint32_t                    TDSP_RESERVED17;                
N    __IO uint32_t                    TDSP_RESERVED18;                //0x002C
X    volatile uint32_t                    TDSP_RESERVED18;                
N    __IO uint32_t                    TDSP_RESERVED19;                //0x002D
X    volatile uint32_t                    TDSP_RESERVED19;                
N    __IO uint32_t                    TDSP_RESERVED20;                //0x002E
X    volatile uint32_t                    TDSP_RESERVED20;                
N    __IO uint32_t                    TDSP_RESERVED21;                //0x002F
X    volatile uint32_t                    TDSP_RESERVED21;                
N    __IO uint32_t                    TDSP_RESERVED22;                //0x0030
X    volatile uint32_t                    TDSP_RESERVED22;                
N    __IO uint32_t                    TDSP_RESERVED23;                //0x0031
X    volatile uint32_t                    TDSP_RESERVED23;                
N    __IO uint32_t                    TDSP_RESERVED24;                //0x0032
X    volatile uint32_t                    TDSP_RESERVED24;                
N    __IO uint32_t                    TDSP_RESERVED25;                //0x0033
X    volatile uint32_t                    TDSP_RESERVED25;                
N    __IO uint32_t                    TDSP_RESERVED26;                //0x0034
X    volatile uint32_t                    TDSP_RESERVED26;                
N    __IO uint32_t                    TDSP_RESERVED27;                //0x0035
X    volatile uint32_t                    TDSP_RESERVED27;                
N    __IO uint32_t                    TDSP_RESERVED28;                //0x0036
X    volatile uint32_t                    TDSP_RESERVED28;                
N    __IO uint32_t                    TDSP_RESERVED29;                //0x0037
X    volatile uint32_t                    TDSP_RESERVED29;                
N    __IO uint32_t                    TDSP_RESERVED30;                //0x0038
X    volatile uint32_t                    TDSP_RESERVED30;                
N    __IO uint32_t                    TDSP_RESERVED31;                //0x0039
X    volatile uint32_t                    TDSP_RESERVED31;                
N    __IO uint32_t                    TDSP_RESERVED32;                //0x003A
X    volatile uint32_t                    TDSP_RESERVED32;                
N    __IO uint32_t                    TDSP_RESERVED33;                //0x003B
X    volatile uint32_t                    TDSP_RESERVED33;                
N    __IO uint32_t                    TDSP_RESERVED34;                //0x003C
X    volatile uint32_t                    TDSP_RESERVED34;                
N    __IO uint32_t                    TDSP_RESERVED35;                //0x003D
X    volatile uint32_t                    TDSP_RESERVED35;                
N    __IO uint32_t                    TDSP_RESERVED36;                //0x003E
X    volatile uint32_t                    TDSP_RESERVED36;                
N    __IO uint32_t                    TDSP_RESERVED37;                //0x003F
X    volatile uint32_t                    TDSP_RESERVED37;                
N    __IO uint32_t                    TDSP_PC;                        //0x0040
X    volatile uint32_t                    TDSP_PC;                        
N    __I  uint32_t                    TDSP_LINK0;                     //0x0041
X    volatile const  uint32_t                    TDSP_LINK0;                     
N    __I  uint32_t                    TDSP_LINK1;                     //0x0042
X    volatile const  uint32_t                    TDSP_LINK1;                     
N    __I  uint32_t                    TDSP_LINK2;                     //0x0043
X    volatile const  uint32_t                    TDSP_LINK2;                     
N    __I  uint32_t                    TDSP_LINK3;                     //0x0044
X    volatile const  uint32_t                    TDSP_LINK3;                     
N    __I  uint32_t                    TDSP_LINK4;                     //0x0045
X    volatile const  uint32_t                    TDSP_LINK4;                     
N    __I  uint32_t                    TDSP_LCNT0;                     //0x0046
X    volatile const  uint32_t                    TDSP_LCNT0;                     
N    __I  uint32_t                    TDSP_LCNT1;                     //0x0047
X    volatile const  uint32_t                    TDSP_LCNT1;                     
N    __I  uint32_t                    TDSP_LCNT2;                     //0x0048
X    volatile const  uint32_t                    TDSP_LCNT2;                     
N    __I  uint32_t                    TDSP_BUSY;                      //0x0049
X    volatile const  uint32_t                    TDSP_BUSY;                      
N    __IO uint32_t                    TDSP_BASEADD;                   //0x004A
X    volatile uint32_t                    TDSP_BASEADD;                   
N    __IO uint32_t                    TDSP_BURST;                     //0x004B
X    volatile uint32_t                    TDSP_BURST;                     
N    __IO t_CYCLE_DIV           	     TDSP_CYCLE_DIV;                 //0x004C
X    volatile t_CYCLE_DIV           	     TDSP_CYCLE_DIV;                 
N    __IO t_CYCLE_MUL           		 TDSP_CYCLE_MUL;                 //0x004D
X    volatile t_CYCLE_MUL           		 TDSP_CYCLE_MUL;                 
N    __O  t_INTERRUPT           		 TDSP_INTERRUPT;                 //0x004E
X    volatile  t_INTERRUPT           		 TDSP_INTERRUPT;                 
N    __IO t_DEBUG_CON           		 TDSP_DEBUG_CON;                 //0x004F
X    volatile t_DEBUG_CON           		 TDSP_DEBUG_CON;                 
N    __I  t_DEBUG_INST           	 TDSP_DEBUG_INST;                //0x0050
X    volatile const  t_DEBUG_INST           	 TDSP_DEBUG_INST;                
N    __I  t_DEBUG_STAT           	 TDSP_DEBUG_STAT;                //0x0051
X    volatile const  t_DEBUG_STAT           	 TDSP_DEBUG_STAT;                
N    __IO t_DEBUG_BREAK0    			 TDSP_DEBUG_BREAK0;              //0x0052
X    volatile t_DEBUG_BREAK0    			 TDSP_DEBUG_BREAK0;              
N    __IO t_DEBUG_BREAK1    			 TDSP_DEBUG_BREAK1;              //0x0053
X    volatile t_DEBUG_BREAK1    			 TDSP_DEBUG_BREAK1;              
N    __IO t_DEBUG_BREAK2    			 TDSP_DEBUG_BREAK2;              //0x0054
X    volatile t_DEBUG_BREAK2    			 TDSP_DEBUG_BREAK2;              
N    __IO t_DEBUG_BREAK3    			 TDSP_DEBUG_BREAK3;              //0x0055
X    volatile t_DEBUG_BREAK3    			 TDSP_DEBUG_BREAK3;              
N    __IO uint32_t                    TDSP_RESERVED38;                //0x0056
X    volatile uint32_t                    TDSP_RESERVED38;                
N    __IO uint32_t                    TDSP_RESERVED39;                //0x0057
X    volatile uint32_t                    TDSP_RESERVED39;                
N    __IO uint32_t                    TDSP_RESERVED40;                //0x0058
X    volatile uint32_t                    TDSP_RESERVED40;                
N    __IO uint32_t                    TDSP_RESERVED41;                //0x0059
X    volatile uint32_t                    TDSP_RESERVED41;                
N    __IO uint32_t                    TDSP_RESERVED42;                //0x005A
X    volatile uint32_t                    TDSP_RESERVED42;                
N    __IO uint32_t                    TDSP_RESERVED43;                //0x005B
X    volatile uint32_t                    TDSP_RESERVED43;                
N    __IO uint32_t                    TDSP_RESERVED44;                //0x005C
X    volatile uint32_t                    TDSP_RESERVED44;                
N    __IO uint32_t                    TDSP_RESERVED45;                //0x005D
X    volatile uint32_t                    TDSP_RESERVED45;                
N    __IO uint32_t                    TDSP_RESERVED46;                //0x005E
X    volatile uint32_t                    TDSP_RESERVED46;                
N    __IO uint32_t                    TDSP_RESERVED47;                //0x005F
X    volatile uint32_t                    TDSP_RESERVED47;                
N    __IO uint32_t                    TDSP_CACHE_DATA0;               //0x0060
X    volatile uint32_t                    TDSP_CACHE_DATA0;               
N    __IO uint32_t                    TDSP_CACHE_DATA1;               //0x0061
X    volatile uint32_t                    TDSP_CACHE_DATA1;               
N    __IO uint32_t                    TDSP_CACHE_DATA2;               //0x0062
X    volatile uint32_t                    TDSP_CACHE_DATA2;               
N    __IO uint32_t                    TDSP_CACHE_DATA3;               //0x0063
X    volatile uint32_t                    TDSP_CACHE_DATA3;               
N    __IO uint32_t                    TDSP_CACHE_DATA4;               //0x0064
X    volatile uint32_t                    TDSP_CACHE_DATA4;               
N    __IO uint32_t                    TDSP_CACHE_DATA5;               //0x0065
X    volatile uint32_t                    TDSP_CACHE_DATA5;               
N    __IO uint32_t                    TDSP_CACHE_DATA6;               //0x0066
X    volatile uint32_t                    TDSP_CACHE_DATA6;               
N    __IO uint32_t                    TDSP_CACHE_DATA7;               //0x0067
X    volatile uint32_t                    TDSP_CACHE_DATA7;               
N    __IO uint32_t                    TDSP_CACHE_DATA8;               //0x0068
X    volatile uint32_t                    TDSP_CACHE_DATA8;               
N    __IO uint32_t                    TDSP_CACHE_DATA9;               //0x0069
X    volatile uint32_t                    TDSP_CACHE_DATA9;               
N    __IO uint32_t                    TDSP_CACHE_DATA10;              //0x006A
X    volatile uint32_t                    TDSP_CACHE_DATA10;              
N    __IO uint32_t                    TDSP_CACHE_DATA11;              //0x006B
X    volatile uint32_t                    TDSP_CACHE_DATA11;              
N    __IO uint32_t                    TDSP_CACHE_DATA12;              //0x006C
X    volatile uint32_t                    TDSP_CACHE_DATA12;              
N    __IO uint32_t                    TDSP_CACHE_DATA13;              //0x006D
X    volatile uint32_t                    TDSP_CACHE_DATA13;              
N    __IO uint32_t                    TDSP_CACHE_DATA14;              //0x006E
X    volatile uint32_t                    TDSP_CACHE_DATA14;              
N    __IO uint32_t                    TDSP_CACHE_DATA15;              //0x006F
X    volatile uint32_t                    TDSP_CACHE_DATA15;              
N    __IO uint32_t                    TDSP_CACHE_DATA16;              //0x0070
X    volatile uint32_t                    TDSP_CACHE_DATA16;              
N    __IO uint32_t                    TDSP_CACHE_DATA17;              //0x0071
X    volatile uint32_t                    TDSP_CACHE_DATA17;              
N    __IO uint32_t                    TDSP_CACHE_DATA18;              //0x0072
X    volatile uint32_t                    TDSP_CACHE_DATA18;              
N    __IO uint32_t                    TDSP_CACHE_DATA19;              //0x0073
X    volatile uint32_t                    TDSP_CACHE_DATA19;              
N    __IO uint32_t                    TDSP_CACHE_DATA20;              //0x0074
X    volatile uint32_t                    TDSP_CACHE_DATA20;              
N    __IO uint32_t                    TDSP_CACHE_DATA21;              //0x0075
X    volatile uint32_t                    TDSP_CACHE_DATA21;              
N    __IO uint32_t                    TDSP_CACHE_DATA22;              //0x0076
X    volatile uint32_t                    TDSP_CACHE_DATA22;              
N    __IO uint32_t                    TDSP_CACHE_DATA23;              //0x0077
X    volatile uint32_t                    TDSP_CACHE_DATA23;              
N    __IO uint32_t                    TDSP_CACHE_DATA24;              //0x0078
X    volatile uint32_t                    TDSP_CACHE_DATA24;              
N    __IO uint32_t                    TDSP_CACHE_DATA25;              //0x0079
X    volatile uint32_t                    TDSP_CACHE_DATA25;              
N    __IO uint32_t                    TDSP_CACHE_DATA26;              //0x007A
X    volatile uint32_t                    TDSP_CACHE_DATA26;              
N    __IO uint32_t                    TDSP_CACHE_DATA27;              //0x007B
X    volatile uint32_t                    TDSP_CACHE_DATA27;              
N    __IO uint32_t                    TDSP_CACHE_DATA28;              //0x007C
X    volatile uint32_t                    TDSP_CACHE_DATA28;              
N    __IO uint32_t                    TDSP_CACHE_DATA29;              //0x007D
X    volatile uint32_t                    TDSP_CACHE_DATA29;              
N    __IO uint32_t                    TDSP_CACHE_DATA30;              //0x007E
X    volatile uint32_t                    TDSP_CACHE_DATA30;              
N    __IO uint32_t                    TDSP_CACHE_DATA31;              //0x007F
X    volatile uint32_t                    TDSP_CACHE_DATA31;              
N    __IO t_DMA_XSIZE            	 TDSP_DMA_XSIZE;				 //0x0080
X    volatile t_DMA_XSIZE            	 TDSP_DMA_XSIZE;				 
N    __IO t_DMA_YSIZE            	 TDSP_DMA_YSIZE;                 //0x0081
X    volatile t_DMA_YSIZE            	 TDSP_DMA_YSIZE;                 
N    __IO uint32_t                    TDSP_DMA_ADD;                  //0x0082
X    volatile uint32_t                    TDSP_DMA_ADD;                  
N} tDSPB_CtrlReg_t;
N
N
N#endif /* __DSPB_H_ */
L 252 "..\..\Hal\system\MFTP.h" 2
N#include "_pwmdrv.h"
L 1 "..\..\Hal\pwmdrv\_pwmdrv.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _pwmdrv.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __PWMDRV_H_
N#define __PWMDRV_H_
N
N
N#include "_pwmdrv_param.h"
L 1 "..\..\Hal\pwmdrv\_pwmdrv_param.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _pwmdrv_param.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __PWMDRV_PARAM_H_
N#define __PWMDRV_PARAM_H_
N
N/*
N * defines
N *
N * */
N
Ntypedef enum {
N	PWM_PARAM_FINGER = 0,
N	PWM_PARAM_PEN = 1,
N	PWM_PARAM_MAX,
N
N} ePwmParamOpMode;
N
N/*
N * typedef
N *
N * */
Ntypedef union
N{
N    struct {
N        unsigned    pwm_gen_enable:            1;
N        unsigned    kiosk_mode:                1;
N        unsigned    tfd_mode:                  1;
N        unsigned    continuos_en:              1;
N        unsigned    frame_rate:                2;
N        unsigned    chip_length0:              5;
N        unsigned    chip_length1:              5;
N        unsigned    frame_intr_sel:            1;
N        unsigned    pen_mode:                  1;
N        unsigned    offclk_ctrl_tpic:          1;
N        unsigned    offclk_ctrl_sric:          1;
N        unsigned    offclk_ctrl_mux:           1;
N        unsigned    offclk_ctrl_vgh:           1;
N        unsigned    offclk_ctrl_gma:           1;
N        unsigned    offclk_ctrl_en:            1;
N        unsigned    pwm_sric_output_en:        1;
N        unsigned    pwm_tpic_output_en:        1;
N        unsigned    pwm_mux_output_en:         1;
N        unsigned    pwm_vgh_output_en:         1;
N        unsigned    pwm_gma_output_en:         1;
N        unsigned    reserved:                  3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWMGEN_CR0_t;
X} __attribute__ ((packed)) tCP_PWMGEN_CR0_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    fstart_en:                 1;
N        unsigned    skip_num:                  5;
N        unsigned    beacon_data_num:           4;
N        unsigned    sric_dummy_num:            6;
N        unsigned    tpic_dummy_num:            6;
N        unsigned    dummy_gap_en:              1;
N        unsigned    pgap_en:                   1;
N        unsigned    pen_s_pwmnum:              7;
N        unsigned    reserved:                  1;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWMGEN_CR1_t;
X} __attribute__ ((packed)) tCP_PWMGEN_CR1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_d_pwmnum:              7;
N        unsigned    finger_pwmnum:             7;
N        unsigned    nm_num:                    7;
N        unsigned    total_mux_num:             6;
N        unsigned    reserved:                  5;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWMGEN_CR2_t;
X} __attribute__ ((packed)) tCP_PWMGEN_CR2_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    set_tx_en:                 1;
N        unsigned    set_tx_num:                7;
N        unsigned    reserved:                  24;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SET_TX_CR_t;
X} __attribute__ ((packed)) tCP_SET_TX_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    tsync_num:                 5;
N        unsigned    tsync_end_loc:             1;
N        unsigned    tsync_dglitch_len:         3;
N        unsigned    tsynct_in_sel:             1;
N        unsigned    tsynct_in_inv:             1;
N        unsigned    tsynct_out_inv:            1;
N        unsigned    tsync_sric_in_sel:         1;
N        unsigned    tsync_sric_out_sel:        1;
N        unsigned    tsync_sric_in_inv:         1;
N        unsigned    tsync_sric_out_inv:        1;
N        unsigned    tsynct2_in_sel:            1;
N        unsigned    tsynct2_in_inv:            1;
N        unsigned    tsynct_kiosk_in_sel:       1;
N        unsigned    tsync_sric_redge_sel:      1;		//	ToDo: Added by register map
N        unsigned    tsync_sric_fedge_sel:      1;		//	ToDo: Added by register map
N        unsigned    reserved:                  11;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_TSYNC_CR_t;
X} __attribute__ ((packed)) tCP_TSYNC_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    nm_en:                     1;
N        unsigned    none_en:                   1;
N        unsigned    st_pnt:                    12;
N        unsigned    end_pnt:                   10;
N        unsigned    kiosk_sgap_end:            1;
N        unsigned    kiosk_pwm_end:             1;
N        unsigned    kiosk_tch_time_end:        1;
N        unsigned    reserved:                  1;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_TSYNC_D2_CR_t;
X} __attribute__ ((packed)) tCP_TSYNC_D2_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    sgap_prd:                  14;
N        unsigned    ping_prd:                  11;
N        unsigned    reserved:                  7;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DLY_CNT1_t;
X} __attribute__ ((packed)) tCP_DLY_CNT1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    mgap_prd_f:                10;
N        unsigned    mgap_prd_p_s:              10;
N        unsigned    mgap_prd_p_d:              10;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DLY_CNT2_t;
X} __attribute__ ((packed)) tCP_DLY_CNT2_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    egap_prd:                  14;
N        unsigned    dgap_prd:                  10;
N        unsigned    offclk_dly:                6;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DLY_CNT3_t;
X} __attribute__ ((packed)) tCP_DLY_CNT3_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    nm_en:                     1;
N        unsigned    none_en:                   1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_pwm_en:              1;
N        unsigned    pen_d_pwm_en:              1;
N        unsigned    finger_pwm_en:             1;
N        unsigned    ping_only_en:              1;
N        unsigned    delay:                     12;
N        unsigned    kiosk_tch_time_end_off:    1;
N        unsigned    reserved:                  6;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_TSYNC_TPIC_CR_t;
X} __attribute__ ((packed)) tCP_TSYNC_TPIC_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_sric_f:                10;
N        unsigned    pwm_tpic_f:                10;
N        unsigned    pwm_mux_f:                 10;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_DLY1_t;
X} __attribute__ ((packed)) tCP_PWM_DLY1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    ping_finger:               5;
N        unsigned    ping_pen_pos:              5;
N        unsigned    ping_pen_dat:              5;
N        unsigned    reserved:                  17;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DSSS_INFO0_t;
X} __attribute__ ((packed)) tCP_DSSS_INFO0_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_cfg0:               5;
N        unsigned    beacon_cfg1:               5;
N        unsigned    beacon_cfg2:               5;
N        unsigned    beacon_cfg3:               5;
N        unsigned    beacon_cfg4:               5;
N        unsigned    beacon_cfg5:               5;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DSSS_INFO1_t;
X} __attribute__ ((packed)) tCP_DSSS_INFO1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_cfg6:               5;
N        unsigned    beacon_cfg7:               5;
N        unsigned    beacon_cfg8:               5;
N        unsigned    beacon_cfg9:               5;
N        unsigned    beacon_cfg10:              5;
N        unsigned    beacon_cfg11:              5;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DSSS_INFO2_t;
X} __attribute__ ((packed)) tCP_DSSS_INFO2_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    pen_s_dmy_en:              1;
N        unsigned    pen_d_dmy_en:              1;
N        unsigned    finger_dmy_en:             1;
N        unsigned    pen_s_set_tx_en:           1;
N        unsigned    pen_d_set_tx_en:           1;
N        unsigned    finger_set_tx_en:          1;
N        unsigned    nm_en:                     1;
N        unsigned    inv_en:                    1;
N        unsigned    ping_only_en:              1;
N        unsigned    reserved:                  16;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_TPIC_CR_t;
X} __attribute__ ((packed)) tCP_PWM_TPIC_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    pen_s_dmy_en:              1;
N        unsigned    pen_d_dmy_en:              1;
N        unsigned    finger_dmy_en:             1;
N        unsigned    pen_s_set_tx_en:           1;
N        unsigned    pen_d_set_tx_en:           1;
N        unsigned    finger_set_tx_en:          1;
N        unsigned    nm_en:                     1;
N        unsigned    inv_en:                    1;
N        unsigned    pwm_2x_en:                 1;
N        unsigned    pen_s_tsync_d2_en:         1;
N        unsigned    pen_d_tsync_d2_en:         1;
N        unsigned    finger_tsync_d2_en:        1;
N        unsigned    ping_only_en:              1;
N        unsigned    reserved:                  12;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_SRIC_CR_t;
X} __attribute__ ((packed)) tCP_PWM_SRIC_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    pen_s_dmy_en:              1;
N        unsigned    pen_d_dmy_en:              1;
N        unsigned    finger_dmy_en:             1;
N        unsigned    pen_s_set_tx_en:           1;
N        unsigned    pen_d_set_tx_en:           1;
N        unsigned    finger_set_tx_en:          1;
N        unsigned    nm_en:                     1;
N        unsigned    inv_en:                    1;
N        unsigned    ping_only_en:              1;
N        unsigned    reserved:                  16;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_MUX_CR_t;
X} __attribute__ ((packed)) tCP_PWM_MUX_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    eclk_en:                   1;
N        unsigned    eclk0_inv_en:              1;
N        unsigned    eclk1_inv_en:              1;
N        unsigned    eclk_div_en:               1;		//	ToDo: Added by register map
N        unsigned    div_num:                   5;
N        unsigned    eclk_force_on:             1;
N        unsigned    eclk_en_src0:              1;		//	ToDo: Modified by register map
N        unsigned    eclk_en_src1:              1;		//	ToDo: Added by register map
N        unsigned    eclk_en_pnt:               9;
N        unsigned    reserved:                  11;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_ECLK_CR_t;
X} __attribute__ ((packed)) tCP_ECLK_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_d:                     10;
N        unsigned    pen_s:                     10;
N        unsigned    finger:                    10;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_FREQ_CR1_t;
X} __attribute__ ((packed)) tCP_FREQ_CR1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    freq_beacon:               8;
N        unsigned    reserved:                  24;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_FREQ_CR2_t;
X} __attribute__ ((packed)) tCP_FREQ_CR2_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb1:                      3;
N        unsigned    lhb2:                      3;
N        unsigned    lhb3:                      3;
N        unsigned    lhb4:                      3;
N        unsigned    lhb5:                      3;
N        unsigned    lhb6:                      3;
N        unsigned    lhb7:                      3;
N        unsigned    lhb8:                      3;
N        unsigned    lhb9:                      3;
N        unsigned    lhb10:                     3;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG11_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG11_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb11:                     3;
N        unsigned    lhb12:                     3;
N        unsigned    lhb13:                     3;
N        unsigned    lhb14:                     3;
N        unsigned    lhb15:                     3;
N        unsigned    lhb16:                     3;
N        unsigned    lhb17:                     3;
N        unsigned    lhb18:                     3;
N        unsigned    lhb19:                     3;
N        unsigned    lhb20:                     3;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG12_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG12_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb21:                     3;
N        unsigned    lhb22:                     3;
N        unsigned    lhb23:                     3;
N        unsigned    lhb24:                     3;
N        unsigned    lhb25:                     3;
N        unsigned    lhb26:                     3;
N        unsigned    lhb27:                     3;
N        unsigned    lhb28:                     3;
N        unsigned    lhb29:                     3;
N        unsigned    lhb30:                     3;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG13_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG13_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb31:                     3;
N        unsigned    lhb32:                     3;
N        unsigned    reserved:                  26;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG14_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG14_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb1:                      3;
N        unsigned    lhb2:                      3;
N        unsigned    lhb3:                      3;
N        unsigned    lhb4:                      3;
N        unsigned    lhb5:                      3;
N        unsigned    lhb6:                      3;
N        unsigned    lhb7:                      3;
N        unsigned    lhb8:                      3;
N        unsigned    lhb9:                      3;
N        unsigned    lhb10:                     3;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG21_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG21_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb11:                     3;
N        unsigned    lhb12:                     3;
N        unsigned    lhb13:                     3;
N        unsigned    lhb14:                     3;
N        unsigned    lhb15:                     3;
N        unsigned    lhb16:                     3;
N        unsigned    lhb17:                     3;
N        unsigned    lhb18:                     3;
N        unsigned    lhb19:                     3;
N        unsigned    lhb20:                     3;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG22_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG22_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb21:                     3;
N        unsigned    lhb22:                     3;
N        unsigned    lhb23:                     3;
N        unsigned    lhb24:                     3;
N        unsigned    lhb25:                     3;
N        unsigned    lhb26:                     3;
N        unsigned    lhb27:                     3;
N        unsigned    lhb28:                     3;
N        unsigned    lhb29:                     3;
N        unsigned    lhb30:                     3;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG23_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG23_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb31:                     3;
N        unsigned    lhb32:                     3;
N        unsigned    reserved:                  26;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_LHB_CONFIG24_t;
X} __attribute__ ((packed)) tCP_LHB_CONFIG24_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon:                    1;
N        unsigned    pen_s:                     1;
N        unsigned    pen_d:                     1;
N        unsigned    finger:                    1;
N        unsigned    nm:                        1;
N        unsigned    none:                      1;
N        unsigned    ping_only:                 1;
N        unsigned    reserved:                  25;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PING_CR_t;
X} __attribute__ ((packed)) tCP_PING_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    sync_gen_en:               1;
N        unsigned    vsync_stuck_en:            1;
N        unsigned    vsync_stuck_level:         1;
N        unsigned    tsynct_stuck_en:           1;
N        unsigned    tsynct_stuck_level:        1;
N        unsigned    tsyncd_stuck_en:           1;
N        unsigned    tsyncd_stuck_level:        1;
N        unsigned    reserved:                  25;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SYNC_GEN_CR_t;
X} __attribute__ ((packed)) tCP_SYNC_GEN_CR_t;
N
N//typedef union
N//{
N//    struct {
N//        unsigned    busy:                      1;
N//        unsigned    state:                     4;
N//        unsigned    reserved:                  27;
N//    } __PACKED tBit;
N//    __IO uint32_t ulBulk;
N//} __PACKED tCP_TE_STATUS_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    tsync_tpic_out_bypass_enb:	1;
N        unsigned    tsync_sric_out_bypass_enb:	1;
N        unsigned    tsync_sric_lhb_ping_en:		1;
N        unsigned    sync_gen_fr_done_mask_en:	1;
N        unsigned    disp_off_beacon_only:		1;
N        unsigned    reserved:                  27;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_TG_DUM5_t;
X} __attribute__ ((packed)) tCP_TG_DUM5_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    stuck_en:                  1;
N        unsigned    stuck_value:               1;
N        unsigned    disp_off_fpnt:             14;
N        unsigned    inv_en:                    1;
N        unsigned    disp_off_en:               1;		//	ToDo: Added by register map
N        unsigned    reserved:                  14;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DISP_OFF_CR_t;
X} __attribute__ ((packed)) tCP_DISP_OFF_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_s_h_pnt:               10;
N        unsigned    pen_d_h_pnt:               10;
N        unsigned    reserved:                  12;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_CR1_t;
X} __attribute__ ((packed)) tCP_PWM_CR1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    finger_h_pnt:              10;
N        unsigned    dmy_h_pnt:                 10;
N        unsigned    reserved:                  12;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_CR2_t;
X} __attribute__ ((packed)) tCP_PWM_CR2_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    vsync_in_inv:              1;
N        unsigned    vsync_in_sel:              1;
N        unsigned    vsync_locate:              5;
N        unsigned    rising_pnt:                10;
N        unsigned    falling_pnt:               10;
N        unsigned    vsync_kiosk_in_sel:        1;
N        unsigned    gst_in_inv: 		       1;		//	ToDo: Added by register map
N        unsigned    reserved:                  3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_VSYNC_CR_t;
X} __attribute__ ((packed)) tCP_VSYNC_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_s:                     6;
N        unsigned    pen_d:                     6;
N        unsigned    finger:                    6;
N        unsigned    nm:                        2;
N        unsigned    reserved:                  12;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_MUX_CR_t;
X} __attribute__ ((packed)) tCP_MUX_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_stuck:              1;
N        unsigned    pen_s_ping_stuck:          1;
N        unsigned    pen_d_ping_stuck:          1;
N        unsigned    finger_ping_stuck:         1;
N        unsigned    pen_s_stuck:               1;
N        unsigned    pen_d_stuck:               1;
N        unsigned    finger_stuck:              1;
N        unsigned    pen_s_dmy_stuck:           1;
N        unsigned    pen_d_dmy_stuck:           1;
N        unsigned    finger_dmy_stuck:          1;
N        unsigned    pen_s_set_tx_stuck:        1;
N        unsigned    pen_d_set_tx_stuck:        1;
N        unsigned    finger_set_tx_stuck:       1;
N        unsigned    nm_stuck:                  1;
N        unsigned    reserved:                  18;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_TPIC_ST_CR_t;
X} __attribute__ ((packed)) tCP_PWM_TPIC_ST_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_stuck:              1;
N        unsigned    pen_s_ping_stuck:          1;
N        unsigned    pen_d_ping_stuck:          1;
N        unsigned    finger_ping_stuck:         1;
N        unsigned    pen_s_stuck:               1;
N        unsigned    pen_d_stuck:               1;
N        unsigned    finger_stuck:              1;
N        unsigned    pen_s_dmy_stuck:           1;
N        unsigned    pen_d_dmy_stuck:           1;
N        unsigned    finger_dmy_stuck:          1;
N        unsigned    pen_s_set_tx_stuck:        1;
N        unsigned    pen_d_set_tx_stuck:        1;
N        unsigned    finger_set_tx_stuck:       1;
N        unsigned    nm_stuck:                  1;
N        unsigned    reserved:                  18;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_SRIC_ST_CR_t;
X} __attribute__ ((packed)) tCP_PWM_SRIC_ST_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_stuck:              1;
N        unsigned    pen_s_ping_stuck:          1;
N        unsigned    pen_d_ping_stuck:          1;
N        unsigned    finger_ping_stuck:         1;
N        unsigned    pen_s_stuck:               1;
N        unsigned    pen_d_stuck:               1;
N        unsigned    finger_stuck:              1;
N        unsigned    pen_s_dmy_stuck:           1;
N        unsigned    pen_d_dmy_stuck:           1;
N        unsigned    finger_dmy_stuck:          1;
N        unsigned    pen_s_set_tx_stuck:        1;
N        unsigned    pen_d_set_tx_stuck:        1;
N        unsigned    finger_set_tx_stuck:       1;
N        unsigned    nm_stuck:                  1;
N        unsigned    reserved:                  18;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_MUX_ST_CR_t;
X} __attribute__ ((packed)) tCP_PWM_MUX_ST_CR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    freq_nm1:                  10;
N        unsigned    freq_nm2:                  10;
N        unsigned    freq_nm3:                  10;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_NM_FREQ_t;
X} __attribute__ ((packed)) tCP_NM_FREQ_t;
N
N//typedef union
N//{
N//    struct {
N//        unsigned    state:                     5;
N//        unsigned    tsync_cnt:                 5;
N//        unsigned    lhb_drv:                   3;
N//        unsigned    mux_cnt:                   6;
N//        unsigned    reserved:                  13;
N//    } __PACKED tBit;
N//    __IO uint32_t ulBulk;
N//} __PACKED tCP_PWM_STATUS_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_vgh_f:                 10;
N        unsigned    pwm_gma_f:                 10;
N        unsigned    reserved:                  12;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_DLY2_t;
X} __attribute__ ((packed)) tCP_PWM_DLY2_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    bgap_prd:                  11;
N        unsigned    bc_egap_prd:               13;
N        unsigned    reserved:                  8;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_DLY_CNT4_t;
X} __attribute__ ((packed)) tCP_DLY_CNT4_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_sric_p:                10;
N        unsigned    pwm_tpic_p:                10;
N        unsigned    pwm_mux_p:                 10;
N        unsigned    reserved:                  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_DLY3_t;
X} __attribute__ ((packed)) tCP_PWM_DLY3_t;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_vgh_p:                 10;
N        unsigned    pwm_gma_p:                 10;
N        unsigned    reserved:                  12;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_PWM_DLY4_t;
X} __attribute__ ((packed)) tCP_PWM_DLY4_t;
N
N//typedef union
N//{
N//    struct {
N//        unsigned    mgap_prd_f_1:              4;
N//        unsigned    mgap_prd_p_s_1:            4;
N//        unsigned    mgap_prd_p_d_1:            4;
N//        unsigned    reserved:                  20;
N//    } __PACKED tBit;
N//    __IO uint32_t ulBulk;
N//} __PACKED tCP_DLY_CNT5_t;
N
Ntypedef struct
N{
N    uint32_t tCP_DSSS_CODE_P_0; //0x000E
N    uint32_t tCP_DSSS_CODE_P_1; //0x000F
N    uint32_t tCP_DSSS_CODE_0_0; //0x0010
N    uint32_t tCP_DSSS_CODE_0_1; //0x0011
N    uint32_t tCP_DSSS_CODE_1_0; //0x0012
N    uint32_t tCP_DSSS_CODE_1_1; //0x0013
N    uint32_t tCP_DSSS_CODE_2_0; //0x0014
N    uint32_t tCP_DSSS_CODE_2_1; //0x0015
N    uint32_t tCP_DSSS_CODE_3_0; //0x0016
N    uint32_t tCP_DSSS_CODE_3_1; //0x0017
N    uint32_t tCP_DSSS_CODE_4_0; //0x0018
N    uint32_t tCP_DSSS_CODE_4_1; //0x0019
N    uint32_t tCP_DSSS_CODE_5_0; //0x001A
N    uint32_t tCP_DSSS_CODE_5_1; //0x001B
N    uint32_t tCP_DSSS_CODE_6_0; //0x001C
N    uint32_t tCP_DSSS_CODE_6_1; //0x001D
N    uint32_t tCP_DSSS_CODE_7_0; //0x001E
N    uint32_t tCP_DSSS_CODE_7_1; //0x001F
N
N} __PACKED tCP_DSSS_CODE_Value_t;
X} __attribute__ ((packed)) tCP_DSSS_CODE_Value_t;
N
N/*
N *
N * Sample structure
Ntypedef union
N{
N	struct {
N
N	} __PACKED tBit;
N
N	__IO uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_2_t;
N*/
N#endif /* __PWMDRV_PARAM_H_ */
L 38 "..\..\Hal\pwmdrv\_pwmdrv.h" 2
N/* ================================================================================ */
N/* ================                      PWMDRV                    ================ */
N/* ================================================================================ */
Ntypedef union
N{
N    struct {
N        unsigned    pwm_gen_enable:            1;
N        unsigned    kiosk_mode:                1;
N        unsigned    tfd_mode:                  1;
N        unsigned    continuos_en:              1;
N        unsigned    frame_rate:                2;
N        unsigned    chip_length0:              5;
N        unsigned    chip_length1:              5;
N        unsigned    frame_intr_sel:            1;
N        unsigned    pen_mode:                  1;
N        unsigned    offclk_ctrl_tpic:          1;
N        unsigned    offclk_ctrl_sric:          1;
N        unsigned    offclk_ctrl_mux:           1;
N        unsigned    offclk_ctrl_vgh:           1;
N        unsigned    offclk_ctrl_gma:           1;
N        unsigned    offclk_ctrl_en:            1;
N        unsigned    pwm_sric_output_en:        1;
N        unsigned    pwm_tpic_output_en:        1;
N        unsigned    pwm_mux_output_en:         1;
N        unsigned    pwm_vgh_output_en:         1;
N        unsigned    pwm_gma_output_en:         1;
N        unsigned    reserved:                  3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWMGEN_CR0;
N
Ntypedef union
N{
N    struct {
N        unsigned    fstart_en:                 1;
N        unsigned    skip_num:                  5;
N        unsigned    beacon_data_num:           4;
N        unsigned    sric_dummy_num:            6;
N        unsigned    tpic_dummy_num:            6;
N        unsigned    dummy_gap_en:              1;
N        unsigned    pgap_en:                   1;
N        unsigned    pen_s_pwmnum:              7;
N        unsigned    reserved:                  1;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWMGEN_CR1;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_d_pwmnum:              7;
N        unsigned    finger_pwmnum:             7;
N        unsigned    nm_num:                    7;
N        unsigned    total_mux_num:             6;
N        unsigned    reserved:                  5;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWMGEN_CR2;
N
Ntypedef union
N{
N    struct {
N        unsigned    set_tx_en:                 1;
N        unsigned    set_tx_num:                7;
N        unsigned    reserved:                  24;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_SET_TX_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    tsync_num:                 5;
N        unsigned    tsync_end_loc:             1;
N        unsigned    tsync_dglitch_len:         3;
N        unsigned    tsynct_in_sel:             1;
N        unsigned    tsynct_in_inv:             1;
N        unsigned    tsynct_out_inv:            1;
N        unsigned    tsync_sric_in_sel:         1;
N        unsigned    tsync_sric_out_sel:        1;
N        unsigned    tsync_sric_in_inv:         1;
N        unsigned    tsync_sric_out_inv:        1;
N        unsigned    tsynct2_in_sel:            1;
N        unsigned    tsynct2_in_inv:            1;
N        unsigned    tsynct_kiosk_in_sel:       1;
N        unsigned    tsync_sric_redge_sel:      1;		//	ToDo: Added by register map
N        unsigned    tsync_sric_fedge_sel:      1;		//	ToDo: Added by register map
N        unsigned    reserved:                  11;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TSYNC_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    nm_en:                     1;
N        unsigned    none_en:                   1;
N        unsigned    st_pnt:                    12;
N        unsigned    end_pnt:                   10;
N        unsigned    kiosk_sgap_end:            1;
N        unsigned    kiosk_pwm_end:             1;
N        unsigned    kiosk_tch_time_end:        1;
N        unsigned    reserved:                  1;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TSYNC_D2_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    sgap_prd:                  14;
N        unsigned    ping_prd:                  11;
N        unsigned    reserved:                  7;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DLY_CNT1;
N
Ntypedef union
N{
N    struct {
N        unsigned    mgap_prd_f:                10;
N        unsigned    mgap_prd_p_s:              10;
N        unsigned    mgap_prd_p_d:              10;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DLY_CNT2;
N
Ntypedef union
N{
N    struct {
N        unsigned    egap_prd:                  14;
N        unsigned    dgap_prd:                  10;
N        unsigned    offclk_dly:                6;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DLY_CNT3;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    nm_en:                     1;
N        unsigned    none_en:                   1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_pwm_en:              1;
N        unsigned    pen_d_pwm_en:              1;
N        unsigned    finger_pwm_en:             1;
N        unsigned    ping_only_en:              1;
N        unsigned    delay:                     12;
N        unsigned    kiosk_tch_time_end_off:    1;
N        unsigned    reserved:                  6;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TSYNC_TPIC_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_sric_f:                10;
N        unsigned    pwm_tpic_f:                10;
N        unsigned    pwm_mux_f:                 10;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_DLY1;
N
Ntypedef union
N{
N    struct {
N        unsigned    ping_finger:               5;
N        unsigned    ping_pen_pos:              5;
N        unsigned    ping_pen_dat:              5;
N        unsigned    reserved:                  17;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DSSS_INFO0;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_cfg0:               5;
N        unsigned    beacon_cfg1:               5;
N        unsigned    beacon_cfg2:               5;
N        unsigned    beacon_cfg3:               5;
N        unsigned    beacon_cfg4:               5;
N        unsigned    beacon_cfg5:               5;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DSSS_INFO1;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_cfg6:               5;
N        unsigned    beacon_cfg7:               5;
N        unsigned    beacon_cfg8:               5;
N        unsigned    beacon_cfg9:               5;
N        unsigned    beacon_cfg10:              5;
N        unsigned    beacon_cfg11:              5;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DSSS_INFO2;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    pen_s_dmy_en:              1;
N        unsigned    pen_d_dmy_en:              1;
N        unsigned    finger_dmy_en:             1;
N        unsigned    pen_s_set_tx_en:           1;
N        unsigned    pen_d_set_tx_en:           1;
N        unsigned    finger_set_tx_en:          1;
N        unsigned    nm_en:                     1;
N        unsigned    inv_en:                    1;
N        unsigned    ping_only_en:              1;
N        unsigned    reserved:                  16;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_TPIC_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    pen_s_dmy_en:              1;
N        unsigned    pen_d_dmy_en:              1;
N        unsigned    finger_dmy_en:             1;
N        unsigned    pen_s_set_tx_en:           1;
N        unsigned    pen_d_set_tx_en:           1;
N        unsigned    finger_set_tx_en:          1;
N        unsigned    nm_en:                     1;
N        unsigned    inv_en:                    1;
N        unsigned    pwm_2x_en:                 1;
N        unsigned    pen_s_tsync_d2_en:         1;
N        unsigned    pen_d_tsync_d2_en:         1;
N        unsigned    finger_tsync_d2_en:        1;
N        unsigned    ping_only_en:              1;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_SRIC_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_en:                 1;
N        unsigned    pen_s_ping_en:             1;
N        unsigned    pen_d_ping_en:             1;
N        unsigned    finger_ping_en:            1;
N        unsigned    pen_s_en:                  1;
N        unsigned    pen_d_en:                  1;
N        unsigned    finger_en:                 1;
N        unsigned    pen_s_dmy_en:              1;
N        unsigned    pen_d_dmy_en:              1;
N        unsigned    finger_dmy_en:             1;
N        unsigned    pen_s_set_tx_en:           1;
N        unsigned    pen_d_set_tx_en:           1;
N        unsigned    finger_set_tx_en:          1;
N        unsigned    nm_en:                     1;
N        unsigned    inv_en:                    1;
N        unsigned    ping_only_en:              1;
N        unsigned    reserved:                  16;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_MUX_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    eclk_en:                   1;
N        unsigned    eclk0_inv_en:              1;
N        unsigned    eclk1_inv_en:              1;
N        unsigned    eclk_div_en:               1;		//	ToDo: Added by register map
N        unsigned    div_num:                   5;
N        unsigned    eclk_force_on:             1;
N        unsigned    eclk_en_src0:              1;		//	ToDo: Modified by register map
N        unsigned    eclk_en_src1:              1;		//	ToDo: Added by register map
N        unsigned    eclk_en_pnt:               9;
N        unsigned    reserved:                  11;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_ECLK_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_d:                     10;
N        unsigned    pen_s:                     10;
N        unsigned    finger:                    10;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FREQ_CR1;
N
Ntypedef union
N{
N    struct {
N        unsigned    freq_beacon:               8;
N        unsigned    reserved:                  24;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FREQ_CR2;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb1:                      3;
N        unsigned    lhb2:                      3;
N        unsigned    lhb3:                      3;
N        unsigned    lhb4:                      3;
N        unsigned    lhb5:                      3;
N        unsigned    lhb6:                      3;
N        unsigned    lhb7:                      3;
N        unsigned    lhb8:                      3;
N        unsigned    lhb9:                      3;
N        unsigned    lhb10:                     3;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG11;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb11:                     3;
N        unsigned    lhb12:                     3;
N        unsigned    lhb13:                     3;
N        unsigned    lhb14:                     3;
N        unsigned    lhb15:                     3;
N        unsigned    lhb16:                     3;
N        unsigned    lhb17:                     3;
N        unsigned    lhb18:                     3;
N        unsigned    lhb19:                     3;
N        unsigned    lhb20:                     3;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG12;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb21:                     3;
N        unsigned    lhb22:                     3;
N        unsigned    lhb23:                     3;
N        unsigned    lhb24:                     3;
N        unsigned    lhb25:                     3;
N        unsigned    lhb26:                     3;
N        unsigned    lhb27:                     3;
N        unsigned    lhb28:                     3;
N        unsigned    lhb29:                     3;
N        unsigned    lhb30:                     3;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG13;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb31:                     3;
N        unsigned    lhb32:                     3;
N        unsigned    reserved:                  26;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG14;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb1:                      3;
N        unsigned    lhb2:                      3;
N        unsigned    lhb3:                      3;
N        unsigned    lhb4:                      3;
N        unsigned    lhb5:                      3;
N        unsigned    lhb6:                      3;
N        unsigned    lhb7:                      3;
N        unsigned    lhb8:                      3;
N        unsigned    lhb9:                      3;
N        unsigned    lhb10:                     3;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG21;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb11:                     3;
N        unsigned    lhb12:                     3;
N        unsigned    lhb13:                     3;
N        unsigned    lhb14:                     3;
N        unsigned    lhb15:                     3;
N        unsigned    lhb16:                     3;
N        unsigned    lhb17:                     3;
N        unsigned    lhb18:                     3;
N        unsigned    lhb19:                     3;
N        unsigned    lhb20:                     3;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG22;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb21:                     3;
N        unsigned    lhb22:                     3;
N        unsigned    lhb23:                     3;
N        unsigned    lhb24:                     3;
N        unsigned    lhb25:                     3;
N        unsigned    lhb26:                     3;
N        unsigned    lhb27:                     3;
N        unsigned    lhb28:                     3;
N        unsigned    lhb29:                     3;
N        unsigned    lhb30:                     3;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG23;
N
Ntypedef union
N{
N    struct {
N        unsigned    lhb31:                     3;
N        unsigned    lhb32:                     3;
N        unsigned    reserved:                  26;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_LHB_CONFIG24;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon:                    1;
N        unsigned    pen_s:                     1;
N        unsigned    pen_d:                     1;
N        unsigned    finger:                    1;
N        unsigned    nm:                        1;
N        unsigned    none:                      1;
N        unsigned    ping_only:                 1;
N        unsigned    reserved:                  25;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PING_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    sync_gen_en:               1;
N        unsigned    vsync_stuck_en:            1;
N        unsigned    vsync_stuck_level:         1;
N        unsigned    tsynct_stuck_en:           1;
N        unsigned    tsynct_stuck_level:        1;
N        unsigned    tsyncd_stuck_en:           1;
N        unsigned    tsyncd_stuck_level:        1;
N        unsigned    reserved:                  25;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_SYNC_GEN_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    busy:                      1;
N        unsigned    state:                     4;
N        unsigned    reserved:                  27;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TE_STATUS;
N
Ntypedef union
N{
N    struct {
N        unsigned    tsync_tpic_out_bypass_enb:	1;
N        unsigned    tsync_sric_out_bypass_enb:	1;
N        unsigned    tsync_sric_lhb_ping_en:		1;
N        unsigned    sync_gen_fr_done_mask_en:	1;
N        unsigned    disp_off_beacon_only:		1;
N        unsigned    reserved:                  27;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TG_DUM5;
N
Ntypedef union
N{
N    struct {
N        unsigned    stuck_en:                  1;
N        unsigned    stuck_value:               1;
N        unsigned    disp_off_fpnt:             14;
N        unsigned    inv_en:                    1;
N//        unsigned    disp_off_en:               1;		//	ToDo: Added by register map
N        unsigned    reserved:                  14;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DISP_OFF_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_s_h_pnt:               10;
N        unsigned    pen_d_h_pnt:               10;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_CR1;
N
Ntypedef union
N{
N    struct {
N        unsigned    finger_h_pnt:              10;
N        unsigned    dmy_h_pnt:                 10;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_CR2;
N
Ntypedef union
N{
N    struct {
N        unsigned    vsync_in_inv:              1;
N        unsigned    vsync_in_sel:              1;
N        unsigned    vsync_locate:              5;
N        unsigned    rising_pnt:                10;
N        unsigned    falling_pnt:               10;
N        unsigned    vsync_kiosk_in_sel:        1;
N        unsigned    gst_in_inv: 		       1;		//	ToDo: Added by register map
N        unsigned    reserved:                  3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_VSYNC_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    pen_s:                     6;
N        unsigned    pen_d:                     6;
N        unsigned    finger:                    6;
N        unsigned    nm:                        2;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_MUX_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_stuck:              1;
N        unsigned    pen_s_ping_stuck:          1;
N        unsigned    pen_d_ping_stuck:          1;
N        unsigned    finger_ping_stuck:         1;
N        unsigned    pen_s_stuck:               1;
N        unsigned    pen_d_stuck:               1;
N        unsigned    finger_stuck:              1;
N        unsigned    pen_s_dmy_stuck:           1;
N        unsigned    pen_d_dmy_stuck:           1;
N        unsigned    finger_dmy_stuck:          1;
N        unsigned    pen_s_set_tx_stuck:        1;
N        unsigned    pen_d_set_tx_stuck:        1;
N        unsigned    finger_set_tx_stuck:       1;
N        unsigned    nm_stuck:                  1;
N        unsigned    reserved:                  18;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_TPIC_ST_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_stuck:              1;
N        unsigned    pen_s_ping_stuck:          1;
N        unsigned    pen_d_ping_stuck:          1;
N        unsigned    finger_ping_stuck:         1;
N        unsigned    pen_s_stuck:               1;
N        unsigned    pen_d_stuck:               1;
N        unsigned    finger_stuck:              1;
N        unsigned    pen_s_dmy_stuck:           1;
N        unsigned    pen_d_dmy_stuck:           1;
N        unsigned    finger_dmy_stuck:          1;
N        unsigned    pen_s_set_tx_stuck:        1;
N        unsigned    pen_d_set_tx_stuck:        1;
N        unsigned    finger_set_tx_stuck:       1;
N        unsigned    nm_stuck:                  1;
N        unsigned    reserved:                  18;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_SRIC_ST_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    beacon_stuck:              1;
N        unsigned    pen_s_ping_stuck:          1;
N        unsigned    pen_d_ping_stuck:          1;
N        unsigned    finger_ping_stuck:         1;
N        unsigned    pen_s_stuck:               1;
N        unsigned    pen_d_stuck:               1;
N        unsigned    finger_stuck:              1;
N        unsigned    pen_s_dmy_stuck:           1;
N        unsigned    pen_d_dmy_stuck:           1;
N        unsigned    finger_dmy_stuck:          1;
N        unsigned    pen_s_set_tx_stuck:        1;
N        unsigned    pen_d_set_tx_stuck:        1;
N        unsigned    finger_set_tx_stuck:       1;
N        unsigned    nm_stuck:                  1;
N        unsigned    reserved:                  18;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_MUX_ST_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    freq_nm1:                  10;
N        unsigned    freq_nm2:                  10;
N        unsigned    freq_nm3:                  10;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_NM_FREQ;
N
Ntypedef union
N{
N    struct {
N        unsigned    state:                     5;
N        unsigned    tsync_cnt:                 5;
N        unsigned    lhb_drv:                   3;
N        unsigned    mux_cnt:                   6;
N        unsigned    reserved:                  13;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_STATUS;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_vgh_f:                 10;
N        unsigned    pwm_gma_f:                 10;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_DLY2;
N
Ntypedef union
N{
N    struct {
N        unsigned    bgap_prd:                  11;
N        unsigned    bc_egap_prd:               14;		//	ToDo: Bit-number modified by register map
N        unsigned    reserved:                  7;
N	} tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DLY_CNT4;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_sric_p:                10;
N        unsigned    pwm_tpic_p:                10;
N        unsigned    pwm_mux_p:                 10;
N        unsigned    reserved:                  2;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_DLY3;
N
Ntypedef union
N{
N    struct {
N        unsigned    pwm_vgh_p:                 10;
N        unsigned    pwm_gma_p:                 10;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_PWM_DLY4;
N
Ntypedef union
N{
N    struct {
N        unsigned    mgap_prd_f_1:              4;
N        unsigned    mgap_prd_p_s_1:            4;
N        unsigned    mgap_prd_p_d_1:            4;
N        unsigned    reserved:                  20;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DLY_CNT5;
N
N/**
N  * @brief PWMDRV / PWM TX Generation Configuration Register
N  */
Ntypedef struct {                             /*!< PWMDRV Structure   */
N    __IO t_PWMGEN_CR0                PWMGEN_CR0;                     //0x0000
X    volatile t_PWMGEN_CR0                PWMGEN_CR0;                     
N    __IO t_PWMGEN_CR1                PWMGEN_CR1;                     //0x0001
X    volatile t_PWMGEN_CR1                PWMGEN_CR1;                     
N    __IO t_PWMGEN_CR2                PWMGEN_CR2;                     //0x0002
X    volatile t_PWMGEN_CR2                PWMGEN_CR2;                     
N    __IO t_SET_TX_CR                 SET_TX_CR;                      //0x0003
X    volatile t_SET_TX_CR                 SET_TX_CR;                      
N    __IO t_TSYNC_CR                  TSYNC_CR;                       //0x0004
X    volatile t_TSYNC_CR                  TSYNC_CR;                       
N    __IO t_TSYNC_D2_CR               TSYNC_D2_CR;                    //0x0005
X    volatile t_TSYNC_D2_CR               TSYNC_D2_CR;                    
N    __IO t_DLY_CNT1                  DLY_CNT1;                       //0x0006
X    volatile t_DLY_CNT1                  DLY_CNT1;                       
N    __IO t_DLY_CNT2                  DLY_CNT2;                       //0x0007
X    volatile t_DLY_CNT2                  DLY_CNT2;                       
N    __IO t_DLY_CNT3                  DLY_CNT3;                       //0x0008
X    volatile t_DLY_CNT3                  DLY_CNT3;                       
N    __IO t_TSYNC_TPIC_CR             TSYNC_TPIC_CR;                  //0x0009
X    volatile t_TSYNC_TPIC_CR             TSYNC_TPIC_CR;                  
N    __IO t_PWM_DLY1                  PWM_DLY1;                       //0x000A
X    volatile t_PWM_DLY1                  PWM_DLY1;                       
N    __IO t_DSSS_INFO0                DSSS_INFO0;                     //0x000B
X    volatile t_DSSS_INFO0                DSSS_INFO0;                     
N    __IO t_DSSS_INFO1                DSSS_INFO1;                     //0x000C
X    volatile t_DSSS_INFO1                DSSS_INFO1;                     
N    __IO t_DSSS_INFO2                DSSS_INFO2;                     //0x000D
X    volatile t_DSSS_INFO2                DSSS_INFO2;                     
N    __IO uint32_t                    DSSS_CODE_P_0;                  //0x000E
X    volatile uint32_t                    DSSS_CODE_P_0;                  
N    __IO uint32_t                    DSSS_CODE_P_1;                  //0x000F
X    volatile uint32_t                    DSSS_CODE_P_1;                  
N    __IO uint32_t                    DSSS_CODE_0_0;                  //0x0010
X    volatile uint32_t                    DSSS_CODE_0_0;                  
N    __IO uint32_t                    DSSS_CODE_0_1;                  //0x0011
X    volatile uint32_t                    DSSS_CODE_0_1;                  
N    __IO uint32_t                    DSSS_CODE_1_0;                  //0x0012
X    volatile uint32_t                    DSSS_CODE_1_0;                  
N    __IO uint32_t                    DSSS_CODE_1_1;                  //0x0013
X    volatile uint32_t                    DSSS_CODE_1_1;                  
N    __IO uint32_t                    DSSS_CODE_2_0;                  //0x0014
X    volatile uint32_t                    DSSS_CODE_2_0;                  
N    __IO uint32_t                    DSSS_CODE_2_1;                  //0x0015
X    volatile uint32_t                    DSSS_CODE_2_1;                  
N    __IO uint32_t                    DSSS_CODE_3_0;                  //0x0016
X    volatile uint32_t                    DSSS_CODE_3_0;                  
N    __IO uint32_t                    DSSS_CODE_3_1;                  //0x0017
X    volatile uint32_t                    DSSS_CODE_3_1;                  
N    __IO uint32_t                    DSSS_CODE_4_0;                  //0x0018
X    volatile uint32_t                    DSSS_CODE_4_0;                  
N    __IO uint32_t                    DSSS_CODE_4_1;                  //0x0019
X    volatile uint32_t                    DSSS_CODE_4_1;                  
N    __IO uint32_t                    DSSS_CODE_5_0;                  //0x001A
X    volatile uint32_t                    DSSS_CODE_5_0;                  
N    __IO uint32_t                    DSSS_CODE_5_1;                  //0x001B
X    volatile uint32_t                    DSSS_CODE_5_1;                  
N    __IO uint32_t                    DSSS_CODE_6_0;                  //0x001C
X    volatile uint32_t                    DSSS_CODE_6_0;                  
N    __IO uint32_t                    DSSS_CODE_6_1;                  //0x001D
X    volatile uint32_t                    DSSS_CODE_6_1;                  
N    __IO uint32_t                    DSSS_CODE_7_0;                  //0x001E
X    volatile uint32_t                    DSSS_CODE_7_0;                  
N    __IO uint32_t                    DSSS_CODE_7_1;                  //0x001F
X    volatile uint32_t                    DSSS_CODE_7_1;                  
N    __IO t_PWM_TPIC_CR               PWM_TPIC_CR;                    //0x0020
X    volatile t_PWM_TPIC_CR               PWM_TPIC_CR;                    
N    __IO t_PWM_SRIC_CR               PWM_SRIC_CR;                    //0x0021
X    volatile t_PWM_SRIC_CR               PWM_SRIC_CR;                    
N    __IO t_PWM_MUX_CR                PWM_MUX_CR;                     //0x0022
X    volatile t_PWM_MUX_CR                PWM_MUX_CR;                     
N    __IO t_ECLK_CR                   ECLK_CR;                        //0x0023
X    volatile t_ECLK_CR                   ECLK_CR;                        
N    __IO uint32_t                    DMY_FREQ;                       //0x0024
X    volatile uint32_t                    DMY_FREQ;                       
N    __IO t_FREQ_CR1                  FREQ_CR1;                       //0x0025
X    volatile t_FREQ_CR1                  FREQ_CR1;                       
N    __IO t_FREQ_CR2                  FREQ_CR2;                       //0x0026
X    volatile t_FREQ_CR2                  FREQ_CR2;                       
N    __IO t_LHB_CONFIG11              LHB_CONFIG11;                   //0x0027
X    volatile t_LHB_CONFIG11              LHB_CONFIG11;                   
N    __IO t_LHB_CONFIG12              LHB_CONFIG12;                   //0x0028
X    volatile t_LHB_CONFIG12              LHB_CONFIG12;                   
N    __IO t_LHB_CONFIG13              LHB_CONFIG13;                   //0x0029
X    volatile t_LHB_CONFIG13              LHB_CONFIG13;                   
N    __IO t_LHB_CONFIG14              LHB_CONFIG14;                   //0x002A
X    volatile t_LHB_CONFIG14              LHB_CONFIG14;                   
N    __IO t_LHB_CONFIG21              LHB_CONFIG21;                   //0x002B
X    volatile t_LHB_CONFIG21              LHB_CONFIG21;                   
N    __IO t_LHB_CONFIG22              LHB_CONFIG22;                   //0x002C
X    volatile t_LHB_CONFIG22              LHB_CONFIG22;                   
N    __IO t_LHB_CONFIG23              LHB_CONFIG23;                   //0x002D
X    volatile t_LHB_CONFIG23              LHB_CONFIG23;                   
N    __IO t_LHB_CONFIG24              LHB_CONFIG24;                   //0x002E
X    volatile t_LHB_CONFIG24              LHB_CONFIG24;                   
N    __IO t_PING_CR                   PING_CR;                        //0x002F
X    volatile t_PING_CR                   PING_CR;                        
N    __IO t_SYNC_GEN_CR               SYNC_GEN_CR;                    //0x0030
X    volatile t_SYNC_GEN_CR               SYNC_GEN_CR;                    
N    __IO uint32_t                    TE_RDY_CNT;                     //0x0031
X    volatile uint32_t                    TE_RDY_CNT;                     
N    __IO uint32_t                    TE_TCH_V_FPCH;                  //0x0032
X    volatile uint32_t                    TE_TCH_V_FPCH;                  
N    __IO uint32_t                    TE_TCH_V_HIGH;                  //0x0033
X    volatile uint32_t                    TE_TCH_V_HIGH;                  
N    __IO uint32_t                    TE_TCH_FPCH;                    //0x0034
X    volatile uint32_t                    TE_TCH_FPCH;                    
N    __IO uint32_t                    TE_TCH_T_HIGH;                  //0x0035
X    volatile uint32_t                    TE_TCH_T_HIGH;                  
N    __IO uint32_t                    TE_TCH_D_HIGH;                  //0x0036
X    volatile uint32_t                    TE_TCH_D_HIGH;                  
N    __IO uint32_t                    TE_TCH_LOW;                     //0x0037
X    volatile uint32_t                    TE_TCH_LOW;                     
N    __IO uint32_t                    TE_TCH_BPCH;                    //0x0038
X    volatile uint32_t                    TE_TCH_BPCH;                    
N    __IO uint32_t                    TE_TCH_PD_LOW;                  //0x0039
X    volatile uint32_t                    TE_TCH_PD_LOW;                  
N    __I  t_TE_STATUS                 TE_STATUS;                      //0x003A
X    volatile const  t_TE_STATUS                 TE_STATUS;                      
N    __IO uint32_t                    TG_DUM1;                        //0x003B
X    volatile uint32_t                    TG_DUM1;                        
N    __IO uint32_t                    TG_DUM2;                        //0x003C
X    volatile uint32_t                    TG_DUM2;                        
N    __IO uint32_t                    TG_DUM3;                        //0x003D
X    volatile uint32_t                    TG_DUM3;                        
N    __IO uint32_t                    TG_DUM4;                        //0x003E
X    volatile uint32_t                    TG_DUM4;                        
N    __IO t_TG_DUM5                   TG_DUM5;                        //0x003F
X    volatile t_TG_DUM5                   TG_DUM5;                        
N    __IO t_DISP_OFF_CR               DISP_OFF_CR;                    //0x0040
X    volatile t_DISP_OFF_CR               DISP_OFF_CR;                    
N    __IO t_PWM_CR1                   PWM_CR1;                        //0x0041
X    volatile t_PWM_CR1                   PWM_CR1;                        
N    __IO t_PWM_CR2                   PWM_CR2;                        //0x0042
X    volatile t_PWM_CR2                   PWM_CR2;                        
N    __IO t_VSYNC_CR                  VSYNC_CR;                       //0x0043
X    volatile t_VSYNC_CR                  VSYNC_CR;                       
N    __IO t_MUX_CR                    MUX_CR;                         //0x0044
X    volatile t_MUX_CR                    MUX_CR;                         
N    __IO t_PWM_TPIC_ST_CR            PWM_TPIC_ST_CR;                 //0x0045
X    volatile t_PWM_TPIC_ST_CR            PWM_TPIC_ST_CR;                 
N    __IO t_PWM_SRIC_ST_CR            PWM_SRIC_ST_CR;                 //0x0046
X    volatile t_PWM_SRIC_ST_CR            PWM_SRIC_ST_CR;                 
N    __IO t_PWM_MUX_ST_CR             PWM_MUX_ST_CR;                  //0x0047
X    volatile t_PWM_MUX_ST_CR             PWM_MUX_ST_CR;                  
N    __IO t_NM_FREQ                   NM_FREQ;                        //0x0048
X    volatile t_NM_FREQ                   NM_FREQ;                        
N    __I  t_PWM_STATUS                PWM_STATUS;                     //0x0049
X    volatile const  t_PWM_STATUS                PWM_STATUS;                     
N    __IO t_PWM_DLY2                  PWM_DLY2;                       //0x004A
X    volatile t_PWM_DLY2                  PWM_DLY2;                       
N    __IO t_DLY_CNT4                  DLY_CNT4;                       //0x004B
X    volatile t_DLY_CNT4                  DLY_CNT4;                       
N    __IO uint32_t                    KIOSK_VSYNC_TIMER;              //0x004C
X    volatile uint32_t                    KIOSK_VSYNC_TIMER;              
N    __IO t_PWM_DLY3                  PWM_DLY3;                       //0x004D
X    volatile t_PWM_DLY3                  PWM_DLY3;                       
N    __IO t_PWM_DLY4                  PWM_DLY4;                       //0x004E
X    volatile t_PWM_DLY4                  PWM_DLY4;                       
N//    __IO t_DLY_CNT5                  DLY_CNT5;                       //0x004F			//	Deleted by register map
N
N} tPWMDRV_CtrlReg_t;
N
N
N#endif /* __PWMDRV_H_ */
L 253 "..\..\Hal\system\MFTP.h" 2
N#include "_dspA.h"
L 1 "..\..\Hal\dspA\_dspA.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _dspA.h
N * created on : 14. 5. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __DSPA_H_
N#define __DSPA_H_
N
N
N/* ================================================================================ */
N/* ================                      DSPA                      ================ */
N/* ================================================================================ */
Ntypedef union
N{
N    struct {
N        unsigned    cal1_mode:                 1;
N        unsigned    cal2_mode:                 3;
N        unsigned    sens_dir:                  1;
N        unsigned    reserved:                  27;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_mode;
N
Ntypedef union
N{
N    struct {
N        unsigned    src2_div_en:               1;
N        unsigned    dst_div_en:                1;
N        unsigned    get_val_en:                1;
N        unsigned    reserved:                  29;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_cal_ctrl;
N
Ntypedef union
N{
N    struct {
N        unsigned    const_a:                   10;
N        unsigned    const_b:                   10;
N        unsigned    const_n:                   4;
N        unsigned    reserved:                  8;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_cal_const;
N
Ntypedef union
N{
N    struct {
N        unsigned    xsize:                     8;
N        unsigned    ysize:                     8;
N        unsigned    datalen:                   16;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_size_cfg;
N
Ntypedef union
N{
N    struct {
N        unsigned    src2_dsize:                2;
N        unsigned    dst_dsize:                 2;
N        unsigned    tot_xsize:                 8;
N        unsigned    reserved:                  20;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_dsize;
N
Ntypedef union
N{
N    struct {
N        unsigned    int_op_end:                1;
N        unsigned    event_en:                  1;
N        unsigned    int_cal_ovf:               1;
N        unsigned    int_tmode:                 1;
N        unsigned    reserved:                  28;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_int_en;
N
Ntypedef union
N{
N    struct {
N        unsigned    int_op_end_clr:            1;
N        unsigned    int_cal_ovf_clr:           1;
N        unsigned    int_tmode_clr:             1;
N        unsigned    reserved:                  29;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_int_clr;
N
Ntypedef union
N{
N    struct {
N        unsigned    int_op_end_sts:            1;
N        unsigned    int_ovf_upper_sts:         1;
N        unsigned    int_ovf_lower_sts:         1;
N        unsigned    dspa_busy:                 1;
N        unsigned    dspa_fsm:                  4;
N        unsigned    dspa_xcnt:                 8;
N        unsigned    dspa_ycnt:                 8;
N        unsigned    reserved:                  8;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_status;
N
Ntypedef union
N{
N    struct {
N        unsigned    tmode_brk_en:              1;
N        unsigned    tmode_brk_pos:             16;
N        unsigned    tmode_brk_st:              1;
N        unsigned    reserved:                  14;
N    } tBit;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_dspa_tmode_cfg;
N
Ntypedef union
N{
N		struct {
N				unsigned    div_x0:              8;
N				unsigned    div_x1:              8;
N				unsigned    div_x2:              8;
N				unsigned    div_x3:              8;
N		} Linefilter;
N		struct {
N				unsigned    p_cell_num:          16;
N				unsigned    p_max_val:           16;
N		} Normalize;
N		struct {
N				unsigned    div_x0:              8;
N				unsigned    div_x1:              8;
N				unsigned    div_x2:              8;
N				unsigned    div_x3:              8;
N		} Linecount;
N		__IO uint32_t w;
X		volatile uint32_t w;
N} t_dspa_gen_reg0;
N
Ntypedef union
N{
N		struct {
N				unsigned    div_x4:              8;
N				unsigned    div_x5:              8;
N				unsigned    div_x6:              8;
N				unsigned    div_x7:              8;
N		} Linefilter;
N		struct {
N				unsigned    p_cell_sum:          32;
N		} Normalize;
N		struct {
N				unsigned    div_x4:              8;
N				unsigned    div_x5:              8;
N				unsigned    div_x6:              8;
N				unsigned    div_x7:              8;
N		} Linecount;
N		__IO uint32_t w;
X		volatile uint32_t w;
N} t_dspa_gen_reg1;
N
Ntypedef union
N{
N		struct {
N				unsigned    n_cnt0:              16;
N				unsigned    n_cnt1:              16;
N		} Linefilter;
N		struct {
N				unsigned    p_max_pos_col:       8;
N				unsigned    p_max_pos_row:       8;
N				unsigned    m_max_pos_col:       8;
N				unsigned    m_max_pos_row:       8;
N		} Normalize;
N		struct {
N				unsigned    line_x0:             8;
N				unsigned    line_x1:             8;
N				unsigned    line_x2:             8;
N				unsigned    line_x3:             8;
N		} Linecount;
N		__IO uint32_t w;
X		volatile uint32_t w;
N} t_dspa_gen_reg2;
N
Ntypedef union
N{
N		struct {
N				unsigned    n_cnt2:              16;
N				unsigned    n_cnt3:              16;
N		} Linefilter;
N		struct {
N				unsigned    m_cell_num:       	 16;
N				unsigned    m_max_val:       		 16;
N		} Normalize;
N		struct {
N				unsigned    line_x4:             8;
N				unsigned    line_x5:             8;
N				unsigned    line_x6:             8;
N				unsigned    line_x7:             8;
N		} Linecount;
N		__IO uint32_t w;
X		volatile uint32_t w;
N} t_dspa_gen_reg3;
N
Ntypedef union
N{
N		struct {
N				unsigned    n_cnt4:              16;
N				unsigned    n_cnt5:              16;
N		} Linefilter;
N		struct {
N				unsigned    m_cell_sum:       	 16;
N		} Normalize;
N		struct {
N				unsigned    line_x8:             8;
N				unsigned    line_x9:             8;
N				unsigned    line_x10:            8;
N				unsigned    line_x11:            8;
N		} Linecount;
N		__IO uint32_t w;
X		volatile uint32_t w;
N} t_dspa_gen_reg4;
N
Ntypedef union
N{
N		struct {
N				unsigned    n_cnt6:              16;
N				unsigned    n_cnt7:              16;
N		} Linefilter;
N		struct {
N				unsigned    t_group_col_min:     8;
N				unsigned    t_group_col_max:     8;
N				unsigned    t_group_row_max:     8;
N				unsigned    t_group_row_min:     8;
N		} Normalize;
N		struct {
N				unsigned    line_x12:            8;
N				unsigned    line_x13:            8;
N				unsigned    line_x14:            8;
N				unsigned    line_x15:            8;
N		} Linecount;
N		__IO uint32_t w;
X		volatile uint32_t w;
N} t_dspa_gen_reg5;
N
N
Ntypedef struct
N{
N    __O  uint32_t                    dspa_start;                     //0x0000
X    volatile  uint32_t                    dspa_start;                     
N    __O  uint32_t                    dspa_init;                      //0x0001
X    volatile  uint32_t                    dspa_init;                      
N    __IO t_dspa_mode                 dspa_mode;                      //0x0002
X    volatile t_dspa_mode                 dspa_mode;                      
N    __IO t_dspa_cal_ctrl             dspa_cal_ctrl;                  //0x0003
X    volatile t_dspa_cal_ctrl             dspa_cal_ctrl;                  
N    __IO t_dspa_cal_const            dspa_cal_const;                 //0x0004
X    volatile t_dspa_cal_const            dspa_cal_const;                 
N    __IO t_dspa_size_cfg             dspa_size_cfg;                  //0x0005
X    volatile t_dspa_size_cfg             dspa_size_cfg;                  
N    __IO t_dspa_dsize                dspa_dsize;                     //0x0006
X    volatile t_dspa_dsize                dspa_dsize;                     
N    __IO uint32_t                    dspa_src1_addr;                 //0x0007
X    volatile uint32_t                    dspa_src1_addr;                 
N    __IO uint32_t                    dspa_src2_addr;                 //0x0008
X    volatile uint32_t                    dspa_src2_addr;                 
N    __IO uint32_t                    dspa_src3_addr;                 //0x0009
X    volatile uint32_t                    dspa_src3_addr;                 
N    __IO uint32_t                    dspa_dst_addr;                  //0x000A
X    volatile uint32_t                    dspa_dst_addr;                  
N    __IO uint32_t                    dspa_lf_uppth;                  //0x000B
X    volatile uint32_t                    dspa_lf_uppth;                  
N    __IO uint32_t                    dspa_lf_lowth;                  //0x000C
X    volatile uint32_t                    dspa_lf_lowth;                  
N    __IO uint32_t                    dspa_lcnt_uppth;                //0x000D
X    volatile uint32_t                    dspa_lcnt_uppth;                
N    __IO uint32_t                    dspa_lcnt_lowth;                //0x000E
X    volatile uint32_t                    dspa_lcnt_lowth;                
N    __IO uint32_t                    dspa_param_th;                  //0x000F
X    volatile uint32_t                    dspa_param_th;                  
N    __IO uint32_t                    dspa_ovf_uppth;                 //0x0010
X    volatile uint32_t                    dspa_ovf_uppth;                 
N    __IO uint32_t                    dspa_ovf_lowth;                 //0x0011
X    volatile uint32_t                    dspa_ovf_lowth;                 
N    __IO t_dspa_gen_reg0             dspa_gen_reg0;                  //0x0012
X    volatile t_dspa_gen_reg0             dspa_gen_reg0;                  
N    __IO t_dspa_gen_reg1             dspa_gen_reg1;                  //0x0013
X    volatile t_dspa_gen_reg1             dspa_gen_reg1;                  
N    __IO t_dspa_gen_reg2             dspa_gen_reg2;                  //0x0014
X    volatile t_dspa_gen_reg2             dspa_gen_reg2;                  
N    __IO t_dspa_gen_reg3             dspa_gen_reg3;                  //0x0015
X    volatile t_dspa_gen_reg3             dspa_gen_reg3;                  
N    __IO t_dspa_gen_reg4             dspa_gen_reg4;                  //0x0016
X    volatile t_dspa_gen_reg4             dspa_gen_reg4;                  
N    __IO t_dspa_gen_reg5             dspa_gen_reg5;                  //0x0017
X    volatile t_dspa_gen_reg5             dspa_gen_reg5;                  
N    __IO uint32_t                    RESERVED0;                      //0x0018
X    volatile uint32_t                    RESERVED0;                      
N    __IO t_dspa_int_en               dspa_int_en;                    //0x0019
X    volatile t_dspa_int_en               dspa_int_en;                    
N    __O  t_dspa_int_clr              dspa_int_clr;                   //0x001A
X    volatile  t_dspa_int_clr              dspa_int_clr;                   
N    __I  t_dspa_status               dspa_status;                    //0x001B
X    volatile const  t_dspa_status               dspa_status;                    
N    __I  uint32_t                    dspa_src1_curr_addr;            //0x001C
X    volatile const  uint32_t                    dspa_src1_curr_addr;            
N    __I  uint32_t                    dspa_src2_curr_addr;            //0x001D
X    volatile const  uint32_t                    dspa_src2_curr_addr;            
N    __I  uint32_t                    dspa_src3_curr_addr;            //0x001E
X    volatile const  uint32_t                    dspa_src3_curr_addr;            
N    __I  uint32_t                    dspa_dst_curr_addr;             //0x001F
X    volatile const  uint32_t                    dspa_dst_curr_addr;             
N    __I  uint32_t                    dspa_src1_buf;                  //0x0020
X    volatile const  uint32_t                    dspa_src1_buf;                  
N    __I  uint32_t                    dspa_src2_buf;                  //0x0021
X    volatile const  uint32_t                    dspa_src2_buf;                  
N    __I  uint32_t                    dspa_src3_buf;                  //0x0022
X    volatile const  uint32_t                    dspa_src3_buf;                  
N    __I  uint32_t                    dspa_dst_buf;                   //0x0023
X    volatile const  uint32_t                    dspa_dst_buf;                   
N    __IO t_dspa_tmode_cfg            dspa_tmode_cfg;                 //0x0024
X    volatile t_dspa_tmode_cfg            dspa_tmode_cfg;                 
N    __O  uint32_t                    dspa_tmode_clr;                 //0x0025
X    volatile  uint32_t                    dspa_tmode_clr;                 
N
N} tDSPA_CtrlReg_t;
N
N
N#endif /* __DSPA_H_ */
L 254 "..\..\Hal\system\MFTP.h" 2
N#include "_mspi.h"
L 1 "..\..\Hal\spi\_mspi.h" 1
N/******************************************************************************************************
N * Copyright (c) 2019 - 2025 SiliconWorks LIMITED
N *
N * file : _mspi.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __MSPI_H_
N#define __MSPI_H_
N
N
N#include "_mspi_param.h"
L 1 "..\..\Hal\spi\_mspi_param.h" 1
N/******************************************************************************************************
N * Copyright (c) 2019 - 2025 SiliconWorks LIMITED
N *
N * file : _mspi_param.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __MSPI_PARAM_H_
N#define __MSPI_PARAM_H_
N
N
Ntypedef union
N{
N    struct {
N        unsigned	spiTxEna0:					1;
N        unsigned	spiTxEna1:					1;
N        unsigned	spiTxEna2:					1;
N        unsigned	spiTxEna3:					1;
N        unsigned	spiTxEna4:					1;
N        unsigned	spiTxEna5:					1;
N        unsigned	spiTxEna6:					1;
N        unsigned	spiTxEna7:					1;
N        unsigned	spiRxEna0:					1;
N        unsigned	spiRxEna1:					1;
N        unsigned	spiRxEna2:					1;
N        unsigned	spiRxEna3:					1;
N        unsigned	spiRxEna4:					1;
N        unsigned	spiRxEna5:					1;
N        unsigned	spiRxEna6:					1;
N        unsigned	spiRxEna7:					1;
N        unsigned	spiTRxEna0:					1;
N        unsigned	spiTRxEna1:					1;
N        unsigned	spiTRxEna2:					1;
N        unsigned	spiTRxEna3:					1;
N        unsigned	spiTRxEna4:					1;
N        unsigned	spiTRxEna5:					1;
N        unsigned	spiTRxEna6:					1;
N        unsigned	spiTRxEna7:					1;
N        unsigned	reserved:					8;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPIENA_t;
X} __attribute__ ((packed)) tCP_SPIENA_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	BITLEN:						1;
N        unsigned	DUALACC:					1;
N        unsigned	DUALBITORD:					1;
N        unsigned	TXDORD:						1;
N        unsigned	RXDORD:						1;
N        unsigned	TXCHKSUM_EN:				1;
N        unsigned	RXCHKSUM_EN:				1;
N        unsigned	RXPOS:						4;
N        unsigned	SCLKDIV:					4;
N        unsigned	MISO_ZERO_CHK_EN:			1;
N        unsigned	reserved:					16;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISCR_t;
X} __attribute__ ((packed)) tCP_SPISCR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	txdata_len:					8;
N        unsigned	rxdata_len:                 8;
N        unsigned	txbit_len:                  5;
N        unsigned	rxbit_len:                  5;
N        unsigned	reserved:					6;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPIDATALEN_t;
X} __attribute__ ((packed)) tCP_SPIDATALEN_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	int_mux_flag:				1;
N        unsigned	int_frame_flag:             1;
N        unsigned	int_roic_flag:              8;
N        unsigned	int_chksum_flag:            8;
N        unsigned	int_misozero_flag:          8;
N        unsigned	reserved:					6;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __I uint32_t ulBulk;
X    volatile const uint32_t ulBulk;
N} __PACKED tCP_SINTRFLAG_t;
X} __attribute__ ((packed)) tCP_SINTRFLAG_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	int_mux_en:					1;
N        unsigned	int_frame_en:               1;
N        unsigned	int_roic_en:                1;
N        unsigned	int_chksum_en:              1;
N        unsigned	int_misozero_en:            1;
N        unsigned	reserved:					27;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SINTRMSCR_t;
X} __attribute__ ((packed)) tCP_SINTRMSCR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	int_roic_mask:				8;
N        unsigned	int_misozero_mask:          8;
N        unsigned	int_chksum_mask:            8;
N        unsigned	reserved:					8;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SINTRMASK_t;
X} __attribute__ ((packed)) tCP_SINTRMASK_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	int_mux_clr:				1;
N        unsigned	int_frame_clr:              1;
N        unsigned	int_roic_clr:               1;
N        unsigned	int_chksum_clr:             1;
N        unsigned	int_misozero_clr:           1;
N        unsigned	reserved:					27;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __O uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SINTRENCLR_t;
X} __attribute__ ((packed)) tCP_SINTRENCLR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spitrsize0:					8;
N        unsigned	spitrsize1:					8;
N        unsigned	spitrsize2:					8;
N        unsigned	spitrsize3:					8;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPITRSIZE0_t;
X} __attribute__ ((packed)) tCP_SPITRSIZE0_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spitrsize4:					8;
N        unsigned	spitrsize5:					8;
N        unsigned	spitrsize6:					8;
N        unsigned	spitrsize7:					8;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPITRSIZE1_t;
X} __attribute__ ((packed)) tCP_SPITRSIZE1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	PreShftLen:					8;
N        unsigned	TmpIdleLen:                 8;
N        unsigned	PostShftLen:                8;
N        unsigned	txbufnum:                   5;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTATELEN_t;
X} __attribute__ ((packed)) tCP_SPISTATELEN_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	aitmode:					1;
N        unsigned	sharemode:                  1;
N        unsigned	reserved:					30;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPIMODE_t;
X} __attribute__ ((packed)) tCP_SPIMODE_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spi0_active:				1;
N        unsigned	spi1_active:				1;
N        unsigned	spi2_active:				1;
N        unsigned	spi3_active:				1;
N        unsigned	spi4_active:				1;
N        unsigned	spi5_active:				1;
N        unsigned	spi6_active:				1;
N        unsigned	spi7_active:				1;
N        unsigned	reserved:					24;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __I uint32_t ulBulk;
X    volatile const uint32_t ulBulk;
N} __PACKED tCP_SPISR_t;
X} __attribute__ ((packed)) tCP_SPISR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStart0:					1;
N        unsigned	spiStart1:					1;
N        unsigned	spiStart2:					1;
N        unsigned	spiStart3:					1;
N        unsigned	spiStart4:					1;
N        unsigned	spiStart5:					1;
N        unsigned	spiStart6:					1;
N        unsigned	spiStart7:					1;
N        unsigned	reserved:					24;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTART_t;
X} __attribute__ ((packed)) tCP_SPISTART_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd0:				13;
N        unsigned	reserved0:                  3;
N        unsigned	spiStrtWAd1:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTWAD01_t;
X} __attribute__ ((packed)) tCP_SPISTRTWAD01_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd2:				13;
N        unsigned	reserved1:                  3;
N        unsigned	spiStrtWAd3:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTWAD23_t;
X} __attribute__ ((packed)) tCP_SPISTRTWAD23_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd4:				13;
N        unsigned	reserved2:                  3;
N        unsigned	spiStrtWAd5:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTWAD45_t;
X} __attribute__ ((packed)) tCP_SPISTRTWAD45_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd6:				13;
N        unsigned	reserved3:                  3;
N        unsigned	spiStrtWAd7:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTWAD67_t;
X} __attribute__ ((packed)) tCP_SPISTRTWAD67_t;
N
Ntypedef union
N{
N    struct
N	{
N        unsigned	spiStrtRAd0:				13;
N        unsigned	reserved4:                  3;
N        unsigned	spiStrtRAd1:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTRAD01_t;
X} __attribute__ ((packed)) tCP_SPISTRTRAD01_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtRAd2:				13;
N        unsigned	reserved5:                  3;
N        unsigned	spiStrtRAd3:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTRAD23_t;
X} __attribute__ ((packed)) tCP_SPISTRTRAD23_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtRAd4:				13;
N        unsigned	reserved6:                  3;
N        unsigned	spiStrtRAd5:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTRAD45_t;
X} __attribute__ ((packed)) tCP_SPISTRTRAD45_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtRAd6:				13;
N        unsigned	reserved7:                  3;
N        unsigned	spiStrtRAd7:                13;
N        unsigned	reserved:					3;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_SPISTRTRAD67_t;
X} __attribute__ ((packed)) tCP_SPISTRTRAD67_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	share_num:					3;
N        unsigned	txaddr_mul:                 13;
N        unsigned	reserved:					16;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_MSPI_SHM_CTRL_t;
X} __attribute__ ((packed)) tCP_MSPI_SHM_CTRL_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	reserved0:					1;
N        unsigned	findex0:                    7;
N        unsigned	reserved1:                  1;
N        unsigned	findex1:                    7;
N        unsigned	reserved2:                  1;
N        unsigned	findex2:                    7;
N        unsigned	reserved3:                  1;
N        unsigned	findex3:                    7;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_MSPI_FINDEX0_t;
X} __attribute__ ((packed)) tCP_MSPI_FINDEX0_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	reserved4:					1;
N        unsigned	findex4:                    7;
N        unsigned	reserved5:                  1;
N        unsigned	findex5:                    7;
N        unsigned	reserved6:                  1;
N        unsigned	findex6:                    7;
N        unsigned	reserved7:                  1;
N        unsigned	findex7:                    7;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} __PACKED tCP_MSPI_FINDEX1_t;
X} __attribute__ ((packed)) tCP_MSPI_FINDEX1_t;
N
N
N#endif /* __MSPI_PARAM_H_ */
L 38 "..\..\Hal\spi\_mspi.h" 2
N/* ================================================================================ */
N/* ================                      MSPI                      ================ */
N/* ================================================================================ */
Ntypedef union
N{
N    struct {
N        unsigned	spiTxEna0:					1;
N        unsigned	spiTxEna1:					1;
N        unsigned	spiTxEna2:					1;
N        unsigned	spiTxEna3:					1;
N        unsigned	spiTxEna4:					1;
N        unsigned	spiTxEna5:					1;
N        unsigned	spiTxEna6:					1;
N        unsigned	spiTxEna7:					1;
N        unsigned	spiRxEna0:					1;
N        unsigned	spiRxEna1:					1;
N        unsigned	spiRxEna2:					1;
N        unsigned	spiRxEna3:					1;
N        unsigned	spiRxEna4:					1;
N        unsigned	spiRxEna5:					1;
N        unsigned	spiRxEna6:					1;
N        unsigned	spiRxEna7:					1;
N        unsigned	spiTRxEna0:					1;
N        unsigned	spiTRxEna1:					1;
N        unsigned	spiTRxEna2:					1;
N        unsigned	spiTRxEna3:					1;
N        unsigned	spiTRxEna4:					1;
N        unsigned	spiTRxEna5:					1;
N        unsigned	spiTRxEna6:					1;
N        unsigned	spiTRxEna7:					1;
N        unsigned	reserved:					8;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPIENA_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	BITLEN:						1;
N        unsigned	DUALACC:					1;
N        unsigned	DUALBITORD:					1;
N        unsigned	TXDORD:						1;
N        unsigned	RXDORD:						1;
N        unsigned	TXCHKSUM_EN:				1;
N        unsigned	RXCHKSUM_EN:				1;
N        unsigned	RXPOS:						4;
N        unsigned	SCLKDIV:					4;
N        unsigned	MISO_ZERO_CHK_EN:			1;
N        unsigned	reserved:					16;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISCR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	txdata_len:					8;
N        unsigned	rxdata_len:                 8;
N        unsigned	txbitlen:                  5;
N        unsigned	rxbitlen:                  5;
N        unsigned	reserved:					6;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPIDATALEN_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	intmux_flag:				1;
N        unsigned	intframe_flag:             1;
N        unsigned	introic_flag:              8;
N        unsigned	intchksum_flag:            8;
N        unsigned	intmisozero_flag:          8;
N        unsigned	reserved:					6;
N    } tBit;
N    __I uint32_t ulBulk;
X    volatile const uint32_t ulBulk;
N} tSINTRFLAG_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	intmux_en:					1;
N        unsigned	intframe_en:               1;
N        unsigned	introic_en:                1;
N        unsigned	intchksum_en:              1;
N        unsigned	intmisozero_en:            1;
N        unsigned	reserved:					27;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSINTRMSCR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	introic_mask:				8;
N        unsigned	intmisozero_mask:          8;
N        unsigned	intchksum_mask:            8;
N        unsigned	reserved:					8;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSINTRMASK_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	intmux_clr:				1;
N        unsigned	intframe_clr:              1;
N        unsigned	introic_clr:               1;
N        unsigned	intchksum_clr:             1;
N        unsigned	intmisozero_clr:           1;
N        unsigned	reserved:					27;
N    } tBit;
N    __O uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSINTRENCLR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spitrsize0:					8;
N        unsigned	spitrsize1:					8;
N        unsigned	spitrsize2:					8;
N        unsigned	spitrsize3:					8;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPITRSIZE0_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spitrsize4:					8;
N        unsigned	spitrsize5:					8;
N        unsigned	spitrsize6:					8;
N        unsigned	spitrsize7:					8;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPITRSIZE1_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	PreShftLen:					8;
N        unsigned	TmpIdleLen:                 8;
N        unsigned	PostShftLen:                8;
N        unsigned	txbufnum:                   5;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTATELEN_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	aitmode:					1;
N        unsigned	sharemode:                  1;
N        unsigned	reserved:					30;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPIMODE_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spi0_active:				1;
N        unsigned	spi1_active:				1;
N        unsigned	spi2_active:				1;
N        unsigned	spi3_active:				1;
N        unsigned	spi4_active:				1;
N        unsigned	spi5_active:				1;
N        unsigned	spi6_active:				1;
N        unsigned	spi7_active:				1;
N        unsigned	reserved:					24;
N    } tBit;
N    __I uint32_t ulBulk;
X    volatile const uint32_t ulBulk;
N} tSPISR_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStart0:					1;
N        unsigned	spiStart1:					1;
N        unsigned	spiStart2:					1;
N        unsigned	spiStart3:					1;
N        unsigned	spiStart4:					1;
N        unsigned	spiStart5:					1;
N        unsigned	spiStart6:					1;
N        unsigned	spiStart7:					1;
N        unsigned	reserved:					24;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTART_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd0:				13;
N        unsigned	reserved0:                  3;
N        unsigned	spiStrtWAd1:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTWAD01_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd2:				13;
N        unsigned	reserved1:                  3;
N        unsigned	spiStrtWAd3:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTWAD23_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd4:				13;
N        unsigned	reserved2:                  3;
N        unsigned	spiStrtWAd5:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTWAD45_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtWAd6:				13;
N        unsigned	reserved3:                  3;
N        unsigned	spiStrtWAd7:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTWAD67_t;
N
Ntypedef union
N{
N    struct
N	{
N        unsigned	spiStrtRAd0:				13;
N        unsigned	reserved4:                  3;
N        unsigned	spiStrtRAd1:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTRAD01_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtRAd2:				13;
N        unsigned	reserved5:                  3;
N        unsigned	spiStrtRAd3:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTRAD23_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtRAd4:				13;
N        unsigned	reserved6:                  3;
N        unsigned	spiStrtRAd5:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTRAD45_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	spiStrtRAd6:				13;
N        unsigned	reserved7:                  3;
N        unsigned	spiStrtRAd7:                13;
N        unsigned	reserved:					3;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tSPISTRTRAD67_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	share_num:					3;
N        unsigned	txaddr_mul:                 13;
N        unsigned	reserved:					16;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tMSPI_SHM_CTRL_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	reserved0:					1;
N        unsigned	findex0:                    7;
N        unsigned	reserved1:                  1;
N        unsigned	findex1:                    7;
N        unsigned	reserved2:                  1;
N        unsigned	findex2:                    7;
N        unsigned	reserved3:                  1;
N        unsigned	findex3:                    7;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tMSPI_FINDEX0_t;
N
Ntypedef union
N{
N    struct {
N        unsigned	reserved4:					1;
N        unsigned	findex4:                    7;
N        unsigned	reserved5:                  1;
N        unsigned	findex5:                    7;
N        unsigned	reserved6:                  1;
N        unsigned	findex6:                    7;
N        unsigned	reserved7:                  1;
N        unsigned	findex7:                    7;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} tMSPI_FINDEX1_t;
N
Ntypedef struct
N{
N	__IO tSPIENA_t				tSPIENA;
X	volatile tSPIENA_t				tSPIENA;
N	__IO tSPISCR_t				tSPISCR;
X	volatile tSPISCR_t				tSPISCR;
N	__IO tSPIDATALEN_t			tSPIDATALEN;
X	volatile tSPIDATALEN_t			tSPIDATALEN;
N	__I  uint32_t				RESERVED0;
X	volatile const  uint32_t				RESERVED0;
N	__I  tSINTRFLAG_t			tSINTRFLAG;
X	volatile const  tSINTRFLAG_t			tSINTRFLAG;
N	__IO tSINTRMSCR_t			tSINTRMSCR;
X	volatile tSINTRMSCR_t			tSINTRMSCR;
N	__IO tSINTRMASK_t			tSINTRMASK;
X	volatile tSINTRMASK_t			tSINTRMASK;
N	__O  tSINTRENCLR_t			tSINTRENCLR;
X	volatile  tSINTRENCLR_t			tSINTRENCLR;
N	__IO tSPITRSIZE0_t			tSPITRSIZE0;
X	volatile tSPITRSIZE0_t			tSPITRSIZE0;
N	__IO tSPITRSIZE1_t			tSPITRSIZE1;
X	volatile tSPITRSIZE1_t			tSPITRSIZE1;
N	__IO uint32_t				SPIAITSTART; // RX Buffer Address Index Clear
X	volatile uint32_t				SPIAITSTART; 
N	__IO uint32_t				SPIMUXNUM;
X	volatile uint32_t				SPIMUXNUM;
N	__IO tSPISTATELEN_t			tSPISTATELEN;
X	volatile tSPISTATELEN_t			tSPISTATELEN;
N	__IO tSPIMODE_t				tSPIMODE;
X	volatile tSPIMODE_t				tSPIMODE;
N	__I  tSPISR_t				tSPISR;
X	volatile const  tSPISR_t				tSPISR;
N	__IO uint32_t				MSPI_WFE_ENA;
X	volatile uint32_t				MSPI_WFE_ENA;
N	__IO uint32_t				MSPI_SMPL_DLY;
X	volatile uint32_t				MSPI_SMPL_DLY;
N	__IO tSPISTART_t			tSPISTART;
X	volatile tSPISTART_t			tSPISTART;
N	__IO tSPISTRTWAD01_t		tSPISTRTWAD01;
X	volatile tSPISTRTWAD01_t		tSPISTRTWAD01;
N	__IO tSPISTRTWAD23_t		tSPISTRTWAD23;
X	volatile tSPISTRTWAD23_t		tSPISTRTWAD23;
N	__IO tSPISTRTWAD45_t		tSPISTRTWAD45;
X	volatile tSPISTRTWAD45_t		tSPISTRTWAD45;
N	__IO tSPISTRTWAD67_t		tSPISTRTWAD67;
X	volatile tSPISTRTWAD67_t		tSPISTRTWAD67;
N	__IO tSPISTRTRAD01_t		tSPISTRTRAD01;
X	volatile tSPISTRTRAD01_t		tSPISTRTRAD01;
N	__IO tSPISTRTRAD23_t		tSPISTRTRAD23;
X	volatile tSPISTRTRAD23_t		tSPISTRTRAD23;
N	__IO tSPISTRTRAD45_t		tSPISTRTRAD45;
X	volatile tSPISTRTRAD45_t		tSPISTRTRAD45;
N	__IO tSPISTRTRAD67_t		tSPISTRTRAD67;
X	volatile tSPISTRTRAD67_t		tSPISTRTRAD67;
N	__IO uint32_t				SPI_SHARE_TERM;
X	volatile uint32_t				SPI_SHARE_TERM;
N	__IO tMSPI_SHM_CTRL_t		tMSPI_SHM_CTRL;
X	volatile tMSPI_SHM_CTRL_t		tMSPI_SHM_CTRL;
N	__IO tMSPI_FINDEX0_t		tMSPI_FINDEX0;
X	volatile tMSPI_FINDEX0_t		tMSPI_FINDEX0;
N	__IO tMSPI_FINDEX1_t		tMSPI_FINDEX1;
X	volatile tMSPI_FINDEX1_t		tMSPI_FINDEX1;
N	__I uint32_t				RESERVED1;
X	volatile const uint32_t				RESERVED1;
N	__I uint32_t				RESERVED2;
X	volatile const uint32_t				RESERVED2;
N	__I uint32_t				RESERVED3;
X	volatile const uint32_t				RESERVED3;
N	__I uint32_t				RESERVED4;
X	volatile const uint32_t				RESERVED4;
N	__I uint32_t				RESERVED5;
X	volatile const uint32_t				RESERVED5;
N	__I uint32_t				RESERVED6;
X	volatile const uint32_t				RESERVED6;
N	__I uint32_t				RESERVED7;
X	volatile const uint32_t				RESERVED7;
N	__I uint32_t				RESERVED8;
X	volatile const uint32_t				RESERVED8;
N
N} tMSPI_CtrlReg_t;
N
N
N#endif /* __MSPI_H_ */
L 255 "..\..\Hal\system\MFTP.h" 2
N#include "_tlvds.h"
L 1 "..\..\Hal\tlvds\_tlvds.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _gdma.h
N * created on : 05. 9. 2018
N* Author : HongTK
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __TLVDS_H_
N#define __TLVDS_H_
N
Ntypedef union
N{
N    struct {
N        unsigned    mst_start:                 1;
N        unsigned    reserved:                  31;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_CTRL;
N
Ntypedef union
N{
N    struct {
N        unsigned    tcsn0_pdb:                 1;
N        unsigned    tcsn1_pdb:                 1;
N        unsigned    tclk0_pdb:                 1;
N        unsigned    tclk1_pdb:                 1;
N        unsigned    tdat0_pdb:                 1;
N        unsigned    tdat1_pdb:                 1;
N        unsigned    rclk0_pdb:                 1;
N        unsigned    rclk1_pdb:                 1;
N        unsigned    rclk2_pdb:                 1;
N        unsigned    rclk3_pdb:                 1;
N        unsigned    rdat0_pdb:                 1;
N        unsigned    rdat1_pdb:                 1;
N        unsigned    rdat2_pdb:                 1;
N        unsigned    rdat3_pdb:                 1;
N        unsigned    tcsn0_drv:                 1;
N        unsigned    tcsn1_drv:                 1;
N        unsigned    tclk0_drv:                 1;
N        unsigned    tclk1_drv:                 1;
N        unsigned    tdat0_drv:                 1;
N        unsigned    tdat1_drv:                 1;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_PHY_STUCK_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    tcsn0_pdb:                 1;
N        unsigned    tcsn1_pdb:                 1;
N        unsigned    tclk0_pdb:                 1;
N        unsigned    tclk1_pdb:                 1;
N        unsigned    tdat0_pdb:                 1;
N        unsigned    tdat1_pdb:                 1;
N        unsigned    rclk0_pdb:                 1;
N        unsigned    rclk1_pdb:                 1;
N        unsigned    rclk2_pdb:                 1;
N        unsigned    rclk3_pdb:                 1;
N        unsigned    rdat0_pdb:                 1;
N        unsigned    rdat1_pdb:                 1;
N        unsigned    rdat2_pdb:                 1;
N        unsigned    rdat3_pdb:                 1;
N        unsigned    tcsn0_drv:                 1;
N        unsigned    tcsn1_drv:                 1;
N        unsigned    tclk0_drv:                 1;
N        unsigned    tclk1_drv:                 1;
N        unsigned    tdat0_drv:                 1;
N        unsigned    tdat1_drv:                 1;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_PHY_STUCK_VALUE;
N
Ntypedef union
N{
N    struct {
N    	unsigned    t1:						   6;
N    	unsigned    t2:                        6;
N        unsigned    t2_1:                      6;
N        unsigned    t3:                        6;
N        unsigned    reserved:                  8;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_INTERVAL_CR;
N
N//typedef union
N//{
N//    struct {
N//    	unsigned    int_tx_done_clr:						   6;
N//    	unsigned    t2:                        6;
N//        unsigned    t2_1:                      6;
N//        unsigned    t3:                        6;
N//        unsigned    reserved:                  8;
N//    } tBit;
N//    __IO uint32_t ulBulk;
N//} t_TLVDS_RESERVED00;
N
Ntypedef union
N{
N    struct {
N        unsigned    pdb_time:                  8;
N        unsigned    drv_time:                  8;
N        unsigned    off_time:                  5;
N        unsigned    reserved:                  11;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AFE_ON_TIME;
N
Ntypedef union
N{
N    struct {
N        unsigned    rx0_cnt:                   5;
N        unsigned    rx1_cnt:                   5;
N        unsigned    rx2_cnt:                   5;
N        unsigned    rx3_cnt:                   5;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_RX_STATUS;
N
Ntypedef union
N{
N    struct {
N        unsigned    tlvds_fsm:                 4;
N        unsigned    bulk_cnt:                  8;
N        unsigned    sric_cnt:                  4;
N        unsigned    int_tx_done:               1;
N        unsigned    int_rx_done:               1;
N        unsigned    int_sric_ready:            1;
N        unsigned    int_mux_done:              1;
N        unsigned    int_fr_done:               1;
N        unsigned    int_chksum_rx3:            1;
N        unsigned    int_chksum_rx2:            1;
N        unsigned    int_chksum_rx1:            1;
N        unsigned    int_chksum_rx0:            1;
N        unsigned    reserved:                  7;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_STATUS;
N
Ntypedef union
N{
N    struct {
N        unsigned    int_tx_done_clr:           1;		// write done
N        unsigned    int_rx_done_clr:           1;		// read done
N        unsigned    int_sric_ready_clr:        1;		// sample & ADC done per one MUX
N        unsigned    int_mux_done_clr:          1;		//
N        unsigned    int_fr_done_clr:           1;		// all MUX done
N        unsigned    int_chksum_clr:            1;		// checksum err
N        unsigned    reserved:                  26;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_INT_CLR;
N
Ntypedef union
N{
N    struct {
N        unsigned    int_tx_done_en:            1;
N        unsigned    int_rx_done_en:            1;
N        unsigned    int_sric_ready_en:         1;
N        unsigned    int_mux_done_en:           1;
N        unsigned    int_fr_done_en:            1;
N        unsigned    int_chksum_en:             1;
N        unsigned    int_sric_ready_mask_en:	   1;
N        unsigned    reserved:                  25;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_INT_EN;
N
Ntypedef union
N{
N    struct {
N        unsigned    tx_en:                     1;
N        unsigned    tr_en:                     1;
N        unsigned    bulk_en:                   1;
N        unsigned    bulk_num:                  8;
N        unsigned    checksum_en:               1;
N        unsigned    int_mux_done_sel:          1;
N        unsigned    reserved:                  19;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_CR1;
N
Ntypedef union
N{
N    struct {
N        unsigned    tx_lsb_first_en:           1;
N        unsigned    rx_lsb_first_en:           1;
N        unsigned    header_len:                2;
N        unsigned    header_num:                3;
N        unsigned    rdmy_len:                  1;
N        unsigned    wdmy_len:                  1;
N        unsigned    ait_mode:                  1;
N        unsigned    buf_mode:                  1;
N        unsigned    sense_done_sel:            2;
N        unsigned    wdata_len:                 1;
N        unsigned    rdata_len:                 2;
N        unsigned    tx_number:                 2;
N        unsigned    rx_number:                 2;
N        unsigned    mem_addr_clr:              1;
N        unsigned    tx0_on:                    1;
N        unsigned    tx1_on:                    1;
N        unsigned    rx0_on:                    1;
N        unsigned    rx1_on:                    1;
N        unsigned    rx2_on:                    1;
N        unsigned    rx3_on:                    1;
N        unsigned    reserved:                  5;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_CR2;
N
Ntypedef union
N{
N    struct {
N        unsigned    trdy_smpl_dly:             8;
N        unsigned    mask_dly:                  6;
N        unsigned    reserved:                  18;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_DLY;
N
Ntypedef union
N{
N    struct {
N        unsigned    sric_number:               4;
N        unsigned    buf_number:                3;
N        unsigned    mux_number:                7;
N        unsigned    tdat_pdn_pre_num:		   3;
N        unsigned    tdat_drv_pre_num:   	   3;
N        unsigned    reserved:                  12;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_CR3;
N
Ntypedef union
N{
N    struct {
N        unsigned    TCSN0:               	   1;
N        unsigned    TXCLK0:                	   1;
N        unsigned    TDAT0:                	   1;
N        unsigned    TCSN1:		   			   1;
N        unsigned    TXCLK1:   	   			   1;
N        unsigned    TDAT1:               	   1;
N        unsigned    RXCLK0:                	   1;
N        unsigned    RDAT0:                	   1;
N        unsigned    RXCLK1:                	   1;
N        unsigned    RDAT1:                	   1;
N        unsigned    RXCLK2:                	   1;
N        unsigned    RDAT2:                	   1;
N        unsigned    RXCLK3:                	   1;
N        unsigned    RDAT3:                	   1;
N        unsigned    reserved:                  18;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_INV_CR;
N
Ntypedef union
N{
N    struct {
N        unsigned    tlvds_findex0:             7;
N        unsigned    reserved0:                 1;
N        unsigned    tlvds_findex1:             7;
N        unsigned    reserved1:                 1;
N        unsigned    tlvds_findex2:             7;
N        unsigned    reserved2:                 1;
N        unsigned    tlvds_findex3:             7;
N        unsigned    reserved3:                 1;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_FINDEX0;
N
Ntypedef union
N{
N    struct {
N        unsigned    tlvds_findex4:             7;
N        unsigned    reserved4:                 1;
N        unsigned    tlvds_findex5:             7;
N        unsigned    reserved5:                 1;
N        unsigned    tlvds_findex6:             7;
N        unsigned    reserved6:                 1;
N        unsigned    tlvds_findex7:             7;
N        unsigned    reserved7:                 1;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_TLVDS_FINDEX1;
N
Ntypedef struct
N{
N    __O  t_TLVDS_CTRL                TLVDS_CTRL;                     //0x0000
X    volatile  t_TLVDS_CTRL                TLVDS_CTRL;                     
N    __IO t_TLVDS_PHY_STUCK_CR        TLVDS_PHY_STUCK_CR;             //0x0001
X    volatile t_TLVDS_PHY_STUCK_CR        TLVDS_PHY_STUCK_CR;             
N    __IO t_TLVDS_PHY_STUCK_VALUE     TLVDS_PHY_STUCK_VALUE;          //0x0002
X    volatile t_TLVDS_PHY_STUCK_VALUE     TLVDS_PHY_STUCK_VALUE;          
N    __IO t_INTERVAL_CR               INTERVAL_CR;                    //0x0003
X    volatile t_INTERVAL_CR               INTERVAL_CR;                    
N    __IO uint32_t                    TLVDS_RESERVED00;               //0x0004
X    volatile uint32_t                    TLVDS_RESERVED00;               
N    __IO uint32_t                    TLVDS_RESERVED01;               //0x0005
X    volatile uint32_t                    TLVDS_RESERVED01;               
N    __IO uint32_t                    TLVDS_RESERVED02;               //0x0006
X    volatile uint32_t                    TLVDS_RESERVED02;               
N    __IO uint32_t                    TLVDS_RESERVED03;               //0x0007
X    volatile uint32_t                    TLVDS_RESERVED03;               
N    __IO uint32_t                    TX0_ST_ADDR;                    //0x0008
X    volatile uint32_t                    TX0_ST_ADDR;                    
N    __IO uint32_t                    TX1_ST_ADDR;                    //0x0009
X    volatile uint32_t                    TX1_ST_ADDR;                    
N    __IO uint32_t                    RX0_ST_ADDR;                    //0x000A
X    volatile uint32_t                    RX0_ST_ADDR;                    
N    __IO uint32_t                    RX1_ST_ADDR;                    //0x000B
X    volatile uint32_t                    RX1_ST_ADDR;                    
N    __IO uint32_t                    RX2_ST_ADDR;                    //0x000C
X    volatile uint32_t                    RX2_ST_ADDR;                    
N    __IO uint32_t                    RX3_ST_ADDR;                    //0x000D
X    volatile uint32_t                    RX3_ST_ADDR;                    
N    __IO t_AFE_ON_TIME               AFE_ON_TIME;                    //0x000E
X    volatile t_AFE_ON_TIME               AFE_ON_TIME;                    
N    __I  t_RX_STATUS                 RX_STATUS;                      //0x000F
X    volatile const  t_RX_STATUS                 RX_STATUS;                      
N    __I  t_TLVDS_STATUS              TLVDS_STATUS;                   //0x0010
X    volatile const  t_TLVDS_STATUS              TLVDS_STATUS;                   
N    __O  t_INT_CLR                   INT_CLR;                        //0x0011
X    volatile  t_INT_CLR                   INT_CLR;                        
N    __IO t_INT_EN                    INT_EN;                         //0x0012
X    volatile t_INT_EN                    INT_EN;                         
N    __IO t_TLVDS_CR1                 TLVDS_CR1;                      //0x0013
X    volatile t_TLVDS_CR1                 TLVDS_CR1;                      
N    __IO t_TLVDS_CR2                 TLVDS_CR2;                      //0x0014
X    volatile t_TLVDS_CR2                 TLVDS_CR2;                      
N    __IO t_TLVDS_DLY                 TLVDS_DLY;                      //0x0015
X    volatile t_TLVDS_DLY                 TLVDS_DLY;                      
N    __IO t_TLVDS_CR3                 TLVDS_CR3;                      //0x0016
X    volatile t_TLVDS_CR3                 TLVDS_CR3;                      
N    __IO t_TLVDS_INV_CR				 TLVDS_INV_CR;                   //0x0017
X    volatile t_TLVDS_INV_CR				 TLVDS_INV_CR;                   
N    __IO t_TLVDS_FINDEX0             TLVDS_FINDEX0;                  //0x0018
X    volatile t_TLVDS_FINDEX0             TLVDS_FINDEX0;                  
N    __IO t_TLVDS_FINDEX1             TLVDS_FINDEX1;                  //0x0019
X    volatile t_TLVDS_FINDEX1             TLVDS_FINDEX1;                  
N
N} tTLVDS_CtrlReg_t ;
N
N#endif /* __TLVDS_H_ */
L 256 "..\..\Hal\system\MFTP.h" 2
N#include "_flitf.h"
L 1 "..\..\Hal\flitf\_flitf.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _flitf.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N/* ================================================================================ */
N/* ================                     FLITF                      ================ */
N/* ================================================================================ */
N
N#ifndef __FLITF_H_
N#define __FLITF_H_
N
N
Ntypedef union
N{
N    struct {
N	    unsigned	LATENCY:					4;
N        unsigned	Reserved:					28;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FACR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	RBB:						1;
N	    unsigned	Reserved0:                  1;
N	    unsigned	PGERR:                      1;
N	    unsigned	Reserved1:                  1;
N	    unsigned	Reserved2:                  1;
N	    unsigned	EOP:                        1;
N	    unsigned	INT_FLITF:                  1;
N	    unsigned	Reserved3:                  1;
N	    unsigned	KEY1_OK:                    1;
N	    unsigned	KEY2_OK:                    1;
N	    unsigned	Reserved4:                  1;
N	    unsigned	Reserved5:                  1;
N	    unsigned	ISP_MODE:                   1;
N	    unsigned	ISP_REGISTER:               1;
N	    unsigned	AHBPATH_EN:                 1;
N	    unsigned	Reserved6:                  1;
N	    unsigned	STANDBY:                    1;
N	    unsigned	WFIC_EN:                    1;
N	    unsigned	Reserved7:                  1;
N	    unsigned	CE:                         1;
N	    unsigned	fsm_wfirgset:               1;
N	    unsigned	fsm_rdmd:                   1;
N	    unsigned	fsm_wrmd:                   1;
N	    unsigned	fsm_scer:                   1;
N	    unsigned	fsm_mcer:                   1;
N	    unsigned	fsm_wfic:                   1;
N	    unsigned	fsm_isp:                    1;
N	    unsigned	fsm_ifmd:                   1;
N	    unsigned	fsm_ifbrd:                  1;
N	    unsigned	fsm_idle:                   1;
N	    unsigned	fsm_bist:                   1;
N	    unsigned	BIST_MODE:                  1;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FSR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	PG:                         1;
N	    unsigned	PER:                        1;
N	    unsigned	MER:                        1;
N	    unsigned	READ:                       1;
N	    unsigned	Reserved0:                  1;
N	    unsigned	Reserved1:                  1;
N	    unsigned	STRT:                       1;
N	    unsigned	LOCK:                       1;
N	    unsigned	WFRGSET:                    1;
N	    unsigned	WFIETEN:                    1;
N	    unsigned	ERRIE:                      1;
N	    unsigned	Reserved2:                  1;
N	    unsigned	EOPIE:                      1;
N	    unsigned	CE_TIE_LOW:                 1;
N	    unsigned	CE_SLP:                     1;
N	    unsigned	CE_OPTEN:                   1;
N	    unsigned	CE_OPTVAL:                  1;
N	    unsigned	Reserved3:                  5;
N	    unsigned	OTFLPG_DIS:                 1;
N	    unsigned	Reserved4:                  8;
N	    unsigned	NVSTRSEL:                   1;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FCR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	Address:                    18;
N        unsigned	Reserved:					14;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FAR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	INF:                        1;
N	    unsigned	SAVEN:                      1;
N	    unsigned	WRONLY:                     1;
N	    unsigned	PROG:                       1;
N	    unsigned	PERASE:                     1;
N	    unsigned	SERASE:                     1;
N	    unsigned	SAV_SRCSEL:                 1;
N	    unsigned	Reserved0:                  1;
N	    unsigned	TM:                         4;
N        unsigned	Reserved1:					20;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FCR1;
N
Ntypedef union
N{
N    struct {
N	    unsigned	PGM_BYTE_LEN:               5;
N	    unsigned	Reserved0:                  2;
N	    unsigned	SFR_WREN:                   1;
N        unsigned	Reserved1:					24;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FCR2;
N
Ntypedef union
N{
N    struct {
N	    unsigned	FCELL_TEST_EN:              1;
N	    unsigned	Reserved:                   31;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_ANASWCR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	LT_MD:                      1;
N	    unsigned	Reserved:                   31;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FACR1;
N
Ntypedef union
N{
N    struct {
N	    unsigned	EN_KEY1_ERR:				1;
N	    unsigned	EN_KEY2_ERR:                1;
N	    unsigned	Reserved0:                  1;
N	    unsigned	Reserved1:                  1;
N	    unsigned	EN_LOCK_WR0_ERR:            1;
N	    unsigned	Reserved:                   1;
N	    unsigned	EN_FAR_DW_ERR:              1;
N	    unsigned	EN_FRDRLW_WR_ERR:           1;
N	    unsigned	Reserved2:                  24;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_ERRESPCR;
N
Ntypedef union
N{
N    struct {
N    	unsigned	ISP_REGISTER:               1;
N    	unsigned	Reserved:                   31;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_ISPMSCR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	IFBRD_TCNT_END:				10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_IFBRD_TCNT_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	MCER_TCNT_END:              10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_MCER_TCNT_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	SCER_TCNT_END:              10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_SCER_TCNT_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	WRMD_TCNT_END:              10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_WRMD_TCNT_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	RDMD_TCNT_END:              10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_RDMD_TCNT_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_MCER_STR:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_MCER_STR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_SCER_STR:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_SCER_STR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_WRMD_STR:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_WRMD_STR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_RDMD_STR:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_RDMD_STR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_MCER_END:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_MCER_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_SCER_END:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_SCER_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_WRMD_END:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_WRMD_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	AE_RDMD_END:                10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_AE_RDMD_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	NVSTR_MCER_STR:             10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_NVSTR_MCER_STR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	NVSTR_SCER_STR:             10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_NVSTR_SCER_STR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	NVSTR_WRMD_STR:             10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_NVSTR_WRMD_STR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	NVSTR_MCER_LTH:             12;
N	    unsigned	Reserved:                   20;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_NVSTR_MCER_LTH;
N
Ntypedef union
N{
N    struct {
N	    unsigned	NVSTR_SCER_LTH:             12;
N	    unsigned	Reserved:                   20;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_NVSTR_SCER_LTH;
N
Ntypedef union
N{
N    struct {
N	    unsigned	NVSTR_WRMD_LTH:             12;
N	    unsigned	Reserved:                   20;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_NVSTR_WRMD_LTH;
N
Ntypedef union
N{
N    struct {
N	    unsigned	DOUTVALID_RDMD:             10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DOUTVALID_RDMD;
N
Ntypedef union
N{
N    struct {
N	    unsigned	WFRGSET_TCNT_END:           10;
N	    unsigned	Reserved:                   22;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_WFRGSET_TCNT_END;
N
Ntypedef union
N{
N    struct {
N	    unsigned	FSMDBG0:                    1;
N	    unsigned	FSMDBG1:                    1;
N	    unsigned	Reserved:                   30;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DBGR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	Reserved0:                  7;
N	    unsigned	NB_PAGE_NUM:                8;
N	    unsigned	Reserved1:                  1;
N	    unsigned	Reserved2:                  5;
N	    unsigned	INFO_PAGE_NUM:              10;
N	    unsigned	Reserved3:                  1;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_BCR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	FSM_INIT:                   1;
N	    unsigned	Reserved:                   31;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FSM_INIT;
N
Ntypedef union
N{
N    struct {
N	    unsigned	NERASE_EN:                  1;
N	    unsigned	NERRD_EN:                   1;
N	    unsigned	NPG_EN:                     1;
N	    unsigned	NPGRD_EN:                   1;
N	    unsigned	IERASE_EN:                  1;
N	    unsigned	IERRD_EN:                   1;
N	    unsigned	IPG_EN:                     1;
N	    unsigned	IPGRD_EN:                   1;
N	    unsigned	SECTOR_NUM:                 4;
N	    unsigned	Reserved:                   20;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_BSCR;
N
Ntypedef union
N{
N    struct {
N	    unsigned	DEVICE_ID:                  24;
N	    unsigned	Reserved:                   8;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_DEVID;
N
Ntypedef union
N{
N    struct {
N	    unsigned	POR:                        1;
N	    unsigned	ECC_EN:                     1;
N        unsigned	reserved:					30;
N    } tBit;
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N} t_FUSRCTRL;
N
Ntypedef union
N{
N    struct {
N	    unsigned	PAT_OUT:                    1;
N	    unsigned	UNKNOWN_ERR:                1;
N	    unsigned	ECC_FLAG:                   1;
N        unsigned	reserved:					24;
N    } tBit;
N    __I uint32_t ulBulk;
X    volatile const uint32_t ulBulk;
N} t_FECCST;
N
N
Ntypedef struct
N{
N	__IO t_FACR 				FACR;
X	volatile t_FACR 				FACR;
N	__IO uint32_t 				FKEYR;
X	volatile uint32_t 				FKEYR;
N	__IO uint32_t 				FOPTKEYR;
X	volatile uint32_t 				FOPTKEYR;
N	__IO t_FSR 					FSR;
X	volatile t_FSR 					FSR;
N	__IO t_FCR 					FCR;
X	volatile t_FCR 					FCR;
N	__IO t_FAR 					FAR;
X	volatile t_FAR 					FAR;
N	__IO t_FCR1 				FCR1;
X	volatile t_FCR1 				FCR1;
N	__IO t_FCR2 				FCR2;
X	volatile t_FCR2 				FCR2;
N	__IO uint32_t 				FLASH_RESERVED0;
X	volatile uint32_t 				FLASH_RESERVED0;
N	__IO t_ANASWCR 				ANASWCR;
X	volatile t_ANASWCR 				ANASWCR;
N	__IO uint32_t 				FWDRLW;
X	volatile uint32_t 				FWDRLW;
N	__IO t_FACR1 				FACR1;
X	volatile t_FACR1 				FACR1;
N	__I	 uint32_t 				FRDRLW;
X	volatile const	 uint32_t 				FRDRLW;
N	__IO uint32_t 				FLASH_RESERVED1;
X	volatile uint32_t 				FLASH_RESERVED1;
N	__I  uint32_t 				PGERSR0;
X	volatile const  uint32_t 				PGERSR0;
N	__I  uint32_t 				PGERSR1;
X	volatile const  uint32_t 				PGERSR1;
N	__I  uint32_t 				PGERSR2;
X	volatile const  uint32_t 				PGERSR2;
N	__I  uint32_t 				PGERSR3;
X	volatile const  uint32_t 				PGERSR3;
N	__IO t_ERRESPCR 			ERRESPCR;
X	volatile t_ERRESPCR 			ERRESPCR;
N	__IO t_ISPMSCR 				ISPMSCR;
X	volatile t_ISPMSCR 				ISPMSCR;
N	__IO uint32_t 				FLASH_RESERVED2;
X	volatile uint32_t 				FLASH_RESERVED2;
N	__IO uint32_t 				FLASH_RESERVED3;
X	volatile uint32_t 				FLASH_RESERVED3;
N	__IO uint32_t 				FLASH_RESERVED4;
X	volatile uint32_t 				FLASH_RESERVED4;
N	__IO uint32_t 				FLASH_RESERVED5;
X	volatile uint32_t 				FLASH_RESERVED5;
N	__IO uint32_t 				PROTECTION;
X	volatile uint32_t 				PROTECTION;
N	__I  uint32_t 				PGERSR4;
X	volatile const  uint32_t 				PGERSR4;
N	__I  uint32_t 				PGERSR5;
X	volatile const  uint32_t 				PGERSR5;
N	__I  uint32_t 				PGERSR6;
X	volatile const  uint32_t 				PGERSR6;
N	__I  uint32_t 				PGERSR7;
X	volatile const  uint32_t 				PGERSR7;
N	__I  uint32_t 				PGERSR8;
X	volatile const  uint32_t 				PGERSR8;
N	__I  uint32_t 				PGERSR9;
X	volatile const  uint32_t 				PGERSR9;
N	__I  uint32_t 				PGERSR10;
X	volatile const  uint32_t 				PGERSR10;
N	__IO t_IFBRD_TCNT_END 		IFBRD_TCNT_END;
X	volatile t_IFBRD_TCNT_END 		IFBRD_TCNT_END;
N	__IO t_MCER_TCNT_END 		MCER_TCNT_END;
X	volatile t_MCER_TCNT_END 		MCER_TCNT_END;
N	__IO t_SCER_TCNT_END 		SCER_TCNT_END;
X	volatile t_SCER_TCNT_END 		SCER_TCNT_END;
N	__IO t_WRMD_TCNT_END 		WRMD_TCNT_END;
X	volatile t_WRMD_TCNT_END 		WRMD_TCNT_END;
N	__IO t_RDMD_TCNT_END 		RDMD_TCNT_END;
X	volatile t_RDMD_TCNT_END 		RDMD_TCNT_END;
N	__IO uint32_t 				FLASH_RESERVED6;
X	volatile uint32_t 				FLASH_RESERVED6;
N	__IO t_AE_MCER_STR 			AE_MCER_STR;
X	volatile t_AE_MCER_STR 			AE_MCER_STR;
N	__IO t_AE_SCER_STR 			AE_SCER_STR;
X	volatile t_AE_SCER_STR 			AE_SCER_STR;
N	__IO t_AE_WRMD_STR 			AE_WRMD_STR;
X	volatile t_AE_WRMD_STR 			AE_WRMD_STR;
N	__IO t_AE_RDMD_STR 			AE_RDMD_STR;
X	volatile t_AE_RDMD_STR 			AE_RDMD_STR;
N	__IO uint32_t 				FLASH_RESERVED7;
X	volatile uint32_t 				FLASH_RESERVED7;
N	__IO t_AE_MCER_END 			AE_MCER_END;
X	volatile t_AE_MCER_END 			AE_MCER_END;
N	__IO t_AE_SCER_END 			AE_SCER_END;
X	volatile t_AE_SCER_END 			AE_SCER_END;
N	__IO t_AE_WRMD_END 			AE_WRMD_END;
X	volatile t_AE_WRMD_END 			AE_WRMD_END;
N	__IO t_AE_RDMD_END 			AE_RDMD_END;
X	volatile t_AE_RDMD_END 			AE_RDMD_END;
N	__IO t_NVSTR_MCER_STR 		NVSTR_MCER_STR;
X	volatile t_NVSTR_MCER_STR 		NVSTR_MCER_STR;
N	__IO t_NVSTR_SCER_STR 		NVSTR_SCER_STR;
X	volatile t_NVSTR_SCER_STR 		NVSTR_SCER_STR;
N	__IO t_NVSTR_WRMD_STR 		NVSTR_WRMD_STR;
X	volatile t_NVSTR_WRMD_STR 		NVSTR_WRMD_STR;
N	__IO t_NVSTR_MCER_LTH 		NVSTR_MCER_LTH;
X	volatile t_NVSTR_MCER_LTH 		NVSTR_MCER_LTH;
N	__IO t_NVSTR_SCER_LTH 		NVSTR_SCER_LTH;
X	volatile t_NVSTR_SCER_LTH 		NVSTR_SCER_LTH;
N	__IO t_NVSTR_WRMD_LTH 		NVSTR_WRMD_LTH;
X	volatile t_NVSTR_WRMD_LTH 		NVSTR_WRMD_LTH;
N	__IO uint32_t 				FLASH_RESERVED8;
X	volatile uint32_t 				FLASH_RESERVED8;
N	__IO t_DOUTVALID_RDMD 		DOUTVALID_RDMD;
X	volatile t_DOUTVALID_RDMD 		DOUTVALID_RDMD;
N	__IO uint32_t 				FLASH_RESERVED9;
X	volatile uint32_t 				FLASH_RESERVED9;
N	__IO uint32_t 				FLASH_RESERVED10;
X	volatile uint32_t 				FLASH_RESERVED10;
N	__IO t_WFRGSET_TCNT_END 	WFRGSET_TCNT_END;
X	volatile t_WFRGSET_TCNT_END 	WFRGSET_TCNT_END;
N	__IO t_DBGR 				DBGR;
X	volatile t_DBGR 				DBGR;
N	__IO t_BCR 					BCR;
X	volatile t_BCR 					BCR;
N	__IO uint32_t 				BWDRLW;
X	volatile uint32_t 				BWDRLW;
N	__IO t_FSM_INIT 			FSM_INIT;
X	volatile t_FSM_INIT 			FSM_INIT;
N	__IO t_BSCR 				BSCR;
X	volatile t_BSCR 				BSCR;
N	__IO t_DEVID 				DEVID;
X	volatile t_DEVID 				DEVID;
N	__IO uint32_t 				FWDRLW01;
X	volatile uint32_t 				FWDRLW01;
N	__IO uint32_t 				FWDRLW02;
X	volatile uint32_t 				FWDRLW02;
N	__IO uint32_t 				FWDRLW03;
X	volatile uint32_t 				FWDRLW03;
N	__IO uint32_t 				FWDRLW04;
X	volatile uint32_t 				FWDRLW04;
N	__IO uint32_t 				FWDRLW05;
X	volatile uint32_t 				FWDRLW05;
N	__IO uint32_t 				FWDRLW06;
X	volatile uint32_t 				FWDRLW06;
N	__IO uint32_t 				FWDRLW07;
X	volatile uint32_t 				FWDRLW07;
N	__IO uint32_t 				FWDRLW08;
X	volatile uint32_t 				FWDRLW08;
N	__IO uint32_t 				FWDRLW09;
X	volatile uint32_t 				FWDRLW09;
N	__IO uint32_t 				FWDRLW10;
X	volatile uint32_t 				FWDRLW10;
N	__IO uint32_t 				FWDRLW11;
X	volatile uint32_t 				FWDRLW11;
N	__IO uint32_t 				FWDRLW12;
X	volatile uint32_t 				FWDRLW12;
N	__IO uint32_t 				FWDRLW13;
X	volatile uint32_t 				FWDRLW13;
N	__IO uint32_t 				FWDRLW14;
X	volatile uint32_t 				FWDRLW14;
N	__IO uint32_t 				FWDRLW15;
X	volatile uint32_t 				FWDRLW15;
N	__IO uint32_t 				FWDRLW16;
X	volatile uint32_t 				FWDRLW16;
N	__IO uint32_t 				FWDRLW17;
X	volatile uint32_t 				FWDRLW17;
N	__IO uint32_t 				FWDRLW18;
X	volatile uint32_t 				FWDRLW18;
N	__IO uint32_t 				FWDRLW19;
X	volatile uint32_t 				FWDRLW19;
N	__IO uint32_t 				FWDRLW20;
X	volatile uint32_t 				FWDRLW20;
N	__IO uint32_t 				FWDRLW21;
X	volatile uint32_t 				FWDRLW21;
N	__IO uint32_t 				FWDRLW22;
X	volatile uint32_t 				FWDRLW22;
N	__IO uint32_t 				FWDRLW23;
X	volatile uint32_t 				FWDRLW23;
N	__IO uint32_t 				FWDRLW24;
X	volatile uint32_t 				FWDRLW24;
N	__IO uint32_t 				FWDRLW25;
X	volatile uint32_t 				FWDRLW25;
N	__IO uint32_t 				FWDRLW26;
X	volatile uint32_t 				FWDRLW26;
N	__IO uint32_t 				FWDRLW27;
X	volatile uint32_t 				FWDRLW27;
N	__IO uint32_t 				FWDRLW28;
X	volatile uint32_t 				FWDRLW28;
N	__IO uint32_t 				FWDRLW29;
X	volatile uint32_t 				FWDRLW29;
N	__IO uint32_t 				FWDRLW30;
X	volatile uint32_t 				FWDRLW30;
N	__IO uint32_t 				FWDRLW31;
X	volatile uint32_t 				FWDRLW31;
N	__I  uint32_t 				PGERSR11;
X	volatile const  uint32_t 				PGERSR11;
N	__I  uint32_t 				PGERSR12;
X	volatile const  uint32_t 				PGERSR12;
N	__I  uint32_t 				PGERSR13;
X	volatile const  uint32_t 				PGERSR13;
N	__I  uint32_t 				PGERSR14;
X	volatile const  uint32_t 				PGERSR14;
N	__I  uint32_t 				PGERSR15;
X	volatile const  uint32_t 				PGERSR15;
N	__I  uint32_t 				PGERSR16;
X	volatile const  uint32_t 				PGERSR16;
N	__I  uint32_t 				PGERSR17;
X	volatile const  uint32_t 				PGERSR17;
N	__I  uint32_t 				PGERSR18;
X	volatile const  uint32_t 				PGERSR18;
N	__I  uint32_t 				PGERSR19;
X	volatile const  uint32_t 				PGERSR19;
N	__I  uint32_t 				PGERSR20;
X	volatile const  uint32_t 				PGERSR20;
N	__I  uint32_t 				PGERSR21;
X	volatile const  uint32_t 				PGERSR21;
N	__I  uint32_t 				PGERSR22;
X	volatile const  uint32_t 				PGERSR22;
N	__I  uint32_t 				PGERSR23;
X	volatile const  uint32_t 				PGERSR23;
N	__I  uint32_t 				PGERSR24;
X	volatile const  uint32_t 				PGERSR24;
N	__I  uint32_t 				PGERSR25;
X	volatile const  uint32_t 				PGERSR25;
N	__I  uint32_t 				PGERSR26;
X	volatile const  uint32_t 				PGERSR26;
N	__I  uint32_t 				PGERSR27;
X	volatile const  uint32_t 				PGERSR27;
N	__I  uint32_t 				PGERSR28;
X	volatile const  uint32_t 				PGERSR28;
N	__I  uint32_t 				PGERSR29;
X	volatile const  uint32_t 				PGERSR29;
N	__I  uint32_t 				PGERSR30;
X	volatile const  uint32_t 				PGERSR30;
N	__I  uint32_t 				PGERSR31;
X	volatile const  uint32_t 				PGERSR31;
N	__IO t_FUSRCTRL 			FUSRCTRL;
X	volatile t_FUSRCTRL 			FUSRCTRL;
N	__I  uint32_t 				FECCPIN;
X	volatile const  uint32_t 				FECCPIN;
N	__I  t_FECCST 				FECCST;
X	volatile const  t_FECCST 				FECCST;
N	__O  uint32_t 				FECCCNTCLR;
X	volatile  uint32_t 				FECCCNTCLR;
N} tFLASH_CtrlReg_t;
N
N#endif
L 257 "..\..\Hal\system\MFTP.h" 2
N#include "_i2c.h"
L 1 "..\..\Hal\i2c\_i2c.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _i2c.h
N * created on : 10. 05. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __I2C_H_
N#define __I2C_H_
N
N
N/* ================================================================================ */
N/* ================                      I2C                       ================ */
N/* ================================================================================ */
N
Ntypedef union
N{
N	struct {
N		unsigned	I2cId:					7;	// I2C Master/Slave Device Address
N		unsigned	reserved:				25;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} t_I2C_DEVICE_ADDR;	// I2C Master/Slave Device Address Register
N
Ntypedef union
N{
N	struct {
N		unsigned	I2cSWReset:				1;	// I2C Software Reset
N		unsigned 	reserved:				31;
N	} tBit;
N	__O uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} t_I2C_SW_RESET;	// I2C Master/Slave Software Reset Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cItrptEn:       			1;	// I2C Interrupt Enable
N		unsigned I2cStrItrptEn:     		1;	// I2C Slave Start Interrupt Enable
N		unsigned I2cStpItrptEn:     		1;	// I2C Stop Interrupt Enable
N		unsigned I2cAddChkItrptEn:  		1;	// I2C Slave Device Address matched Interrupt Enable
N		unsigned I2cByteItrptEn:    		1;	// I2C Slave Byte Done Interrupt Enable
N		unsigned I2cMstItrptEn:     		1;	// I2C Master Packet Done Interrupt Enable
N		unsigned I2cIspModeEn:      		1;	// I2C ISP Protocol Entry Mode Enable
N		unsigned I2cTxFifoItrptEn:  		1;	// I2C TX FIFO Interrupt Enable
N		unsigned I2cRxFifoItrptEn:  		1;	// I2C RX FIFO Interrupt Enable
N		unsigned I2cSclHoldItrptEn: 		1;	// I2C SCL Hold Interrupt Enable
N		unsigned I2cFilterEn:				1;	// I2C Filter Enable
N		unsigned reserved:					21;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} t_I2C_GLB_CR;	// I2C Interrupt Control Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cMstClkDiv: 				16;	// I2C Master SCLK Clock Divide Value
N		unsigned reserved:					16;
N	} tBit;
N	__IO uint32_t ulBulk;	  // 0x0C
X	volatile uint32_t ulBulk;	  
N} t_I2C_MST_CR1;	// I2C Master Control Register 1
N
Ntypedef union
N{
N	struct {
N		unsigned I2cMstDataTr: 				8;	// I2C Master Data Transfer
N		unsigned I2cMstStr: 				1;	// I2C Master Start Condition
N		unsigned I2cMstStop:				1;	// I2C Master Stop Condition
N		unsigned I2cMstRcvMode:				1;	// I2C Master Receive Mode
N		unsigned I2cMstNackTr:				1;	// I2C Ack Condition
N		unsigned reserved:					20;
N	} tBit;
N	__IO uint32_t ulBulk;	  // 0x10
X	volatile uint32_t ulBulk;	  
N} t_I2C_MST_CR2;	// I2C Master Control Register 2
N
Ntypedef union
N{
N	struct {
N		unsigned I2C_ITRPT:					1;	// I2C Interrupt Flag
N		unsigned reserved00:				1;	// Not Used
N		unsigned IspMode:          			1;	// I2C ISP Mode Status
N		unsigned I2cSlvRdWrFlag:   			1;	// I2C Slave R/W Condition Status
N		unsigned I2cSlvAckRcv:     			1;	// I2C Slave Ack Condition
N		unsigned I2cPacketEn:      			1;	// I2CMaster packet Status
N		unsigned I2cMstAckRcv:     			1;	// I2C Master Received Ack Condition
N		unsigned reserved01:            	1;	// Not Used
N		unsigned I2cMstDataRcv:    			8;	// I2C Master Received Data Status
N		unsigned I2cItrptState:    			4;	// I2C Interrupt State
N		unsigned reserved:					12;
N	} tBit;
N	__IO uint32_t ulBulk;		  // 0x14
X	volatile uint32_t ulBulk;		  
N} t_I2C_GLB_SR;	// I2C Global Status Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cSlvStSR:    			14;	// I2C Slave FSM Status
N		unsigned reserved:					18;
N	} tBit;
N	__I  uint32_t ulBulk;	  // 0x18
X	volatile const  uint32_t ulBulk;	  
N} t_I2C_SLV_ST_SR;	// I2C Slave Status Register
N
Ntypedef union
N{
N	struct {
N		unsigned TxFifoInit:     			1;	// I2C TXFIFO WPTR / RPTR Clear
N		unsigned TxDmaIfEn :     			1;	// I2C DMA I/F TX Enable
N		unsigned TxFifoWmLv:     			5;	// I2C TXFIFO Watermark Level
N		unsigned TxFifoReqSel:   			1;	// TXFIFO Request Selection
N		unsigned RxFifoInit:     			1;	// I2C RXFIFO WPTR / RPTR Clear
N		unsigned RxDmaIfEn:      			1;	// I2C DMA I/F RX Enable
N		unsigned RxFifoWmLv:     			5;	// I2C RXFIFO Watermark Level
N		unsigned RxFifoReqSel:   			1;	// RXFIFO Request Selection
N		unsigned reserved:					16;
N	} tBit;
N	__IO uint32_t ulBulk;	  // 0x1C
X	volatile uint32_t ulBulk;	  
N} t_I2C_FIFO_CR;	// I2C FIFO Control Register
N
Ntypedef union
N{
N	struct {
N		unsigned TxFifoData:   				8;	// TXFIFO Data	//	ToDo There is not on register map !!!
N		unsigned reserved:					24;
N	} tBit;
N	__O uint32_t ulBulk;  // 0x20
X	volatile uint32_t ulBulk;  
N} t_I2C_TXFIFO_DATA;	// I2C TXFIFO Data Register
N
Ntypedef union
N{
N	struct {
N		unsigned RxFifoData:   				8;	// RXFIFO Data	//	ToDo There is not on register map !!!
N		unsigned reserved:					24;
N	} tBit;
N	__I uint32_t ulBulk;  // 0x24
X	volatile const uint32_t ulBulk;  
N} t_I2C_RXFIFO_DATA;	// I2C RXFIFO Data Register
N
Ntypedef union
N{
N	struct {
N		unsigned TxFifoEmpty:    			1;	// TXFIFO Empty Flag
N		unsigned TxFifoFull:     			1;	// TXFIFO Full Flag
N		unsigned TxFifoWmFlag:   			1;	// TXFIFO Watermark Level Flag
N		unsigned TxFifoWmBlw:    			1;	// TXFIFO Watermark Level Below Flag
N		unsigned TxWrPtr:        			5;	// TXFIFO Write Pointer
N		unsigned TxRdPtr:        			5;	// TXFIFO Read Pointer
N		unsigned reserved00:				2;	// Not Used
N		unsigned RxFifoEmpty:    			1;	// RXFIFO Empty Flag
N		unsigned RxFifoFull:     			1;	// RXFIFO Full Flag
N		unsigned RxFifoWmFlag:   			1;	// RXFIFO Watermark Level Flag
N		unsigned RxFifoWmAbv:    			1;	// RXFIFO Watermark Level Above Flag
N		unsigned RxWrPtr:        			5;	// RXFIFO Write Pointer
N		unsigned RxRdPtr:       			5;	// RXFIFO Read Pointer
N		unsigned reserved01:          		2;	// Not Used
N	} tBit;
N	__I uint32_t ulBulk;  // 0x28
X	volatile const uint32_t ulBulk;  
N} t_I2C_FIFO_SR;	// I2C TXFIFO / RXFIFO Status Register
N
Ntypedef union
N{
N	struct {
N		unsigned SetPwrRegLSBOn:     		8;	// Power Register LSB for Wakeup Mode
N		unsigned SetPwrRegLSBSleep:  		8;	// Power Register LSB for Sleep Mode
N		unsigned SetPwrRegMSB:       		8;	// Register MSB of Power Mode
N		unsigned SetPwrRegLSBFirst:  		1;	// Set I2C protocol, LSB first
N		unsigned reserved:					7;
N	} tBit;
N	__IO uint32_t ulBulk;  // 0x2C
X	volatile uint32_t ulBulk;  
N} t_I2C_SET_PWR_REG;	// I2C Set Power Register
N
Ntypedef union
N{
N	struct {
N		unsigned SetPwrCmdLSB:     			8;	// Command LSB of Power Mode
N		unsigned SetPwrCmdMSB:     			8;	// Command MSB of Power mode
N		unsigned SetPwrCmdEn:      			1;	// Power Command Enable
N		unsigned SetPwrLSBFirst:   			1;	// Set I2C Protocol, LB first
N		unsigned reserved:					14;
N	} tBit;
N	__IO uint32_t ulBulk;  // 0x30
X	volatile uint32_t ulBulk;  
N} t_I2C_SET_PWR_CMD;	// I2C Set Power Command Register
N
Ntypedef union
N{
N	struct {
N		unsigned WakeUpItrptEn:    			1;	// Wake up Interrupt Enable
N		unsigned SleepItrptEn:     			1;	// Sleep Interrup Enable
N		unsigned WakeUpItrpt:      			1;	// Wake Up Interrupt
N		unsigned SleepItrpt:      	 		1;	// Sleep Interrupt
N		unsigned PowerState:        		1;	// State of Power Save Mode
N		unsigned reserved:					27;
N	} tBit;
N	__IO uint32_t ulBulk;  // 0x34
X	volatile uint32_t ulBulk;  
N} t_I2C_SET_PWR_INT;	// I2C Set Power Interrupt Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cDlyVal:    				6;	// Delay after negative edge of SCL
N		unsigned reserved:					26;
N	} tBit;
N	__IO uint32_t ulBulk;	  // 0x38
X	volatile uint32_t ulBulk;	  
N} t_I2C_DLY_VALUE;	// I2C Delay Value Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cSlvTrLen:    			15;	// I2C Slave Transfer Length
N		unsigned reserved00:				1;	// Not Used
N		unsigned I2cSlvTrCnt:     			15;	// I2C Slave Transfer Count Value
N		unsigned I2cSlvTrDone:    			1;	// I2C Slave Transfer Done Flag
N	} tBit;
N	__IO uint32_t ulBulk;	  // 0x3C
X	volatile uint32_t ulBulk;	  
N} t_I2C_SLV_DBG;	// I2C Slave Debugging Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cMstTrLen:    			15;	// I2C Master Transfer Length
N		unsigned reserved00:           		1;	// Not Used
N		unsigned I2cMstTrCnt:     			15;	// I2C Master Transfer Count Value
N		unsigned I2cMstTrDone:    			1;	// I2C Master Transfer Done Flag
N	} tBit;
N	__IO uint32_t ulBulk;	  // 0x40
X	volatile uint32_t ulBulk;	  
N} t_I2C_MST_DBG;	// I2C Master Debugging Register
N
Ntypedef union
N{
N	struct {
N		unsigned TxFifoInit2:    			1;	// TXFIFO WPTR / RPTR Clear
N		unsigned TxFifoIntEna2:  			1;	// Interrupt I/F TX Enable
N		unsigned TxFifoWmLv2:    			5;	// TXFIFO Watermark Level 2
N		unsigned TxFifoIntSel:   			1;	// TXFIFO Interrupt Selection
N		unsigned RxFifoInit2:    			1;	// RXFIFO WPTR / RPTR Clear
N		unsigned RxFifoIntEna2:  			1;	// Interrupt I/F RX Enable
N		unsigned RxFifoWmLv2:    			5;	// RXFIFO Watermark Level 2
N		unsigned RxFifoIntSel:   			1;	// RXFIFO Interrupt Selection
N		unsigned reserved:					16;
N	} tBit;
N	__IO uint32_t ulBulk;	  // 0x44
X	volatile uint32_t ulBulk;	  
N} t_I2C_FIFO_CR2;	// I2C FIFO Control Register 2
N
Ntypedef union
N{
N	struct {
N		unsigned TxFifoEmpty:    			1;	// TXFIFO Empty Flag
N		unsigned TxFifoFull:     			1;	// TXFIFO Full Flag
N		unsigned TxFifoWmFlag2:  			1;	// TXFIFO Watermark Level Flag
N		unsigned TxFifoWmBlw2:   			1;	// TXFIFO Watermark Level Below Flag
N		unsigned TxWrPtr:        			5;	// TXFIFO Write Pointer
N		unsigned TxRdPtr:        			5;	// TXFIFO Read Pointer
N		unsigned TxFifoInt:      			1;	// TXFIFO Interrupt
N		unsigned reserved00:           		1;	// Not Used
N		unsigned RxFifoEmpty:    			1;	// RXFIFO Empty Flag
N		unsigned RxFifoFull:     			1;	// RXFIFO Full Flag
N		unsigned RxFifoWmFlag2:  			1;	// RXFIFO Watermark Level Flag
N		unsigned RxFifoWmAbv2:   			1;	// RXFIFO Watermark Level Above Flag
N		unsigned RxWrPtr:        			5;	// RXFIFO Write Pointer
N		unsigned RxRdPtr:        			5;	// RXFIFO Read Pointer
N		unsigned RxFifoInt:      			1;	// RXFIFO Interrupt
N		unsigned reserved01:				1;
N	} tBit;
N	__I uint32_t ulBulk;	  // 0x48
X	volatile const uint32_t ulBulk;	  
N} t_I2C_FIFO_SR2;	// I2C TXFIFO / RXFIFO Status Register 2
N
Ntypedef union
N{
N	struct {
N		unsigned SlpCr:      				1;	// Sleep Enable
N		unsigned PrMux:      				1;	// APB Bus RDATA Selection
N		unsigned reserved:					30;
N	} tBit;
N	__IO uint32_t ulBulk;		  // 0x58
X	volatile uint32_t ulBulk;		  
N} t_I2C_SLP_CR; 	// I2C Sleep Control Register
N
Ntypedef union
N{
N	struct {
N		unsigned SlpSr:		 				1;	// Device Address Check Interrupt
N		unsigned PclkEna:	 				1;	// Normal PCLK Enable
N		unsigned PclkCr:		 			1;	// SCLK Enable
N		unsigned reserved:					29;
N	} tBit;
N	__IO uint32_t ulBulk;		  // 0x5C
X	volatile uint32_t ulBulk;		  
N} t_I2C_SLP_SR;	// I2C Sleep Status Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cSclHoldEn:		 		1;	// SCL Stretch Function1 Enable
N		unsigned I2cSclHoldStatus:	 		1;	// SCL Sretch Status
N		unsigned reserved:					30;
N	} tBit;
N	__IO uint32_t ulBulk;		  // 0x60
X	volatile uint32_t ulBulk;		  
N} t_I2C_SCL_HOLD;	// I2C SCL Stretch Control Register
N
Ntypedef union
N{
N	struct {
N		unsigned I2cSclHoldEn2:		 		1;	// SCL Stretch Fuction2 Enable
N		unsigned I2cSclHoldRls:		 		1;	// SCL Stretch Status
N		unsigned I2cSclHoldCntEn:	 		1;	// SCL Hold Timeout Count Enable
N		unsigned I2cSclHoldTOutSt:	 		1;	// SCL Hold Timeout Status
N		unsigned reserved00:				12;	// Not Used
N		unsigned I2cSclHoldTOutVal:	 		16;	// SCL Hold Timeout Counter Value
N	} tBit;
N	__IO uint32_t ulBulk;		  // 0x64
X	volatile uint32_t ulBulk;		  
N} t_I2C_SCL_HOLD2;	// I2C SCL Stretch Control Register 2
N
Ntypedef struct
N{																		//Index
N	__IO t_I2C_DEVICE_ADDR 			I2C_DEVICE_ADDR;						//0x0000
X	volatile t_I2C_DEVICE_ADDR 			I2C_DEVICE_ADDR;						
N	__O  t_I2C_SW_RESET				I2C_SW_RESET;                   	//0x0001
X	volatile  t_I2C_SW_RESET				I2C_SW_RESET;                   	
N	__IO t_I2C_GLB_CR  				I2C_GLB_CR;                     	//0x0002
X	volatile t_I2C_GLB_CR  				I2C_GLB_CR;                     	
N	__IO t_I2C_MST_CR1  			I2C_MST_CR1;                    	//0x0003
X	volatile t_I2C_MST_CR1  			I2C_MST_CR1;                    	
N	__IO t_I2C_MST_CR2 				I2C_MST_CR2;                    	//0x0004
X	volatile t_I2C_MST_CR2 				I2C_MST_CR2;                    	
N	__IO t_I2C_GLB_SR  				I2C_GLB_SR;                     	//0x0005
X	volatile t_I2C_GLB_SR  				I2C_GLB_SR;                     	
N	__I  t_I2C_SLV_ST_SR   			I2C_SLV_ST_SR;                  	//0x0006
X	volatile const  t_I2C_SLV_ST_SR   			I2C_SLV_ST_SR;                  	
N	__IO t_I2C_FIFO_CR 				I2C_FIFO_CR;                    	//0x0007
X	volatile t_I2C_FIFO_CR 				I2C_FIFO_CR;                    	
N	__O  uint32_t 					I2C_TXFIFO_DATA;                	//0x0008
X	volatile  uint32_t 					I2C_TXFIFO_DATA;                	
N	__I  uint32_t 					I2C_RXFIFO_DATA;                	//0x0009
X	volatile const  uint32_t 					I2C_RXFIFO_DATA;                	
N	__I  t_I2C_FIFO_SR 				I2C_FIFO_SR;                    	//0x000A
X	volatile const  t_I2C_FIFO_SR 				I2C_FIFO_SR;                    	
N	__IO t_I2C_SET_PWR_REG 			I2C_SET_PWR_REG;                	//0x000B
X	volatile t_I2C_SET_PWR_REG 			I2C_SET_PWR_REG;                	
N	__IO t_I2C_SET_PWR_CMD 			I2C_SET_PWR_CMD;                	//0x000C
X	volatile t_I2C_SET_PWR_CMD 			I2C_SET_PWR_CMD;                	
N	__IO t_I2C_SET_PWR_INT 			I2C_SET_PWR_INT;                	//0x000D
X	volatile t_I2C_SET_PWR_INT 			I2C_SET_PWR_INT;                	
N	__IO t_I2C_DLY_VALUE 			I2C_DLY_VALUE;                  	//0x000E
X	volatile t_I2C_DLY_VALUE 			I2C_DLY_VALUE;                  	
N	__IO t_I2C_SLV_DBG 				I2C_SLV_DBG;                    	//0x000F
X	volatile t_I2C_SLV_DBG 				I2C_SLV_DBG;                    	
N	__IO t_I2C_MST_DBG 				I2C_MST_DBG;                    	//0x0010
X	volatile t_I2C_MST_DBG 				I2C_MST_DBG;                    	
N	__IO t_I2C_FIFO_CR2 			I2C_FIFO_CR2;                   	//0x0011
X	volatile t_I2C_FIFO_CR2 			I2C_FIFO_CR2;                   	
N	__I  t_I2C_FIFO_SR2 			I2C_FIFO_SR2;                   	//0x0012
X	volatile const  t_I2C_FIFO_SR2 			I2C_FIFO_SR2;                   	
N	__IO t_I2C_SLP_CR 				I2C_SLP_CR;                     	//0x0013
X	volatile t_I2C_SLP_CR 				I2C_SLP_CR;                     	
N	__IO t_I2C_SLP_SR 				I2C_SLP_SR;                     	//0x0014
X	volatile t_I2C_SLP_SR 				I2C_SLP_SR;                     	
N	__IO t_I2C_SCL_HOLD 			I2C_SCL_HOLD;                   	//0x0015
X	volatile t_I2C_SCL_HOLD 			I2C_SCL_HOLD;                   	
N	__IO t_I2C_SCL_HOLD2 			I2C_SCL_HOLD2;                  	//0x0016
X	volatile t_I2C_SCL_HOLD2 			I2C_SCL_HOLD2;                  	
N	__IO uint32_t 					I2C_Reserved00;              		//0x0017
X	volatile uint32_t 					I2C_Reserved00;              		
N	__IO uint32_t 					I2C_Reserved01;              		//0x0018
X	volatile uint32_t 					I2C_Reserved01;              		
N	__IO uint32_t 					I2C_Reserved02;              		//0x0019
X	volatile uint32_t 					I2C_Reserved02;              		
N	__IO uint32_t 					I2C_Reserved03;              		//0x001A
X	volatile uint32_t 					I2C_Reserved03;              		
N	__IO uint32_t 					I2C_Reserved04;              		//0x001B
X	volatile uint32_t 					I2C_Reserved04;              		
N	__IO uint32_t 					I2C_Reserved05;              		//0x001C
X	volatile uint32_t 					I2C_Reserved05;              		
N	__IO uint32_t 					I2C_Reserved06;              		//0x001D
X	volatile uint32_t 					I2C_Reserved06;              		
N	__IO uint32_t 					I2C_Reserved07;              		//0x001E
X	volatile uint32_t 					I2C_Reserved07;              		
N	__IO uint32_t 					I2C_Reserved08;              		//0x001F
X	volatile uint32_t 					I2C_Reserved08;              		
N
N} tI2C_CtrlReg_t;
N
N
N//
N//	__IO t_I2C_DEVICE_ADDR 			I2CM1_DEVICE_ADD;					//0x0020
N//	__O  t_I2C_SW_RESET				I2CM1_SW_RESET;                   	//0x0021
N//	__IO t_I2C_GLB_CR  				I2CM1_GLB_CR;                     	//0x0022
N//	__IO t_I2C_MST_CR1  			I2CM1_MST_CR1;                    	//0x0023
N//	__IO t_I2C_MST_CR2 				I2CM1_MST_CR2;                    	//0x0024
N//	__IO t_I2C_GLB_SR  				I2CM1_GLB_SR;                     	//0x0025
N//	__I  t_I2C_SLV_ST_SR   			I2CM1_SLV_ST_SR;                  	//0x0026
N//	__IO t_I2C_FIFO_CR 				I2CM1_FIFO_CR;                    	//0x0027
N//	__O  uint32_t 					I2CM1_TXFIFO_DATA;                	//0x0028
N//	__I  uint32_t 					I2CM1_RXFIFO_DATA;                	//0x0029
N//	__I  t_I2C_FIFO_SR 				I2CM1_FIFO_SR;                    	//0x002A
N//	__IO t_I2C_SET_PWR_REG 			I2CM1_SET_PWR_REG;                	//0x002B
N//	__IO t_I2C_SET_PWR_CMD 			I2CM1_SET_PWR_CMD;                	//0x002C
N//	__IO t_I2C_SET_PWR_INT 			I2CM1_SET_PWR_INT;                	//0x002D
N//	__IO t_I2C_DLY_VALUE 			I2CM1_DLY_VALUE;                  	//0x002E
N//	__IO t_I2C_SLV_DBG 				I2CM1_SLV_DBG;                    	//0x002F
N//	__IO t_I2C_MST_DBG 				I2CM1_MST_DBG;                    	//0x0030
N//	__IO t_I2C_FIFO_CR2 			I2CM1_FIFO_CR2;                   	//0x0031
N//	__I  t_I2C_FIFO_SR2 			I2CM1_FIFO_SR2;                   	//0x0032
N//	__IO t_I2C_SLP_CR 				I2CM1_SLP_CR;                     	//0x0033
N//	__IO t_I2C_SLP_SR 				I2CM1_SLP_SR;                     	//0x0034
N//	__IO t_I2C_SCL_HOLD 			I2CM1_SCL_HOLD;                   	//0x0035
N//	__IO t_I2C_SCL_HOLD2 			I2CM1_SCL_HOLD2;                  	//0x0036
N//	__IO uint32_t 					I2CM1_Reserved00;              		//0x0037
N//	__IO uint32_t 					I2CM1_Reserved01;              		//0x0038
N//	__IO uint32_t 					I2CM1_Reserved02;                   //0x0039
N//	__IO uint32_t 					I2CM1_Reserved03;                   //0x003A
N//	__IO uint32_t 					I2CM1_Reserved04;                   //0x003B
N//	__IO uint32_t 					I2CM1_Reserved05;                   //0x003C
N//	__IO uint32_t 					I2CM1_Reserved06;                   //0x003D
N//	__IO uint32_t 					I2CM1_Reserved07;                   //0x003E
N//	__IO uint32_t 					I2CM1_Reserved08;				    //0x003F
N//	__IO uint32_t 					I2CM1_Reserved09;                   //0x0040
N//	__IO uint32_t 					I2CM1_Reserved10;                   //0x0041
N//	__IO uint32_t 					I2CM1_Reserved11;                   //0x0042
N//	__IO uint32_t 					I2CM1_Reserved12;                   //0x0043
N//	__IO uint32_t 					I2CM1_Reserved13;                   //0x0044
N//	__IO uint32_t 					I2CM1_Reserved14;                   //0x0045
N//	__IO uint32_t 					I2CM1_Reserved15;                   //0x0046
N//	__IO uint32_t 					I2CM1_Reserved16;              		//0x0047
N//
N//} tI2C_CtrlReg_t;
N
N
N
N#endif /* __I2C_H_ */
L 258 "..\..\Hal\system\MFTP.h" 2
N
N//#include "_tspi.h"
N
N
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group MFTP */
N/** @} */ /* End of group LG Display */
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N#define HW_REG(addr) (*((volatile unsigned long *)(addr)))
N#define READ_MEMORY32(Reg)		(*(__IO uint32_t*)Reg)
N#define READ_MEMORY16(Reg)		(*(__IO uint16_t*)Reg)
N#define READ_MEMORY8(Reg)		(*(__IO uint8_t*)Reg)
N#define WRITE_MEMORY32(reg,value) 	(READ_MEMORY32(reg) = value)
N#define WRITE_MEMORY16(reg,value) 	(READ_MEMORY16(reg) = value)
N#define WRITE_MEMORY8(reg,value)		(READ_MEMORY8(reg) = value)
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N#define READ_REG(REG)         ((REG))
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define __I     volatile const            /*!< defines 'read only' permissions      */
N#define __O     volatile                  /*!< defines 'write only' permissions     */
N#define __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N/* -------------------  Bit Definition ------------------ */
N#define BIT0		((uint32_t)0x0000000000000001) /** Bit 0 select mask */
N#define BIT1		((uint32_t)0x0000000000000002) /** Bit 1 select mask */
N#define BIT2		((uint32_t)0x0000000000000004) /** Bit 2 select mask */
N#define BIT3		((uint32_t)0x0000000000000008) /** Bit 3 select mask */
N#define BIT4		((uint32_t)0x0000000000000010) /** Bit 4 select mask */
N#define BIT5		((uint32_t)0x0000000000000020) /** Bit 5 select mask */
N#define BIT6		((uint32_t)0x0000000000000040) /** Bit 6 select mask */
N#define BIT7		((uint32_t)0x0000000000000080) /** Bit 7 select mask */
N#define BIT8		((uint32_t)0x0000000000000100) /** Bit 8 select mask */
N#define BIT9		((uint32_t)0x0000000000000200) /** Bit 9 select mask */
N#define BIT10		((uint32_t)0x0000000000000400) /** Bit 10 select mask */
N#define BIT11		((uint32_t)0x0000000000000800) /** Bit 11 select mask */
N#define BIT12		((uint32_t)0x0000000000001000) /** Bit 12 select mask */
N#define BIT13		((uint32_t)0x0000000000002000) /** Bit 13 select mask */
N#define BIT14		((uint32_t)0x0000000000004000) /** Bit 14 select mask */
N#define BIT15		((uint32_t)0x0000000000008000) /** Bit 15 select mask */
N#define BIT16		((uint32_t)0x0000000000010000) /** Bit 16 select mask */
N#define BIT17		((uint32_t)0x0000000000020000) /** Bit 17 select mask */
N#define BIT18		((uint32_t)0x0000000000040000) /** Bit 18 select mask */
N#define BIT19		((uint32_t)0x0000000000080000) /** Bit 19 select mask */
N#define BIT20		((uint32_t)0x0000000000100000) /** Bit 20 select mask */
N#define BIT21		((uint32_t)0x0000000000200000) /** Bit 21 select mask */
N#define BIT22		((uint32_t)0x0000000000400000) /** Bit 22 select mask */
N#define BIT23		((uint32_t)0x0000000000800000) /** Bit 23 select mask */
N#define BIT24		((uint32_t)0x0000000001000000) /** Bit 24 select mask */
N#define BIT25		((uint32_t)0x0000000002000000) /** Bit 25 select mask */
N#define BIT26		((uint32_t)0x0000000004000000) /** Bit 26 select mask */
N#define BIT27		((uint32_t)0x0000000008000000) /** Bit 27 select mask */
N#define BIT28		((uint32_t)0x0000000010000000) /** Bit 28 select mask */
N#define BIT29		((uint32_t)0x0000000020000000) /** Bit 29 select mask */
N#define BIT30		((uint32_t)0x0000000040000000) /** Bit 30 select mask */
N#define BIT31		((uint32_t)0x0000000080000000) /** Bit 31 select mask */
N#define BIT32		((uint64_t)0x0000000100000000) /** Bit 32 select mask */
N#define BIT33		((uint64_t)0x0000000200000000) /** Bit 33 select mask */
N#define BIT34		((uint64_t)0x0000000400000000) /** Bit 34 select mask */
N#define BIT35		((uint64_t)0x0000000800000000) /** Bit 35 select mask */
N#define BIT36		((uint64_t)0x0000001000000000) /** Bit 36 select mask */
N#define BIT37		((uint64_t)0x0000002000000000) /** Bit 37 select mask */
N#define BIT38		((uint64_t)0x0000004000000000) /** Bit 38 select mask */
N#define BIT39		((uint64_t)0x0000008000000000) /** Bit 39 select mask */
N#define BIT40		((uint64_t)0x0000010000000000) /** Bit 40 select mask */
N#define BIT41		((uint64_t)0x0000020000000000) /** Bit 41 select mask */
N#define BIT42		((uint64_t)0x0000040000000000) /** Bit 42 select mask */
N#define BIT43		((uint64_t)0x0000080000000000) /** Bit 43 select mask */
N#define BIT44		((uint64_t)0x0000100000000000) /** Bit 44 select mask */
N#define BIT45		((uint64_t)0x0000200000000000) /** Bit 45 select mask */
N#define BIT46		((uint64_t)0x0000400000000000) /** Bit 46 select mask */
N#define BIT(X)		(1<<(X)) /** Bit X select mask */
N#define vBIT0(X)		(X<<(0))
N#define vBIT1(X)		(X<<(1))
N#define vBIT2(X)		(X<<(2))
N#define vBIT3(X)		(X<<(3))
N#define vBIT4(X)		(X<<(4))
N#define vBIT5(X)		(X<<(5))
N#define vBIT6(X)		(X<<(6))
N#define vBIT7(X)		(X<<(7))
N#define vBIT8(X)		(X<<(8))
N#define vBIT9(X)		(X<<(9))
N
N
N#ifndef _BV
N#define _BV( x )            ( 1 << (x) )
N#endif
N#define x_BV( x )           0
N
N
N#define BYTE7(X)    ((X & 0xff00000000000000) >> 56)
N#define BYTE6(X)    ((X & 0x00ff000000000000) >> 48)
N#define BYTE5(X)    ((X & 0x0000ff0000000000) >> 40)
N#define BYTE4(X)    ((X & 0x000000ff00000000) >> 32)
N#define BYTE3(X)    ((X & 0x00000000ff000000) >> 24)
N#define BYTE2(X)    ((X & 0x0000000000ff0000) >> 16)
N#define BYTE1(X)    ((X & 0x000000000000ff00) >> 8)
N#define BYTE0(X)    ((X & 0x00000000000000ff) >> 0)
N
N#define SHORT0(X)   ((X & 0x000000000000FFFF) >>  0)
N#define SHORT1(X)   ((X & 0x00000000FFFF0000) >>  16)
N#define SHORT2(X)   ((X & 0x0000FFFF00000000) >>  32)
N#define SHORT3(X)   ((X & 0xFFFF000000000000) >>  48)
N
N#define WORD0(X)    ((X & 0x00000000FFFFFFFF) >>  0)
N#define WORD1(X)    ((X & 0xFFFFFFFF00000000) >> 32)
N
N#ifndef signof
N#define signof(expr)       ((typeof(expr)) -1 < ((typeof(expr)) 0))
N#endif /* signof */
N
N#define GET_ARRAY_(x)       (sizeof(x)/sizeof(*(x)))
N
N#define _PSTR(x)            #x
N#define PSTR(x)             _PSTR(x)
N
Ntypedef enum  {RESET = 0, SET = 1}         	FlagStatus, ITStatus;
Ntypedef enum  {DISABLE = 0, ENABLE = 1}  	FunctionalState;
Ntypedef enum  {ERROR = 0, SUCCESS = 1}     	ErrorStatus;
Ntypedef enum  {ODD = 0, EVEN = 1}           ParityNum;
N
N
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 390 "..\..\Hal\system\MFTP.h" 2
N#include <stdint.h>
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 392 "..\..\Hal\system\MFTP.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 393 "..\..\Hal\system\MFTP.h" 2
Ntypedef unsigned char bool_t;
N
N#define ON						(0==0)
N#define OFF						(1==0)
N
N#define YES						(0==0)
N#define NO						(1==0)
N
N#define TRUE					(0==0)
N#define FALSE					(1==0)
N
N#define IS_TRUE(X)				((X) != 0)
N#define IS_FALSE(X)				((X) == 0)
N
N#define MSB_2BYTE(x)			(((x)>>8)&0xFF)
N#define LSB_2BYTE(x)			((x)&0xFF)
N
N#define TO_BE_DEFINED			(0)
N
N/* -------------------  Other User Definition ------------------ */
N
N#ifndef NULL
S#define NULL                ((void *)0)
N#endif
N
N#define MSB(x)              (((x)>>8) & 0xFF)
N#define LSB(x)              ((x) & 0xFF)
N#define MSB1(x)       		(((x)>>24)&0xFF)
N#define MSB2(x)       		(((x)>>16)&0xFF)
N#define LSB1(x)       		(((x)>>8)&0xFF)
N#define LSB2(x)       		((x)&0xFF)
N
N#ifndef MAX
N#define MAX( x, y )         ( ( ( x ) > ( y ) ) ? ( x ) : ( y ) )
N#endif
N
N#ifndef MIN
N#define MIN( x, y )         ( ( ( x ) < ( y ) ) ? ( x ) : ( y ) )
N#endif
N
N#ifndef QUOT
N#define QUOT( x, y )        ( ( ( x ) + ( y / 2 ) ) / ( y ) )
N#endif
N
N#ifndef MOD
N#define MOD( x, y )         ( ( ( x )+( y ) )%( y ) )
N#endif
N
N#ifndef ABS
N#define ABS( x )            (( ( x ) >= 0 )? (x) : -(x))
N#endif
N
N/** @} */ /* End of group Exported_macro */
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* _MFTP_H_ */
L 38 "..\..\Env\env_def.h" 2
N#include "env_defines.h"
L 1 "..\..\Env\env_defines.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_defines.h
N * created on : 14. 5. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N#ifndef _ENV_DEFINES_H_
N#define _ENV_DEFINES_H_
N
N
N/****************************************************************************************
N *                              Define Of Panel Vender
N ****************************************************************************************/
N#define MODULE_DEF_S_1						(0x00010000)
N#define MODULE_DEF_B_1						(0x00020000)
N#define MODULE_DEF_INX_1					(0x00040000)
N#define MODULE_DEF_T_1						(0x00080000)
N#define MODULE_DEF_A_1						(0x00100000)
N//#define MODULE_DEF_					(0x00200000)
N//#define MODULE_DEF_					(0x00400000)
N//#define MODULE_DEF_					(0x00800000)
N//#define MODULE_DEF_					(0x01000000)
N//#define MODULE_DEF_					(0x02000000)
N//#define MODULE_DEF_					(0x04000000)
N//#define MODULE_DEF_					(0x08000000)
N//#define MODULE_DEF_					(0x10000000)
N//#define MODULE_DEF_					(0x20000000)
N//#define MODULE_DEF_					(0x40000000)
N//#define MODULE_DEF_					(0x80000000)
N#define USED_MODULE_DEF						(MODULE_DEF_B_1)
N
N
N#define IS_MODULE_DEF_S_1(M)				(MODULE_DEF_S_1 & (M))
N#define IS_MODULE_DEF_B_1(M)				(MODULE_DEF_B_1 & (M))
N#define IS_MODULE_DEF_INX_1(M)				(MODULE_DEF_INX_1 & (M))
N#define IS_MODULE_DEF_T_1(M)				(MODULE_DEF_T_1 & (M))
N#define IS_MODULE_DEF_A_1(M)				(MODULE_DEF_A_1 & (M))
N//#define IS_MODULE_DEF_(M)				(MODULE_DEF_ & (M))
N//#define IS_MODULE_DEF_(M)				(MODULE_DEF_ & (M))
N//#define IS_MODULE_DEF_(M)				(MODULE_DEF_ & (M))
N//#define IS_MODULE_DEF_(M)				(MODULE_DEF_ & (M))
N//#define IS_MODULE_DEF_(M)				(MODULE_DEF_ & (M))
N//#define IS_MODULE_DEF_(M)				(MODULE_DEF_ & (M))
N//#define IS_MODULE_DEF_(M)				(MODULE_DEF_ & (M))
N/****************************************************************************************
N *                              Define Of Active Stylus Pen Protocol
N ****************************************************************************************/
N#define PEN_PROTOCOL_MULTI_PROTOCOL_OPERATION			(0x00010000)
N#define PEN_PROTOCOL_MS_PEN								(1)
N#define PEN_PROTOCOL_WACOM_PEN							(2)
N#define PEN_PROTOCOL_MSnWACOM_PEN						(PEN_PROTOCOL_MULTI_PROTOCOL_OPERATION | 3)
N#define PEN_PROTOCOL_WGP_PEN							(4)
N#define PEN_PROTOCOL_MSnWGP_PEN							(PEN_PROTOCOL_MULTI_PROTOCOL_OPERATION | 5)
N#define PEN_PROTOCOL_WGP_UHD_PEN						(6)
N
N/****************************************************************************************
N *                              Define Of ROIC Define
N ****************************************************************************************/
N#define ROIC_SW97500						(1)
N#define ROIC_SW92502						(2)
N#define ROIC_SW92503						(3)
N#define ROIC_SW92503S						(4)
N#define ROIC_SW92503B						(5)
N#define ROIC_SW98500						(7)
N#define ROIC_SW92505						(9)
N#define ROIC_SW98502						(10)
N#define ROIC_SW92510						(11)
N#define ROIC_SW92508						(12)
N#define ROIC_SW92509						(13)
N#define ROIC_SW92512						(14)
N#define ROIC_SW92511						(15)
N#define ROIC_SW92513						(16)
N
N/****************************************************************************************
N *                              Define Of Sensing Frequency
N ****************************************************************************************/
N#define PWMDRV_FREQUENCY_80K				(80)
N#define PWMDRV_FREQUENCY_86K				(86)
N#define PWMDRV_FREQUENCY_91K				(91)
N#define PWMDRV_FREQUENCY_112K				(112)
N#define PWMDRV_FREQUENCY_114K				(114)
N#define PWMDRV_FREQUENCY_133K				(133)
N
N#include "boot_info.h"
L 1 "..\..\Boot\boot_info.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : boot_info.h
N * created on : 14. 5. 2019
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _BOOT_INFO_H_
N#define _BOOT_INFO_H_
N
N
N#define BOOT_VERSION			(0x0103)
N#define UNIQUE_BOOT_PID			(0x7702)
N
N
Ntypedef struct
N{
N	uint16_t usBootVer;
N	uint16_t usBootMemSize;
N	uint16_t usBootVID;
N	uint16_t usBootPID;
N
N} tBootGenInfo_t;
N
Ntypedef struct
N{
N	uint16_t usBootVer;
N	uint16_t usBootMemSize;
N	uint16_t usBootVID;
N	uint16_t usBootPID;
N	uint32_t usCRCValue;
N
N} tBootTailInfo_t;
N
N
N#endif /* _BOOT_INFO_H_ */
L 112 "..\..\Env\env_defines.h" 2
N
N#if (USED_MODULE_DEF == MODULE_DEF_S_1)
X#if (((0x00020000)) == (0x00010000))
S#include "env_model_S/env_model.h"
N#elif (USED_MODULE_DEF == MODULE_DEF_B_1)
X#elif (((0x00020000)) == (0x00020000))
N#include "env_model_B/env_model.h"
L 1 "..\..\Env\env_model_B/env_model.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  env_model.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_MODEL_H_
N#define _ENV_MODEL_H_
N
N
N#define UNIQUE_VID 									(0x424F) // BOE(BO)
N
N#define SWIP_QUEUE_MODE 				(2)
N#define SWIP_QUEUE_SIZE 				(7)
N#define SHORT_NUM 						(10)
N
N
N/* Define for Model Customer Dependency */
N#define MODEL_DEF_FHD_92503B_HAIER					(MODULE_DEF_B_1 | 1) /* FHD Haier */
N#define MODEL_DEF_FHD_92503B_HAIER_CG				(MODULE_DEF_B_1 | 2) /* FHD Haier w/CG */
N#define MODEL_DEF_FHD_97500_MNT_S3					(MODULE_DEF_B_1 | 3) /* FHD HP */
N#define MODEL_DEF_FHD_92503B_HAIER_CG_MPP			(MODULE_DEF_B_1 | 4) /* FHD Haier w/CG */
N#define MODEL_DEF_FHD_92511_HAIER_WGP				(MODULE_DEF_B_1 | 5) /* FHD Haier wo/CG */
N#define MODEL_DEF_SQHD_92509_HUANAN_WGP				(MODULE_DEF_B_1 | 6) /* SQHD Huanan */
N#define MODEL_DEF_SQHD_92509_HUANAN_MPP				(MODULE_DEF_B_1 | 7) /* SQHD Huanan */
N#define MODEL_DEF_SQHD_92509_HUANAN_SPLIT_MPP		(MODULE_DEF_B_1 | 8) /* SQHD Huanan */
N#define MODEL_DEF_FHD_92513_LENOVO					(MODULE_DEF_B_1 | 9) /* FHD Lenovo 16" */
N#define MODEL_DEF_FHD_92513_LENOVO_NON_PRIVACY		(MODULE_DEF_B_1 | 10) /* FHD Lenovo 16" */
N
N#define CUSTOMER   						(MODEL_DEF_FHD_92513_LENOVO_NON_PRIVACY)
N
N#if (CUSTOMER == MODEL_DEF_FHD_92503B_HAIER)
X#if ((((0x00020000) | 10)) == ((0x00020000) | 1))
S	#include "customer/FHD_92503B_haier/information.h"
S	#include "customer/FHD_92503B_haier/param_configset_algorithm_common.h"
S		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
S			#include "customer/FHD_92503B_haier/param_configset_algorithm_mode_wgp.h"
S		#endif
S		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
S			#include "customer/FHD_92503B_haier/param_configset_algorithm_mode_mpp.h"
S		#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN) */
S	#include "customer/FHD_92503B_haier/param_configset_mspi.h"
S	#include "customer/FHD_92503B_haier/param_configset_pwmdrv.h"
S	#include "customer/FHD_92503B_haier/param_configset_roic.h"
S	#include "customer/FHD_92503B_haier/remap_table.h"
S	#include "customer/FHD_92503B_haier/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_FHD_92503B_HAIER_CG)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 2))
S	#include "customer/FHD_92503B_haier_CG/information.h"
S	#include "customer/FHD_92503B_haier_CG/param_configset_algorithm_common.h"
S	#include "customer/FHD_92503B_haier_CG/param_configset_algorithm_mode_wgp.h"
S	#include "customer/FHD_92503B_haier_CG/param_configset_mspi.h"
S	#include "customer/FHD_92503B_haier_CG/param_configset_pwmdrv.h"
S	#include "customer/FHD_92503B_haier_CG/param_configset_roic.h"
S	#include "customer/FHD_92503B_haier_CG/remap_table.h"
S	#include "customer/FHD_92503B_haier_CG/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_FHD_92503B_HAIER_CG_MPP)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 4))
S	#include "customer/FHD_92503B_haier_CG_MPP/information.h"
S	#include "customer/FHD_92503B_haier_CG_MPP/param_configset_algorithm_common.h"
S	#include "customer/FHD_92503B_haier_CG_MPP/param_configset_algorithm_mode_mpp.h"
S	#include "customer/FHD_92503B_haier_CG_MPP/param_configset_mspi.h"
S	#include "customer/FHD_92503B_haier_CG_MPP/param_configset_pwmdrv.h"
S	#include "customer/FHD_92503B_haier_CG_MPP/param_configset_roic.h"
S	#include "customer/FHD_92503B_haier_CG_MPP/remap_table.h"
S	#include "customer/FHD_92503B_haier_CG_MPP/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_FHD_97500_MNT_S3)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 3))
S	#include "customer/FHD_97500_MNT_S3/information.h"
S	#include "customer/FHD_97500_MNT_S3/param_configset_algorithm_common.h"
S	#include "customer/FHD_97500_MNT_S3/param_configset_algorithm_mode_wgp.h"
S	#include "customer/FHD_97500_MNT_S3/param_configset_mspi.h"
S	#include "customer/FHD_97500_MNT_S3/param_configset_pwmdrv.h"
S	#include "customer/FHD_97500_MNT_S3/param_configset_roic.h"
S	#include "customer/FHD_97500_MNT_S3/remap_table.h"
S	#include "customer/FHD_97500_MNT_S3/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_FHD_92511_HAIER_WGP)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 5))
S#undef UNIQUE_VID
S#define UNIQUE_VID 									(0x29BD)
S	#include "customer/FHD_92511_haier_WGP/information.h"
S	#include "customer/FHD_92511_haier_WGP/param_configset_algorithm_common.h"
S	#include "customer/FHD_92511_haier_WGP/param_configset_algorithm_mode_wgp.h"
S	#include "customer/FHD_92511_haier_WGP/param_configset_mspi.h"
S	#include "customer/FHD_92511_haier_WGP/param_configset_pwmdrv.h"
S	#include "customer/FHD_92511_haier_WGP/param_configset_roic.h"
S	#include "customer/FHD_92511_haier_WGP/remap_table.h"
S	#include "customer/FHD_92511_haier_WGP/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 6))
S#undef UNIQUE_VID
S#define UNIQUE_VID 									(0x29BD)
S	#include "customer/SQHD_92509_Huanan_13_WGP/information.h"
S	#include "customer/SQHD_92509_Huanan_13_WGP/param_configset_algorithm_common.h"
S	#include "customer/SQHD_92509_Huanan_13_WGP/param_configset_algorithm_mode_wgp.h"
S	#include "customer/SQHD_92509_Huanan_13_WGP/param_configset_mspi_wgp.h"
S	#include "customer/SQHD_92509_Huanan_13_WGP/param_configset_pwmdrv_wgp.h"
S	#include "customer/SQHD_92509_Huanan_13_WGP/param_configset_roic_wgp.h"
S	#include "customer/SQHD_92509_Huanan_13_WGP/remap_table.h"
S	#include "customer/SQHD_92509_Huanan_13_WGP/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_MPP)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 7))
S#undef UNIQUE_VID
S#define UNIQUE_VID 									(0x29BD)
S	#include "customer/SQHD_92509_Huanan_13_MPP/information.h"
S	#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_algorithm_common.h"
S	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_algorithm_mode_wgp.h"
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_mspi_wgp.h"
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_pwmdrv_wgp.h"
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_roic_wgp.h"
S	#endif
S	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_algorithm_mode_mpp.h"
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_mspi_mpp.h"
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_pwmdrv_mpp.h"
S		#include "customer/SQHD_92509_Huanan_13_MPP/param_configset_roic_mpp.h"
S	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN) */
S	#include "customer/SQHD_92509_Huanan_13_MPP/remap_table.h"
S	#include "customer/SQHD_92509_Huanan_13_MPP/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_SPLIT_MPP)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 8))
S#undef UNIQUE_VID
S#define UNIQUE_VID 									(0x29BD)
S	#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/information.h"
S	#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_algorithm_common.h"
S	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_algorithm_mode_wgp.h"
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_mspi_wgp.h"
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_pwmdrv_wgp.h"
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_roic_wgp.h"
S	#endif
S	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_algorithm_mode_mpp.h"
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_mspi_mpp.h"
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_pwmdrv_mpp.h"
S		#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/param_configset_roic_mpp.h"
S	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN) */
S	#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/remap_table.h"
S	#include "customer/SQHD_92509_Huanan_13_SPLIT_MPP/gpio_define.h"
S#elif (CUSTOMER == MODEL_DEF_FHD_92513_LENOVO)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 9))
S#undef UNIQUE_VID
S#define UNIQUE_VID 									(0x29BD)
S	#include "customer/FHD_92513_16_Lenovo/information.h"
S	#include "customer/FHD_92513_16_Lenovo/param_configset_algorithm_common.h"
S	#include "customer/FHD_92513_16_Lenovo/param_configset_algorithm_mode_wgp.h"
S	#include "customer/FHD_92513_16_Lenovo/param_configset_mspi.h"
S	#include "customer/FHD_92513_16_Lenovo/param_configset_pwmdrv.h"
S	#include "customer/FHD_92513_16_Lenovo/param_configset_roic.h"
S	#include "customer/FHD_92513_16_Lenovo/remap_table.h"
S	#include "customer/FHD_92513_16_Lenovo/gpio_define.h"
N#elif (CUSTOMER == MODEL_DEF_FHD_92513_LENOVO_NON_PRIVACY)
X#elif ((((0x00020000) | 10)) == ((0x00020000) | 10))
N#undef UNIQUE_VID
N#define UNIQUE_VID 									(0x29BD)
N	#include "customer/FHD_92513_16_Lenovo_NonPrivacy/information.h"
L 1 "..\..\Env\env_model_B/customer/FHD_92513_16_Lenovo_NonPrivacy/information.h" 1
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  information.h
N * created on : 06. 08. 2021
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _INFORMATION_H_
N#define _INFORMATION_H_
N
N
N/********************************************************************************
N *                              Customer : DEFAULT                              *
N ********************************************************************************/
N#define USED_TRIMCODE_UPDATE_SECURITY_FUNC					(NO)
N 
N#define USED_ROIC_DEF										(ROIC_SW92513) // (== SW92400)
N
N#define BOE_LENOVO_16_NBPC_PIN_TYPE_R00						(1)
N
N
N#define USED_PCB_PINMAP										(BOE_LENOVO_16_NBPC_PIN_TYPE_R00)
N
N#define USED_BEACON_SET_ADJUST								(NO)
N/*
N * Use beacon for modulation in dummy LHB
N */
N#define USED_DUMMY_LHB_MODULATION							(YES)
N#define USED_CMUX_OFF										(NO)
N#define USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION		(YES)
N#define USED_ESD_RECOVERY_CHECK_ABNORMAL_PEN_DELTA			(YES)
N#define USED_ESD_DEBUG										(NO)
N
N/*
N * Support Pen Protocol
N */
N//#define PEN_PROTOCOL_MS_PEN
N//#define PEN_PROTOCOL_WACOM_PEN
N//#define PEN_PROTOCOL_MSnWACOM_PEN
N//#define PEN_PROTOCOL_WGP_PEN
N//#define PEN_PROTOCOL_MSnWGP_PEN
N//#define PEN_PROTOCOL_WGP_UHD_PEN
N#define USED_PEN_PROTOCOL								(PEN_PROTOCOL_WGP_PEN)
N#define USED_WGP_AGIC_PEN								(YES)
N
N#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
X#if (((4)) == ((0x00010000) | 3) || ((4)) == ((0x00010000) | 5))
S	#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_MSPen				(0x0150)
S	#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_AITPen				(0x0288)
S	#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_WGPPen				(0x0444)
N#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN)
X	#if (((4)) == (4))
N		#if (USED_ROIC_DEF == ROIC_SW92510 || USED_ROIC_DEF == ROIC_SW92508 || USED_ROIC_DEF == ROIC_SW92509)
X		#if (((16)) == (11) || ((16)) == (12) || ((16)) == (13))
S			#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Active		(0x0C8D)
S			#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Idle		(0x0000)
N		#else
N			#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Active		(0x0445)
N			#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Idle		(0x0048)
N		#endif
N	#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
S		#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Active			(0x0054)
S		#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Idle			(0x0054)
S	#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
S		#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Active			(0x0151)
S		#define DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Idle			(0x0048)
N	#endif
N#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N
N#define USED_SPI_NBIT_TRANSMODE							(NO)
N#define SPI_TRANSFER_BIT_NUM							(16)
N
N#define USED_TOUCH_TUNING_PROCESS						(NO)
N#define USED_DO_NOT_TOUCH_ONLY_DISPLAY					(NO)
N#define USED_DO_NOT_TOUCH_REPORT						(NO)
N#define USED_DO_NOT_FINGER_TOUCH_REPORT					(NO)
N#define USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS		(NO)
N#if USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS
X#if ((1==0))
S#define ZERO_FINGER_RAWDATA_MASK_NUM					(32)
S#define ZERO_FINGER_RAWDATA_MASK_COL_NUM				(3) // (ROW MAX / 32) + ((ROW_MAX % 32) > 0 ? 1 : 0)
N#endif /* USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS */
N#define USED_FINGER_DYNAMIC_MUX_SCAN_ORDER				(NO)
N#define USED_PEN_DATA_AFE_GAIN_OTHER_SET				(NO)
N#if USED_PEN_DATA_AFE_GAIN_OTHER_SET
X#if ((1==0))
S	#define DEF_PEN_LOCAL_DATA_GAIN_SET_BIT_MASK_Idle			(0x0829)
N#endif /* USED_PEN_DATA_AFE_GAIN_OTHER_SET */
N
N#define USED_ONLY_LOCAL_MODE							(NO || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN))//(NO)
N#define USED_ONLY_FULL_MODE								(NO)
N#define USED_ONLY_IDLE_MODE								(NO)
N#define USED_ONLY_LOCAL_IDLE_MODE						(NO)
N#define USED_ONLY_S3_MODE								(NO)
N#define USED_IDLE_FINGER_EVEN_ODD						(YES)
N
N#define USED_SMT_OP_MODE								(YES)
N#define USED_IDLE_MODE_CONTROL							(YES && (!USED_CMUX_OFF))
N#define USED_ENTER_IDLE_REAL_TIME_CHECK					(YES & USED_IDLE_MODE_CONTROL)
N#define USED_IDLE_MODE_30Hz_CONTROL						(NO)
N#define USED_IDLE_MODE_20Hz_CONTROL						(NO)
N#if USED_IDLE_FINGER_EVEN_ODD
X#if ((0==0))
N	#define USED_IDLE_NI_SENSING_MUX_NUM					(2)
N#else
S	#define USED_IDLE_NI_SENSING_MUX_NUM					(1)
N#endif
N#define USED_REFERENCE_INIT_IDLE_MODE_ENTER				(YES & USED_IDLE_MODE_CONTROL)
N#define USED_IDLE_LOW_POWER								(NO & USED_IDLE_MODE_CONTROL)
N#define USED_FAST_SWITCH_IDLE_TO_ACTIVE					(YES & USED_IDLE_MODE_CONTROL)
N#define USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE				(YES & USED_IDLE_MODE_CONTROL)
N#define DEF_FULLSCAN_SWITCH_IDLE_LHB_IDX				(9) // Switching as the fullscan at the LHB index of same idle frame.
N
N#define USED_LOCAL_IDLE_MODE_CONTROL					(NO)
N#define USED_LOCAL_IDLE_PEN_OTHER_CONTROL				(NO && USED_LOCAL_IDLE_MODE_CONTROL)
N#if USED_LOCAL_IDLE_MODE_CONTROL
X#if ((1==0))
S#define USED_LOCAL_IDLE_30Hz							(YES)
N#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
N
N#define USED_NOISE_HOPPING_FREQ								(YES && (!USED_CMUX_OFF))
N#define USE_FORCE_FREQ_HOPPING								(NO && USED_NOISE_HOPPING_FREQ)
N#if USE_FORCE_FREQ_HOPPING
X#if ((1==0) && ((0==0) && (!((1==0)))))
S	#define USED_IDLE_MODE_CONTROL							(NO)
N#endif /* USE_FORCE_FREQ_HOPPING */
N#define USE_FREQ_HOPPIG_DEBUG								(NO && USED_NOISE_HOPPING_FREQ)
N#define USE_FREQ_HOPPING_BASELINE_CONTI_UPDATE				(YES && USED_NOISE_HOPPING_FREQ && (!USE_FORCE_FREQ_HOPPING))
N#define HOPP_BASELINE_CONTI_ON_OFF_CONTROL_START_CNT_THD	(20)
N#define DEF_FREQ_HOPPING_BASELINE_UPDATE_CHECK_CNT_THD		(100)
N#define DEF_FREQ_HOPPING_BASELINE_UPDATE_CONTI_CNT_THD		(10)
N
N#define USED_START_TIME_OUT_CHECK						(YES)
N#define USED_START_TIME_OUT_COUNT						(100)
N
N#define USED_TSYNC2_INPUT_FROM_TCON						(NO)
N
N#define USED_TPIC_MUXEN_ON_OFF_CONTROL					(YES)
N#define USED_TPIC_MUXEN_2_ON_OFF_CONTROL				(NO)
N#define USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM				(YES)
N#define TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD			(20)
N#define USED_TPIC_MUXEN_ON_OFF_CONTROL_DISABLE_DATAREAD	(YES & USED_TPIC_MUXEN_ON_OFF_CONTROL)
N
N#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
X#if (((4)) == ((0x00010000) | 3) || ((4)) == ((0x00010000) | 5))
S	#define DEF_TPIC_MUX_EN_SET_BIT_MASK_MSPen				(0x0000)
S	#define DEF_TPIC_MUX_EN_SET_BIT_MASK_AITPen				(0x0000)
S	#define DEF_TPIC_MUX_EN_SET_BIT_MASK_WGPPen				(0x0000)
N#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN)
X	#if (((4)) == (4))
N		#if (USED_ROIC_DEF == ROIC_SW92510 || USED_ROIC_DEF == ROIC_SW92508)
X		#if (((16)) == (11) || ((16)) == (12))
S			#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Full		(0x03BD)
S			#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Local		(0x03BD)
S			#if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
S				#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0x0020)
S			#else /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
S				#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0x0200)
S			#endif /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
N		#else
N			#if USED_DUMMY_LHB_MODULATION
X			#if ((0==0))
N				#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Full		(0xFFFF)
N				#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Local		(0xFFF7)
N				#if USED_LOCAL_IDLE_30Hz
S					#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0x18002)
N				#else
N					#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0xFFFF)
N				#endif
N			#else
S				#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Full		(0xF1F1)
S				#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Local		(0xFFF7)
S				#if USED_LOCAL_IDLE_30Hz
S					#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0x18002)
S				#else
S					#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0x0100)
S				#endif
N			#endif
N		#endif
N	#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
S		#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Full		(0x0000)
S		#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Local		(0x0000)
S		#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0x0000)
S	#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
S		#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Full		(0x0000)
S		#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Local		(0x0000)
S		#define DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle		(0x0000)
N	#endif
N#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N
N#define USED_GPIO_UPLINK_LEVEL_CONTROL					(NO)
N#if USED_GPIO_UPLINK_LEVEL_CONTROL
X#if ((1==0))
S	#define DEF_UPLINK_HW_CONTROL							(1)
S	#define DEF_UPLINK_SW_CONTROL							(2)
S	#define DEF_UPLINK_CONTROL_OPERATION					(DEF_UPLINK_SW_CONTROL)
N#endif /* USED_GPIO_UPLINK_LEVEL_CONTROL */
N
N#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
X#if (((4)) == ((0x00010000) | 3) || ((4)) == ((0x00010000) | 5))
S	#define DEF_UPLINK_CTRL_SET_BIT_MASK_MSPen				(0x0202)
S	#define DEF_UPLINK_CTRL_SET_BIT_MASK_WGPPen				(0x0002)
N#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
X	#if (((4)) == (4) || ((4)) == (6))
N		#define DEF_UPLINK_CTRL_SET_BIT_MASK_WGPPen		(0x0002)
N	#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
S		#define DEF_UPLINK_CTRL_SET_BIT_MASK_MSPen		(0x0202)
N	#endif
N#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N
N#define USED_TPIC_PENEN_ON_OFF_CONTROL					(NO)
N#define USED_TPIC_PENEN_OFF_TIMING_LAST_PWM				(YES)
N#define TPIC_PENEN_ON_OFF_CONTROL_START_CNT_THD			(20)
N#define USED_TPIC_PENEN_ON_OFF_CONTROL_DISABLE_DATAREAD	(YES & USED_TPIC_MUXEN_ON_OFF_CONTROL)
N
N#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
X#if (((4)) == ((0x00010000) | 3) || ((4)) == ((0x00010000) | 5))
S	#define DEF_TPIC_PEN_EN_SET_BIT_MASK_MSPen				(0x0000)
S	#define DEF_TPIC_PEN_EN_SET_BIT_MASK_AITPen				(0x0000)
S	#define DEF_TPIC_PEN_EN_SET_BIT_MASK_WGPPen				(0x0000)
N#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN)
X	#if (((4)) == (4))
N		#if (USED_ROIC_DEF == ROIC_SW92510 || USED_ROIC_DEF == ROIC_SW92508)
X		#if (((16)) == (11) || ((16)) == (12))
S			#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Full		(0x0647)
S			#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Local		(0xE5E7)
S			#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle		(0x0048)
N		#else
N			#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Full		(0xF1F1)
N			#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Local		(0xE5E7)
N			#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle		(0x0048)
N		#endif
N	#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
S		#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Full		(0x0000)
S		#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Local		(0x0000)
S		#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle		(0x0000)
S	#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
S		#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Full		(0x0000)
S		#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Local		(0x0000)
S		#define DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle		(0x0000)
N	#endif
N#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN) */
N
N#define DEF_ECLK_DRIVING_STRENGTH						(GPIO_DRIVE_STR_16mA)
N#define USED_ECLK_ON_OFF_CONTROL						(YES)
N#define ECLK_ON_OFF_CONTROL_START_CNT_THD				(20)
N#define USED_ECLK_FRQ_ADJUST_CONTROL					(YES & USED_ECLK_ON_OFF_CONTROL)
N#define ECLK_FRQ_ADJUST_DISPLAY_DIV						(11)//(3)
N#define USED_ECLK_ON_OFF_CONTROL_DISABLE_DATAREAD		(YES & USED_ECLK_ON_OFF_CONTROL)
N#define ECLK_NEED_DURING_MSPI_OPERATION					(NO & USED_ECLK_ON_OFF_CONTROL)
N
N#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
X#if ((0==0))
N	#define DEF_ECLK_EN_SET_BIT_MASK_Full					(0xF9F9)
N	#define DEF_ECLK_EN_SET_BIT_MASK_Local					(0xFFF7)
N	#define DEF_ECLK_EN_SET_BIT_MASK_Idle					(0x0100)
N#else
S	#define DEF_ECLK_EN_SET_BIT_MASK_Full					(0xF1F1)
S	#define DEF_ECLK_EN_SET_BIT_MASK_Local					(0xFFF7)
S	#define DEF_ECLK_EN_SET_BIT_MASK_Idle					(0x0100)
N#endif
N
N#define USED_TOUCH_REPORT_ON_OFF_CONTROL					(YES)
N#define TOUCH_REPORT_ON_OFF_CONTROL_START_CNT_THD			(20)
N#define USED_TOUCH_REPORT_ON_OFF_CONTROL_DISABLE_DATAREAD	(YES & USED_TOUCH_REPORT_ON_OFF_CONTROL)
N
N#define USED_FORCE_S3_MODE_OPER							(NO)
N#define USED_GPIO_TEST_HANDSHAKE						(NO)
N
N#define PWMDRV_USED_FREQUENCY						(PWMDRV_FREQUENCY_91K)
N#define PLL_OUT_CLOCK_SPEED							(PLL_OUT_CLOCK_90MHz)
N
N#define USED_OPERATION_STAND_ALONE					(NO)
N#define USED_OPERATION_STAND_ALONE_DISPLAY_ON		(NO)
N
N#define USED_SHARP_SPECIFIC_PROTOCOL				(NO)
N
N#define USED_PEN_MODE_OPERATION						(NO)
N#define USED_INIT_PEN_MODE							(YES && USED_PEN_MODE_OPERATION)
N#define USED_PEN_ID_GET_FUNCTION					(YES && USED_PEN_MODE_OPERATION)
N
N#define USED_S3_MODE_FUNCTION						(NO && (!USED_PEN_MODE_OPERATION))
N#define USED_LPWG_MCU_SLEEP							(NO && (!USED_PEN_MODE_OPERATION))
N#define USED_S3_ALL_MUX_SHORT						(NO)
N
N#define USED_PWM_GATE_CONTROL						(NO)
N#define USED_TP_RST_OPERATION						(NO)
N#define USED_TP_LCD_ON_OPERATION					(YES && (USED_OPERATION_STAND_ALONE == NO))
N#define USED_TP_RSTnLCDON_DOUBLE_OPERATION			(USED_TP_RST_OPERATION && USED_TP_LCD_ON_OPERATION)
N
N#define USED_I2C_STOP_STATE_CHECK					(YES)
N
N#define USED_FINGER_OTHER_PWM_MUX_NUM_LAST_LHB		(NO)
N#if USED_FINGER_OTHER_PWM_MUX_NUM_LAST_LHB
X#if ((1==0))
S	#define DEF_FINGER_PWM_OTHER_NUM_SET_BIT_MASK_Full		(0x8080)
S	#define DEF_FINGER_PWM_NORMAL_NUM_SET_BIT_MASK_Full		(0x0101)
S	#define DEF_FINGER_PWM_OTHER_NUM_SET_BIT_MASK_Local		(0x0800)
S	#define DEF_FINGER_PWM_NORMAL_NUM_SET_BIT_MASK_Local	(0x1000)
N#endif /* USED_FINGER_OTHER_PWM_MUX_NUM_LAST_LHB */
N
N#define USED_ESD_RECOERY_DETECTION_RAWDATA_STUCK			(YES)
N#define DEF_ROIC_SENSING_BUFFER_NUM							(3)
N#define DEF_USED_AFE_1_CHECK_ROW_INDEX						(0)
N#define DEF_USED_AFE_1_CHECK_COL_INDEX						(0)
N#define DEF_USED_AFE_2_CHECK_ROW_INDEX						(2)
N#define DEF_USED_AFE_2_CHECK_COL_INDEX						(2)
N#define USED_ESD_RECOERY_DETECTION_ROIC_Abnoraml			(NO)
N#define USED_ESD_RECOVERY_GHOST_TOUCH_DELTA_PATTERN			(YES)
N#define USED_ESD_RECOVERY_RESET_AT_REBASE					(YES)
N#define USED_ESD_RECOVERY_RESET_TOUCH_AT_FIRST_FRAME		(YES)
N#define DEF_ESD_RECOVERY_RESET_TOUCH_AT_FIRST_FRAME_CNT_THD	(10)
N#define DEF_ESD_DEBUG_RAWDATA_BEFORE_LINEFILTER				(YES)
N//#define USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION		(YES)
N#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
X#if ((0==0))
N	#define DEF_ESD_SCAN_POS_NEG_ACCUM_BLOCK_THD				(30)
N	#define DEF_ESD_SCAN_REPORT_SKIP_DELTASUM_THD				(15000)
N	#define DEF_ESD_SCAN_REPORT_SKIP_CNT_THD					(10)
N#endif /* USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION */
N#if USED_ESD_RECOVERY_CHECK_ABNORMAL_PEN_DELTA
X#if ((0==0))
N	#define DEF_ESD_CHECK_ABNORMAL_PEN_DELTA_RESET_THD			(3)
N	#define DEF_ESD_CHECK_ABNORMAL_PEN_DELTA_FRAME_NUM			(10)
N	#define DEF_ESD_CHECK_ABNORMAL_PEN_DELTA_SUM_THD			(20000)
N#endif /*USED_ESD_RECOVERY_CHECK_ABNORMAL_PEN_DELTA*/
N
N/*******************************************************************
N * Custom Specific Define
N *******************************************************************/
N#define USED_TOUCH_WGP_PREDRV_MUX_SENSING				(YES)/*Pend Data*/
N
N#define USED_RAWDATA_TUNE_CALIBRATION					(NO)
N#if USED_RAWDATA_TUNE_CALIBRATION
X#if ((1==0))
S	#define DEF_RAWDATA_TUNE_TYPE_AUTO						(1)
S	#define DEF_RAWDATA_TUNE_TYPE_MANUAL					(2)
S	#define RAWDATA_TUNE_CALIBRATION_TYPE					(DEF_RAWDATA_TUNE_TYPE_AUTO)
S	#define USED_RAWDATA_HOPP_FRQ_CALIBRATION				(NO)
S	#if (RAWDATA_TUNE_CALIBRATION_TYPE == DEF_RAWDATA_TUNE_TYPE_AUTO)
S		#define RAWDATA_TUNE_AUTO_CALIBRATION_TARGET_VAL		(1900)
S	#endif /* (RAWDATA_TUNE_CALIBRATION_TYPE == DEF_RAWDATA_TUNE_TYPE_AUTO) */
N#endif /* USED_RAWDATA_TUNE_CALIBRATION */
N#define USED_ROIC_AFE_LP_OPTION							(YES)
N
N#define USED_QUEUECOMMONDATA_SEND_Timer_Tick			(YES)
N
N#define USED_MNT_S3_MODE_FUNCTION						(NO)
N#define S3_MODE_FRAME_RATE_Hz							(20)//Hz
N#define S3_MODE_TOUCH_TIME_usec							(7000)//usec
N#define USED_S3_POWER_INPUT_CHECK						(YES && USED_MNT_S3_MODE_FUNCTION)
N#define USED_S3_SIGNAL_OUTPUT_CTRL						(YES && USED_MNT_S3_MODE_FUNCTION)
N#define USED_S3_VDD_OE_INPUT_OUTPUT_CTRL				(YES && USED_MNT_S3_MODE_FUNCTION)
N#define USED_S3_VDD_OE_INPUT_OUTPUT_ALWAYS_LOW_CTRL		(NO && USED_MNT_S3_MODE_FUNCTION)
N#define TPIC_S3_VDD_OE_INPUT_OUTPUT_CTRL_START_CNT_THD	(4)
N#define TPIC_S3_VDD_OE_INPUT_OUTPUT_CTRL_FRAME_CNT_THD	(40) //2 sec
N#define USED_S3_PGAMMA_SW_I2C_CTRL						(YES && USED_MNT_S3_MODE_FUNCTION)
N
N#define USED_S3_WAKEUP_MOUSE_DEVICE						(NO)
N#define USED_S3_WAKEUP_DEBUGING							(NO)
N
N#define USED_S3_MSPI_4MHz_OPERATION						(YES)
N
N#define USED_VTSP_ONLY_LOW_POWER						(NO)
N#define USED_VTSP_ONLY_HOST_INTERFACE_OFF				(NO)
N#define USED_TOUCH_SLEEP_CTRL_BY_HOST					(NO)
N#if USED_TOUCH_SLEEP_CTRL_BY_HOST
X#if ((1==0))
S	#define DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN		(YES) // For Test
N#endif /* USED_TOUCH_SLEEP_CTRL_BY_HOST */
N
N#define USED_CHECK_TP_EN_PIN_IN_PT_TEST_ITEM			(YES)
N
N#define USED_PWM_FRQ_114KHz								(NO) // vFF.05
N#define USED_PWM_FRQ_140KHz								(NO) // vFF.06
N
N#define USED_GET_REVERSE_CRC_VALUE						(0)
N
N/*******************************************************************
N * MSB 8bit is Binary Type
N *******************************************************************/
N#if 1
N	#define APP_VERSION					(0x0006) // base v00.07
N#else
S	#define APP_VERSION					(0xFF15) // For BOE
S//	#define APP_VERSION					(0xF001) // For SE
N#endif
N
N#define CONFIG_VERSION				(0x0001)
N#define I2C_ADDRESS					(0x09)
N#define HID_DESCRIPTOR_ADDRESS		(0x0001)
N#define UNIQUE_APP_PID 				(0x9902)
N
N#define I2C_X_RESOLUTION			(32768)
N#define I2C_Y_RESOLUTION			(32768)
N
N// For CRC Matching
N#define APP_MEM_SIZE				(0xD3FA)//(80)//(0x137B)//(80)//(0x1F77)//(80)
N#define CONFIG_MEM_SIZE				(0x5252)//(28)//(0xD198)//(28)//(0x7AFA)//(28)
N
N// 13.3"
N// X, Y Physical Maximum
N#define X_PHYSICAL_MAX				(34445) // (34.445 cm)
N#define Y_PHYSICAL_MAX				(21528) // (21.528 cm)
N
N#define MODE_WDT				// WDT Mode Apply
N//#define DC_BASE
N#define MODE_I2C
N
N/* The Pen Intensity and Rawdata is broken when viewing using a tool.
N * The Intensity and RawData is 2-Bytes, but I2C communication is 1-byte.
N * Pen data and I2C Logging is async.
N * If the data is updated immediately after sending the MSB using the I2C.
N * LSB Data is sending update data. So, tool Is display Broken data
N * If this define is applied, I2C is processed by 2bytes  */
N#define USED_I2C_READ_DATA_UNIT_2BYTE		(YES & USED_PEN_MODE_OPERATION)
N
N#define ADD_TOUCH
N#if USED_PEN_MODE_OPERATION
X#if ((1==0))
S	#define ADD_PEN
N#endif /* USED_PEN_MODE_OPERATION */
N
N#define ADD_CUSTOM
N#define USB_SELECTIVE_SUSPEND
N//#define I2C_SELECTIVE_SUSPEND
N
N/*******************************************************************************************
N *                       Algorithm Setting
N *******************************************************************************************/
N#if USED_PEN_MODE_OPERATION
X#if ((1==0))
S/*------------------ Pen Tilt Setting -----------------------------------------------------*/ 
S#define TILT_ON 1		    			//Tilt Enable 
S#ifdef TILT_ON
S	#define TILT_OPCODE	1
S	//#define DSP_SMOOTH_PASTPOS	1 
S	#define TILT_SMOOTHING	1
S	#define TILT_EDGE_FILTER		(NO)
S	#define TILT_AREA_FILTER		(NO)
S	//#define Pen2ReportMethod	2 //0 : All Original, 1 : Pen2 Prediction, 2 : Smoothing of Pen2 prediction, 3 : Pen2 Skip (180hz) 
S	//#define FirstTiltWaitReport 1    //Report skip until correct tilt value
S	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
S		#define FirstTiltWaitReportMS 1    //Report skip until correct tilt value
S		//#define TiltAccuracyTest 1
S	#endif
S	#define TiltBasedRingDelta				(NO)
S	#define TiltDirecLimitFilter			(NO)
S	#define TiltChangeLimitFilter			(NO)
S	#define HighDeltaTiltSmoothCoefChange	(NO)
S	#define TiltDirecLimitFilter 			(NO)
S	#define TiltDeltaLimit_EN				(YES)
S	#define TiltDeltaLimit_ADD				(YES)
S	#define TiltMedianFilter				(NO)
S	#define UseLastContact3x3				(NO)
S	#define TiltArcSinLookUp_Num			(2)		// 0,1,2,3 : each table use, 3 < : all table use debug mode 
S	#define TiltAdjustEn 					(NO)
S#endif
S/*-----------------------------------------------------------------------------------------*/ 
S
S/*-------------------- Pen Contact&Hover&Data Setting -------------------------------------*/  
S//#define PenFingerSameLineNoiseException 1
S//#define LongDisPointException	1
S#define LocalFingerNoiseRemove 1				 //Local Finger Point remove near by pen point 
S#define OrgPastPosInterpolation_OPCODE 3 		 //Org Pos Num 0:off, Max 3 
S//#define SW_RATE_UP_EN					1		 // 1:300hz, 2:360hz, 3:420hz
S//#define CalculateDeltaLocalSearch_OPCODE	1
S#define ADAPTOR_NOISE_ALGO_EN			(NO)
S#define AbnormalContactRemove_EN		(NO)
S#define LOCAL_REBASE_ALGO_EN			(NO)	//	Local Mode Re-Baseline Algorithm On, HanCH
S#define USED_DSPA_FUNC_FOR_PEN_SEARCH	(NO)	//	Local Pen Search Mode Phase & Delta Calculation On, HanCH
S#define USED_DSPA_FUNC_FOR_PEN_LOCAL	(NO)	//	Local Pen Hover&Contact Mode Phase & Delta Calculation On, HanCH
S#define CornerSmoothContact				(NO)//(YES)
S#define IdealInterOnlyCorner 			(NO)//(YES)
S#define DataAdaptiveContactTh_EN		(NO)
S#define HoverDeltaMul_EN				(NO)
S#define HIGH_HOVER_JITTER_REDUCE		(YES)
S#define DeltaBaseNewEdgeCompen_SW		(YES)
S#define PEN_CORNER_EXPEND_ADD			(YES)
S#define CORNER_CoordiShift_WithTilt_ADD (NO)//(YES)
S#define USED_PEN_PRESSURE_BRUSH_LEVEL_CTRL	(YES)
S//#define PEN_FINGER_1TOUCH_REPORT		(YES)
S//#define PEN_Latency_Test_ByFW			(YES)
S#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
S	#define FingerAreaPenDeltaDelete 			(1)
S#endif
S/*-----------------------------------------------------------------------------------------*/
N#endif /* #if USED_PEN_MODE_OPERATION */
N
N/*-------------------- Finger Setting -----------------------------------------------------*/ 
N#define USED_DSPA_FUNC_FOR_FINGER			(YES)	//	Finger Mode DAP_A On, HanCH
N#if USED_DSPA_FUNC_FOR_FINGER
X#if ((0==0))
N	#define USED_DSPA_FUNC_FOR_FINGER_LF		(NO)	//	Finger Mode DAP_A LineFilter On, HanCH
N	#define USED_DSPA_FUNC_FOR_FINGER_CAL_DELTA	(YES)	//	Finger Mode DAP_A Delta Calculation On, HanCH
N#endif
N#define FINGER_LF_VER2_EN					(YES)
N#define PALM_VER1_EN						(NO)
N#define WinCertAssistance_En				(NO)
N#define CPI_TEST_EN							(NO)
N#define LGD_ERROR_FRAME_PROCESS_EN			(NO)
N#define NORMALIZE_DELTA_EN					(NO)
N#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
X#if (((4)) == (1))
S	#define BIG_FINGER_EDGE_EXPAND_ALGO_EN		(YES)
S	#define BIG_FINGER_EDGE_ACC_TEST_ALGO_EN	(YES)
N#else
N	#define BIG_FINGER_EDGE_EXPAND_ALGO_EN		(YES)
N#endif
N#define VECTOR_PREDICTION_EN								(YES)
N#define PalmCandidateTouchCut_EN							(YES)
N#define PalmFirstDetectionShift								(YES)
N#define ADAPTIVE_SEEDBASE				(NO)
N#define DIAG_OFF						(NO || USED_RAWDATA_TUNE_CALIBRATION)
N#define FAST_LF_EN						(NO)	//SW LineFilter Fast Process On //It must be NO, when DSP_A Finger Cal Delta define&parameter On, 201217 HanCH
N#define LABEL_FAST_EN					(NO)	//label_SearchValidArea Fast Process On	1 : Delta Calculation&Labeling 1st Stage merge Off, 2 : Delta Calculation&Labeling 1st Stage merge On//It must be NO, when DSP_A Finger Cal Delta define&parameter On, 201217 HanCH
N#if LABEL_FAST_EN
X#if ((1==0))
S	#define	ROW_IN_ARRAY 	8
S	#define COL_IN_ARRAY	8
S	#define ARRAY_ROW		(ROW_MAX/ROW_IN_ARRAY+1)
S	#define ARRAY_COL		(COL_MAX/COL_IN_ARRAY+1)
N#endif
N#define FAST_SPLIT						(YES)	//Label Split Fast Process On
N#define REMOVE_EDGE_EN 					(YES)
N#define MULTI_EDGE_COEF_EN 				(YES)
N#define WeightedConflict				(YES)	//heon
N#define ConflictTest					(YES)
N//#define FINGER_Latency_Test_ByFW		(YES)
N/*-----------------------------------------------------------------------------------------*/
N
N/*******************************************************************************************
N *                       Operation Mode Setting
N *******************************************************************************************/
N
N#define LHB_NUM								(16)
N#if USED_IDLE_MODE_30Hz_CONTROL
X#if ((1==0))
S	#define LOCAL_IDLE_LHB_NUM				(20)
S#elif USED_IDLE_MODE_20Hz_CONTROL
X#elif ((1==0))
S	#define LOCAL_IDLE_LHB_NUM				(30)
N#else
N	#define LOCAL_IDLE_LHB_NUM				(16)
N#endif
N
N#define MAX_TOUCH_                      	(10)
N#define MAX_KEY_                        	(4)
N#define PAD_                            	(0)
N
N#define ROW_MAX								(48)
N#define COL_MAX								(84)
N#define FPITCH_X							(4.10)
N#define FPITCH_Y							(4.49)
N#define NI_ROW_MAX							(USED_IDLE_NI_SENSING_MUX_NUM*5)
N
N#define LOCAL_FINGER_1MUX_ROW_NUM			(5)
N#define LOCAL_FINGER_1LHB_SCAN_MUX_NUM		(3)
N
N#define PEN_COORD_ROW_MAX					(5)
N#define PEN_COORD_COL_MAX					(COL_MAX)
N#define PEN_DATA_ROW_MAX					(PEN_COORD_ROW_MAX*6) // MS MPP Pen Data
N#define PEN_DATA_ROW_MAX_2					(PEN_COORD_ROW_MAX*8) // Wacom AIT Pen Data
N#define PEN_DATA_ROW_MAX_3					(PEN_COORD_ROW_MAX*7) // Wacom WGP Pen Data
N
N#define MUX_RANGE_SIZE	    				(2)
N#define MAX_MUX_SIZE						(PEN_COORD_ROW_MAX)
N#define MAX_MUX_HALF						(MAX_MUX_SIZE>>1)
N#define MUX_MAX_ROW							(ROW_MAX - MAX_MUX_SIZE)
N
N
N/***************************************************************************************************************************************
N * platform_env.h
N ***************************************************************************************************************************************/
N//#define _USE_NOISE_INDEX_
N#define _DV_SAMPLE_
N
N#define MSPI_START_VAL					(uint32_t)(BIT3|BIT2|BIT1|BIT0)
N
N#define SPI_DMY_LEN     				(2)
N#define SRIC_PROTOCOL_RESET_COUNT   	(7)
N#define READ_ALIGNED_BUF    			(0x0000)
N
N#define ROIC_ALIGNED_COL_LEN  			(21)//(12)//(14)
N#define ROIC_ALIGNED_ROW_LEN  			(5)
N
N#define R0_COL_LEN						(11)
N#define R0_ROW_LEN						(5)
N
N#define R1_COL_LEN						(10)
N#define R1_ROW_LEN						(5)
N
N
N#define MSPI_NUM                		(4)
N#define SRIC_NUM                		(4)
N
N#define SM_NUM                  		(1)
N
N#define MSPI_ROW_MAX_MUX				(10)
N#define FINGER_MUX_NUM              	(10)
N#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
X#if ((0==0))
N	#define FINGER_ESD_SCAN_MUX_NUM			(2)
N	#define FINGER_ESD_SCAN_ROW_MAX_NUM		(10)
N#endif
N
N#define FINGER_IDLE_NI_MUX_NUM          (USED_IDLE_NI_SENSING_MUX_NUM)
N
N#define MSPI_MSPEN_ALIGNED_COL_LEN  				(21)//(12)//(14)
N#define MSPI_MSPEN_ALIGNED_ROW_LEN  				(5)
N
N#define MSPI_WACOMPEN_ALIGNED_COL_LEN  				(21)//(12)//(14)
N#define MSPI_WACOMPEN_ALIGNED_ROW_LEN  				(5)
N
N#define MSPI_WGPPEN_ALIGNED_COL_LEN  				(21)//(12)//(14)
N#define MSPI_WGPPEN_ALIGNED_ROW_LEN  				(5)
N#define MSPI_WGPPEN_ALIGNED_DUMMY					(7)//(2)//(2)//(6)//(2)
N
N
N#define SZ_MSPIBUF_REGISTER     			(SPI_DMY_LEN + 1)
N#define SZ_MSPIBUF_MUXDATA      			(SPI_DMY_LEN + 5 + (ROIC_ALIGNED_COL_LEN * ROIC_ALIGNED_ROW_LEN))
N//#define SZ_MSPIBUF_MUXDATA      			((ROIC_ALIGNED_COL_LEN * ROIC_ALIGNED_ROW_LEN))
N//#define SZ_MSPIBUF_FINGER_FULL_FRAME		(SZ_MSPIBUF_MUXDATA * FINGER_MUX_NUM)
N//#define SZ_MSPIBUF_FINGER_IDLE_FULL_FRAME   (SZ_MSPIBUF_MUXDATA * FINGER_IDLE_NI_MUX_NUM)
N
N#define LOCAL_FINGER_LAST_LHB				(PARTIAL_FINGER4)
N
N#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN)
X#if (((4)) == (4))
N	#define LOCAL_OP_LAST_LHB				(PARTIAL_PEN_DATA4)
N#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
S	#define LOCAL_OP_LAST_LHB				(PARTIAL_PEN_COORD_DATA4)
S#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
S	#define LOCAL_OP_LAST_LHB				(PARTIAL_FINGER3)
S#elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
S	#define LOCAL_OP_LAST_LHB				(PARTIAL_FINGER3) // For MPP2.5
S	#define LOCAL_OP_2_LAST_LHB				(PARTIAL_PEN_DATA4) // For WGP
N#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN) */
N
N
N#endif /* _INFORMATION_H_ */
L 174 "..\..\Env\env_model_B/env_model.h" 2
C "..\..\Env\env_model_B/env_model.h" 174 87 cannot open source input file "customer/FHD_92513_16_Lenovo_NonPrivacy/param_configset_algorithm_common.h": No such file or directory
N	#include "customer/FHD_92513_16_Lenovo_NonPrivacy/param_configset_algorithm_common.h"
