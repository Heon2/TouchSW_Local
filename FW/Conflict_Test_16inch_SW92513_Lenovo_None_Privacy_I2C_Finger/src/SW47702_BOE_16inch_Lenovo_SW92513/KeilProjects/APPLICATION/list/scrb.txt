; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\scrb.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\scrb.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\scrb.crf ..\..\Hal\scrb\scrb.c]
                          THUMB

                          AREA ||i.SCRB_Initialize||, CODE, READONLY, ALIGN=2

                  SCRB_Initialize PROC
;;;35     
;;;36     void SCRB_Initialize(void)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  b08c              SUB      sp,sp,#0x30
;;;38     	/*
;;;39     	 * Trim Code Read and Write
;;;40     	 */
;;;41     	{
;;;42     #if 0 /* Old Trim Code */
;;;43     		unsigned * saddr;
;;;44     		unsigned int Trimdata = 0;
;;;45     
;;;46     		FLASH->FACR.tBit.LATENCY = 0x6;
;;;47     		FLASH->FUSRCTRL.tBit.ECC_EN = 0x1;
;;;48     
;;;49     		saddr = (unsigned *)0x00020088;
;;;50     		Trimdata = *saddr;
;;;51     		SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VREF_TRIM = (Trimdata>>5) & 0xF;
;;;52     		SCRB->SYS_ANA_TRIM.tBit.R_MAIN_IREF_TRIM = Trimdata & 0x1F;
;;;53     
;;;54     		saddr = (unsigned *)0x00020084;
;;;55     		Trimdata = *saddr;
;;;56     		SCRB->SYS_ANA_TRIM.tBit.R_LDO_TRIM = Trimdata & 0x1F;
;;;57     
;;;58     		saddr = (unsigned *)0x00020080;
;;;59     		Trimdata = *saddr;
;;;60     		SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_ITRIM = (Trimdata>>6) & 0x7;
;;;61     		SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_VTRIM = Trimdata & 0x3F;
;;;62     
;;;63     		FLASH->FUSRCTRL.tBit.ECC_EN = 0x3;
;;;64     		FLASH->FACR.tBit.LATENCY = 0x6;
;;;65     #else
;;;66     		tFlashPTTrimCodeInfo_t PTTrimCodeInfo = {0,};
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
;;;67     
;;;68     		// Flash access latency - Must do
;;;69     		FLASH->FACR.tBit.LATENCY = 0x6;			// flash access latency, must be over 6
000008  4db5              LDR      r5,|L1.736|
00000a  9601              STR      r6,[sp,#4]            ;66
00000c  9602              STR      r6,[sp,#8]            ;66
00000e  9603              STR      r6,[sp,#0xc]          ;66
000010  9604              STR      r6,[sp,#0x10]         ;66
000012  9605              STR      r6,[sp,#0x14]         ;66
000014  9606              STR      r6,[sp,#0x18]         ;66
000016  9607              STR      r6,[sp,#0x1c]         ;66
000018  9608              STR      r6,[sp,#0x20]         ;66
00001a  9609              STR      r6,[sp,#0x24]         ;66
00001c  960a              STR      r6,[sp,#0x28]
00001e  6828              LDR      r0,[r5,#0]
000020  f020000f          BIC      r0,r0,#0xf
000024  1d80              ADDS     r0,r0,#6
000026  6028              STR      r0,[r5,#0]
;;;70     
;;;71     		SCRB->SYS_OSC_PD_CTL.ulBulk = 0x7;		// for BOD Control
000028  2007              MOVS     r0,#7
00002a  03ec              LSLS     r4,r5,#15
00002c  62a0              STR      r0,[r4,#0x28]
;;;72     
;;;73     		// Analog Trim setting - Must do
;;;74     		FLASH->FUSRCTRL.tBit.ECC_EN = 0x1;		//	ECC OFF
00002e  f8d501d0          LDR      r0,[r5,#0x1d0]
000032  f0400002          ORR      r0,r0,#2
000036  f8c501d0          STR      r0,[r5,#0x1d0]
;;;75     
;;;76     		if(FLITF_CheckTrimInfoSectionIntegrity(&PTTrimCodeInfo))
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       FLITF_CheckTrimInfoSectionIntegrity
000040  b318              CBZ      r0,|L1.138|
;;;77     		{
;;;78     			SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_VTRIM = PTTrimCodeInfo.tTrim1.R_OSC12M_VTRIM;
000042  f89d0014          LDRB     r0,[sp,#0x14]
000046  6ae1              LDR      r1,[r4,#0x2c]
000048  f3600105          BFI      r1,r0,#0,#6
00004c  62e1              STR      r1,[r4,#0x2c]
;;;79     			SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_ITRIM = PTTrimCodeInfo.tTrim1.R_OSC12M_ITRIM;
00004e  f8bd0014          LDRH     r0,[sp,#0x14]
000052  0981              LSRS     r1,r0,#6
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  f3611088          BFI      r0,r1,#6,#3
00005a  62e0              STR      r0,[r4,#0x2c]
;;;80     			SCRB->SYS_ANA_TRIM.tBit.R_LDO_TRIM = PTTrimCodeInfo.tTrim2.R_LDO_TRIM;
00005c  f89d0018          LDRB     r0,[sp,#0x18]
000060  6ae1              LDR      r1,[r4,#0x2c]
000062  f360214d          BFI      r1,r0,#9,#5
000066  62e1              STR      r1,[r4,#0x2c]
;;;81     			SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VBGR_CTL = PTTrimCodeInfo.tTrim3.R_MAIN_VBGR_CTL;		//	New Added.
000068  f89d001c          LDRB     r0,[sp,#0x1c]
00006c  6ae1              LDR      r1,[r4,#0x2c]
00006e  f3604112          BFI      r1,r0,#16,#3
000072  62e1              STR      r1,[r4,#0x2c]
;;;82     			SCRB->SYS_ANA_TRIM.tBit.R_MAIN_IREF_TRIM = PTTrimCodeInfo.tTrim3.R_MAIN_IREF_TRIM;
000074  08c1              LSRS     r1,r0,#3
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  f36140d7          BFI      r0,r1,#19,#5
00007c  62e0              STR      r0,[r4,#0x2c]
;;;83     			SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VREF_TRIM = PTTrimCodeInfo.tTrim3.R_MAIN_VREF_TRIM;
00007e  f89d101d          LDRB     r1,[sp,#0x1d]
000082  6ae0              LDR      r0,[r4,#0x2c]
000084  f361601b          BFI      r0,r1,#24,#4
000088  62e0              STR      r0,[r4,#0x2c]
                  |L1.138|
;;;84     		}
;;;85     #ifdef _USE_WITH_BOOT_
;;;86     	#if USED_TRIMCODE_UPDATE_SECURITY_FUNC
;;;87     		else
;;;88     		{
;;;89     			tSimpleBootFlashCtrlInfo_t * pSimpleBootFlashCtrlInfo = (tSimpleBootFlashCtrlInfo_t *)SRAM_SIMPLE_BOOT_CTRL_INFO_ADDR;
;;;90     			pSimpleBootFlashCtrlInfo->ulFlashUpdateType = SIMPLE_BOOT_FLASH_UPDATE_TRIM_CODE_WRITE;
;;;91     			{
;;;92     				/*
;;;93     				 * PT Trim Code Update
;;;94     				 */
;;;95     				memset((void *)&pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo, 0x0, sizeof(tFlashPTTrimCodeInfo_t));
;;;96     				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.ulMagicCode = EFLASH_PT_MAGIC_CODE;
;;;97     
;;;98     				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_VTRIM = 0xA;
;;;99     				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_ITRIM = 0x7;
;;;100    
;;;101    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim2.R_LDO_TRIM = 0x11;
;;;102    
;;;103    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VBGR_CTL = 0x4;
;;;104    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_IREF_TRIM = 0xF;
;;;105    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VREF_TRIM = 0xC;
;;;106    
;;;107    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.CheckSum = FLITF_Calc32bitCheckSum((uint32_t *)&pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo, EFLASH_ANALOG_TRIM_PT_INFO_WORD_SIZE-1);
;;;108    			}
;;;109    
;;;110    			{
;;;111    				/*
;;;112    				 * FT Trim Code Update
;;;113    				 */
;;;114    				memset((void *)&pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo, 0x0, sizeof(tFlashFTTrimCodeInfo_t));
;;;115    
;;;116    				pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo.CHIP_ID_ECC = EFLASH_FT_CHIP_ID_CODE;
;;;117    
;;;118    				pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo.CheckSum = FLITF_Calc32bitCheckSum((uint32_t *)&pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo, EFLASH_ANALOG_TRIM_FT_INFO_WORD_SIZE-1);
;;;119    			}
;;;120    
;;;121    			FLITF_FlashInformationRegionWriteOperation();
;;;122    		}
;;;123    	#endif /* USED_TRIMCODE_UPDATE_SECURITY_FUNC */
;;;124    #endif /* _USE_WITH_BOOT_ */
;;;125    
;;;126    		// Analog Trim setting - Must do
;;;127    		FLASH->FUSRCTRL.tBit.ECC_EN = 0x3;		//	ECC ON
00008a  f8d501d0          LDR      r0,[r5,#0x1d0]
00008e  f0400002          ORR      r0,r0,#2
000092  f8c501d0          STR      r0,[r5,#0x1d0]
;;;128    		// Flash access latency - Must do
;;;129    		FLASH->FACR.tBit.LATENCY = 0x6;			// flash access latency, must be over 6
000096  6828              LDR      r0,[r5,#0]
000098  f020000f          BIC      r0,r0,#0xf
00009c  1d80              ADDS     r0,r0,#6
00009e  6028              STR      r0,[r5,#0]
;;;130    #endif
;;;131    	}
;;;132    
;;;133    	/*
;;;134    	 * ECLK OFF시키자!! Default가 Enable이라 PLL On되면 ECLK바로 구동 되어 버림!!
;;;135    	 */
;;;136    	PWMDRV->ECLK_CR.tBit.eclk_force_on = 0;
0000a0  4890              LDR      r0,|L1.740|
0000a2  f8501f8c          LDR      r1,[r0,#0x8c]!
0000a6  f4217100          BIC      r1,r1,#0x200
0000aa  6001              STR      r1,[r0,#0]
;;;137    	PWMDRV->ECLK_CR.tBit.eclk_en = 0;
0000ac  6801              LDR      r1,[r0,#0]
0000ae  f0210101          BIC      r1,r1,#1
0000b2  6001              STR      r1,[r0,#0]
;;;138    
;;;139    	{
;;;140    		tSYS_CLK_CTL _SYS_CLK_CTL;
;;;141    		_SYS_CLK_CTL.tBit.wdtclk_en = YES;
;;;142    		_SYS_CLK_CTL.tBit.timclk0_en = YES;
;;;143    		_SYS_CLK_CTL.tBit.timclk1_en = YES;
;;;144    		_SYS_CLK_CTL.tBit.timclk2_en = YES;
;;;145    		_SYS_CLK_CTL.tBit.timclk3_en = YES;
;;;146    		_SYS_CLK_CTL.tBit.i2cclk_en = YES;//YES;
;;;147    		_SYS_CLK_CTL.tBit.dspaclk_en = YES;
;;;148    		_SYS_CLK_CTL.tBit.tdspclk_en = YES;
;;;149    #ifdef MODE_I2C
;;;150    		_SYS_CLK_CTL.tBit.usbcclk_en = NO;
;;;151    		_SYS_CLK_CTL.tBit.usbhclk_en = NO;
;;;152    #else /* MODE_I2C */
;;;153    		_SYS_CLK_CTL.tBit.usbcclk_en = YES;
;;;154    		_SYS_CLK_CTL.tBit.usbhclk_en = YES;
;;;155    #endif /* MODE_I2C */
;;;156    		_SYS_CLK_CTL.tBit.pwmclk_en = YES;
;;;157    		_SYS_CLK_CTL.tBit.mspiclk_en = YES;
;;;158    		_SYS_CLK_CTL.tBit.sscgclk_en = YES;
;;;159    		_SYS_CLK_CTL.tBit.mpiclk_en = NO;
;;;160    		_SYS_CLK_CTL.tBit.tlvclk_en = NO;
;;;161    		_SYS_CLK_CTL.tBit.i2cm0clk_en = YES;
;;;162    		_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = YES;
;;;163    		_SYS_CLK_CTL.tBit.i2cm1clk_en = YES;
0000b4  9800              LDR      r0,[sp,#0]
0000b6  f42040c6          BIC      r0,r0,#0x6300
0000ba  f4202000          BIC      r0,r0,#0x80000
;;;164    		_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = YES;
0000be  f04000ff          ORR      r0,r0,#0xff
0000c2  f4403067          ORR      r0,r0,#0x39c00
;;;165    		_SYS_CLK_CTL.tBit.osc_deglitch_en = NO;
0000c6  f4402080          ORR      r0,r0,#0x40000
;;;166    		SCRB->SYS_CLK_CTL.ulBulk = _SYS_CLK_CTL.ulBulk;
0000ca  9000              STR      r0,[sp,#0]
0000cc  9800              LDR      r0,[sp,#0]
0000ce  60a0              STR      r0,[r4,#8]
;;;167    
;;;168    	    SCRB->SYS_RST_CTL.ulBulk = 0x00; /* all release */
0000d0  60e6              STR      r6,[r4,#0xc]
;;;169    	    WDT->WDOG_RSTCLR = 1; // watchdog interrupt status clear
0000d2  2001              MOVS     r0,#1
0000d4  f8c4018c          STR      r0,[r4,#0x18c]
;;;170    
;;;171    	    SCB->SHCSR |= (7 << 16);
0000d8  4883              LDR      r0,|L1.744|
0000da  6801              LDR      r1,[r0,#0]
0000dc  f44121e0          ORR      r1,r1,#0x70000
0000e0  6001              STR      r1,[r0,#0]
;;;172    	    SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
0000e2  4982              LDR      r1,|L1.748|
0000e4  2004              MOVS     r0,#4
0000e6  6008              STR      r0,[r1,#0]
;;;173    	}
;;;174    
;;;175    	{
;;;176    		/*
;;;177    		 * USB POR set
;;;178    		 */
;;;179    		tUSB_PHY_FC USB_PHY;
;;;180    		USB_PHY.ulBulk = SCRB->USB_PHY_FC.ulBulk;
0000e8  f8d400a8          LDR      r0,[r4,#0xa8]
0000ec  9000              STR      r0,[sp,#0]
;;;181    		USB_PHY.tBit.pllaliv = 0;
;;;182    
;;;183    #ifdef MODE_I2C
;;;184    	#if !USED_PEN_MODE_OPERATION
;;;185    		/*
;;;186    		 * X-tal Oscillator Off
;;;187    		 */
;;;188    		USB_PHY.tBit.oscouten = 0;
;;;189    	#endif /* !USED_PEN_MODE_OPERATION */
;;;190    		USB_PHY.tBit.ponrst = 0;
0000ee  f020001a          BIC      r0,r0,#0x1a
;;;191    #else /* MODE_I2C */
;;;192    		USB_PHY.tBit.ponrst = 1;
;;;193    #endif /* MODE_I2C */
;;;194    		SCRB->USB_PHY_FC.ulBulk = USB_PHY.ulBulk;
0000f2  9000              STR      r0,[sp,#0]
0000f4  9800              LDR      r0,[sp,#0]
0000f6  f8c400a8          STR      r0,[r4,#0xa8]
;;;195    //		SCRB->USB_PHY_FC.ulBulk = 0x31B;		// USB POR ON, USB should be worked after 3msec with this setting.
;;;196    
;;;197    		medium_delay(3000);
0000fa  f64030b8          MOV      r0,#0xbb8
0000fe  f7fffffe          BL       medium_delay
;;;198    		/*
;;;199    		 * Internal OSC use (12MHz) - Default.
;;;200    		 */
;;;201    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	//	main system clk: 12MHz, default: 0
000102  6e20              LDR      r0,[r4,#0x60]
000104  f0200001          BIC      r0,r0,#1
000108  6620              STR      r0,[r4,#0x60]
;;;202    		/*
;;;203    		 * MCLK freq. setting
;;;204    		 */
;;;205    		SCRB->SYS_MAINCLK_CFG.tBit.mclksel = 0;	// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)		//	0: internal OSC, 1: External Crystal
00010a  6e20              LDR      r0,[r4,#0x60]
00010c  f4203080          BIC      r0,r0,#0x10000
000110  6620              STR      r0,[r4,#0x60]
;;;206    		SCRB->SYS_MAINCLK_CFG.tBit.mclkdiv = 15;	// WATCHDOG_BASE_ADDR & timer clock. OSC freq./(mclkdiv+1)    ( default: 12)
000112  6e20              LDR      r0,[r4,#0x60]
000114  f420407c          BIC      r0,r0,#0xfc00
000118  f5005070          ADD      r0,r0,#0x3c00
00011c  6620              STR      r0,[r4,#0x60]
;;;207    
;;;208    		/*
;;;209    		 * Cache Control
;;;210    		 */
;;;211    		SCRB->CACHE_CTRL.tBit.CACHE_EN = 0;	// 1: ENABLE. 0 : disable
00011e  f8d40090          LDR      r0,[r4,#0x90]
000122  f0200001          BIC      r0,r0,#1
000126  f8c40090          STR      r0,[r4,#0x90]
;;;212    		while(SCRB->CACHE_ST != 1)
00012a  bf00              NOP      
                  |L1.300|
00012c  f8d40094          LDR      r0,[r4,#0x94]
000130  2801              CMP      r0,#1
000132  d1fb              BNE      |L1.300|
;;;213    		{
;;;214    			;
;;;215    		}
;;;216    		SCRB->CACHE_CTRL.tBit.CACHE_FLUSH = 0;
000134  f8d40090          LDR      r0,[r4,#0x90]
000138  f0200002          BIC      r0,r0,#2
00013c  f8c40090          STR      r0,[r4,#0x90]
;;;217    		SCRB->CACHE_CTRL.tBit.CACHE_FLUSH = 1;
000140  f8d40090          LDR      r0,[r4,#0x90]
000144  f0400002          ORR      r0,r0,#2
000148  f8c40090          STR      r0,[r4,#0x90]
;;;218    		SCRB->CACHE_CTRL.tBit.CACHE_FLUSH = 0;
00014c  f8d40090          LDR      r0,[r4,#0x90]
000150  f0200002          BIC      r0,r0,#2
000154  f8c40090          STR      r0,[r4,#0x90]
;;;219    
;;;220    		SCRB->CACHE_CTRL.tBit.CACHE_BST = 3;	// burst 8
000158  f8d40090          LDR      r0,[r4,#0x90]
00015c  f040000c          ORR      r0,r0,#0xc
000160  f8c40090          STR      r0,[r4,#0x90]
;;;221    		SCRB->CACHE_CTRL.tBit.CACHE_DEN = 0;//1;	// data enable
000164  f8d40090          LDR      r0,[r4,#0x90]
000168  f0200010          BIC      r0,r0,#0x10
00016c  f8c40090          STR      r0,[r4,#0x90]
;;;222    		SCRB->CACHE_CTRL.tBit.CACHE_EN = 1;	// 1: ENABLE. 0 : disable
000170  f8d40090          LDR      r0,[r4,#0x90]
000174  f0400001          ORR      r0,r0,#1
000178  f8c40090          STR      r0,[r4,#0x90]
;;;223    	}
;;;224    
;;;225    	{
;;;226    #if USED_SPI_NBIT_TRANSMODE
;;;227    		/*
;;;228    		 * PLL Power On
;;;229    		 * 	- VCO range : 150 < (Fin*N)/M < 300 ==> MUST BE !!     // Fin: input clk
;;;230    		 * 	- PLL clock = (Fin*N)/(M*O)
;;;231    		 */
;;;232    #define PLL_RSEL_MAX			(5)
;;;233    #define PLL_RECOVERY_CNT		(870)	//	870: about 1ms  @12MHz
;;;234    		uint8_t ucRselIdx = 0;
;;;235    		uint8_t vucRselValue[PLL_RSEL_MAX] = {3, 2, 1, 0, 4};
;;;236    		uint32_t ulPllLockCnt = 0;
;;;237    
;;;238    		SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
;;;239    
;;;240    		SCRB->PLL_CFG.tBit.rsel = 4;
;;;241    
;;;242    		SCRB->PLL_CFG.tBit.pllin_sel = 1;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
;;;243    
;;;244    	#if USED_SW98502_MSPI_16MHz
;;;245    		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;246    			SCRB->PLL_CFG.tBit.refdiv = 1;//1;		// M = refdiv+1
;;;247    			SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;248    			SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;249    		//		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;250    		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;251    			SCRB->PLL_CFG.tBit.refdiv = 1;//1;		// M = refdiv+1
;;;252    			SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;253    			SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  288MHz		//	feedback divider
;;;254    		#elif (SPI_TRANSFER_BIT_NUM == 12)
;;;255    			SCRB->PLL_CFG.tBit.refdiv = 0;//1;		// M = refdiv+1
;;;256    			SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;257    			SCRB->PLL_CFG.tBit.fbdiv = 16;		// N = fbdiv (>5).  288MHz		//	feedback divider
;;;258    		#endif
;;;259    	#else
;;;260    		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;261    			SCRB->PLL_CFG.tBit.refdiv = 1;//1;		// M = refdiv+1
;;;262    			SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;263    			SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;264    		//		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;265    		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;266    			SCRB->PLL_CFG.tBit.refdiv = 1;//1;		// M = refdiv+1
;;;267    			SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;268    			SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  288MHz		//	feedback divider
;;;269    		#elif (SPI_TRANSFER_BIT_NUM == 12)
;;;270    			SCRB->PLL_CFG.tBit.refdiv = 1;//1;		// M = refdiv+1
;;;271    			SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;272    			SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  288MHz		//	feedback divider
;;;273    		#endif
;;;274    	#endif
;;;275    
;;;276    		SCRB->PLL_CFG.tBit.pll_stby_i = 0;	// PLL power on
;;;277    		while (!SCRB->PLL_LOCK)				// Wait Lock
;;;278    		{
;;;279    			ulPllLockCnt++;
;;;280    
;;;281    			if (ulPllLockCnt > PLL_RECOVERY_CNT)
;;;282    			{
;;;283    				SCRB->PLL_CFG.tBit.rsel = vucRselValue[ucRselIdx++];		//	rsel update
;;;284    				ulPllLockCnt = 0;
;;;285    
;;;286    				if (ucRselIdx >= PLL_RSEL_MAX)
;;;287    					ucRselIdx = 0;
;;;288    			}
;;;289    		}
;;;290    
;;;291    		/*
;;;292    		 * Change PLL clock
;;;293    		 */
;;;294    		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 1;//0;//1;//0;		// PLL clock divider. PLLCLK/(pllclkdiv+1)
;;;295    		SCRB->SYS_MAINCLK_CFG.tBit.usbclkdiv = 4;		// USB480 clock divider. 480MHz/(usbclkdiv+1)
;;;296    	#if (SPI_TRANSFER_BIT_NUM == 10)
;;;297    		SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 1;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;298    	#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;299    		SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;300    	#elif (SPI_TRANSFER_BIT_NUM == 12)
;;;301    		SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;302    	#endif
;;;303    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	// 0: INT OSC 1: PLL/USB clock
;;;304    #else /* USED_SPI_NBIT_TRANSMODE */
;;;305    		/*
;;;306    		 * PLL Power On
;;;307    		 * 	- VCO range : 150 < (Fin*N)/M < 300 ==> MUST BE !!     // Fin: input clk
;;;308    		 * 	- PLL clock = (Fin*N)/(M*O)
;;;309    		 */
;;;310    #define PLL_RSEL_MAX			(5)
;;;311    #define PLL_RECOVERY_CNT		(870)	//	870: about 1ms  @12MHz
;;;312    		uint8_t ucRselIdx = 0;
;;;313    		uint8_t vucRselValue[PLL_RSEL_MAX] = {3, 2, 1, 0, 4};
00017c  a25c              ADR      r2,|L1.752|
00017e  2000              MOVS     r0,#0                 ;312
000180  e9d21200          LDRD     r1,r2,[r2,#0]
000184  e9cd1200          STRD     r1,r2,[sp,#0]
;;;314    		uint32_t ulPllLockCnt = 0;
;;;315    
;;;316    		SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
000188  6fa1              LDR      r1,[r4,#0x78]
00018a  f4415100          ORR      r1,r1,#0x2000
00018e  67a1              STR      r1,[r4,#0x78]
;;;317    
;;;318    		SCRB->PLL_CFG.tBit.rsel = 4;
000190  6fa1              LDR      r1,[r4,#0x78]
000192  f42131e0          BIC      r1,r1,#0x1c000
000196  f5013180          ADD      r1,r1,#0x10000
00019a  67a1              STR      r1,[r4,#0x78]
;;;319    
;;;320    #ifdef MODE_I2C
;;;321    	#if USED_PEN_MODE_OPERATION
;;;322    		SCRB->PLL_CFG.tBit.pllin_sel = 1;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
;;;323    	#else
;;;324    		SCRB->PLL_CFG.tBit.pllin_sel = 0;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
00019c  6fa1              LDR      r1,[r4,#0x78]
00019e  f4212180          BIC      r1,r1,#0x40000
0001a2  67a1              STR      r1,[r4,#0x78]
;;;325    	#endif
;;;326    #else /* MODE_I2C */
;;;327    		SCRB->PLL_CFG.tBit.pllin_sel = 1;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
;;;328    #endif /* MODE_I2C */
;;;329    		SCRB->PLL_CFG.tBit.refdiv = 0;//1;		// M = refdiv+1
0001a4  6fa1              LDR      r1,[r4,#0x78]
0001a6  f0210107          BIC      r1,r1,#7
0001aa  67a1              STR      r1,[r4,#0x78]
;;;330    		SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
0001ac  6fa1              LDR      r1,[r4,#0x78]
0001ae  f42161c0          BIC      r1,r1,#0x600
0001b2  67a1              STR      r1,[r4,#0x78]
;;;331    
;;;332    		SCRB->PLL_CFG.tBit.fbdiv = 16;		// N = fbdiv (>5).  96MHz		//	feedback divider
0001b4  6fa1              LDR      r1,[r4,#0x78]
0001b6  f42171fc          BIC      r1,r1,#0x1f8
0001ba  3180              ADDS     r1,r1,#0x80
0001bc  67a1              STR      r1,[r4,#0x78]
;;;333    //		SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;334    //		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;335    
;;;336    		SCRB->PLL_CFG.tBit.pll_stby_i = 0;	// PLL power on
0001be  6fa1              LDR      r1,[r4,#0x78]
0001c0  f4215100          BIC      r1,r1,#0x2000
0001c4  67a1              STR      r1,[r4,#0x78]
;;;337    		while (!SCRB->PLL_LOCK)				// Wait Lock
0001c6  6fe1              LDR      r1,[r4,#0x7c]
0001c8  b9a1              CBNZ     r1,|L1.500|
0001ca  e084              B        |L1.726|
                  |L1.460|
0001cc  1c49              ADDS     r1,r1,#1
;;;338    		{
;;;339    			ulPllLockCnt++;
;;;340    
;;;341    			if (ulPllLockCnt > PLL_RECOVERY_CNT)
0001ce  428a              CMP      r2,r1
0001d0  d20b              BCS      |L1.490|
;;;342    			{
;;;343    				SCRB->PLL_CFG.tBit.rsel = vucRselValue[ucRselIdx++];		//	rsel update
0001d2  f813c000          LDRB     r12,[r3,r0]
0001d6  1c40              ADDS     r0,r0,#1
0001d8  6fa1              LDR      r1,[r4,#0x78]
0001da  b2c0              UXTB     r0,r0
0001dc  f36c3190          BFI      r1,r12,#14,#3
0001e0  67a1              STR      r1,[r4,#0x78]
;;;344    				ulPllLockCnt = 0;
0001e2  2100              MOVS     r1,#0
;;;345    
;;;346    				if (ucRselIdx >= PLL_RSEL_MAX)
0001e4  2805              CMP      r0,#5
;;;347    					ucRselIdx = 0;
0001e6  bf28              IT       CS
0001e8  2000              MOVCS    r0,#0
                  |L1.490|
0001ea  f8d4c07c          LDR      r12,[r4,#0x7c]        ;337
0001ee  f1bc0f00          CMP      r12,#0                ;337
0001f2  d0eb              BEQ      |L1.460|
                  |L1.500|
;;;348    			}
;;;349    		}
;;;350    
;;;351    		/*
;;;352    		 * Change PLL clock
;;;353    		 */
;;;354    		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 1;//1;//0;		// PLL clock divider. PLLCLK/(pllclkdiv+1)
0001f4  6e20              LDR      r0,[r4,#0x60]
0001f6  f020003c          BIC      r0,r0,#0x3c
0001fa  1d00              ADDS     r0,r0,#4
0001fc  6620              STR      r0,[r4,#0x60]
;;;355    		SCRB->SYS_MAINCLK_CFG.tBit.usbclkdiv = 4;		// USB480 clock divider. 480MHz/(usbclkdiv+1)
0001fe  6e20              LDR      r0,[r4,#0x60]
000200  f4207070          BIC      r0,r0,#0x3c0
000204  f5007080          ADD      r0,r0,#0x100
000208  6620              STR      r0,[r4,#0x60]
;;;356    		SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
00020a  6e20              LDR      r0,[r4,#0x60]
00020c  f0200002          BIC      r0,r0,#2
000210  6620              STR      r0,[r4,#0x60]
;;;357    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	// 0: INT OSC 1: PLL/USB clock
000212  6e20              LDR      r0,[r4,#0x60]
000214  f0200001          BIC      r0,r0,#1
000218  6620              STR      r0,[r4,#0x60]
;;;358    #endif /* USED_SPI_NBIT_TRANSMODE */
;;;359    	}
;;;360    
;;;361    	{
;;;362    		/*
;;;363    		 * SSCG control : SSCG input range - 40MHz~50MHz
;;;364    		 */
;;;365    #if ((USED_ROIC_DEF == ROIC_SW98500) || (USED_ROIC_DEF == ROIC_SW98502))
;;;366    	#if USED_SPI_NBIT_TRANSMODE
;;;367    		#if USED_SW98502_MSPI_16MHz
;;;368    			#if (SPI_TRANSFER_BIT_NUM == 10) // SPI 18MHz
;;;369    				SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 2;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;370    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 5;//7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;371    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;372    			#elif (SPI_TRANSFER_BIT_NUM == 11) // SPI 20MHz
;;;373    				SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 2;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;374    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;375    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;//1;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;376    			#elif (SPI_TRANSFER_BIT_NUM == 12) // SPI 18MHz
;;;377    				SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 3;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;378    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 9;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;379    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;//1;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;380    			#endif
;;;381    		#else
;;;382    			#if (SPI_TRANSFER_BIT_NUM == 10) // SPI 18MHz
;;;383    				SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 2;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;384    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 5;//7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;385    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;386    			#elif (SPI_TRANSFER_BIT_NUM == 11) // SPI 20MHz
;;;387    				SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 2;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;388    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;389    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;//1;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;390    			#elif (SPI_TRANSFER_BIT_NUM == 12) // SPI 18MHz
;;;391    				SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 2;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;392    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;393    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;//1;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;394    			#endif
;;;395    		#endif
;;;396    		SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
;;;397    
;;;398    		#if (SPI_TRANSFER_BIT_NUM == 12) // SPI 18MHz
;;;399    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 0;	// SSCG power on
;;;400    		#else
;;;401    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 0;	// SSCG power on
;;;402    		#endif
;;;403    		medium_delay(300);						// You need stable time
;;;404    
;;;405    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
;;;406    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
;;;407    //		#if (SPI_TRANSFER_BIT_NUM == 12) // SPI 18MHz
;;;408    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 0;	// SSCG operation start
;;;409    //		#else
;;;410    //		SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 0;	// SSCG operation start
;;;411    //		#endif
;;;412    
;;;413    		SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;414    		SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
;;;415    	#else /* USED_SPI_NBIT_TRANSMODE */
;;;416    		SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;417    		SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 9;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;418    		SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;419    		SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
;;;420    
;;;421    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
;;;422    		medium_delay(300);							// You need stable time
;;;423    
;;;424    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
;;;425    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
;;;426    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 1;		// SSCG operation start
;;;427    
;;;428    		SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;429    		SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
;;;430    	#endif /* USED_SPI_NBIT_TRANSMODE */
;;;431    #else /* ((USED_ROIC_DEF == ROIC_SW98500) || (USED_ROIC_DEF == ROIC_SW98502)) */
;;;432    		SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 3;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
00021a  6ea0              LDR      r0,[r4,#0x68]
00021c  f020001c          BIC      r0,r0,#0x1c
000220  300c              ADDS     r0,r0,#0xc
000222  66a0              STR      r0,[r4,#0x68]
;;;433    		SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 9;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
000224  6ea0              LDR      r0,[r4,#0x68]
000226  f42070f0          BIC      r0,r0,#0x1e0
00022a  f5007090          ADD      r0,r0,#0x120
00022e  66a0              STR      r0,[r4,#0x68]
;;;434    		SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
000230  6ea0              LDR      r0,[r4,#0x68]
000232  f0200001          BIC      r0,r0,#1
000236  66a0              STR      r0,[r4,#0x68]
;;;435    		SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
000238  6ea0              LDR      r0,[r4,#0x68]
00023a  f0200002          BIC      r0,r0,#2
00023e  66a0              STR      r0,[r4,#0x68]
;;;436    
;;;437    	#if (USED_ROIC_DEF == ROIC_SW97500)
;;;438    		#if USED_SSCG_ON_OFF_CONTORL_AITnTLP_MODE
;;;439    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
;;;440    		#else
;;;441    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 0;	// SSCG power on
;;;442    		#endif
;;;443    	#else
;;;444    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
000240  6ce0              LDR      r0,[r4,#0x4c]
000242  f0400002          ORR      r0,r0,#2
000246  64e0              STR      r0,[r4,#0x4c]
;;;445    	#endif
;;;446    		medium_delay(300);							// You need stable time
000248  f44f7096          MOV      r0,#0x12c
00024c  f7fffffe          BL       medium_delay
;;;447    
;;;448    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
000250  6d20              LDR      r0,[r4,#0x50]
000252  f4406040          ORR      r0,r0,#0xc00
000256  6520              STR      r0,[r4,#0x50]
;;;449    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
000258  6d20              LDR      r0,[r4,#0x50]
00025a  f44040e0          ORR      r0,r0,#0x7000
00025e  6520              STR      r0,[r4,#0x50]
;;;450    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 1;		// SSCG operation start
000260  6ce0              LDR      r0,[r4,#0x4c]
000262  f0400001          ORR      r0,r0,#1
000266  64e0              STR      r0,[r4,#0x4c]
;;;451    
;;;452    	#if (USED_ROIC_DEF == ROIC_SW97500)
;;;453    		SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;454    	#else
;;;455    		SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 1;	// SSCGCLK select. 0: no sscg, 1:sscg out
000268  6ea0              LDR      r0,[r4,#0x68]
00026a  f4407000          ORR      r0,r0,#0x200
00026e  66a0              STR      r0,[r4,#0x68]
;;;456    	#endif
;;;457    		SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
000270  6d20              LDR      r0,[r4,#0x50]
000272  f4403080          ORR      r0,r0,#0x10000
000276  6520              STR      r0,[r4,#0x50]
;;;458    #endif /* ((USED_ROIC_DEF == ROIC_SW98500) || (USED_ROIC_DEF == ROIC_SW98502)) */
;;;459    	}
;;;460    
;;;461    	{
;;;462    		/*
;;;463    		 * PWM clock control
;;;464    		 */
;;;465    #if USED_SPI_NBIT_TRANSMODE
;;;466    		SCRB->SYS_PWMCLK_CFG.tBit.pllclkdiv = 1;//0;	// PLLCLK_div. PLLCLK/(pllclkdiv+1)
;;;467    		SCRB->SYS_PWMCLK_CFG.tBit.usbclkdiv = 4;	// USBCLK480_div. 480MHz/(usbclkdiv+1) -> 96MHz input
;;;468    	#if (SPI_TRANSFER_BIT_NUM == 10)
;;;469    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 1;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;470    	#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;471    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 0;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;472    	#elif (SPI_TRANSFER_BIT_NUM == 12)
;;;473    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 0;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;474    	#endif
;;;475    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv = 0;//1;	// PWM source clock divider - TSYNC sync. pre-PWMCLK/(pwmclkdiv+1) -> 96MHz
;;;476    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_num = 3;//1;	// PWMDRV_CLK - PWM/ECLK generation clock divide. pre-PWMLCK/(pwmclkdiv_num+1), 3: 12Mhz
;;;477    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclk_phase_en = 0;// ECLK to TSYNC sync enable
;;;478    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 1;	// PWMDRV_CLK - PWM/ECLK generation clock enable. -> 48MHz
;;;479    		SCRB->SYS_CLK_CTL.tBit.pwmclk_en = 1;	// PWMCLK on
;;;480    #else /* USED_SPI_NBIT_TRANSMODE */
;;;481    		SCRB->SYS_PWMCLK_CFG.tBit.pllclkdiv = 1;//0;	// PLLCLK_div. PLLCLK/(pllclkdiv+1)
000278  6e60              LDR      r0,[r4,#0x64]
00027a  f02000f0          BIC      r0,r0,#0xf0
00027e  3010              ADDS     r0,r0,#0x10
000280  6660              STR      r0,[r4,#0x64]
;;;482    		SCRB->SYS_PWMCLK_CFG.tBit.usbclkdiv = 4;	// USBCLK480_div. 480MHz/(usbclkdiv+1) -> 96MHz input
000282  6e60              LDR      r0,[r4,#0x64]
000284  f4206070          BIC      r0,r0,#0xf00
000288  f5006080          ADD      r0,r0,#0x400
00028c  6660              STR      r0,[r4,#0x64]
;;;483    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 0;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
00028e  6e60              LDR      r0,[r4,#0x64]
000290  f0200001          BIC      r0,r0,#1
000294  6660              STR      r0,[r4,#0x64]
;;;484    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv = 0;//1;	// PWM source clock divider - TSYNC sync. pre-PWMCLK/(pwmclkdiv+1) -> 96MHz
000296  6e60              LDR      r0,[r4,#0x64]
000298  f020000e          BIC      r0,r0,#0xe
00029c  6660              STR      r0,[r4,#0x64]
;;;485    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_num = 3;//1;	// PWMDRV_CLK - PWM/ECLK generation clock divide. pre-PWMLCK/(pwmclkdiv_num+1), 3: 12Mhz
00029e  6e60              LDR      r0,[r4,#0x64]
0002a0  f4204060          BIC      r0,r0,#0xe000
0002a4  f50040c0          ADD      r0,r0,#0x6000
0002a8  6660              STR      r0,[r4,#0x64]
;;;486    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclk_phase_en = 0;// ECLK to TSYNC sync enable
0002aa  6e60              LDR      r0,[r4,#0x64]
0002ac  f4203080          BIC      r0,r0,#0x10000
0002b0  6660              STR      r0,[r4,#0x64]
;;;487    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 1;	// PWMDRV_CLK - PWM/ECLK generation clock enable. -> 48MHz
0002b2  6e60              LDR      r0,[r4,#0x64]
0002b4  f4405080          ORR      r0,r0,#0x1000
0002b8  6660              STR      r0,[r4,#0x64]
;;;488    		SCRB->SYS_CLK_CTL.tBit.pwmclk_en = 1;	// PWMCLK on
0002ba  68a0              LDR      r0,[r4,#8]
0002bc  f4406080          ORR      r0,r0,#0x400
0002c0  60a0              STR      r0,[r4,#8]
;;;489    #endif /* USED_SPI_NBIT_TRANSMODE */
;;;490    	}
;;;491    
;;;492    	{
;;;493    		/*
;;;494    		 * Clock Enable
;;;495    		 */
;;;496    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		// 1: PLL clk enable
0002c2  6e20              LDR      r0,[r4,#0x60]
0002c4  f0400001          ORR      r0,r0,#1
0002c8  6620              STR      r0,[r4,#0x60]
;;;497    	}
;;;498    
;;;499    	{
;;;500    		/*
;;;501    		 * VDDA(3.3V) BOD Power Down Function Enable
;;;502    		 * If VDDA level is down(3.3V -> 2.75V(R_VOD_VHLS Set Level (Default 2:2.719V)))), reset mcu
;;;503    		 */
;;;504    		SCRB->SYS_OSC_PD_CTL.tBit.R_BOD_PD_N = 1;
0002ca  6aa0              LDR      r0,[r4,#0x28]
0002cc  f0400004          ORR      r0,r0,#4
0002d0  62a0              STR      r0,[r4,#0x28]
;;;505    	}
;;;506    }
0002d2  b00c              ADD      sp,sp,#0x30
0002d4  bd70              POP      {r4-r6,pc}
                  |L1.726|
0002d6  2101              MOVS     r1,#1                 ;339
0002d8  f2403266          MOV      r2,#0x366             ;341
0002dc  466b              MOV      r3,sp                 ;313
0002de  e784              B        |L1.490|
;;;507    
                          ENDP

                  |L1.736|
                          DCD      0x40008000
                  |L1.740|
                          DCD      0x40002000
                  |L1.744|
                          DCD      0xe000ed24
                  |L1.748|
                          DCD      0xe000ed10
                  |L1.752|
0002f0  03020100          DCB      3,2,1,0
0002f4  0400              DCB      4,0
0002f6  00                DCB      0
0002f7  00                DCB      0

                          AREA ||i.SCRB_PLL_Clock_Off||, CODE, READONLY, ALIGN=1

                  SCRB_PLL_Clock_Off PROC
;;;507    
;;;508    void SCRB_PLL_Clock_Off(bool_t bUsedSystemClk)
000000  b538              PUSH     {r3-r5,lr}
;;;509    {
;;;510    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;		//	main system clk: 12MHz, default: 0
000002  f04f4480          MOV      r4,#0x40000000
000006  4605              MOV      r5,r0                 ;509
000008  6e20              LDR      r0,[r4,#0x60]
00000a  f0200001          BIC      r0,r0,#1
00000e  6620              STR      r0,[r4,#0x60]
;;;511    	delay_usec(1);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       delay_us
;;;512    //	SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;513    //	SCRB->SSCG_PD_CTL.ulBulk = 0x0;
;;;514    
;;;515    #ifdef MODE_I2C
;;;516    	if(bUsedSystemClk == NO)
000016  b95d              CBNZ     r5,|L2.48|
;;;517    	{
;;;518    		/*
;;;519    		 * I2C는 24M이상에서만 동작 하는 것을 확인
;;;520    		 * (7+1)8분주 적용 하여 192/8=24M로 구동시켜 야만 I2C동작함. 그 이하는 동작 하지 않음
;;;521    		 */
;;;522    		/*
;;;523    		 * USB는 30M이상에서만 동작 하는 것을 확인
;;;524    		 * (5+1)6분주 적용 하여 192/6=32M로 구동시켜 야만 USB동작함. 그 이하는 동작 하지 않음
;;;525    		 */
;;;526    		/*
;;;527    		 * Dell Set에서 HID over I2C의 경우, 64M이상에서만 동작 하는 것을 확인
;;;528    		 * (2+1)6분주 적용 하여 192/3=64M로 구동시켜 야만 HID over I2C동작함. 그 이하는 동작 하지 않음
;;;529    		 * Set Shurt down시 VDD가 Off된 후 Host로 부터 Touch개수가 몇개인지에 대한 응답을 하기 위해서는 이 이상 구동이 필요함.
;;;530    		 */
;;;531    		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 2;//5;
000018  6e20              LDR      r0,[r4,#0x60]
00001a  f020003c          BIC      r0,r0,#0x3c
00001e  3008              ADDS     r0,r0,#8
000020  6620              STR      r0,[r4,#0x60]
;;;532    		delay_usec(1);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       delay_us
;;;533    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		//	main system clk: 12MHz, default: 0
000028  6e20              LDR      r0,[r4,#0x60]
00002a  f0400001          ORR      r0,r0,#1
00002e  6620              STR      r0,[r4,#0x60]
                  |L2.48|
;;;534    	}
;;;535    #else /* MODE_I2C */
;;;536    	#if USED_VTSP_ONLY_HOST_INTERFACE_OFF
;;;537    	{
;;;538    		/*
;;;539    		 * USB and X-tal Oscillator Off
;;;540    		 */
;;;541    		NVIC_ClearPendingIRQ(USB_IRQn);
;;;542    		SCRB->USB_INTR_CLR.ulBulk = 0x7; // USB CM3 Internal Interrupt clear!!
;;;543    		NVIC_DisableIRQ (USB_IRQn);
;;;544    		SCRB->USB_PHY_FC.tBit.extctrl_suspendm = 0;
;;;545    		SCRB->USB_PHY_FC.tBit.ponrst = 0;
;;;546    		SCRB->USB_PHY_FC.tBit.oscouten = 0;
;;;547    	}
;;;548    	#else /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;549    	{
;;;550    		/*
;;;551    		 * USB는 30M이상에서만 동작 하는 것을 확인
;;;552    		 * (5+1)6분주 적용 하여 192/6=32M로 구동시켜 야만 USB동작함. 그 이하는 동작 하지 않음
;;;553    		 */
;;;554    		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 5;
;;;555    		delay_usec(1);
;;;556    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		//	main system clk: 12MHz, default: 0
;;;557    	}
;;;558    	#endif /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;559    
;;;560    #endif /* MODE_I2C */
;;;561    	tSYS_CLK_CTL _SYS_CLK_CTL;
;;;562    	_SYS_CLK_CTL.tBit.wdtclk_en = YES;
;;;563    	_SYS_CLK_CTL.tBit.timclk0_en = YES;
;;;564    	_SYS_CLK_CTL.tBit.timclk1_en = NO;
;;;565    	_SYS_CLK_CTL.tBit.timclk2_en = NO;
;;;566    	_SYS_CLK_CTL.tBit.timclk3_en = NO;
;;;567    	_SYS_CLK_CTL.tBit.i2cclk_en = YES;
;;;568    	_SYS_CLK_CTL.tBit.dspaclk_en = NO;
;;;569    	_SYS_CLK_CTL.tBit.tdspclk_en = NO;
;;;570    #ifdef MODE_I2C
;;;571    	_SYS_CLK_CTL.tBit.usbcclk_en = NO;
;;;572    	_SYS_CLK_CTL.tBit.usbhclk_en = NO;
;;;573    #else /* MODE_I2C */
;;;574    	#if USED_VTSP_ONLY_HOST_INTERFACE_OFF
;;;575    		_SYS_CLK_CTL.tBit.usbcclk_en = NO;
;;;576    		_SYS_CLK_CTL.tBit.usbhclk_en = NO;
;;;577    	#else /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;578    		_SYS_CLK_CTL.tBit.usbcclk_en = YES;
;;;579    		_SYS_CLK_CTL.tBit.usbhclk_en = YES;
;;;580    	#endif /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;581    #endif /* MODE_I2C */
;;;582    	_SYS_CLK_CTL.tBit.pwmclk_en = NO;
;;;583    	_SYS_CLK_CTL.tBit.mspiclk_en = NO;
;;;584    	_SYS_CLK_CTL.tBit.sscgclk_en = NO;
;;;585    	_SYS_CLK_CTL.tBit.mpiclk_en = NO;
000030  9800              LDR      r0,[sp,#0]
000032  f4207077          BIC      r0,r0,#0x3dc
000036  f42040f8          BIC      r0,r0,#0x7c00
;;;586    	_SYS_CLK_CTL.tBit.tlvclk_en = NO;
;;;587    
;;;588    #if USED_VTSP_ONLY_HOST_INTERFACE_OFF
;;;589    	_SYS_CLK_CTL.tBit.i2cm0clk_en = NO;
;;;590    	_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = NO;
;;;591    	_SYS_CLK_CTL.tBit.i2cm1clk_en = NO;
;;;592    	_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = NO;
;;;593    #else /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;594    	_SYS_CLK_CTL.tBit.i2cm0clk_en = YES;
;;;595    	_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = YES;
;;;596    	_SYS_CLK_CTL.tBit.i2cm1clk_en = YES;
;;;597    	_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = YES;
00003a  f4202000          BIC      r0,r0,#0x80000
;;;598    #endif /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;599    	_SYS_CLK_CTL.tBit.osc_deglitch_en = NO;
00003e  f0400023          ORR      r0,r0,#0x23
000042  f44020f0          ORR      r0,r0,#0x78000
;;;600    	SCRB->SYS_CLK_CTL.ulBulk = _SYS_CLK_CTL.ulBulk;
000046  9000              STR      r0,[sp,#0]
000048  9800              LDR      r0,[sp,#0]
00004a  60a0              STR      r0,[r4,#8]
;;;601    
;;;602    }
00004c  bd38              POP      {r3-r5,pc}
;;;603    
                          ENDP


                          AREA ||i.SCRB_PLL_Clock_On||, CODE, READONLY, ALIGN=1

                  SCRB_PLL_Clock_On PROC
;;;603    
;;;604    void SCRB_PLL_Clock_On(void)
000000  b538              PUSH     {r3-r5,lr}
;;;605    {
;;;606    #if USED_VTSP_ONLY_HOST_INTERFACE_OFF
;;;607    	Hal_WDT_ForceReset();
;;;608    #else /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;609    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;		//	main system clk: 12MHz, default: 0
000002  f04f4480          MOV      r4,#0x40000000
000006  6e20              LDR      r0,[r4,#0x60]
000008  f0200001          BIC      r0,r0,#1
00000c  6620              STR      r0,[r4,#0x60]
;;;610    	delay_usec(1);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       delay_us
;;;611    	SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 1;
000014  6e20              LDR      r0,[r4,#0x60]
000016  f020003c          BIC      r0,r0,#0x3c
00001a  1d00              ADDS     r0,r0,#4
00001c  6620              STR      r0,[r4,#0x60]
;;;612    	delay_usec(1);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       delay_us
;;;613    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		//	main system clk: 12MHz, default: 0
000024  6e20              LDR      r0,[r4,#0x60]
000026  f0400001          ORR      r0,r0,#1
00002a  6620              STR      r0,[r4,#0x60]
;;;614    	delay_usec(1);
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       delay_us
;;;615    #endif /* USED_VTSP_ONLY_HOST_INTERFACE_OFF */
;;;616    
;;;617    	tSYS_CLK_CTL _SYS_CLK_CTL;
;;;618    	_SYS_CLK_CTL.tBit.wdtclk_en = YES;
;;;619    	_SYS_CLK_CTL.tBit.timclk0_en = YES;
;;;620    	_SYS_CLK_CTL.tBit.timclk1_en = YES;
;;;621    	_SYS_CLK_CTL.tBit.timclk2_en = YES;
;;;622    	_SYS_CLK_CTL.tBit.timclk3_en = YES;
;;;623    	_SYS_CLK_CTL.tBit.i2cclk_en = YES;
;;;624    	_SYS_CLK_CTL.tBit.dspaclk_en = YES;
;;;625    	_SYS_CLK_CTL.tBit.tdspclk_en = YES;
;;;626    #ifdef MODE_I2C
;;;627    	_SYS_CLK_CTL.tBit.usbcclk_en = NO;
;;;628    	_SYS_CLK_CTL.tBit.usbhclk_en = NO;
;;;629    #else /* MODE_I2C */
;;;630    	_SYS_CLK_CTL.tBit.usbcclk_en = YES;
;;;631    	_SYS_CLK_CTL.tBit.usbhclk_en = YES;
;;;632    #endif /* MODE_I2C */
;;;633    	_SYS_CLK_CTL.tBit.pwmclk_en = YES;
;;;634    	_SYS_CLK_CTL.tBit.mspiclk_en = YES;
;;;635    	_SYS_CLK_CTL.tBit.sscgclk_en = YES;
;;;636    	_SYS_CLK_CTL.tBit.mpiclk_en = NO;
;;;637    	_SYS_CLK_CTL.tBit.tlvclk_en = NO;
;;;638    	_SYS_CLK_CTL.tBit.i2cm0clk_en = YES;
;;;639    	_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = YES;
;;;640    	_SYS_CLK_CTL.tBit.i2cm1clk_en = YES;
000032  9800              LDR      r0,[sp,#0]
000034  f42040c6          BIC      r0,r0,#0x6300
000038  f4202000          BIC      r0,r0,#0x80000
;;;641    	_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = YES;
00003c  f04000ff          ORR      r0,r0,#0xff
000040  f4403067          ORR      r0,r0,#0x39c00
;;;642    	_SYS_CLK_CTL.tBit.osc_deglitch_en = NO;
000044  f4402080          ORR      r0,r0,#0x40000
;;;643    	SCRB->SYS_CLK_CTL.ulBulk = _SYS_CLK_CTL.ulBulk;
000048  9000              STR      r0,[sp,#0]
00004a  9800              LDR      r0,[sp,#0]
00004c  60a0              STR      r0,[r4,#8]
;;;644    }
00004e  bd38              POP      {r3-r5,pc}
;;;645    
                          ENDP


                          AREA ||i.SCRB_Remap_And_Reset||, CODE, READONLY, ALIGN=1

                  SCRB_Remap_And_Reset PROC
;;;656    
;;;657    void SCRB_Remap_And_Reset(uint8_t _num)
000000  f04f4180          MOV      r1,#0x40000000
;;;658    {
;;;659    	SCRB->SYS_BUS_REMAP = _num;
000004  f8410fb4          STR      r0,[r1,#0xb4]!
;;;660    	SCRB->CM3_REMAP_RESET = 1;
000008  2001              MOVS     r0,#1
00000a  6088              STR      r0,[r1,#8]
;;;661    }
00000c  4770              BX       lr
;;;662    
                          ENDP


                          AREA ||i.SCRB_USB_Reset||, CODE, READONLY, ALIGN=1

                  SCRB_USB_Reset PROC
;;;645    
;;;646    void SCRB_USB_Reset(void)
000000  f04f4180          MOV      r1,#0x40000000
;;;647    {
;;;648    	SCRB->SYS_RST_CTL.tBit.usb_rst = 1;
000004  68c8              LDR      r0,[r1,#0xc]
000006  f0400020          ORR      r0,r0,#0x20
00000a  60c8              STR      r0,[r1,#0xc]
;;;649    	SCRB->USB_PHY_FC.tBit.ponrst = 0;
00000c  f8d100a8          LDR      r0,[r1,#0xa8]
000010  f0200010          BIC      r0,r0,#0x10
000014  f8c100a8          STR      r0,[r1,#0xa8]
;;;650    
;;;651    	for (int i=0; i<100; i++);
000018  2000              MOVS     r0,#0
                  |L5.26|
00001a  1c40              ADDS     r0,r0,#1
00001c  2864              CMP      r0,#0x64
00001e  dbfc              BLT      |L5.26|
;;;652    
;;;653    	SCRB->USB_PHY_FC.tBit.ponrst = 1;
000020  f8d100a8          LDR      r0,[r1,#0xa8]
000024  f0400010          ORR      r0,r0,#0x10
000028  f8c100a8          STR      r0,[r1,#0xa8]
;;;654    	SCRB->SYS_RST_CTL.tBit.usb_rst = 0;
00002c  68c8              LDR      r0,[r1,#0xc]
00002e  f0200020          BIC      r0,r0,#0x20
000032  60c8              STR      r0,[r1,#0xc]
;;;655    }
000034  4770              BX       lr
;;;656    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\scrb\\scrb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_scrb_c_5ffd5815____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___6_scrb_c_5ffd5815____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_scrb_c_5ffd5815____REVSH|
#line 402
|__asm___6_scrb_c_5ffd5815____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_scrb_c_5ffd5815____RRX|
#line 587
|__asm___6_scrb_c_5ffd5815____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
