; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\hal.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\hal.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\hal.crf ..\..\Hal\hal.c]
                          THUMB

                          AREA ||i.HAL_CheckBootInterfaceInfoOnSecurityRegion||, CODE, READONLY, ALIGN=2

                  HAL_CheckBootInterfaceInfoOnSecurityRegion PROC
;;;1492    */
;;;1493   void HAL_CheckBootInterfaceInfoOnSecurityRegion(void)
000000  b510              PUSH     {r4,lr}
;;;1494   {
;;;1495   	if(FLITF_EnsureBootInterfaceCodeFlashIntegrity() == NO)
000002  f7fffffe          BL       FLITF_EnsureBootInterfaceCodeFlashIntegrity
000006  2800              CMP      r0,#0
;;;1496   	{
;;;1497   		tSimpleBootFlashCtrlInfo_t * pSimpleBootFlashCtrlInfo = (tSimpleBootFlashCtrlInfo_t *)SRAM_SIMPLE_BOOT_CTRL_INFO_ADDR;
;;;1498   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceId.BOOT_VID = UNIQUE_VID;
;;;1499   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceId.BOOT_PID = UNIQUE_BOOT_PID;
;;;1500   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceInfo.BOOT_I2C_SLV_ADDR = I2C_ADDRESS;
;;;1501   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceInfo.APP_KBYTE_SIZE = FLASH_APPLICATION_KBYTE_SIZE;
;;;1502   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceInfo.BOOT_HID_DESCRIPTOR_ADR = HID_DESCRIPTOR_ADDRESS;
;;;1503   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.BOOT_INFO_WRITE_EN_CODE = EFLASH_BOOT_INFO_WRITE_EN_CODE;
;;;1504   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.CheckSum = FLITF_Calc32bitCheckSum((uint32_t *)&pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo, (EFLASH_VID_PID_I2CSLV_WORD_SIZE - 1));
;;;1505   
;;;1506   		pSimpleBootFlashCtrlInfo->ulFlashUpdateType = SIMPLE_BOOT_FLASH_UPDATE_HOST_INTERFACE;
;;;1507   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_VTRIM = SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_VTRIM;
;;;1508   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_ITRIM = SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_ITRIM;
;;;1509   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim2.R_LDO_TRIM = SCRB->SYS_ANA_TRIM.tBit.R_LDO_TRIM;
;;;1510   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VBGR_CTL = SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VBGR_CTL;
;;;1511   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_IREF_TRIM = SCRB->SYS_ANA_TRIM.tBit.R_MAIN_IREF_TRIM;
;;;1512   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VREF_TRIM = SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VREF_TRIM;
;;;1513   
;;;1514   		FLITF_FlashInformationRegionWriteOperation();
;;;1515   	}
;;;1516   }
000008  bf18              IT       NE
00000a  bd10              POPNE    {r4,pc}
00000c  4c20              LDR      r4,|L1.144|
00000e  f64210bd          MOV      r0,#0x29bd            ;1498
000012  2103              MOVS     r1,#3                 ;1504
000014  80a0              STRH     r0,[r4,#4]            ;1498
000016  f2477002          MOV      r0,#0x7702            ;1499
00001a  80e0              STRH     r0,[r4,#6]            ;1499
00001c  2009              MOVS     r0,#9                 ;1500
00001e  7220              STRB     r0,[r4,#8]            ;1500
000020  2074              MOVS     r0,#0x74              ;1501
000022  7260              STRB     r0,[r4,#9]            ;1501
000024  2001              MOVS     r0,#1                 ;1502
000026  8160              STRH     r0,[r4,#0xa]          ;1502
000028  481a              LDR      r0,|L1.148|
00002a  60e0              STR      r0,[r4,#0xc]          ;1503
00002c  1d20              ADDS     r0,r4,#4              ;1504
00002e  342e              ADDS     r4,r4,#0x2e           ;1504
000030  f7fffffe          BL       FLITF_Calc32bitCheckSum
000034  f8440c1e          STR      r0,[r4,#-0x1e]        ;1504
000038  f44f6070          MOV      r0,#0xf00             ;1506
00003c  f8440c2e          STR      r0,[r4,#-0x2e]        ;1506
000040  f04f4080          MOV      r0,#0x40000000        ;1507
000044  6ac1              LDR      r1,[r0,#0x2c]         ;1507
000046  7da2              LDRB     r2,[r4,#0x16]         ;1507
000048  f3610205          BFI      r2,r1,#0,#6           ;1507
00004c  75a2              STRB     r2,[r4,#0x16]         ;1507
00004e  6ac1              LDR      r1,[r0,#0x2c]         ;1508
000050  098a              LSRS     r2,r1,#6              ;1508
000052  8ae1              LDRH     r1,[r4,#0x16]         ;1508
000054  f3621188          BFI      r1,r2,#6,#3           ;1508
000058  82e1              STRH     r1,[r4,#0x16]         ;1508
00005a  6ac1              LDR      r1,[r0,#0x2c]         ;1509
00005c  0a4a              LSRS     r2,r1,#9              ;1509
00005e  7ea1              LDRB     r1,[r4,#0x1a]         ;1509
000060  f3620104          BFI      r1,r2,#0,#5           ;1509
000064  76a1              STRB     r1,[r4,#0x1a]         ;1509
000066  6ac1              LDR      r1,[r0,#0x2c]         ;1510
000068  0c0a              LSRS     r2,r1,#16             ;1510
00006a  7fa1              LDRB     r1,[r4,#0x1e]         ;1510
00006c  f3620102          BFI      r1,r2,#0,#3           ;1510
000070  6ac2              LDR      r2,[r0,#0x2c]         ;1511
000072  0cd2              LSRS     r2,r2,#19             ;1511
000074  f36201c7          BFI      r1,r2,#3,#5           ;1511
000078  77a1              STRB     r1,[r4,#0x1e]         ;1511
00007a  6ac0              LDR      r0,[r0,#0x2c]         ;1512
00007c  0e01              LSRS     r1,r0,#24             ;1512
00007e  7fe0              LDRB     r0,[r4,#0x1f]         ;1512
000080  f3610003          BFI      r0,r1,#0,#4           ;1512
000084  77e0              STRB     r0,[r4,#0x1f]         ;1512
000086  e8bd4010          POP      {r4,lr}               ;1514
00008a  f7ffbffe          B.W      FLITF_FlashInformationRegionWriteOperation
;;;1517   #if USED_LPWG_MCU_SLEEP
                          ENDP

00008e  0000              DCW      0x0000
                  |L1.144|
                          DCD      0x20010000
                  |L1.148|
                          DCD      0x4a4d4801

                          AREA ||i.HAL_CheckSensningModeChange||, CODE, READONLY, ALIGN=2

                  HAL_CheckSensningModeChange PROC
;;;978    
;;;979    bool_t HAL_CheckSensningModeChange(eSENSING_CHANGE_MODE_t mode)
000000  493e              LDR      r1,|L2.252|
;;;980    {
000002  b510              PUSH     {r4,lr}
000004  680a              LDR      r2,[r1,#0]  ; ptHalInfo
;;;981    	bool_t bIsModeChange = YES;
000006  2401              MOVS     r4,#1
000008  8851              LDRH     r1,[r2,#2]
;;;982    #if USED_S3_ALL_MUX_SHORT
;;;983    	const tModuleSRICCommonConf_t * pktmoduleSRICCommonConf;
;;;984    	pktmoduleSRICCommonConf = module_SRIC_GetCommonConfig();
;;;985    #endif /* USED_S3_ALL_MUX_SHORT */
;;;986    	eSENSING_MODE_t ePastSensingMode = HAL_GetSensingMode();
;;;987    
;;;988    	switch(mode)
00000a  280f              CMP      r0,#0xf
00000c  d273              BCS      |L2.246|
00000e  e8dff000          TBB      [pc,r0]
000012  7208              DCB      0x72,0x08
000014  1e1e1e39          DCB      0x1e,0x1e,0x1e,0x39
000018  50727272          DCB      0x50,0x72,0x72,0x72
00001c  72727269          DCB      0x72,0x72,0x72,0x69
000020  6d00              DCB      0x6d,0x00
;;;989    	{
;;;990    		case SM_CHANGE_IDLE_MODE:
;;;991    		{
;;;992    #if USED_IDLE_MODE_CONTROL
;;;993    			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
000022  f4115f80          TST      r1,#0x1000
000026  d067              BEQ      |L2.248|
;;;994    			{
;;;995    				PWMDRV_RegisterInit(SM_FINGER_ONLY_IDLE_MODE, NO);
000028  2100              MOVS     r1,#0
00002a  f44f5088          MOV      r0,#0x1100
00002e  f7fffffe          BL       PWMDRV_RegisterInit
;;;996    				PWMDRV_Cmd(ENABLE);
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       PWMDRV_Cmd
;;;997    				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_Full_To_FullIdle);
000038  200b              MOVS     r0,#0xb
00003a  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
00003e  492f              LDR      r1,|L2.252|
;;;998    	#if USED_IDLE_LOW_POWER
;;;999    				SCRB_Clock_Control(CLK_IDLE_CTRL);
;;;1000   	#endif /* USED_IDLE_LOW_POWER */
;;;1001   				HAL_SetSensingMode(SM_FINGER_ONLY_IDLE_MODE);
000040  f44f5088          MOV      r0,#0x1100
000044  6809              LDR      r1,[r1,#0]  ; ptHalInfo
000046  2900              CMP      r1,#0
000048  bf18              IT       NE
00004a  8048              STRHNE   r0,[r1,#2]
00004c  e054              B        |L2.248|
;;;1002   			}
;;;1003   #endif /* USED_IDLE_MODE_CONTROL */
;;;1004   #if USED_LOCAL_IDLE_MODE_CONTROL
;;;1005   			if(IS_FINGER_PEN_MODE(ePastSensingMode))
;;;1006   			{
;;;1007   				PWMDRV_RegisterInit(SM_FINGER_PEN_IDLE_MODE, NO);
;;;1008   				PWMDRV_Cmd(ENABLE);
;;;1009   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_Local_To_LocalIdle);
;;;1010   				HAL_SetSensingMode(SM_FINGER_PEN_IDLE_MODE);
;;;1011   			}
;;;1012   #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1013   			break;
;;;1014   		}
;;;1015   
;;;1016   #if USED_PEN_MODE_OPERATION
;;;1017   		case SM_CHANGE_LocalIdle_To_Local_MODE:
;;;1018   		case SM_FAST_CHANGE_LocalIdle_To_Local_MODE:
;;;1019   		{
;;;1020   			PWMDRV_RegisterInit(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE, NO);
;;;1021   			PWMDRV_Cmd(ENABLE);
;;;1022   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_LocalIdle_To_Local);
;;;1023   			HAL_SetSensingMode(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE);
;;;1024   //			_gT(_GPIO_TP_INTR);
;;;1025   			break;
;;;1026   		}
;;;1027   		case SM_CHANGE_LocalIdle_To_Full_MODE:
;;;1028   		case SM_FAST_CHANGE_LocalIdle_To_Full_MODE:
;;;1029   		{
;;;1030   			PWMDRV_RegisterInit(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE, NO);
;;;1031   			PWMDRV_Cmd(ENABLE);
;;;1032   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_LocalIdle_To_Full);
;;;1033   			HAL_SetSensingMode(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE);
;;;1034   //			_gT(_GPIO_TP_INTR);
;;;1035   			break;
;;;1036   		}
;;;1037   #else /* USED_PEN_MODE_OPERATION */
;;;1038   		case SM_CHANGE_ACTIVE_MODE:
;;;1039   #if USED_FAST_SWITCH_IDLE_TO_ACTIVE
;;;1040   		case SM_FAST_CHANGE_ACTIVE_MODE:
;;;1041   #endif /* USED_FAST_SWITCH_IDLE_TO_ACTIVE */
;;;1042   #if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
;;;1043   		case SM_CHANGE_FULLSCAN_IDLE_MODE:
;;;1044   #endif /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
;;;1045   		{
;;;1046   			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
00004e  f4115f80          TST      r1,#0x1000
000052  d051              BEQ      |L2.248|
;;;1047   			{
;;;1048   #if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
;;;1049   				if(mode == SM_CHANGE_FULLSCAN_IDLE_MODE)
000054  2804              CMP      r0,#4
000056  d012              BEQ      |L2.126|
;;;1050   				{
;;;1051   					PWMDRV_FullScanIdleModeSetting();
;;;1052   				}
;;;1053   				else
;;;1054   #endif /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
;;;1055   				{
;;;1056   					PWMDRV_RegisterInit(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE, NO);
000058  2100              MOVS     r1,#0
00005a  f2410003          MOV      r0,#0x1003
00005e  f7fffffe          BL       PWMDRV_RegisterInit
;;;1057   					PWMDRV_Cmd(ENABLE);
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       PWMDRV_Cmd
                  |L2.104|
;;;1058   				}
;;;1059   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FullIdle_To_Full);
000068  200d              MOVS     r0,#0xd
00006a  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
00006e  4823              LDR      r0,|L2.252|
;;;1060   	#if USED_IDLE_LOW_POWER
;;;1061   				SCRB_Clock_Control(CLK_NORMAL_CTRL);
;;;1062   	#endif /* USED_IDLE_LOW_POWER */
;;;1063   				HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
000070  f2410103          MOV      r1,#0x1003
000074  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000076  2800              CMP      r0,#0
000078  bf18              IT       NE
00007a  8041              STRHNE   r1,[r0,#2]
00007c  e03c              B        |L2.248|
                  |L2.126|
00007e  f7fffffe          BL       PWMDRV_FullScanIdleModeSetting
000082  e7f1              B        |L2.104|
;;;1064   			}
;;;1065   			break;
;;;1066   		}
;;;1067   #endif /* USED_PEN_MODE_OPERATION */
;;;1068   
;;;1069   #if USED_NOISE_HOPPING_FREQ
;;;1070   		case SM_CHANGE_ACTIVE_FRQ_MAIN_MODE:
;;;1071   		{
;;;1072   	#if USED_PEN_MODE_OPERATION
;;;1073   			if(IS_FINGER_PEN_MODE(ePastSensingMode))
;;;1074   			{
;;;1075   				PWMDRV_RegisterInit(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE, NO);
;;;1076   				PWMDRV_Cmd(ENABLE);
;;;1077   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_FreHopp_CHANGE_Main_Freq);
;;;1078   				HAL_SetSensingMode(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE);
;;;1079   			}
;;;1080   			else
;;;1081   			{
;;;1082   				PWMDRV_RegisterInit(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE, NO);
;;;1083   				PWMDRV_Cmd(ENABLE);
;;;1084   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_FreHopp_CHANGE_Main_Freq);
;;;1085   				HAL_SetSensingMode(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE);
;;;1086   			}
;;;1087   	#else /* USED_PEN_MODE_OPERATION */
;;;1088   			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
000084  f4115f80          TST      r1,#0x1000
000088  d011              BEQ      |L2.174|
;;;1089   			{
;;;1090   				PWMDRV_RegisterInit(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE, NO);
00008a  2100              MOVS     r1,#0
00008c  f2410003          MOV      r0,#0x1003
000090  f7fffffe          BL       PWMDRV_RegisterInit
;;;1091   				PWMDRV_Cmd(ENABLE);
000094  2001              MOVS     r0,#1
000096  f7fffffe          BL       PWMDRV_Cmd
;;;1092   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_FreHopp_CHANGE_Main_Freq);
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
0000a0  4816              LDR      r0,|L2.252|
;;;1093   				HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
0000a2  f2410103          MOV      r1,#0x1003
0000a6  6800              LDR      r0,[r0,#0]  ; ptHalInfo
0000a8  2800              CMP      r0,#0
0000aa  bf18              IT       NE
0000ac  8041              STRHNE   r1,[r0,#2]
                  |L2.174|
;;;1094   			}
;;;1095   	#endif /* USED_PEN_MODE_OPERATION */
;;;1096   			app_SetCurrentSelectFrequency(FREQ_MAIN);
0000ae  2001              MOVS     r0,#1
;;;1097   //			_gT(_GPIO_TP_INTR);
;;;1098   			break;
0000b0  e015              B        |L2.222|
;;;1099   		}
;;;1100   		case SM_CHANGE_ACTIVE_FRQ_HOP1_MODE:
;;;1101   		{
;;;1102   	#if USED_PEN_MODE_OPERATION
;;;1103   			if(IS_FINGER_PEN_MODE(ePastSensingMode))
;;;1104   			{
;;;1105   				PWMDRV_RegisterInit(SM_FINGER_PEN_ACTIVE_FRQ_HOP1_MODE, NO);
;;;1106   				PWMDRV_Cmd(ENABLE);
;;;1107   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_FreHopp_CHANGE_Hopp1_Freq);
;;;1108   				HAL_SetSensingMode(SM_FINGER_PEN_ACTIVE_FRQ_HOP1_MODE);
;;;1109   			}
;;;1110   			else
;;;1111   			{
;;;1112   				PWMDRV_RegisterInit(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP1_MODE, NO);
;;;1113   				PWMDRV_Cmd(ENABLE);
;;;1114   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_FreHopp_CHANGE_Hopp1_Freq);
;;;1115   				HAL_SetSensingMode(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP1_MODE);
;;;1116   			}
;;;1117   	#else /* USED_PEN_MODE_OPERATION */
;;;1118   			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
0000b2  f4115f80          TST      r1,#0x1000
0000b6  d011              BEQ      |L2.220|
;;;1119   			{
;;;1120   				PWMDRV_RegisterInit(SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE, NO);
0000b8  2100              MOVS     r1,#0
0000ba  f2410005          MOV      r0,#0x1005
0000be  f7fffffe          BL       PWMDRV_RegisterInit
;;;1121   				PWMDRV_Cmd(ENABLE);
0000c2  2001              MOVS     r0,#1
0000c4  f7fffffe          BL       PWMDRV_Cmd
;;;1122   				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_FreHopp_CHANGE_Hopp1_Freq);
0000c8  2011              MOVS     r0,#0x11
0000ca  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
0000ce  480b              LDR      r0,|L2.252|
;;;1123   				HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE);
0000d0  f2410105          MOV      r1,#0x1005
0000d4  6800              LDR      r0,[r0,#0]  ; ptHalInfo
0000d6  2800              CMP      r0,#0
0000d8  bf18              IT       NE
0000da  8041              STRHNE   r1,[r0,#2]
                  |L2.220|
;;;1124   			}
;;;1125   	#endif /* USED_PEN_MODE_OPERATION */
;;;1126   			app_SetCurrentSelectFrequency(FREQ_HOPP1);
0000dc  2002              MOVS     r0,#2
                  |L2.222|
0000de  f7fffffe          BL       app_SetCurrentSelectFrequency
0000e2  e009              B        |L2.248|
0000e4  7910              LDRB     r0,[r2,#4]            ;1096
;;;1127   //			_gT(_GPIO_TP_INTR);
;;;1128   			break;
;;;1129   		}
;;;1130   		//		case SM_CHANGE_ACTIVE_FRQ_HOP2_MODE:
;;;1131   		//		{
;;;1132   		//			break;
;;;1133   		//		}
;;;1134   #endif /* USED_NOISE_HOPPING_FREQ */
;;;1135   
;;;1136   #if USED_PEN_MODE_OPERATION
;;;1137   		case SM_CHAGNE_Full_To_Local_MODE:
;;;1138   		{
;;;1139   	#if USED_NOISE_HOPPING_FREQ
;;;1140   			eSENSING_MODE_t eChangeSeningMode;
;;;1141   			if(IS_ACTIVE_MODE_FRQ_MAIN(ePastSensingMode))
;;;1142   			{
;;;1143   				eChangeSeningMode = SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE;
;;;1144   			}
;;;1145   			else
;;;1146   			{
;;;1147   				eChangeSeningMode = SM_FINGER_PEN_ACTIVE_FRQ_HOP1_MODE;
;;;1148   			}
;;;1149   			PWMDRV_RegisterInit(eChangeSeningMode, NO);
;;;1150   			PWMDRV_Cmd(ENABLE);
;;;1151   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_Full_To_Local);
;;;1152   			HAL_SetSensingMode(eChangeSeningMode);
;;;1153   
;;;1154   	#else /* USED_NOISE_HOPPING_FREQ */
;;;1155   			PWMDRV_RegisterInit(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE, NO);
;;;1156   			PWMDRV_Cmd(ENABLE);
;;;1157   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_Full_To_Local);
;;;1158   			HAL_SetSensingMode(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE);
;;;1159   	#endif /* USED_NOISE_HOPPING_FREQ */
;;;1160   //			_gT(_GPIO_TP_INTR);
;;;1161   			break;
;;;1162   		}
;;;1163   		case SM_CHAGNE_Local_To_Full_MODE:
;;;1164   		{
;;;1165   	#if USED_NOISE_HOPPING_FREQ
;;;1166   			eSENSING_MODE_t eChangeSeningMode;
;;;1167   			if(IS_ACTIVE_MODE_FRQ_MAIN(ePastSensingMode))
;;;1168   			{
;;;1169   				eChangeSeningMode = SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE;
;;;1170   			}
;;;1171   			else
;;;1172   			{
;;;1173   				eChangeSeningMode = SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP1_MODE;
;;;1174   			}
;;;1175   			PWMDRV_RegisterInit(eChangeSeningMode, NO);
;;;1176   			PWMDRV_Cmd(ENABLE);
;;;1177   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_Local_To_Full);
;;;1178   			HAL_SetSensingMode(eChangeSeningMode);
;;;1179   
;;;1180   	#else /* USED_NOISE_HOPPING_FREQ */
;;;1181   			PWMDRV_RegisterInit(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE, NO);
;;;1182   			PWMDRV_Cmd(ENABLE);
;;;1183   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_Local_To_Full);
;;;1184   			HAL_SetSensingMode(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE);
;;;1185   	#endif /* USED_NOISE_HOPPING_FREQ */
;;;1186   //			_gT(_GPIO_TP_INTR);
;;;1187   			break;
;;;1188   		}
;;;1189   #endif /* USED_PEN_MODE_OPERATION */
;;;1190   
;;;1191   
;;;1192   
;;;1193   //		case SM_CHANGE_FINGER_PEN_MODE:
;;;1194   //#if USED_FAST_SWITCH_LOCAL_IDLE_TO_ACTIVE
;;;1195   //		case SM_FAST_CHANGE_FINGER_PEN_MODE:
;;;1196   //#endif /* USED_FAST_SWITCH_LOCAL_IDLE_TO_ACTIVE */
;;;1197   //		{
;;;1198   //			PWMDRV_RegisterInit(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE, NO);
;;;1199   //			PWMDRV_Cmd(ENABLE);
;;;1200   //			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FINGER_PEN_LOCAL_ACTIVE);
;;;1201   //			HAL_SetSensingMode(SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE);
;;;1202   //			break;
;;;1203   //		}
;;;1204   		case SM_CHANGE_DIAG_TEST:
;;;1205   		{
;;;1206   			SRIC_SetDiagTestOperationMode(HAL_GetDiagTestSensingChangeMode());
0000e6  f7fffffe          BL       SRIC_SetDiagTestOperationMode
;;;1207   			break;
0000ea  e005              B        |L2.248|
0000ec  7950              LDRB     r0,[r2,#5]
;;;1208   		}
;;;1209   		case SM_CHANGE_ROIC_REG_VAL:
;;;1210   		{
;;;1211   			SRIC_SetRuntimeChangeRegister(HAL_GetROICRegSetChangeMode());
0000ee  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
;;;1212   			break;
0000f2  e001              B        |L2.248|
0000f4  e7ff              B        |L2.246|
                  |L2.246|
;;;1213   		}
;;;1214   		case SM_CHANGE_COMPLETE:
;;;1215   		default:
;;;1216   		{
;;;1217   			bIsModeChange = NO;
0000f6  2400              MOVS     r4,#0
                  |L2.248|
;;;1218   			break;
;;;1219   		}
;;;1220   	}
;;;1221   
;;;1222   	return bIsModeChange;
0000f8  4620              MOV      r0,r4
;;;1223   }
0000fa  bd10              POP      {r4,pc}
;;;1224   
                          ENDP

                  |L2.252|
                          DCD      ||.data||

                          AREA ||i.HAL_ConfigInit||, CODE, READONLY, ALIGN=2

                  HAL_ConfigInit PROC
;;;865    
;;;866    void HAL_ConfigInit(bool_t bIsS3)
000000  4904              LDR      r1,|L3.20|
;;;867    {
;;;868    #if USED_PEN_MODE_OPERATION
;;;869    	#if IS_MULTI_PROTOCOL_OPERATION
;;;870    		tHalIntrHandle.ulLocalPenRowIdxSetByMspiIdxBitMask_MSPen = DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_MSPen;
;;;871    		tHalIntrHandle.ulLocalPenRowIdxSetByMspiIdxBitMask_AITPen = DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_AITPen;
;;;872    		tHalIntrHandle.ulLocalPenRowIdxSetByMspiIdxBitMask_WGPPen = DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_WGPPen;
;;;873    	#else
;;;874    		tHalIntrHandle.ulLocalPenRowIdxSetByMspiIdxBitMask[0] = DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Active;
;;;875    		tHalIntrHandle.ulLocalPenRowIdxSetByMspiIdxBitMask[1] = DEF_PEN_LOCAL_INDEX_SET_BIT_MASK_Idle;
;;;876    	#endif
;;;877    #if USED_INIT_PEN_MODE
;;;878    	ptHalInfo->eSensingMode = SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE;
;;;879    #else /* USED_INIT_PEN_MODE */
;;;880    	ptHalInfo->eSensingMode = SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE;
;;;881    #endif /* USED_INIT_PEN_MODE */
;;;882    #else /* USED_PEN_MODE_OPERATION */
;;;883    	if(bIsS3)
000002  2800              CMP      r0,#0
;;;884    	{
;;;885    		ptHalInfo->eSensingMode = SM_S3_ACTIVE_MODE;
000004  6809              LDR      r1,[r1,#0]
000006  bf14              ITE      NE
000008  f6400001          MOVNE    r0,#0x801
;;;886    	}
;;;887    	else
;;;888    	{
;;;889    		ptHalInfo->eSensingMode = SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE;
00000c  f2410003          MOVEQ    r0,#0x1003
000010  8048              STRH     r0,[r1,#2]            ;885
;;;890    	}
;;;891    #endif /* USED_PEN_MODE_OPERATION */
;;;892    
;;;893    #if ((IS_ROIC_DEF_SW92510 || IS_ROIC_DEF_SW92508 || IS_ROIC_DEF_SW92512) && USED_TPIC_MUXEN_ON_OFF_CONTROL)
;;;894    	tHalIntrHandle.ulMuxEnControlByTsyncIdxBitMask[MUXEN_STATUS_FULL] = DEF_TPIC_MUX_EN_SET_BIT_MASK_Full;
;;;895    	tHalIntrHandle.ulMuxEnControlByTsyncIdxBitMask[MUXEN_STATUS_LOCAL] = DEF_TPIC_MUX_EN_SET_BIT_MASK_Local;
;;;896    	tHalIntrHandle.ulMuxEnControlByTsyncIdxBitMask[MUXEN_STATUS_IDLE] = DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle;
;;;897    #endif /* ((IS_ROIC_DEF_SW92510 || IS_ROIC_DEF_SW92512) && USED_TPIC_MUXEN_ON_OFF_CONTROL) */
;;;898    
;;;899    #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;900    	tHalIntrHandle.ulPenEnControlByTsyncIdxBitMask[PENEN_STATUS_FULL] = DEF_TPIC_PEN_EN_SET_BIT_MASK_Full;
;;;901    	tHalIntrHandle.ulPenEnControlByTsyncIdxBitMask[PENEN_STATUS_LOCAL] = DEF_TPIC_PEN_EN_SET_BIT_MASK_Local;
;;;902    	tHalIntrHandle.ulPenEnControlByTsyncIdxBitMask[PENEN_STATUS_IDLE] = DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle;
;;;903    #endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;904    
;;;905    #if USED_ESD_RECOERY_DETECTION_ROIC_Abnoraml
;;;906    	tHalIntrHandle.bIsROICReg_ESDRecovery = NO;
;;;907    #endif /* USED_ESD_RECOERY_DETECTION_ROIC_Abnoraml */
;;;908    }
000012  4770              BX       lr
;;;909    
                          ENDP

                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.HAL_ECLK_Off||, CODE, READONLY, ALIGN=2

                  HAL_ECLK_Off PROC
;;;176    
;;;177    void HAL_ECLK_Off(void)
000000  4803              LDR      r0,|L4.16|
;;;178    {
;;;179    #if USED_ECLK_FRQ_ADJUST_CONTROL
;;;180    	/*
;;;181    	 * Not Implementation
;;;182    	 */
;;;183    	PWMDRV->ECLK_CR.tBit.div_num = ECLK_FRQ_ADJUST_DISPLAY_DIV;
000002  f8501f8c          LDR      r1,[r0,#0x8c]!
000006  f42171f8          BIC      r1,r1,#0x1f0
00000a  31b0              ADDS     r1,r1,#0xb0
00000c  6001              STR      r1,[r0,#0]
;;;184    #else /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;185    	tCP_ECLK_CR_t tCP_ECLK_CR_TMP;
;;;186    	tCP_ECLK_CR_TMP.ulBulk = PWMDRV->ECLK_CR.ulBulk;
;;;187    	tCP_ECLK_CR_TMP.tBit.eclk_en = DISABLE;
;;;188    	tCP_ECLK_CR_TMP.tBit.eclk_force_on = DISABLE;
;;;189    	PWMDRV->ECLK_CR.ulBulk = tCP_ECLK_CR_TMP.ulBulk;
;;;190    #endif /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;191    }
00000e  4770              BX       lr
;;;192    #endif /* USED_ECLK_ON_OFF_CONTROL */
                          ENDP

                  |L4.16|
                          DCD      0x40002000

                          AREA ||i.HAL_ECLK_On||, CODE, READONLY, ALIGN=2

                  HAL_ECLK_On PROC
;;;160    
;;;161    void HAL_ECLK_On(void)
000000  4803              LDR      r0,|L5.16|
;;;162    {
;;;163    #if USED_ECLK_FRQ_ADJUST_CONTROL
;;;164    	/*
;;;165    	 * Not Implementation
;;;166    	 */
;;;167    	PWMDRV->ECLK_CR.tBit.div_num = 0;
000002  f8501f8c          LDR      r1,[r0,#0x8c]!
000006  f42171f8          BIC      r1,r1,#0x1f0
00000a  6001              STR      r1,[r0,#0]
;;;168    #else /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;169    	tCP_ECLK_CR_t tCP_ECLK_CR_TMP;
;;;170    	tCP_ECLK_CR_TMP.ulBulk = PWMDRV->ECLK_CR.ulBulk;
;;;171    	tCP_ECLK_CR_TMP.tBit.eclk_en = DISABLE;
;;;172    	tCP_ECLK_CR_TMP.tBit.eclk_force_on = ENABLE;
;;;173    	PWMDRV->ECLK_CR.ulBulk = tCP_ECLK_CR_TMP.ulBulk;
;;;174    #endif /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;175    }
00000c  4770              BX       lr
;;;176    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40002000

                          AREA ||i.HAL_GetBaseImagePointer||, CODE, READONLY, ALIGN=2

                  HAL_GetBaseImagePointer PROC
;;;1224   
;;;1225   uint16_t * HAL_GetBaseImagePointer(eSENSING_MODE_t mode, eBaseImageType_t type)
000000  b570              PUSH     {r4-r6,lr}
;;;1226   {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;1227   	uint16_t * pImage = NULL;
000006  2500              MOVS     r5,#0
;;;1228   	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
000008  f7fffffe          BL       hal_Info_GetControlLocalFingerOPType
;;;1229   
;;;1230   #if USED_MNT_S3_MODE_FUNCTION
;;;1231   	if(IS_S3_MODE(mode))
;;;1232   	{
;;;1233   		pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;1234   	}
;;;1235   	else
;;;1236   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1237   	{
;;;1238   		if(IS_ACTIVE_MODE(mode))
00000c  f0140f01          TST      r4,#1
;;;1239   		{
;;;1240   			if(IS_ACTIVE_MODE_FRQ_HOP1(mode))
;;;1241   			{
;;;1242   				if(type == BASELINE_TYPE_FULL)
;;;1243   				{
;;;1244   					//pImage = HAL_GET_HOPP1_BASELINE_IMAGE_PTR();	// leegc
;;;1245   				}
;;;1246   				else
;;;1247   				{
;;;1248   	//				pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;1249   				}
;;;1250   			}
;;;1251   			else if(IS_ACTIVE_MODE_FRQ_HOP2(mode))
;;;1252   			{
;;;1253   				if(type == BASELINE_TYPE_FULL)
;;;1254   				{
;;;1255   					//pImage = HAL_GET_HOPP2_BASELINE_IMAGE_PTR();	// leegc
;;;1256   				}
;;;1257   				else
;;;1258   				{
;;;1259   	//				pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;1260   				}
;;;1261   			}
;;;1262   			else
;;;1263   			{
;;;1264   				if(type == BASELINE_TYPE_FULL)
;;;1265   				{
;;;1266   	#if IS_MULTI_PROTOCOL_OPERATION
;;;1267   					switch(eLocalFingerOPType)
;;;1268   					{
;;;1269   						case ACTIVEPEN_TYPE_LOCAL_MS:
;;;1270   						{
;;;1271   							pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;1272   							break;
;;;1273   						}
;;;1274   						case ACTIVEPEN_TYPE_LOCAL_WACOM:
;;;1275   						case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;1276   						{
;;;1277   		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;1278   							pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;1279   		#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;1280   							pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
;;;1281   		#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;1282   							break;
;;;1283   						}
;;;1284   					}
;;;1285   	#else
;;;1286   		#if IS_MSPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION
;;;1287   					pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;1288   		#else
;;;1289   					pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
;;;1290   		#endif
;;;1291   	#endif
;;;1292   				}
;;;1293   			}
;;;1294   		}
;;;1295   		else
;;;1296   		{
;;;1297   			pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
000010  bf02              ITTT     EQ
000012  4808              LDREQ    r0,|L6.52|
000014  f5003590          ADDEQ    r5,r0,#0x12000
000018  f5056549          ADDEQ    r5,r5,#0xc90
00001c  d007              BEQ      |L6.46|
00001e  f0140f04          TST      r4,#4                 ;1240
000022  bf04              ITT      EQ                    ;1251
000024  f0140f08          TSTEQ    r4,#8                 ;1251
000028  2e00              CMPEQ    r6,#0                 ;1264
00002a  d100              BNE      |L6.46|
00002c  4d02              LDR      r5,|L6.56|
                  |L6.46|
;;;1298   		}
;;;1299   	}
;;;1300   
;;;1301   	return pImage;
00002e  4628              MOV      r0,r5
;;;1302   }
000030  bd70              POP      {r4-r6,pc}
;;;1303   
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      FullSharedBuff
                  |L6.56|
                          DCD      FullSharedBuff+0x5940

                          AREA ||i.HAL_GetDiagTestSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_GetDiagTestSensingChangeMode PROC
;;;937    
;;;938    eDIAG_TEST_CHANGE_MODE_t HAL_GetDiagTestSensingChangeMode(void)
000000  4801              LDR      r0,|L7.8|
;;;939    {
;;;940    	return ptHalInfo->eDiagTestChangeMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7900              LDRB     r0,[r0,#4]
;;;941    }
000006  4770              BX       lr
;;;942    
                          ENDP

                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetECLKOnOffControl||, CODE, READONLY, ALIGN=2

                  HAL_GetECLKOnOffControl PROC
;;;143    
;;;144    bool_t HAL_GetECLKOnOffControl(void)
000000  4806              LDR      r0,|L8.28|
;;;145    {
;;;146    	if(ptHalInfo->bIsECLKOnOffStartCheckCnt < ECLK_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6881              LDR      r1,[r0,#8]
000006  2914              CMP      r1,#0x14
000008  d202              BCS      |L8.16|
;;;147    	{
;;;148    		ptHalInfo->bIsECLKOnOffStartCheckCnt++;
00000a  6881              LDR      r1,[r0,#8]
00000c  1c49              ADDS     r1,r1,#1
00000e  6081              STR      r1,[r0,#8]
                  |L8.16|
;;;149    	}
;;;150    
;;;151    	if(ptHalInfo->bIsECLKOnOffStartCheckCnt >= ECLK_ON_OFF_CONTROL_START_CNT_THD)
000010  6881              LDR      r1,[r0,#8]
000012  2914              CMP      r1,#0x14
;;;152    	{
;;;153    		return ptHalInfo->bIsECLKOnOffStart;
000014  bf2c              ITE      CS
000016  7980              LDRBCS   r0,[r0,#6]
;;;154    	}
;;;155    	else
;;;156    	{
;;;157    		return NO;
000018  2000              MOVCC    r0,#0
;;;158    	}
;;;159    }
00001a  4770              BX       lr
;;;160    
                          ENDP

                  |L8.28|
                          DCD      ||.data||

                          AREA ||i.HAL_GetHoppBaselineContinueEnControl||, CODE, READONLY, ALIGN=2

                  HAL_GetHoppBaselineContinueEnControl PROC
;;;390    
;;;391    bool_t HAL_GetHoppBaselineContinueEnControl(void)
000000  4806              LDR      r0,|L9.28|
;;;392    {
;;;393    	if(ptHalInfo->bIsHoppBaselineContinueOnOffStartCheckCnt < HOPP_BASELINE_CONTI_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6a01              LDR      r1,[r0,#0x20]
000006  2914              CMP      r1,#0x14
000008  d202              BCS      |L9.16|
;;;394    	{
;;;395    		ptHalInfo->bIsHoppBaselineContinueOnOffStartCheckCnt++;
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  1c49              ADDS     r1,r1,#1
00000e  6201              STR      r1,[r0,#0x20]
                  |L9.16|
;;;396    	}
;;;397    
;;;398    	if(ptHalInfo->bIsHoppBaselineContinueOnOffStartCheckCnt >= HOPP_BASELINE_CONTI_ON_OFF_CONTROL_START_CNT_THD)
000010  6a01              LDR      r1,[r0,#0x20]
000012  2914              CMP      r1,#0x14
;;;399    	{
;;;400    		return ptHalInfo->bIsHoppBaselineContinueOnOffStart;
000014  bf2c              ITE      CS
000016  7f00              LDRBCS   r0,[r0,#0x1c]
;;;401    	}
;;;402    	else
;;;403    	{
;;;404    		return NO;
000018  2000              MOVCC    r0,#0
;;;405    	}
;;;406    }
00001a  4770              BX       lr
;;;407    #endif /* USE_FREQ_HOPPING_BASELINE_CONTI_UPDATE */
                          ENDP

                  |L9.28|
                          DCD      ||.data||

                          AREA ||i.HAL_GetROICRegSetChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_GetROICRegSetChangeMode PROC
;;;956    
;;;957    eROIC_REG_SET_CHANGE_MODE_t HAL_GetROICRegSetChangeMode(void)
000000  4801              LDR      r0,|L10.8|
;;;958    {
;;;959    	return ptHalInfo->eROICRegSetChangeMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7940              LDRB     r0,[r0,#5]
;;;960    }
000006  4770              BX       lr
;;;961    
                          ENDP

                  |L10.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_GetSensingChangeMode PROC
;;;909    
;;;910    eSENSING_CHANGE_MODE_t HAL_GetSensingChangeMode(void)
000000  4801              LDR      r0,|L11.8|
;;;911    {
;;;912    	return ptHalInfo->eSensingChangeMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7800              LDRB     r0,[r0,#0]
;;;913    }
000006  4770              BX       lr
;;;914    
                          ENDP

                  |L11.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetSensingMode||, CODE, READONLY, ALIGN=2

                  HAL_GetSensingMode PROC
;;;926    
;;;927    eSENSING_MODE_t HAL_GetSensingMode(void)
000000  4801              LDR      r0,|L12.8|
;;;928    {
;;;929    	return ptHalInfo->eSensingMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  8840              LDRH     r0,[r0,#2]
;;;930    }
000006  4770              BX       lr
;;;931    
                          ENDP

                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTPICMuxEnControl||, CODE, READONLY, ALIGN=2

                  HAL_GetTPICMuxEnControl PROC
;;;221    
;;;222    bool_t HAL_GetTPICMuxEnControl(void)
000000  4806              LDR      r0,|L13.28|
;;;223    {
;;;224    	if(ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt < TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6901              LDR      r1,[r0,#0x10]
000006  2914              CMP      r1,#0x14
000008  d202              BCS      |L13.16|
;;;225    	{
;;;226    		ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt++;
00000a  6901              LDR      r1,[r0,#0x10]
00000c  1c49              ADDS     r1,r1,#1
00000e  6101              STR      r1,[r0,#0x10]
                  |L13.16|
;;;227    	}
;;;228    
;;;229    	if(ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt >= TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD)
000010  6901              LDR      r1,[r0,#0x10]
000012  2914              CMP      r1,#0x14
;;;230    	{
;;;231    		return ptHalInfo->bIsTPICMuxEnOnOffStart;
000014  bf2c              ITE      CS
000016  7b00              LDRBCS   r0,[r0,#0xc]
;;;232    	}
;;;233    	else
;;;234    	{
;;;235    		return NO;
000018  2000              MOVCC    r0,#0
;;;236    	}
;;;237    }
00001a  4770              BX       lr
;;;238    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
                          ENDP

                  |L13.28|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTouchReportEnControl||, CODE, READONLY, ALIGN=2

                  HAL_GetTouchReportEnControl PROC
;;;358    
;;;359    bool_t HAL_GetTouchReportEnControl(void)
000000  4806              LDR      r0,|L14.28|
;;;360    {
;;;361    	if(ptHalInfo->bIsTouchReportOnOffStartCheckCnt < TOUCH_REPORT_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6981              LDR      r1,[r0,#0x18]
000006  2914              CMP      r1,#0x14
000008  d202              BCS      |L14.16|
;;;362    	{
;;;363    		ptHalInfo->bIsTouchReportOnOffStartCheckCnt++;
00000a  6981              LDR      r1,[r0,#0x18]
00000c  1c49              ADDS     r1,r1,#1
00000e  6181              STR      r1,[r0,#0x18]
                  |L14.16|
;;;364    	}
;;;365    
;;;366    	if(ptHalInfo->bIsTouchReportOnOffStartCheckCnt >= TOUCH_REPORT_ON_OFF_CONTROL_START_CNT_THD)
000010  6981              LDR      r1,[r0,#0x18]
000012  2914              CMP      r1,#0x14
;;;367    	{
;;;368    		return ptHalInfo->bIsTouchReportOnOffStart;
000014  bf2c              ITE      CS
000016  7d00              LDRBCS   r0,[r0,#0x14]
;;;369    	}
;;;370    	else
;;;371    	{
;;;372    		return NO;
000018  2000              MOVCC    r0,#0
;;;373    	}
;;;374    }
00001a  4770              BX       lr
;;;375    #endif /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
                          ENDP

                  |L14.28|
                          DCD      ||.data||

                          AREA ||i.HAL_Initialize||, CODE, READONLY, ALIGN=2

                  HAL_Initialize PROC
;;;860     */
;;;861    void HAL_Initialize(void)
000000  b510              PUSH     {r4,lr}
;;;862    {
;;;863    	ptHalInfo = hal_GetInfo();
000002  f7fffffe          BL       hal_GetInfo
000006  4901              LDR      r1,|L15.12|
000008  6008              STR      r0,[r1,#0]  ; ptHalInfo
;;;864    }
00000a  bd10              POP      {r4,pc}
;;;865    
                          ENDP

                  |L15.12|
                          DCD      ||.data||

                          AREA ||i.HAL_SetDiagTestSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_SetDiagTestSensingChangeMode PROC
;;;942    
;;;943    void HAL_SetDiagTestSensingChangeMode(eDIAG_TEST_CHANGE_MODE_t mode)
000000  4909              LDR      r1,|L16.40|
000002  6809              LDR      r1,[r1,#0]
;;;944    {
000004  b158              CBZ      r0,|L16.30|
000006  798b              LDRB     r3,[r1,#6]
;;;945    #if USED_ECLK_ON_OFF_CONTROL
;;;946    	// Mode ????? EClk On/Off Control?? Disable????? ???.
;;;947    	if(mode != SM_CHANGE_COMPLETE)
;;;948    	{
;;;949    		HAL_SetECLKOnOffControl(NO);
000008  2200              MOVS     r2,#0
00000a  2b01              CMP      r3,#1
00000c  d106              BNE      |L16.28|
00000e  4b07              LDR      r3,|L16.44|
000010  f8d3c08c          LDR      r12,[r3,#0x8c]
000014  f42c7cf8          BIC      r12,r12,#0x1f0
000018  f8c3c08c          STR      r12,[r3,#0x8c]
                  |L16.28|
00001c  718a              STRB     r2,[r1,#6]
                  |L16.30|
;;;950    	}
;;;951    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;952    	ptHalInfo->eDiagTestChangeMode = mode;
00001e  7108              STRB     r0,[r1,#4]
;;;953    	ptHalInfo->eSensingChangeMode = SM_CHANGE_DIAG_TEST;
000020  200d              MOVS     r0,#0xd
000022  7008              STRB     r0,[r1,#0]
;;;954    }
000024  4770              BX       lr
;;;955    
                          ENDP

000026  0000              DCW      0x0000
                  |L16.40|
                          DCD      ||.data||
                  |L16.44|
                          DCD      0x40002000

                          AREA ||i.HAL_SetECLKOnOffControl||, CODE, READONLY, ALIGN=2

                  HAL_SetECLKOnOffControl PROC
;;;123    #if USED_ECLK_ON_OFF_CONTROL
;;;124    void HAL_SetECLKOnOffControl(bool_t bIsEn)
000000  4909              LDR      r1,|L17.40|
;;;125    {
;;;126    	if(bIsEn == NO)
;;;127    	{
;;;128    		if(ptHalInfo->bIsECLKOnOffStart == YES)
000002  6809              LDR      r1,[r1,#0]
;;;129    		{
;;;130    			HAL_ECLK_On();
;;;131    		}
;;;132    	}
;;;133    	else
;;;134    	{
;;;135    		if(ptHalInfo->bIsECLKOnOffStart == NO)
000004  798a              LDRB     r2,[r1,#6]
000006  b120              CBZ      r0,|L17.18|
000008  2a00              CMP      r2,#0
;;;136    		{
;;;137    			ptHalInfo->bIsECLKOnOffStartCheckCnt = 0;
00000a  bf04              ITT      EQ
00000c  2200              MOVEQ    r2,#0
00000e  608a              STREQ    r2,[r1,#8]
000010  e007              B        |L17.34|
                  |L17.18|
000012  2a01              CMP      r2,#1                 ;128
000014  d105              BNE      |L17.34|
000016  4a05              LDR      r2,|L17.44|
000018  f8523f8c          LDR      r3,[r2,#0x8c]!        ;128
00001c  f42373f8          BIC      r3,r3,#0x1f0          ;128
000020  6013              STR      r3,[r2,#0]            ;128
                  |L17.34|
;;;138    		}
;;;139    	}
;;;140    
;;;141    	ptHalInfo->bIsECLKOnOffStart = bIsEn;
000022  7188              STRB     r0,[r1,#6]
;;;142    }
000024  4770              BX       lr
;;;143    
                          ENDP

000026  0000              DCW      0x0000
                  |L17.40|
                          DCD      ||.data||
                  |L17.44|
                          DCD      0x40002000

                          AREA ||i.HAL_SetHoppBaselineContinueEnControl||, CODE, READONLY, ALIGN=2

                  HAL_SetHoppBaselineContinueEnControl PROC
;;;377    #if USE_FREQ_HOPPING_BASELINE_CONTI_UPDATE
;;;378    void HAL_SetHoppBaselineContinueEnControl(bool_t bIsEn)
000000  4904              LDR      r1,|L18.20|
;;;379    {
;;;380    	if(bIsEn == YES)
000002  2801              CMP      r0,#1
;;;381    	{
;;;382    		if(ptHalInfo->bIsHoppBaselineContinueOnOffStart == NO)
000004  6809              LDR      r1,[r1,#0]
000006  bf01              ITTTT    EQ
000008  7f0a              LDRBEQ   r2,[r1,#0x1c]
00000a  2a00              CMPEQ    r2,#0
;;;383    		{
;;;384    			ptHalInfo->bIsHoppBaselineContinueOnOffStartCheckCnt = 0;
00000c  2200              MOVEQ    r2,#0
00000e  620a              STREQ    r2,[r1,#0x20]
;;;385    		}
;;;386    	}
;;;387    
;;;388    	ptHalInfo->bIsHoppBaselineContinueOnOffStart = bIsEn;
000010  7708              STRB     r0,[r1,#0x1c]
;;;389    }
000012  4770              BX       lr
;;;390    
                          ENDP

                  |L18.20|
                          DCD      ||.data||

                          AREA ||i.HAL_SetROICRegSetChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_SetROICRegSetChangeMode PROC
;;;961    
;;;962    void HAL_SetROICRegSetChangeMode(eROIC_REG_SET_CHANGE_MODE_t mode)
000000  4909              LDR      r1,|L19.40|
000002  6809              LDR      r1,[r1,#0]
;;;963    {
000004  b158              CBZ      r0,|L19.30|
000006  798b              LDRB     r3,[r1,#6]
;;;964    #if USED_ECLK_ON_OFF_CONTROL
;;;965    	// ECLK on/off control is disable when change the mode.
;;;966    	if(mode != SM_CHANGE_COMPLETE)
;;;967    	{
;;;968    		HAL_SetECLKOnOffControl(NO);
000008  2200              MOVS     r2,#0
00000a  2b01              CMP      r3,#1
00000c  d106              BNE      |L19.28|
00000e  4b07              LDR      r3,|L19.44|
000010  f8d3c08c          LDR      r12,[r3,#0x8c]
000014  f42c7cf8          BIC      r12,r12,#0x1f0
000018  f8c3c08c          STR      r12,[r3,#0x8c]
                  |L19.28|
00001c  718a              STRB     r2,[r1,#6]
                  |L19.30|
;;;969    	}
;;;970    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;971    	ptHalInfo->eROICRegSetChangeMode = mode;
00001e  7148              STRB     r0,[r1,#5]
;;;972    	ptHalInfo->eSensingChangeMode = SM_CHANGE_ROIC_REG_VAL;
000020  200e              MOVS     r0,#0xe
000022  7008              STRB     r0,[r1,#0]
;;;973    }
000024  4770              BX       lr
;;;974    
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
                          DCD      ||.data||
                  |L19.44|
                          DCD      0x40002000

                          AREA ||i.HAL_SetSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_SetSensingChangeMode PROC
;;;914    
;;;915    void HAL_SetSensingChangeMode(eSENSING_CHANGE_MODE_t mode)
000000  4908              LDR      r1,|L20.36|
000002  6809              LDR      r1,[r1,#0]
;;;916    {
000004  b158              CBZ      r0,|L20.30|
000006  798b              LDRB     r3,[r1,#6]
;;;917    #if USED_ECLK_ON_OFF_CONTROL
;;;918    	// ECLK on/off control is disable, when change the mode.
;;;919    	if(mode != SM_CHANGE_COMPLETE)
;;;920    	{
;;;921    		HAL_SetECLKOnOffControl(NO);
000008  2200              MOVS     r2,#0
00000a  2b01              CMP      r3,#1
00000c  d106              BNE      |L20.28|
00000e  4b06              LDR      r3,|L20.40|
000010  f8d3c08c          LDR      r12,[r3,#0x8c]
000014  f42c7cf8          BIC      r12,r12,#0x1f0
000018  f8c3c08c          STR      r12,[r3,#0x8c]
                  |L20.28|
00001c  718a              STRB     r2,[r1,#6]
                  |L20.30|
;;;922    	}
;;;923    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;924    	ptHalInfo->eSensingChangeMode = mode;
00001e  7008              STRB     r0,[r1,#0]
;;;925    }
000020  4770              BX       lr
;;;926    
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      ||.data||
                  |L20.40|
                          DCD      0x40002000

                          AREA ||i.HAL_SetSensingMode||, CODE, READONLY, ALIGN=2

                  HAL_SetSensingMode PROC
;;;931    
;;;932    void HAL_SetSensingMode(eSENSING_MODE_t mode)
000000  4902              LDR      r1,|L21.12|
;;;933    {
;;;934    	if(ptHalInfo != NULL)
000002  6809              LDR      r1,[r1,#0]  ; ptHalInfo
000004  2900              CMP      r1,#0
;;;935    		ptHalInfo->eSensingMode = mode;
000006  bf18              IT       NE
000008  8048              STRHNE   r0,[r1,#2]
;;;936    }
00000a  4770              BX       lr
;;;937    
                          ENDP

                  |L21.12|
                          DCD      ||.data||

                          AREA ||i.HAL_SetTPICMuxEnControl||, CODE, READONLY, ALIGN=2

                  HAL_SetTPICMuxEnControl PROC
;;;194    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;195    void HAL_SetTPICMuxEnControl(bool_t bIsEn, bool_t bIsVCCOff)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
;;;197    	if(bIsEn == NO)
;;;198    	{
;;;199    		if(ptHalInfo->bIsTPICMuxEnOnOffStart == YES)
000002  4d0c              LDR      r5,|L22.52|
000004  0004              MOVS     r4,r0                 ;196
;;;200    		{
;;;201    			if(bIsVCCOff)
;;;202    			{
;;;203    				GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_LOW);
;;;204    			}
;;;205    			else
;;;206    			{
;;;207    				GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_HIGH);
;;;208    			}
;;;209    		}
;;;210    	}
;;;211    	else
;;;212    	{
;;;213    		if(ptHalInfo->bIsTPICMuxEnOnOffStart == NO)
000006  682a              LDR      r2,[r5,#0]
000008  7b10              LDRB     r0,[r2,#0xc]
00000a  d004              BEQ      |L22.22|
00000c  2800              CMP      r0,#0
;;;214    		{
;;;215    			ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt = 0;
00000e  bf04              ITT      EQ
000010  2000              MOVEQ    r0,#0
000012  6110              STREQ    r0,[r2,#0x10]
000014  e00b              B        |L22.46|
                  |L22.22|
000016  2801              CMP      r0,#1                 ;199
000018  d109              BNE      |L22.46|
00001a  b121              CBZ      r1,|L22.38|
00001c  2100              MOVS     r1,#0                 ;203
00001e  2025              MOVS     r0,#0x25              ;203
000020  f7fffffe          BL       GPIO_Set_DATA
000024  e003              B        |L22.46|
                  |L22.38|
000026  2101              MOVS     r1,#1                 ;207
000028  2025              MOVS     r0,#0x25              ;207
00002a  f7fffffe          BL       GPIO_Set_DATA
                  |L22.46|
;;;216    		}
;;;217    	}
;;;218    
;;;219    	ptHalInfo->bIsTPICMuxEnOnOffStart = bIsEn;
00002e  6828              LDR      r0,[r5,#0]  ; ptHalInfo
000030  7304              STRB     r4,[r0,#0xc]
;;;220    }
000032  bd70              POP      {r4-r6,pc}
;;;221    
                          ENDP

                  |L22.52|
                          DCD      ||.data||

                          AREA ||i.HAL_SetTouchReportEnControl||, CODE, READONLY, ALIGN=2

                  HAL_SetTouchReportEnControl PROC
;;;345    #if USED_TOUCH_REPORT_ON_OFF_CONTROL
;;;346    void HAL_SetTouchReportEnControl(bool_t bIsEn)
000000  4904              LDR      r1,|L23.20|
;;;347    {
;;;348    	if(bIsEn == YES)
000002  2801              CMP      r0,#1
;;;349    	{
;;;350    		if(ptHalInfo->bIsTouchReportOnOffStart == NO)
000004  6809              LDR      r1,[r1,#0]
000006  bf01              ITTTT    EQ
000008  7d0a              LDRBEQ   r2,[r1,#0x14]
00000a  2a00              CMPEQ    r2,#0
;;;351    		{
;;;352    			ptHalInfo->bIsTouchReportOnOffStartCheckCnt = 0;
00000c  2200              MOVEQ    r2,#0
00000e  618a              STREQ    r2,[r1,#0x18]
;;;353    		}
;;;354    	}
;;;355    
;;;356    	ptHalInfo->bIsTouchReportOnOffStart = bIsEn;
000010  7508              STRB     r0,[r1,#0x14]
;;;357    }
000012  4770              BX       lr
;;;358    
                          ENDP

                  |L23.20|
                          DCD      ||.data||

                          AREA ||i.Hal_VccOff_State||, CODE, READONLY, ALIGN=2

                  Hal_VccOff_State PROC
;;;574    
;;;575    void Hal_VccOff_State(void)
000000  4888              LDR      r0,|L24.548|
;;;576    {
000002  b510              PUSH     {r4,lr}
;;;577    	// ECLK OFF
;;;578    //	PWMDRV->ECLK_CR.tBit.eclk_en = DISABLE;
;;;579    	PWMDRV->ECLK_CR.tBit.eclk_force_on = DISABLE;
000004  f8501f8c          LDR      r1,[r0,#0x8c]!
000008  f4217100          BIC      r1,r1,#0x200
00000c  6001              STR      r1,[r0,#0]
;;;580    
;;;581    #if (!USED_DO_NOT_TOUCH_ONLY_DISPLAY)
;;;582    	GPIO_Init(_GPIO_TSYNC_OUT, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00000e  2300              MOVS     r3,#0
000010  461a              MOV      r2,r3
000012  2103              MOVS     r1,#3
000014  2032              MOVS     r0,#0x32
000016  f7fffffe          BL       GPIO_Init
;;;583    	GPIO_Init(_GPIO_TSYNC_IN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00001a  2300              MOVS     r3,#0
00001c  461a              MOV      r2,r3
00001e  2103              MOVS     r1,#3
000020  202e              MOVS     r0,#0x2e
000022  f7fffffe          BL       GPIO_Init
;;;584    #if USED_TSYNC2_INPUT_FROM_TCON
;;;585    	GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;586    #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;587    #endif /* (!USED_DO_NOT_TOUCH_ONLY_DISPLAY) */
;;;588    #if !(CUSTOMER == MODEL_DEF_FHD_92503S || \
;;;589    		CUSTOMER == MODEL_DEF_UHD_98502_WGP_Pen || \
;;;590    		(CUSTOMER == MODEL_DEF_UHD_92510_Souryu_Beatrice_Finger && USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S00) || \
;;;591    		(CUSTOMER == MODEL_DEF_UHD_92510_Souryu_Beatrice_Pen && USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S00))
;;;592    	GPIO_Init(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  2103              MOVS     r1,#3
00002c  2033              MOVS     r0,#0x33
00002e  f7fffffe          BL       GPIO_Init
;;;593    #endif
;;;594    	GPIO_Init(_GPIO_MUX_EN_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000032  2300              MOVS     r3,#0
000034  461a              MOV      r2,r3
000036  2103              MOVS     r1,#3
000038  2025              MOVS     r0,#0x25
00003a  f7fffffe          BL       GPIO_Init
;;;595    
;;;596    	//Vsync Pull-Down
;;;597    	GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00003e  2300              MOVS     r3,#0
000040  461a              MOV      r2,r3
000042  2103              MOVS     r1,#3
000044  202d              MOVS     r0,#0x2d
000046  f7fffffe          BL       GPIO_Init
;;;598    
;;;599    	//MSPI Pull-Down
;;;600    	GPIO_Init(_GPIO_MSPI_0_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00004a  2300              MOVS     r3,#0
00004c  461a              MOV      r2,r3
00004e  2103              MOVS     r1,#3
000050  200b              MOVS     r0,#0xb
000052  f7fffffe          BL       GPIO_Init
;;;601    	GPIO_Init(_GPIO_MSPI_0_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000056  2300              MOVS     r3,#0
000058  461a              MOV      r2,r3
00005a  2103              MOVS     r1,#3
00005c  200c              MOVS     r0,#0xc
00005e  f7fffffe          BL       GPIO_Init
;;;602    	GPIO_Init(_GPIO_MSPI_0_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000062  2300              MOVS     r3,#0
000064  461a              MOV      r2,r3
000066  2103              MOVS     r1,#3
000068  200d              MOVS     r0,#0xd
00006a  f7fffffe          BL       GPIO_Init
;;;603    	GPIO_Init(_GPIO_MSPI_0_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00006e  2300              MOVS     r3,#0
000070  461a              MOV      r2,r3
000072  2103              MOVS     r1,#3
000074  200e              MOVS     r0,#0xe
000076  f7fffffe          BL       GPIO_Init
;;;604    
;;;605    	GPIO_Init(_GPIO_MSPI_1_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00007a  2300              MOVS     r3,#0
00007c  461a              MOV      r2,r3
00007e  2103              MOVS     r1,#3
000080  200f              MOVS     r0,#0xf
000082  f7fffffe          BL       GPIO_Init
;;;606    	GPIO_Init(_GPIO_MSPI_1_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000086  2300              MOVS     r3,#0
000088  461a              MOV      r2,r3
00008a  2103              MOVS     r1,#3
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       GPIO_Init
;;;607    	GPIO_Init(_GPIO_MSPI_1_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000092  2300              MOVS     r3,#0
000094  461a              MOV      r2,r3
000096  2103              MOVS     r1,#3
000098  2011              MOVS     r0,#0x11
00009a  f7fffffe          BL       GPIO_Init
;;;608    	GPIO_Init(_GPIO_MSPI_1_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00009e  2300              MOVS     r3,#0
0000a0  461a              MOV      r2,r3
0000a2  2103              MOVS     r1,#3
0000a4  2012              MOVS     r0,#0x12
0000a6  f7fffffe          BL       GPIO_Init
;;;609    
;;;610    	GPIO_Init(_GPIO_MSPI_2_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000aa  2300              MOVS     r3,#0
0000ac  461a              MOV      r2,r3
0000ae  2103              MOVS     r1,#3
0000b0  2013              MOVS     r0,#0x13
0000b2  f7fffffe          BL       GPIO_Init
;;;611    	GPIO_Init(_GPIO_MSPI_2_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000b6  2300              MOVS     r3,#0
0000b8  461a              MOV      r2,r3
0000ba  2103              MOVS     r1,#3
0000bc  2014              MOVS     r0,#0x14
0000be  f7fffffe          BL       GPIO_Init
;;;612    	GPIO_Init(_GPIO_MSPI_2_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000c2  2300              MOVS     r3,#0
0000c4  461a              MOV      r2,r3
0000c6  2103              MOVS     r1,#3
0000c8  2015              MOVS     r0,#0x15
0000ca  f7fffffe          BL       GPIO_Init
;;;613    	GPIO_Init(_GPIO_MSPI_2_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000ce  2300              MOVS     r3,#0
0000d0  461a              MOV      r2,r3
0000d2  2103              MOVS     r1,#3
0000d4  2016              MOVS     r0,#0x16
0000d6  f7fffffe          BL       GPIO_Init
;;;614    
;;;615    	GPIO_Init(_GPIO_MSPI_3_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000da  2300              MOVS     r3,#0
0000dc  461a              MOV      r2,r3
0000de  2103              MOVS     r1,#3
0000e0  2017              MOVS     r0,#0x17
0000e2  f7fffffe          BL       GPIO_Init
;;;616    	GPIO_Init(_GPIO_MSPI_3_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000e6  2300              MOVS     r3,#0
0000e8  461a              MOV      r2,r3
0000ea  2103              MOVS     r1,#3
0000ec  2018              MOVS     r0,#0x18
0000ee  f7fffffe          BL       GPIO_Init
;;;617    	GPIO_Init(_GPIO_MSPI_3_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000f2  2300              MOVS     r3,#0
0000f4  461a              MOV      r2,r3
0000f6  2103              MOVS     r1,#3
0000f8  2019              MOVS     r0,#0x19
0000fa  f7fffffe          BL       GPIO_Init
;;;618    	GPIO_Init(_GPIO_MSPI_3_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000fe  2300              MOVS     r3,#0
000100  461a              MOV      r2,r3
000102  2103              MOVS     r1,#3
000104  201a              MOVS     r0,#0x1a
000106  f7fffffe          BL       GPIO_Init
;;;619    
;;;620    	GPIO_Init(_GPIO_MSPI_4_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00010a  2300              MOVS     r3,#0
00010c  461a              MOV      r2,r3
00010e  2103              MOVS     r1,#3
000110  201b              MOVS     r0,#0x1b
000112  f7fffffe          BL       GPIO_Init
;;;621    	GPIO_Init(_GPIO_MSPI_4_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000116  2300              MOVS     r3,#0
000118  461a              MOV      r2,r3
00011a  2103              MOVS     r1,#3
00011c  201c              MOVS     r0,#0x1c
00011e  f7fffffe          BL       GPIO_Init
;;;622    	GPIO_Init(_GPIO_MSPI_4_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000122  2300              MOVS     r3,#0
000124  461a              MOV      r2,r3
000126  2103              MOVS     r1,#3
000128  201d              MOVS     r0,#0x1d
00012a  f7fffffe          BL       GPIO_Init
;;;623    	GPIO_Init(_GPIO_MSPI_4_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00012e  2300              MOVS     r3,#0
000130  461a              MOV      r2,r3
000132  2103              MOVS     r1,#3
000134  201e              MOVS     r0,#0x1e
000136  f7fffffe          BL       GPIO_Init
;;;624    
;;;625    	GPIO_Init(_GPIO_MSPI_5_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00013a  2300              MOVS     r3,#0
00013c  461a              MOV      r2,r3
00013e  2103              MOVS     r1,#3
000140  201f              MOVS     r0,#0x1f
000142  f7fffffe          BL       GPIO_Init
;;;626    #if !USED_TPIC_PENEN_ON_OFF_CONTROL
;;;627    	GPIO_Init(_GPIO_MSPI_5_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000146  2300              MOVS     r3,#0
000148  461a              MOV      r2,r3
00014a  2103              MOVS     r1,#3
00014c  2020              MOVS     r0,#0x20
00014e  f7fffffe          BL       GPIO_Init
;;;628    #endif
;;;629    
;;;630    #if (USED_MODULE_DEF == MODULE_DEF_S_1)
;;;631    	#if (USED_PCB_PINMAP != SHARP_NBPC_PIN_TYPE_S01)
;;;632    		GPIO_Init(_GPIO_MSPI_5_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;633    	#endif /* (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01) */
;;;634    #elif (USED_MODULE_DEF == MODULE_DEF_A_1)
;;;635    	GPIO_Init(_GPIO_MSPI_5_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;636    #else /* (USED_MODULE_DEF == MODULE_DEF_S_1) */
;;;637    	GPIO_Init(_GPIO_MSPI_5_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000152  2300              MOVS     r3,#0
000154  461a              MOV      r2,r3
000156  2103              MOVS     r1,#3
000158  2021              MOVS     r0,#0x21
00015a  f7fffffe          BL       GPIO_Init
;;;638    #endif /* (USED_MODULE_DEF == MODULE_DEF_S_1) */
;;;639    	GPIO_Init(_GPIO_MSPI_5_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00015e  2300              MOVS     r3,#0
000160  461a              MOV      r2,r3
000162  2103              MOVS     r1,#3
000164  2022              MOVS     r0,#0x22
000166  f7fffffe          BL       GPIO_Init
;;;640    
;;;641    	GPIO_Init(_GPIO_MSPI_6_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00016a  2300              MOVS     r3,#0
00016c  461a              MOV      r2,r3
00016e  2103              MOVS     r1,#3
000170  2023              MOVS     r0,#0x23
000172  f7fffffe          BL       GPIO_Init
;;;642    	GPIO_Init(_GPIO_MSPI_6_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000176  2300              MOVS     r3,#0
000178  461a              MOV      r2,r3
00017a  2103              MOVS     r1,#3
00017c  2024              MOVS     r0,#0x24
00017e  f7fffffe          BL       GPIO_Init
;;;643    	#if ((!((USED_MODULE_DEF == MODULE_DEF_B_1) && (CUSTOMER == MODEL_DEF_FHD_97500_MNT_S3))) && (!USED_GPIO_MSPI_6_IS_MUX_EN)) && \
;;;644    		!((USED_MODULE_DEF == MODULE_DEF_T_1)) && \
;;;645    		!(USED_MODULE_DEF == MODULE_DEF_A_1) && \
;;;646    		!((USED_MODULE_DEF == MODULE_DEF_B_1) && ((CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP) || (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_MPP) || (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_SPLIT_MPP)))
;;;647    		GPIO_Init(_GPIO_MSPI_6_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;648    	#endif /* (!((USED_MODULE_DEF == MODULE_DEF_B_1) && (CUSTOMER == MODEL_DEF_FHD_97500_MNT_S3))) */
;;;649    	GPIO_Init(_GPIO_MSPI_6_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000182  2300              MOVS     r3,#0
000184  461a              MOV      r2,r3
000186  2103              MOVS     r1,#3
000188  2026              MOVS     r0,#0x26
00018a  f7fffffe          BL       GPIO_Init
;;;650    
;;;651    	GPIO_Init(_GPIO_MSPI_7_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00018e  2300              MOVS     r3,#0
000190  461a              MOV      r2,r3
000192  2103              MOVS     r1,#3
000194  2027              MOVS     r0,#0x27
000196  f7fffffe          BL       GPIO_Init
;;;652    	GPIO_Init(_GPIO_MSPI_7_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00019a  2300              MOVS     r3,#0
00019c  461a              MOV      r2,r3
00019e  2103              MOVS     r1,#3
0001a0  2028              MOVS     r0,#0x28
0001a2  f7fffffe          BL       GPIO_Init
;;;653    	#if !USED_PWM_GATE_CONTROL
;;;654    		GPIO_Init(_GPIO_MSPI_7_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001a6  2300              MOVS     r3,#0
0001a8  461a              MOV      r2,r3
0001aa  2103              MOVS     r1,#3
0001ac  2029              MOVS     r0,#0x29
0001ae  f7fffffe          BL       GPIO_Init
;;;655    	#endif
;;;656    	GPIO_Init(_GPIO_MSPI_7_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001b2  2300              MOVS     r3,#0
0001b4  461a              MOV      r2,r3
0001b6  2103              MOVS     r1,#3
0001b8  202a              MOVS     r0,#0x2a
0001ba  f7fffffe          BL       GPIO_Init
;;;657    
;;;658    	//TP EN -> GPIO -> Low
;;;659    #if (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3)
;;;660    	#if DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN
;;;661    		GPIO_Init(_GPIO_SLEEP_EN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;662    	#else /* DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN */
;;;663    		GPIO_Init(_GPIO_TP_EN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001be  2300              MOVS     r3,#0
0001c0  461a              MOV      r2,r3
0001c2  2103              MOVS     r1,#3
0001c4  2005              MOVS     r0,#5
0001c6  f7fffffe          BL       GPIO_Init
;;;664    	#endif /* DEF_TOUCH_SLEEP_CTRL_HOST_GPIO_TEST_TPEN */
;;;665    #endif /* (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3) */
;;;666    
;;;667    	//PWM Pull-Down
;;;668    	GPIO_Init(_GPIO_PWM_SRIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001ca  2300              MOVS     r3,#0
0001cc  461a              MOV      r2,r3
0001ce  2103              MOVS     r1,#3
0001d0  202f              MOVS     r0,#0x2f
0001d2  f7fffffe          BL       GPIO_Init
;;;669    	GPIO_Init(_GPIO_PWM_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001d6  2300              MOVS     r3,#0
0001d8  461a              MOV      r2,r3
0001da  2103              MOVS     r1,#3
0001dc  2030              MOVS     r0,#0x30
0001de  f7fffffe          BL       GPIO_Init
;;;670    #if USED_PWM_GATE_CONTROL
;;;671    	GPIO_Init(_GPIO_PWM_GATE, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;672    #endif /* USED_PWM_GATE_CONTROL */
;;;673    
;;;674    	//ECLK Pull-Down
;;;675    	GPIO_Init(_GPIO_ECLK_0, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001e2  2300              MOVS     r3,#0
0001e4  461a              MOV      r2,r3
0001e6  2103              MOVS     r1,#3
0001e8  202b              MOVS     r0,#0x2b
0001ea  f7fffffe          BL       GPIO_Init
;;;676    	GPIO_Init(_GPIO_ECLK_1, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001ee  2300              MOVS     r3,#0
0001f0  461a              MOV      r2,r3
0001f2  2103              MOVS     r1,#3
0001f4  202c              MOVS     r0,#0x2c
0001f6  f7fffffe          BL       GPIO_Init
;;;677    	GPIO_Init(_GPIO_TP_INTR, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
0001fa  2301              MOVS     r3,#1
0001fc  2200              MOVS     r2,#0
0001fe  2103              MOVS     r1,#3
000200  2004              MOVS     r0,#4
000202  f7fffffe          BL       GPIO_Init
;;;678    
;;;679    	//Reset SRIC
;;;680    	GPIO_Init(_GPIO_RSTN_SRIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000206  2300              MOVS     r3,#0
000208  461a              MOV      r2,r3
00020a  2103              MOVS     r1,#3
00020c  2034              MOVS     r0,#0x34
00020e  f7fffffe          BL       GPIO_Init
;;;681    
;;;682    	//Reset Uplink
;;;683    #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;684    	GPIO_Init(_GPIO_PEN_EN_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;685    #else
;;;686    	#if ((USED_MODULE_DEF == MODULE_DEF_S_1) && (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S02)) || \
;;;687    		((USED_MODULE_DEF == MODULE_DEF_B_1) && ((USED_PCB_PINMAP == BOE_HUANAN_NBPC_PIN_TYPE_R00) || BOE_LENOVO_16_NBPC_PIN_TYPE_R00))
;;;688    		GPIO_Init(_GPIO_PEN_EN_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000212  2300              MOVS     r3,#0
000214  2103              MOVS     r1,#3
000216  e8bd4010          POP      {r4,lr}
00021a  461a              MOV      r2,r3
00021c  2036              MOVS     r0,#0x36
00021e  f7ffbffe          B.W      GPIO_Init
;;;689    	#elif USED_MODULE_DEF == MODULE_DEF_A_1
;;;690    		GPIO_Init(_GPIO_PEN_EN_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;691    	#else /* ((USED_MODULE_DEF == MODULE_DEF_S_1) && (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S02)) */
;;;692    		GPIO_Init(_GPIO_Uplink_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;693    	#endif /* ((USED_MODULE_DEF == MODULE_DEF_S_1) && (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S02)) */
;;;694    #endif
;;;695    }
;;;696    
                          ENDP

000222  0000              DCW      0x0000
                  |L24.548|
                          DCD      0x40002000

                          AREA ||i.Hal_sric_start||, CODE, READONLY, ALIGN=2

                  Hal_sric_start PROC
;;;422    //#endif /* USED_TPIC_VCOM_LEVEL_I2CM_CONTROL */
;;;423    bool_t Hal_sric_start(bool_t cmuxoff)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;424    {
000004  4d36              LDR      r5,|L25.224|
000006  6828              LDR      r0,[r5,#0]  ; ptHalInfo
000008  8844              LDRH     r4,[r0,#2]
;;;425    	eSENSING_MODE_t eSensingMode;
;;;426    	eSensingMode = HAL_GetSensingMode();
;;;427    
;;;428    #if !USED_OPERATION_STAND_ALONE
;;;429    	if(!IS_S3_MODE(eSensingMode))
00000a  f4146f00          TST      r4,#0x800
00000e  d109              BNE      |L25.36|
                  |L25.16|
;;;430    	{
;;;431    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 0);
000010  202d              MOVS     r0,#0x2d
000012  f7fffffe          BL       GPIO_Get_IN
000016  2800              CMP      r0,#0
000018  d0fa              BEQ      |L25.16|
                  |L25.26|
;;;432    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 1);
00001a  202d              MOVS     r0,#0x2d
00001c  f7fffffe          BL       GPIO_Get_IN
000020  2801              CMP      r0,#1
000022  d0fa              BEQ      |L25.26|
                  |L25.36|
;;;433    	}
;;;434    #endif /* !USED_OPERATION_STAND_ALONE */
;;;435    
;;;436    	tHalIntrHandle.ulInitFirstFrame = 1;
000024  4f2f              LDR      r7,|L25.228|
000026  2001              MOVS     r0,#1
000028  62b8              STR      r0,[r7,#0x28]  ; tHalIntrHandle
;;;437    #if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
;;;438    	tHalIntrHandle.bIsIdlePWMRollback = NO;
00002a  2600              MOVS     r6,#0
00002c  f8876024          STRB     r6,[r7,#0x24]
;;;439    #endif
;;;440    
;;;441    //	while(1)
;;;442    //	{
;;;443    //		ulTPICSendData[0] = TPIC_VCOM_H_ADDR;
;;;444    //		ulTPICSendData[1] = (uint8_t)eTPIC_VCOM_H_Level;
;;;445    //		I2CM_SendByte(TPIC_CTRL_I2C_SLAVE_ADDR, &ulTPICSendData[0], 2);
;;;446    //		delay_usec(500);
;;;447    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VCOM_H_ADDR, &ulTPICRecvData[0], 1);
;;;448    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VCOM_L_ADDR, &ulTPICRecvData[1], 1);
;;;449    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VGL1_H_ADDR, &ulTPICRecvData[2], 1);
;;;450    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VGL2_H_ADDR, &ulTPICRecvData[3], 1);
;;;451    //
;;;452    //		delay_msec(10);
;;;453    //	}
;;;454    
;;;455    #if ((USED_PEN_PROTOCOL == PEN_PROTOCOL_WACOM_PEN) && USED_TPIC_VCOM_LEVEL_I2CM_CONTROL)
;;;456    	HAL_TPIC_UplinkModulation_LevelCtrl_Enable();
;;;457    #endif /* ((USED_PEN_PROTOCOL == PEN_PROTOCOL_WACOM_PEN) && USED_TPIC_VCOM_LEVEL_I2CM_CONTROL) */
;;;458    
;;;459    	PWMDRV_Init(eSensingMode);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       PWMDRV_Init
;;;460    
;;;461    	SRIC_Reset(eSensingMode);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       SRIC_Reset
;;;462    	delay_msec(10);
00003c  f2427010          MOV      r0,#0x2710
000040  f7fffffe          BL       delay_us
;;;463    	MSPI_Initialize();
000044  f7fffffe          BL       MSPI_Initialize
;;;464    
;;;465    	MSPI_Set_TLPMODE();
000048  f7fffffe          BL       MSPI_Set_TLPMODE
;;;466    
;;;467    #if USED_SRIC_REG_INIT_RETRY
;;;468    	{
;;;469    #define DEF_SRIC_RETRY_COUNT_THD			(5)
;;;470    		uint32_t ulReTryCount = 0;
;;;471    		do
;;;472    		{
;;;473    			if(ulReTryCount > DEF_SRIC_RETRY_COUNT_THD)
;;;474    			{
;;;475    				return NO;
;;;476    			}
;;;477    
;;;478    			if(SRIC_RegisterInit(eSensingMode) == YES)
;;;479    			{
;;;480    				break;
;;;481    			}
;;;482    
;;;483    			SRIC_Reset(eSensingMode);
;;;484    			delay_msec(10);
;;;485    
;;;486    			ulReTryCount++;
;;;487    		} while(1);
;;;488    	}
;;;489    #else /* USED_SRIC_REG_INIT_RETRY */
;;;490    	SRIC_RegisterInit(eSensingMode);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       SRIC_RegisterInit
;;;491    #endif /* USED_SRIC_REG_INIT_RETRY */
;;;492    
;;;493    #if USED_OPERATION_STAND_ALONE
;;;494    	delay_usec(500);
;;;495    #else /* USED_OPERATION_STAND_ALONE */
;;;496    
;;;497    	if(IS_S3_MODE(eSensingMode))
000052  f4146f00          TST      r4,#0x800
000056  d004              BEQ      |L25.98|
;;;498    	{
;;;499    #if USED_S3_VDD_OE_INPUT_OUTPUT_CTRL
;;;500    		HAL_Set_S3_VDD_OddEven_Ctrl(YES);
;;;501    #endif /* USED_S3_VDD_OE_INPUT_OUTPUT_CTRL */
;;;502    
;;;503    		delay_usec(500);
000058  f44f70fa          MOV      r0,#0x1f4
00005c  f7fffffe          BL       delay_us
000060  e013              B        |L25.138|
                  |L25.98|
;;;504    #if USED_S3_PGAMMA_SW_I2C_CTRL
;;;505    		module_S3_PGAMMA_I2C_SW_Disable();
;;;506    #endif /* USED_S3_PGAMMA_SW_I2C_CTRL */
;;;507    	}
;;;508    	else
;;;509    	{
;;;510    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 1);
000062  202d              MOVS     r0,#0x2d
000064  f7fffffe          BL       GPIO_Get_IN
000068  2801              CMP      r0,#1
00006a  d0fa              BEQ      |L25.98|
                  |L25.108|
;;;511    //#if USED_S3_PGAMMA_SW_I2C_CTRL
;;;512    //		_gT(_GPIO_TP_INTR);
;;;513    //		module_S3_PGAMMA_I2C_SW_Enable();
;;;514    //		_gT(_GPIO_TP_INTR);
;;;515    //#endif /* USED_S3_PGAMMA_SW_I2C_CTRL */
;;;516    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 0);
00006c  202d              MOVS     r0,#0x2d
00006e  f7fffffe          BL       GPIO_Get_IN
000072  2800              CMP      r0,#0
000074  d0fa              BEQ      |L25.108|
                  |L25.118|
;;;517    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 1);
000076  202d              MOVS     r0,#0x2d
000078  f7fffffe          BL       GPIO_Get_IN
00007c  2801              CMP      r0,#1
00007e  d0fa              BEQ      |L25.118|
                  |L25.128|
;;;518    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 0);
000080  202d              MOVS     r0,#0x2d
000082  f7fffffe          BL       GPIO_Get_IN
000086  2800              CMP      r0,#0
000088  d0fa              BEQ      |L25.128|
                  |L25.138|
;;;519    	}
;;;520    #endif /* USED_OPERATION_STAND_ALONE */
;;;521    
;;;522    //	{
;;;523    //		PWMDRV_Cmd(ENABLE);
;;;524    //		PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;525    //		tHalIntrHandle.ulInitFirstFrame = 0;
;;;526    //		while(1) ;
;;;527    //	}
;;;528    
;;;529    #if USED_DO_NOT_TOUCH_ONLY_DISPLAY
;;;530    	/*
;;;531    	 * ECLK Disable!! Default value of ECLK is Enable, so ECLK operate when pll is on.
;;;532    	 */
;;;533    	PWMDRV->ECLK_CR.tBit.eclk_force_on = 0;
;;;534    	PWMDRV->ECLK_CR.tBit.eclk_en = 0;
;;;535    	GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_LOW);
;;;536    	Hal_VccOff_State();
;;;537    	while(1)
;;;538    	{
;;;539    		__WFI();
;;;540    	}
;;;541    #endif /* USED_DO_NOT_TOUCH_ONLY_DISPLAY */
;;;542    
;;;543    	SRIC_Run(ENABLE);
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       SRIC_Run
;;;544    
;;;545    	MSPI_ITConfig(ENABLE);
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       MSPI_ITConfig
;;;546    	MSPI_Set_AITMODE(eSensingMode);
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       MSPI_Set_AITMODE
;;;547    
;;;548    	MSPI_Set_BUFSIZE_FingerPenMode(0);
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       MSPI_Set_BUFSIZE_FingerPenMode
;;;549    
;;;550    	PWMDRV_Cmd(ENABLE);
0000a2  2001              MOVS     r0,#1
0000a4  f7fffffe          BL       PWMDRV_Cmd
;;;551    	MSPI->SPIAITSTART = MSPI_START_VAL;
0000a8  f04f2140          MOV      r1,#0x40004000
0000ac  200f              MOVS     r0,#0xf
0000ae  6288              STR      r0,[r1,#0x28]
;;;552    
;;;553    //	PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;554    	tHalIntrHandle.ulInitFirstFrame = 0;
0000b0  62be              STR      r6,[r7,#0x28]  ; tHalIntrHandle
0000b2  6828              LDR      r0,[r5,#0]  ; ptHalInfo
;;;555    
;;;556    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;557    	HAL_SetTPICMuxEnControl(YES, NO);
0000b4  2101              MOVS     r1,#1
0000b6  7b02              LDRB     r2,[r0,#0xc]
0000b8  2a00              CMP      r2,#0
0000ba  bf08              IT       EQ
0000bc  6106              STREQ    r6,[r0,#0x10]
0000be  7301              STRB     r1,[r0,#0xc]
0000c0  7d02              LDRB     r2,[r0,#0x14]
;;;558    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;559    
;;;560    #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;561    	HAL_SetTPICPenEnControl(YES);
;;;562    #endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;563    
;;;564    #if USED_TOUCH_REPORT_ON_OFF_CONTROL
;;;565    	HAL_SetTouchReportEnControl(YES);
0000c2  2101              MOVS     r1,#1
0000c4  2a00              CMP      r2,#0
0000c6  bf08              IT       EQ
0000c8  6186              STREQ    r6,[r0,#0x18]
0000ca  7501              STRB     r1,[r0,#0x14]
0000cc  7982              LDRB     r2,[r0,#6]
;;;566    #endif /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
;;;567    
;;;568    #if USED_ECLK_ON_OFF_CONTROL
;;;569    	HAL_SetECLKOnOffControl(YES);
0000ce  2101              MOVS     r1,#1
0000d0  2a00              CMP      r2,#0
0000d2  bf08              IT       EQ
0000d4  6086              STREQ    r6,[r0,#8]
0000d6  7181              STRB     r1,[r0,#6]
;;;570    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;571    
;;;572    	return YES;
0000d8  2001              MOVS     r0,#1
;;;573    }
0000da  e8bd81f0          POP      {r4-r8,pc}
;;;574    
                          ENDP

0000de  0000              DCW      0x0000
                  |L25.224|
                          DCD      ||.data||
                  |L25.228|
                          DCD      ||.bss||

                          AREA ||i.callPendSV||, CODE, READONLY, ALIGN=2

                  callPendSV PROC
;;;408    
;;;409    void callPendSV(void)
000000  4904              LDR      r1,|L26.20|
;;;410    {
;;;411    	// Set a PendSV to request processing
;;;412    	NVIC_INT_CTRL_REG = NVIC_PENDSVSET_BIT;
000002  f04f5080          MOV      r0,#0x10000000
000006  6008              STR      r0,[r1,#0]
;;;413    	/* Barriers are normally not required but do ensure the code is completely	within the specified behaviour for the architecture. */
;;;414    	__asm volatile( "dsb" );
000008  f3bf8f4f          DSB      
;;;415    	__asm volatile( "isb" );
00000c  f3bf8f6f          ISB      
;;;416    }
000010  4770              BX       lr
;;;417    
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
                          DCD      0xe000ed04

                          AREA ||i.initBoardGPIO||, CODE, READONLY, ALIGN=1

                  initBoardGPIO PROC
;;;42     
;;;43     void initBoardGPIO(void)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     	// TSYNCN_OUT
;;;46     	GPIO_Init(_GPIO_TSYNC_OUT, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
000002  2301              MOVS     r3,#1
000004  2200              MOVS     r2,#0
000006  2103              MOVS     r1,#3
000008  2032              MOVS     r0,#0x32
00000a  f7fffffe          BL       GPIO_Init
;;;47     
;;;48     #if (USED_MODULE_DEF == MODULE_DEF_S_1)
;;;49     	#if (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01 || USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S02)
;;;50     		GPIO_Init(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;51     	#endif /* (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01 || USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S02) */
;;;52     #else
;;;53     	GPIO_Init(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
00000e  2301              MOVS     r3,#1
000010  2200              MOVS     r2,#0
000012  2103              MOVS     r1,#3
000014  2033              MOVS     r0,#0x33
000016  f7fffffe          BL       GPIO_Init
;;;54     #endif
;;;55     
;;;56     #if USED_S3_VDD_OE_INPUT_OUTPUT_CTRL
;;;57     //		module_Set_S3_VDD_OddEven_Ctrl(NO);
;;;58     	GPIO_Init(_GPIO_VDDO_EVEN_CTRL, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;59     #endif /* USED_S3_VDD_OE_INPUT_OUTPUT_CTRL */
;;;60     #if USED_S3_PGAMMA_SW_I2C_CTRL
;;;61     	GPIO_Init(_GPIO_PGMA_SCL, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;62     	GPIO_Init(_GPIO_PGMA_SDL, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;63     #endif /* USED_S3_PGAMMA_SW_I2C_CTRL */
;;;64     
;;;65     #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;66     	GPIO_Init(_GPIO_PEN_EN_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;67     #endif
;;;68     
;;;69     #if USED_GPIO_UPLINK_LEVEL_CONTROL
;;;70     #if (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_HW_CONTROL)
;;;71     	GPIO_Set_Mode(_GPIO_Uplink_GPIO, GPIO_MODE_FUNC_2);
;;;72     #elif (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)
;;;73     	GPIO_Init(_GPIO_Uplink_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;74     #endif /* (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_HW_CONTROL) */
;;;75     #endif /* USED_GPIO_UPLINK_LEVEL_CONTROL */
;;;76     
;;;77     	GPIO_Init(_GPIO_MUX_EN_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
00001a  2301              MOVS     r3,#1
00001c  2200              MOVS     r2,#0
00001e  2103              MOVS     r1,#3
000020  e8bd4010          POP      {r4,lr}
000024  2025              MOVS     r0,#0x25
000026  f7ffbffe          B.W      GPIO_Init
;;;78     #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;79     	GPIO_Init(_GPIO_PEN_EN_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;80     #endif
;;;81     
;;;82     #if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;83     	GPIO_Init(_GPIO_MUX_EN2_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;84     #endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;85     }
;;;86     
                          ENDP


                          AREA ||i.initECLK||, CODE, READONLY, ALIGN=2

                  initECLK PROC
;;;103    
;;;104    void initECLK(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106    	const tHalPwmdrvCommonConf_t * pktHalPwmdrvCommonConf;
;;;107    	pktHalPwmdrvCommonConf = hal_pwmdrv_GetCommonConfig();
000002  f7fffffe          BL       hal_pwmdrv_GetCommonConfig
000006  4604              MOV      r4,r0
;;;108    	// 8. ECLK Configuration  
;;;109    	GPIO_Set_Mode(_GPIO_ECLK_0, GPIO_MODE_FUNC_0);	// ECLK0
000008  2100              MOVS     r1,#0
00000a  202b              MOVS     r0,#0x2b
00000c  f7fffffe          BL       GPIO_Set_Mode
;;;110    	GPIO_Set_DS(_GPIO_ECLK_0, DEF_ECLK_DRIVING_STRENGTH);
000010  2102              MOVS     r1,#2
000012  202b              MOVS     r0,#0x2b
000014  f7fffffe          BL       GPIO_Set_DS
;;;111    #if USED_ECLK_1WAY_CONNECTION
;;;112    	GPIO_Init(_GPIO_ECLK_1, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;113    #else
;;;114    	GPIO_Set_Mode(_GPIO_ECLK_1, GPIO_MODE_FUNC_0);	// ECLK1
000018  2100              MOVS     r1,#0
00001a  202c              MOVS     r0,#0x2c
00001c  f7fffffe          BL       GPIO_Set_Mode
;;;115    	GPIO_Set_DS(_GPIO_ECLK_1, DEF_ECLK_DRIVING_STRENGTH);
000020  2102              MOVS     r1,#2
000022  202c              MOVS     r0,#0x2c
000024  f7fffffe          BL       GPIO_Set_DS
;;;116    #endif
;;;117    
;;;118    //	SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 0;	// PWMDRV_CLK off
;;;119    	PWMDRV->ECLK_CR.ulBulk = pktHalPwmdrvCommonConf->tCP_ECLK_CR.ulBulk;
000028  f8d411c8          LDR      r1,[r4,#0x1c8]
00002c  4803              LDR      r0,|L28.60|
00002e  f8401f8c          STR      r1,[r0,#0x8c]!
;;;120    	PWMDRV->ECLK_CR.tBit.eclk_force_on = PWM_ECLK_ALWAYS_ON;			// ECLK always on. 0-TSYNC on/off
000032  6801              LDR      r1,[r0,#0]
000034  f4417100          ORR      r1,r1,#0x200
000038  6001              STR      r1,[r0,#0]
;;;121    }
00003a  bd10              POP      {r4,pc}
;;;122    
                          ENDP

                  |L28.60|
                          DCD      0x40002000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tHalIntrHandle
                          %        44

                          AREA ||.data||, DATA, ALIGN=2

                  ptHalInfo
                          DCD      0x00000000

                          AREA ||area_number.33||, DATA, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.data||
                  ulVSyncIrqFlg
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_9cc174c9____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___5_hal_c_9cc174c9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_9cc174c9____REVSH|
#line 402
|__asm___5_hal_c_9cc174c9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_9cc174c9____RRX|
#line 587
|__asm___5_hal_c_9cc174c9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
