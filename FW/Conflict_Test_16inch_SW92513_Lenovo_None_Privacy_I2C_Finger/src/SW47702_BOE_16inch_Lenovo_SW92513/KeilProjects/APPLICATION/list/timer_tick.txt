; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\timer_tick.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\timer_tick.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\timer_tick.crf ..\..\Hal\timer\timer_tick.c]
                          THUMB

                          AREA ||i.TimerTick_DeInitialize||, CODE, READONLY, ALIGN=2

                  TimerTick_DeInitialize PROC
;;;89     
;;;90     void TimerTick_DeInitialize(void)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92     	TIMER_StopTimer(TIMER_NUM_0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       TIMER_StopTimer
;;;93     	Fncp_Systick_IRQHandler = NULL;
000008  4901              LDR      r1,|L1.16|
00000a  2000              MOVS     r0,#0
00000c  6008              STR      r0,[r1,#0]  ; Fncp_Systick_IRQHandler
;;;94     }
00000e  bd10              POP      {r4,pc}
;;;95     
                          ENDP

                  |L1.16|
                          DCD      Fncp_Systick_IRQHandler

                          AREA ||i.TimerTick_GetIdleModeCheckTimeSec||, CODE, READONLY, ALIGN=2

                  TimerTick_GetIdleModeCheckTimeSec PROC
;;;239    uint32_t ulTimeSec;
;;;240    uint32_t TimerTick_GetIdleModeCheckTimeSec(void)
000000  4904              LDR      r1,|L2.20|
;;;241    {
;;;242    //	uint32_t ulTimeSec;
;;;243    
;;;244    	ulTimeSec = (ulTimerTickIdleCheckCount * SYSTICK_MAXCOUNT)/(_timer_clock_ * 1000 * 1000);
000002  6808              LDR      r0,[r1,#0]  ; ulTimerTickIdleCheckCount
000004  688a              LDR      r2,[r1,#8]  ; _timer_clock_
000006  0380              LSLS     r0,r0,#14
000008  4b03              LDR      r3,|L2.24|
00000a  435a              MULS     r2,r3,r2
00000c  fbb0f0f2          UDIV     r0,r0,r2
000010  60c8              STR      r0,[r1,#0xc]  ; ulTimeSec
;;;245    
;;;246    	return ulTimeSec;
;;;247    }
000012  4770              BX       lr
;;;248    #endif /* USED_ENTER_IDLE_REAL_TIME_CHECK */
                          ENDP

                  |L2.20|
                          DCD      ||.data||
                  |L2.24|
                          DCD      0x000f4240

                          AREA ||i.TimerTick_Initialize||, CODE, READONLY, ALIGN=2

                  TimerTick_Initialize PROC
;;;75     
;;;76     void TimerTick_Initialize(uint32_t clk)
000000  b500              PUSH     {lr}
;;;77     {
;;;78     	tTimerOpHandleInfo_t TimerOpHandleInfo;
;;;79     	Fncp_Systick_IRQHandler = &TimerTick_InterruptHandler;
000002  4a0b              LDR      r2,|L3.48|
000004  b083              SUB      sp,sp,#0xc            ;77
000006  4909              LDR      r1,|L3.44|
;;;80     #define TIMER_NUM_0			(0)
;;;81     	TimerOpHandleInfo.ulLoadBGCount = 0;
000008  6011              STR      r1,[r2,#0]  ; Fncp_Systick_IRQHandler
00000a  2100              MOVS     r1,#0
;;;82     	TimerOpHandleInfo.ulLoadCount = SYSTICK_MAXCOUNT;
00000c  f44f4280          MOV      r2,#0x4000
000010  e9cd2101          STRD     r2,r1,[sp,#4]
;;;83     	TimerOpHandleInfo.ulTimerUnit = TIMER_NUM_0;
;;;84     	_timer_clock_ = clk;
000014  9100              STR      r1,[sp,#0]
000016  4907              LDR      r1,|L3.52|
000018  6088              STR      r0,[r1,#8]  ; _timer_clock_
;;;85     	TIMER_SetPeriodicMode(&TimerOpHandleInfo);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       TIMER_SetPeriodicMode
;;;86     //	SysTick_Config(SYSTICK_MAXCOUNT);
;;;87     	TIMER_StartTimer(TIMER_NUM_0);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       TIMER_StartTimer
;;;88     }
000026  b003              ADD      sp,sp,#0xc
000028  bd00              POP      {pc}
;;;89     
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      TimerTick_InterruptHandler
                  |L3.48|
                          DCD      Fncp_Systick_IRQHandler
                  |L3.52|
                          DCD      ||.data||

                          AREA ||i.TimerTick_InterruptHandler||, CODE, READONLY, ALIGN=2

                  TimerTick_InterruptHandler PROC
;;;41     
;;;42     void TimerTick_InterruptHandler(void)
000000  4806              LDR      r0,|L4.28|
;;;43     {
;;;44     	//56bit counter를 만들기 위해 32bit카운트 변수 추가
;;;45     	if (_timertick_high_rank_count_ == 0)
000002  6841              LDR      r1,[r0,#4]  ; _timertick_high_rank_count_
000004  2900              CMP      r1,#0
;;;46     	{
;;;47     		_timertick_high_rank_count_ = SYSTICK_MAX_HIGHT_RANK_COUNT;
000006  bf0e              ITEE     EQ
000008  f04f31ff          MOVEQ    r1,#0xffffffff
;;;48     	}
;;;49     	else
;;;50     	{
;;;51     		--_timertick_high_rank_count_;
00000c  6841              LDRNE    r1,[r0,#4]  ; _timertick_high_rank_count_
00000e  1e49              SUBNE    r1,r1,#1
000010  6041              STR      r1,[r0,#4]  ; _timertick_high_rank_count_
;;;52     	}
;;;53     
;;;54     #if USED_ENTER_IDLE_REAL_TIME_CHECK
;;;55     	ulTimerTickIdleCheckCount++;
000012  6801              LDR      r1,[r0,#0]  ; ulTimerTickIdleCheckCount
000014  1c49              ADDS     r1,r1,#1
000016  6001              STR      r1,[r0,#0]  ; ulTimerTickIdleCheckCount
;;;56     #endif /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;57     
;;;58     #if USED_QUEUECOMMONDATA_SEND_Timer_Tick
;;;59     	#ifdef MODE_I2C
;;;60     		QueueCommonData_I2C();
000018  f7ffbffe          B.W      QueueCommonData_I2C
;;;61     	#else
;;;62     		QueueCommonData_USB();
;;;63     	#endif
;;;64     #else /* USED_QUEUECOMMONDATA_SEND_Timer_Tick */
;;;65     	if(tHalIntrHandle.ulUSBSendData_TimerTick)
;;;66     	{
;;;67     	#ifdef MODE_I2C
;;;68     		QueueCommonData_I2C();
;;;69     	#else
;;;70     		QueueCommonData_USB();
;;;71     	#endif
;;;72     	}
;;;73     #endif /* USED_QUEUECOMMONDATA_SEND_Timer_Tick */
;;;74     }
;;;75     
                          ENDP

                  |L4.28|
                          DCD      ||.data||

                          AREA ||i.TimerTick_ResetIdleModeCheckTime||, CODE, READONLY, ALIGN=2

                  TimerTick_ResetIdleModeCheckTime PROC
;;;233    #if USED_ENTER_IDLE_REAL_TIME_CHECK
;;;234    void TimerTick_ResetIdleModeCheckTime(void)
000000  4901              LDR      r1,|L5.8|
;;;235    {
;;;236    	ulTimerTickIdleCheckCount = 0;
000002  2000              MOVS     r0,#0
000004  6008              STR      r0,[r1,#0]  ; ulTimerTickIdleCheckCount
;;;237    }
000006  4770              BX       lr
;;;238    
                          ENDP

                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;218     */
;;;219    void delay_ms(uint32_t time)
000000  b4f0              PUSH     {r4-r7}
000002  f8dfc080          LDR      r12,|L6.132|
;;;220    {
;;;221    	delay_us(time * 1000);
000006  f44f717a          MOV      r1,#0x3e8
00000a  4348              MULS     r0,r1,r0
00000c  f8dc1008          LDR      r1,[r12,#8]  ; _timer_clock_
000010  f44f4280          MOV      r2,#0x4000
000014  fbb2f1f1          UDIV     r1,r2,r1
000018  f1a1030a          SUB      r3,r1,#0xa
00001c  fbb0f1f3          UDIV     r1,r0,r3
000020  fbb0f5f3          UDIV     r5,r0,r3
000024  fb030611          MLS      r6,r3,r1,r0
000028  2400              MOVS     r4,#0
00002a  0412              LSLS     r2,r2,#16
00002c  2d00              CMP      r5,#0
00002e  dd14              BLE      |L6.90|
                  |L6.48|
000030  f8d201b8          LDR      r0,[r2,#0x1b8]        ;220
000034  f3c0010d          UBFX     r1,r0,#0,#14          ;220
                  |L6.56|
000038  f8d201b8          LDR      r0,[r2,#0x1b8]        ;220
00003c  f3c0000d          UBFX     r0,r0,#0,#14          ;220
000040  1a08              SUBS     r0,r1,r0              ;220
000042  bf48              IT       MI                    ;220
000044  f5004080          ADDMI    r0,r0,#0x4000         ;220
000048  f8dc7008          LDR      r7,[r12,#8]           ;220  ; _timer_clock_
00004c  fbb0f7f7          UDIV     r7,r0,r7              ;220
000050  429f              CMP      r7,r3                 ;220
000052  d3f1              BCC      |L6.56|
000054  1c64              ADDS     r4,r4,#1              ;220
000056  42ac              CMP      r4,r5                 ;220
000058  dbea              BLT      |L6.48|
                  |L6.90|
00005a  f8d201b8          LDR      r0,[r2,#0x1b8]        ;220
00005e  f3c0010d          UBFX     r1,r0,#0,#14          ;220
000062  bf00              NOP                            ;220
                  |L6.100|
000064  f8d201b8          LDR      r0,[r2,#0x1b8]        ;220
000068  f3c0000d          UBFX     r0,r0,#0,#14          ;220
00006c  1a08              SUBS     r0,r1,r0              ;220
00006e  bf48              IT       MI                    ;220
000070  f5004080          ADDMI    r0,r0,#0x4000         ;220
000074  f8dc3008          LDR      r3,[r12,#8]           ;220  ; _timer_clock_
000078  fbb0f0f3          UDIV     r0,r0,r3              ;220
00007c  42b0              CMP      r0,r6                 ;220
00007e  d3f1              BCC      |L6.100|
;;;222    //	int i, count, remainder, block;
;;;223    //	block = SYSTICK_MAXCOUNT/(1000*_timer_clock_) -10;
;;;224    //	count = time / block;//200ms단위로 딜레이
;;;225    //	remainder = time % block;//나머지 딜레이
;;;226    //	for (i=0;i<count;++i)
;;;227    //	{
;;;228    //		delay_ms_useSystick(block);
;;;229    //	}
;;;230    //	delay_ms_useSystick(remainder);
;;;231    }
000080  bcf0              POP      {r4-r7}
000082  4770              BX       lr
;;;232    
                          ENDP

                  |L6.132|
                          DCD      ||.data||

                          AREA ||i.delay_ms_useSystick||, CODE, READONLY, ALIGN=2

                  delay_ms_useSystick PROC
;;;169     */
;;;170    void delay_ms_useSystick(uint32_t time)
000000  b470              PUSH     {r4-r6}
;;;171    {
;;;172    	uint32_t start = getSysTick();
000002  f04f4480          MOV      r4,#0x40000000
000006  f8d411b8          LDR      r1,[r4,#0x1b8]
;;;173    	do {
;;;174    	} while (getMSfromTick(getElapsedSYSTICK(start))<time);
00000a  4b0d              LDR      r3,|L7.64|
00000c  f3c1020d          UBFX     r2,r1,#0,#14          ;172
000010  f04f3cff          MOV      r12,#0xffffffff
                  |L7.20|
000014  f8d411b8          LDR      r1,[r4,#0x1b8]
000018  f3c1010d          UBFX     r1,r1,#0,#14
00001c  1a51              SUBS     r1,r2,r1
00001e  bf48              IT       MI
000020  f5014180          ADDMI    r1,r1,#0x4000
000024  689d              LDR      r5,[r3,#8]  ; _timer_clock_
000026  eb050645          ADD      r6,r5,r5,LSL #1
00002a  ebc615c5          RSB      r5,r6,r5,LSL #7
00002e  eb0c05c5          ADD      r5,r12,r5,LSL #3
000032  fbb1f1f5          UDIV     r1,r1,r5
000036  4281              CMP      r1,r0
000038  d3ec              BCC      |L7.20|
;;;175    }
00003a  bc70              POP      {r4-r6}
00003c  4770              BX       lr
;;;176    /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      ||.data||

                          AREA ||i.delay_systick||, CODE, READONLY, ALIGN=1

                  delay_systick PROC
;;;183     */
;;;184    void delay_systick(uint32_t tick_count)
000000  f04f4380          MOV      r3,#0x40000000
;;;185    {
;;;186    	uint32_t start = getSysTick();
000004  f8d311b8          LDR      r1,[r3,#0x1b8]
000008  f3c1020d          UBFX     r2,r1,#0,#14
                  |L8.12|
00000c  f8d311b8          LDR      r1,[r3,#0x1b8]
000010  f3c1010d          UBFX     r1,r1,#0,#14
000014  1a51              SUBS     r1,r2,r1
000016  bf48              IT       MI
000018  f5014180          ADDMI    r1,r1,#0x4000
;;;187    	do {
;;;188    	} while (getElapsedSYSTICK(start)<tick_count);
00001c  4281              CMP      r1,r0
00001e  d3f5              BCC      |L8.12|
;;;189    }
000020  4770              BX       lr
;;;190    /**
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;198    
;;;199    void delay_us(uint32_t time)
000000  b4f0              PUSH     {r4-r7}
;;;200    {
;;;201    	int i,count,remainder,block;
;;;202    	block = SYSTICK_MAXCOUNT / _timer_clock_ -10;
000002  4d1e              LDR      r5,|L9.124|
000004  68a9              LDR      r1,[r5,#8]  ; _timer_clock_
000006  f44f4280          MOV      r2,#0x4000
00000a  fbb2f1f1          UDIV     r1,r2,r1
00000e  f1a1030a          SUB      r3,r1,#0xa
;;;203    	count = time / block;//200ms단위로 딜레이
;;;204    	remainder = time % block;//나머지 딜레이
000012  fbb0f1f3          UDIV     r1,r0,r3
000016  fbb0f4f3          UDIV     r4,r0,r3              ;203
00001a  fb030611          MLS      r6,r3,r1,r0
00001e  0412              LSLS     r2,r2,#16
;;;205    	for (i=0; i<count; ++i)
000020  f04f0c00          MOV      r12,#0
000024  2c00              CMP      r4,#0
000026  dd14              BLE      |L9.82|
                  |L9.40|
000028  f8d201b8          LDR      r0,[r2,#0x1b8]        ;200
00002c  f3c0010d          UBFX     r1,r0,#0,#14          ;200
                  |L9.48|
000030  f8d201b8          LDR      r0,[r2,#0x1b8]        ;200
000034  f3c0000d          UBFX     r0,r0,#0,#14          ;200
000038  1a08              SUBS     r0,r1,r0              ;200
00003a  bf48              IT       MI                    ;200
00003c  f5004080          ADDMI    r0,r0,#0x4000         ;200
000040  68af              LDR      r7,[r5,#8]            ;200  ; _timer_clock_
000042  fbb0f7f7          UDIV     r7,r0,r7              ;200
000046  429f              CMP      r7,r3                 ;200
000048  d3f2              BCC      |L9.48|
00004a  f10c0c01          ADD      r12,r12,#1            ;200
00004e  45a4              CMP      r12,r4
000050  dbea              BLT      |L9.40|
                  |L9.82|
000052  f8d201b8          LDR      r0,[r2,#0x1b8]
000056  f3c0010d          UBFX     r1,r0,#0,#14
00005a  bf00              NOP      
                  |L9.92|
00005c  f8d201b8          LDR      r0,[r2,#0x1b8]
000060  f3c0000d          UBFX     r0,r0,#0,#14
000064  1a08              SUBS     r0,r1,r0
000066  bf48              IT       MI
000068  f5004080          ADDMI    r0,r0,#0x4000
00006c  68ab              LDR      r3,[r5,#8]  ; _timer_clock_
00006e  fbb0f0f3          UDIV     r0,r0,r3
000072  42b0              CMP      r0,r6
000074  d3f2              BCC      |L9.92|
;;;206    	{
;;;207    		delay_us_useSystick(block);
;;;208    	}
;;;209    	delay_us_useSystick(remainder);
;;;210    }
000076  bcf0              POP      {r4-r7}
000078  4770              BX       lr
;;;211    /**
                          ENDP

00007a  0000              DCW      0x0000
                  |L9.124|
                          DCD      ||.data||

                          AREA ||i.delay_us_useSystick||, CODE, READONLY, ALIGN=2

                  delay_us_useSystick PROC
;;;155     */
;;;156    void delay_us_useSystick(uint32_t time)
000000  b410              PUSH     {r4}
;;;157    {
;;;158    	uint32_t start = getSysTick();
000002  f04f4380          MOV      r3,#0x40000000
000006  f8d311b8          LDR      r1,[r3,#0x1b8]
;;;159    	do {
;;;160    	} while (getUSfromTick(getElapsedSYSTICK(start))<time);
00000a  f8dfc028          LDR      r12,|L10.52|
00000e  f3c1020d          UBFX     r2,r1,#0,#14          ;158
000012  bf00              NOP                            ;158
                  |L10.20|
000014  f8d311b8          LDR      r1,[r3,#0x1b8]        ;158
000018  f3c1010d          UBFX     r1,r1,#0,#14          ;158
00001c  1a51              SUBS     r1,r2,r1              ;158
00001e  bf48              IT       MI                    ;158
000020  f5014180          ADDMI    r1,r1,#0x4000         ;158
000024  f8dc4008          LDR      r4,[r12,#8]  ; _timer_clock_
000028  fbb1f1f4          UDIV     r1,r1,r4
00002c  4281              CMP      r1,r0
00002e  d3f1              BCC      |L10.20|
;;;161    }
000030  bc10              POP      {r4}
000032  4770              BX       lr
;;;162    /**
                          ENDP

                  |L10.52|
                          DCD      ||.data||

                          AREA ||i.getElapsedLongSYSTICK||, CODE, READONLY, ALIGN=2

                  getElapsedLongSYSTICK PROC
;;;125     */
;;;126    uint64_t getElapsedLongSYSTICK(uint64_t start)
000000  4a0e              LDR      r2,|L11.60|
;;;127    {
000002  b410              PUSH     {r4}
;;;128    	int64_t elapsedTick;
;;;129    	elapsedTick = start-getLongSysTick();
000004  6853              LDR      r3,[r2,#4]  ; _timertick_high_rank_count_
000006  2200              MOVS     r2,#0
000008  0394              LSLS     r4,r2,#14
00000a  ea444c93          ORR      r12,r4,r3,LSR #18
00000e  039c              LSLS     r4,r3,#14
000010  f04f4380          MOV      r3,#0x40000000
000014  f8d331b8          LDR      r3,[r3,#0x1b8]
000018  ea4c0202          ORR      r2,r12,r2
00001c  f3c3030d          UBFX     r3,r3,#0,#14
000020  4323              ORRS     r3,r3,r4
000022  1ac0              SUBS     r0,r0,r3
000024  4191              SBCS     r1,r1,r2
;;;130    	if (elapsedTick < 0)
;;;131    	{
;;;132    		elapsedTick = SYSTICK_MAX_LONG_COUNT + elapsedTick;
;;;133    	}
;;;134    	return elapsedTick;
;;;135    }
000026  bf5c              ITT      PL
000028  bc10              POPPL    {r4}
00002a  4770              BXPL     lr
00002c  f64372fe          MOV      r2,#0x3ffe            ;132
000030  1880              ADDS     r0,r0,r2              ;132
000032  bc10              POP      {r4}
000034  f1410100          ADC      r1,r1,#0              ;132
000038  4770              BX       lr
;;;136    /**
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      ||.data||

                          AREA ||i.getElapsedSYSTICK||, CODE, READONLY, ALIGN=1

                  getElapsedSYSTICK PROC
;;;107    
;;;108    uint32_t getElapsedSYSTICK(uint32_t start)
000000  f04f4180          MOV      r1,#0x40000000
;;;109    {
;;;110    	int32_t elapsedTick;
;;;111    	elapsedTick = start - getSysTick();
000004  f8d111b8          LDR      r1,[r1,#0x1b8]
000008  f3c1010d          UBFX     r1,r1,#0,#14
00000c  1a40              SUBS     r0,r0,r1
00000e  bf48              IT       MI
000010  f5004080          ADDMI    r0,r0,#0x4000
;;;112    	if (elapsedTick < 0)
;;;113    	{
;;;114    		elapsedTick += SYSTICK_MAXCOUNT;
;;;115    	}
;;;116    	return elapsedTick;
;;;117    }
000014  4770              BX       lr
;;;118    /**
                          ENDP


                          AREA ||i.getElapsedSYSTICK2||, CODE, READONLY, ALIGN=1

                  getElapsedSYSTICK2 PROC
;;;99       */
;;;100    uint32_t getElapsedSYSTICK2(uint32_t start,uint32_t end)
000000  1a40              SUBS     r0,r0,r1
;;;101    {
;;;102    	int32_t elapsedTick;
;;;103    	elapsedTick = start-end;
000002  bf48              IT       MI
000004  f5004080          ADDMI    r0,r0,#0x4000
;;;104    	if (elapsedTick < 0) elapsedTick += SYSTICK_MAXCOUNT;
;;;105    	return elapsedTick;
;;;106    }
000008  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.getElapsedTime_us||, CODE, READONLY, ALIGN=2

                  getElapsedTime_us PROC
;;;143     */
;;;144    uint64_t getElapsedTime_us(uint64_t start_tick)
000000  b570              PUSH     {r4-r6,lr}
000002  4a10              LDR      r2,|L14.68|
000004  f8d2c004          LDR      r12,[r2,#4]  ; _timertick_high_rank_count_
000008  2300              MOVS     r3,#0
00000a  039d              LSLS     r5,r3,#14
00000c  ea45449c          ORR      r4,r5,r12,LSR #18
000010  ea4f358c          LSL      r5,r12,#14
000014  f04f4c80          MOV      r12,#0x40000000
000018  f8dcc1b8          LDR      r12,[r12,#0x1b8]
00001c  431c              ORRS     r4,r4,r3
00001e  f3cc0c0d          UBFX     r12,r12,#0,#14
000022  ea450c0c          ORR      r12,r5,r12
000026  ebb0000c          SUBS     r0,r0,r12
00002a  41a1              SBCS     r1,r1,r4
;;;145    {
00002c  d505              BPL      |L14.58|
00002e  f6437cfe          MOV      r12,#0x3ffe
000032  eb10000c          ADDS     r0,r0,r12
000036  f1410100          ADC      r1,r1,#0
                  |L14.58|
;;;146    	return getUSfromTick(getElapsedLongSYSTICK(start_tick));
00003a  6892              LDR      r2,[r2,#8]  ; _timer_clock_
00003c  f7fffffe          BL       __aeabi_uldivmod
;;;147    }
000040  bd70              POP      {r4-r6,pc}
;;;148    /**
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  ulTimerTickIdleCheckCount
                          DCD      0x00000000
                  _timertick_high_rank_count_
                          DCD      0x00000000
                  _timer_clock_
                          DCD      0x00000000
                  ulTimeSec
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\timer\\timer_tick.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_timer_tick_c_2dc1a604____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___12_timer_tick_c_2dc1a604____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_timer_tick_c_2dc1a604____REVSH|
#line 402
|__asm___12_timer_tick_c_2dc1a604____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_timer_tick_c_2dc1a604____RRX|
#line 587
|__asm___12_timer_tick_c_2dc1a604____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
