; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\pwmdrv.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\pwmdrv.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\pwmdrv.crf ..\..\Hal\pwmdrv\pwmdrv.c]
                          THUMB

                          AREA ||i.PWMDRV_Cmd||, CODE, READONLY, ALIGN=2

                  PWMDRV_Cmd PROC
;;;1739   
;;;1740   void PWMDRV_Cmd(FunctionalState _NewState)
000000  4905              LDR      r1,|L1.24|
;;;1741   {
;;;1742   	PWMDRV->PWMGEN_CR0.tBit.pwm_gen_enable = _NewState;
000002  680a              LDR      r2,[r1,#0]
000004  f3600200          BFI      r2,r0,#0,#1
000008  600a              STR      r2,[r1,#0]
;;;1743   //	if(_NewState == ENABLE)
;;;1744   //	{
;;;1745   //		SCRB->SYS_RST_CTL.tBit.pwm_rst = 0;
;;;1746   //	}
;;;1747   //	else
;;;1748   //	{
;;;1749   //		SCRB->SYS_RST_CTL.tBit.pwm_rst = 1;
;;;1750   //	}
;;;1751   	PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = _NewState;
00000a  f8d120c0          LDR      r2,[r1,#0xc0]
00000e  f3600200          BFI      r2,r0,#0,#1
000012  f8c120c0          STR      r2,[r1,#0xc0]
;;;1752   
;;;1753   //	PWMDRV->PWMGEN_CR0.tBit.pwm_gen_enable = _NewState;
;;;1754   //	if(_NewState == DISABLE)
;;;1755   //	{
;;;1756   //		PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = DISABLE;
;;;1757   //	}
;;;1758   }
000016  4770              BX       lr
;;;1759   
                          ENDP

                  |L1.24|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_FullScanIdleModeSetting||, CODE, READONLY, ALIGN=2

                  PWMDRV_FullScanIdleModeSetting PROC
;;;1643   #if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
;;;1644   void PWMDRV_FullScanIdleModeSetting(void)
000000  b508              PUSH     {r3,lr}
;;;1645   {
;;;1646   	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000002  f7fffffe          BL       hal_pwmdrv_GetControlConfig
;;;1647   	tCP_PWMGEN_CR2_t tCP_PWMGEN_CR2;
;;;1648   
;;;1649   	tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
000006  6880              LDR      r0,[r0,#8]
000008  9000              STR      r0,[sp,#0]
;;;1650   	tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_total_mux_num;
00000a  f8bd0002          LDRH     r0,[sp,#2]
00000e  f42060fc          BIC      r0,r0,#0x7e0
000012  f50070c0          ADD      r0,r0,#0x180
000016  f8ad0002          STRH     r0,[sp,#2]
;;;1651   	PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
00001a  9900              LDR      r1,[sp,#0]
00001c  480c              LDR      r0,|L2.80|
00001e  6081              STR      r1,[r0,#8]
;;;1652   	PWMDRV->MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_MUX_CR_finger;
000020  f8d01110          LDR      r1,[r0,#0x110]
000024  f421317c          BIC      r1,r1,#0x3f000
000028  f5015100          ADD      r1,r1,#0x2000
00002c  f8c01110          STR      r1,[r0,#0x110]
;;;1653   #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;1654   	PWMDRV->PWMGEN_CR1.tBit.pen_s_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_pen_s_pwmnum;
000030  f8501f04          LDR      r1,[r0,#4]!
000034  f02141fe          BIC      r1,r1,#0x7f000000
000038  f1016110          ADD      r1,r1,#0x9000000
00003c  6001              STR      r1,[r0,#0]
;;;1655   #endif
;;;1656   #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;1657   	PWMDRV->PWM_TPIC_CR.tBit.pen_s_en = DISABLE;
00003e  6fc1              LDR      r1,[r0,#0x7c]
000040  f0210110          BIC      r1,r1,#0x10
000044  67c1              STR      r1,[r0,#0x7c]
;;;1658   	PWMDRV->PWM_TPIC_CR.tBit.pen_s_dmy_en = DISABLE;
000046  6fc1              LDR      r1,[r0,#0x7c]
000048  f0210180          BIC      r1,r1,#0x80
00004c  67c1              STR      r1,[r0,#0x7c]
;;;1659   #endif
;;;1660   }
00004e  bd08              POP      {r3,pc}
;;;1661   #endif /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
                          ENDP

                  |L2.80|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_GPIO_Init||, CODE, READONLY, ALIGN=1

                  PWMDRV_GPIO_Init PROC
;;;1662   
;;;1663   void PWMDRV_GPIO_Init(eSENSING_MODE_t _eSensingMode)
000000  b510              PUSH     {r4,lr}
;;;1664   {
;;;1665   	// I/O COnfiguration
;;;1666   #if USED_OPERATION_STAND_ALONE
;;;1667   	GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1668   //	GPIO_Set_PE(_GPIO_VSYNC, GPIO_PE_PULL_DOWN); // Input
;;;1669   	GPIO_Init(_GPIO_TSYNC_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1670   //	GPIO_Set_PE(_GPIO_TSYNC_IN, GPIO_PE_PULL_DOWN); // Input
;;;1671   #if USED_TSYNC2_INPUT_FROM_TCON
;;;1672   	GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_NONE);
;;;1673   #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;1674   #else /* USED_OPERATION_STAND_ALONE */
;;;1675   
;;;1676   	if(IS_S3_MODE(_eSensingMode))
000002  f4106f00          TST      r0,#0x800
;;;1677   	{
;;;1678   		GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1679   		GPIO_Init(_GPIO_TSYNC_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1680   #if USED_TSYNC2_INPUT_FROM_TCON
;;;1681   		GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1682   #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;1683   	}
;;;1684   	else
;;;1685   	{
;;;1686   #if USED_TOUCH_TUNING_PROCESS
;;;1687   		GPIO_Set_Mode(_GPIO_VSYNC, GPIO_MODE_FUNC_0); // Used VSync Interrupt
;;;1688   #else /* USED_TOUCH_TUNING_PROCESS */
;;;1689   		GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
000006  f04f0302          MOV      r3,#2
00000a  f04f0201          MOV      r2,#1
00000e  f04f0103          MOV      r1,#3
000012  f04f002d          MOV      r0,#0x2d
000016  d008              BEQ      |L3.42|
000018  f7fffffe          BL       GPIO_Init
00001c  2302              MOVS     r3,#2                 ;1679
00001e  2201              MOVS     r2,#1                 ;1679
000020  2103              MOVS     r1,#3                 ;1679
000022  202e              MOVS     r0,#0x2e              ;1679
000024  f7fffffe          BL       GPIO_Init
000028  e005              B        |L3.54|
                  |L3.42|
00002a  f7fffffe          BL       GPIO_Init
;;;1690   #endif /* USED_TOUCH_TUNING_PROCESS */
;;;1691   		GPIO_Set_Mode(_GPIO_TSYNC_IN, GPIO_MODE_FUNC_0);
00002e  2100              MOVS     r1,#0
000030  202e              MOVS     r0,#0x2e
000032  f7fffffe          BL       GPIO_Set_Mode
                  |L3.54|
;;;1692   #if USED_TSYNC2_INPUT_FROM_TCON
;;;1693   		GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1694   #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;1695   	}
;;;1696   #endif /* USED_OPERATION_STAND_ALONE */
;;;1697   
;;;1698   	GPIO_Set_Mode(_GPIO_PWM_SRIC, GPIO_MODE_FUNC_0); // PWM_TX
000036  2100              MOVS     r1,#0
000038  202f              MOVS     r0,#0x2f
00003a  f7fffffe          BL       GPIO_Set_Mode
;;;1699   	GPIO_Set_Mode(_GPIO_PWM_TPIC, GPIO_MODE_FUNC_0); // PWM_DATA (PWM_LFD)
00003e  2100              MOVS     r1,#0
000040  2030              MOVS     r0,#0x30
000042  f7fffffe          BL       GPIO_Set_Mode
;;;1700   #if USED_PWM_GATE_CONTROL
;;;1701   	GPIO_Set_Mode(_GPIO_PWM_GATE, GPIO_MODE_FUNC_1); // PWM_DATA (PWM_LFD)
;;;1702   #endif /* USED_PWM_GATE_CONTROL */
;;;1703   
;;;1704   	GPIO_Set_DS(_GPIO_PWM_SRIC, GPIO_DRIVE_STR_20mA);
000046  2103              MOVS     r1,#3
000048  202f              MOVS     r0,#0x2f
00004a  f7fffffe          BL       GPIO_Set_DS
;;;1705   	GPIO_Set_DS(_GPIO_PWM_TPIC, GPIO_DRIVE_STR_20mA);
00004e  2103              MOVS     r1,#3
000050  2030              MOVS     r0,#0x30
000052  f7fffffe          BL       GPIO_Set_DS
;;;1706   #if USED_PWM_GATE_CONTROL
;;;1707   	GPIO_Set_DS(_GPIO_PWM_GATE, GPIO_DRIVE_STR_20mA);
;;;1708   #endif /* USED_PWM_GATE_CONTROL */
;;;1709   
;;;1710   	GPIO_Set_Mode(_GPIO_TSYNC_OUT, GPIO_MODE_FUNC_0); // TSYNCN_OUT
000056  2100              MOVS     r1,#0
000058  2032              MOVS     r0,#0x32
00005a  f7fffffe          BL       GPIO_Set_Mode
;;;1711   	GPIO_Set_DS(_GPIO_TSYNC_OUT, GPIO_DRIVE_STR_20mA);
00005e  2103              MOVS     r1,#3
000060  2032              MOVS     r0,#0x32
000062  f7fffffe          BL       GPIO_Set_DS
;;;1712   
;;;1713   #if (USED_MODULE_DEF == MODULE_DEF_B_1)
;;;1714   #if USED_REVISION_PINMAP
;;;1715   #if (USED_REVISION_PINMAP_2)
;;;1716   	GPIO_Set_Mode(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_0);
;;;1717   	GPIO_Set_DS(_GPIO_TSYNC_TMIC, GPIO_DRIVE_STR_20mA);
;;;1718   #endif /* (USED_REVISION_PINMAP_2 */
;;;1719   #else  /* USED_REVISION_PINMAP */
;;;1720   #if USED_TSYNC_TMIC_GPIO_CONTROL
;;;1721   	GPIO_Init(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;1722   #else  /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;1723   	GPIO_Set_Mode(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_0);
000066  2100              MOVS     r1,#0
000068  2033              MOVS     r0,#0x33
00006a  f7fffffe          BL       GPIO_Set_Mode
;;;1724   	GPIO_Set_DS(_GPIO_TSYNC_TMIC, GPIO_DRIVE_STR_20mA);
00006e  2103              MOVS     r1,#3
000070  e8bd4010          POP      {r4,lr}
000074  2033              MOVS     r0,#0x33
000076  f7ffbffe          B.W      GPIO_Set_DS
;;;1725   #endif /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;1726   #endif /* USED_REVISION_PINMAP */
;;;1727   #elif (USED_MODULE_DEF == MODULE_DEF_S_1)
;;;1728   #if (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01 || USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S02)
;;;1729   	GPIO_Set_Mode(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_0);
;;;1730   	GPIO_Set_DS(_GPIO_TSYNC_TMIC, GPIO_DRIVE_STR_20mA);
;;;1731   #endif /* (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01 || USED_PCB_PINMAP == AUO_NBPC_PIN_TYPE_S01) */
;;;1732   #elif (USED_MODULE_DEF == MODULE_DEF_A_1)
;;;1733   #if (USED_PCB_PINMAP == AUO_NBPC_PIN_TYPE_A00)
;;;1734   	GPIO_Set_Mode(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_0);
;;;1735   	GPIO_Set_DS(_GPIO_TSYNC_TMIC, GPIO_DRIVE_STR_20mA);
;;;1736   #endif /* (USED_PCB_PINMAP == AUO_NBPC_PIN_TYPE_S01) */
;;;1737   #endif /* (USED_MODULE_DEF == MODULE_DEF_B_1) */
;;;1738   }
;;;1739   
                          ENDP


                          AREA ||i.PWMDRV_ITConfig||, CODE, READONLY, ALIGN=1

                  PWMDRV_ITConfig PROC
;;;1759   
;;;1760   void PWMDRV_ITConfig(tPWM_INTR_CFG_t * pIntrCfg, uint32_t ulNum)
000000  2300              MOVS     r3,#0
;;;1761   {
;;;1762   	uint32_t ulIdx;
;;;1763   
;;;1764   	for(ulIdx = 0; ulIdx < ulNum; ulIdx++)
000002  2900              CMP      r1,#0
;;;1765   	{
;;;1766   		NVIC_ClearPendingIRQ(pIntrCfg[ulIdx].PWM_IRQ_TYPE);
;;;1767   		NVIC_SetPriority(pIntrCfg[ulIdx].PWM_IRQ_TYPE, pIntrCfg[ulIdx].ulIRQ_Priority);
;;;1768   		if(pIntrCfg[ulIdx].newState != DISABLE)
;;;1769   		{
;;;1770   			NVIC_EnableIRQ(pIntrCfg[ulIdx].PWM_IRQ_TYPE);
;;;1771   		}
;;;1772   		else
;;;1773   		{
;;;1774   			NVIC_DisableIRQ(pIntrCfg[ulIdx].PWM_IRQ_TYPE);
;;;1775   		}
;;;1776   	}
;;;1777   }
000004  bf98              IT       LS
000006  4770              BXLS     lr
000008  b430              PUSH     {r4,r5}               ;1761
00000a  2401              MOVS     r4,#1                 ;1761
                  |L4.12|
00000c  eb030243          ADD      r2,r3,r3,LSL #1       ;1766
000010  eb000282          ADD      r2,r0,r2,LSL #2       ;1766
000014  f992c000          LDRSB    r12,[r2,#0]           ;1766
000018  f00c051f          AND      r5,r12,#0x1f          ;1766
00001c  ea4f1c5c          LSR      r12,r12,#5            ;1766
000020  ea4f0c8c          LSL      r12,r12,#2            ;1766
000024  f10c2ce0          ADD      r12,r12,#0xe000e000   ;1766
000028  fa04f505          LSL      r5,r4,r5              ;1766
00002c  f8cc5280          STR      r5,[r12,#0x280]       ;1766
000030  f992c000          LDRSB    r12,[r2,#0]           ;1767
000034  6855              LDR      r5,[r2,#4]            ;1767
000036  f1bc0f00          CMP      r12,#0                ;1767
00003a  ea4f1545          LSL      r5,r5,#5              ;1767
00003e  bfb8              IT       LT                    ;1767
000040  f00c0c0f          ANDLT    r12,r12,#0xf          ;1767
000044  f10c2ce0          ADD      r12,r12,#0xe000e000   ;1767
000048  bfb4              ITE      LT                    ;1767
00004a  f88c5d14          STRBLT   r5,[r12,#0xd14]       ;1767
00004e  f88c5400          STRBGE   r5,[r12,#0x400]       ;1767
000052  f892c008          LDRB     r12,[r2,#8]           ;1768
000056  f9922000          LDRSB    r2,[r2,#0]            ;1774
00005a  f1bc0f00          CMP      r12,#0                ;1768
00005e  f0020c1f          AND      r12,r2,#0x1f          ;1768
000062  ea4f1252          LSR      r2,r2,#5              ;1768
000066  ea4f0282          LSL      r2,r2,#2              ;1768
00006a  fa04fc0c          LSL      r12,r4,r12            ;1768
00006e  f10222e0          ADD      r2,r2,#0xe000e000     ;1768
000072  bf14              ITE      NE                    ;1768
000074  f8c2c100          STRNE    r12,[r2,#0x100]       ;1768
000078  f8c2c180          STREQ    r12,[r2,#0x180]       ;1768
00007c  1c5b              ADDS     r3,r3,#1              ;1768
00007e  428b              CMP      r3,r1                 ;1764
000080  d3c4              BCC      |L4.12|
000082  bc30              POP      {r4,r5}
000084  4770              BX       lr
;;;1778   
                          ENDP


                          AREA ||i.PWMDRV_Init||, CODE, READONLY, ALIGN=2

                  PWMDRV_Init PROC
;;;896    
;;;897    void PWMDRV_Init(eSENSING_MODE_t _eSensingMode)
000000  b530              PUSH     {r4,r5,lr}
;;;898    {
;;;899    	Fncp_VSYNC_IN_IRQHandler = &PWMDRV_VSync_In_InterruptHandler;
000002  496a              LDR      r1,|L5.428|
000004  4605              MOV      r5,r0                 ;898
000006  b08d              SUB      sp,sp,#0x34           ;898
000008  4867              LDR      r0,|L5.424|
;;;900    	Fncp_TSYNC_IN_IRQHandler = &PWMDRV_TSync_In_InterruptHandler;
00000a  6008              STR      r0,[r1,#0]  ; Fncp_VSYNC_IN_IRQHandler
00000c  4969              LDR      r1,|L5.436|
00000e  4868              LDR      r0,|L5.432|
;;;901    	Fncp_TSYNC_OUT_IRQHandler = &PWMDRV_TSync_Out_InterruptHandler;
000010  6008              STR      r0,[r1,#0]  ; Fncp_TSYNC_IN_IRQHandler
000012  496a              LDR      r1,|L5.444|
000014  4868              LDR      r0,|L5.440|
;;;902    	Fncp_PWMDRV_IRQHandler = &PWMDRV_PWM_Out_InterruptHandler;
000016  6008              STR      r0,[r1,#0]  ; Fncp_TSYNC_OUT_IRQHandler
000018  496a              LDR      r1,|L5.452|
00001a  4869              LDR      r0,|L5.448|
;;;903    
;;;904    	PWMDRV_RegisterInit(_eSensingMode, YES);
00001c  6008              STR      r0,[r1,#0]  ; Fncp_PWMDRV_IRQHandler
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       PWMDRV_RegisterInit
;;;905    	SCRB->SYS_RST_CTL.tBit.pwm_rst = 1;
000026  f04f4480          MOV      r4,#0x40000000
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  f0400040          ORR      r0,r0,#0x40
000030  60e0              STR      r0,[r4,#0xc]
;;;906    	SCRB->SYS_RST_CTL.tBit.pwm_rst = 0;
000032  68e0              LDR      r0,[r4,#0xc]
000034  f0200040          BIC      r0,r0,#0x40
000038  60e0              STR      r0,[r4,#0xc]
00003a  f4156f00          TST      r5,#0x800
00003e  f04f0302          MOV      r3,#2
000042  f04f0201          MOV      r2,#1
000046  f04f0103          MOV      r1,#3
00004a  f04f002d          MOV      r0,#0x2d
00004e  d008              BEQ      |L5.98|
000050  f7fffffe          BL       GPIO_Init
000054  2302              MOVS     r3,#2
000056  2201              MOVS     r2,#1
000058  2103              MOVS     r1,#3
00005a  202e              MOVS     r0,#0x2e
00005c  f7fffffe          BL       GPIO_Init
000060  e005              B        |L5.110|
                  |L5.98|
000062  f7fffffe          BL       GPIO_Init
000066  2100              MOVS     r1,#0
000068  202e              MOVS     r0,#0x2e
00006a  f7fffffe          BL       GPIO_Set_Mode
                  |L5.110|
00006e  2100              MOVS     r1,#0
000070  202f              MOVS     r0,#0x2f
000072  f7fffffe          BL       GPIO_Set_Mode
000076  2100              MOVS     r1,#0
000078  2030              MOVS     r0,#0x30
00007a  f7fffffe          BL       GPIO_Set_Mode
00007e  2103              MOVS     r1,#3
000080  202f              MOVS     r0,#0x2f
000082  f7fffffe          BL       GPIO_Set_DS
000086  2103              MOVS     r1,#3
000088  2030              MOVS     r0,#0x30
00008a  f7fffffe          BL       GPIO_Set_DS
00008e  2100              MOVS     r1,#0
000090  2032              MOVS     r0,#0x32
000092  f7fffffe          BL       GPIO_Set_Mode
000096  2103              MOVS     r1,#3
000098  2032              MOVS     r0,#0x32
00009a  f7fffffe          BL       GPIO_Set_DS
00009e  2100              MOVS     r1,#0
0000a0  2033              MOVS     r0,#0x33
0000a2  f7fffffe          BL       GPIO_Set_Mode
0000a6  2103              MOVS     r1,#3
0000a8  2033              MOVS     r0,#0x33
0000aa  f7fffffe          BL       GPIO_Set_DS
;;;907    	PWMDRV_GPIO_Init(_eSensingMode);
;;;908    
;;;909    #if USED_OPERATION_STAND_ALONE
;;;910    	{
;;;911    		SCRB->PWM_INT_CTRL.tBit.int_en_pwm_ab = PWM_INTR_DISABLE;
;;;912    		SCRB->PWM_INT_CTRL.tBit.int_en_pwm_frame = PWM_INTR_DISABLE;
;;;913    		SCRB->PWM_INT_CTRL.tBit.int_en_tsync_ab = PWM_INTR_DISABLE;
;;;914    		SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_DISABLE;
;;;915    
;;;916    		SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_DISABLE;
;;;917    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncin = PWM_INTR_BOTH_EDGE;
;;;918    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_RISING_EDGE; // Rising
;;;919    		SCRB->PWM_INT_CTRL.tBit.int_tsyncin_src_sel = PWM_TYNCIN_INT_SOURCE_TSYNC_D;
;;;920    
;;;921    		{
;;;922    			tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
;;;923    			{
;;;924    				{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;925    				{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, DISABLE},
;;;926    				{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, ENABLE},
;;;927    				{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;928    			};
;;;929    			PWMDRV_ITConfig((tPWM_INTR_CFG_t *)&tPWM_INTR_CFG[0], 4);
;;;930    		}
;;;931    	}
;;;932    #else /* USED_OPERATION_STAND_ALONE */
;;;933    	{
;;;934    	#if USED_MNT_S3_MODE_FUNCTION
;;;935    		if(IS_S3_MODE(_eSensingMode))
;;;936    		{
;;;937    			SCRB->PWM_INT_CTRL.tBit.int_en_pwm_ab = PWM_INTR_DISABLE;
;;;938    			SCRB->PWM_INT_CTRL.tBit.int_en_pwm_frame = PWM_INTR_DISABLE;
;;;939    			SCRB->PWM_INT_CTRL.tBit.int_en_tsync_ab = PWM_INTR_DISABLE;
;;;940    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL)
;;;941    			SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_ENABLE;
;;;942    		#if USED_PWM_PULSE_END_FLAG_CHECK
;;;943    			SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_BOTH_EDGE;
;;;944    		#else /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;945    			SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_FALLING_EDGE;
;;;946    		#endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;947    	#else /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;948    			SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_DISABLE;
;;;949    			SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_RISING_EDGE;
;;;950    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;951    
;;;952    	#if USED_TOUCH_TUNING_PROCESS
;;;953    			SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_RISING_EDGE;
;;;954    	#else /* USED_TOUCH_TUNING_PROCESS */
;;;955    			SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_DISABLE;
;;;956    	#endif /* USED_TOUCH_TUNING_PROCESS */
;;;957    			SCRB->PWM_INT_CTRL.tBit.int_en_tsyncin = PWM_INTR_DISABLE;
;;;958    			SCRB->PWM_INT_CTRL.tBit.int_tsyncin_src_sel = PWM_TYNCIN_INT_SOURCE_TSYNC_D;
;;;959    
;;;960    			{
;;;961    				tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
;;;962    				{
;;;963    					{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;964    					{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, DISABLE},
;;;965    					{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, ENABLE},
;;;966    		#if (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL)
;;;967    					{PWMDRV_IRQn, PWMDRV_IRQn_Priority, ENABLE}
;;;968    		#else /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;969    					{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;970    		#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;971    				};
;;;972    				PWMDRV_ITConfig((tPWM_INTR_CFG_t *)&tPWM_INTR_CFG[0], 4);
;;;973    			}
;;;974    		}
;;;975    		else
;;;976    	#endif /* USED_MNT_S3_MODE_FUNCTION */
;;;977    		{
;;;978    			SCRB->PWM_INT_CTRL.tBit.int_en_pwm_ab = PWM_INTR_DISABLE;
0000ae  f8d40088          LDR      r0,[r4,#0x88]
0000b2  f0200001          BIC      r0,r0,#1
0000b6  f8c40088          STR      r0,[r4,#0x88]
;;;979    			SCRB->PWM_INT_CTRL.tBit.int_en_pwm_frame = PWM_INTR_DISABLE;
0000ba  f8d40088          LDR      r0,[r4,#0x88]
0000be  f0200002          BIC      r0,r0,#2
0000c2  f8c40088          STR      r0,[r4,#0x88]
;;;980    			SCRB->PWM_INT_CTRL.tBit.int_en_tsync_ab = PWM_INTR_DISABLE;
0000c6  f8d40088          LDR      r0,[r4,#0x88]
0000ca  f0200004          BIC      r0,r0,#4
0000ce  f8c40088          STR      r0,[r4,#0x88]
;;;981    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_TPIC_PENEN_ON_OFF_CONTROL)
;;;982    			SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_ENABLE;
0000d2  f8d40088          LDR      r0,[r4,#0x88]
0000d6  f4406080          ORR      r0,r0,#0x400
0000da  f8c40088          STR      r0,[r4,#0x88]
;;;983    	#else /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_TPIC_PENEN_ON_OFF_CONTROL) */
;;;984    			SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_DISABLE;
;;;985    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_TPIC_PENEN_ON_OFF_CONTROL) */
;;;986    
;;;987    	#if USED_TOUCH_TUNING_PROCESS
;;;988    			SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_RISING_EDGE;
;;;989    	#else /* USED_TOUCH_TUNING_PROCESS */
;;;990    			SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_DISABLE;
0000de  f8d40088          LDR      r0,[r4,#0x88]
0000e2  f0200060          BIC      r0,r0,#0x60
0000e6  f8c40088          STR      r0,[r4,#0x88]
;;;991    	#endif /* USED_TOUCH_TUNING_PROCESS */
;;;992    			SCRB->PWM_INT_CTRL.tBit.int_en_tsyncin = PWM_INTR_BOTH_EDGE;
0000ea  f8d40088          LDR      r0,[r4,#0x88]
0000ee  f0400018          ORR      r0,r0,#0x18
0000f2  f8c40088          STR      r0,[r4,#0x88]
;;;993    			SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_DISABLE; // Rising
0000f6  f8d40088          LDR      r0,[r4,#0x88]
0000fa  f42070c0          BIC      r0,r0,#0x180
0000fe  f8c40088          STR      r0,[r4,#0x88]
;;;994    			SCRB->PWM_INT_CTRL.tBit.int_tsyncin_src_sel = PWM_TYNCIN_INT_SOURCE_TSYNC_T;
000102  f8d40088          LDR      r0,[r4,#0x88]
000106  f4207000          BIC      r0,r0,#0x200
00010a  f8c40088          STR      r0,[r4,#0x88]
;;;995    
;;;996    			{
;;;997    		#if USED_DO_NOT_TOUCH_ONLY_DISPLAY
;;;998    				tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
;;;999    				{
;;;1000   					{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;1001   					{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, DISABLE},
;;;1002   					{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, DISABLE},
;;;1003   					{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;1004   				};
;;;1005   		#else /* USED_DO_NOT_TOUCH_ONLY_DISPLAY */
;;;1006   				tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
00010e  482e              LDR      r0,|L5.456|
000110  ad04              ADD      r5,sp,#0x10
;;;1007   				{
;;;1008   		#if USED_TOUCH_TUNING_PROCESS
;;;1009   					{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, ENABLE},
;;;1010   		#else /* USED_TOUCH_TUNING_PROCESS */
;;;1011   					{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;1012   		#endif /* USED_TOUCH_TUNING_PROCESS */
;;;1013   					{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, ENABLE},
;;;1014   					{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, DISABLE},
;;;1015   		#if (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_TPIC_PENEN_ON_OFF_CONTROL)
;;;1016   					{PWMDRV_IRQn, PWMDRV_IRQn_Priority, ENABLE}
;;;1017   		#else /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_TPIC_PENEN_ON_OFF_CONTROL) */
;;;1018   					{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;1019   		#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_TPIC_PENEN_ON_OFF_CONTROL) */
;;;1020   				};
;;;1021   		#endif /* USED_DO_NOT_TOUCH_ONLY_DISPLAY */
;;;1022   				PWMDRV_ITConfig((tPWM_INTR_CFG_t *)&tPWM_INTR_CFG[0], 4);
000112  2404              MOVS     r4,#4
000114  e8b0100e          LDM      r0!,{r1-r3,r12}       ;1006
000118  e88d100e          STM      sp,{r1-r3,r12}        ;1006
00011c  e8b0100e          LDM      r0!,{r1-r3,r12}       ;1006
000120  e885100e          STM      r5,{r1-r3,r12}        ;1006
000124  c80f              LDM      r0,{r0-r3}            ;1006
000126  f10d0c20          ADD      r12,sp,#0x20
00012a  466d              MOV      r5,sp
00012c  e88c000f          STM      r12,{r0-r3}
000130  2000              MOVS     r0,#0
000132  2201              MOVS     r2,#1                 ;904
                  |L5.308|
000134  eb000140          ADD      r1,r0,r0,LSL #1       ;904
000138  eb050181          ADD      r1,r5,r1,LSL #2       ;904
00013c  f9913000          LDRSB    r3,[r1,#0]            ;904
000140  f0030c1f          AND      r12,r3,#0x1f          ;904
000144  fa02fc0c          LSL      r12,r2,r12            ;904
000148  095b              LSRS     r3,r3,#5              ;904
00014a  009b              LSLS     r3,r3,#2              ;904
00014c  f10323e0          ADD      r3,r3,#0xe000e000     ;904
000150  f8c3c280          STR      r12,[r3,#0x280]       ;904
000154  f9913000          LDRSB    r3,[r1,#0]            ;904
000158  f8d1c004          LDR      r12,[r1,#4]           ;904
00015c  2b00              CMP      r3,#0                 ;904
00015e  ea4f1c4c          LSL      r12,r12,#5            ;904
000162  bfb8              IT       LT                    ;904
000164  f003030f          ANDLT    r3,r3,#0xf            ;904
000168  f10323e0          ADD      r3,r3,#0xe000e000     ;904
00016c  bfb4              ITE      LT                    ;904
00016e  f883cd14          STRBLT   r12,[r3,#0xd14]       ;904
000172  f883c400          STRBGE   r12,[r3,#0x400]       ;904
000176  7a0b              LDRB     r3,[r1,#8]            ;904
000178  f9911000          LDRSB    r1,[r1,#0]            ;904
00017c  2b00              CMP      r3,#0                 ;904
00017e  f001031f          AND      r3,r1,#0x1f           ;904
000182  ea4f1151          LSR      r1,r1,#5              ;904
000186  ea4f0181          LSL      r1,r1,#2              ;904
00018a  fa02f303          LSL      r3,r2,r3              ;904
00018e  f10121e0          ADD      r1,r1,#0xe000e000     ;904
000192  bf14              ITE      NE                    ;904
000194  f8c13100          STRNE    r3,[r1,#0x100]        ;904
000198  f8c13180          STREQ    r3,[r1,#0x180]        ;904
00019c  1c40              ADDS     r0,r0,#1              ;904
00019e  42a0              CMP      r0,r4                 ;904
0001a0  d3c8              BCC      |L5.308|
;;;1023   			}
;;;1024   		}
;;;1025   	}
;;;1026   #endif /* USED_OPERATION_STAND_ALONE */
;;;1027   }
0001a2  b00d              ADD      sp,sp,#0x34
0001a4  bd30              POP      {r4,r5,pc}
;;;1028   
                          ENDP

0001a6  0000              DCW      0x0000
                  |L5.424|
                          DCD      PWMDRV_VSync_In_InterruptHandler
                  |L5.428|
                          DCD      Fncp_VSYNC_IN_IRQHandler
                  |L5.432|
                          DCD      PWMDRV_TSync_In_InterruptHandler
                  |L5.436|
                          DCD      Fncp_TSYNC_IN_IRQHandler
                  |L5.440|
                          DCD      PWMDRV_TSync_Out_InterruptHandler
                  |L5.444|
                          DCD      Fncp_TSYNC_OUT_IRQHandler
                  |L5.448|
                          DCD      PWMDRV_PWM_Out_InterruptHandler
                  |L5.452|
                          DCD      Fncp_PWMDRV_IRQHandler
                  |L5.456|
                          DCD      ||.constdata||

                          AREA ||i.PWMDRV_LocalLHBSetting||, CODE, READONLY, ALIGN=2

                  PWMDRV_LocalLHBSetting PROC
;;;1576   
;;;1577   void PWMDRV_LocalLHBSetting(eSENSING_MODE_t _eSensingMode)
000000  b510              PUSH     {r4,lr}
;;;1578   {
000002  4604              MOV      r4,r0
;;;1579   	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000004  f7fffffe          BL       hal_pwmdrv_GetControlConfig
;;;1580   
;;;1581   #if USED_MNT_S3_MODE_FUNCTION
;;;1582   	if(IS_S3_MODE(_eSensingMode))
;;;1583   	{
;;;1584   		PWMDRV->LHB_CONFIG11.ulBulk = g_tCP_S3_LHB_CONFIG11.ulBulk;
;;;1585   		PWMDRV->LHB_CONFIG12.ulBulk = g_tCP_S3_LHB_CONFIG12.ulBulk;
;;;1586   		PWMDRV->LHB_CONFIG13.ulBulk = g_tCP_S3_LHB_CONFIG13.ulBulk;
;;;1587   		PWMDRV->LHB_CONFIG14.ulBulk = g_tCP_S3_LHB_CONFIG14.ulBulk;
;;;1588   
;;;1589   		PWMDRV->LHB_CONFIG21.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG21.ulBulk;
;;;1590   		PWMDRV->LHB_CONFIG22.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG22.ulBulk;
;;;1591   		PWMDRV->LHB_CONFIG23.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG23.ulBulk;
;;;1592   		PWMDRV->LHB_CONFIG24.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG24.ulBulk;
;;;1593   	}
;;;1594   	else
;;;1595   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1596   	{
;;;1597   	#if USED_IDLE_MODE_CONTROL
;;;1598   		if(IS_ACTIVE_MODE(_eSensingMode))
;;;1599   		{
;;;1600   			PWMDRV->LHB_CONFIG11.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG11.ulBulk;
000008  4919              LDR      r1,|L6.112|
00000a  f0140f01          TST      r4,#1                 ;1598
00000e  d00e              BEQ      |L6.46|
000010  f8d02130          LDR      r2,[r0,#0x130]
000014  f8c1209c          STR      r2,[r1,#0x9c]
;;;1601   			PWMDRV->LHB_CONFIG12.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG12.ulBulk;
000018  f8d02134          LDR      r2,[r0,#0x134]
00001c  f8c120a0          STR      r2,[r1,#0xa0]
;;;1602   			PWMDRV->LHB_CONFIG13.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG13.ulBulk;
000020  f8d02138          LDR      r2,[r0,#0x138]
000024  f8c120a4          STR      r2,[r1,#0xa4]
;;;1603   			PWMDRV->LHB_CONFIG14.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG14.ulBulk;
000028  f8d0213c          LDR      r2,[r0,#0x13c]
00002c  e00d              B        |L6.74|
                  |L6.46|
;;;1604   		}
;;;1605   		else
;;;1606   		{
;;;1607   			PWMDRV->LHB_CONFIG11.ulBulk = g_tCP_LHB_CONFIG21.ulBulk;
00002e  4a11              LDR      r2,|L6.116|
000030  6812              LDR      r2,[r2,#0]  ; g_tCP_LHB_CONFIG21
000032  f8c1209c          STR      r2,[r1,#0x9c]
;;;1608   			PWMDRV->LHB_CONFIG12.ulBulk = g_tCP_LHB_CONFIG22.ulBulk;
000036  4a10              LDR      r2,|L6.120|
000038  6812              LDR      r2,[r2,#0]  ; g_tCP_LHB_CONFIG22
00003a  f8c120a0          STR      r2,[r1,#0xa0]
;;;1609   			PWMDRV->LHB_CONFIG13.ulBulk = g_tCP_LHB_CONFIG23.ulBulk;
00003e  4a0f              LDR      r2,|L6.124|
000040  6812              LDR      r2,[r2,#0]  ; g_tCP_LHB_CONFIG23
000042  f8c120a4          STR      r2,[r1,#0xa4]
;;;1610   			PWMDRV->LHB_CONFIG14.ulBulk = g_tCP_LHB_CONFIG24.ulBulk;
000046  4a0e              LDR      r2,|L6.128|
000048  6812              LDR      r2,[r2,#0]  ; g_tCP_LHB_CONFIG24
                  |L6.74|
00004a  f8c120a8          STR      r2,[r1,#0xa8]
;;;1611   		}
;;;1612   	#else /* USED_IDLE_MODE_CONTROL */
;;;1613   		PWMDRV->LHB_CONFIG11.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG11.ulBulk;
;;;1614   		PWMDRV->LHB_CONFIG12.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG12.ulBulk;
;;;1615   		PWMDRV->LHB_CONFIG13.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG13.ulBulk;
;;;1616   		PWMDRV->LHB_CONFIG14.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG14.ulBulk;
;;;1617   	#endif /* USED_IDLE_MODE_CONTROL */
;;;1618   
;;;1619   	#if  USED_LOCAL_IDLE_MODE_CONTROL
;;;1620   		if(IS_ACTIVE_MODE(_eSensingMode))
;;;1621   		{
;;;1622   			PWMDRV->LHB_CONFIG21.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG21.ulBulk;
;;;1623   			PWMDRV->LHB_CONFIG22.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG22.ulBulk;
;;;1624   			PWMDRV->LHB_CONFIG23.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG23.ulBulk;
;;;1625   			PWMDRV->LHB_CONFIG24.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG24.ulBulk;
;;;1626   		}
;;;1627   		else
;;;1628   		{
;;;1629   			PWMDRV->LHB_CONFIG21.ulBulk = g_tCP_LHB_CONFIG21.ulBulk;
;;;1630   			PWMDRV->LHB_CONFIG22.ulBulk = g_tCP_LHB_CONFIG22.ulBulk;
;;;1631   			PWMDRV->LHB_CONFIG23.ulBulk = g_tCP_LHB_CONFIG23.ulBulk;
;;;1632   			PWMDRV->LHB_CONFIG24.ulBulk = g_tCP_LHB_CONFIG24.ulBulk;
;;;1633   		}
;;;1634   	#else /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1635   		PWMDRV->LHB_CONFIG21.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG21.ulBulk;
00004e  f8d02140          LDR      r2,[r0,#0x140]
000052  f8c120ac          STR      r2,[r1,#0xac]
;;;1636   		PWMDRV->LHB_CONFIG22.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG22.ulBulk;
000056  f8d02144          LDR      r2,[r0,#0x144]
00005a  f8c120b0          STR      r2,[r1,#0xb0]
;;;1637   		PWMDRV->LHB_CONFIG23.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG23.ulBulk;
00005e  f8d02148          LDR      r2,[r0,#0x148]
000062  f8c120b4          STR      r2,[r1,#0xb4]
;;;1638   		PWMDRV->LHB_CONFIG24.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG24.ulBulk;
000066  f8d0014c          LDR      r0,[r0,#0x14c]
00006a  f8c100b8          STR      r0,[r1,#0xb8]
;;;1639   	#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1640   	}
;;;1641   }
00006e  bd10              POP      {r4,pc}
;;;1642   
                          ENDP

                  |L6.112|
                          DCD      0x40002000
                  |L6.116|
                          DCD      ||.data||
                  |L6.120|
                          DCD      ||.data||+0x4
                  |L6.124|
                          DCD      ||.data||+0x8
                  |L6.128|
                          DCD      ||.data||+0xc

                          AREA ||i.PWMDRV_PWM_Out_InterruptHandler||, CODE, READONLY, ALIGN=1

                  PWMDRV_PWM_Out_InterruptHandler PROC
;;;836    
;;;837    void PWMDRV_PWM_Out_InterruptHandler(void)
000000  b510              PUSH     {r4,lr}
;;;838    {
;;;839    	if(SCRB->SYS_INT_ST.tBit.r_pwm_ab_intr != 0)
000002  f04f4480          MOV      r4,#0x40000000
000006  69a0              LDR      r0,[r4,#0x18]
000008  f4100f80          TST      r0,#0x400000
00000c  d005              BEQ      |L7.26|
;;;840    	{
;;;841    		SCRB->PWM_INT_CLR.tBit.pwm_ab_int_clr = 0x1;
00000e  f8d4008c          LDR      r0,[r4,#0x8c]
000012  f0400001          ORR      r0,r0,#1
000016  f8c4008c          STR      r0,[r4,#0x8c]
                  |L7.26|
;;;842    	}
;;;843    
;;;844    	if(SCRB->SYS_INT_ST.tBit.r_pwm_frame_intr != 0)
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  f4101f00          TST      r0,#0x200000
000020  d005              BEQ      |L7.46|
;;;845    	{
;;;846    		SCRB->PWM_INT_CLR.tBit.pwm_frame_int_clr = 0x1;
000022  f8d4008c          LDR      r0,[r4,#0x8c]
000026  f0400002          ORR      r0,r0,#2
00002a  f8c4008c          STR      r0,[r4,#0x8c]
                  |L7.46|
;;;847    	}
;;;848    
;;;849    	if(SCRB->SYS_INT_ST2.tBit.int_lhb != 0)
00002e  f8d40098          LDR      r0,[r4,#0x98]
000032  f0100f01          TST      r0,#1
;;;850    	{
;;;851    #if (USED_TPIC_MUXEN_ON_OFF_CONTROL && USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM)
;;;852    		if(HAL_GetTPICMuxEnControl())
;;;853    		{
;;;854    			// MUX EN Code Add
;;;855    	#if USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE
;;;856    			if(IS_ACTIVE_MODE(HAL_GetSensingMode()))
;;;857    			{
;;;858    				SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;859    			}
;;;860    			else
;;;861    			{
;;;862    				SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;863    			}
;;;864    	#else /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;865    			SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;866    //			_gOut(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;867    	#endif /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;868    	#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;869    			GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_LOW);
;;;870    	#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;871    		}
;;;872    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM) */
;;;873    
;;;874    #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;875    		if(HAL_GetTPICPenEnControl())
;;;876    		{
;;;877    //			uint32_t ulTPIC_PenEnSetCheckBitMask;
;;;878    //			ulTPIC_PenEnSetCheckBitMask = tHalIntrHandle.ulPenEnControlByTsyncIdxBitMask[0];
;;;879    
;;;880    //			if(ulTPIC_PenEnSetCheckBitMask & (1<<tHalIntrHandle.ulTSyncInFallingCnt))
;;;881    //			{
;;;882    				SET_GPIO_PEN_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;883    //			}
;;;884    		}
;;;885    #endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;886    
;;;887    
;;;888    
;;;889    #if USED_PWM_PULSE_END_FLAG_CHECK
;;;890    		tHalIntrHandle.ulPWM_Pulse_End_Flag = YES;
;;;891    #endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;892    
;;;893    		SCRB->PWM_INT_CLR.tBit.lhb_int_clr = 0x1;
;;;894    	}
;;;895    }
000036  bf08              IT       EQ
000038  bd10              POPEQ    {r4,pc}
00003a  f7fffffe          BL       HAL_GetTPICMuxEnControl
00003e  b128              CBZ      r0,|L7.76|
000040  f8d40124          LDR      r0,[r4,#0x124]        ;865
000044  f0206080          BIC      r0,r0,#0x4000000      ;865
000048  f8c40124          STR      r0,[r4,#0x124]        ;865
                  |L7.76|
00004c  f8d4008c          LDR      r0,[r4,#0x8c]         ;893
000050  f0400040          ORR      r0,r0,#0x40           ;893
000054  f8c4008c          STR      r0,[r4,#0x8c]         ;893
000058  bd10              POP      {r4,pc}
;;;896    
                          ENDP


                          AREA ||i.PWMDRV_RegisterInit||, CODE, READONLY, ALIGN=2

                  PWMDRV_RegisterInit PROC
;;;1028   
;;;1029   void PWMDRV_RegisterInit(eSENSING_MODE_t _eSensingMode, bool_t bIsInit)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1030   {
000002  b083              SUB      sp,sp,#0xc
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
;;;1031   	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000008  f7fffffe          BL       hal_pwmdrv_GetControlConfig
00000c  4604              MOV      r4,r0
;;;1032   	tCP_PWMGEN_CR0_t tCP_PWMGEN_CR0;
;;;1033   	tCP_PWMGEN_CR1_t tCP_PWMGEN_CR1;
;;;1034   	tCP_PWMGEN_CR2_t tCP_PWMGEN_CR2;
;;;1035   	tCP_TSYNC_CR_t tCP_TSYNC_CR;
;;;1036   
;;;1037   	tCP_PWMGEN_CR0.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR0.ulBulk;
00000e  6800              LDR      r0,[r0,#0]
000010  9000              STR      r0,[sp,#0]
;;;1038   
;;;1039   #if USED_MNT_S3_MODE_FUNCTION
;;;1040   	if(IS_S3_MODE(_eSensingMode))
;;;1041   	{
;;;1042   		tCP_PWMGEN_CR0.tBit.pen_mode = (PWM_FULL_FINGER_MODE);
;;;1043   		PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1044   		PWMDRV->PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1045   		PWMDRV->PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_Idle_total_mux_num;
;;;1046   		PWMDRV->PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_Idle_finger_pwmnum;
;;;1047   
;;;1048   
;;;1049   		PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1050   		PWMDRV->TSYNC_CR.tBit.tsync_num = 0;
;;;1051   		PWMDRV->TSYNC_CR.tBit.tsynct_in_sel = PWM_TSYNC_INTR_INTERNAL;
;;;1052   		PWMDRV->TSYNC_CR.tBit.tsynct_in_inv = 0;
;;;1053   		PWMDRV->TSYNC_CR.tBit.tsync_sric_in_sel = PWM_TSYNC_SRIC_INTR_INTERNAL;
;;;1054   		PWMDRV->TSYNC_CR.tBit.tsync_sric_out_inv = 0;
;;;1055   		{
;;;1056   #define TSYNCGEN_TIMING_DIV_VALUE		(534)
;;;1057   			uint32_t ulTotal_Time_usec;
;;;1058   //			ulTotal_Time_usec = (1000*1000/S3_MODE_FRAME_RATE_Hz)>>1; // 1LHB of 2LHB?? (/2)
;;;1059   //			PWMDRV->TE_TCH_T_HIGH = ((ulTotal_Time_usec-S3_MODE_TOUCH_TIME_usec)*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1060   //			PWMDRV->TE_TCH_D_HIGH = ((ulTotal_Time_usec-S3_MODE_TOUCH_TIME_usec)*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1061   //			PWMDRV->TE_TCH_LOW = (S3_MODE_TOUCH_TIME_usec*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1062   
;;;1063   			ulTotal_Time_usec = (1000*1000/S3_MODE_FRAME_RATE_Hz); // 1LHB of 1LHB
;;;1064   			PWMDRV->TE_TCH_T_HIGH = (S3_MODE_TOUCH_TIME_usec*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1065   			PWMDRV->TE_TCH_D_HIGH = (S3_MODE_TOUCH_TIME_usec*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1066   			PWMDRV->TE_TCH_LOW = ((ulTotal_Time_usec-S3_MODE_TOUCH_TIME_usec)*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1067   #undef TSYNCGEN_TIMING_DIV_VALUE
;;;1068   		}
;;;1069   //		PWMDRV->TE_TCH_T_HIGH = 3933;//ptHalPwmdrvControlConf->tCP_TE_TCH_T_HIGH;
;;;1070   //		PWMDRV->TE_TCH_D_HIGH = 2000;//ptHalPwmdrvControlConf->tCP_TE_TCH_D_HIGH;
;;;1071   //		PWMDRV->TE_TCH_LOW = 749;//ptHalPwmdrvControlConf->tCP_TE_TCH_LOW;
;;;1072   	}
;;;1073   	else
;;;1074   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1075   	{
;;;1076   	#if USED_PEN_MODE_OPERATION
;;;1077   		if(IS_FINGER_PEN_MODE(_eSensingMode))
;;;1078   		{
;;;1079   			tCP_PWMGEN_CR0.tBit.pen_mode = (PWM_LOCAL_PEN_MODE);
;;;1080   			if(IS_ACTIVE_MODE(_eSensingMode))
;;;1081   			{
;;;1082   				/*
;;;1083   				 * PWM Pulse Setting
;;;1084   				 */
;;;1085   		#if USED_NOISE_HOPPING_FREQ
;;;1086   				if(IS_ACTIVE_MODE_FRQ_MAIN(_eSensingMode))
;;;1087   				{
;;;1088   					PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1089   					PWMDRV->PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1090   				}
;;;1091   				else if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
;;;1092   				{
;;;1093   					tCP_PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1094   					tCP_PWMGEN_CR1.tBit.sric_dummy_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_HOPP1_sric_dummy_num;
;;;1095   					tCP_PWMGEN_CR1.tBit.tpic_dummy_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_HOPP1_tpic_dummy_num;
;;;1096   					tCP_PWMGEN_CR1.tBit.pen_s_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_HOPP1_pen_s_pwmnum;
;;;1097   					PWMDRV->PWMGEN_CR1.ulBulk = tCP_PWMGEN_CR1.ulBulk;
;;;1098   
;;;1099   					tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1100   					tCP_PWMGEN_CR2.tBit.pen_d_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_HOPP1_pen_d_pwmnum;
;;;1101   					tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_HoppFrq_finger_pwmnum;
;;;1102   					PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1103   
;;;1104   				}
;;;1105   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1106   		#else /* USED_NOISE_HOPPING_FREQ */
;;;1107   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1108   				PWMDRV->PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1109   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1110   		#endif /* USED_NOISE_HOPPING_FREQ */
;;;1111   			}
;;;1112   		#if USED_LOCAL_IDLE_MODE_CONTROL
;;;1113   			else
;;;1114   			{
;;;1115   				/*
;;;1116   				 * PWM Pulse Setting
;;;1117   				 */
;;;1118   				tCP_PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1119   				tCP_PWMGEN_CR1.tBit.sric_dummy_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_sric_idle_dummy_num;
;;;1120   				tCP_PWMGEN_CR1.tBit.tpic_dummy_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_tpic_idle_dummy_num;
;;;1121   				tCP_PWMGEN_CR1.tBit.pen_s_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_pen_s_idle_pwmnum;
;;;1122   				PWMDRV->PWMGEN_CR1.ulBulk = tCP_PWMGEN_CR1.ulBulk;
;;;1123   
;;;1124   				tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1125   				tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_num;
;;;1126   				tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_total_mux_num;
;;;1127   				PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1128   
;;;1129   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1130   				PWMDRV->TSYNC_CR.tBit.tsync_num = (LOCAL_IDLE_LHB_NUM-1);
;;;1131   			}
;;;1132   		#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1133   		}
;;;1134   		else
;;;1135   	#endif /* USED_PEN_MODE_OPERATION */
;;;1136   		{
;;;1137   			tCP_PWMGEN_CR0.tBit.pen_mode = (PWM_FULL_FINGER_MODE);
000012  f89d0002          LDRB     r0,[sp,#2]
;;;1138   			if(IS_ACTIVE_MODE(_eSensingMode))
000016  f0160f01          TST      r6,#1
00001a  f0200002          BIC      r0,r0,#2              ;1137
00001e  f88d0002          STRB     r0,[sp,#2]            ;1137
;;;1139   			{
;;;1140   	#if IS_MSPEN_PROTOCOL_OPERATION
;;;1141   		#if USED_NOISE_HOPPING_FREQ
;;;1142   				if(IS_ACTIVE_MODE_FRQ_MAIN(_eSensingMode))
;;;1143   				{
;;;1144   					/*
;;;1145   					 * PWM Pulse Setting
;;;1146   					 */
;;;1147   					PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1148   					tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1149   					tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_MPP_PWMGEN_CR2_total_mux_num;
;;;1150   					PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1151   				}
;;;1152   				else if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
;;;1153   				{
;;;1154   					/*
;;;1155   					 * PWM Pulse Setting
;;;1156   					 */
;;;1157   			#if USED_PEN_MODE_OPERATION
;;;1158   					tCP_PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1159   					tCP_PWMGEN_CR1.tBit.sric_dummy_num = PARAMSET_PWMDRV_MPP_PWMGEN_CR1_HOPP1_sric_dummy_num;
;;;1160   					tCP_PWMGEN_CR1.tBit.tpic_dummy_num = PARAMSET_PWMDRV_MPP_PWMGEN_CR1_HOPP1_tpic_dummy_num;
;;;1161   					tCP_PWMGEN_CR1.tBit.pen_s_pwmnum = PARAMSET_PWMDRV_MPP_PWMGEN_CR1_HOPP1_pen_s_pwmnum;
;;;1162   					PWMDRV->PWMGEN_CR1.ulBulk = tCP_PWMGEN_CR1.ulBulk;
;;;1163   			#else /* USED_PEN_MODE_OPERATION */
;;;1164   					PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1165   			#endif /* USED_PEN_MODE_OPERATION */
;;;1166   
;;;1167   					tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1168   					tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_MPP_PWMGEN_CR2_HoppFrq_finger_pwmnum;
;;;1169   					tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_MPP_PWMGEN_CR2_total_mux_num;
;;;1170   					PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1171   				}
;;;1172   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1173   		#else /* USED_NOISE_HOPPING_FREQ */
;;;1174   				/*
;;;1175   				 * PWM Pulse Setting
;;;1176   				 */
;;;1177   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1178   				tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1179   				tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_MPP_PWMGEN_CR2_total_mux_num;
;;;1180   				PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1181   
;;;1182   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1183   		#endif /* USED_NOISE_HOPPING_FREQ */
;;;1184   	#else /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1185   		#if USED_NOISE_HOPPING_FREQ
;;;1186   				if(IS_ACTIVE_MODE_FRQ_MAIN(_eSensingMode))
;;;1187   				{
;;;1188   					/*
;;;1189   					 * PWM Pulse Setting
;;;1190   					 */
;;;1191   					PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
000022  4dfe              LDR      r5,|L8.1052|
000024  d07e              BEQ      |L8.292|
000026  f0160f02          TST      r6,#2                 ;1186
00002a  d00e              BEQ      |L8.74|
00002c  6860              LDR      r0,[r4,#4]
00002e  6068              STR      r0,[r5,#4]
;;;1192   					tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
000030  68a0              LDR      r0,[r4,#8]
000032  9001              STR      r0,[sp,#4]
;;;1193   					tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_total_mux_num;
000034  f8bd0006          LDRH     r0,[sp,#6]
000038  f42060fc          BIC      r0,r0,#0x7e0
00003c  f5007020          ADD      r0,r0,#0x280
000040  f8ad0006          STRH     r0,[sp,#6]
;;;1194   					PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
000044  9801              LDR      r0,[sp,#4]
000046  60a8              STR      r0,[r5,#8]
000048  e02f              B        |L8.170|
                  |L8.74|
;;;1195   				}
;;;1196   				else if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
00004a  f0160f04          TST      r6,#4
00004e  d02c              BEQ      |L8.170|
;;;1197   				{
;;;1198   					/*
;;;1199   					 * PWM Pulse Setting
;;;1200   					 */
;;;1201   			#if USED_PEN_MODE_OPERATION || USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;1202   					tCP_PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
000050  6860              LDR      r0,[r4,#4]
000052  9001              STR      r0,[sp,#4]
;;;1203   					tCP_PWMGEN_CR1.tBit.sric_dummy_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_HOPP1_sric_dummy_num;
000054  f89d0005          LDRB     r0,[sp,#5]
000058  f02000fc          BIC      r0,r0,#0xfc
00005c  300c              ADDS     r0,r0,#0xc
00005e  f88d0005          STRB     r0,[sp,#5]
;;;1204   					tCP_PWMGEN_CR1.tBit.tpic_dummy_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_HOPP1_tpic_dummy_num;
000062  f89d0006          LDRB     r0,[sp,#6]
000066  f020003f          BIC      r0,r0,#0x3f
00006a  1cc0              ADDS     r0,r0,#3
00006c  f88d0006          STRB     r0,[sp,#6]
;;;1205   					tCP_PWMGEN_CR1.tBit.pen_s_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR1_HOPP1_pen_s_pwmnum;
000070  f89d0007          LDRB     r0,[sp,#7]
000074  f020007f          BIC      r0,r0,#0x7f
000078  300f              ADDS     r0,r0,#0xf
00007a  f88d0007          STRB     r0,[sp,#7]
;;;1206   					PWMDRV->PWMGEN_CR1.ulBulk = tCP_PWMGEN_CR1.ulBulk;
00007e  9801              LDR      r0,[sp,#4]
000080  6068              STR      r0,[r5,#4]
;;;1207   			#else /* USED_PEN_MODE_OPERATION */
;;;1208   					PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1209   			#endif /* USED_PEN_MODE_OPERATION */
;;;1210   
;;;1211   					tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
000082  68a0              LDR      r0,[r4,#8]
000084  9001              STR      r0,[sp,#4]
;;;1212   					tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_HoppFrq_finger_pwmnum;
000086  f8bd0004          LDRH     r0,[sp,#4]
00008a  f420507e          BIC      r0,r0,#0x3f80
00008e  f5006000          ADD      r0,r0,#0x800
000092  f8ad0004          STRH     r0,[sp,#4]
;;;1213   					tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_total_mux_num;
000096  f8bd0006          LDRH     r0,[sp,#6]
00009a  f42060fc          BIC      r0,r0,#0x7e0
00009e  f5007020          ADD      r0,r0,#0x280
0000a2  f8ad0006          STRH     r0,[sp,#6]
;;;1214   					PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
0000a6  9801              LDR      r0,[sp,#4]
0000a8  60a8              STR      r0,[r5,#8]
                  |L8.170|
;;;1215   				}
;;;1216   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
0000aa  6920              LDR      r0,[r4,#0x10]
                  |L8.172|
;;;1217   		#else /* USED_NOISE_HOPPING_FREQ */
;;;1218   				/*
;;;1219   				 * PWM Pulse Setting
;;;1220   				 */
;;;1221   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1222   				tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1223   				tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_total_mux_num;
;;;1224   				PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1225   
;;;1226   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1227   		#endif /* USED_NOISE_HOPPING_FREQ */
;;;1228   	#endif /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1229   			}
;;;1230   	#if USED_IDLE_MODE_CONTROL
;;;1231   			else
;;;1232   			{
;;;1233   				/*
;;;1234   				 * PWM Pulse Setting
;;;1235   				 */
;;;1236   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1237   				tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1238   				tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_num;
;;;1239   				tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_total_mux_num;
;;;1240   				PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1241   
;;;1242   				tCP_TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1243   				tCP_TSYNC_CR.tBit.tsync_num = LOCAL_IDLE_LHB_NUM - 1;
;;;1244   				PWMDRV->TSYNC_CR.ulBulk = tCP_TSYNC_CR.ulBulk;
0000ac  6128              STR      r0,[r5,#0x10]
;;;1245   			}
;;;1246   	#endif /* USED_IDLE_MODE_CONTROL */
;;;1247   		}
;;;1248   
;;;1249   		PWMDRV->TE_TCH_T_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_T_HIGH;
0000ae  f8d40168          LDR      r0,[r4,#0x168]
0000b2  f8c500d4          STR      r0,[r5,#0xd4]
;;;1250   		PWMDRV->TE_TCH_D_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_D_HIGH;
0000b6  f8d4016c          LDR      r0,[r4,#0x16c]
0000ba  f8c500d8          STR      r0,[r5,#0xd8]
;;;1251   		PWMDRV->TE_TCH_LOW = ptHalPwmdrvControlConf->tCP_TE_TCH_LOW;
0000be  f8d40170          LDR      r0,[r4,#0x170]
0000c2  f8c500dc          STR      r0,[r5,#0xdc]
;;;1252   	}
;;;1253   
;;;1254   	PWMDRV->PWMGEN_CR0.ulBulk = tCP_PWMGEN_CR0.ulBulk;
0000c6  9800              LDR      r0,[sp,#0]
0000c8  6028              STR      r0,[r5,#0]
;;;1255   	PWMDRV->SET_TX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_SET_TX_CR.ulBulk;
0000ca  68e0              LDR      r0,[r4,#0xc]
0000cc  60e8              STR      r0,[r5,#0xc]
;;;1256   	PWMDRV->TSYNC_D2_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_D2_CR.ulBulk;
0000ce  6960              LDR      r0,[r4,#0x14]
0000d0  6168              STR      r0,[r5,#0x14]
;;;1257   	PWMDRV->DLY_CNT1.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT1.ulBulk;
0000d2  69a0              LDR      r0,[r4,#0x18]
0000d4  61a8              STR      r0,[r5,#0x18]
;;;1258   	PWMDRV->DLY_CNT2.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT2.ulBulk;
0000d6  69e0              LDR      r0,[r4,#0x1c]
0000d8  61e8              STR      r0,[r5,#0x1c]
;;;1259   	PWMDRV->DLY_CNT3.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT3.ulBulk;
0000da  6a20              LDR      r0,[r4,#0x20]
0000dc  6228              STR      r0,[r5,#0x20]
;;;1260   	PWMDRV->TSYNC_TPIC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_TPIC_CR.ulBulk;
0000de  6a60              LDR      r0,[r4,#0x24]
0000e0  6268              STR      r0,[r5,#0x24]
;;;1261   	PWMDRV->PWM_DLY1.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY1.ulBulk;
0000e2  6aa0              LDR      r0,[r4,#0x28]
0000e4  62a8              STR      r0,[r5,#0x28]
;;;1262   	PWMDRV->DSSS_INFO0.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO0.ulBulk;
0000e6  6ae0              LDR      r0,[r4,#0x2c]
0000e8  62e8              STR      r0,[r5,#0x2c]
;;;1263   	PWMDRV->PWM_TPIC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_TPIC_CR.ulBulk;
0000ea  f8d40118          LDR      r0,[r4,#0x118]
0000ee  f8c50080          STR      r0,[r5,#0x80]
;;;1264   	PWMDRV->PWM_SRIC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_SRIC_CR.ulBulk;
0000f2  f8d4011c          LDR      r0,[r4,#0x11c]
0000f6  f8c50084          STR      r0,[r5,#0x84]
;;;1265   	PWMDRV->PWM_MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_MUX_CR.ulBulk;
0000fa  f8d40120          LDR      r0,[r4,#0x120]
0000fe  f8c50088          STR      r0,[r5,#0x88]
;;;1266   #if USED_NOISE_HOPPING_FREQ
;;;1267   	{
;;;1268   		if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
000102  f0160f04          TST      r6,#4
000106  d045              BEQ      |L8.404|
;;;1269   		{
;;;1270   	#if IS_MSPEN_PROTOCOL_OPERATION
;;;1271   			PWMDRV->DMY_FREQ = PARAMSET_PWMDRV_MPP_HOPP1_DMY_FREQ;
;;;1272   			tCP_FREQ_CR1_t tCP_FREQ_CR1;
;;;1273   			tCP_FREQ_CR1.tBit.pen_s = PARAMSET_PWMDRV_MPP_HOPP1_PEN_POS_FREQ;
;;;1274   			tCP_FREQ_CR1.tBit.pen_d = PARAMSET_PWMDRV_MPP_HOPP1_PEN_DAT_FREQ;
;;;1275   			tCP_FREQ_CR1.tBit.finger = PARAMSET_PWMDRV_MPP_HOPP1_FINGER_FREQ;
;;;1276   			PWMDRV->FREQ_CR1.ulBulk = tCP_FREQ_CR1.ulBulk;
;;;1277   			PWMDRV->FREQ_CR2.tBit.freq_beacon = PARAMSET_PWMDRV_MPP_HOPP1_Beacon_FREQ;
;;;1278   	#else /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1279   			PWMDRV->DMY_FREQ = PARAMSET_PWMDRV_WGP_HOPP1_DMY_FREQ;
000108  20b3              MOVS     r0,#0xb3
00010a  f8c50090          STR      r0,[r5,#0x90]
;;;1280   			tCP_FREQ_CR1_t tCP_FREQ_CR1;
;;;1281   			tCP_FREQ_CR1.tBit.pen_s = PARAMSET_PWMDRV_WGP_HOPP1_PEN_POS_FREQ;
00010e  f8bd0001          LDRH     r0,[sp,#1]
000112  f36f008b          BFC      r0,#2,#10
000116  f5007033          ADD      r0,r0,#0x2cc
00011a  f8ad0001          STRH     r0,[sp,#1]
;;;1282   			tCP_FREQ_CR1.tBit.pen_d = PARAMSET_PWMDRV_WGP_HOPP1_PEN_DAT_FREQ;
00011e  f8bd0000          LDRH     r0,[sp,#0]
000122  e000              B        |L8.294|
                  |L8.292|
000124  e015              B        |L8.338|
                  |L8.294|
000126  f400407c          AND      r0,r0,#0xfc00
00012a  30b3              ADDS     r0,r0,#0xb3
00012c  f8ad0000          STRH     r0,[sp,#0]
;;;1283   			tCP_FREQ_CR1.tBit.finger = PARAMSET_PWMDRV_WGP_HOPP1_FINGER_FREQ;
000130  f8bd0002          LDRH     r0,[sp,#2]
000134  f36f100d          BFC      r0,#4,#10
000138  f5006033          ADD      r0,r0,#0xb30
00013c  f8ad0002          STRH     r0,[sp,#2]
;;;1284   			PWMDRV->FREQ_CR1.ulBulk = tCP_FREQ_CR1.ulBulk;
000140  9800              LDR      r0,[sp,#0]
000142  f8c50094          STR      r0,[r5,#0x94]
;;;1285   			PWMDRV->FREQ_CR2.tBit.freq_beacon = PARAMSET_PWMDRV_WGP_HOPP1_Beacon_FREQ;
000146  f8d50098          LDR      r0,[r5,#0x98]
00014a  f02000ff          BIC      r0,r0,#0xff
00014e  3059              ADDS     r0,r0,#0x59
;;;1286   	#endif /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1287   		}
000150  e02a              B        |L8.424|
                  |L8.338|
000152  6860              LDR      r0,[r4,#4]            ;1236
000154  6068              STR      r0,[r5,#4]            ;1236
000156  68a0              LDR      r0,[r4,#8]            ;1237
000158  9001              STR      r0,[sp,#4]            ;1237
00015a  f8bd0004          LDRH     r0,[sp,#4]            ;1238
00015e  f420507e          BIC      r0,r0,#0x3f80         ;1238
000162  f50060a0          ADD      r0,r0,#0x500          ;1238
000166  f8ad0004          STRH     r0,[sp,#4]            ;1238
00016a  f8bd0006          LDRH     r0,[sp,#6]            ;1239
00016e  f42060fc          BIC      r0,r0,#0x7e0          ;1239
000172  f50070c0          ADD      r0,r0,#0x180          ;1239
000176  f8ad0006          STRH     r0,[sp,#6]            ;1239
00017a  9801              LDR      r0,[sp,#4]            ;1240
00017c  60a8              STR      r0,[r5,#8]            ;1240
00017e  6920              LDR      r0,[r4,#0x10]         ;1242
000180  9001              STR      r0,[sp,#4]            ;1242
000182  f89d0004          LDRB     r0,[sp,#4]            ;1243
000186  f020001f          BIC      r0,r0,#0x1f           ;1243
00018a  300f              ADDS     r0,r0,#0xf            ;1243
00018c  f88d0004          STRB     r0,[sp,#4]            ;1243
000190  9801              LDR      r0,[sp,#4]            ;1244
000192  e78b              B        |L8.172|
                  |L8.404|
;;;1288   		else
;;;1289   		{
;;;1290   			PWMDRV->DMY_FREQ = ptHalPwmdrvControlConf->tCP_DMY_FREQ;
000194  f8d40124          LDR      r0,[r4,#0x124]
000198  f8c50090          STR      r0,[r5,#0x90]
;;;1291   			PWMDRV->FREQ_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_FREQ_CR1.ulBulk;
00019c  f8d40128          LDR      r0,[r4,#0x128]
0001a0  f8c50094          STR      r0,[r5,#0x94]
;;;1292   			PWMDRV->FREQ_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_FREQ_CR2.ulBulk;
0001a4  f8d4012c          LDR      r0,[r4,#0x12c]
                  |L8.424|
0001a8  f8c50098          STR      r0,[r5,#0x98]
0001ac  f7fffffe          BL       hal_pwmdrv_GetControlConfig
0001b0  f0160f01          TST      r6,#1
0001b4  d00e              BEQ      |L8.468|
0001b6  f8d01130          LDR      r1,[r0,#0x130]
0001ba  f8c5109c          STR      r1,[r5,#0x9c]
0001be  f8d01134          LDR      r1,[r0,#0x134]
0001c2  f8c510a0          STR      r1,[r5,#0xa0]
0001c6  f8d01138          LDR      r1,[r0,#0x138]
0001ca  f8c510a4          STR      r1,[r5,#0xa4]
0001ce  f8d0113c          LDR      r1,[r0,#0x13c]
0001d2  e00d              B        |L8.496|
                  |L8.468|
0001d4  4992              LDR      r1,|L8.1056|
0001d6  6809              LDR      r1,[r1,#0]  ; g_tCP_LHB_CONFIG21
0001d8  f8c5109c          STR      r1,[r5,#0x9c]
0001dc  4991              LDR      r1,|L8.1060|
0001de  6809              LDR      r1,[r1,#0]  ; g_tCP_LHB_CONFIG22
0001e0  f8c510a0          STR      r1,[r5,#0xa0]
0001e4  4990              LDR      r1,|L8.1064|
0001e6  6809              LDR      r1,[r1,#0]  ; g_tCP_LHB_CONFIG23
0001e8  f8c510a4          STR      r1,[r5,#0xa4]
0001ec  498f              LDR      r1,|L8.1068|
0001ee  6809              LDR      r1,[r1,#0]  ; g_tCP_LHB_CONFIG24
                  |L8.496|
0001f0  f8c510a8          STR      r1,[r5,#0xa8]
0001f4  f8d01140          LDR      r1,[r0,#0x140]
0001f8  f8c510ac          STR      r1,[r5,#0xac]
0001fc  f8d01144          LDR      r1,[r0,#0x144]
000200  f8c510b0          STR      r1,[r5,#0xb0]
000204  f8d01148          LDR      r1,[r0,#0x148]
000208  f8c510b4          STR      r1,[r5,#0xb4]
00020c  f8d0014c          LDR      r0,[r0,#0x14c]
000210  f8c500b8          STR      r0,[r5,#0xb8]
;;;1293   		}
;;;1294   	}
;;;1295   #else
;;;1296   	PWMDRV->DMY_FREQ = ptHalPwmdrvControlConf->tCP_DMY_FREQ;
;;;1297   	PWMDRV->FREQ_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_FREQ_CR1.ulBulk;
;;;1298   	PWMDRV->FREQ_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_FREQ_CR2.ulBulk;
;;;1299   #endif
;;;1300   
;;;1301   	PWMDRV_LocalLHBSetting(_eSensingMode);
;;;1302   	PWMDRV->PING_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PING_CR.ulBulk;
000214  f8d40150          LDR      r0,[r4,#0x150]
000218  f8c500bc          STR      r0,[r5,#0xbc]
;;;1303   	PWMDRV->SYNC_GEN_CR.ulBulk = ptHalPwmdrvControlConf->tCP_SYNC_GEN_CR.ulBulk;
00021c  f8d40154          LDR      r0,[r4,#0x154]
000220  f8c500c0          STR      r0,[r5,#0xc0]
;;;1304   	PWMDRV->TE_RDY_CNT = ptHalPwmdrvControlConf->tCP_TE_RDY_CNT;
000224  f8d40158          LDR      r0,[r4,#0x158]
000228  f8c500c4          STR      r0,[r5,#0xc4]
;;;1305   	PWMDRV->TE_TCH_V_FPCH = ptHalPwmdrvControlConf->tCP_TE_TCH_V_FPCH;
00022c  f8d4015c          LDR      r0,[r4,#0x15c]
000230  f8c500c8          STR      r0,[r5,#0xc8]
;;;1306   	PWMDRV->TE_TCH_V_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_V_HIGH;
000234  f8d40160          LDR      r0,[r4,#0x160]
000238  f8c500cc          STR      r0,[r5,#0xcc]
;;;1307   	PWMDRV->TE_TCH_FPCH = ptHalPwmdrvControlConf->tCP_TE_TCH_FPCH;
00023c  f8d40164          LDR      r0,[r4,#0x164]
000240  f8c500d0          STR      r0,[r5,#0xd0]
;;;1308   //	PWMDRV->TE_TCH_T_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_T_HIGH;
;;;1309   //	PWMDRV->TE_TCH_D_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_D_HIGH;
;;;1310   //	PWMDRV->TE_TCH_LOW = ptHalPwmdrvControlConf->tCP_TE_TCH_LOW;
;;;1311   	PWMDRV->TE_TCH_BPCH = ptHalPwmdrvControlConf->tCP_TE_TCH_BPCH;
000244  f8d40174          LDR      r0,[r4,#0x174]
000248  f8c500e0          STR      r0,[r5,#0xe0]
;;;1312   	PWMDRV->TE_TCH_PD_LOW = ptHalPwmdrvControlConf->tCP_TE_TCH_PD_LOW;
00024c  f8d40178          LDR      r0,[r4,#0x178]
000250  f8c500e4          STR      r0,[r5,#0xe4]
;;;1313   	PWMDRV->TG_DUM1 = ptHalPwmdrvControlConf->tCP_TG_DUM1;
000254  f8d4017c          LDR      r0,[r4,#0x17c]
000258  f8c500ec          STR      r0,[r5,#0xec]
;;;1314   	PWMDRV->TG_DUM2 = ptHalPwmdrvControlConf->tCP_TG_DUM2;
00025c  f8d40180          LDR      r0,[r4,#0x180]
000260  f8c500f0          STR      r0,[r5,#0xf0]
;;;1315   	PWMDRV->TG_DUM3 = ptHalPwmdrvControlConf->tCP_TG_DUM3;
000264  f8d40184          LDR      r0,[r4,#0x184]
000268  f8c500f4          STR      r0,[r5,#0xf4]
;;;1316   	PWMDRV->TG_DUM4 = ptHalPwmdrvControlConf->tCP_TG_DUM4;
00026c  f8d40188          LDR      r0,[r4,#0x188]
000270  f8c500f8          STR      r0,[r5,#0xf8]
;;;1317   	PWMDRV->TG_DUM5.ulBulk = ptHalPwmdrvControlConf->tCP_TG_DUM5.ulBulk;
000274  f8d4018c          LDR      r0,[r4,#0x18c]
000278  f8c500fc          STR      r0,[r5,#0xfc]
;;;1318   #if USED_MNT_S3_MODE_FUNCTION
;;;1319   	if(IS_S3_MODE(_eSensingMode))
;;;1320   	{
;;;1321   		PWMDRV->TG_DUM5.tBit.tsync_sric_out_bypass_enb = 1; //0:Bypass, 1:Internal Timing
;;;1322   	}
;;;1323   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1324   
;;;1325   	PWMDRV->DISP_OFF_CR.ulBulk = ptHalPwmdrvControlConf->tCP_DISP_OFF_CR.ulBulk;
00027c  f8d40190          LDR      r0,[r4,#0x190]
000280  f8c50100          STR      r0,[r5,#0x100]
;;;1326   #if USED_NOISE_HOPPING_FREQ
;;;1327   	{
;;;1328   		if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
000284  f0160f04          TST      r6,#4
000288  d022              BEQ      |L8.720|
;;;1329   		{
;;;1330   	#if IS_MSPEN_PROTOCOL_OPERATION
;;;1331   			tCP_PWM_CR1_t tCP_PWM_CR1;
;;;1332   			tCP_PWM_CR1.tBit.pen_s_h_pnt = PARAMSET_PWMDRV_MPP_HOPP1_PWM_CR2_pen_s_h_pnt;
;;;1333   			tCP_PWM_CR1.tBit.pen_d_h_pnt = PARAMSET_PWMDRV_MPP_HOPP1_PWM_CR2_pen_d_h_pnt;
;;;1334   			PWMDRV->PWM_CR1.ulBulk = tCP_PWM_CR1.ulBulk;
;;;1335   
;;;1336   			tCP_PWM_CR2_t tCP_PWM_CR2;
;;;1337   			tCP_PWM_CR2.tBit.finger_h_pnt = PARAMSET_PWMDRV_MPP_HOPP1_PWM_CR2_finger_h_pnt;
;;;1338   			tCP_PWM_CR2.tBit.dmy_h_pnt = PARAMSET_PWMDRV_MPP_HOPP1_PWM_CR2_dmy_h_pnt;
;;;1339   			PWMDRV->PWM_CR2.ulBulk = tCP_PWM_CR2.ulBulk;
;;;1340   	#else /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1341   			tCP_PWM_CR1_t tCP_PWM_CR1;
;;;1342   			tCP_PWM_CR1.tBit.pen_s_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_pen_s_h_pnt;
00028a  f8bd0000          LDRH     r0,[sp,#0]
00028e  f400407c          AND      r0,r0,#0xfc00
000292  305a              ADDS     r0,r0,#0x5a
000294  f8ad0000          STRH     r0,[sp,#0]
;;;1343   			tCP_PWM_CR1.tBit.pen_d_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_pen_d_h_pnt;
000298  f8bd0001          LDRH     r0,[sp,#1]
00029c  f36f008b          BFC      r0,#2,#10
0002a0  f50070b4          ADD      r0,r0,#0x168
0002a4  f8ad0001          STRH     r0,[sp,#1]
;;;1344   			PWMDRV->PWM_CR1.ulBulk = tCP_PWM_CR1.ulBulk;
0002a8  9800              LDR      r0,[sp,#0]
0002aa  f8c50104          STR      r0,[r5,#0x104]
;;;1345   
;;;1346   			tCP_PWM_CR2_t tCP_PWM_CR2;
;;;1347   			tCP_PWM_CR2.tBit.finger_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_finger_h_pnt;
0002ae  f8bd0004          LDRH     r0,[sp,#4]
0002b2  f400407c          AND      r0,r0,#0xfc00
0002b6  305a              ADDS     r0,r0,#0x5a
0002b8  f8ad0004          STRH     r0,[sp,#4]
;;;1348   			tCP_PWM_CR2.tBit.dmy_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_dmy_h_pnt;
0002bc  f8bd0005          LDRH     r0,[sp,#5]
0002c0  f36f008b          BFC      r0,#2,#10
0002c4  f50070b4          ADD      r0,r0,#0x168
0002c8  f8ad0005          STRH     r0,[sp,#5]
;;;1349   			PWMDRV->PWM_CR2.ulBulk = tCP_PWM_CR2.ulBulk;
0002cc  9801              LDR      r0,[sp,#4]
;;;1350   	#endif /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1351   		}
0002ce  e005              B        |L8.732|
                  |L8.720|
;;;1352   		else
;;;1353   		{
;;;1354   			PWMDRV->PWM_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR1.ulBulk;
0002d0  f8d40194          LDR      r0,[r4,#0x194]
0002d4  f8c50104          STR      r0,[r5,#0x104]
;;;1355   			PWMDRV->PWM_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR2.ulBulk;
0002d8  f8d40198          LDR      r0,[r4,#0x198]
                  |L8.732|
0002dc  f8c50108          STR      r0,[r5,#0x108]
;;;1356   		}
;;;1357   	}
;;;1358   #else
;;;1359   	PWMDRV->PWM_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR1.ulBulk;
;;;1360   	PWMDRV->PWM_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR2.ulBulk;
;;;1361   #endif
;;;1362   	PWMDRV->VSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_VSYNC_CR.ulBulk;
0002e0  f8d4019c          LDR      r0,[r4,#0x19c]
0002e4  f8c5010c          STR      r0,[r5,#0x10c]
;;;1363   
;;;1364   	if(IS_ACTIVE_MODE(_eSensingMode))
0002e8  f0060001          AND      r0,r6,#1
0002ec  2800              CMP      r0,#0
;;;1365   	{
;;;1366   		PWMDRV->MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_MUX_CR.ulBulk;
;;;1367   	}
;;;1368   #if USED_LOCAL_IDLE_MODE_CONTROL
;;;1369   	else
;;;1370   	{
;;;1371   		tCP_MUX_CR_t tCP_MUX_CR;
;;;1372   		tCP_MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_MUX_CR.ulBulk;
;;;1373   	#if IS_MSPEN_PROTOCOL_OPERATION
;;;1374   		tCP_MUX_CR.tBit.pen_s = PARAMSET_PWMDRV_MPP_MUX_CR_Idle_pen_s;
;;;1375   		tCP_MUX_CR.tBit.finger = PARAMSET_PWMDRV_MPP_MUX_CR_Idle_finger;
;;;1376   	#else /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1377   		tCP_MUX_CR.tBit.pen_s = PARAMSET_PWMDRV_WGP_MUX_CR_Idle_pen_s;
;;;1378   		tCP_MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_MUX_CR_Idle_finger;
;;;1379   	#endif /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1380   		PWMDRV->MUX_CR.ulBulk = tCP_MUX_CR.ulBulk;
;;;1381   	}
;;;1382   #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1383   #if USED_IDLE_MODE_CONTROL
;;;1384   	else
;;;1385   	{
;;;1386   		tCP_MUX_CR_t tCP_MUX_CR;
;;;1387   		tCP_MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_MUX_CR.ulBulk;
0002ee  f8d401a0          LDR      r0,[r4,#0x1a0]
0002f2  d109              BNE      |L8.776|
0002f4  9000              STR      r0,[sp,#0]
;;;1388   		tCP_MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_MUX_CR_Idle_finger;
0002f6  f8bd0001          LDRH     r0,[sp,#1]
0002fa  f420707c          BIC      r0,r0,#0x3f0
0002fe  f1000020          ADD      r0,r0,#0x20
000302  f8ad0001          STRH     r0,[sp,#1]
;;;1389   		PWMDRV->MUX_CR.ulBulk = tCP_MUX_CR.ulBulk;
000306  9800              LDR      r0,[sp,#0]
                  |L8.776|
000308  f8c50110          STR      r0,[r5,#0x110]
;;;1390   	}
;;;1391   #endif /* USED_IDLE_MODE_CONTROL */
;;;1392   
;;;1393   	PWMDRV->PWM_TPIC_ST_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_TPIC_ST_CR.ulBulk;
00030c  f8d401a4          LDR      r0,[r4,#0x1a4]
000310  f8c50114          STR      r0,[r5,#0x114]
;;;1394   	PWMDRV->PWM_SRIC_ST_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_SRIC_ST_CR.ulBulk;
000314  f8d401a8          LDR      r0,[r4,#0x1a8]
000318  f8c50118          STR      r0,[r5,#0x118]
;;;1395   	PWMDRV->PWM_MUX_ST_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_MUX_ST_CR.ulBulk;
00031c  f8d401ac          LDR      r0,[r4,#0x1ac]
000320  f8c5011c          STR      r0,[r5,#0x11c]
;;;1396   	PWMDRV->NM_FREQ.ulBulk = ptHalPwmdrvControlConf->tCP_NM_FREQ.ulBulk;
000324  f8d401b0          LDR      r0,[r4,#0x1b0]
000328  f8c50120          STR      r0,[r5,#0x120]
;;;1397   	PWMDRV->PWM_DLY2.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY2.ulBulk;
00032c  f8d401b4          LDR      r0,[r4,#0x1b4]
000330  f8c50128          STR      r0,[r5,#0x128]
;;;1398   
;;;1399   #if USED_PEN_MODE_OPERATION || USED_DUMMY_LHB_MODULATION
;;;1400   	#if USED_NOISE_HOPPING_FREQ
;;;1401   		if(IS_ACTIVE_MODE(_eSensingMode))
;;;1402   		{
;;;1403   			if(IS_ACTIVE_MODE_FRQ_MAIN(_eSensingMode))
;;;1404   			{
;;;1405   				PWMDRV->DLY_CNT4.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT4.ulBulk;
;;;1406   			}
;;;1407   			else
;;;1408   			{
;;;1409   				/*
;;;1410   				 * For WGP 16LHB PWM 86KHz!!
;;;1411   				 */
;;;1412   				t_DLY_CNT4 DLY_CNT4;
;;;1413   				DLY_CNT4.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT4.ulBulk;
;;;1414   				DLY_CNT4.tBit.bgap_prd = PARAMSET_PWMDRV_WGP_HOPP1_DLY_CNT4_bgap_prd;
;;;1415   				PWMDRV->DLY_CNT4.ulBulk = DLY_CNT4.ulBulk;
;;;1416   			}
;;;1417   		}
;;;1418   		else
;;;1419   		{
;;;1420   			PWMDRV->DLY_CNT4.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT4.ulBulk;
000334  bf04              ITT      EQ
000336  f8d401b8          LDREQ    r0,[r4,#0x1b8]
00033a  f8c5012c          STREQ    r0,[r5,#0x12c]
00033e  d00d              BEQ      |L8.860|
000340  f8d401b8          LDR      r0,[r4,#0x1b8]        ;1413
000344  f0160f02          TST      r6,#2                 ;1403
000348  d106              BNE      |L8.856|
00034a  9000              STR      r0,[sp,#0]            ;1413
00034c  f36f000a          BFC      r0,#0,#11             ;1414
000350  f2001079          ADD      r0,r0,#0x179          ;1414
000354  9000              STR      r0,[sp,#0]            ;1415
000356  9800              LDR      r0,[sp,#0]            ;1415
                  |L8.856|
000358  f8c5012c          STR      r0,[r5,#0x12c]        ;1405
                  |L8.860|
;;;1421   		}
;;;1422   	#else /* USED_NOISE_HOPPING_FREQ */
;;;1423   		PWMDRV->DLY_CNT4.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT4.ulBulk;
;;;1424   	#endif /* USED_NOISE_HOPPING_FREQ */
;;;1425   #else /* USED_PEN_MODE_OPERATION */
;;;1426   	PWMDRV->DLY_CNT4.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT4.ulBulk;
;;;1427   #endif /* USED_PEN_MODE_OPERATION */
;;;1428   
;;;1429   	PWMDRV->KIOSK_VSYNC_TIMER = ptHalPwmdrvControlConf->tCP_KIOSK_VSYNC_TIMER;
00035c  f8d401bc          LDR      r0,[r4,#0x1bc]
000360  f8c50130          STR      r0,[r5,#0x130]
;;;1430   	PWMDRV->PWM_DLY3.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY3.ulBulk;
000364  f8d401c0          LDR      r0,[r4,#0x1c0]
000368  f8c50134          STR      r0,[r5,#0x134]
;;;1431   	PWMDRV->PWM_DLY4.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY4.ulBulk;
00036c  f8d401c4          LDR      r0,[r4,#0x1c4]
000370  f8c50138          STR      r0,[r5,#0x138]
;;;1432   
;;;1433   #if USED_PEN_MODE_OPERATION || USED_DUMMY_LHB_MODULATION
;;;1434   	/*
;;;1435   	 * Pen Beacon Setting
;;;1436   	 */
;;;1437   	if(bIsInit)
000374  2f00              CMP      r7,#0
000376  d03a              BEQ      |L8.1006|
;;;1438   	{
;;;1439   #if IS_MULTI_PROTOCOL_OPERATION
;;;1440   	PWMDRV_Set_DSSS_INFO(PWMDRV->PWMGEN_CR0.tBit.pen_mode);
;;;1441   	PWMDRV_Set_DSSS_CODE(PWM_PEN_COMMON_BEACON);
;;;1442   #else /* IS_MULTI_PROTOCOL_OPERATION */
;;;1443   	#if (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION)
;;;1444   		#if USED_BEACON_SET_ADJUST
;;;1445   //				hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
;;;1446   			PWMDRV_Set_DSSS_INFO(PWM_WGP_PEN_SETTABLE_BEACON);
;;;1447   //				hal_Info_SetChangeCompleteWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
;;;1448   //				hal_Info_SetCurrentWGPPenBeaconType(PWM_WGP_PEN_SETTABLE_BEACON);
;;;1449   		#else /* USED_BEACON_SET_ADJUST */
;;;1450   			PWMDRV_Set_DSSS_INFO(PWMDRV->PWMGEN_CR0.tBit.pen_mode);
000378  6828              LDR      r0,[r5,#0]
00037a  f3c04440          UBFX     r4,r0,#17,#1
00037e  f7fffffe          BL       hal_pwmdrv_GetControlConfig
000382  eb000084          ADD      r0,r0,r4,LSL #2
000386  6b01              LDR      r1,[r0,#0x30]
000388  6329              STR      r1,[r5,#0x30]
00038a  6b80              LDR      r0,[r0,#0x38]
00038c  6368              STR      r0,[r5,#0x34]
00038e  f7fffffe          BL       hal_Info_GetChangeWGPPenBeaconType
000392  f7fffffe          BL       hal_Info_SetChangeCompleteWGPPenBeaconType
000396  20ff              MOVS     r0,#0xff
000398  f7fffffe          BL       hal_Info_SetChangeWGPPenBeaconType
00039c  f7fffffe          BL       hal_pwmdrv_GetControlConfig
0003a0  f8501f40          LDR      r1,[r0,#0x40]!
0003a4  63a9              STR      r1,[r5,#0x38]
0003a6  6841              LDR      r1,[r0,#4]
0003a8  63e9              STR      r1,[r5,#0x3c]
0003aa  6881              LDR      r1,[r0,#8]
0003ac  6429              STR      r1,[r5,#0x40]
0003ae  68c1              LDR      r1,[r0,#0xc]
0003b0  6469              STR      r1,[r5,#0x44]
0003b2  6901              LDR      r1,[r0,#0x10]
0003b4  64a9              STR      r1,[r5,#0x48]
0003b6  6941              LDR      r1,[r0,#0x14]
0003b8  64e9              STR      r1,[r5,#0x4c]
0003ba  6981              LDR      r1,[r0,#0x18]
0003bc  6529              STR      r1,[r5,#0x50]
0003be  69c1              LDR      r1,[r0,#0x1c]
0003c0  6569              STR      r1,[r5,#0x54]
0003c2  6a01              LDR      r1,[r0,#0x20]
0003c4  65a9              STR      r1,[r5,#0x58]
0003c6  6a41              LDR      r1,[r0,#0x24]
0003c8  65e9              STR      r1,[r5,#0x5c]
0003ca  6a81              LDR      r1,[r0,#0x28]
0003cc  6629              STR      r1,[r5,#0x60]
0003ce  6ac1              LDR      r1,[r0,#0x2c]
0003d0  6669              STR      r1,[r5,#0x64]
0003d2  6b01              LDR      r1,[r0,#0x30]
0003d4  66a9              STR      r1,[r5,#0x68]
0003d6  6b41              LDR      r1,[r0,#0x34]
0003d8  66e9              STR      r1,[r5,#0x6c]
0003da  6b81              LDR      r1,[r0,#0x38]
0003dc  6729              STR      r1,[r5,#0x70]
0003de  6bc1              LDR      r1,[r0,#0x3c]
0003e0  6769              STR      r1,[r5,#0x74]
0003e2  6c01              LDR      r1,[r0,#0x40]
0003e4  67a9              STR      r1,[r5,#0x78]
0003e6  6c40              LDR      r0,[r0,#0x44]
0003e8  67e8              STR      r0,[r5,#0x7c]
;;;1451   			PWMDRV_Set_DSSS_CODE(PWM_PEN_COMMON_BEACON);
;;;1452   		#endif /* USED_BEACON_SET_ADJUST */
;;;1453   	#elif IS_MSPEN_PROTOCOL_OPERATION
;;;1454   		PWMDRV_Set_DSSS_INFO(PWMDRV->PWMGEN_CR0.tBit.pen_mode);
;;;1455   		PWMDRV_Set_DSSS_CODE(PWM_PEN_COMMON_BEACON);
;;;1456   	#endif /* (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION) */
;;;1457   #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;1458   	}
;;;1459   	#if USED_DUMMY_LHB_MODULATION
;;;1460   	else
;;;1461   	{
;;;1462   		const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
;;;1463   		tCP_PWMGEN_CR0_t tCP_PWMGEN_CR0;
;;;1464   		tCP_DSSS_CODE_Value_t * pCP_DSSS_CODE_Value = (tCP_DSSS_CODE_Value_t *)&ptHalPwmdrvControlConf->tCP_DSSS_CODE_Value[0];
;;;1465   		tCP_PWMGEN_CR0.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR0.ulBulk;
;;;1466   		tCP_PWMGEN_CR0.tBit.pen_mode = (PWM_FULL_FINGER_MODE);
;;;1467   		if(IS_ACTIVE_MODE(_eSensingMode))
;;;1468   		{
;;;1469   			PWMDRV->DSSS_CODE_1_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_1_1;
;;;1470   			tCP_PWMGEN_CR0.tBit.chip_length0 = 28;
;;;1471   		}
;;;1472   		else
;;;1473   		{
;;;1474   			PWMDRV->PWMGEN_CR1.tBit.pen_s_pwmnum = 10;
;;;1475   			PWMDRV->DSSS_CODE_1_1 = 0xAAAAA800;
;;;1476   			tCP_PWMGEN_CR0.tBit.chip_length0 = 22;
;;;1477   		}
;;;1478   		PWMDRV->PWMGEN_CR0.ulBulk = tCP_PWMGEN_CR0.ulBulk;
;;;1479   	}
;;;1480   	#endif
;;;1481   #endif /* USED_PEN_MODE_OPERATION */
;;;1482   }
0003ea  b003              ADD      sp,sp,#0xc
0003ec  bdf0              POP      {r4-r7,pc}
                  |L8.1006|
0003ee  f7fffffe          BL       hal_pwmdrv_GetControlConfig
0003f2  f1000140          ADD      r1,r0,#0x40           ;1464
0003f6  6800              LDR      r0,[r0,#0]            ;1465
0003f8  9000              STR      r0,[sp,#0]            ;1465
0003fa  f89d0002          LDRB     r0,[sp,#2]            ;1466
0003fe  f0160f01          TST      r6,#1                 ;1467
000402  f0200002          BIC      r0,r0,#2              ;1466
000406  f88d0002          STRB     r0,[sp,#2]            ;1466
00040a  d014              BEQ      |L8.1078|
00040c  6948              LDR      r0,[r1,#0x14]         ;1469
00040e  64e8              STR      r0,[r5,#0x4c]         ;1469
000410  f8bd0000          LDRH     r0,[sp,#0]            ;1470
000414  f42060f8          BIC      r0,r0,#0x7c0          ;1470
000418  e00a              B        |L8.1072|
00041a  0000              DCW      0x0000
                  |L8.1052|
                          DCD      0x40002000
                  |L8.1056|
                          DCD      ||.data||
                  |L8.1060|
                          DCD      ||.data||+0x4
                  |L8.1064|
                          DCD      ||.data||+0x8
                  |L8.1068|
                          DCD      ||.data||+0xc
                  |L8.1072|
000430  f50060e0          ADD      r0,r0,#0x700          ;1470
000434  e00d              B        |L8.1106|
                  |L8.1078|
000436  6868              LDR      r0,[r5,#4]            ;1474
000438  f02040fe          BIC      r0,r0,#0x7f000000     ;1474
00043c  f1006020          ADD      r0,r0,#0xa000000      ;1474
000440  6068              STR      r0,[r5,#4]            ;1474
000442  4807              LDR      r0,|L8.1120|
000444  64e8              STR      r0,[r5,#0x4c]         ;1475
000446  f8bd0000          LDRH     r0,[sp,#0]            ;1476
00044a  f42060f8          BIC      r0,r0,#0x7c0          ;1476
00044e  f50060b0          ADD      r0,r0,#0x580          ;1476
                  |L8.1106|
000452  f8ad0000          STRH     r0,[sp,#0]            ;1476
000456  9800              LDR      r0,[sp,#0]            ;1478
000458  6028              STR      r0,[r5,#0]            ;1478
00045a  b003              ADD      sp,sp,#0xc
00045c  bdf0              POP      {r4-r7,pc}
;;;1483   
                          ENDP

00045e  0000              DCW      0x0000
                  |L8.1120|
                          DCD      0xaaaaa800

                          AREA ||i.PWMDRV_Set_DSSS_CODE||, CODE, READONLY, ALIGN=2

                  PWMDRV_Set_DSSS_CODE PROC
;;;1846   
;;;1847   void PWMDRV_Set_DSSS_CODE(uint32_t ulIdx)
000000  b510              PUSH     {r4,lr}
;;;1848   {
000002  4604              MOV      r4,r0
;;;1849   	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000004  f7fffffe          BL       hal_pwmdrv_GetControlConfig
;;;1850   	tCP_DSSS_CODE_Value_t * pCP_DSSS_CODE_Value = (tCP_DSSS_CODE_Value_t *)&ptHalPwmdrvControlConf->tCP_DSSS_CODE_Value[ulIdx];
000008  eb0401c4          ADD      r1,r4,r4,LSL #3
00000c  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;1851   
;;;1852   	PWMDRV->DSSS_CODE_P_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_P_0;
000010  4913              LDR      r1,|L9.96|
000012  f8502f40          LDR      r2,[r0,#0x40]!
000016  638a              STR      r2,[r1,#0x38]
;;;1853   	PWMDRV->DSSS_CODE_P_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_P_1;
000018  6842              LDR      r2,[r0,#4]
00001a  63ca              STR      r2,[r1,#0x3c]
;;;1854   	PWMDRV->DSSS_CODE_0_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_0_0;
00001c  6882              LDR      r2,[r0,#8]
00001e  640a              STR      r2,[r1,#0x40]
;;;1855   	PWMDRV->DSSS_CODE_0_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_0_1;
000020  68c2              LDR      r2,[r0,#0xc]
000022  644a              STR      r2,[r1,#0x44]
;;;1856   	PWMDRV->DSSS_CODE_1_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_1_0;
000024  6902              LDR      r2,[r0,#0x10]
000026  648a              STR      r2,[r1,#0x48]
;;;1857   	PWMDRV->DSSS_CODE_1_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_1_1;
000028  6942              LDR      r2,[r0,#0x14]
00002a  64ca              STR      r2,[r1,#0x4c]
;;;1858   	PWMDRV->DSSS_CODE_2_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_2_0;
00002c  6982              LDR      r2,[r0,#0x18]
00002e  650a              STR      r2,[r1,#0x50]
;;;1859   	PWMDRV->DSSS_CODE_2_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_2_1;
000030  69c2              LDR      r2,[r0,#0x1c]
000032  654a              STR      r2,[r1,#0x54]
;;;1860   	PWMDRV->DSSS_CODE_3_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_3_0;
000034  6a02              LDR      r2,[r0,#0x20]
000036  658a              STR      r2,[r1,#0x58]
;;;1861   	PWMDRV->DSSS_CODE_3_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_3_1;
000038  6a42              LDR      r2,[r0,#0x24]
00003a  65ca              STR      r2,[r1,#0x5c]
;;;1862   	PWMDRV->DSSS_CODE_4_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_4_0;
00003c  6a82              LDR      r2,[r0,#0x28]
00003e  660a              STR      r2,[r1,#0x60]
;;;1863   	PWMDRV->DSSS_CODE_4_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_4_1;
000040  6ac2              LDR      r2,[r0,#0x2c]
000042  664a              STR      r2,[r1,#0x64]
;;;1864   	PWMDRV->DSSS_CODE_5_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_5_0;
000044  6b02              LDR      r2,[r0,#0x30]
000046  668a              STR      r2,[r1,#0x68]
;;;1865   	PWMDRV->DSSS_CODE_5_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_5_1;
000048  6b42              LDR      r2,[r0,#0x34]
00004a  66ca              STR      r2,[r1,#0x6c]
;;;1866   	PWMDRV->DSSS_CODE_6_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_6_0;
00004c  6b82              LDR      r2,[r0,#0x38]
00004e  670a              STR      r2,[r1,#0x70]
;;;1867   	PWMDRV->DSSS_CODE_6_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_6_1;
000050  6bc2              LDR      r2,[r0,#0x3c]
000052  674a              STR      r2,[r1,#0x74]
;;;1868   	PWMDRV->DSSS_CODE_7_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_7_0;
000054  6c02              LDR      r2,[r0,#0x40]
000056  678a              STR      r2,[r1,#0x78]
;;;1869   	PWMDRV->DSSS_CODE_7_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_7_1;
000058  6c40              LDR      r0,[r0,#0x44]
00005a  67c8              STR      r0,[r1,#0x7c]
;;;1870   }
00005c  bd10              POP      {r4,pc}
;;;1871   
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_Set_DSSS_INFO||, CODE, READONLY, ALIGN=2

                  PWMDRV_Set_DSSS_INFO PROC
;;;1779   #if USED_PEN_MODE_OPERATION || USED_DUMMY_LHB_MODULATION
;;;1780   void PWMDRV_Set_DSSS_INFO(uint32_t ulIdx)
000000  b510              PUSH     {r4,lr}
;;;1781   {
000002  4604              MOV      r4,r0
;;;1782   //	uint32_t ChangeWGPPenBeaconType = hal_Info_GetChangeWGPPenBeaconType();
;;;1783   #if USED_BEACON_SET_ADJUST
;;;1784   	#if IS_MULTI_PROTOCOL_OPERATION
;;;1785   	switch(hal_Info_GetControlActivePenSettingType())
;;;1786   	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;1787   	{
;;;1788   	#if IS_MULTI_PROTOCOL_OPERATION
;;;1789   		case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;1790   	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;1791   		{
;;;1792   	#if IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION
;;;1793   //			if(hal_Info_GetChangeWGPPenBeaconType() != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;1794   			if(ulIdx != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;1795   			{
;;;1796   				PWM_Set_UL_CMD(ulIdx);
;;;1797   //				hal_Info_SetChangeCompleteWGPPenBeaconType(hal_Info_GetChangeWGPPenBeaconType());
;;;1798   				hal_Info_SetChangeCompleteWGPPenBeaconType(ulIdx);
;;;1799   				hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
;;;1800   			}
;;;1801   	#endif /* IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION */
;;;1802   	#if IS_MULTI_PROTOCOL_OPERATION
;;;1803   			break;
;;;1804   	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;1805   		}
;;;1806   	#if IS_MULTI_PROTOCOL_OPERATION
;;;1807   		case ACTIVEPEN_TYPE_LOCAL_MS:
;;;1808   	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;1809   		{
;;;1810   	#if IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION
;;;1811   			PWMDRV_Set_DSSS_CODE(PWM_PEN_COMMON_BEACON);
;;;1812   			const tHalPwmdrvControlConf_t *ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
;;;1813   			PWMDRV->DSSS_INFO1.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO1[ulIdx].ulBulk;
;;;1814   			PWMDRV->DSSS_INFO2.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO2[ulIdx].ulBulk;
;;;1815   	#endif /* IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION */
;;;1816   	#if IS_MULTI_PROTOCOL_OPERATION
;;;1817   			break;
;;;1818   	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;1819   		}
;;;1820   	}
;;;1821   #else /* USED_BEACON_SET_ADJUST */
;;;1822   	{
;;;1823   	#if IS_MSPEN_PROTOCOL_OPERATION
;;;1824   //		if(hal_Info_GetChangeWGPPenBeaconType() != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;1825   		{
;;;1826   			const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
;;;1827   			PWMDRV->DSSS_INFO1.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO1[ulIdx].ulBulk;
;;;1828   			PWMDRV->DSSS_INFO2.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO2[ulIdx].ulBulk;
;;;1829   		}
;;;1830   	#else /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1831   		#if !USED_DUMMY_LHB_MODULATION
;;;1832   		if(hal_Info_GetChangeWGPPenBeaconType() != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;1833   		#endif
;;;1834   		{
;;;1835   			const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000004  f7fffffe          BL       hal_pwmdrv_GetControlConfig
;;;1836   			PWMDRV->DSSS_INFO1.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO1[ulIdx].ulBulk;
000008  eb000084          ADD      r0,r0,r4,LSL #2
00000c  6b02              LDR      r2,[r0,#0x30]
00000e  4906              LDR      r1,|L10.40|
000010  630a              STR      r2,[r1,#0x30]
;;;1837   			PWMDRV->DSSS_INFO2.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO2[ulIdx].ulBulk;
000012  6b80              LDR      r0,[r0,#0x38]
000014  6348              STR      r0,[r1,#0x34]
;;;1838   		}
;;;1839   	#endif /* IS_MSPEN_PROTOCOL_OPERATION */
;;;1840   	}
;;;1841   
;;;1842   	hal_Info_SetChangeCompleteWGPPenBeaconType(hal_Info_GetChangeWGPPenBeaconType());
000016  f7fffffe          BL       hal_Info_GetChangeWGPPenBeaconType
00001a  f7fffffe          BL       hal_Info_SetChangeCompleteWGPPenBeaconType
;;;1843   	hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
00001e  e8bd4010          POP      {r4,lr}
000022  20ff              MOVS     r0,#0xff
000024  f7ffbffe          B.W      hal_Info_SetChangeWGPPenBeaconType
;;;1844   #endif /* USED_BEACON_SET_ADJUST */
;;;1845   }
;;;1846   
                          ENDP

                  |L10.40|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_TSync_In_InterruptHandler||, CODE, READONLY, ALIGN=2

                  PWMDRV_TSync_In_InterruptHandler PROC
;;;71     
;;;72     void PWMDRV_TSync_In_InterruptHandler(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;73     {
;;;74     	if(SCRB->SYS_INT_ST.tBit.int_tsyncin != 0)
000004  f04f4680          MOV      r6,#0x40000000
000008  69b0              LDR      r0,[r6,#0x18]
00000a  f4102f00          TST      r0,#0x80000
;;;75     	{
;;;76     		if(tHalIntrHandle.ulInitFirstFrame == 1)
;;;77     		{
;;;78     			tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;79     			tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;80     		}
;;;81     		else
;;;82     		{
;;;83     			eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
;;;84     			eActivePenType_t ePenType = hal_Info_GetControlActivePenOPType();
;;;85     
;;;86     			if(GET_GPIO_TSYNC_IN_STATUS == GPIO_DATA_LOW)
;;;87     			{
;;;88     				/*
;;;89     				 * Falling
;;;90     				 */
;;;91     #if USED_TSYNC_TMIC_GPIO_CONTROL
;;;92     				GPIO_Set_DATA(_GPIO_TSYNC_TMIC, GPIO_DATA_LOW);
;;;93     #endif /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;94     				tHalIntrHandle.ulTSyncInFallingCnt++;
;;;95     
;;;96     #if (USED_LOCAL_IDLE_MODE_CONTROL && (LHB_NUM != LOCAL_IDLE_LHB_NUM))
;;;97     				if(IS_IDLE_MODE(eSensingMode))
;;;98     				{
;;;99     					if(tHalIntrHandle.ulTSyncInFallingCnt >= LOCAL_IDLE_LHB_NUM)
;;;100    					{
;;;101    						tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;102    					}
;;;103    				}
;;;104    				else
;;;105    #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;106    				{
;;;107    					if(tHalIntrHandle.ulTSyncInFallingCnt >= LHB_NUM)
;;;108    					{
;;;109    						tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;110    					}
;;;111    				}
;;;112    
;;;113    				{
;;;114    #if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;115    					uint32_t ulUplinkCtrlCheckBitMask;
;;;116    #endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;117    #if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;118    					uint32_t ulMuxEnCheckBitMask;
;;;119    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;120    #if USED_ECLK_ON_OFF_CONTROL
;;;121    					uint32_t ulECLKEnCheckBitMask;
;;;122    #endif
;;;123    #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;124    					uint32_t ulPenEnCheckBitMask;
;;;125    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;126    
;;;127    #if IS_MULTI_PROTOCOL_OPERATION
;;;128    					switch(ePenType)
;;;129    					{
;;;130    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;131    #if IS_MULTI_PROTOCOL_OPERATION
;;;132    						case ACTIVEPEN_TYPE_LOCAL_MS:
;;;133    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;134    #if IS_MULTI_PROTOCOL_OPERATION || IS_MSPEN_PROTOCOL_OPERATION
;;;135    						{
;;;136    	#if USED_PEN_MODE_OPERATION
;;;137    		#if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;138    							ulUplinkCtrlCheckBitMask = DEF_UPLINK_CTRL_SET_BIT_MASK_MSPen;
;;;139    		#endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;140    
;;;141    							if(IS_FINGER_PEN_MODE(eSensingMode))
;;;142    							{
;;;143    		#if  USED_LOCAL_IDLE_MODE_CONTROL
;;;144    								if(IS_IDLE_MODE(eSensingMode))
;;;145    								{
;;;146    			#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;147    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle;
;;;148    			#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;149    			#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;150    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle;
;;;151    			#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;152    								}
;;;153    								else
;;;154    		#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;155    								{
;;;156    		#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;157    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Local;
;;;158    		#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;159    		#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;160    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Local;
;;;161    		#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;162    								}
;;;163    							}
;;;164    							else
;;;165    	#endif /* USED_PEN_MODE_OPERATION */
;;;166    							{
;;;167    		#if USED_IDLE_MODE_CONTROL
;;;168    								if(IS_IDLE_MODE(eSensingMode))
;;;169    								{
;;;170    			#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;171    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle;
;;;172    			#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;173    			#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;174    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle;
;;;175    			#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;176    								}
;;;177    								else
;;;178    		#endif /* USED_IDLE_MODE_CONTROL */
;;;179    								{
;;;180    		#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;181    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Full;
;;;182    		#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;183    		#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;184    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Full;
;;;185    		#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;186    								}
;;;187    							}
;;;188    	#if IS_MULTI_PROTOCOL_OPERATION
;;;189    							break;
;;;190    	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;191    						}
;;;192    #endif /* IS_MULTI_PROTOCOL_OPERATION || IS_MSPEN_PROTOCOL_OPERATION */
;;;193    #if IS_MULTI_PROTOCOL_OPERATION
;;;194    						case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;195    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;196    #if IS_MULTI_PROTOCOL_OPERATION || IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION
;;;197    						{
;;;198    	#if USED_PEN_MODE_OPERATION
;;;199    		#if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;200    							ulUplinkCtrlCheckBitMask = DEF_UPLINK_CTRL_SET_BIT_MASK_WGPPen;
;;;201    		#endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;202    
;;;203    							if(IS_FINGER_PEN_MODE(eSensingMode))
;;;204    							{
;;;205    		#if  USED_LOCAL_IDLE_MODE_CONTROL
;;;206    								if(IS_IDLE_MODE(eSensingMode))
;;;207    								{
;;;208    			#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;209    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle;
;;;210    			#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;211    			#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;212    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle;
;;;213    			#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;214    								}
;;;215    								else
;;;216    		#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;217    								{
;;;218    		#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;219    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Local;
;;;220    		#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;221    		#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;222    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Local;
;;;223    		#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;224    								}
;;;225    							}
;;;226    							else
;;;227    	#endif /* USED_PEN_MODE_OPERATION */
;;;228    							{
;;;229    	#if USED_IDLE_MODE_CONTROL
;;;230    								if(IS_IDLE_MODE(eSensingMode))
;;;231    								{
;;;232    		#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;233    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Idle;
;;;234    		#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;235    		#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;236    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Idle;
;;;237    		#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;238    		#if USED_ECLK_ON_OFF_CONTROL
;;;239    									ulECLKEnCheckBitMask = DEF_ECLK_EN_SET_BIT_MASK_Idle;
;;;240    		#endif
;;;241    								}
;;;242    								else
;;;243    	#endif /* USED_IDLE_MODE_CONTROL */
;;;244    								{
;;;245    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;246    									ulMuxEnCheckBitMask = DEF_TPIC_MUX_EN_SET_BIT_MASK_Full;
;;;247    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;248    	#if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;249    									ulPenEnCheckBitMask = DEF_TPIC_PEN_EN_SET_BIT_MASK_Full;
;;;250    	#endif /* USED_TPIC_PENEN_ON_OFF_CONTROL */
;;;251    	#if USED_ECLK_ON_OFF_CONTROL
;;;252    									ulECLKEnCheckBitMask = DEF_ECLK_EN_SET_BIT_MASK_Full;
;;;253    	#endif
;;;254    								}
;;;255    							}
;;;256    	#if IS_MULTI_PROTOCOL_OPERATION
;;;257    							break;
;;;258    	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;259    						}
;;;260    #endif /* IS_MULTI_PROTOCOL_OPERATION || IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION */
;;;261    #if IS_MULTI_PROTOCOL_OPERATION
;;;262    					} /* switch(ePenType) */
;;;263    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;264    
;;;265    #if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;266    					if(ulUplinkCtrlCheckBitMask & (1<<tHalIntrHandle.ulTSyncInFallingCnt))
;;;267    					{
;;;268    						SET_GPIO_Uplink_GPIO_STATUS = GPIO_DATA_HIGH;
;;;269    //						GPIO_Set_DATA(_GPIO_Uplink_GPIO, GPIO_DATA_HIGH);
;;;270    					}
;;;271    #endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;272    
;;;273    #if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;274    					if(HAL_GetTPICMuxEnControl())
;;;275    					{
;;;276    						if(ulMuxEnCheckBitMask & (1<<tHalIntrHandle.ulTSyncInFallingCnt))
;;;277    						{
;;;278    							SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;279    //							_gOut(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;280    						}
;;;281    					}
;;;282    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;283    
;;;284    #if USED_ECLK_ON_OFF_CONTROL
;;;285    					if(HAL_GetECLKOnOffControl())
;;;286    					{
;;;287    						if(ulECLKEnCheckBitMask & (1<<tHalIntrHandle.ulTSyncInFallingCnt))
;;;288    						{
;;;289    							HAL_ECLK_On();
;;;290    						}
;;;291    					}
;;;292    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;293    
;;;294    #if USED_TPIC_PENEN_ON_OFF_CONTROL
;;;295    					if(HAL_GetTPICPenEnControl())
;;;296    					{
;;;297    						if(ulPenEnCheckBitMask & (1<<tHalIntrHandle.ulTSyncInFallingCnt))
;;;298    						{
;;;299    							SET_GPIO_PEN_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;300    						}
;;;301    					}
;;;302    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;303    				}
;;;304    			}
;;;305    			else
;;;306    			{
;;;307    				/*
;;;308    				 * Rising
;;;309    				 */
;;;310    #if USED_TSYNC_TMIC_GPIO_CONTROL
;;;311    				GPIO_Set_DATA(_GPIO_TSYNC_TMIC, GPIO_DATA_HIGH);
;;;312    #endif /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;313    				tHalIntrHandle.ulTSyncInRisingCnt++;
;;;314    
;;;315    #if USED_LOCAL_IDLE_MODE_CONTROL || USED_IDLE_MODE_30Hz_CONTROL || USED_IDLE_MODE_20Hz_CONTROL
;;;316    				if(IS_IDLE_MODE(eSensingMode))
;;;317    				{
;;;318    					if(tHalIntrHandle.ulTSyncInRisingCnt >= LOCAL_IDLE_LHB_NUM || tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;319    					{
;;;320    						tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;321    					}
;;;322    				}
;;;323    				else
;;;324    #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;325    				{
;;;326    					if(tHalIntrHandle.ulTSyncInRisingCnt >= LHB_NUM || tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;327    					{
;;;328    						tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;329    					}
;;;330    				}
;;;331    
;;;332    				if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;333    				{
;;;334    #if ((CUSTOMER == MODEL_DEF_FHD_PLUSE_92510_Dell_Wendy_Finger) || \
;;;335    		(CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_Finger) || \
;;;336    		(CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_FLIP_Finger) || \
;;;337    		(CUSTOMER == MODEL_DEF_QHD_92512_Dell_FINGER) || \
;;;338    		(CUSTOMER == MODEL_DEF_FHD_92513_LENOVO) || \
;;;339    		(CUSTOMER == MODEL_DEF_FHD_92513_LENOVO_NON_PRIVACY))
;;;340    					tSYS_CFG_t tCFGR_SYS_CFG;
;;;341    					tCFGR_SYS_CFG.ulBulk = module_SRIC_GetCommonConfig()->SYS_CFG.ulBulk;
;;;342    					//Reset SRIC mux order
;;;343    					MSPI_Set_TLPMODE();
;;;344    					tCFGR_SYS_CFG.tBit.tg_reset = 1;
;;;345    					MSPI_RegisterWrite((uint32_t)(0x0014), tCFGR_SYS_CFG.ulBulk);
;;;346    					tCFGR_SYS_CFG.tBit.tg_reset = 0;
;;;347    					MSPI_RegisterWrite((uint32_t)(0x0014), tCFGR_SYS_CFG.ulBulk);
;;;348    
;;;349    	#if (USED_ROIC_DEF == ROIC_SW92513)
;;;350    					// you must buf pnt clear when tg reset!!
;;;351    					tSPIS_ERROR_CLR_t tSPIS_ERROR_CLR;
;;;352    					tSPIS_ERROR_CLR.ulBulk = module_SRIC_GetCommonConfig()->SPIS_ERROR_CLR.ulBulk;
;;;353    					tSPIS_ERROR_CLR.tBit.buf_pnt_clr = 1;
;;;354    					MSPI_RegisterWrite((uint32_t)(0x0008), tSPIS_ERROR_CLR.ulBulk);
;;;355    					tSPIS_ERROR_CLR.tBit.buf_pnt_clr = 0;
;;;356    					MSPI_RegisterWrite((uint32_t)(0x0008), tSPIS_ERROR_CLR.ulBulk);
;;;357    	#endif /* (USED_ROIC_DEF == ROIC_SW92513) */
;;;358    
;;;359    	#if USED_ESD_RECOERY_DETECTION_ROIC_Abnoraml
;;;360    					if(IS_ACTIVE_MODE(eSensingMode) && tHalIntrHandle.bIsROICReg_ESDRecovery == NO)
;;;361    					{
;;;362    						if(SRIC_RegisterCheckEveryFrame(eSensingMode) == NO)
;;;363    						{
;;;364    							tHalIntrHandle.bIsROICReg_ESDRecovery = YES;
;;;365    						}
;;;366    					}
;;;367    	#endif /* USED_ESD_RECOERY_DETECTION_ROIC_Abnoraml */
;;;368    					MSPI_Set_AITMODE(eSensingMode);
;;;369    
;;;370    					//Reset MSPI mux order
;;;371    					MSPI->SPIAITSTART = 0x00;
;;;372    					MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;373    					tHalIntrHandle.ulMSPIPenModeIntrCnt = 0;
;;;374    					MSPI->SPIAITSTART = MSPI_START_VAL;
;;;375    #endif /* ((CUSTOMER == MODEL_DEF_FHD_PLUSE_92510_Dell_Wendy_Finger) || (CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_Finger)  || (CUSTOMER == MODEL_DEF_QHD_92512_Dell_WGP_PEN) */
;;;376    
;;;377    					SCRB->SYS_RST_CTL.tBit.pwm_rst = 1;
;;;378    					SCRB->SYS_RST_CTL.tBit.pwm_rst = 0;
;;;379    					tHalIntrHandle.ulTSyncInFallingCnt = 0; // Sync Matching Count of Rising and Falling
;;;380    					tHalIntrHandle.ulVSyncFlag = 1;
;;;381    #if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
;;;382    					if(tHalIntrHandle.bIsIdlePWMRollback)
;;;383    					{
;;;384    						tHalIntrHandle.bIsIdlePWMRollback = NO;
;;;385    						PWMDRV->TSYNC_TPIC_CR.tBit.finger_en = ENABLE;
;;;386    						PWMDRV->TSYNC_TPIC_CR.tBit.finger_pwm_en = ENABLE;
;;;387    
;;;388    						PWMDRV->PWM_TPIC_CR.tBit.finger_en = PARAMSET_PWMDRV_WGP_PWM_TPIC_CR_finger_en;
;;;389    						PWMDRV->PWM_TPIC_CR.tBit.finger_dmy_en = PARAMSET_PWMDRV_WGP_PWM_TPIC_CR_finger_dmy_en;
;;;390    						PWMDRV->PWM_SRIC_CR.tBit.finger_en = PARAMSET_PWMDRV_WGP_PWM_SRIC_CR_finger_en;
;;;391    						PWMDRV->PWM_SRIC_CR.tBit.finger_dmy_en = PARAMSET_PWMDRV_WGP_PWM_SRIC_CR_finger_dmy_en;
;;;392    	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;393    						PWMDRV->PWM_SRIC_CR.tBit.pen_s_en = PARAMSET_PWMDRV_WGP_PWM_SRIC_CR_pen_s_en;
;;;394    						PWMDRV->PWM_SRIC_CR.tBit.pen_s_dmy_en = PARAMSET_PWMDRV_WGP_PWM_SRIC_CR_pen_s_dmy_en;
;;;395    	#endif
;;;396    					}
;;;397    #endif /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
;;;398    
;;;399    #if (USED_FAST_SWITCH_IDLE_TO_ACTIVE && (USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE == NO))
;;;400    					if(HAL_GetSensingChangeMode() == SM_FAST_CHANGE_ACTIVE_MODE)
;;;401    					{
;;;402    						if(HAL_CheckSensningModeChange(SM_FAST_CHANGE_ACTIVE_MODE))
;;;403    						{
;;;404    							HAL_SetSensingChangeMode(SM_CHANGE_COMPLETE);
;;;405    							MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;406    						}
;;;407    					}
;;;408    #elif USED_FAST_SWITCH_LOCAL_IDLE_TO_ACTIVE
;;;409    					if(HAL_GetSensingChangeMode() == SM_FAST_CHANGE_LocalIdle_To_Local_MODE)
;;;410    					{
;;;411    						if(HAL_CheckSensningModeChange(SM_FAST_CHANGE_LocalIdle_To_Local_MODE))
;;;412    						{
;;;413    							HAL_SetSensingChangeMode(SM_CHANGE_COMPLETE);
;;;414    							MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;415    							MSPI->SPIAITSTART = MSPI_START_VAL;
;;;416    						}
;;;417    					}
;;;418    #endif /* (USED_FAST_SWITCH_IDLE_TO_ACTIVE && (USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE == NO)) */
;;;419    
;;;420    #if USED_LOCAL_IDLE_30Hz
;;;421    					if(IS_IDLE_MODE(eSensingMode))
;;;422    					{
;;;423    						tCFGR_SYS_CFG_t tCFGR_SYS_CFG;
;;;424    						const tModuleSRICCommonConf_t * pktmoduleSRICCommonConf = module_SRIC_GetCommonConfig();
;;;425    						tCFGR_SYS_CFG.ulBulk = pktmoduleSRICCommonConf->CFGR_SYS_CFG.ulBulk;
;;;426    						MSPI_Set_TLPMODE();
;;;427    						/*
;;;428    						 * ROIC Power On!!
;;;429    						 */
;;;430    						MSPI_RegisterWrite((uint32_t)(0x01C0), pktmoduleSRICCommonConf->CFGR_SSU_PW_CTRL.ulBulk);
;;;431    						/*
;;;432    						 * TG Reset 1 -> 0
;;;433    						 */
;;;434    						tCFGR_SYS_CFG.tBit.tg_reset = 1;
;;;435    						MSPI_RegisterWrite((uint32_t)(0x0014), tCFGR_SYS_CFG.ulBulk);
;;;436    						tCFGR_SYS_CFG.tBit.tg_reset = 0;
;;;437    						MSPI_RegisterWrite((uint32_t)(0x0014), tCFGR_SYS_CFG.ulBulk);
;;;438    
;;;439    						MSPI_Set_AITMODE(HAL_GetSensingMode());
;;;440    					}
;;;441    #endif /* USED_LOCAL_IDLE_30Hz */
;;;442    				}
;;;443    
;;;444    #if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
;;;445    				if(tHalIntrHandle.ulTSyncInRisingCnt == DEF_FULLSCAN_SWITCH_IDLE_LHB_IDX)
;;;446    				{
;;;447    					if(HAL_GetSensingChangeMode() == SM_CHANGE_FULLSCAN_IDLE_MODE)
;;;448    					{
;;;449    						if(HAL_CheckSensningModeChange(SM_CHANGE_FULLSCAN_IDLE_MODE))
;;;450    						{
;;;451    							HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_MODE);
;;;452    							MSPI->SPIAITSTART = 0x00;
;;;453    							MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;454    							tHalIntrHandle.ulMSPIPenModeIntrCnt = 1; /* For 2nd Full Sensing of Active Sensing */
;;;455    							MSPI->SPIAITSTART = MSPI_START_VAL;
;;;456    						}
;;;457    					}
;;;458    					else if(IS_IDLE_MODE(eSensingMode))
;;;459    					{
;;;460    						tHalIntrHandle.bIsIdlePWMRollback = YES;
;;;461    //						_gT(_GPIO_TP_INTR);
;;;462    	#if !USED_DUMMY_LHB_MODULATION
;;;463    						PWMDRV->TSYNC_TPIC_CR.tBit.finger_en = DISABLE;
;;;464    						PWMDRV->TSYNC_TPIC_CR.tBit.finger_pwm_en = DISABLE;
;;;465    						PWMDRV->PWM_TPIC_CR.tBit.finger_en = DISABLE;
;;;466    						PWMDRV->PWM_TPIC_CR.tBit.finger_dmy_en = DISABLE;
;;;467    	#endif
;;;468    						PWMDRV->PWM_SRIC_CR.tBit.finger_en = DISABLE;
;;;469    						PWMDRV->PWM_SRIC_CR.tBit.finger_dmy_en = DISABLE;
;;;470    	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;471    						PWMDRV->PWM_SRIC_CR.tBit.pen_s_en = DISABLE;
;;;472    						PWMDRV->PWM_SRIC_CR.tBit.pen_s_dmy_en = DISABLE;
;;;473    						PWMDRV->PWM_TPIC_CR.tBit.pen_s_en = ENABLE;
;;;474    						PWMDRV->PWM_TPIC_CR.tBit.pen_s_dmy_en = ENABLE;
;;;475    	#endif
;;;476    					}
;;;477    				}
;;;478    #endif /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
;;;479    
;;;480    				{
;;;481    #if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;482    					uint32_t ulUplinkCtrlCheckBitMask;
;;;483    #endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;484    
;;;485    #if IS_MULTI_PROTOCOL_OPERATION
;;;486    					switch(ePenType)
;;;487    					{
;;;488    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;489    #if IS_MULTI_PROTOCOL_OPERATION
;;;490    						case ACTIVEPEN_TYPE_LOCAL_MS:
;;;491    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;492    #if IS_MULTI_PROTOCOL_OPERATION || IS_MSPEN_PROTOCOL_OPERATION
;;;493    						{
;;;494    	#if USED_PEN_MODE_OPERATION
;;;495    		#if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;496    							ulUplinkCtrlCheckBitMask = DEF_UPLINK_CTRL_SET_BIT_MASK_MSPen;
;;;497    		#endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;498    							if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;499    							{
;;;500    								PWMDRV_Set_DSSS_CODE(hal_Info_GetMPPPen1stBeaconType());
;;;501    							}
;;;502    							else if(tHalIntrHandle.ulTSyncInRisingCnt == 8)
;;;503    							{
;;;504    								PWMDRV_Set_DSSS_CODE(PWM_MPP_PEN_2nd_BEACON);
;;;505    							}
;;;506    	#endif /* USED_PEN_MODE_OPERATION */
;;;507    	#if IS_MULTI_PROTOCOL_OPERATION
;;;508    							break;
;;;509    	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;510    						}
;;;511    #endif /* IS_MULTI_PROTOCOL_OPERATION || IS_MSPEN_PROTOCOL_OPERATION */
;;;512    #if IS_MULTI_PROTOCOL_OPERATION
;;;513    						case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;514    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;515    #if IS_MULTI_PROTOCOL_OPERATION || IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION
;;;516    						{
;;;517    	#if USED_PEN_MODE_OPERATION
;;;518    		#if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;519    							ulUplinkCtrlCheckBitMask = DEF_UPLINK_CTRL_SET_BIT_MASK_WGPPen;
;;;520    		#endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;521    
;;;522    		#if USED_NOISE_HOPPING_FREQ
;;;523    			#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;524    							/*
;;;525    							 * TODO : Implementation Frequency Hopping
;;;526    							 */
;;;527    			#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;528    							if(IS_ACTIVE_MODE(eSensingMode))
;;;529    							{
;;;530    								if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;531    								{
;;;532    									PWMDRV_Set_DSSS_INFO(hal_Info_GetChangeWGPPenBeaconType());
;;;533    								}
;;;534    								/*
;;;535    								 * Current Beacon Type change in T-Sync Rising Edge Interrupt after Changed the Up-Link.
;;;536    								 */
;;;537    								if(tHalIntrHandle.ulTSyncInRisingCnt == 1)
;;;538    								{
;;;539    									if(hal_Info_GetChangeCompleteWGPPenBeaconType() != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;540    									{
;;;541    										hal_Info_SetCurrentWGPPenBeaconType(hal_Info_GetChangeCompleteWGPPenBeaconType());
;;;542    										hal_Info_SetChangeCompleteWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
;;;543    									}
;;;544    
;;;545    									if(hal_Info_GetCurrentWGPPenBeaconType() == PWM_WGP_PEN_HOPP_SETTABLE_BEACON)
;;;546    									{
;;;547    										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;548    									}
;;;549    								}
;;;550    							}
;;;551    			#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;552    		#else /* USED_NOISE_HOPPING_FREQ */
;;;553    							if(IS_FINGER_PEN_MODE(eSensingMode))
;;;554    							{
;;;555    			#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;556    				#if USED_WGP_PEN_UHD_16LHB_OPERATION
;;;557    								if(tHalIntrHandle.ulTSyncInRisingCnt == 0 || tHalIntrHandle.ulTSyncInRisingCnt == 8)
;;;558    								{
;;;559    									PWMDRV_Set_DSSS_INFO(hal_Info_GetChangeWGPPenBeaconType());
;;;560    								}
;;;561    								/*
;;;562    								 * Current Beacon Type change in T-Sync Rising Edge Interrupt after Changed the Up-Link.
;;;563    								 */
;;;564    								if(tHalIntrHandle.ulTSyncInRisingCnt == 1 || tHalIntrHandle.ulTSyncInRisingCnt == 9)
;;;565    								{
;;;566    									if(hal_Info_GetChangeCompleteWGPPenBeaconType() != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;567    									{
;;;568    										hal_Info_SetCurrentWGPPenBeaconType(hal_Info_GetChangeCompleteWGPPenBeaconType());
;;;569    										hal_Info_SetChangeCompleteWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
;;;570    									}
;;;571    								#if USED_NOISE_HOPPING_FREQ
;;;572    									if(hal_Info_GetCurrentWGPPenBeaconType() == PWM_WGP_PEN_HOPP_SETTABLE_BEACON)
;;;573    									{
;;;574    										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;575    									}
;;;576    								#endif
;;;577    								}
;;;578    
;;;579    								if(IS_ACTIVE_MODE(eSensingMode))
;;;580    								{
;;;581    									if(tHalIntrHandle.ulLocalIndexChangeStart == 1 &&
;;;582    										(tHalIntrHandle.ulTSyncInRisingCnt == 1 || tHalIntrHandle.ulTSyncInRisingCnt == 9  || tHalIntrHandle.ulTSyncInRisingCnt == 15))
;;;583    									{
;;;584    										uint32_t ulTempNextSPISize;
;;;585    										tAlgorithmInfo_t * ptAlgorithmInfo = algorithm_GetInfo();
;;;586    										if(tHalIntrHandle.ulTSyncInRisingCnt == 1)
;;;587    										{
;;;588    											ulTempNextSPISize = 0;
;;;589    										}
;;;590    										else if(tHalIntrHandle.ulTSyncInRisingCnt == 9)
;;;591    										{
;;;592    											ulTempNextSPISize = 7;
;;;593    										}
;;;594    										else if(tHalIntrHandle.ulTSyncInRisingCnt == 15)
;;;595    										{
;;;596    											ulTempNextSPISize = 12;
;;;597    										}
;;;598    										SRIC_SetLocalIndex(((ulTempNextSPISize << 16) | sensingRowStart));
;;;599    										MSPI_Set_BUFSIZE_FingerPenMode(ulTempNextSPISize);
;;;600    										p_currentRowStart = currentRowStart;
;;;601    										currentRowStart = sensingRowStart;
;;;602    										currentColStart = ptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;603    									}
;;;604    								}
;;;605    				#else /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;606    								if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;607    								{
;;;608    									PWMDRV_Set_DSSS_INFO(hal_Info_GetChangeWGPPenBeaconType());
;;;609    								}
;;;610    								/*
;;;611    								 * Current Beacon Type change in T-Sync Rising Edge Interrupt after Changed the Up-Link.
;;;612    								 */
;;;613    								if(tHalIntrHandle.ulTSyncInRisingCnt == 1)
;;;614    								{
;;;615    									if(hal_Info_GetChangeCompleteWGPPenBeaconType() != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;616    									{
;;;617    										hal_Info_SetCurrentWGPPenBeaconType(hal_Info_GetChangeCompleteWGPPenBeaconType());
;;;618    										hal_Info_SetChangeCompleteWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
;;;619    									}
;;;620    								#if USED_NOISE_HOPPING_FREQ
;;;621    									if(hal_Info_GetCurrentWGPPenBeaconType() == PWM_WGP_PEN_HOPP_SETTABLE_BEACON)
;;;622    									{
;;;623    										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;624    									}
;;;625    								#endif
;;;626    								}
;;;627    								if(IS_ACTIVE_MODE(eSensingMode))
;;;628    								{
;;;629    									if(tHalIntrHandle.ulLocalIndexChangeStart == 1 &&
;;;630    											tHalIntrHandle.ulTSyncInRisingCnt == 1)
;;;631    									{
;;;632    										tAlgorithmInfo_t * ptAlgorithmInfo = algorithm_GetInfo();
;;;633    										SRIC_SetLocalIndex(sensingRowStart);
;;;634    										MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;635    										p_currentRowStart = currentRowStart;
;;;636    										currentRowStart = sensingRowStart;
;;;637    										currentColStart = ptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;638    									}
;;;639    								}
;;;640    				#endif /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;641    			#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;642    								if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;643    								{
;;;644    									PWMDRV_Set_DSSS_INFO(hal_Info_GetChangeWGPPenBeaconType());
;;;645    								}
;;;646    								/*
;;;647    								 * Current Beacon Type change in T-Sync Rising Edge Interrupt after Changed the Up-Link.
;;;648    								 */
;;;649    								if(tHalIntrHandle.ulTSyncInRisingCnt == 1)
;;;650    								{
;;;651    									if(hal_Info_GetChangeCompleteWGPPenBeaconType() != PWM_WGP_PEN_BEACON_CHANGE_DONE)
;;;652    									{
;;;653    										hal_Info_SetCurrentWGPPenBeaconType(hal_Info_GetChangeCompleteWGPPenBeaconType());
;;;654    										hal_Info_SetChangeCompleteWGPPenBeaconType(PWM_WGP_PEN_BEACON_CHANGE_DONE);
;;;655    									}
;;;656    								}
;;;657    			#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;658    							}
;;;659    		#endif /* USED_NOISE_HOPPING_FREQ */
;;;660    							else
;;;661    	#endif /* USED_PEN_MODE_OPERATION */
;;;662    							{
;;;663    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON && !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM)
;;;664    
;;;665    		#if USED_PWM_PULSE_END_FLAG_CHECK
;;;666    									if(tHalIntrHandle.ulPWM_Pulse_End_Flag == YES)
;;;667    									{
;;;668    			#if USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE
;;;669    										SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;670    			#else /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;671    										SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;672    			#endif /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;673    			#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;674    										GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_LOW);
;;;675    			#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;676    										tHalIntrHandle.ulPWM_Pulse_End_Flag = NO;
;;;677    									}
;;;678    		#endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;679    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON && !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM) */
;;;680    							}
;;;681    	#if IS_MULTI_PROTOCOL_OPERATION
;;;682    							break;
;;;683    	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;684    						}
;;;685    #endif /* IS_MULTI_PROTOCOL_OPERATION || IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION */
;;;686    #if IS_MULTI_PROTOCOL_OPERATION
;;;687    					} /* switch(ePenType) */
;;;688    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;689    
;;;690    #if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;691    					if(ulUplinkCtrlCheckBitMask & (1<<tHalIntrHandle.ulTSyncInFallingCnt))
;;;692    					{
;;;693    						SET_GPIO_Uplink_GPIO_STATUS = GPIO_DATA_LOW;
;;;694    					}
;;;695    #endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;696    				}
;;;697    
;;;698    #if USED_FINGER_OTHER_PWM_MUX_NUM_LAST_LHB
;;;699    				if(IS_ACTIVE_MODE(eSensingMode))
;;;700    	#if USED_PEN_MODE_OPERATION
;;;701    				{
;;;702    					uint32_t ulPWMOtherCtrlBitMask;
;;;703    					uint32_t ulPWMNormalCtrlBitMask;
;;;704    					if(IS_FINGER_PEN_MODE(eSensingMode))
;;;705    					{
;;;706    						ulPWMOtherCtrlBitMask = DEF_FINGER_PWM_OTHER_NUM_SET_BIT_MASK_Local;
;;;707    						ulPWMNormalCtrlBitMask = DEF_FINGER_PWM_NORMAL_NUM_SET_BIT_MASK_Local;
;;;708    					}
;;;709    					else
;;;710    					{
;;;711    						ulPWMOtherCtrlBitMask = DEF_FINGER_PWM_OTHER_NUM_SET_BIT_MASK_Full;
;;;712    						ulPWMNormalCtrlBitMask = DEF_FINGER_PWM_NORMAL_NUM_SET_BIT_MASK_Full;
;;;713    					}
;;;714    
;;;715    		#if (IS_MULTI_PROTOCOL_OPERATION || IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION)
;;;716    					if(ulPWMOtherCtrlBitMask & (1<<tHalIntrHandle.ulTSyncInRisingCnt))
;;;717    					{
;;;718    						PWMDRV->MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_LAST_LHB_MUX_CR_finger;
;;;719    					}
;;;720    					else if(ulPWMNormalCtrlBitMask & (1<<tHalIntrHandle.ulTSyncInRisingCnt))
;;;721    					{
;;;722    						PWMDRV->MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_MUX_CR_finger;
;;;723    					}
;;;724    		#elif IS_MSPEN_PROTOCOL_OPERATION
;;;725    					if(ulPWMOtherCtrlBitMask & (1<<tHalIntrHandle.ulTSyncInRisingCnt))
;;;726    					{
;;;727    						PWMDRV->MUX_CR.tBit.finger = PARAMSET_PWMDRV_MPP_LAST_LHB_MUX_CR_finger;
;;;728    					}
;;;729    					else if(ulPWMNormalCtrlBitMask & (1<<tHalIntrHandle.ulTSyncInRisingCnt))
;;;730    					{
;;;731    						PWMDRV->MUX_CR.tBit.finger = PARAMSET_PWMDRV_MPP_MUX_CR_finger;
;;;732    					}
;;;733    		#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;734    				}
;;;735    	#else /* USED_PEN_MODE_OPERATION */
;;;736    				{
;;;737    					if(DEF_FINGER_PWM_OTHER_NUM_SET_BIT_MASK_Full & (1<<tHalIntrHandle.ulTSyncInRisingCnt))
;;;738    					{
;;;739    						PWMDRV->MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_LAST_LHB_MUX_CR_finger;
;;;740    					}
;;;741    					else if(DEF_FINGER_PWM_NORMAL_NUM_SET_BIT_MASK_Full & (1<<tHalIntrHandle.ulTSyncInRisingCnt))
;;;742    					{
;;;743    						PWMDRV->MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_MUX_CR_finger;
;;;744    					}
;;;745    				}
;;;746    	#endif /* USED_PEN_MODE_OPERATION */
;;;747    #endif /* USED_FINGER_OTHER_PWM_MUX_NUM_LAST_LHB */
;;;748    
;;;749    #if (!USED_QUEUECOMMONDATA_SEND_Timer_Tick)
;;;750    	#ifdef MODE_I2C
;;;751    				QueueCommonData_I2C();
;;;752    	#else
;;;753    				QueueCommonData_USB();
;;;754    	#endif
;;;755    #endif /* (!USED_QUEUECOMMONDATA_SEND_Timer_Tick) */
;;;756    
;;;757    #if USED_ECLK_ON_OFF_CONTROL
;;;758    				if(HAL_GetECLKOnOffControl())
;;;759    				{
;;;760    					HAL_ECLK_Off();
;;;761    				}
;;;762    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;763    			}
;;;764    
;;;765    		}
;;;766    
;;;767    		SCRB->PWM_INT_CLR.tBit.tsyncin_int_clr = 0x1;
;;;768    	}
;;;769    }
00000e  bf08              IT       EQ
000010  e8bd8ff8          POPEQ    {r3-r11,pc}
000014  4c8d              LDR      r4,|L11.588|
000016  6aa0              LDR      r0,[r4,#0x28]         ;76  ; tHalIntrHandle
000018  2700              MOVS     r7,#0                 ;76
00001a  2801              CMP      r0,#1                 ;76
00001c  bf04              ITT      EQ                    ;78
00001e  6227              STREQ    r7,[r4,#0x20]         ;78  ; tHalIntrHandle
000020  61e7              STREQ    r7,[r4,#0x1c]         ;79  ; tHalIntrHandle
000022  f00080f9          BEQ.W    |L11.536|
000026  f7fffffe          BL       HAL_GetSensingMode
00002a  4682              MOV      r10,r0                ;83
00002c  f7fffffe          BL       hal_Info_GetControlActivePenOPType
000030  f8d60150          LDR      r0,[r6,#0x150]        ;86
000034  f04f0901          MOV      r9,#1                 ;276
000038  f0100f08          TST      r0,#8                 ;86
00003c  d008              BEQ      |L11.80|
00003e  6a20              LDR      r0,[r4,#0x20]         ;313  ; tHalIntrHandle
000040  1c40              ADDS     r0,r0,#1              ;313
000042  6220              STR      r0,[r4,#0x20]         ;313  ; tHalIntrHandle
000044  6a20              LDR      r0,[r4,#0x20]         ;326  ; tHalIntrHandle
000046  2810              CMP      r0,#0x10              ;326
000048  d22b              BCS      |L11.162|
00004a  69e0              LDR      r0,[r4,#0x1c]         ;326  ; tHalIntrHandle
00004c  bb50              CBNZ     r0,|L11.164|
00004e  e028              B        |L11.162|
                  |L11.80|
000050  69e0              LDR      r0,[r4,#0x1c]         ;94  ; tHalIntrHandle
000052  1c40              ADDS     r0,r0,#1              ;94
000054  61e0              STR      r0,[r4,#0x1c]         ;94  ; tHalIntrHandle
000056  69e0              LDR      r0,[r4,#0x1c]         ;107  ; tHalIntrHandle
000058  2810              CMP      r0,#0x10              ;107
00005a  bf28              IT       CS                    ;109
00005c  61e7              STRCS    r7,[r4,#0x1c]         ;109  ; tHalIntrHandle
00005e  f41a7f80          TST      r10,#0x100            ;230
000062  bf14              ITE      NE                    ;239
000064  f44f7580          MOVNE    r5,#0x100             ;239
000068  f64f15f9          MOVEQ    r5,#0xf9f9            ;252
00006c  f7fffffe          BL       HAL_GetTPICMuxEnControl
000070  b158              CBZ      r0,|L11.138|
000072  69e0              LDR      r0,[r4,#0x1c]         ;276  ; tHalIntrHandle
000074  fa09f000          LSL      r0,r9,r0              ;276
000078  0400              LSLS     r0,r0,#16             ;276
00007a  0c00              LSRS     r0,r0,#16             ;276
00007c  d005              BEQ      |L11.138|
00007e  f8d60124          LDR      r0,[r6,#0x124]        ;278
000082  f0406080          ORR      r0,r0,#0x4000000      ;278
000086  f8c60124          STR      r0,[r6,#0x124]        ;278
                  |L11.138|
00008a  f7fffffe          BL       HAL_GetECLKOnOffControl
00008e  2800              CMP      r0,#0                 ;285
000090  d07e              BEQ      |L11.400|
000092  69e0              LDR      r0,[r4,#0x1c]         ;287  ; tHalIntrHandle
000094  fa09f000          LSL      r0,r9,r0              ;287
000098  4228              TST      r0,r5                 ;287
00009a  bf18              IT       NE                    ;289
00009c  f7fffffe          BLNE     HAL_ECLK_On
0000a0  e0ba              B        |L11.536|
                  |L11.162|
0000a2  6227              STR      r7,[r4,#0x20]         ;328  ; tHalIntrHandle
                  |L11.164|
0000a4  6a20              LDR      r0,[r4,#0x20]         ;332  ; tHalIntrHandle
0000a6  4d6a              LDR      r5,|L11.592|
0000a8  f04f2840          MOV      r8,#0x40004000        ;371
0000ac  f04f0b0f          MOV      r11,#0xf              ;374
0000b0  2800              CMP      r0,#0                 ;332
0000b2  d17b              BNE      |L11.428|
0000b4  f7fffffe          BL       module_SRIC_GetCommonConfig
0000b8  6940              LDR      r0,[r0,#0x14]         ;341
0000ba  9000              STR      r0,[sp,#0]            ;341
0000bc  f7fffffe          BL       MSPI_Set_TLPMODE
0000c0  f89d0000          LDRB     r0,[sp,#0]            ;344
0000c4  f0400001          ORR      r0,r0,#1              ;344
0000c8  f88d0000          STRB     r0,[sp,#0]            ;344
0000cc  9900              LDR      r1,[sp,#0]            ;345
0000ce  2014              MOVS     r0,#0x14              ;345
0000d0  f7fffffe          BL       MSPI_RegisterWrite
0000d4  f89d0000          LDRB     r0,[sp,#0]            ;346
0000d8  f0200001          BIC      r0,r0,#1              ;346
0000dc  f88d0000          STRB     r0,[sp,#0]            ;346
0000e0  9900              LDR      r1,[sp,#0]            ;347
0000e2  2014              MOVS     r0,#0x14              ;347
0000e4  f7fffffe          BL       MSPI_RegisterWrite
0000e8  f7fffffe          BL       module_SRIC_GetCommonConfig
0000ec  6880              LDR      r0,[r0,#8]            ;352
0000ee  9000              STR      r0,[sp,#0]            ;352
0000f0  f89d0000          LDRB     r0,[sp,#0]            ;353
0000f4  f0400008          ORR      r0,r0,#8              ;353
0000f8  f88d0000          STRB     r0,[sp,#0]            ;353
0000fc  9900              LDR      r1,[sp,#0]            ;354
0000fe  2008              MOVS     r0,#8                 ;354
000100  f7fffffe          BL       MSPI_RegisterWrite
000104  f89d0000          LDRB     r0,[sp,#0]            ;355
000108  f0200008          BIC      r0,r0,#8              ;355
00010c  f88d0000          STRB     r0,[sp,#0]            ;355
000110  9900              LDR      r1,[sp,#0]            ;356
000112  2008              MOVS     r0,#8                 ;356
000114  f7fffffe          BL       MSPI_RegisterWrite
000118  4650              MOV      r0,r10                ;368
00011a  f7fffffe          BL       MSPI_Set_AITMODE
00011e  f8c87028          STR      r7,[r8,#0x28]         ;371
000122  2000              MOVS     r0,#0                 ;372
000124  f7fffffe          BL       MSPI_Set_BUFSIZE_FingerPenMode
000128  6027              STR      r7,[r4,#0]            ;373  ; tHalIntrHandle
00012a  f8c8b028          STR      r11,[r8,#0x28]        ;374
00012e  68f0              LDR      r0,[r6,#0xc]          ;377
000130  f0400040          ORR      r0,r0,#0x40           ;377
000134  60f0              STR      r0,[r6,#0xc]          ;377
000136  68f0              LDR      r0,[r6,#0xc]          ;378
000138  f0200040          BIC      r0,r0,#0x40           ;378
00013c  60f0              STR      r0,[r6,#0xc]          ;378
00013e  61e7              STR      r7,[r4,#0x1c]         ;379  ; tHalIntrHandle
000140  f8c49018          STR      r9,[r4,#0x18]         ;380  ; tHalIntrHandle
000144  f8940024          LDRB     r0,[r4,#0x24]         ;382  ; tHalIntrHandle
000148  b318              CBZ      r0,|L11.402|
00014a  f8847024          STRB     r7,[r4,#0x24]         ;384
00014e  6a68              LDR      r0,[r5,#0x24]         ;385
000150  f0400008          ORR      r0,r0,#8              ;385
000154  6268              STR      r0,[r5,#0x24]         ;385
000156  6a68              LDR      r0,[r5,#0x24]         ;386
000158  f4406000          ORR      r0,r0,#0x800          ;386
00015c  6268              STR      r0,[r5,#0x24]         ;386
00015e  f8d50080          LDR      r0,[r5,#0x80]         ;388
000162  f0400040          ORR      r0,r0,#0x40           ;388
000166  f8c50080          STR      r0,[r5,#0x80]         ;388
00016a  f8d50080          LDR      r0,[r5,#0x80]         ;389
00016e  f4407000          ORR      r0,r0,#0x200          ;389
000172  f8c50080          STR      r0,[r5,#0x80]         ;389
000176  f8d50084          LDR      r0,[r5,#0x84]         ;390
00017a  f0400040          ORR      r0,r0,#0x40           ;390
00017e  f8c50084          STR      r0,[r5,#0x84]         ;390
000182  f8d50084          LDR      r0,[r5,#0x84]         ;391
000186  f4407000          ORR      r0,r0,#0x200          ;391
00018a  f8c50084          STR      r0,[r5,#0x84]         ;391
00018e  e001              B        |L11.404|
                  |L11.400|
000190  e042              B        |L11.536|
                  |L11.402|
000192  e00b              B        |L11.428|
                  |L11.404|
000194  f8d50084          LDR      r0,[r5,#0x84]         ;393
000198  f0400010          ORR      r0,r0,#0x10           ;393
00019c  f8c50084          STR      r0,[r5,#0x84]         ;393
0001a0  f8d50084          LDR      r0,[r5,#0x84]         ;394
0001a4  f0400080          ORR      r0,r0,#0x80           ;394
0001a8  f8c50084          STR      r0,[r5,#0x84]         ;394
                  |L11.428|
0001ac  6a20              LDR      r0,[r4,#0x20]         ;445  ; tHalIntrHandle
0001ae  2809              CMP      r0,#9                 ;445
0001b0  d12c              BNE      |L11.524|
0001b2  f7fffffe          BL       HAL_GetSensingChangeMode
0001b6  2804              CMP      r0,#4                 ;447
0001b8  d036              BEQ      |L11.552|
0001ba  f41a7f80          TST      r10,#0x100            ;458
0001be  d025              BEQ      |L11.524|
0001c0  f8849024          STRB     r9,[r4,#0x24]         ;460
0001c4  f8d50084          LDR      r0,[r5,#0x84]         ;468
0001c8  f0200040          BIC      r0,r0,#0x40           ;468
0001cc  f8c50084          STR      r0,[r5,#0x84]         ;468
0001d0  f8d50084          LDR      r0,[r5,#0x84]         ;469
0001d4  f4207000          BIC      r0,r0,#0x200          ;469
0001d8  f8c50084          STR      r0,[r5,#0x84]         ;469
0001dc  f8d50084          LDR      r0,[r5,#0x84]         ;471
0001e0  f0200010          BIC      r0,r0,#0x10           ;471
0001e4  f8c50084          STR      r0,[r5,#0x84]         ;471
0001e8  f8d50084          LDR      r0,[r5,#0x84]         ;472
0001ec  f0200080          BIC      r0,r0,#0x80           ;472
0001f0  f8c50084          STR      r0,[r5,#0x84]         ;472
0001f4  f8d50080          LDR      r0,[r5,#0x80]         ;473
0001f8  f0400010          ORR      r0,r0,#0x10           ;473
0001fc  f8c50080          STR      r0,[r5,#0x80]         ;473
000200  f8d50080          LDR      r0,[r5,#0x80]         ;474
000204  f0400080          ORR      r0,r0,#0x80           ;474
000208  f8c50080          STR      r0,[r5,#0x80]         ;474
                  |L11.524|
00020c  f7fffffe          BL       HAL_GetECLKOnOffControl
000210  2800              CMP      r0,#0                 ;758
000212  bf18              IT       NE                    ;760
000214  f7fffffe          BLNE     HAL_ECLK_Off
                  |L11.536|
000218  f8d6008c          LDR      r0,[r6,#0x8c]         ;767
00021c  f0400010          ORR      r0,r0,#0x10           ;767
000220  f8c6008c          STR      r0,[r6,#0x8c]         ;767
000224  e8bd8ff8          POP      {r3-r11,pc}
                  |L11.552|
000228  2004              MOVS     r0,#4                 ;449
00022a  f7fffffe          BL       HAL_CheckSensningModeChange
00022e  2800              CMP      r0,#0                 ;449
000230  d0ec              BEQ      |L11.524|
000232  2002              MOVS     r0,#2                 ;451
000234  f7fffffe          BL       HAL_SetSensingChangeMode
000238  f8c87028          STR      r7,[r8,#0x28]         ;452
00023c  2000              MOVS     r0,#0                 ;453
00023e  f7fffffe          BL       MSPI_Set_BUFSIZE_FingerPenMode
000242  f8c49000          STR      r9,[r4,#0]            ;454  ; tHalIntrHandle
000246  f8c8b028          STR      r11,[r8,#0x28]        ;455
00024a  e7df              B        |L11.524|
;;;770    
                          ENDP

                  |L11.588|
                          DCD      tHalIntrHandle
                  |L11.592|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_TSync_Out_InterruptHandler||, CODE, READONLY, ALIGN=2

                  PWMDRV_TSync_Out_InterruptHandler PROC
;;;770    
;;;771    void PWMDRV_TSync_Out_InterruptHandler(void)
000000  b510              PUSH     {r4,lr}
;;;772    {
;;;773    	if(SCRB->SYS_INT_ST.tBit.int_tsyncout != 0)
000002  f04f4480          MOV      r4,#0x40000000
000006  69a0              LDR      r0,[r4,#0x18]
000008  f4101f80          TST      r0,#0x100000
;;;774    	{
;;;775    #if (USED_S3_VDD_OE_INPUT_OUTPUT_CTRL || USED_ECLK_ON_OFF_CONTROL || USED_TPIC_MUXEN_ON_OFF_CONTROL)
;;;776    		if(tHalIntrHandle.ulInitFirstFrame == 1)
;;;777    		{
;;;778    //			_gT(_GPIO_TP_INTR);
;;;779    		}
;;;780    		else
;;;781    		{
;;;782    #if USED_PWM_PULSE_END_FLAG_CHECK
;;;783    			if(tHalIntrHandle.ulPWM_Pulse_End_Flag == YES)
;;;784    			{
;;;785    				tHalIntrHandle.ulPWM_Pulse_End_Flag = NO;
;;;786    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM)
;;;787    				if(HAL_GetTPICMuxEnControl())
;;;788    				{
;;;789    					SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;790    		#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;791    					GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_LOW);
;;;792    		#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;793    				}
;;;794    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM) */
;;;795    			}
;;;796    			else
;;;797    #endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;798    			{
;;;799    #if USED_ECLK_ON_OFF_CONTROL
;;;800    				if(HAL_GetECLKOnOffControl())
;;;801    				{
;;;802    					HAL_ECLK_On();
;;;803    				}
;;;804    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;805    
;;;806    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;807    				if(HAL_GetTPICMuxEnControl())
;;;808    				{
;;;809    					SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;810    //					_gOut(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;811    	#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;812    					GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_HIGH);
;;;813    	#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;814    				}
;;;815    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;816    #if USED_S3_VDD_OE_INPUT_OUTPUT_CTRL
;;;817    				HAL_Change_S3_VDD_OddEven_Stauts();
;;;818    #endif /* USED_S3_VDD_OE_INPUT_OUTPUT_CTRL */
;;;819    			}
;;;820    		}
;;;821    #endif /* (USED_S3_VDD_OE_INPUT_OUTPUT_CTRL || USED_ECLK_ON_OFF_CONTROL || USED_TPIC_MUXEN_ON_OFF_CONTROL) */
;;;822    
;;;823    		SCRB->PWM_INT_CLR.tBit.tsyncout_int_clr = 0x1;
;;;824    
;;;825    #if USED_OPERATION_STAND_ALONE
;;;826    	#if (!USED_QUEUECOMMONDATA_SEND_Timer_Tick)
;;;827    		#ifdef MODE_I2C
;;;828    		QueueCommonData_I2C();
;;;829    		#else
;;;830    		QueueCommonData_USB();
;;;831    		#endif
;;;832    	#endif /* (!USED_QUEUECOMMONDATA_SEND_Timer_Tick) */
;;;833    #endif /* USED_OPERATION_STAND_ALONE */
;;;834    	}
;;;835    }
00000c  bf08              IT       EQ
00000e  bd10              POPEQ    {r4,pc}
000010  480c              LDR      r0,|L12.68|
000012  6a80              LDR      r0,[r0,#0x28]         ;776  ; tHalIntrHandle
000014  2801              CMP      r0,#1                 ;776
000016  d00e              BEQ      |L12.54|
000018  f7fffffe          BL       HAL_GetECLKOnOffControl
00001c  2800              CMP      r0,#0                 ;800
00001e  bf18              IT       NE                    ;802
000020  f7fffffe          BLNE     HAL_ECLK_On
000024  f7fffffe          BL       HAL_GetTPICMuxEnControl
000028  b128              CBZ      r0,|L12.54|
00002a  f8d40124          LDR      r0,[r4,#0x124]        ;809
00002e  f0406080          ORR      r0,r0,#0x4000000      ;809
000032  f8c40124          STR      r0,[r4,#0x124]        ;809
                  |L12.54|
000036  f8d4008c          LDR      r0,[r4,#0x8c]         ;823
00003a  f0400020          ORR      r0,r0,#0x20           ;823
00003e  f8c4008c          STR      r0,[r4,#0x8c]         ;823
000042  bd10              POP      {r4,pc}
;;;836    
                          ENDP

                  |L12.68|
                          DCD      tHalIntrHandle

                          AREA ||i.PWMDRV_VSync_In_InterruptHandler||, CODE, READONLY, ALIGN=1

                  PWMDRV_VSync_In_InterruptHandler PROC
;;;45     
;;;46     void PWMDRV_VSync_In_InterruptHandler(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;47     {
;;;48     	if(SCRB->SYS_INT_ST.tBit.int_vsyncin != 0)
000004  6981              LDR      r1,[r0,#0x18]
000006  f4112f80          TST      r1,#0x40000
00000a  d005              BEQ      |L13.24|
;;;49     	{
;;;50     		SCRB->PWM_INT_CLR.tBit.vsyncin_int_clr = 0x1;
00000c  f8d0108c          LDR      r1,[r0,#0x8c]
000010  f0410108          ORR      r1,r1,#8
000014  f8c0108c          STR      r1,[r0,#0x8c]
                  |L13.24|
;;;51     #if USED_TOUCH_TUNING_PROCESS
;;;52     #include "app_tuning_process.h"
;;;53     		if(gtuning_ctrl_RawTune_Type.ulVSync_TouchSync_Timing_Index != tHalIntrHandle.ulTSyncInFallingCnt)
;;;54     		{
;;;55     			gtuning_ctrl_RawTune_Type.ulVSync_TouchSync_Timing_Index = tHalIntrHandle.ulTSyncInFallingCnt;
;;;56     			gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_Count = gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_CheckCount;
;;;57     			gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_CheckCount = 0;
;;;58     		}
;;;59     		else
;;;60     		{
;;;61     			gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_CheckCount++;
;;;62     		}
;;;63     #endif /* USED_TOUCH_TUNING_PROCESS */
;;;64     	}
;;;65     
;;;66     	if(SCRB->SYS_INT_ST.tBit.int_tsync_ab != 0)
000018  6981              LDR      r1,[r0,#0x18]
00001a  f4110f00          TST      r1,#0x800000
;;;67     	{
;;;68     		SCRB->PWM_INT_CLR.tBit.tsync_ab_int_clr = 0x1;
;;;69     	}
;;;70     }
00001e  bf08              IT       EQ
000020  4770              BXEQ     lr
000022  f8d0108c          LDR      r1,[r0,#0x8c]         ;68
000026  f0410104          ORR      r1,r1,#4              ;68
00002a  f8c0108c          STR      r1,[r0,#0x8c]         ;68
00002e  4770              BX       lr
;;;71     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  0a000000          DCB      0x0a,0x00,0x00,0x00
                          DCD      0x00000003
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      0x00000003
000014  01000000          DCB      0x01,0x00,0x00,0x00
000018  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      0x00000003
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x00000003
00002c  01000000          DCB      0x01,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  g_tCP_LHB_CONFIG21
000000  00006000          DCB      0x00,0x00,0x60,0x00
                  g_tCP_LHB_CONFIG22
000004  d9b6b52d          DCB      0xd9,0xb6,0xb5,0x2d
                  g_tCP_LHB_CONFIG23
000008  6ddbb62d          DCB      0x6d,0xdb,0xb6,0x2d
                  g_tCP_LHB_CONFIG24
00000c  2d000000          DCB      0x2d,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\pwmdrv\\pwmdrv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_pwmdrv_c_b42e3490____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___8_pwmdrv_c_b42e3490____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_pwmdrv_c_b42e3490____REVSH|
#line 402
|__asm___8_pwmdrv_c_b42e3490____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_pwmdrv_c_b42e3490____RRX|
#line 587
|__asm___8_pwmdrv_c_b42e3490____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
