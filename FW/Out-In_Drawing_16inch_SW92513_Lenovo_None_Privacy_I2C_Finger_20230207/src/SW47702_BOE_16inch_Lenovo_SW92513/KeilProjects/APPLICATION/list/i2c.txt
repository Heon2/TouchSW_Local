; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\i2c.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\i2c.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\i2c.crf ..\..\Hal\i2c\i2c.c]
                          THUMB

                          AREA ||i.CallReadyStatus_ToHost||, CODE, READONLY, ALIGN=2

                  CallReadyStatus_ToHost PROC
;;;452    // 2021.12.06
;;;453    uint8_t CallReadyStatus_ToHost(void)
000000  b510              PUSH     {r4,lr}
;;;454    {
000002  b092              SUB      sp,sp,#0x48
;;;455    	HID_MULTITOUCH_I2C 	DummyData = { 0, };
000004  2144              MOVS     r1,#0x44
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;456    	uint8_t*			pFlag = NULL;
;;;457    	uint8_t* 			pFeatureBit = NULL;
;;;458    	uint8_t 			bRet = FALSE;
;;;459    
;;;460    	DummyData.I2C_Length = sizeof(HID_MULTITOUCH_I2C);
00000c  2042              MOVS     r0,#0x42
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;461    	DummyData.Data.ReportID = HID_REPORT_ID__MULTI_TOUCH;
000012  2010              MOVS     r0,#0x10
000014  f88d0002          STRB     r0,[sp,#2]
;;;462    	DummyData.Data.ContactCount = 0;
000018  2000              MOVS     r0,#0
00001a  f88d003f          STRB     r0,[sp,#0x3f]
;;;463    	pFlag = (uint8_t*)&DummyData.Data.ScanTime;
;;;464    	pFlag[0] = 'L';
00001e  204c              MOVS     r0,#0x4c
000020  f88d0040          STRB     r0,[sp,#0x40]
;;;465    	pFlag[1] = 'X';
000024  2058              MOVS     r0,#0x58
000026  f88d0041          STRB     r0,[sp,#0x41]
;;;466    
;;;467    	pFeatureBit = (uint8_t*)&DummyData.Data.Touch[0];
;;;468    	*pFeatureBit |= FEATURELIST__COMMAND_FEATURE;
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  490d              LDR      r1,|L1.100|
;;;469    	*pFeatureBit |= FEATURELIST__READYSTATUS_INTERRUPT;
000030  f0400003          ORR      r0,r0,#3
000034  f88d0003          STRB     r0,[sp,#3]
000038  7809              LDRB     r1,[r1,#0]  ; g_tDelayCheckInfo
00003a  2000              MOVS     r0,#0
;;;470    	*pFeatureBit |= FEATURELIST__RESERVED_1;
;;;471    	*pFeatureBit |= FEATURELIST__RESERVED_2;
;;;472    	*pFeatureBit |= FEATURELIST__RESERVED_3;
;;;473    	*pFeatureBit |= FEATURELIST__RESERVED_4;
;;;474    	*pFeatureBit |= FEATURELIST__RESERVED_5;
;;;475    	*pFeatureBit |= FEATURELIST__RESERVED_6;
;;;476    
;;;477    	bRet = SendTouchData_I2C(&DummyData);
00003c  466c              MOV      r4,sp
00003e  2900              CMP      r1,#0
;;;478    	return bRet;
;;;479    }
000040  bf1c              ITT      NE
000042  b012              ADDNE    sp,sp,#0x48
000044  bd10              POPNE    {r4,pc}
000046  4808              LDR      r0,|L1.104|
000048  f7fffffe          BL       StaticQueue_CheckFull
00004c  2801              CMP      r0,#1
00004e  bf04              ITT      EQ
000050  4805              LDREQ    r0,|L1.104|
000052  f7fffffe          BLEQ     StaticQueue_HeadDelete
000056  4621              MOV      r1,r4
000058  4803              LDR      r0,|L1.104|
00005a  f7fffffe          BL       StaticQueue_Push
00005e  b012              ADD      sp,sp,#0x48
000060  2001              MOVS     r0,#1
000062  bd10              POP      {r4,pc}
;;;480    
                          ENDP

                  |L1.100|
                          DCD      ||area_number.17||+0xa
                  |L1.104|
                          DCD      g_Queue_Common

                          AREA ||i.GetCustomData_I2C||, CODE, READONLY, ALIGN=2

                  GetCustomData_I2C PROC
;;;401    #ifdef MODE_I2C
;;;402    void GetCustomData_I2C(uint8_t* pData)
000000  4601              MOV      r1,r0
;;;403    {
;;;404    	memcpy(&g_CustomBuffer_I2C.Data, pData, I2C_DATA_LENGTH);
000002  2240              MOVS     r2,#0x40
000004  4801              LDR      r0,|L2.12|
000006  f7ffbffe          B.W      __aeabi_memcpy
;;;405    	return;
;;;406    }
;;;407    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||+0x503

                          AREA ||i.I2C_DeInitialize||, CODE, READONLY, ALIGN=2

                  I2C_DeInitialize PROC
;;;1250   
;;;1251   void I2C_DeInitialize(void)
000000  b508              PUSH     {r3,lr}
;;;1252   {
;;;1253   	GPIO_Set_Mode(_GPIO_SLV_SCL, GPIO_MODE_FUNC_0);
000002  2100              MOVS     r1,#0
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       GPIO_Set_Mode
;;;1254   	GPIO_Set_Mode(_GPIO_SLV_SDA, GPIO_MODE_FUNC_0);
00000a  2100              MOVS     r1,#0
00000c  2003              MOVS     r0,#3
00000e  f7fffffe          BL       GPIO_Set_Mode
;;;1255   
;;;1256   	tSYS_CLK_CTL _SYS_CLK_CTL;
;;;1257   	Fncp_I2C_SLV_IRQHandler = NULL;
000012  490a              LDR      r1,|L3.60|
000014  2000              MOVS     r0,#0
000016  6008              STR      r0,[r1,#0]  ; Fncp_I2C_SLV_IRQHandler
000018  f04f21e0          MOV      r1,#0xe000e000
00001c  f04f7000          MOV      r0,#0x2000000
000020  f8c10200          STR      r0,[r1,#0x200]
000024  f8c10180          STR      r0,[r1,#0x180]
;;;1258   
;;;1259   	// I2C SLAVE Setting
;;;1260   	NVIC_SetPendingIRQ(I2C_SLV_IRQn);    /* Interrupt Enable */
;;;1261   	NVIC_DisableIRQ(I2C_SLV_IRQn);    /* Interrupt Disable */
;;;1262   	_SYS_CLK_CTL.ulBulk = SCRB->SYS_CLK_CTL.ulBulk;
000028  0140              LSLS     r0,r0,#5
00002a  6881              LDR      r1,[r0,#8]
00002c  9100              STR      r1,[sp,#0]
;;;1263   	_SYS_CLK_CTL.tBit.i2cm0clk_en = YES;
;;;1264   	_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = YES;
;;;1265   	_SYS_CLK_CTL.tBit.i2cm1clk_en = YES;
;;;1266   	_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = YES;
00002e  f44121f0          ORR      r1,r1,#0x78000
;;;1267   	SCRB->SYS_CLK_CTL.ulBulk = _SYS_CLK_CTL.ulBulk;
000032  9100              STR      r1,[sp,#0]
000034  9900              LDR      r1,[sp,#0]
000036  6081              STR      r1,[r0,#8]
;;;1268   }
000038  bd08              POP      {r3,pc}
;;;1269   
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      Fncp_I2C_SLV_IRQHandler

                          AREA ||i.I2C_Initialize||, CODE, READONLY, ALIGN=2

                  I2C_Initialize PROC
;;;1216   
;;;1217   void I2C_Initialize(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1218   {
;;;1219   	Fncp_I2C_SLV_IRQHandler = &I2C_InterruptHandler;
000004  493b              LDR      r1,|L4.244|
000006  483a              LDR      r0,|L4.240|
;;;1220   
;;;1221   	GPIO_Set_Mode(_GPIO_SLV_SCL, GPIO_MODE_FUNC_0);
000008  6008              STR      r0,[r1,#0]  ; Fncp_I2C_SLV_IRQHandler
00000a  2100              MOVS     r1,#0
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       GPIO_Set_Mode
;;;1222   	GPIO_Set_Mode(_GPIO_SLV_SDA, GPIO_MODE_FUNC_0);
000012  2100              MOVS     r1,#0
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       GPIO_Set_Mode
00001a  4837              LDR      r0,|L4.248|
00001c  f44f7180          MOV      r1,#0x100
000020  2700              MOVS     r7,#0
000022  8001              STRH     r1,[r0,#0]
000024  f240316b          MOV      r1,#0x36b
000028  8041              STRH     r1,[r0,#2]
00002a  2121              MOVS     r1,#0x21
00002c  8081              STRH     r1,[r0,#4]
00002e  2124              MOVS     r1,#0x24
000030  80c1              STRH     r1,[r0,#6]
000032  2142              MOVS     r1,#0x42
000034  8101              STRH     r1,[r0,#8]
000036  2125              MOVS     r1,#0x25
000038  8141              STRH     r1,[r0,#0xa]
00003a  2144              MOVS     r1,#0x44
00003c  8181              STRH     r1,[r0,#0xc]
00003e  2122              MOVS     r1,#0x22
000040  81c1              STRH     r1,[r0,#0xe]
000042  2123              MOVS     r1,#0x23
000044  8201              STRH     r1,[r0,#0x10]
000046  f64211bd          MOV      r1,#0x29bd
00004a  8241              STRH     r1,[r0,#0x12]
00004c  f6491102          MOV      r1,#0x9902
000050  8281              STRH     r1,[r0,#0x14]
000052  f44f7181          MOV      r1,#0x102
000056  82c1              STRH     r1,[r0,#0x16]
000058  6187              STR      r7,[r0,#0x18]  ; g_I2CHidDescriptor
00005a  f100061c          ADD      r6,r0,#0x1c
00005e  4827              LDR      r0,|L4.252|
000060  463d              MOV      r5,r7
000062  2408              MOVS     r4,#8
000064  6801              LDR      r1,[r0,#0]  ; u8_HID_MultiTouch_Descriptor_Head
000066  6031              STR      r1,[r6,#0]
000068  6840              LDR      r0,[r0,#4]  ; u8_HID_MultiTouch_Descriptor_Head
00006a  6070              STR      r0,[r6,#4]
                  |L4.108|
00006c  1930              ADDS     r0,r6,r4
00006e  2243              MOVS     r2,#0x43
000070  4923              LDR      r1,|L4.256|
000072  f7fffffe          BL       __aeabi_memcpy
000076  f1040043          ADD      r0,r4,#0x43
00007a  b284              UXTH     r4,r0
00007c  1c68              ADDS     r0,r5,#1
00007e  b2c5              UXTB     r5,r0
000080  2d0a              CMP      r5,#0xa
000082  d3f3              BCC      |L4.108|
000084  1930              ADDS     r0,r6,r4
000086  2245              MOVS     r2,#0x45
000088  491e              LDR      r1,|L4.260|
00008a  f7fffffe          BL       __aeabi_memcpy
00008e  f1040045          ADD      r0,r4,#0x45
000092  b280              UXTH     r0,r0
000094  4430              ADD      r0,r0,r6
000096  2280              MOVS     r2,#0x80
000098  491b              LDR      r1,|L4.264|
00009a  f7fffffe          BL       __aeabi_memcpy
00009e  f04f21e0          MOV      r1,#0xe000e000
0000a2  f04f7000          MOV      r0,#0x2000000
0000a6  f8c10200          STR      r0,[r1,#0x200]
0000aa  f8c10100          STR      r0,[r1,#0x100]
0000ae  4817              LDR      r0,|L4.268|
0000b0  f8807400          STRB     r7,[r0,#0x400]
;;;1223   
;;;1224   #ifdef MODE_I2C
;;;1225   	// I2C SLAVE Setting
;;;1226   	Init_HidDescriptor();
;;;1227   	Init_HidReportDescriptor();
;;;1228   #endif
;;;1229   
;;;1230   	// I2C SLAVE Setting
;;;1231   	NVIC_SetPendingIRQ(I2C_SLV_IRQn);    /* Interrupt Enable */
;;;1232   	NVIC_EnableIRQ(I2C_SLV_IRQn);    /* Interrupt Enable */
;;;1233   	NVIC_SetPriority(I2C_SLV_IRQn, I2C_SLV_IRQn_Priority);
;;;1234   
;;;1235   	I2C->I2C_DEVICE_ADDR.tBit.I2cId = I2C_ADDRESS;
0000b4  4816              LDR      r0,|L4.272|
0000b6  f8501f80          LDR      r1,[r0,#0x80]!
0000ba  f021017f          BIC      r1,r1,#0x7f
0000be  3109              ADDS     r1,r1,#9
0000c0  6001              STR      r1,[r0,#0]
;;;1236   	I2C->I2C_SW_RESET.tBit.I2cSWReset = 1;
0000c2  6841              LDR      r1,[r0,#4]
0000c4  f0410101          ORR      r1,r1,#1
0000c8  6041              STR      r1,[r0,#4]
;;;1237   	I2C->I2C_DEVICE_ADDR.tBit.I2cId	= I2C_ADDRESS;
0000ca  6801              LDR      r1,[r0,#0]
0000cc  f021017f          BIC      r1,r1,#0x7f
0000d0  3109              ADDS     r1,r1,#9
0000d2  6001              STR      r1,[r0,#0]
;;;1238   
;;;1239   	/*
;;;1240   	 * I2C SCL Hold En
;;;1241   	 */
;;;1242   //	I2C->I2C_SCL_HOLD.tBit.I2cSclHoldEn = 1;
;;;1243   
;;;1244   	I2C->I2C_GLB_CR.ulBulk = 0x000007FF;
0000d4  f24071ff          MOV      r1,#0x7ff
0000d8  6081              STR      r1,[r0,#8]
;;;1245   
;;;1246   	// FIFO
;;;1247   	I2C->I2C_FIFO_CR.tBit.TxFifoInit = 1;
0000da  69c1              LDR      r1,[r0,#0x1c]
0000dc  f0410101          ORR      r1,r1,#1
0000e0  61c1              STR      r1,[r0,#0x1c]
;;;1248   	I2C->I2C_FIFO_CR.tBit.RxFifoInit = 1;
0000e2  69c1              LDR      r1,[r0,#0x1c]
0000e4  f4417180          ORR      r1,r1,#0x100
0000e8  61c1              STR      r1,[r0,#0x1c]
;;;1249   }
0000ea  e8bd81f0          POP      {r4-r8,pc}
;;;1250   
                          ENDP

0000ee  0000              DCW      0x0000
                  |L4.240|
                          DCD      I2C_InterruptHandler
                  |L4.244|
                          DCD      Fncp_I2C_SLV_IRQHandler
                  |L4.248|
                          DCD      ||.bss||+0xa1
                  |L4.252|
                          DCD      u8_HID_MultiTouch_Descriptor_Head
                  |L4.256|
                          DCD      u8_HID_MultiTouch_Descriptor_Main
                  |L4.260|
                          DCD      u8_HID_MultiTouch_Descriptor_Tail
                  |L4.264|
                          DCD      u8_HID_Custom_Descriptor
                  |L4.268|
                          DCD      0xe000e019
                  |L4.272|
                          DCD      0x40007000

                          AREA ||i.I2C_InterruptHandler||, CODE, READONLY, ALIGN=2

                  I2C_InterruptHandler PROC
;;;590    
;;;591    void I2C_InterruptHandler(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;592    {
;;;593    	uint32_t ulI2CItrptState = I2C->I2C_GLB_SR.tBit.I2cItrptState;
000004  4ef8              LDR      r6,|L5.1000|
000006  f8d60094          LDR      r0,[r6,#0x94]
00000a  f3c04903          UBFX     r9,r0,#16,#4
;;;594    	uint32_t ulI2cSlvRdWrFlag = I2C->I2C_GLB_SR.tBit.I2cSlvRdWrFlag;
00000e  f8d60094          LDR      r0,[r6,#0x94]
;;;595    	do
;;;596    	{
;;;597    		// Interrupt Clear
;;;598    		I2C->I2C_GLB_SR.tBit.I2C_ITRPT = 0;
000012  f8d61094          LDR      r1,[r6,#0x94]
000016  f3c000c0          UBFX     r0,r0,#3,#1           ;594
00001a  f0210101          BIC      r1,r1,#1
00001e  f8c61094          STR      r1,[r6,#0x94]
;;;599    
;;;600    #ifdef MODE_I2C
;;;601    		// Reset !!!
;;;602    		if (g_bReset == I2C_RESET)
000022  4df2              LDR      r5,|L5.1004|
000024  2700              MOVS     r7,#0
000026  f04f0b01          MOV      r11,#1
00002a  78a9              LDRB     r1,[r5,#2]  ; g_bReset
;;;603    		{
;;;604    			g_nResetTxCount += 1;
;;;605    			I2C->I2C_TXFIFO_DATA  = 0;
;;;606    
;;;607    			if (g_nResetTxCount >= 2)
;;;608    			{
;;;609    				g_bReset = I2C_NORMAL;
;;;610    				
;;;611    				// Check GPIO Interrupt
;;;612    //				if (IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_LOW)
;;;613    				if(GPIO_TP_INTR_OUT_STATUS == GPIO_DATA_LOW)
00002c  f04f4a80          MOV      r10,#0x40000000
000030  2901              CMP      r1,#1                 ;602
000032  d009              BEQ      |L5.72|
;;;614    				{
;;;615    					// Disable GPIO Interrupt
;;;616    					GPIO_TP_INTR_OUT_STATUS = GPIO_DATA_HIGH;
;;;617    //					GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;618    				}
;;;619    			}
;;;620    
;;;621    			break;
;;;622    		}
;;;623    #endif // MODE_I2C
;;;624    
;;;625    		//
;;;626    		// Host --> Device
;;;627    		//
;;;628    		if (ulI2cSlvRdWrFlag == 0)
000034  b300              CBZ      r0,|L5.120|
;;;629    		{
;;;630    			uint8_t 	ReadData = 0;
;;;631    			uint8_t 	bCompleted = FALSE;
;;;632    #ifdef MODE_I2C
;;;633    			uint16_t*	pCheckRegister = NULL;
;;;634    #endif
;;;635    
;;;636    			if (I2C->I2C_FIFO_SR2.tBit.RxFifoEmpty != 0)
;;;637    			{
;;;638    				break;
;;;639    			}
;;;640    
;;;641    			if (g_RxCommandIndex == 0)
;;;642    			{
;;;643    				Protocol_hid_Init();
;;;644    			}
;;;645    
;;;646    			ReadData = (uint8_t)(I2C->I2C_RXFIFO_DATA & 0xFF);
;;;647    			if (g_RxCommandIndex < 100)
;;;648    			{
;;;649    				g_RxCommand[g_RxCommandIndex] = ReadData;
;;;650    				g_RxCommandIndex += 1;
;;;651    			}
;;;652    			
;;;653    
;;;654    			if (g_RxCommandIndex < 2)
;;;655    			{
;;;656    				break;
;;;657    			}
;;;658    
;;;659    #ifdef MODE_I2C
;;;660    			g_TxByteInterruptCount = 0;
;;;661    			///////////////// 2021.08.06 josh3 //////////////////
;;;662    			////
;;;663    			////    To block Touch or Pen data while device process Protocol data.
;;;664    //			g_StartTime_I2C = 0;
;;;665    //			g_DelayTime = 0;
;;;666    			g_tDelayCheckInfo.bIsDelayStart = YES;
;;;667    			g_tDelayCheckInfo.usDelayStopCheckCount = 0;
;;;668    
;;;669    			// Cancel touch or pen data transmission. (for SUD with ISP board)
;;;670    //			if (IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_LOW)
;;;671    			if(GPIO_TP_INTR_OUT_STATUS == GPIO_DATA_LOW)
;;;672    			{
;;;673    				// Disable GPIO Interrupt
;;;674    				GPIO_TP_INTR_OUT_STATUS = GPIO_DATA_HIGH;
;;;675    //				GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;676    
;;;677    				// Init value
;;;678    				g_TxSendCount = 0;
;;;679    				g_CheckComplete_Common_I2C = DMA_READY;
;;;680    				g_TxPtr_Common = NULL;
;;;681    				g_TxIndex_Common = 0;
;;;682    
;;;683    				// Clear Tx
;;;684    				I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;685    
;;;686    				// Clear Queue
;;;687    				StaticQueue_Init(&g_Queue_Common);
;;;688    			}
;;;689    			////
;;;690    			////
;;;691    			/////////////////////////////////////////////////////
;;;692    				
;;;693    			pCheckRegister = (uint16_t*)g_RxCommand;
;;;694    			switch(pCheckRegister[0])
;;;695    			{
;;;696    				// I2C HID Descriptor
;;;697    				case HID_DESCRIPTOR_ADDRESS:
;;;698    				{
;;;699    					uint16_t	Length = 0;
;;;700    
;;;701    					// Clear Tx
;;;702    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;703    
;;;704    					// I2C HID Descriptor
;;;705    					Length = sizeof(I2C_HID_DESCRIPTOR) + 2;
;;;706    					g_TxSendCount = Length;
;;;707    
;;;708    					I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;709    					I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;710    
;;;711    					g_TxPtr = (uint8_t*)&g_I2CHidDescriptor;
;;;712    					g_TxIndex = 0;
;;;713    
;;;714    					bCompleted = TRUE;
;;;715    					break;
;;;716    				}
;;;717    				case I2C_REPORT_REGISTER:
;;;718    				{
;;;719    					// Clear Tx
;;;720    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;721    
;;;722    					// HID Report Descriptor
;;;723    					g_TxPtr = (uint8_t*)g_HID_ReportDesc_Temp;
;;;724    					g_TxSendCount = g_I2CHidDescriptor.ReportLength;
;;;725    					
;;;726    					// Length
;;;727    					g_TxIndex = 0;
;;;728    					I2C->I2C_TXFIFO_DATA = g_TxPtr[g_TxIndex];
;;;729    					g_TxIndex += 1;
;;;730    					I2C->I2C_TXFIFO_DATA = g_TxPtr[g_TxIndex];
;;;731    					g_TxIndex += 1;
;;;732    
;;;733    					bCompleted = TRUE;
;;;734    					break;
;;;735    				}
;;;736    
;;;737    				case I2C_COMMAND_REGISTER:
;;;738    				{
;;;739    					PI2C__REQUEST pRequest = (PI2C__REQUEST)g_RxCommand;
;;;740    
;;;741    					if (pRequest->OpCode == I2C__REQUEST_OPCODE__SET_REPORT)
;;;742    					{
;;;743    						// 2021.12.04 josh3
;;;744    						// ex: 0x0150( 22 00 32 03 23 00 07 00 02 0E 00 01 50 )
;;;745    						if (pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__FEATURE_4)
;;;746    						{
;;;747    							PI2C__REQUEST_LXS pRequestLxs = (PI2C__REQUEST_LXS)g_RxCommand;
;;;748    
;;;749    							if (g_RxCommandIndex < 13)
;;;750    							{
;;;751    								break;
;;;752    							}
;;;753    
;;;754    							if (pRequestLxs->ProtocolDataLength > 0)
;;;755    							{
;;;756    								g_CustomBuffer_I2C.I2C_Length = 0x42;
;;;757    								g_CustomBuffer_I2C.Data.PacketID = 0x09;
;;;758    								g_CustomBuffer_I2C.Data.DeviceID_b.bRead = FALSE;
;;;759    								g_CustomBuffer_I2C.Data.DeviceID_b.addr = 0x34;
;;;760    								g_CustomBuffer_I2C.Data.Length = 2;
;;;761    								g_CustomBuffer_I2C.Data.Data[0] = pRequestLxs->Data[0];
;;;762    								g_CustomBuffer_I2C.Data.Data[1] = pRequestLxs->Data[1];
;;;763    
;;;764    								// Length - For next read command
;;;765    								g_FeatureDataLength = pRequestLxs->ProtocolDataLength;
;;;766    
;;;767    								RecieveCustomData_I2C(&g_CustomBuffer_I2C);
;;;768    							}
;;;769    							else
;;;770    							{
;;;771    								// Just check !!!
;;;772    								// ( 22 00 32 03 23 00 07 00 02 00 00 07 98 )
;;;773    								g_FeatureDataLength = 0;
;;;774    							}
;;;775    
;;;776    							bCompleted = TRUE;
;;;777    							break;
;;;778    						}
;;;779    #if USED_WACOM_HIDI2C_DRIVER
;;;780    						// Report ID 0x0B - Set Wacom Mode (22 00 3B 03 23 00 06 00 0B 01 00 00)
;;;781    						else if (pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__WACOM_CUSTOM)
;;;782    						{
;;;783    							if (g_RxCommandIndex < 12)
;;;784    							{
;;;785    								break;
;;;786    							}
;;;787    
;;;788    							// 0 : MS Inbox Driver
;;;789    							// 1 :  Wacom ISD Driver
;;;790    							if (HID_REPORT_ID__WACOM_CUSTOM == pRequest->Data[0])
;;;791    							{
;;;792    								g_WacomISD = pRequest->Data[1];
;;;793    							}
;;;794    
;;;795    							bCompleted = TRUE;
;;;796    							break;
;;;797    						}
;;;798    #endif /* USED_WACOM_HIDI2C_DRIVER */
;;;799    					}
;;;800    					else if (pRequest->OpCode == I2C__REQUEST_OPCODE__GET_REPORT)
;;;801    					{
;;;802    						switch(pRequest->I2C_Request_Common.ReportID)
;;;803    						{
;;;804    							// ( 22 00 34 02 23 00 )
;;;805    							case HID_REPORT_ID__FEATURE_2:
;;;806    							case HID_REPORT_ID__FEATURE_4:
;;;807    							case HID_REPORT_ID__FEATURE_6:
;;;808    							case HID_REPORT_ID__FEATURE_20:
;;;809    							case HID_REPORT_ID__FEATURE_60:
;;;810    							{
;;;811    								uint16_t	Length = 0;
;;;812    								uint16_t	index = 0;
;;;813    								uint8_t		nData = 0;
;;;814    
;;;815    								if (g_RxCommandIndex < 6)
;;;816    								{
;;;817    									break;
;;;818    								}
;;;819    
;;;820    								g_FeatureData.ReportID = pRequest->I2C_Request_Common.ReportID;
;;;821    								memset(g_FeatureData.Data, 0, 60);
;;;822    
;;;823    
;;;824    								if (g_FeatureDataLength == 0)
;;;825    								{
;;;826    									// Just check !!!
;;;827    									g_FeatureData.Data[0] = 0x98;
;;;828    									g_FeatureData.Data[1] = 0x07;
;;;829    									g_FeatureDataLength = 2;
;;;830    								}
;;;831    								else
;;;832    								{
;;;833    									for (index = 0; index < g_FeatureDataLength; index++)
;;;834    									{
;;;835    										if (Protocol_hid_FromDeviceToHost(&nData, FALSE) == TRUE)
;;;836    										{
;;;837    											g_FeatureData.Data[index] = nData;
;;;838    										}
;;;839    									}
;;;840    								}
;;;841    
;;;842    								// Clear Tx
;;;843    								I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;844    
;;;845    								// Size
;;;846    								Length = g_FeatureDataLength + 3; // (ReportID + Length)
;;;847    								g_TxSendCount = Length;
;;;848    
;;;849    								I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;850    								I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;851    
;;;852    								// ex : 0x0150 ( 11 00 04 53 57 49 50 00 00 00 00 10 01 BD 29 01 32 .... )
;;;853    								g_TxPtr = (uint8_t*)&g_FeatureData;
;;;854    								g_TxIndex = 0;
;;;855    
;;;856    								bCompleted = TRUE;
;;;857    								break;
;;;858    							}
;;;859    
;;;860    							// Report ID : 8 - Get MaxTouch Count (22 00 38 02 23 00)
;;;861    							case HID_REPORT_ID__CONTACT_COUNT:
;;;862    							{
;;;863    								uint16_t	Length = 0;
;;;864    
;;;865    								if (g_RxCommandIndex < 6)
;;;866    								{
;;;867    									break;
;;;868    								}
;;;869    					
;;;870    								// Clear Tx
;;;871    								I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;872    
;;;873    								// Size
;;;874    								Length = sizeof(TOUCH_MAX_COUNT) + 2;
;;;875    								g_TxSendCount = Length;
;;;876    
;;;877    								I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;878    								I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;879    
;;;880    								g_TxPtr = (uint8_t*)&g_MaxTouchCount_I2C;
;;;881    								g_TxIndex = 0;
;;;882    
;;;883    								g_MaxTouchCount_I2C.ReportID = HID_REPORT_ID__CONTACT_COUNT;
;;;884    								g_MaxTouchCount_I2C.Count = HID_MAX_TOUCH;
;;;885    
;;;886    								bCompleted = TRUE;
;;;887    								break;
;;;888    							}
;;;889    
;;;890    							// Report ID : 6 - Get BlobCode (22 00 36 02 23 00)
;;;891    							case HID_REPORT_ID__BLOB_CODE:
;;;892    							{
;;;893    								uint16_t	Length = 0;
;;;894    
;;;895    								if (g_RxCommandIndex < 6)
;;;896    								{
;;;897    									break;
;;;898    								}
;;;899    					
;;;900    								// Clear Tx
;;;901    								I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;902    
;;;903    								// Size
;;;904    								Length = HID_TOUCH_BLOB_LENGTH + 2;
;;;905    								g_TxSendCount = Length;
;;;906    
;;;907    								I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;908    								I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;909    
;;;910    								g_TxPtr = (uint8_t*)u8_HID_Touch_Blob;
;;;911    								g_TxIndex = 0;
;;;912    
;;;913    								bCompleted = TRUE;
;;;914    								break;
;;;915    							}
;;;916    						}
;;;917    					}
;;;918    					//  Get Idle (22 00 10 04)
;;;919    					else if (pRequest->OpCode == I2C__REQUEST_OPCODE__GET_IDLE)
;;;920    					{
;;;921    						uint16_t	Length = 0;
;;;922    
;;;923    						if (g_RxCommandIndex < 4)
;;;924    						{
;;;925    							break;
;;;926    						}
;;;927    					
;;;928    						// Clear Tx
;;;929    						I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;930    
;;;931    						//  Size
;;;932    						Length = sizeof(TOUCH_IDLE) + 2;
;;;933    						g_TxSendCount = Length;
;;;934    
;;;935    						I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;936    						I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;937    
;;;938    						g_TxPtr = (uint8_t*)&g_TouchIdle_I2C;
;;;939    						g_TxIndex = 0;
;;;940    
;;;941    						bCompleted = TRUE;
;;;942    					}
;;;943    					else if (pRequest->OpCode == I2C__REQUEST_OPCODE__SET_POWER)
;;;944    					{
;;;945    						if (g_RxCommandIndex < 4)
;;;946    						{
;;;947    							break;
;;;948    						}
;;;949    
;;;950    						// Set Power (22 00 00 08)
;;;951    						if (pRequest->I2C_Request_Power.PowerState == I2C__REQUEST_REPORT_POWER_STATE__ON)
;;;952    						{
;;;953    							g_Ready = I2C_READY;
;;;954    							bCompleted = TRUE;
;;;955    						}
;;;956    						// Sleep (22 00 01 08)
;;;957    						else if (pRequest->I2C_Request_Power.PowerState == I2C__REQUEST_REPORT_POWER_STATE__SLEEP)
;;;958    						{
;;;959    							g_Ready = I2C_NOT_READY;
;;;960    							bCompleted = TRUE;
;;;961    						}
;;;962    					}
;;;963    					// Reset (22 00 00 01)
;;;964    					else if (pRequest->OpCode == I2C__REQUEST_OPCODE__RESET)
;;;965    					{
;;;966    						if (g_RxCommandIndex < 4)
;;;967    						{
;;;968    							break;
;;;969    						}
;;;970    
;;;971    						g_bReset = I2C_RESET;
;;;972    						g_nResetTxCount = 0;
;;;973    
;;;974    						// Clear Tx
;;;975    						I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;976    
;;;977    						// GPIO Interrupt Enable
;;;978    						GPIO_TP_INTR_OUT_STATUS = GPIO_DATA_LOW;
;;;979    //						GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;980    
;;;981    						bCompleted = TRUE;
;;;982    					}
;;;983    
;;;984    					break;
;;;985    				}
;;;986    				
;;;987    				case I2C_OUTPUT_REGISTER:
;;;988    				{
;;;989    					PI2C__OUTPUT pOutputData = (PI2C__OUTPUT)g_RxCommand;
;;;990    
;;;991    					if (pOutputData->ReportID == HID_REPORT_ID__CUSTOM_OUT)
;;;992    					{
;;;993    						// sizeof OUTPUT Data - 68 Bytes
;;;994    						if (g_RxCommandIndex != 68)
;;;995    						{
;;;996    							break;
;;;997    						}
;;;998    
;;;999    						// 0x0150
;;;1000   						if ((pOutputData->Data[0] == 0x69) && (pOutputData->Data[3] == 0x01) && (pOutputData->Data[4] == 0x50))
;;;1001   						{
;;;1002   							g_bCallReadyStatus = TRUE;
;;;1003   						}
;;;1004   
;;;1005   						GetCustomData_I2C(&pOutputData->ReportID);
;;;1006   						RecieveCustomData_I2C(&g_CustomBuffer_I2C);
;;;1007   
;;;1008   						// It can receive the custom out data without init command.
;;;1009   						// This case we have to check Ready here.
;;;1010   						g_Ready = I2C_READY;
;;;1011   
;;;1012   						bCompleted = TRUE;
;;;1013   					}
;;;1014   
;;;1015   					break;
;;;1016   				}
;;;1017   
;;;1018   				// SUD - Host to Device
;;;1019   				default:
;;;1020   				{
;;;1021   					if (g_RxCommandIndex == 2)
;;;1022   					{
;;;1023   						uint16_t usRegAddr = 0;
;;;1024   						uint8_t nData = 0;
;;;1025   						uint8_t b2Byte = FALSE;
;;;1026   
;;;1027   #if USED_I2C_READ_DATA_UNIT_2BYTE
;;;1028   						bIsTempSend = NO;
;;;1029   						b2Byte = TRUE;
;;;1030   #endif /* USED_I2C_READ_DATA_UNIT_2BYTE */
;;;1031   
;;;1032   						// Clear
;;;1033   						I2C->I2C_FIFO_CR.ulBulk |= 0x01;	
;;;1034   
;;;1035   						// Addr
;;;1036   						usRegAddr = g_RxCommand[0] << 8;
;;;1037   						usRegAddr |= g_RxCommand[1];
;;;1038   
;;;1039   						// 0x0150
;;;1040   						if ((g_RxCommand[0] == 0x01) && (g_RxCommand[1] == 0x50))
;;;1041   						{
;;;1042   							g_bCallReadyStatus = TRUE;
;;;1043   						}
;;;1044   
;;;1045   						Protocol_hid__SetAddress(usRegAddr);
;;;1046   						if (Protocol_hid_FromDeviceToHost(&nData, b2Byte) == TRUE)
;;;1047   						{
;;;1048   							I2C->I2C_TXFIFO_DATA = nData;
;;;1049   						}
;;;1050   					}
;;;1051   					else if (g_RxCommandIndex > 2)
;;;1052   					{
;;;1053   						// Data
;;;1054   						Protocol_hid__FromHostToDevice(g_RxCommand[g_RxCommandIndex-1]);
;;;1055   					}
;;;1056   					break;
;;;1057   				}
;;;1058   			}
;;;1059   #else // MODE_I2C
;;;1060   			if (g_RxCommandIndex == 2)
;;;1061   			{
;;;1062   				uint16_t usRegAddr = 0;
;;;1063   				uint8_t nData = 0;
;;;1064   				uint8_t b2Byte = FALSE;
;;;1065   
;;;1066   	#if USED_I2C_READ_DATA_UNIT_2BYTE
;;;1067   				bIsTempSend = NO;
;;;1068   				b2Byte = TRUE;
;;;1069   	#endif /* USED_I2C_READ_DATA_UNIT_2BYTE */
;;;1070   
;;;1071   				// Clear
;;;1072   				I2C->I2C_FIFO_CR.ulBulk |= 0x01;	
;;;1073   
;;;1074   				// Addr
;;;1075   				usRegAddr = g_RxCommand[0] << 8;
;;;1076   				usRegAddr |= g_RxCommand[1];
;;;1077   
;;;1078   				Protocol_hid__SetAddress(usRegAddr);
;;;1079   				if (Protocol_hid_FromDeviceToHost(&nData, b2Byte) == TRUE)
;;;1080   				{
;;;1081   					I2C->I2C_TXFIFO_DATA = nData;
;;;1082   				}
;;;1083   			}
;;;1084   			else if (g_RxCommandIndex > 2)
;;;1085   			{
;;;1086   				// Data
;;;1087   				Protocol_hid__FromHostToDevice(g_RxCommand[g_RxCommandIndex-1]);
;;;1088   			}
;;;1089   #endif // MODE_I2C
;;;1090   
;;;1091   			if (bCompleted == TRUE)
;;;1092   			{
;;;1093   				memset(g_RxCommand, 0, 100);
;;;1094   				g_RxCommandIndex = 0;
;;;1095   			}
;;;1096   		}
;;;1097   		//
;;;1098   		// Device --> Host
;;;1099   		//
;;;1100   		else if (ulI2cSlvRdWrFlag == 1)
000036  2800              CMP      r0,#0
000038  f000820f          BEQ.W    |L5.1114|
;;;1101   		{
;;;1102   #ifdef MODE_I2C
;;;1103   			if (ulI2CItrptState == I2C_BYTE_ITRPT)
00003c  f1b90f03          CMP      r9,#3
000040  f00081e8          BEQ.W    |L5.1044|
000044  f000b9e9          B.W      |L5.1050|
                  |L5.72|
000048  78e8              LDRB     r0,[r5,#3]            ;604  ; g_nResetTxCount
00004a  1c40              ADDS     r0,r0,#1              ;604
00004c  b2c0              UXTB     r0,r0                 ;604
00004e  70e8              STRB     r0,[r5,#3]            ;604
000050  f8c670a0          STR      r7,[r6,#0xa0]         ;605
000054  2802              CMP      r0,#2                 ;607
000056  f0c08200          BCC.W    |L5.1114|
00005a  70af              STRB     r7,[r5,#2]            ;609
00005c  f8da0104          LDR      r0,[r10,#0x104]       ;613
000060  f0100f10          TST      r0,#0x10              ;613
000064  f04081f9          BNE.W    |L5.1114|
000068  f8da0104          LDR      r0,[r10,#0x104]       ;616
00006c  f0400010          ORR      r0,r0,#0x10           ;616
000070  f8ca0104          STR      r0,[r10,#0x104]       ;616
000074  f000b9f1          B.W      |L5.1114|
                  |L5.120|
000078  f8d600c8          LDR      r0,[r6,#0xc8]         ;636
00007c  f4103f80          TST      r0,#0x10000           ;636
000080  f04081eb          BNE.W    |L5.1114|
000084  6928              LDR      r0,[r5,#0x10]         ;641  ; g_RxCommandIndex
000086  2800              CMP      r0,#0                 ;641
000088  bf08              IT       EQ                    ;643
00008a  f7fffffe          BLEQ     Protocol_hid_Init
00008e  f8d600a4          LDR      r0,[r6,#0xa4]         ;646
000092  4cd7              LDR      r4,|L5.1008|
000094  b2c1              UXTB     r1,r0                 ;646
000096  6928              LDR      r0,[r5,#0x10]         ;647  ; g_RxCommandIndex
000098  2864              CMP      r0,#0x64              ;647
00009a  d202              BCS      |L5.162|
00009c  5421              STRB     r1,[r4,r0]            ;649
00009e  1c40              ADDS     r0,r0,#1              ;649
0000a0  6128              STR      r0,[r5,#0x10]         ;650  ; g_RxCommandIndex
                  |L5.162|
0000a2  2802              CMP      r0,#2                 ;654
0000a4  f0c081d9          BCC.W    |L5.1114|
0000a8  48d2              LDR      r0,|L5.1012|
0000aa  62af              STR      r7,[r5,#0x28]         ;666  ; g_TxByteInterruptCount
0000ac  f880b000          STRB     r11,[r0,#0]           ;666
0000b0  8047              STRH     r7,[r0,#2]            ;667
0000b2  f8da0104          LDR      r0,[r10,#0x104]       ;671
0000b6  f0100f10          TST      r0,#0x10              ;671
0000ba  d113              BNE      |L5.228|
0000bc  f8da0104          LDR      r0,[r10,#0x104]       ;674
0000c0  f0400010          ORR      r0,r0,#0x10           ;674
0000c4  f8ca0104          STR      r0,[r10,#0x104]       ;674
0000c8  626f              STR      r7,[r5,#0x24]         ;679  ; g_TxSendCount
0000ca  f885b004          STRB     r11,[r5,#4]           ;679
0000ce  61ef              STR      r7,[r5,#0x1c]         ;681  ; g_TxPtr_Common
0000d0  622f              STR      r7,[r5,#0x20]         ;684  ; g_TxIndex_Common
0000d2  f8d6009c          LDR      r0,[r6,#0x9c]         ;684
0000d6  f0400001          ORR      r0,r0,#1              ;684
0000da  f8c6009c          STR      r0,[r6,#0x9c]         ;684
0000de  48c6              LDR      r0,|L5.1016|
0000e0  f7fffffe          BL       StaticQueue_Init
                  |L5.228|
0000e4  48c2              LDR      r0,|L5.1008|
0000e6  8801              LDRH     r1,[r0,#0]            ;694
0000e8  3064              ADDS     r0,r0,#0x64           ;711
0000ea  2901              CMP      r1,#1                 ;694
0000ec  d015              BEQ      |L5.282|
0000ee  2921              CMP      r1,#0x21              ;694
0000f0  d023              BEQ      |L5.314|
0000f2  f500608c          ADD      r0,r0,#0x460          ;756
0000f6  2922              CMP      r1,#0x22              ;694
0000f8  d036              BEQ      |L5.360|
0000fa  2925              CMP      r1,#0x25              ;694
0000fc  f0008126          BEQ.W    |L5.844|
000100  6928              LDR      r0,[r5,#0x10]         ;1021  ; g_RxCommandIndex
000102  2802              CMP      r0,#2                 ;1021
000104  f0008150          BEQ.W    |L5.936|
000108  f24081a7          BLS.W    |L5.1114|
00010c  4420              ADD      r0,r0,r4              ;1054
00010e  f8100c01          LDRB     r0,[r0,#-1]           ;1054
000112  f7fffffe          BL       Protocol_hid__FromHostToDevice
000116  f000b9a0          B.W      |L5.1114|
                  |L5.282|
00011a  f8d6109c          LDR      r1,[r6,#0x9c]         ;702
00011e  f0410101          ORR      r1,r1,#1              ;702
000122  f8c6109c          STR      r1,[r6,#0x9c]         ;702
000126  211e              MOVS     r1,#0x1e              ;705
000128  6269              STR      r1,[r5,#0x24]         ;708  ; g_TxSendCount
00012a  f8c610a0          STR      r1,[r6,#0xa0]         ;708
00012e  f8c670a0          STR      r7,[r6,#0xa0]         ;709
000132  e9c50705          STRD     r0,r7,[r5,#0x14]      ;709
000136  f000b930          B.W      |L5.922|
                  |L5.314|
00013a  f8d6109c          LDR      r1,[r6,#0x9c]         ;720
00013e  f0410101          ORR      r1,r1,#1              ;720
000142  f8c6109c          STR      r1,[r6,#0x9c]         ;720
000146  49ad              LDR      r1,|L5.1020|
000148  6169              STR      r1,[r5,#0x14]         ;724  ; g_TxPtr
00014a  8840              LDRH     r0,[r0,#2]            ;724  ; g_I2CHidDescriptor
00014c  61af              STR      r7,[r5,#0x18]         ;728  ; g_TxIndex
00014e  6268              STR      r0,[r5,#0x24]         ;728  ; g_TxSendCount
000150  7808              LDRB     r0,[r1,#0]            ;728
000152  f8c600a0          STR      r0,[r6,#0xa0]         ;728
000156  f8c5b018          STR      r11,[r5,#0x18]        ;730  ; g_TxIndex
00015a  7848              LDRB     r0,[r1,#1]            ;730
00015c  f8c600a0          STR      r0,[r6,#0xa0]         ;730
000160  2002              MOVS     r0,#2                 ;731
000162  61a8              STR      r0,[r5,#0x18]         ;734  ; g_TxIndex
000164  f000b919          B.W      |L5.922|
                  |L5.360|
000168  4ba1              LDR      r3,|L5.1008|
00016a  78d9              LDRB     r1,[r3,#3]            ;741
00016c  f001020f          AND      r2,r1,#0xf            ;741
000170  2a03              CMP      r2,#3                 ;741
000172  d00a              BEQ      |L5.394|
000174  2104              MOVS     r1,#4                 ;874
000176  2a02              CMP      r2,#2                 ;800
000178  d037              BEQ      |L5.490|
00017a  2a04              CMP      r2,#4                 ;919
00017c  d07e              BEQ      |L5.636|
00017e  2a08              CMP      r2,#8                 ;943
000180  d07d              BEQ      |L5.638|
000182  2a01              CMP      r2,#1                 ;964
000184  d07c              BEQ      |L5.640|
000186  f000b968          B.W      |L5.1114|
                  |L5.394|
00018a  7899              LDRB     r1,[r3,#2]            ;745
00018c  f001010f          AND      r1,r1,#0xf            ;745
000190  2902              CMP      r1,#2                 ;745
000192  f0408162          BNE.W    |L5.1114|
000196  692a              LDR      r2,[r5,#0x10]         ;749  ; g_RxCommandIndex
000198  4995              LDR      r1,|L5.1008|
00019a  2a0d              CMP      r2,#0xd               ;749
00019c  f0c0815d          BCC.W    |L5.1114|
0001a0  f8b12009          LDRH     r2,[r1,#9]            ;754
0001a4  2a00              CMP      r2,#0                 ;754
0001a6  bf08              IT       EQ                    ;773
0001a8  706f              STRBEQ   r7,[r5,#1]            ;773
0001aa  d06a              BEQ      |L5.642|
0001ac  2342              MOVS     r3,#0x42              ;756
0001ae  8003              STRH     r3,[r0,#0]            ;756
0001b0  2309              MOVS     r3,#9                 ;757
0001b2  7083              STRB     r3,[r0,#2]            ;757
0001b4  78c3              LDRB     r3,[r0,#3]            ;758  ; g_CustomBuffer_I2C
0001b6  f04f0c02          MOV      r12,#2                ;760
0001ba  f02303ff          BIC      r3,r3,#0xff           ;759
0001be  3368              ADDS     r3,r3,#0x68           ;759
0001c0  70c3              STRB     r3,[r0,#3]            ;759
0001c2  f8a0c004          STRH     r12,[r0,#4]           ;760
0001c6  f891c00b          LDRB     r12,[r1,#0xb]         ;761
0001ca  f880c006          STRB     r12,[r0,#6]           ;761
0001ce  7b09              LDRB     r1,[r1,#0xc]          ;762
0001d0  71c1              STRB     r1,[r0,#7]            ;762
0001d2  488b              LDR      r0,|L5.1024|
0001d4  706a              STRB     r2,[r5,#1]            ;765
0001d6  f0130f01          TST      r3,#1                 ;765
0001da  d002              BEQ      |L5.482|
0001dc  f7fffffe          BL       HidReadWrite__Read_I2C
0001e0  e0db              B        |L5.922|
                  |L5.482|
0001e2  1c80              ADDS     r0,r0,#2              ;767
0001e4  f7fffffe          BL       HidReadWrite__Write
0001e8  e0d7              B        |L5.922|
                  |L5.490|
0001ea  7898              LDRB     r0,[r3,#2]            ;802
0001ec  f000000f          AND      r0,r0,#0xf            ;802
0001f0  2809              CMP      r0,#9                 ;802
0001f2  f0808132          BCS.W    |L5.1114|
0001f6  e8dff000          TBB      [pc,r0]               ;802
0001fa  9505              DCB      0x95,0x05
0001fc  05050505          DCB      0x05,0x05,0x05,0x05
000200  62954b00          DCB      0x62,0x95,0x4b,0x00
000204  f88d7000          STRB     r7,[sp,#0]            ;813
000208  6929              LDR      r1,[r5,#0x10]         ;815  ; g_RxCommandIndex
00020a  2400              MOVS     r4,#0                 ;812
00020c  2906              CMP      r1,#6                 ;815
00020e  f0c08124          BCC.W    |L5.1114|
000212  f8df81f0          LDR      r8,|L5.1028|
000216  213c              MOVS     r1,#0x3c              ;821
000218  f8880000          STRB     r0,[r8,#0]            ;820
00021c  f1080001          ADD      r0,r8,#1              ;821
000220  f7fffffe          BL       __aeabi_memclr
000224  7868              LDRB     r0,[r5,#1]            ;824  ; g_FeatureDataLength
000226  2800              CMP      r0,#0                 ;824
000228  d008              BEQ      |L5.572|
00022a  d91a              BLS      |L5.610|
                  |L5.556|
00022c  f04f0100          MOV      r1,#0                 ;835
000230  4668              MOV      r0,sp                 ;835
000232  f7fffffe          BL       Protocol_hid_FromDeviceToHost
000236  2801              CMP      r0,#1                 ;835
000238  d10e              BNE      |L5.600|
00023a  e008              B        |L5.590|
                  |L5.572|
00023c  2098              MOVS     r0,#0x98              ;827
00023e  f8880001          STRB     r0,[r8,#1]            ;827
000242  2007              MOVS     r0,#7                 ;828
000244  f8880002          STRB     r0,[r8,#2]            ;828
000248  2002              MOVS     r0,#2                 ;829
00024a  7068              STRB     r0,[r5,#1]            ;829
00024c  e009              B        |L5.610|
                  |L5.590|
00024e  eb080104          ADD      r1,r8,r4              ;837
000252  f89d0000          LDRB     r0,[sp,#0]            ;837
000256  7048              STRB     r0,[r1,#1]            ;837
                  |L5.600|
000258  1c60              ADDS     r0,r4,#1              ;833
00025a  b284              UXTH     r4,r0                 ;833
00025c  7868              LDRB     r0,[r5,#1]            ;833  ; g_FeatureDataLength
00025e  4284              CMP      r4,r0                 ;833
000260  d3e4              BCC      |L5.556|
                  |L5.610|
000262  f8d6009c          LDR      r0,[r6,#0x9c]         ;843
000266  f0400001          ORR      r0,r0,#1              ;843
00026a  f8c6009c          STR      r0,[r6,#0x9c]         ;843
00026e  7868              LDRB     r0,[r5,#1]            ;846  ; g_FeatureDataLength
000270  1cc0              ADDS     r0,r0,#3              ;846
000272  b2c1              UXTB     r1,r0                 ;849
000274  6268              STR      r0,[r5,#0x24]         ;849  ; g_TxSendCount
000276  f8c610a0          STR      r1,[r6,#0xa0]         ;849
00027a  e003              B        |L5.644|
                  |L5.636|
00027c  e032              B        |L5.740|
                  |L5.638|
00027e  e044              B        |L5.778|
                  |L5.640|
000280  e051              B        |L5.806|
                  |L5.642|
000282  e08a              B        |L5.922|
                  |L5.644|
000284  0a00              LSRS     r0,r0,#8              ;850
000286  f8c600a0          STR      r0,[r6,#0xa0]         ;850
00028a  e9c58705          STRD     r8,r7,[r5,#0x14]      ;850
00028e  e084              B        |L5.922|
000290  6928              LDR      r0,[r5,#0x10]         ;865  ; g_RxCommandIndex
000292  2806              CMP      r0,#6                 ;865
000294  d346              BCC      |L5.804|
000296  f8d6009c          LDR      r0,[r6,#0x9c]         ;871
00029a  f0400001          ORR      r0,r0,#1              ;871
00029e  f8c6009c          STR      r0,[r6,#0x9c]         ;871
0002a2  2004              MOVS     r0,#4                 ;874
0002a4  6268              STR      r0,[r5,#0x24]         ;877  ; g_TxSendCount
0002a6  f8c610a0          STR      r1,[r6,#0xa0]         ;877
0002aa  f8c670a0          STR      r7,[r6,#0xa0]         ;878
0002ae  4856              LDR      r0,|L5.1032|
0002b0  e9c50705          STRD     r0,r7,[r5,#0x14]      ;883
0002b4  2108              MOVS     r1,#8                 ;883
0002b6  7001              STRB     r1,[r0,#0]            ;883
0002b8  210a              MOVS     r1,#0xa               ;884
0002ba  7041              STRB     r1,[r0,#1]            ;884
0002bc  e06d              B        |L5.922|
0002be  6928              LDR      r0,[r5,#0x10]         ;895  ; g_RxCommandIndex
0002c0  2806              CMP      r0,#6                 ;895
0002c2  d32f              BCC      |L5.804|
0002c4  f8d6009c          LDR      r0,[r6,#0x9c]         ;901
0002c8  f0400001          ORR      r0,r0,#1              ;901
0002cc  f8c6009c          STR      r0,[r6,#0x9c]         ;901
0002d0  f2401003          MOV      r0,#0x103             ;904
0002d4  6268              STR      r0,[r5,#0x24]         ;907  ; g_TxSendCount
0002d6  2003              MOVS     r0,#3                 ;907
0002d8  f8c600a0          STR      r0,[r6,#0xa0]         ;907
0002dc  f8c6b0a0          STR      r11,[r6,#0xa0]        ;908
0002e0  484a              LDR      r0,|L5.1036|
0002e2  e00f              B        |L5.772|
                  |L5.740|
0002e4  6928              LDR      r0,[r5,#0x10]         ;923  ; g_RxCommandIndex
0002e6  2804              CMP      r0,#4                 ;923
0002e8  d31c              BCC      |L5.804|
0002ea  f8d6009c          LDR      r0,[r6,#0x9c]         ;929
0002ee  f0400001          ORR      r0,r0,#1              ;929
0002f2  f8c6009c          STR      r0,[r6,#0x9c]         ;929
0002f6  2004              MOVS     r0,#4                 ;932
0002f8  6268              STR      r0,[r5,#0x24]         ;935  ; g_TxSendCount
0002fa  f8c610a0          STR      r1,[r6,#0xa0]         ;935
0002fe  f8c670a0          STR      r7,[r6,#0xa0]         ;936
000302  4843              LDR      r0,|L5.1040|
                  |L5.772|
000304  e9c50705          STRD     r0,r7,[r5,#0x14]      ;938
000308  e047              B        |L5.922|
                  |L5.778|
00030a  6928              LDR      r0,[r5,#0x10]         ;945  ; g_RxCommandIndex
00030c  2804              CMP      r0,#4                 ;945
00030e  d309              BCC      |L5.804|
000310  7898              LDRB     r0,[r3,#2]            ;951
000312  f0100f0f          TST      r0,#0xf               ;951
000316  d03e              BEQ      |L5.918|
000318  f000000f          AND      r0,r0,#0xf            ;957
00031c  2801              CMP      r0,#1                 ;957
00031e  bf08              IT       EQ                    ;959
000320  702f              STRBEQ   r7,[r5,#0]            ;959
000322  d03a              BEQ      |L5.922|
                  |L5.804|
000324  e099              B        |L5.1114|
                  |L5.806|
000326  6928              LDR      r0,[r5,#0x10]         ;966  ; g_RxCommandIndex
000328  2804              CMP      r0,#4                 ;966
00032a  d35c              BCC      |L5.998|
00032c  f885b002          STRB     r11,[r5,#2]           ;971
000330  70ef              STRB     r7,[r5,#3]            ;972
000332  f8d6009c          LDR      r0,[r6,#0x9c]         ;975
000336  f0400001          ORR      r0,r0,#1              ;975
00033a  f8c6009c          STR      r0,[r6,#0x9c]         ;975
00033e  f8da0104          LDR      r0,[r10,#0x104]       ;978
000342  f0200010          BIC      r0,r0,#0x10           ;978
000346  f8ca0104          STR      r0,[r10,#0x104]       ;978
00034a  e026              B        |L5.922|
                  |L5.844|
00034c  4928              LDR      r1,|L5.1008|
00034e  790a              LDRB     r2,[r1,#4]            ;991
000350  2a09              CMP      r2,#9                 ;991
000352  bf04              ITT      EQ                    ;994
000354  692a              LDREQ    r2,[r5,#0x10]         ;994  ; g_RxCommandIndex
000356  2a44              CMPEQ    r2,#0x44              ;994
000358  d17f              BNE      |L5.1114|
00035a  794a              LDRB     r2,[r1,#5]            ;1000
00035c  2a69              CMP      r2,#0x69              ;1000
00035e  bf04              ITT      EQ                    ;1000
000360  7a0a              LDRBEQ   r2,[r1,#8]            ;1000
000362  2a01              CMPEQ    r2,#1                 ;1000
000364  d104              BNE      |L5.880|
000366  7a4a              LDRB     r2,[r1,#9]            ;1000
000368  2a50              CMP      r2,#0x50              ;1000
00036a  bf08              IT       EQ                    ;1002
00036c  f885b005          STRBEQ   r11,[r5,#5]           ;1002
                  |L5.880|
000370  2240              MOVS     r2,#0x40              ;1002
000372  1c80              ADDS     r0,r0,#2              ;1002
000374  1d09              ADDS     r1,r1,#4              ;1002
000376  f7fffffe          BL       __aeabi_memcpy
00037a  4821              LDR      r0,|L5.1024|
00037c  7881              LDRB     r1,[r0,#2]            ;1006
00037e  2909              CMP      r1,#9                 ;1006
000380  d109              BNE      |L5.918|
000382  78c1              LDRB     r1,[r0,#3]            ;1006
000384  f0110f01          TST      r1,#1                 ;1006
000388  d002              BEQ      |L5.912|
00038a  f7fffffe          BL       HidReadWrite__Read_I2C
00038e  e002              B        |L5.918|
                  |L5.912|
000390  1c80              ADDS     r0,r0,#2              ;1006
000392  f7fffffe          BL       HidReadWrite__Write
                  |L5.918|
000396  f885b000          STRB     r11,[r5,#0]           ;1010
                  |L5.922|
00039a  2164              MOVS     r1,#0x64              ;1093
00039c  4814              LDR      r0,|L5.1008|
00039e  f7fffffe          BL       __aeabi_memclr
0003a2  612f              STR      r7,[r5,#0x10]         ;1094  ; g_RxCommandIndex
0003a4  e059              B        |L5.1114|
0003a6  bf00              NOP                            ;1024
                  |L5.936|
0003a8  f88d7000          STRB     r7,[sp,#0]            ;1024
0003ac  f8d6009c          LDR      r0,[r6,#0x9c]         ;1033
0003b0  f04f0800          MOV      r8,#0                 ;1025
0003b4  f0400001          ORR      r0,r0,#1              ;1033
0003b8  f8c6009c          STR      r0,[r6,#0x9c]         ;1033
0003bc  7822              LDRB     r2,[r4,#0]            ;1036  ; g_RxCommand
0003be  7861              LDRB     r1,[r4,#1]            ;1037  ; g_RxCommand
0003c0  2a01              CMP      r2,#1                 ;1040
0003c2  ea412002          ORR      r0,r1,r2,LSL #8       ;1037
0003c6  bf04              ITT      EQ                    ;1040
0003c8  2950              CMPEQ    r1,#0x50              ;1040
0003ca  f885b005          STRBEQ   r11,[r5,#5]           ;1042
0003ce  f7fffffe          BL       Protocol_hid__SetAddress
0003d2  4641              MOV      r1,r8                 ;1046
0003d4  4668              MOV      r0,sp                 ;1046
0003d6  f7fffffe          BL       Protocol_hid_FromDeviceToHost
0003da  2801              CMP      r0,#1                 ;1046
0003dc  bf04              ITT      EQ                    ;1048
0003de  f89d0000          LDRBEQ   r0,[sp,#0]            ;1048
0003e2  f8c600a0          STREQ    r0,[r6,#0xa0]         ;1048
                  |L5.998|
0003e6  e038              B        |L5.1114|
                  |L5.1000|
                          DCD      0x40007000
                  |L5.1004|
                          DCD      ||area_number.17||
                  |L5.1008|
                          DCD      ||.bss||+0x3d
                  |L5.1012|
                          DCD      ||area_number.17||+0xa
                  |L5.1016|
                          DCD      g_Queue_Common
                  |L5.1020|
                          DCD      ||.bss||+0xbd
                  |L5.1024|
                          DCD      ||.bss||+0x501
                  |L5.1028|
                          DCD      ||.bss||
                  |L5.1032|
                          DCD      ||area_number.17||+0x6
                  |L5.1036|
                          DCD      u8_HID_Touch_Blob
                  |L5.1040|
                          DCD      ||area_number.17||+0x8
                  |L5.1044|
;;;1104   			{
;;;1105   				g_TxByteInterruptCount += 1;
000414  6aa8              LDR      r0,[r5,#0x28]  ; g_TxByteInterruptCount
000416  1c40              ADDS     r0,r0,#1
000418  62a8              STR      r0,[r5,#0x28]  ; g_TxByteInterruptCount
                  |L5.1050|
00041a  4830              LDR      r0,|L5.1244|
00041c  6969              LDR      r1,[r5,#0x14]         ;602  ; g_TxPtr
00041e  6a40              LDR      r0,[r0,#0x24]         ;602
;;;1106   			}
;;;1107   			// HID over I2C - Command
;;;1108   			if (g_TxPtr != NULL)
000420  b189              CBZ      r1,|L5.1094|
;;;1109   			{
;;;1110   				I2C->I2C_TXFIFO_DATA = g_TxPtr[g_TxIndex];
000422  69aa              LDR      r2,[r5,#0x18]  ; g_TxIndex
000424  5c89              LDRB     r1,[r1,r2]
000426  f8c610a0          STR      r1,[r6,#0xa0]
;;;1111   				g_TxIndex += 1;
00042a  1c51              ADDS     r1,r2,#1
;;;1112   
;;;1113   				if (g_TxByteInterruptCount == g_TxSendCount)
00042c  61a9              STR      r1,[r5,#0x18]  ; g_TxIndex
00042e  6aa9              LDR      r1,[r5,#0x28]  ; g_TxByteInterruptCount
000430  4281              CMP      r1,r0
000432  d112              BNE      |L5.1114|
;;;1114   				{
;;;1115   					g_TxPtr = NULL;
;;;1116   					g_TxIndex = 0;
000434  616f              STR      r7,[r5,#0x14]  ; g_TxPtr
;;;1117   
;;;1118   					memset(g_RxCommand, 0, 100);
000436  2164              MOVS     r1,#0x64
000438  4829              LDR      r0,|L5.1248|
00043a  61af              STR      r7,[r5,#0x18]  ; g_TxIndex
00043c  f7fffffe          BL       __aeabi_memclr
;;;1119   					g_RxCommandIndex = 0;
;;;1120   
;;;1121   					g_TxByteInterruptCount = 0;
000440  612f              STR      r7,[r5,#0x10]  ; g_RxCommandIndex
000442  62af              STR      r7,[r5,#0x28]  ; g_TxByteInterruptCount
000444  e009              B        |L5.1114|
                  |L5.1094|
;;;1122   				}
;;;1123   			}
;;;1124   			// HID over I2C - Touch, Pen, Custom
;;;1125   			else if (g_TxPtr_Common != NULL)
000446  69ea              LDR      r2,[r5,#0x1c]  ; g_TxPtr_Common
000448  b3aa              CBZ      r2,|L5.1206|
;;;1126   			{
;;;1127   				if (g_TxIndex_Common < g_TxSendCount)
00044a  6a29              LDR      r1,[r5,#0x20]  ; g_TxIndex_Common
00044c  4281              CMP      r1,r0
00044e  d204              BCS      |L5.1114|
;;;1128   				{
;;;1129   					I2C->I2C_TXFIFO_DATA = g_TxPtr_Common[g_TxIndex_Common];
000450  5c50              LDRB     r0,[r2,r1]
000452  f8c600a0          STR      r0,[r6,#0xa0]
;;;1130   					g_TxIndex_Common += 1;
000456  1c48              ADDS     r0,r1,#1
000458  6228              STR      r0,[r5,#0x20]  ; g_TxIndex_Common
                  |L5.1114|
;;;1131   				}
;;;1132   
;;;1133   //				if (g_TxByteInterruptCount == g_TxSendCount)
;;;1134   //				{
;;;1135   //					g_CheckComplete_Common_I2C = DMA_READY;
;;;1136   //					g_TxPtr_Common = NULL;
;;;1137   //					g_TxIndex_Common = 0;
;;;1138   //					g_TxSendCount = 0;
;;;1139   //					g_TxByteInterruptCount = 0;
;;;1140   //					//Check GPIO Interrupt
;;;1141   //					if(GPIO_TP_INTR_OUT_STATUS == GPIO_DATA_LOW)
;;;1142   //					{
;;;1143   //						// Disable GPIO Interrupt
;;;1144   //						GPIO_TP_INTR_OUT_STATUS = GPIO_DATA_HIGH;
;;;1145   //					}
;;;1146   //				}
;;;1147   			}
;;;1148   			// SUD
;;;1149   			else
;;;1150   #endif /* MODE_I2C */
;;;1151   			{
;;;1152   				uint8_t nData = 0;
;;;1153   				uint8_t b2Byte = FALSE;
;;;1154   
;;;1155   				if (ulI2CItrptState == I2C_STP_ITRPT)
;;;1156   				{
;;;1157   					break;
;;;1158   				}
;;;1159   
;;;1160   #if USED_I2C_READ_DATA_UNIT_2BYTE
;;;1161   				b2Byte = TRUE;
;;;1162   #endif /* USED_I2C_READ_DATA_UNIT_2BYTE */
;;;1163   
;;;1164   				if (Protocol_hid_FromDeviceToHost(&nData, b2Byte) == TRUE)
;;;1165   				{
;;;1166   					I2C->I2C_TXFIFO_DATA = nData;
;;;1167   				}
;;;1168   			}
;;;1169   		}
;;;1170   
;;;1171   	} while (FALSE);
;;;1172   
;;;1173   	if (ulI2CItrptState == I2C_STP_ITRPT)
00045a  f1b90f02          CMP      r9,#2
;;;1174   	{
;;;1175   #ifdef MODE_I2C
;;;1176   		if (g_TxPtr != NULL)
;;;1177   		{
;;;1178   			g_TxPtr = NULL;
;;;1179   			g_TxIndex = 0;
;;;1180   		}
;;;1181   #endif // MODE_I2C
;;;1182   
;;;1183   		if (g_RxCommandIndex > 0)
;;;1184   		{		
;;;1185   			memset(g_RxCommand, 0, 100);
;;;1186   			g_RxCommandIndex = 0;
;;;1187   		}
;;;1188   #ifdef MODE_I2C
;;;1189   		g_tDelayCheckInfo.bIsDelayStopCheckCountEnable = YES;
;;;1190   
;;;1191   
;;;1192   		if (g_bReset != I2C_RESET)
;;;1193   		{
;;;1194   //			if (g_TxByteInterruptCount >= g_TxSendCount)
;;;1195   			{
;;;1196   				g_CheckComplete_Common_I2C = DMA_READY;
;;;1197   				g_TxPtr_Common = NULL;
;;;1198   				g_TxIndex_Common = 0;
;;;1199   				g_TxSendCount = 0;
;;;1200   				g_TxByteInterruptCount = 0;
;;;1201   			}
;;;1202   
;;;1203   			// Check GPIO Interrupt
;;;1204   			if(GPIO_TP_INTR_OUT_STATUS == GPIO_DATA_LOW)
;;;1205   			{
;;;1206   				// Disable GPIO Interrupt
;;;1207   				GPIO_TP_INTR_OUT_STATUS = GPIO_DATA_HIGH;
;;;1208   			}
;;;1209   		}
;;;1210   #endif
;;;1211   	}
;;;1212   
;;;1213   	return;
;;;1214   }
00045e  bf18              IT       NE
000460  e8bd8ff8          POPNE    {r3-r11,pc}
000464  6968              LDR      r0,[r5,#0x14]         ;1176  ; g_TxPtr
000466  2800              CMP      r0,#0                 ;1176
000468  bf1c              ITT      NE                    ;1179
00046a  616f              STRNE    r7,[r5,#0x14]         ;1179  ; g_TxPtr
00046c  61af              STRNE    r7,[r5,#0x18]         ;1179  ; g_TxIndex
                  |L5.1134|
00046e  6928              LDR      r0,[r5,#0x10]         ;1183  ; g_RxCommandIndex
000470  b120              CBZ      r0,|L5.1148|
000472  2164              MOVS     r1,#0x64              ;1185
000474  481a              LDR      r0,|L5.1248|
000476  f7fffffe          BL       __aeabi_memclr
00047a  612f              STR      r7,[r5,#0x10]         ;1186  ; g_RxCommandIndex
                  |L5.1148|
00047c  4819              LDR      r0,|L5.1252|
00047e  f880b001          STRB     r11,[r0,#1]           ;1189
000482  78a8              LDRB     r0,[r5,#2]            ;1192  ; g_bReset
000484  2801              CMP      r0,#1                 ;1192
000486  bf08              IT       EQ
000488  e8bd8ff8          POPEQ    {r3-r11,pc}
00048c  f885b004          STRB     r11,[r5,#4]           ;1196
000490  61ef              STR      r7,[r5,#0x1c]         ;1198  ; g_TxPtr_Common
000492  622f              STR      r7,[r5,#0x20]         ;1199  ; g_TxIndex_Common
000494  626f              STR      r7,[r5,#0x24]         ;1200  ; g_TxSendCount
000496  62af              STR      r7,[r5,#0x28]         ;1204  ; g_TxByteInterruptCount
000498  f8da0104          LDR      r0,[r10,#0x104]       ;1204
00049c  f0100f10          TST      r0,#0x10              ;1204
0004a0  bf18              IT       NE
0004a2  e8bd8ff8          POPNE    {r3-r11,pc}
0004a6  f8da0104          LDR      r0,[r10,#0x104]       ;1207
0004aa  f0400010          ORR      r0,r0,#0x10           ;1207
0004ae  f8ca0104          STR      r0,[r10,#0x104]       ;1207
0004b2  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.1206|
0004b6  e7ff              B        |L5.1208|
                  |L5.1208|
0004b8  2100              MOVS     r1,#0                 ;1153
0004ba  f88d7000          STRB     r7,[sp,#0]            ;1152
0004be  f1b90f02          CMP      r9,#2                 ;1155
0004c2  d0d4              BEQ      |L5.1134|
0004c4  4668              MOV      r0,sp                 ;1164
0004c6  f7fffffe          BL       Protocol_hid_FromDeviceToHost
0004ca  2801              CMP      r0,#1                 ;1164
0004cc  bf04              ITT      EQ                    ;1166
0004ce  f89d0000          LDRBEQ   r0,[sp,#0]            ;1166
0004d2  f8c600a0          STREQ    r0,[r6,#0xa0]         ;1166
0004d6  e8bd8ff8          POP      {r3-r11,pc}
;;;1215   
                          ENDP

0004da  0000              DCW      0x0000
                  |L5.1244|
                          DCD      ||area_number.17||
                  |L5.1248|
                          DCD      ||.bss||+0x3d
                  |L5.1252|
                          DCD      ||area_number.17||+0xa

                          AREA ||i.I2C_TxData||, CODE, READONLY, ALIGN=2

                  I2C_TxData PROC
;;;198    #ifdef MODE_I2C
;;;199    void I2C_TxData(uint8_t* pData, uint16_t Length)
000000  2900              CMP      r1,#0
;;;200    {
;;;201    	uint16_t i = 0;
;;;202    
;;;203    	for (i = 0; i < Length; i++)
;;;204    	{
;;;205    		I2C->I2C_TXFIFO_DATA = pData[i];
;;;206    	}
;;;207    
;;;208    	return;
;;;209    }
000002  bf08              IT       EQ
000004  4770              BXEQ     lr
000006  f0110201          ANDS     r2,r1,#1              ;206
00000a  4b0c              LDR      r3,|L6.60|
00000c  bf1c              ITT      NE                    ;205
00000e  f890c000          LDRBNE   r12,[r0,#0]           ;205
000012  f8c3c0a0          STRNE    r12,[r3,#0xa0]        ;205
000016  428a              CMP      r2,r1                 ;203
000018  bf28              IT       CS
00001a  4770              BXCS     lr
                  |L6.28|
00001c  f810c002          LDRB     r12,[r0,r2]           ;205
000020  f8c3c0a0          STR      r12,[r3,#0xa0]        ;205
000024  eb000c02          ADD      r12,r0,r2             ;205
000028  f89cc001          LDRB     r12,[r12,#1]          ;205
00002c  f8c3c0a0          STR      r12,[r3,#0xa0]        ;205
000030  1c92              ADDS     r2,r2,#2              ;205
000032  b292              UXTH     r2,r2                 ;205
000034  428a              CMP      r2,r1                 ;205
000036  d3f1              BCC      |L6.28|
000038  4770              BX       lr
;;;210    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x40007000

                          AREA ||i.Make_EmptyI2CData||, CODE, READONLY, ALIGN=2

                  Make_EmptyI2CData PROC
;;;210    
;;;211    void Make_EmptyI2CData(void)
000000  4808              LDR      r0,|L7.36|
;;;212    {
;;;213    	// Clear Tx
;;;214    	I2C->I2C_FIFO_CR.ulBulk |= 0x01;
000002  f8501f9c          LDR      r1,[r0,#0x9c]!
000006  f0410101          ORR      r1,r1,#1
00000a  6001              STR      r1,[r0,#0]
;;;215    
;;;216    	// It is ready 2byte as reponse Resect CMD from Host.
;;;217    	// It seems like to read 36Byte from Host.
;;;218    	I2C->I2C_TXFIFO_DATA = 0x00;
00000c  2100              MOVS     r1,#0
00000e  6041              STR      r1,[r0,#4]
;;;219    	I2C->I2C_TXFIFO_DATA = 0x00;
000010  6041              STR      r1,[r0,#4]
;;;220    
;;;221    	// GPIO Interrupt Enable
;;;222    	GPIO_TP_INTR_OUT_STATUS = GPIO_DATA_LOW;
000012  f04f4080          MOV      r0,#0x40000000
000016  f8d01104          LDR      r1,[r0,#0x104]
00001a  f0210110          BIC      r1,r1,#0x10
00001e  f8c01104          STR      r1,[r0,#0x104]
;;;223    //	GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;224    	return;
;;;225    }
000022  4770              BX       lr
;;;226    
                          ENDP

                  |L7.36|
                          DCD      0x40007000

                          AREA ||i.QueueCommonData_I2C||, CODE, READONLY, ALIGN=2

                  QueueCommonData_I2C PROC
;;;481    
;;;482    void QueueCommonData_I2C(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;483    {
;;;484    	if(g_tDelayCheckInfo.bIsDelayStopCheckCountEnable == YES)
000002  4e3f              LDR      r6,|L8.256|
000004  2400              MOVS     r4,#0
000006  b091              SUB      sp,sp,#0x44           ;483
000008  7870              LDRB     r0,[r6,#1]  ; g_tDelayCheckInfo
00000a  2801              CMP      r0,#1
;;;485    	{
;;;486    		if(g_tDelayCheckInfo.usDelayStopCheckCount > DEF_I2C_DELAY_CHECK_CNT_THD)
;;;487    		{
;;;488    			g_tDelayCheckInfo.bIsDelayStart = NO;
;;;489    			g_tDelayCheckInfo.bIsDelayStopCheckCountEnable = NO;
;;;490    		}
;;;491    		else
;;;492    		{
;;;493    			g_tDelayCheckInfo.usDelayStopCheckCount++;
;;;494    		}
;;;495    	}
;;;496    	else
;;;497    	{
;;;498    		g_tDelayCheckInfo.usDelayStopCheckCount = 0;
00000c  bf18              IT       NE
00000e  8074              STRHNE   r4,[r6,#2]
000010  d004              BEQ      |L8.28|
                  |L8.18|
;;;499    	}
;;;500    
;;;501    	if (g_bCallReadyStatus == TRUE)
000012  4d3c              LDR      r5,|L8.260|
000014  7968              LDRB     r0,[r5,#5]  ; g_bCallReadyStatus
000016  2801              CMP      r0,#1
000018  d124              BNE      |L8.100|
00001a  e007              B        |L8.44|
                  |L8.28|
00001c  8870              LDRH     r0,[r6,#2]            ;486  ; g_tDelayCheckInfo
00001e  2832              CMP      r0,#0x32              ;486
000020  bf87              ITTEE    HI                    ;488
000022  7034              STRBHI   r4,[r6,#0]            ;488
000024  7074              STRBHI   r4,[r6,#1]            ;489
000026  1c40              ADDLS    r0,r0,#1              ;489
000028  8070              STRHLS   r0,[r6,#2]            ;493
00002a  e7f2              B        |L8.18|
                  |L8.44|
00002c  2144              MOVS     r1,#0x44              ;486
00002e  4668              MOV      r0,sp                 ;486
000030  f7fffffe          BL       __aeabi_memclr4
000034  2042              MOVS     r0,#0x42              ;486
000036  f8ad0000          STRH     r0,[sp,#0]            ;486
00003a  2010              MOVS     r0,#0x10              ;486
00003c  f88d0002          STRB     r0,[sp,#2]            ;486
000040  204c              MOVS     r0,#0x4c              ;486
000042  f88d0040          STRB     r0,[sp,#0x40]         ;486
000046  2058              MOVS     r0,#0x58              ;486
000048  f88d403f          STRB     r4,[sp,#0x3f]         ;486
00004c  f88d0041          STRB     r0,[sp,#0x41]         ;486
000050  f89d0003          LDRB     r0,[sp,#3]            ;486
000054  466f              MOV      r7,sp                 ;486
000056  f0400003          ORR      r0,r0,#3              ;486
00005a  f88d0003          STRB     r0,[sp,#3]            ;486
00005e  7830              LDRB     r0,[r6,#0]            ;486  ; g_tDelayCheckInfo
000060  2800              CMP      r0,#0                 ;486
000062  d03e              BEQ      |L8.226|
                  |L8.100|
;;;502    	{
;;;503    		if (CallReadyStatus_ToHost() == TRUE)
;;;504    		{
;;;505    			g_bCallReadyStatus = FALSE;
;;;506    		}
;;;507    	}
;;;508    
;;;509    	do
;;;510    	{
;;;511    		if (g_CheckComplete_Common_I2C != DMA_READY)
000064  7928              LDRB     r0,[r5,#4]  ; g_CheckComplete_Common_I2C
000066  2801              CMP      r0,#1
;;;512    		{
;;;513    			break;
;;;514    		}
;;;515    
;;;516    		if (g_Ready != I2C_READY)
000068  bf07              ITTEE    EQ
00006a  7828              LDRBEQ   r0,[r5,#0]  ; g_Ready
00006c  2801              CMPEQ    r0,#1
;;;517    		{
;;;518    			break;
;;;519    		}
;;;520    
;;;521    		if (g_bReset != I2C_NORMAL)
;;;522    		{
;;;523    			break;
;;;524    		}
;;;525    
;;;526    		if (g_TxPtr != NULL)
;;;527    		{
;;;528    			break;
;;;529    		}
;;;530    
;;;531    		if (g_RxCommandIndex > 0)
;;;532    		{
;;;533    			break;
;;;534    		}
;;;535    
;;;536    		if (StaticQueue_CheckEmpty(&g_Queue_Common) != 0)
;;;537    		{
;;;538    			break;
;;;539    		}
;;;540    
;;;541    		// Pop
;;;542    		if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Common_I2C) == TRUE)
;;;543    		{
;;;544    			uint16_t* pLength = (uint16_t*)&g_Common_I2C;
;;;545    
;;;546    			// Tx Count
;;;547    			g_TxSendCount = pLength[0];
;;;548    
;;;549    			// Flag
;;;550    			g_CheckComplete_Common_I2C = DMA_NOT_READY;
;;;551    
;;;552    			// Pointer
;;;553    			g_TxPtr_Common = (uint8_t*)&g_Common_I2C;
;;;554    			g_TxIndex_Common = 0;
;;;555    
;;;556    			// Clear Tx
;;;557    			I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;558    
;;;559    			// 2 Byte - Length
;;;560    			I2C->I2C_TXFIFO_DATA = g_TxPtr_Common[g_TxIndex_Common];
;;;561    			g_TxIndex_Common += 1;
;;;562    
;;;563    			I2C->I2C_TXFIFO_DATA = g_TxPtr_Common[g_TxIndex_Common];
;;;564    			g_TxIndex_Common += 1;
;;;565    
;;;566    			g_TxByteInterruptCount = 0;
;;;567    
;;;568    			// GPIO Interrupt Enable
;;;569    			GPIO_TP_INTR_OUT_STATUS = GPIO_DATA_LOW;
;;;570    //			GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;571    		}
;;;572    
;;;573    	} while (FALSE);
;;;574    
;;;575    	return;
;;;576    }
00006e  b011              ADDNE    sp,sp,#0x44
000070  bdf0              POPNE    {r4-r7,pc}
000072  78a8              LDRB     r0,[r5,#2]            ;521  ; g_bReset
000074  2800              CMP      r0,#0                 ;521
000076  bf01              ITTTT    EQ                    ;526
000078  6968              LDREQ    r0,[r5,#0x14]         ;526  ; g_TxPtr
00007a  2800              CMPEQ    r0,#0                 ;526
00007c  6928              LDREQ    r0,[r5,#0x10]         ;531  ; g_RxCommandIndex
00007e  2800              CMPEQ    r0,#0                 ;531
000080  bf1c              ITT      NE
000082  b011              ADDNE    sp,sp,#0x44
000084  bdf0              POPNE    {r4-r7,pc}
000086  4820              LDR      r0,|L8.264|
000088  f7fffffe          BL       StaticQueue_CheckEmpty
00008c  2800              CMP      r0,#0                 ;536
00008e  bf1c              ITT      NE
000090  b011              ADDNE    sp,sp,#0x44
000092  bdf0              POPNE    {r4-r7,pc}
000094  491d              LDR      r1,|L8.268|
000096  481c              LDR      r0,|L8.264|
000098  f7fffffe          BL       StaticQueue_Pop
00009c  2801              CMP      r0,#1                 ;542
00009e  bf1c              ITT      NE
0000a0  b011              ADDNE    sp,sp,#0x44
0000a2  bdf0              POPNE    {r4-r7,pc}
0000a4  4819              LDR      r0,|L8.268|
0000a6  4919              LDR      r1,|L8.268|
0000a8  8800              LDRH     r0,[r0,#0]            ;547
0000aa  6268              STR      r0,[r5,#0x24]         ;550  ; g_TxSendCount
0000ac  712c              STRB     r4,[r5,#4]            ;550
0000ae  4818              LDR      r0,|L8.272|
0000b0  e9c51407          STRD     r1,r4,[r5,#0x1c]      ;557
0000b4  f8502f9c          LDR      r2,[r0,#0x9c]!        ;557
0000b8  f0420201          ORR      r2,r2,#1              ;557
0000bc  6002              STR      r2,[r0,#0]            ;557
0000be  780a              LDRB     r2,[r1,#0]            ;560
0000c0  6042              STR      r2,[r0,#4]            ;560
0000c2  2201              MOVS     r2,#1                 ;561
0000c4  622a              STR      r2,[r5,#0x20]         ;563  ; g_TxIndex_Common
0000c6  7849              LDRB     r1,[r1,#1]            ;563
0000c8  6041              STR      r1,[r0,#4]            ;563
0000ca  2002              MOVS     r0,#2                 ;564
0000cc  62ac              STR      r4,[r5,#0x28]         ;569  ; g_TxByteInterruptCount
0000ce  6228              STR      r0,[r5,#0x20]         ;569  ; g_TxIndex_Common
0000d0  0740              LSLS     r0,r0,#29             ;569
0000d2  f8d01104          LDR      r1,[r0,#0x104]        ;569
0000d6  f0210110          BIC      r1,r1,#0x10           ;569
0000da  f8c01104          STR      r1,[r0,#0x104]        ;569
0000de  b011              ADD      sp,sp,#0x44
0000e0  bdf0              POP      {r4-r7,pc}
                  |L8.226|
0000e2  4809              LDR      r0,|L8.264|
0000e4  f7fffffe          BL       StaticQueue_CheckFull
0000e8  2801              CMP      r0,#1
0000ea  bf04              ITT      EQ
0000ec  4806              LDREQ    r0,|L8.264|
0000ee  f7fffffe          BLEQ     StaticQueue_HeadDelete
0000f2  4639              MOV      r1,r7
0000f4  4804              LDR      r0,|L8.264|
0000f6  f7fffffe          BL       StaticQueue_Push
0000fa  716c              STRB     r4,[r5,#5]            ;505
0000fc  e7b2              B        |L8.100|
;;;577    #endif
                          ENDP

0000fe  0000              DCW      0x0000
                  |L8.256|
                          DCD      ||area_number.17||+0xa
                  |L8.260|
                          DCD      ||area_number.17||
                  |L8.264|
                          DCD      g_Queue_Common
                  |L8.268|
                          DCD      ||.bss||+0x4bf
                  |L8.272|
                          DCD      0x40007000

                          AREA ||i.RecieveCustomData_I2C||, CODE, READONLY, ALIGN=1

                  RecieveCustomData_I2C PROC
;;;370    
;;;371    void RecieveCustomData_I2C(PHJ_HID_CONTROL_STRUCT_I2C pData)
000000  7881              LDRB     r1,[r0,#2]
;;;372    {
;;;373    	switch (pData->Data.PacketID)
000002  2909              CMP      r1,#9
;;;374    	{
;;;375    		case HID_REPORT_ID__CUSTOM_OUT:
;;;376    		{
;;;377    			if (pData->Data.DeviceID_b.bRead)
;;;378    			{
;;;379    				HidReadWrite__Read_I2C(pData);
;;;380    			}
;;;381    			else
;;;382    			{
;;;383    				HidReadWrite__Write(&pData->Data);
;;;384    			}
;;;385    
;;;386    			break;
;;;387    		}
;;;388    	}
;;;389    
;;;390    	return;
;;;391    }
000004  bf18              IT       NE
000006  4770              BXNE     lr
000008  78c1              LDRB     r1,[r0,#3]            ;377
00000a  f0110f01          TST      r1,#1                 ;377
00000e  d001              BEQ      |L9.20|
000010  f7ffbffe          B.W      HidReadWrite__Read_I2C
                  |L9.20|
000014  1c80              ADDS     r0,r0,#2              ;379
000016  f7ffbffe          B.W      HidReadWrite__Write
;;;392    #endif /* MODE_I2C */
                          ENDP


                          AREA ||i.SendCustomData_I2C||, CODE, READONLY, ALIGN=2

                  SendCustomData_I2C PROC
;;;353    
;;;354    void SendCustomData_I2C(PHJ_HID_CONTROL_STRUCT_I2C pUserData)
000000  b510              PUSH     {r4,lr}
;;;355    {
000002  4604              MOV      r4,r0
;;;356    	if (StaticQueue_CheckInit(&g_Queue_Common) == 0)
000004  480b              LDR      r0,|L10.52|
000006  f7fffffe          BL       StaticQueue_CheckInit
00000a  2800              CMP      r0,#0
;;;357    	{
;;;358    		// Init Queue
;;;359    		StaticQueue_Init(&g_Queue_Common);
00000c  bf04              ITT      EQ
00000e  4809              LDREQ    r0,|L10.52|
000010  f7fffffe          BLEQ     StaticQueue_Init
;;;360    	}
;;;361    
;;;362    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
000014  4807              LDR      r0,|L10.52|
000016  f7fffffe          BL       StaticQueue_CheckFull
00001a  2801              CMP      r0,#1
;;;363    	{
;;;364    		StaticQueue_HeadDelete(&g_Queue_Common);
00001c  bf04              ITT      EQ
00001e  4805              LDREQ    r0,|L10.52|
000020  f7fffffe          BLEQ     StaticQueue_HeadDelete
;;;365    	}
;;;366    
;;;367    	pUserData->I2C_Length = sizeof(HJ_HID_CONTROL_STRUCT_I2C);
000024  2042              MOVS     r0,#0x42
000026  8020              STRH     r0,[r4,#0]
;;;368    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
000028  4621              MOV      r1,r4
00002a  e8bd4010          POP      {r4,lr}
00002e  4801              LDR      r0,|L10.52|
000030  f7ffbffe          B.W      StaticQueue_Push
;;;369    }
;;;370    
                          ENDP

                  |L10.52|
                          DCD      g_Queue_Common

                          AREA ||i.SendTouchData_I2C||, CODE, READONLY, ALIGN=2

                  SendTouchData_I2C PROC
;;;317    #ifdef ADD_TOUCH
;;;318    uint8_t SendTouchData_I2C(PHID_MULTITOUCH_I2C pUserData)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320    	uint8_t bPush = FALSE;
;;;321    
;;;322    	if(g_tDelayCheckInfo.bIsDelayStart == NO)
000002  4a0a              LDR      r2,|L11.44|
000004  4604              MOV      r4,r0                 ;319
000006  2000              MOVS     r0,#0                 ;320
000008  7812              LDRB     r2,[r2,#0]  ; g_tDelayCheckInfo
00000a  2a00              CMP      r2,#0                 ;319
;;;323    	{
;;;324    		if(StaticQueue_CheckFull(&g_Queue_Common) == 1)
;;;325    		{
;;;326    			StaticQueue_HeadDelete(&g_Queue_Common);
;;;327    		}
;;;328    
;;;329    		StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
;;;330    		bPush = TRUE;
;;;331    	}
;;;332    
;;;333    	return bPush;
;;;334    }
00000c  bf18              IT       NE
00000e  bd10              POPNE    {r4,pc}
000010  4807              LDR      r0,|L11.48|
000012  f7fffffe          BL       StaticQueue_CheckFull
000016  2801              CMP      r0,#1                 ;324
000018  bf04              ITT      EQ                    ;326
00001a  4805              LDREQ    r0,|L11.48|
00001c  f7fffffe          BLEQ     StaticQueue_HeadDelete
000020  4621              MOV      r1,r4                 ;329
000022  4803              LDR      r0,|L11.48|
000024  f7fffffe          BL       StaticQueue_Push
000028  2001              MOVS     r0,#1                 ;330
00002a  bd10              POP      {r4,pc}
;;;335    
                          ENDP

                  |L11.44|
                          DCD      ||area_number.17||+0xa
                  |L11.48|
                          DCD      g_Queue_Common

                          AREA ||i.swap_uint16||, CODE, READONLY, ALIGN=1

                  swap_uint16 PROC
;;;394    
;;;395    uint16_t swap_uint16(uint16_t val)
000000  0201              LSLS     r1,r0,#8
;;;396    {
;;;397    	return (val << 8) | (val >> 8);
000002  ea412010          ORR      r0,r1,r0,LSR #8
000006  b280              UXTH     r0,r0
;;;398    }
000008  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_FeatureData
                          %        61
                  g_RxCommand
                          %        100
                  g_I2CHidDescriptor
                          %        28
                  g_HID_ReportDesc_Temp
                          %        1026
                  g_Common_I2C
                          %        66
                  g_CustomBuffer_I2C
                          %        66

                          AREA ||.data||, DATA, ALIGN=2

                  g_I2C
                          DCD      0x40007080

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  g_Ready
000000  01                DCB      0x01
                  g_FeatureDataLength
000001  00                DCB      0x00
                  g_bReset
000002  00                DCB      0x00
                  g_nResetTxCount
000003  00                DCB      0x00
                  g_CheckComplete_Common_I2C
000004  01                DCB      0x01
                  g_bCallReadyStatus
000005  00                DCB      0x00
                  g_MaxTouchCount_I2C
000006  0000              DCB      0x00,0x00
                  g_TouchIdle_I2C
000008  0000              DCW      0x0000
                  g_tDelayCheckInfo
00000a  0000              DCB      0x00,0x00
00000c  0000              DCW      0x0000
00000e  0000              DCB      0x00,0x00
                  g_RxCommandIndex
                          DCD      0x00000000
                  g_TxPtr
                          DCD      0x00000000
                  g_TxIndex
                          DCD      0x00000000
                  g_TxPtr_Common
                          DCD      0x00000000
                  g_TxIndex_Common
                          DCD      0x00000000
                  g_TxSendCount
                          DCD      0x00000000
                  g_TxByteInterruptCount
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=0

                          EXPORTAS ||area_number.18||, ||.data||
                  g_DeviceMode_I2C
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.19||, DATA, ALIGN=0

                          EXPORTAS ||area_number.19||, ||.data||
                  g_LatencyMode_I2C
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\i2c\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___5_i2c_c_g_I2C____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____REVSH|
#line 402
|__asm___5_i2c_c_g_I2C____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____RRX|
#line 587
|__asm___5_i2c_c_g_I2C____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
