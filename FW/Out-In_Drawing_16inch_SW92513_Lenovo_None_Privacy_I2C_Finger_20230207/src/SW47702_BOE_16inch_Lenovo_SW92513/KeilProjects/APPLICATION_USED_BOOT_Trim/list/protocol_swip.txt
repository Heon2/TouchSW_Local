; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\protocol_swip.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\protocol_swip.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\protocol_swip.crf ..\..\Protocol\protocol_swip.c]
                          THUMB

                          AREA ||i.Hal_ClearIntr||, CODE, READONLY, ALIGN=2

                  Hal_ClearIntr PROC
;;;427    
;;;428    void Hal_ClearIntr(void) 
000000  4804              LDR      r0,|L1.20|
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7840              LDRB     r0,[r0,#1]
000006  2801              CMP      r0,#1
;;;429    {
;;;430      if(/*CheckI2CReady() ||*/ !protocol_swip_GetEventIntrType()) return;
;;;431    	
;;;432    	GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;433    }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  2101              MOVS     r1,#1                 ;432
00000e  2004              MOVS     r0,#4                 ;432
000010  f7ffbffe          B.W      GPIO_Set_DATA
;;;434    
                          ENDP

                  |L1.20|
                          DCD      tProtocolCtrl

                          AREA ||i.Hal_GetIntr||, CODE, READONLY, ALIGN=2

                  Hal_GetIntr PROC
;;;434    
;;;435    bool_t Hal_GetIntr(void)
000000  4808              LDR      r0,|L2.36|
;;;436    {
000002  b510              PUSH     {r4,lr}
000004  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000006  7840              LDRB     r0,[r0,#1]
000008  2801              CMP      r0,#1
00000a  d103              BNE      |L2.20|
;;;437     
;;;438     if(/*CheckI2CReady()||*/!protocol_swip_GetEventIntrType()) return 0;
;;;439    	
;;;440    	if(IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_LOW)
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       GPIO_Get_IN
000012  b108              CBZ      r0,|L2.24|
                  |L2.20|
000014  2000              MOVS     r0,#0                 ;438
;;;441    	{
;;;442    		GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;443    	}
;;;444    
;;;445    	return 0;
;;;446    }
000016  bd10              POP      {r4,pc}
                  |L2.24|
000018  2101              MOVS     r1,#1                 ;442
00001a  2004              MOVS     r0,#4                 ;442
00001c  f7fffffe          BL       GPIO_Set_DATA
000020  e7f8              B        |L2.20|
;;;447    void Hal_PendIntr(void)
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      tProtocolCtrl

                          AREA ||i.Hal_PendIntr||, CODE, READONLY, ALIGN=2

                  Hal_PendIntr PROC
;;;446    }
;;;447    void Hal_PendIntr(void)
000000  4804              LDR      r0,|L3.20|
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7840              LDRB     r0,[r0,#1]
000006  2801              CMP      r0,#1
;;;448    {
;;;449      
;;;450      if(/*CheckI2CReady() ||*/ !protocol_swip_GetEventIntrType()) return;
;;;451    	GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;452    }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  2100              MOVS     r1,#0                 ;451
00000e  2004              MOVS     r0,#4                 ;451
000010  f7ffbffe          B.W      GPIO_Set_DATA
;;;453    
                          ENDP

                  |L3.20|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_CheckEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_CheckEventInterrupt PROC
;;;480    
;;;481    bool_t protocol_swip_CheckEventInterrupt(void)
000000  480d              LDR      r0,|L4.56|
;;;482    {
000002  b510              PUSH     {r4,lr}
;;;483        thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
000004  6841              LDR      r1,[r0,#4]  ; tProtocolCtrl
000006  784a              LDRB     r2,[r1,#1]
000008  490c              LDR      r1,|L4.60|
00000a  6849              LDR      r1,[r1,#4]  ; thisInfo
00000c  700a              STRB     r2,[r1,#0]
;;;484        switch( thisInfo->eEventTriggerType )
00000e  b2d1              UXTB     r1,r2
000010  2901              CMP      r1,#1
000012  d002              BEQ      |L4.26|
000014  2902              CMP      r1,#2
000016  d006              BEQ      |L4.38|
000018  e00b              B        |L4.50|
                  |L4.26|
;;;485        {
;;;486        case ETT_INTERRUPT:
;;;487            if(IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_HIGH )	return YES;
00001a  2004              MOVS     r0,#4
00001c  f7fffffe          BL       GPIO_Get_IN
000020  2801              CMP      r0,#1
000022  d106              BNE      |L4.50|
;;;488    		else									return NO;
;;;489    //        break; // NOTE : warning제거
;;;490        case ETT_REGISTER:
;;;491            if(tProtocolCtrl.getter->bEventReady == NO) 	return YES;
;;;492    		else											return NO;
;;;493    //        break; // NOTE : warning제거
;;;494        default:
;;;495        	break;
;;;496        }
;;;497    
;;;498        return NO; // NOTE : warning제거
;;;499    }
000024  bd10              POP      {r4,pc}
                  |L4.38|
000026  6800              LDR      r0,[r0,#0]            ;491  ; tProtocolCtrl
000028  7840              LDRB     r0,[r0,#1]            ;491
00002a  2800              CMP      r0,#0                 ;491
00002c  bf04              ITT      EQ                    ;491
00002e  2001              MOVEQ    r0,#1                 ;491
000030  bd10              POPEQ    {r4,pc}
                  |L4.50|
000032  2000              MOVS     r0,#0                 ;498
000034  bd10              POP      {r4,pc}
;;;500    
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      tProtocolCtrl
                  |L4.60|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_ClearEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_ClearEventInterrupt PROC
;;;467    
;;;468    void protocol_swip_ClearEventInterrupt(void)
000000  480a              LDR      r0,|L5.44|
;;;469    {
;;;470        switch( thisInfo->eEventTriggerType )
000002  2100              MOVS     r1,#0
000004  6840              LDR      r0,[r0,#4]  ; thisInfo
000006  7802              LDRB     r2,[r0,#0]
000008  4809              LDR      r0,|L5.48|
00000a  2a01              CMP      r2,#1
00000c  d004              BEQ      |L5.24|
00000e  2a02              CMP      r2,#2
;;;471        {
;;;472        case ETT_INTERRUPT:
;;;473            Hal_ClearIntr();
;;;474            break;
;;;475        case ETT_REGISTER:
;;;476            tProtocolCtrl.getter->bEventReady = NO;
000010  bf04              ITT      EQ
000012  6800              LDREQ    r0,[r0,#0]  ; tProtocolCtrl
000014  7041              STRBEQ   r1,[r0,#1]
;;;477            break;
;;;478        }
;;;479    }
000016  4770              BX       lr
                  |L5.24|
000018  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
00001a  7840              LDRB     r0,[r0,#1]
00001c  2801              CMP      r0,#1
00001e  bf18              IT       NE
000020  4770              BXNE     lr
000022  2101              MOVS     r1,#1
000024  2004              MOVS     r0,#4
000026  f7ffbffe          B.W      GPIO_Set_DATA
;;;480    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      ||.data||
                  |L5.48|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_ClearInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_ClearInterrupt PROC
;;;633    
;;;634    void protocol_swip_ClearInterrupt(uint16_t _addr)
000000  b4f0              PUSH     {r4-r7}
;;;635    {
;;;636    	uint16_t SWIP_REG_ADDR;
;;;637    	
;;;638    	if(thisInfo->eEventTriggerType == ETT_REGISTER){
000002  4a23              LDR      r2,|L6.144|
000004  f8d2c004          LDR      r12,[r2,#4]  ; thisInfo
000008  f89c1000          LDRB     r1,[r12,#0]
00000c  2902              CMP      r1,#2
;;;639    		SWIP_REG_ADDR = SWIP_REG_ADDR_EVENT_PACKET_INFO;
00000e  bf0c              ITE      EQ
000010  f44f7304          MOVEQ    r3,#0x210
;;;640    	}
;;;641    	else{
;;;642    		SWIP_REG_ADDR = SWIP_REG_ADDR_EVENT_PACKET_CONTENT;
000014  f2402311          MOVNE    r3,#0x211
;;;643    	}
;;;644    
;;;645        if( _addr == SWIP_REG_ADDR_CTRL_GETTER + offsetof(tProtocolGetter_t, eReadyStatus) )
;;;646        {
;;;647            if( tProtocolCtrl.getter->eReadyStatus != RS_NONE )
000018  4c1e              LDR      r4,|L6.148|
00001a  f5b06fc0          CMP      r0,#0x600             ;645
00001e  6821              LDR      r1,[r4,#0]
000020  d024              BEQ      |L6.108|
000022  332f              ADDS     r3,r3,#0x2f           ;635
;;;648                tProtocolCtrl.getter->eReadyStatus = RS_NONE;
;;;649        }
;;;650        //Touch packet의 마지막 data를 읽어갈 때,
;;;651        else if( _addr == SWIP_REG_ADDR + TEST_DEVICE_READ_PACKED - 1 )
000024  4298              CMP      r0,r3
;;;652        {
;;;653    #if (SWIP_QUEUE_MODE)
;;;654    		if(sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear) // Not Queue Empty
;;;655    		{
;;;656    			sptAlgorithmInfo->QueueFront++;
;;;657    			sptAlgorithmInfo->QueueFront = (sptAlgorithmInfo->QueueFront) % SWIP_QUEUE_SIZE;
;;;658    		}
;;;659    #endif
;;;660            protocol_swip_ClearEventInterrupt();
;;;661        }
;;;662    }
000026  bf1c              ITT      NE
000028  bcf0              POPNE    {r4-r7}
00002a  4770              BXNE     lr
00002c  6890              LDR      r0,[r2,#8]            ;654  ; sptAlgorithmInfo
00002e  2500              MOVS     r5,#0                 ;654
000030  f5005080          ADD      r0,r0,#0x1000         ;654
000034  f8902159          LDRB     r2,[r0,#0x159]        ;654
000038  f8903158          LDRB     r3,[r0,#0x158]        ;654
00003c  429a              CMP      r2,r3                 ;654
00003e  d00c              BEQ      |L6.90|
000040  4f15              LDR      r7,|L6.152|
000042  1c52              ADDS     r2,r2,#1              ;654
000044  b2d2              UXTB     r2,r2                 ;656
000046  463e              MOV      r6,r7                 ;657
000048  2300              MOVS     r3,#0                 ;657
00004a  fbe26307          UMLAL    r6,r3,r2,r7           ;657
00004e  085b              LSRS     r3,r3,#1              ;657
000050  eba303c3          SUB      r3,r3,r3,LSL #3       ;657
000054  441a              ADD      r2,r2,r3              ;657
000056  f8802159          STRB     r2,[r0,#0x159]        ;657
                  |L6.90|
00005a  f89c0000          LDRB     r0,[r12,#0]           ;657
00005e  2801              CMP      r0,#1                 ;657
000060  d00b              BEQ      |L6.122|
000062  2802              CMP      r0,#2                 ;657
000064  bf08              IT       EQ                    ;657
000066  704d              STRBEQ   r5,[r1,#1]            ;657
000068  bcf0              POP      {r4-r7}
00006a  4770              BX       lr
                  |L6.108|
00006c  7808              LDRB     r0,[r1,#0]            ;647
00006e  2805              CMP      r0,#5                 ;647
000070  bf1c              ITT      NE                    ;648
000072  2005              MOVNE    r0,#5                 ;648
000074  7008              STRBNE   r0,[r1,#0]            ;648
000076  bcf0              POP      {r4-r7}
000078  4770              BX       lr
                  |L6.122|
00007a  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
00007c  7840              LDRB     r0,[r0,#1]
00007e  2801              CMP      r0,#1
000080  bf1c              ITT      NE
000082  bcf0              POPNE    {r4-r7}
000084  4770              BXNE     lr
000086  2101              MOVS     r1,#1
000088  bcf0              POP      {r4-r7}
00008a  2004              MOVS     r0,#4
00008c  f7ffbffe          B.W      GPIO_Set_DATA
;;;663    
                          ENDP

                  |L6.144|
                          DCD      ||.data||
                  |L6.148|
                          DCD      tProtocolCtrl
                  |L6.152|
                          DCD      0x49249249

                          AREA ||i.protocol_swip_GetABSAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetABSAvrCount PROC
;;;380    // Protocol for Test Mode
;;;381    uint8_t protocol_swip_GetABSAvrCount(void)
000000  4801              LDR      r0,|L7.8|
;;;382    {
;;;383    	return tSWIPTest.tTest.ptCtrl->ucABSAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7840              LDRB     r0,[r0,#1]
;;;384    }
000006  4770              BX       lr
;;;385    
                          ENDP

                  |L7.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetDCABSAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetDCABSAvrCount PROC
;;;385    
;;;386    uint8_t protocol_swip_GetDCABSAvrCount(void)
000000  4801              LDR      r0,|L8.8|
;;;387    {
;;;388    	return tSWIPTest.tTest.ptCtrl->ucDCABSAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7880              LDRB     r0,[r0,#2]
;;;389    }
000006  4770              BX       lr
;;;390    
                          ENDP

                  |L8.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetDFUP_Ready||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetDFUP_Ready PROC
;;;363    
;;;364    bool_t protocol_swip_GetDFUP_Ready(void)
000000  4801              LDR      r0,|L9.8|
;;;365    {
;;;366    	return tProtocolCtrl.setter->bDFUP_Ready;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7cc0              LDRB     r0,[r0,#0x13]
;;;367    }
000006  4770              BX       lr
;;;368    
                          ENDP

                  |L9.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetEnableBulkLog||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetEnableBulkLog PROC
;;;353    
;;;354    bool_t protocol_swip_GetEnableBulkLog(void)
000000  4801              LDR      r0,|L10.8|
;;;355    {
;;;356    	return tProtocolCtrl.setter->bEnableBulkLog;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7c80              LDRB     r0,[r0,#0x12]
;;;357    }
000006  4770              BX       lr
;;;358    
                          ENDP

                  |L10.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetEventIntrType||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetEventIntrType PROC
;;;338    
;;;339    bool_t protocol_swip_GetEventIntrType(void)
000000  4803              LDR      r0,|L11.16|
;;;340    {
;;;341       return (tProtocolCtrl.setter->eEventTriggerType == ETT_INTERRUPT) ? YES : NO;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7840              LDRB     r0,[r0,#1]
000006  2801              CMP      r0,#1
000008  bf18              IT       NE
00000a  2000              MOVNE    r0,#0
;;;342    }
00000c  4770              BX       lr
;;;343    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetJitterAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetJitterAvrCount PROC
;;;400    
;;;401    uint8_t protocol_swip_GetJitterAvrCount(void)
000000  4801              LDR      r0,|L12.8|
;;;402    {
;;;403    	return tSWIPTest.tTest.ptCtrl->ucJitterAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7940              LDRB     r0,[r0,#5]
;;;404    }
000006  4770              BX       lr
;;;405    
                          ENDP

                  |L12.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetJitterCheckCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetJitterCheckCount PROC
;;;405    
;;;406    uint8_t protocol_swip_GetJitterCheckCount(void)
000000  4801              LDR      r0,|L13.8|
;;;407    {
;;;408    	return tSWIPTest.tTest.ptCtrl->ucJitterCheckCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7980              LDRB     r0,[r0,#6]
;;;409    }
000006  4770              BX       lr
;;;410    
                          ENDP

                  |L13.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetLocalIdx||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetLocalIdx PROC
;;;348    
;;;349    bool_t protocol_swip_GetLocalIdx(void)
000000  4801              LDR      r0,|L14.8|
;;;350    {
;;;351       return tProtocolCtrl.setter->LocalIdx;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  78c0              LDRB     r0,[r0,#3]
;;;352    }
000006  4770              BX       lr
;;;353    
                          ENDP

                  |L14.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetLocalIdxFixedEn||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetLocalIdxFixedEn PROC
;;;343    
;;;344    bool_t protocol_swip_GetLocalIdxFixedEn(void)
000000  4801              LDR      r0,|L15.8|
;;;345    {
;;;346       return tProtocolCtrl.setter->LocalIdxFixedEn;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7880              LDRB     r0,[r0,#2]
;;;347    }
000006  4770              BX       lr
;;;348    
                          ENDP

                  |L15.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetMappedPointer||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetMappedPointer PROC
;;;588    
;;;589    uint8_t* protocol_swip_GetMappedPointer(uint16_t _addr)
000000  0a01              LSRS     r1,r0,#8
;;;590    {
;;;591        int i;
;;;592        uint8_t maddr = MSB(_addr), laddr = LSB(_addr);
000002  b2c2              UXTB     r2,r0
;;;593        //TODO: remove it! 임시로 기존 프로토콜 사용하기 위해서 작업해 두었습니다.
;;;594        if( _addr >= SWIP_REG_ADDR_RESERVED )
000004  f5b04f70          CMP      r0,#0xf000
000008  d22f              BCS      |L16.106|
;;;595        {
;;;596            return (uint8_t*)0;
;;;597        }
;;;598    
;;;599        if( maddr < GET_ARRAY_(vtMRmiMap) )
00000a  2915              CMP      r1,#0x15
00000c  d217              BCS      |L16.62|
;;;600        {
;;;601    		const tSWIPSubsetInfo_t* info = vtMRmiMap[maddr];
00000e  4818              LDR      r0,|L16.112|
000010  f8501021          LDR      r1,[r0,r1,LSL #2]
;;;602    		if(info != NULL)
000014  b349              CBZ      r1,|L16.106|
;;;603    		{
;;;604    			for( i=info->iSize; i--; )
000016  688b              LDR      r3,[r1,#8]
000018  1e58              SUBS     r0,r3,#1
;;;605    			{
;;;606    				int start_addr = info->vucStartLAddr[i];
00001a  bf28              IT       CS
00001c  f8d1c004          LDRCS    r12,[r1,#4]
000020  d323              BCC      |L16.106|
000022  bf00              NOP      
                  |L16.36|
000024  f81c3000          LDRB     r3,[r12,r0]
;;;607    				if( laddr >= start_addr )
000028  429a              CMP      r2,r3
00002a  db05              BLT      |L16.56|
;;;608    				{
;;;609    					return info->ppucData[i] + laddr - start_addr;
00002c  6809              LDR      r1,[r1,#0]
00002e  f8510020          LDR      r0,[r1,r0,LSL #2]
000032  4410              ADD      r0,r0,r2
000034  1ac0              SUBS     r0,r0,r3
;;;610    				}
;;;611    			}
;;;612    		}
;;;613    		else
;;;614    		{
;;;615    			info = NULL;
;;;616    		}
;;;617        }
;;;618        else //16K buffers.
;;;619        {
;;;620            for( i=tSWIPBufferInfo.iSize; i--; )
;;;621            {
;;;622                int start_addr = tSWIPBufferInfo.vusStartAddr[i];
;;;623    
;;;624                if( _addr >= start_addr)
;;;625                {
;;;626                    return tSWIPBufferInfo.ppucBuffer[i] + _addr - start_addr;
;;;627                }
;;;628            }
;;;629        }
;;;630    
;;;631        return (uint8_t*)NULL;
;;;632    }
000036  4770              BX       lr
                  |L16.56|
000038  1e40              SUBS     r0,r0,#1
00003a  d2f3              BCS      |L16.36|
00003c  e015              B        |L16.106|
                  |L16.62|
00003e  f8dfc034          LDR      r12,|L16.116|
000042  f8dc2008          LDR      r2,[r12,#8]           ;620  ; tSWIPBufferInfo
000046  1e51              SUBS     r1,r2,#1              ;620
000048  bf28              IT       CS                    ;622
00004a  f8dc3004          LDRCS    r3,[r12,#4]           ;622
00004e  d30c              BCC      |L16.106|
                  |L16.80|
000050  f8332011          LDRH     r2,[r3,r1,LSL #1]     ;622
000054  4290              CMP      r0,r2                 ;624
000056  db06              BLT      |L16.102|
000058  f8dc3000          LDR      r3,[r12,#0]           ;626  ; tSWIPBufferInfo
00005c  f8531021          LDR      r1,[r3,r1,LSL #2]     ;626
000060  4408              ADD      r0,r0,r1              ;626
000062  1a80              SUBS     r0,r0,r2              ;626
000064  4770              BX       lr
                  |L16.102|
000066  1e49              SUBS     r1,r1,#1
000068  d2f2              BCS      |L16.80|
                  |L16.106|
00006a  2000              MOVS     r0,#0                 ;631
00006c  4770              BX       lr
;;;633    
                          ENDP

00006e  0000              DCW      0x0000
                  |L16.112|
                          DCD      ||.data||+0x48
                  |L16.116|
                          DCD      ||.data||+0x3c

                          AREA ||i.protocol_swip_GetMode||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetMode PROC
;;;328    
;;;329    eProtocolMode_t protocol_swip_GetMode(void)
000000  4801              LDR      r0,|L17.8|
;;;330    {
;;;331        return tProtocolCtrl.setter->eMode;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7800              LDRB     r0,[r0,#0]
;;;332    }
000006  4770              BX       lr
;;;333    
                          ENDP

                  |L17.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetOpenAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetOpenAvrCount PROC
;;;390    
;;;391    uint8_t protocol_swip_GetOpenAvrCount(void)
000000  4801              LDR      r0,|L18.8|
;;;392    {
;;;393    	return tSWIPTest.tTest.ptCtrl->ucOpenAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  78c0              LDRB     r0,[r0,#3]
;;;394    }
000006  4770              BX       lr
;;;395    
                          ENDP

                  |L18.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetPacketFormatId||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetPacketFormatId PROC
;;;574    
;;;575    eSWIPPacketFormatId_t protocol_swip_GetPacketFormatId(void)
000000  4801              LDR      r0,|L19.8|
;;;576    {
;;;577        return thisCommonConf->ePacketFormatId;
000002  6800              LDR      r0,[r0,#0]  ; thisCommonConf
000004  8800              LDRH     r0,[r0,#0]
;;;578    }
000006  4770              BX       lr
;;;579    
                          ENDP

                  |L19.8|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_GetShortAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetShortAvrCount PROC
;;;395    
;;;396    uint8_t protocol_swip_GetShortAvrCount(void)
000000  4801              LDR      r0,|L20.8|
;;;397    {
;;;398    	return tSWIPTest.tTest.ptCtrl->ucShortAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7900              LDRB     r0,[r0,#4]
;;;399    }
000006  4770              BX       lr
;;;400    
                          ENDP

                  |L20.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetTestType||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetTestType PROC
;;;410    
;;;411    eSWIPTestType_t protocol_swip_GetTestType(void)
000000  4801              LDR      r0,|L21.8|
;;;412    {
;;;413        return tSWIPTest.tTest.ptCtrl->eTestType;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7800              LDRB     r0,[r0,#0]
;;;414    }
000006  4770              BX       lr
;;;415    
                          ENDP

                  |L21.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_Init||, CODE, READONLY, ALIGN=2

                  protocol_swip_Init PROC
;;;800    
;;;801    void protocol_swip_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;802    {
;;;803    	volatile unsigned long  BOOT_ADDR = 0x00001FFAUL;
000002  f64170fa          MOV      r0,#0x1ffa
;;;804    
;;;805    	thisCommonConf = protocol_GetCommonConfig();
000006  9000              STR      r0,[sp,#0]
000008  f7fffffe          BL       protocol_GetCommonConfig
00000c  4c27              LDR      r4,|L22.172|
;;;806    	thisInfo = protocol_GetInfo();
00000e  6020              STR      r0,[r4,#0]  ; thisCommonConf
000010  f7fffffe          BL       protocol_GetInfo
;;;807    	sptAlgorithmInfo = algorithm_GetInfo();
000014  6060              STR      r0,[r4,#4]  ; thisInfo
000016  f7fffffe          BL       algorithm_GetInfo
;;;808    
;;;809    	tSWIPInfo.ptPanel->usXResolution = I2C_X_RESOLUTION;//32768;
00001a  60a0              STR      r0,[r4,#8]  ; sptAlgorithmInfo
00001c  f1040014          ADD      r0,r4,#0x14
000020  f44f4100          MOV      r1,#0x8000
000024  6802              LDR      r2,[r0,#0]  ; tSWIPInfo
000026  8211              STRH     r1,[r2,#0x10]
;;;810    	tSWIPInfo.ptPanel->usYResolution = I2C_Y_RESOLUTION;//32768;
000028  6802              LDR      r2,[r0,#0]  ; tSWIPInfo
00002a  8251              STRH     r1,[r2,#0x12]
;;;811    
;;;812    	tSWIPInfo.ptPanel->ucXNode_ = COL_MAX;
00002c  6802              LDR      r2,[r0,#0]  ; tSWIPInfo
00002e  2154              MOVS     r1,#0x54
000030  7511              STRB     r1,[r2,#0x14]
;;;813    	tSWIPInfo.ptPanel->ucYNode_ = ROW_MAX;
000032  6802              LDR      r2,[r0,#0]  ; tSWIPInfo
000034  2130              MOVS     r1,#0x30
000036  7551              STRB     r1,[r2,#0x15]
;;;814    	tSWIPInfo.ptPanel->ucLocalYNode_ = PEN_COORD_ROW_MAX;
000038  6802              LDR      r2,[r0,#0]  ; tSWIPInfo
00003a  2105              MOVS     r1,#5
00003c  7591              STRB     r1,[r2,#0x16]
;;;815    #ifdef _USE_WITH_BOOT_
;;;816        tSWIPInfo.ptVersion->bcdBootVer = (*(uint16_t *)(0x2FF4));
00003e  f64271f4          MOV      r1,#0x2ff4
000042  6842              LDR      r2,[r0,#4]  ; tSWIPInfo
000044  8809              LDRH     r1,[r1,#0]
000046  8011              STRH     r1,[r2,#0]
;;;817    #else
;;;818        tSWIPInfo.ptVersion->bcdBootVer = BOOT_VERSION;
;;;819    #endif
;;;820        tSWIPInfo.ptVersion->bcdAppVer = APP_VERSION;
000048  6842              LDR      r2,[r0,#4]  ; tSWIPInfo
00004a  2106              MOVS     r1,#6
00004c  8051              STRH     r1,[r2,#2]
;;;821        tSWIPInfo.ptVersion->bcdParamVer = CONFIG_VERSION;
00004e  6843              LDR      r3,[r0,#4]  ; tSWIPInfo
000050  2201              MOVS     r2,#1
000052  809a              STRH     r2,[r3,#4]
;;;822    
;;;823    #ifdef _USE_WITH_BOOT_
;;;824        tSWIPInfo.ptSectionAddress->usAppMemSize = (*(uint16_t *)(0x1FFF4));
000054  4a16              LDR      r2,|L22.176|
000056  6883              LDR      r3,[r0,#8]  ; tSWIPInfo
000058  8812              LDRH     r2,[r2,#0]
00005a  80da              STRH     r2,[r3,#6]
;;;825        tSWIPInfo.ptSectionAddress->usConfigMemSize = (*(uint16_t *)(0x1FFF6));
00005c  4a15              LDR      r2,|L22.180|
00005e  6883              LDR      r3,[r0,#8]  ; tSWIPInfo
000060  8812              LDRH     r2,[r2,#0]
000062  811a              STRH     r2,[r3,#8]
;;;826    #else
;;;827        tSWIPInfo.ptSectionAddress->usAppMemSize = APP_MEM_SIZE;
;;;828        tSWIPInfo.ptSectionAddress->usConfigMemSize = CONFIG_MEM_SIZE;
;;;829    #endif
;;;830    
;;;831    #ifdef _USE_WITH_BOOT_
;;;832    	tSWIPInfo.ptIntegrity->ulBootCRC = (*(volatile unsigned short *)(0x2FFC));
000064  f64272fc          MOV      r2,#0x2ffc
000068  8812              LDRH     r2,[r2,#0]
00006a  68c3              LDR      r3,[r0,#0xc]  ; tSWIPInfo
00006c  601a              STR      r2,[r3,#0]
;;;833    	tSWIPInfo.ptIntegrity->ulAppCRC = (*(volatile unsigned short *)(0x1FFFC));
00006e  4a12              LDR      r2,|L22.184|
000070  8812              LDRH     r2,[r2,#0]
000072  68c3              LDR      r3,[r0,#0xc]  ; tSWIPInfo
;;;834    #else
;;;835    	tSWIPInfo.ptIntegrity->ulBootCRC = 0xFFFF;//SYSCFG_SPI_BOOT_crc_code_read();
;;;836    	tSWIPInfo.ptIntegrity->ulAppCRC = 0xFFFF;//SYSCFG_SPI_APP_crc_code_read();
;;;837    #endif /* _USE_WITH_BOOT_ */
;;;838    
;;;839    #if (USED_MODULE_DEF == MODULE_DEF_S_1)
;;;840    	protocol_swip_UpdatePTInspectionGetInfo();
;;;841    #endif /* (USED_MODULE_DEF == MODULE_DEF_S_1) */
;;;842    
;;;843    	tSWIPInfo.ptIntegrity->ulParamCRC = 0x00000000;
;;;844    	tSWIPInfo.ptExtra->usPWMTxFrequecy = PWMDRV_USED_FREQUENCY;
;;;845    
;;;846    	tSWIPEvent.ptEventFormat->ePacketFormatId = thisCommonConf->ePacketFormatId;
;;;847    
;;;848    	int iItemSize = 0x06;
;;;849    	int iTouchEventPacketSize  = 0x0042;
000074  2542              MOVS     r5,#0x42
000076  605a              STR      r2,[r3,#4]            ;833
000078  68c3              LDR      r3,[r0,#0xc]          ;843  ; tSWIPInfo
00007a  2200              MOVS     r2,#0                 ;843
00007c  609a              STR      r2,[r3,#8]            ;843
00007e  6940              LDR      r0,[r0,#0x14]         ;844  ; tSWIPInfo
000080  225b              MOVS     r2,#0x5b              ;844
000082  8002              STRH     r2,[r0,#0]            ;844
000084  6820              LDR      r0,[r4,#0]            ;846  ; thisCommonConf
000086  340c              ADDS     r4,r4,#0xc            ;846
000088  6822              LDR      r2,[r4,#0]            ;846  ; tSWIPEvent
00008a  8800              LDRH     r0,[r0,#0]            ;846
00008c  8090              STRH     r0,[r2,#4]            ;846
;;;850    
;;;851    	tSWIPEvent.ptEventFormat->ucTouchPacketItemSize = iItemSize;
00008e  6820              LDR      r0,[r4,#0]  ; tSWIPEvent
000090  7181              STRB     r1,[r0,#6]
;;;852    	tSWIPEvent.ptPacketInfo = malloc(iTouchEventPacketSize);
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       malloc
;;;853    	memset(tSWIPEvent.ptPacketInfo, 0, iTouchEventPacketSize);
000098  4629              MOV      r1,r5
00009a  6060              STR      r0,[r4,#4]  ; tSWIPEvent
00009c  f7fffffe          BL       __aeabi_memclr
;;;854    
;;;855    	vtProtocolBufferPointers.pParameterBuffer = (void *)PARAM_GetPreMainSet();
0000a0  f7fffffe          BL       PARAM_GetPreMainSet
0000a4  4905              LDR      r1,|L22.188|
0000a6  6048              STR      r0,[r1,#4]  ; vtProtocolBufferPointers
;;;856    }
0000a8  bd38              POP      {r3-r5,pc}
;;;857    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L22.172|
                          DCD      ||.data||
                  |L22.176|
                          DCD      0x0001fff4
                  |L22.180|
                          DCD      0x0001fff6
                  |L22.184|
                          DCD      0x0001fffc
                  |L22.188|
                          DCD      vtProtocolBufferPointers

                          AREA ||i.protocol_swip_InitTouchEventBuffer||, CODE, READONLY, ALIGN=2

                  protocol_swip_InitTouchEventBuffer PROC
;;;579    
;;;580    void protocol_swip_InitTouchEventBuffer(void)
000000  4903              LDR      r1,|L23.16|
;;;581    {
;;;582    	thisInfo->iEventPacket_ = 0;
000002  2000              MOVS     r0,#0
000004  6849              LDR      r1,[r1,#4]  ; thisInfo
000006  f8c10001          STR      r0,[r1,#1]
;;;583    #ifdef MODE_I2C
;;;584    	protocol_swip_WaitEventInterruptCleared();	
00000a  f7ffbffe          B.W      protocol_swip_WaitEventInterruptCleared
;;;585    #endif
;;;586    }
;;;587    
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_PendEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendEventInterrupt PROC
;;;453    
;;;454    void protocol_swip_PendEventInterrupt(void)
000000  480b              LDR      r0,|L24.48|
;;;455    {
;;;456        thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
000002  6841              LDR      r1,[r0,#4]  ; tProtocolCtrl
000004  784a              LDRB     r2,[r1,#1]
000006  490b              LDR      r1,|L24.52|
000008  6849              LDR      r1,[r1,#4]  ; thisInfo
00000a  700a              STRB     r2,[r1,#0]
00000c  2101              MOVS     r1,#1
;;;457        switch( thisInfo->eEventTriggerType )
00000e  2a01              CMP      r2,#1
000010  d004              BEQ      |L24.28|
000012  2a02              CMP      r2,#2
;;;458        {
;;;459        case ETT_INTERRUPT:
;;;460            Hal_PendIntr();
;;;461            break;
;;;462        case ETT_REGISTER:
;;;463            tProtocolCtrl.getter->bEventReady = YES;
000014  bf04              ITT      EQ
000016  6800              LDREQ    r0,[r0,#0]  ; tProtocolCtrl
000018  7041              STRBEQ   r1,[r0,#1]
;;;464            break;
;;;465        }
;;;466    }
00001a  4770              BX       lr
                  |L24.28|
00001c  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
00001e  7840              LDRB     r0,[r0,#1]
000020  2801              CMP      r0,#1
000022  bf18              IT       NE
000024  4770              BXNE     lr
000026  2100              MOVS     r1,#0
000028  2004              MOVS     r0,#4
00002a  f7ffbffe          B.W      GPIO_Set_DATA
;;;467    
                          ENDP

00002e  0000              DCW      0x0000
                  |L24.48|
                          DCD      tProtocolCtrl
                  |L24.52|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_PendReadyStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendReadyStatus PROC
;;;373    
;;;374    void protocol_swip_PendReadyStatus(void)
000000  4804              LDR      r0,|L25.20|
;;;375    {
;;;376        tProtocolCtrl.getter->eReadyStatus = RS_READY;
000002  21a0              MOVS     r1,#0xa0
000004  6802              LDR      r2,[r0,#0]  ; tProtocolCtrl
000006  7011              STRB     r1,[r2,#0]
000008  6800              LDR      r0,[r0,#0]
                  |L25.10|
;;;377        while( tProtocolCtrl.getter->eReadyStatus == RS_READY );
00000a  7801              LDRB     r1,[r0,#0]
00000c  29a0              CMP      r1,#0xa0
00000e  d0fc              BEQ      |L25.10|
;;;378    }
000010  4770              BX       lr
;;;379    
                          ENDP

000012  0000              DCW      0x0000
                  |L25.20|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PendTestResult||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendTestResult PROC
;;;553    
;;;554    void protocol_swip_PendTestResult(const tSWIPTestDataFmt_t* _ptDataFormat, const void* _pBuf)
000000  4a0c              LDR      r2,|L26.52|
;;;555    {
;;;556        tSWIPTest.tTest.ptCtrl->eTestType = CTT_NONE;
000002  23ff              MOVS     r3,#0xff
000004  f8d2c004          LDR      r12,[r2,#4]  ; tSWIPTest
000008  f88c3000          STRB     r3,[r12,#0]
;;;557        //Set data format.
;;;558        tSWIPTest.tTest.ptFormat = _ptDataFormat;
;;;559    
;;;560        //Set buffer address.
;;;561        vtProtocolBufferPointers.pGeneralBuffer = (void*)_pBuf;
00000c  6090              STR      r0,[r2,#8]  ; tSWIPTest
00000e  480a              LDR      r0,|L26.56|
000010  6001              STR      r1,[r0,#0]  ; vtProtocolBufferPointers
;;;562    
;;;563    #ifdef MODE_I2C
;;;564    	// 2021.12.06
;;;565    	g_bCallReadyStatus = TRUE;
000012  490a              LDR      r1,|L26.60|
000014  2001              MOVS     r0,#1
000016  7008              STRB     r0,[r1,#0]
;;;566    #endif
;;;567    
;;;568        //Pend wait flag and wait for image type setting.
;;;569        tProtocolCtrl.getter->eReadyStatus = RS_READY;
000018  4909              LDR      r1,|L26.64|
00001a  20a0              MOVS     r0,#0xa0
00001c  680b              LDR      r3,[r1,#0]  ; tProtocolCtrl
00001e  7018              STRB     r0,[r3,#0]
;;;570        while( tSWIPTest.tTest.ptCtrl->eTestType == CTT_NONE
;;;571                && tProtocolCtrl.setter->eMode == M_TOUCH_DIAG )
000020  6850              LDR      r0,[r2,#4]
000022  684a              LDR      r2,[r1,#4]
                  |L26.36|
000024  7801              LDRB     r1,[r0,#0]            ;570
000026  29ff              CMP      r1,#0xff              ;570
000028  bf04              ITT      EQ
00002a  7811              LDRBEQ   r1,[r2,#0]
00002c  2901              CMPEQ    r1,#1
00002e  d0f9              BEQ      |L26.36|
;;;572            ;
;;;573    }
000030  4770              BX       lr
;;;574    
                          ENDP

000032  0000              DCW      0x0000
                  |L26.52|
                          DCD      ||.data||+0x30
                  |L26.56|
                          DCD      vtProtocolBufferPointers
                  |L26.60|
                          DCD      g_bCallReadyStatus
                  |L26.64|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PushTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_PushTouchEvent PROC
;;;668    #endif
;;;669    void protocol_swip_PushTouchEvent(const uSWIPTouchItem_t* _kptItem)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;670    {
;;;671    	int index = 0;
;;;672    
;;;673    #if (SWIP_QUEUE_MODE)
;;;674    	if(sptAlgorithmInfo->bQueueStart == 0)
000004  4d7c              LDR      r5,|L27.504|
000006  4607              MOV      r7,r0                 ;670
000008  2400              MOVS     r4,#0                 ;671
00000a  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
;;;675    	{
;;;676    		sptAlgorithmInfo->bQueueStart = 1;
;;;677    		if((sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE == sptAlgorithmInfo->QueueFront ) // Queue Full Check
;;;678    		{	
;;;679    			uint8_t CurrFrontIdx, NextFrontIdx;
;;;680    
;;;681    			if( protocol_swip_CheckEventInterrupt() == YES )
;;;682    			{
;;;683    				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE;
;;;684    			}
;;;685    			else
;;;686    			{
;;;687    				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 2) % SWIP_QUEUE_SIZE;
;;;688    			}
;;;689    			NextFrontIdx = (CurrFrontIdx + 1) % SWIP_QUEUE_SIZE;
;;;690    
;;;691    			for(index=0; index<MAX_TOUCH_; index++)				
;;;692    			{
;;;693    				if( ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status == 0 && ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID > 0)
00000c  4e7b              LDR      r6,|L27.508|
00000e  f5005080          ADD      r0,r0,#0x1000         ;674
000012  f890115a          LDRB     r1,[r0,#0x15a]        ;674
000016  2900              CMP      r1,#0                 ;674
000018  d17e              BNE      |L27.280|
00001a  2101              MOVS     r1,#1                 ;676
00001c  f880115a          STRB     r1,[r0,#0x15a]        ;676
000020  f8901158          LDRB     r1,[r0,#0x158]        ;677
000024  f8df81d8          LDR      r8,|L27.512|
000028  2200              MOVS     r2,#0                 ;677
00002a  4643              MOV      r3,r8                 ;677
00002c  1c49              ADDS     r1,r1,#1              ;677
00002e  fbe13208          UMLAL    r3,r2,r1,r8           ;677
000032  0852              LSRS     r2,r2,#1              ;677
000034  eba202c2          SUB      r2,r2,r2,LSL #3       ;677
000038  f8900159          LDRB     r0,[r0,#0x159]        ;677
00003c  4411              ADD      r1,r1,r2              ;677
00003e  4281              CMP      r1,r0                 ;677
000040  d17c              BNE      |L27.316|
000042  4870              LDR      r0,|L27.516|
000044  6841              LDR      r1,[r0,#4]            ;677  ; tProtocolCtrl
000046  784a              LDRB     r2,[r1,#1]            ;677
000048  6869              LDR      r1,[r5,#4]            ;677  ; thisInfo
00004a  700a              STRB     r2,[r1,#0]            ;677
00004c  b2d1              UXTB     r1,r2                 ;677
00004e  2901              CMP      r1,#1                 ;677
000050  d002              BEQ      |L27.88|
000052  2902              CMP      r1,#2                 ;677
000054  d006              BEQ      |L27.100|
000056  e008              B        |L27.106|
                  |L27.88|
000058  2004              MOVS     r0,#4                 ;677
00005a  f7fffffe          BL       GPIO_Get_IN
00005e  2801              CMP      r0,#1                 ;677
000060  d103              BNE      |L27.106|
000062  e02d              B        |L27.192|
                  |L27.100|
000064  6800              LDR      r0,[r0,#0]            ;677  ; tProtocolCtrl
000066  7840              LDRB     r0,[r0,#1]            ;677
000068  b350              CBZ      r0,|L27.192|
                  |L27.106|
00006a  68a8              LDR      r0,[r5,#8]            ;687  ; sptAlgorithmInfo
00006c  4a64              LDR      r2,|L27.512|
00006e  f5005080          ADD      r0,r0,#0x1000         ;687
000072  2100              MOVS     r1,#0                 ;687
000074  f8900158          LDRB     r0,[r0,#0x158]        ;687
000078  1c80              ADDS     r0,r0,#2              ;687
00007a  fbe02108          UMLAL    r2,r1,r0,r8           ;687
00007e  0849              LSRS     r1,r1,#1              ;687
000080  eba101c1          SUB      r1,r1,r1,LSL #3       ;687
000084  4408              ADD      r0,r0,r1              ;687
000086  b2c0              UXTB     r0,r0                 ;687
                  |L27.136|
000088  1c41              ADDS     r1,r0,#1              ;689
00008a  4b5d              LDR      r3,|L27.512|
00008c  2200              MOVS     r2,#0                 ;689
00008e  fbe13208          UMLAL    r3,r2,r1,r8           ;689
000092  0852              LSRS     r2,r2,#1              ;689
000094  eba202c2          SUB      r2,r2,r2,LSL #3       ;689
000098  4411              ADD      r1,r1,r2              ;689
00009a  b2c9              UXTB     r1,r1                 ;689
;;;694    				{
;;;695    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].Status = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status; 
00009c  eb011141          ADD      r1,r1,r1,LSL #5
0000a0  eb001040          ADD      r0,r0,r0,LSL #5       ;693
0000a4  eb060241          ADD      r2,r6,r1,LSL #1
0000a8  eb060340          ADD      r3,r6,r0,LSL #1       ;693
                  |L27.172|
0000ac  eb040044          ADD      r0,r4,r4,LSL #1       ;693
0000b0  eb030140          ADD      r1,r3,r0,LSL #1       ;693
0000b4  f891c003          LDRB     r12,[r1,#3]           ;693
0000b8  f1bc0f00          CMP      r12,#0                ;693
0000bc  d127              BNE      |L27.270|
0000be  e00f              B        |L27.224|
                  |L27.192|
0000c0  68a8              LDR      r0,[r5,#8]            ;683  ; sptAlgorithmInfo
0000c2  4a4f              LDR      r2,|L27.512|
0000c4  f5005080          ADD      r0,r0,#0x1000         ;683
0000c8  2100              MOVS     r1,#0                 ;683
0000ca  f8900158          LDRB     r0,[r0,#0x158]        ;683
0000ce  1c40              ADDS     r0,r0,#1              ;683
0000d0  fbe02108          UMLAL    r2,r1,r0,r8           ;683
0000d4  0849              LSRS     r1,r1,#1              ;683
0000d6  eba101c1          SUB      r1,r1,r1,LSL #3       ;683
0000da  4408              ADD      r0,r0,r1              ;683
0000dc  b2c0              UXTB     r0,r0                 ;683
0000de  e7d3              B        |L27.136|
                  |L27.224|
0000e0  f891c004          LDRB     r12,[r1,#4]           ;693
0000e4  f1bc0f00          CMP      r12,#0                ;693
0000e8  d011              BEQ      |L27.270|
0000ea  f891c003          LDRB     r12,[r1,#3]
0000ee  eb020040          ADD      r0,r2,r0,LSL #1
0000f2  f880c003          STRB     r12,[r0,#3]
;;;696    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ID 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID; 	 
0000f6  f891c004          LDRB     r12,[r1,#4]
0000fa  f880c004          STRB     r12,[r0,#4]
;;;697    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucX 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucX; 	 
0000fe  f8b1c005          LDRH     r12,[r1,#5]
000102  f8a0c005          STRH     r12,[r0,#5]
;;;698    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucY 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucY;	 
000106  f8b11007          LDRH     r1,[r1,#7]
00010a  f8a01007          STRH     r1,[r0,#7]
                  |L27.270|
00010e  1c64              ADDS     r4,r4,#1
000110  2c0a              CMP      r4,#0xa               ;691
000112  dbcb              BLT      |L27.172|
;;;699    				}
;;;700    			}
;;;701    
;;;702    			sptAlgorithmInfo->QueueFront++;
000114  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
000116  e001              B        |L27.284|
                  |L27.280|
000118  e01c              B        |L27.340|
00011a  e00f              B        |L27.316|
                  |L27.284|
00011c  f5005180          ADD      r1,r0,#0x1000
000120  4b37              LDR      r3,|L27.512|
000122  f8910159          LDRB     r0,[r1,#0x159]
000126  2200              MOVS     r2,#0
000128  1c40              ADDS     r0,r0,#1
00012a  b2c0              UXTB     r0,r0
;;;703    			sptAlgorithmInfo->QueueFront = (sptAlgorithmInfo->QueueFront) % SWIP_QUEUE_SIZE;
00012c  fbe03208          UMLAL    r3,r2,r0,r8
000130  0852              LSRS     r2,r2,#1
000132  eba202c2          SUB      r2,r2,r2,LSL #3
000136  4410              ADD      r0,r0,r2
000138  f8810159          STRB     r0,[r1,#0x159]
                  |L27.316|
;;;704    		}
;;;705    		memset((void *)&ptPacketInfoQueue[sptAlgorithmInfo->QueueRear], 0x00, sizeof(tSWIPPacketInfo_t));
00013c  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
00013e  2142              MOVS     r1,#0x42
000140  f5005080          ADD      r0,r0,#0x1000
000144  f8900158          LDRB     r0,[r0,#0x158]
000148  eb001040          ADD      r0,r0,r0,LSL #5
00014c  eb060040          ADD      r0,r6,r0,LSL #1
000150  f7fffffe          BL       __aeabi_memclr
                  |L27.340|
;;;706    	}
;;;707    #endif
;;;708    
;;;709    	index = (_kptItem->tItem00.tInfo.b4FingerID-1);
000154  7838              LDRB     r0,[r7,#0]
000156  f000010f          AND      r1,r0,#0xf
;;;710    
;;;711    #if (SWIP_QUEUE_MODE)
;;;712    #if USED_SHARP_SPECIFIC_PROTOCOL
;;;713    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].Status = ((_kptItem->tItem00.tInfo.b6Type << 1) | (_kptItem->tItem00.tInfo.b1Status & 0x01)) & 0xff;
;;;714    #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;715    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].Status = _kptItem->tItem00.tInfo.bTouch;
00015a  09c3              LSRS     r3,r0,#7
00015c  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
00015e  1e49              SUBS     r1,r1,#1
000160  f5005080          ADD      r0,r0,#0x1000
000164  f8902158          LDRB     r2,[r0,#0x158]
000168  eb021242          ADD      r2,r2,r2,LSL #5
00016c  eb060c42          ADD      r12,r6,r2,LSL #1
000170  eb010241          ADD      r2,r1,r1,LSL #1
000174  eb0c0c42          ADD      r12,r12,r2,LSL #1
000178  f88c3003          STRB     r3,[r12,#3]
;;;716    #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;717    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ID 	= _kptItem->tItem00.tInfo.b4FingerID;
00017c  f890c158          LDRB     r12,[r0,#0x158]
000180  783b              LDRB     r3,[r7,#0]
000182  eb0c1c4c          ADD      r12,r12,r12,LSL #5
000186  eb060c4c          ADD      r12,r6,r12,LSL #1
00018a  eb0c0c42          ADD      r12,r12,r2,LSL #1
00018e  f003030f          AND      r3,r3,#0xf
000192  f88c3004          STRB     r3,[r12,#4]
;;;718    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucX 	= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
000196  78fb              LDRB     r3,[r7,#3]
000198  f897c001          LDRB     r12,[r7,#1]
00019c  ea43230c          ORR      r3,r3,r12,LSL #8
0001a0  f890c158          LDRB     r12,[r0,#0x158]
0001a4  eb0c1c4c          ADD      r12,r12,r12,LSL #5
0001a8  eb060c4c          ADD      r12,r6,r12,LSL #1
0001ac  eb0c0c42          ADD      r12,r12,r2,LSL #1
0001b0  f8ac3005          STRH     r3,[r12,#5]
;;;719    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucY 	= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
0001b4  793b              LDRB     r3,[r7,#4]
0001b6  f897c002          LDRB     r12,[r7,#2]
0001ba  ea43230c          ORR      r3,r3,r12,LSL #8
0001be  f890c158          LDRB     r12,[r0,#0x158]
0001c2  eb0c1c4c          ADD      r12,r12,r12,LSL #5
0001c6  eb060c4c          ADD      r12,r6,r12,LSL #1
0001ca  eb0c0242          ADD      r2,r12,r2,LSL #1
0001ce  f8a23007          STRH     r3,[r2,#7]
;;;720    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].RowStart 				= _kptItem->tItem00.ucRowStart;
0001d2  f8903158          LDRB     r3,[r0,#0x158]
0001d6  7a3a              LDRB     r2,[r7,#8]
0001d8  eb031343          ADD      r3,r3,r3,LSL #5
0001dc  eb060343          ADD      r3,r6,r3,LSL #1
0001e0  f8a32040          STRH     r2,[r3,#0x40]
;;;721    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].ucContactCnt 			= index;
0001e4  f8900158          LDRB     r0,[r0,#0x158]
0001e8  eb001040          ADD      r0,r0,r0,LSL #5
0001ec  eb060040          ADD      r0,r6,r0,LSL #1
0001f0  f880103f          STRB     r1,[r0,#0x3f]
;;;722    #else
;;;723    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= _kptItem->tItem00.tInfo.bTouch;
;;;724    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= _kptItem->tItem00.tInfo.b4FingerID;
;;;725    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
;;;726    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
;;;727    	tSWIPEvent.ptPacketInfo->RowStart 					= _kptItem->tItem00.ucRowStart;
;;;728    	tSWIPEvent.ptPacketInfo->ucContactCnt 				= index;
;;;729    	thisInfo->iEventPacket_ += ((int)tSWIPEvent.ptEventFormat->ucTouchPacketItemSize);
;;;730    #endif
;;;731    }
0001f4  e8bd81f0          POP      {r4-r8,pc}
;;;732    
                          ENDP

                  |L27.504|
                          DCD      ||.data||
                  |L27.508|
                          DCD      ||area_number.39||
                  |L27.512|
                          DCD      0x49249249
                  |L27.516|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SendPenEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_SendPenEvent PROC
;;;766    
;;;767    void protocol_swip_SendPenEvent(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;768    {
;;;769    	int index;
;;;770    
;;;771    #if (SWIP_QUEUE_MODE)
;;;772    	if( sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
000004  4c5b              LDR      r4,|L28.372|
000006  68a0              LDR      r0,[r4,#8]  ; sptAlgorithmInfo
000008  f5005080          ADD      r0,r0,#0x1000
00000c  f8901159          LDRB     r1,[r0,#0x159]
000010  f8900158          LDRB     r0,[r0,#0x158]
000014  4281              CMP      r1,r0
;;;773    	{
;;;774    		for(index=0; index<MAX_TOUCH_; index++)
;;;775    		{
;;;776    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;777    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;778    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;779    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;780    			tSWIPEvent.ptPacketInfo->RowStart 					= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;781    			tSWIPEvent.ptPacketInfo->ucContactCnt 				= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;782    		}
;;;783    		tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;784    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;785    		protocol_swip_PendEventInterrupt();
;;;786    	}
;;;787    #else			
;;;788    	if( thisInfo->iEventPacket_ )
;;;789    		{
;;;790    		tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;791    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;792    		protocol_swip_PendEventInterrupt();
;;;793    	}
;;;794    	else
;;;795    	{
;;;796    		tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;797    	}
;;;798    #endif
;;;799    }
000016  bf08              IT       EQ
000018  e8bd9ff0          POPEQ    {r4-r12,pc}
00001c  f8dfb158          LDR      r11,|L28.376|
000020  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
000024  7841              LDRB     r1,[r0,#1]
000026  6860              LDR      r0,[r4,#4]  ; thisInfo
000028  7001              STRB     r1,[r0,#0]
00002a  b2c8              UXTB     r0,r1
00002c  2801              CMP      r0,#1
00002e  d07d              BEQ      |L28.300|
000030  2802              CMP      r0,#2
000032  bf18              IT       NE
000034  e8bd9ff0          POPNE    {r4-r12,pc}
000038  f8db0000          LDR      r0,[r11,#0]  ; tProtocolCtrl
00003c  7840              LDRB     r0,[r0,#1]
00003e  2800              CMP      r0,#0
000040  bf18              IT       NE
000042  e8bd9ff0          POPNE    {r4-r12,pc}
000046  bf00              NOP                            ;774
                  |L28.72|
000048  68a1              LDR      r1,[r4,#8]            ;776  ; sptAlgorithmInfo
00004a  2504              MOVS     r5,#4                 ;776
00004c  4a4b              LDR      r2,|L28.380|
00004e  484c              LDR      r0,|L28.384|
000050  2603              MOVS     r6,#3                 ;776
000052  f04f0c00          MOV      r12,#0                ;774
000056  46a6              MOV      lr,r4                 ;776
000058  2705              MOVS     r7,#5                 ;778
00005a  f04f0807          MOV      r8,#7                 ;779
00005e  f5015380          ADD      r3,r1,#0x1000         ;776
000062  bf00              NOP                            ;776
                  |L28.100|
000064  f8931159          LDRB     r1,[r3,#0x159]        ;776
000068  eb011141          ADD      r1,r1,r1,LSL #5       ;776
00006c  eb020441          ADD      r4,r2,r1,LSL #1       ;776
000070  eb0c014c          ADD      r1,r12,r12,LSL #1     ;776
000074  eb040441          ADD      r4,r4,r1,LSL #1       ;776
000078  78e4              LDRB     r4,[r4,#3]            ;776
00007a  f8d09004          LDR      r9,[r0,#4]            ;776  ; tSWIPEvent
00007e  eb060a41          ADD      r10,r6,r1,LSL #1      ;776
000082  f809400a          STRB     r4,[r9,r10]           ;776
000086  f8934159          LDRB     r4,[r3,#0x159]        ;777
00008a  eb041444          ADD      r4,r4,r4,LSL #5       ;777
00008e  eb020444          ADD      r4,r2,r4,LSL #1       ;777
000092  eb040441          ADD      r4,r4,r1,LSL #1       ;777
000096  7924              LDRB     r4,[r4,#4]            ;777
000098  f8d09004          LDR      r9,[r0,#4]            ;777  ; tSWIPEvent
00009c  eb050a41          ADD      r10,r5,r1,LSL #1      ;777
0000a0  f809400a          STRB     r4,[r9,r10]           ;777
0000a4  f8934159          LDRB     r4,[r3,#0x159]        ;778
0000a8  eb041444          ADD      r4,r4,r4,LSL #5       ;778
0000ac  eb020444          ADD      r4,r2,r4,LSL #1       ;778
0000b0  eb040441          ADD      r4,r4,r1,LSL #1       ;778
0000b4  f8b44005          LDRH     r4,[r4,#5]            ;778
0000b8  f8d09004          LDR      r9,[r0,#4]            ;778  ; tSWIPEvent
0000bc  eb070a41          ADD      r10,r7,r1,LSL #1      ;778
0000c0  44d1              ADD      r9,r9,r10             ;778
0000c2  f8a94000          STRH     r4,[r9,#0]            ;778
0000c6  f8934159          LDRB     r4,[r3,#0x159]        ;779
0000ca  eb041444          ADD      r4,r4,r4,LSL #5       ;779
0000ce  eb020444          ADD      r4,r2,r4,LSL #1       ;779
0000d2  eb040441          ADD      r4,r4,r1,LSL #1       ;779
0000d6  f8b44007          LDRH     r4,[r4,#7]            ;779
0000da  f8d09004          LDR      r9,[r0,#4]            ;779  ; tSWIPEvent
0000de  eb080141          ADD      r1,r8,r1,LSL #1       ;779
0000e2  4449              ADD      r1,r1,r9              ;779
0000e4  800c              STRH     r4,[r1,#0]            ;779
0000e6  f8931159          LDRB     r1,[r3,#0x159]        ;780
0000ea  eb011141          ADD      r1,r1,r1,LSL #5       ;780
0000ee  eb020141          ADD      r1,r2,r1,LSL #1       ;780
0000f2  f8b14040          LDRH     r4,[r1,#0x40]         ;780
0000f6  6841              LDR      r1,[r0,#4]            ;780  ; tSWIPEvent
0000f8  f8a14040          STRH     r4,[r1,#0x40]         ;780
0000fc  f8934159          LDRB     r4,[r3,#0x159]        ;781
000100  eb041444          ADD      r4,r4,r4,LSL #5       ;781
000104  eb020444          ADD      r4,r2,r4,LSL #1       ;781
000108  f894403f          LDRB     r4,[r4,#0x3f]         ;781
00010c  f10c0c01          ADD      r12,r12,#1            ;781
000110  f881403f          STRB     r4,[r1,#0x3f]         ;781
000114  f1bc0f0a          CMP      r12,#0xa              ;774
000118  dba4              BLT      |L28.100|
00011a  6842              LDR      r2,[r0,#4]            ;783  ; tSWIPEvent
00011c  2101              MOVS     r1,#1                 ;783
00011e  7091              STRB     r1,[r2,#2]            ;783
000120  6840              LDR      r0,[r0,#4]            ;784  ; tSWIPEvent
000122  2230              MOVS     r2,#0x30              ;784
000124  8002              STRH     r2,[r0,#0]            ;784
000126  f8db0004          LDR      r0,[r11,#4]           ;784  ; tProtocolCtrl
00012a  e000              B        |L28.302|
                  |L28.300|
00012c  e00d              B        |L28.330|
                  |L28.302|
00012e  7842              LDRB     r2,[r0,#1]            ;784
000130  f8de0004          LDR      r0,[lr,#4]            ;784  ; thisInfo
000134  7002              STRB     r2,[r0,#0]            ;784
000136  b2d0              UXTB     r0,r2                 ;784
000138  2801              CMP      r0,#1                 ;784
00013a  d00e              BEQ      |L28.346|
00013c  2802              CMP      r0,#2                 ;784
00013e  bf04              ITT      EQ                    ;784
000140  f8db0000          LDREQ    r0,[r11,#0]           ;784  ; tProtocolCtrl
000144  7041              STRBEQ   r1,[r0,#1]            ;784
000146  e8bd9ff0          POP      {r4-r12,pc}
                  |L28.330|
00014a  2004              MOVS     r0,#4
00014c  f7fffffe          BL       GPIO_Get_IN
000150  2801              CMP      r0,#1
000152  bf18              IT       NE
000154  e8bd9ff0          POPNE    {r4-r12,pc}
000158  e776              B        |L28.72|
                  |L28.346|
00015a  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
00015e  7840              LDRB     r0,[r0,#1]
000160  2801              CMP      r0,#1
000162  bf18              IT       NE
000164  e8bd9ff0          POPNE    {r4-r12,pc}
000168  2100              MOVS     r1,#0
00016a  e8bd5ff0          POP      {r4-r12,lr}
00016e  2004              MOVS     r0,#4
000170  f7ffbffe          B.W      GPIO_Set_DATA
;;;800    
                          ENDP

                  |L28.372|
                          DCD      ||.data||
                  |L28.376|
                          DCD      tProtocolCtrl
                  |L28.380|
                          DCD      ||area_number.39||
                  |L28.384|
                          DCD      ||.data||+0xc

                          AREA ||i.protocol_swip_SendTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_SendTouchEvent PROC
;;;732    
;;;733    void protocol_swip_SendTouchEvent(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;734    {
;;;735    	int index = 0;	
;;;736    
;;;737    #if (SWIP_QUEUE_MODE)
;;;738    	if(sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
000004  4d5b              LDR      r5,|L29.372|
000006  2400              MOVS     r4,#0                 ;735
000008  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
00000a  f5005080          ADD      r0,r0,#0x1000
00000e  f8901159          LDRB     r1,[r0,#0x159]
000012  f8900158          LDRB     r0,[r0,#0x158]
000016  4281              CMP      r1,r0
;;;739    	{
;;;740    		for(index=0; index<MAX_TOUCH_; index++)
;;;741    		{
;;;742    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;743    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;744    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;745    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;746    			tSWIPEvent.ptPacketInfo->RowStart 					= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;747    			tSWIPEvent.ptPacketInfo->ucContactCnt 				= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;748    		}
;;;749    		tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;750    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;751    		protocol_swip_PendEventInterrupt();
;;;752    	}
;;;753    #else
;;;754    	if( thisInfo->iEventPacket_ )
;;;755    	{
;;;756    		tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;757    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;758    		protocol_swip_PendEventInterrupt();
;;;759    	}
;;;760    	else
;;;761    	{
;;;762    		tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;763    	}
;;;764    #endif
;;;765    }
000018  bf08              IT       EQ
00001a  e8bd9ff0          POPEQ    {r4-r12,pc}
00001e  f8dfb158          LDR      r11,|L29.376|
000022  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
000026  7841              LDRB     r1,[r0,#1]
000028  6868              LDR      r0,[r5,#4]  ; thisInfo
00002a  7001              STRB     r1,[r0,#0]
00002c  b2c8              UXTB     r0,r1
00002e  2801              CMP      r0,#1
000030  d07e              BEQ      |L29.304|
000032  2802              CMP      r0,#2
000034  bf18              IT       NE
000036  e8bd9ff0          POPNE    {r4-r12,pc}
00003a  f8db0000          LDR      r0,[r11,#0]  ; tProtocolCtrl
00003e  7840              LDRB     r0,[r0,#1]
000040  2800              CMP      r0,#0
000042  bf18              IT       NE
000044  e8bd9ff0          POPNE    {r4-r12,pc}
                  |L29.72|
000048  46ae              MOV      lr,r5                 ;742
00004a  68a9              LDR      r1,[r5,#8]            ;742  ; sptAlgorithmInfo
00004c  2504              MOVS     r5,#4                 ;742
00004e  4a4b              LDR      r2,|L29.380|
000050  484b              LDR      r0,|L29.384|
000052  2603              MOVS     r6,#3                 ;742
000054  2705              MOVS     r7,#5                 ;744
000056  f04f0807          MOV      r8,#7                 ;745
00005a  f5015380          ADD      r3,r1,#0x1000         ;742
00005e  bf00              NOP                            ;742
                  |L29.96|
000060  f8931159          LDRB     r1,[r3,#0x159]        ;742
000064  eb011141          ADD      r1,r1,r1,LSL #5       ;742
000068  eb020c41          ADD      r12,r2,r1,LSL #1      ;742
00006c  eb040144          ADD      r1,r4,r4,LSL #1       ;742
000070  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;742
000074  f89cc003          LDRB     r12,[r12,#3]          ;742
000078  f8d09004          LDR      r9,[r0,#4]            ;742  ; tSWIPEvent
00007c  eb060a41          ADD      r10,r6,r1,LSL #1      ;742
000080  f809c00a          STRB     r12,[r9,r10]          ;742
000084  f893c159          LDRB     r12,[r3,#0x159]       ;743
000088  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;743
00008c  eb020c4c          ADD      r12,r2,r12,LSL #1     ;743
000090  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;743
000094  f89cc004          LDRB     r12,[r12,#4]          ;743
000098  f8d09004          LDR      r9,[r0,#4]            ;743  ; tSWIPEvent
00009c  eb050a41          ADD      r10,r5,r1,LSL #1      ;743
0000a0  f809c00a          STRB     r12,[r9,r10]          ;743
0000a4  f893c159          LDRB     r12,[r3,#0x159]       ;744
0000a8  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;744
0000ac  eb020c4c          ADD      r12,r2,r12,LSL #1     ;744
0000b0  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;744
0000b4  f8bcc005          LDRH     r12,[r12,#5]          ;744
0000b8  f8d09004          LDR      r9,[r0,#4]            ;744  ; tSWIPEvent
0000bc  eb070a41          ADD      r10,r7,r1,LSL #1      ;744
0000c0  44d1              ADD      r9,r9,r10             ;744
0000c2  f8a9c000          STRH     r12,[r9,#0]           ;744
0000c6  f893c159          LDRB     r12,[r3,#0x159]       ;745
0000ca  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;745
0000ce  eb020c4c          ADD      r12,r2,r12,LSL #1     ;745
0000d2  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;745
0000d6  f8bcc007          LDRH     r12,[r12,#7]          ;745
0000da  f8d09004          LDR      r9,[r0,#4]            ;745  ; tSWIPEvent
0000de  eb080141          ADD      r1,r8,r1,LSL #1       ;745
0000e2  4449              ADD      r1,r1,r9              ;745
0000e4  f8a1c000          STRH     r12,[r1,#0]           ;745
0000e8  f8931159          LDRB     r1,[r3,#0x159]        ;746
0000ec  eb011141          ADD      r1,r1,r1,LSL #5       ;746
0000f0  eb020141          ADD      r1,r2,r1,LSL #1       ;746
0000f4  f8b1c040          LDRH     r12,[r1,#0x40]        ;746
0000f8  6841              LDR      r1,[r0,#4]            ;746  ; tSWIPEvent
0000fa  f8a1c040          STRH     r12,[r1,#0x40]        ;746
0000fe  f893c159          LDRB     r12,[r3,#0x159]       ;747
000102  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;747
000106  eb020c4c          ADD      r12,r2,r12,LSL #1     ;747
00010a  f89cc03f          LDRB     r12,[r12,#0x3f]       ;747
00010e  1c64              ADDS     r4,r4,#1              ;747
000110  f881c03f          STRB     r12,[r1,#0x3f]        ;747
000114  2c0a              CMP      r4,#0xa               ;740
000116  dba3              BLT      |L29.96|
000118  6842              LDR      r2,[r0,#4]            ;749  ; tSWIPEvent
00011a  2101              MOVS     r1,#1                 ;749
00011c  7091              STRB     r1,[r2,#2]            ;749
00011e  6840              LDR      r0,[r0,#4]            ;750  ; tSWIPEvent
000120  2230              MOVS     r2,#0x30              ;750
000122  8002              STRH     r2,[r0,#0]            ;750
000124  f8db0004          LDR      r0,[r11,#4]           ;750  ; tProtocolCtrl
000128  7842              LDRB     r2,[r0,#1]            ;750
00012a  f8de0004          LDR      r0,[lr,#4]            ;750  ; thisInfo
00012e  e000              B        |L29.306|
                  |L29.304|
000130  e00a              B        |L29.328|
                  |L29.306|
000132  7002              STRB     r2,[r0,#0]            ;750
000134  b2d0              UXTB     r0,r2                 ;750
000136  2801              CMP      r0,#1                 ;750
000138  d00e              BEQ      |L29.344|
00013a  2802              CMP      r0,#2                 ;750
00013c  bf04              ITT      EQ                    ;750
00013e  f8db0000          LDREQ    r0,[r11,#0]           ;750  ; tProtocolCtrl
000142  7041              STRBEQ   r1,[r0,#1]            ;750
000144  e8bd9ff0          POP      {r4-r12,pc}
                  |L29.328|
000148  2004              MOVS     r0,#4
00014a  f7fffffe          BL       GPIO_Get_IN
00014e  2801              CMP      r0,#1
000150  bf18              IT       NE
000152  e8bd9ff0          POPNE    {r4-r12,pc}
000156  e777              B        |L29.72|
                  |L29.344|
000158  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
00015c  7840              LDRB     r0,[r0,#1]
00015e  2801              CMP      r0,#1
000160  bf18              IT       NE
000162  e8bd9ff0          POPNE    {r4-r12,pc}
000166  2100              MOVS     r1,#0
000168  e8bd5ff0          POP      {r4-r12,lr}
00016c  2004              MOVS     r0,#4
00016e  f7ffbffe          B.W      GPIO_Set_DATA
;;;766    
                          ENDP

000172  0000              DCW      0x0000
                  |L29.372|
                          DCD      ||.data||
                  |L29.376|
                          DCD      tProtocolCtrl
                  |L29.380|
                          DCD      ||area_number.39||
                  |L29.384|
                          DCD      ||.data||+0xc

                          AREA ||i.protocol_swip_SetDFUP_Ready||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetDFUP_Ready PROC
;;;368    
;;;369    void protocol_swip_SetDFUP_Ready(bool_t _bVal)
000000  4901              LDR      r1,|L30.8|
;;;370    {
;;;371    	tProtocolCtrl.setter->bDFUP_Ready = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  74c8              STRB     r0,[r1,#0x13]
;;;372    }
000006  4770              BX       lr
;;;373    
                          ENDP

                  |L30.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetEnableBulkLog||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetEnableBulkLog PROC
;;;358    
;;;359    void protocol_swip_SetEnableBulkLog(bool_t _bVal)
000000  4901              LDR      r1,|L31.8|
;;;360    {
;;;361    	tProtocolCtrl.setter->bEnableBulkLog = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7488              STRB     r0,[r1,#0x12]
;;;362    }
000006  4770              BX       lr
;;;363    
                          ENDP

                  |L31.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetMode||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetMode PROC
;;;333    
;;;334    void protocol_swip_SetMode(eProtocolMode_t _eMode)
000000  4901              LDR      r1,|L32.8|
;;;335    {
;;;336    	tProtocolCtrl.setter->eMode = _eMode;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7008              STRB     r0,[r1,#0]
;;;337    }
000006  4770              BX       lr
;;;338    
                          ENDP

                  |L32.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_WaitEventInterruptCleared||, CODE, READONLY, ALIGN=2

                  protocol_swip_WaitEventInterruptCleared PROC
;;;500    
;;;501    void protocol_swip_WaitEventInterruptCleared(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;502    {
;;;503    #define INTR_HIGH_              300
;;;504    #define WAIT_FOR_INTERRUPT_     0xFFFF
;;;505    	int intr = NO;
000004  2500              MOVS     r5,#0
;;;506    	int cnt = WAIT_FOR_INTERRUPT_;
;;;507    	
;;;508    	do
;;;509    	{
;;;510    		switch( thisInfo->eEventTriggerType )
000006  4e32              LDR      r6,|L33.208|
000008  4c32              LDR      r4,|L33.212|
00000a  f64f78ff          MOV      r8,#0xffff            ;506
00000e  462f              MOV      r7,r5                 ;506
                  |L33.16|
000010  6870              LDR      r0,[r6,#4]  ; thisInfo
000012  7800              LDRB     r0,[r0,#0]
000014  2800              CMP      r0,#0
;;;511    		{
;;;512    			case ETT_INTERRUPT:
;;;513    			{
;;;514    				intr = Hal_GetIntr();
;;;515    				if( cnt-- == 0 )
;;;516    				{
;;;517    					Hal_ClearIntr();
;;;518    					int i;
;;;519    					for (i = INTR_HIGH_; i--;)
;;;520    					__NOP();
;;;521    					Hal_PendIntr();
;;;522    					cnt = WAIT_FOR_INTERRUPT_;
;;;523    				}
;;;524    			}
;;;525    			break;
;;;526    
;;;527    			case ETT_REGISTER:
;;;528    			{
;;;529    				intr = tProtocolCtrl.getter->bEventReady;
;;;530    				if( intr )
;;;531    				{
;;;532    					protocol_swip_ClearEventInterrupt();
;;;533    				}
;;;534    			}
;;;535    			break;
;;;536    
;;;537    			case ETT_NONE:
;;;538    				intr = NO;
000016  bf08              IT       EQ
000018  2500              MOVEQ    r5,#0
00001a  d035              BEQ      |L33.136|
00001c  2801              CMP      r0,#1                 ;510
00001e  d002              BEQ      |L33.38|
000020  2802              CMP      r0,#2                 ;510
000022  d02c              BEQ      |L33.126|
000024  e030              B        |L33.136|
                  |L33.38|
000026  6860              LDR      r0,[r4,#4]            ;510  ; tProtocolCtrl
000028  7840              LDRB     r0,[r0,#1]            ;510
00002a  2801              CMP      r0,#1                 ;510
00002c  d103              BNE      |L33.54|
00002e  2004              MOVS     r0,#4                 ;510
000030  f7fffffe          BL       GPIO_Get_IN
000034  b140              CBZ      r0,|L33.72|
                  |L33.54|
000036  2500              MOVS     r5,#0                 ;510
000038  f1b80801          SUBS     r8,r8,#1              ;510
00003c  d224              BCS      |L33.136|
00003e  6860              LDR      r0,[r4,#4]            ;510  ; tProtocolCtrl
000040  7840              LDRB     r0,[r0,#1]            ;510
000042  2801              CMP      r0,#1                 ;510
000044  d109              BNE      |L33.90|
000046  e004              B        |L33.82|
                  |L33.72|
000048  2101              MOVS     r1,#1                 ;510
00004a  2004              MOVS     r0,#4                 ;510
00004c  f7fffffe          BL       GPIO_Set_DATA
000050  e7f1              B        |L33.54|
                  |L33.82|
000052  2101              MOVS     r1,#1                 ;510
000054  2004              MOVS     r0,#4                 ;510
000056  f7fffffe          BL       GPIO_Set_DATA
                  |L33.90|
00005a  bf00              NOP                            ;520
00005c  bf00              NOP                            ;520
00005e  f2401029          MOV      r0,#0x129             ;519
                  |L33.98|
000062  bf00              NOP                            ;520
000064  1e40              SUBS     r0,r0,#1              ;520
000066  d2fc              BCS      |L33.98|
000068  6860              LDR      r0,[r4,#4]            ;519  ; tProtocolCtrl
00006a  7840              LDRB     r0,[r0,#1]            ;519
00006c  2801              CMP      r0,#1                 ;519
00006e  d103              BNE      |L33.120|
000070  2100              MOVS     r1,#0                 ;519
000072  2004              MOVS     r0,#4                 ;519
000074  f7fffffe          BL       GPIO_Set_DATA
                  |L33.120|
000078  f64f78ff          MOV      r8,#0xffff            ;522
00007c  e004              B        |L33.136|
                  |L33.126|
00007e  6820              LDR      r0,[r4,#0]            ;529  ; tProtocolCtrl
000080  7845              LDRB     r5,[r0,#1]            ;529
000082  2d00              CMP      r5,#0                 ;530
000084  bf18              IT       NE                    ;530
000086  7047              STRBNE   r7,[r0,#1]            ;530
                  |L33.136|
;;;539    			break;
;;;540    		}
;;;541    
;;;542    		if( thisInfo->eEventTriggerType != tProtocolCtrl.setter->eEventTriggerType )
000088  6870              LDR      r0,[r6,#4]  ; thisInfo
00008a  6861              LDR      r1,[r4,#4]  ; tProtocolCtrl
00008c  7800              LDRB     r0,[r0,#0]
00008e  7849              LDRB     r1,[r1,#1]
000090  4288              CMP      r0,r1
000092  d018              BEQ      |L33.198|
;;;543    		{
;;;544    			thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
000094  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
000096  7841              LDRB     r1,[r0,#1]
000098  6870              LDR      r0,[r6,#4]  ; thisInfo
00009a  7001              STRB     r1,[r0,#0]
00009c  b2c8              UXTB     r0,r1
00009e  2801              CMP      r0,#1
0000a0  d005              BEQ      |L33.174|
0000a2  2802              CMP      r0,#2
0000a4  bf04              ITT      EQ
0000a6  6820              LDREQ    r0,[r4,#0]  ; tProtocolCtrl
0000a8  7047              STRBEQ   r7,[r0,#1]
;;;545    			protocol_swip_ClearEventInterrupt();
;;;546    			break;
;;;547    		}
;;;548    	}
;;;549    	while (intr);
;;;550    }
0000aa  e8bd81f0          POP      {r4-r8,pc}
                  |L33.174|
0000ae  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
0000b0  7840              LDRB     r0,[r0,#1]
0000b2  2801              CMP      r0,#1
0000b4  bf18              IT       NE
0000b6  e8bd81f0          POPNE    {r4-r8,pc}
0000ba  2101              MOVS     r1,#1
0000bc  e8bd41f0          POP      {r4-r8,lr}
0000c0  2004              MOVS     r0,#4
0000c2  f7ffbffe          B.W      GPIO_Set_DATA
                  |L33.198|
0000c6  2d00              CMP      r5,#0                 ;549
0000c8  d1a2              BNE      |L33.16|
0000ca  e8bd81f0          POP      {r4-r8,pc}
;;;551    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L33.208|
                          DCD      ||.data||
                  |L33.212|
                          DCD      tProtocolCtrl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ktSWIPInfoPanel
                          %        23

                          AREA ||area_number.36||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.36||, ||.bss||
                  ktSWIPInfoFirmwareSectionAddress
                          %        10

                          AREA ||area_number.37||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.37||, ||.bss||
                  ktSWIPInfoFirmwareIntegrity
                          %        12

                          AREA ||area_number.38||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.38||, ||.bss||
                  ktSWIPInfoTrimCode
                          %        64

                          AREA ||area_number.39||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.39||, ||.bss||
                  ptPacketInfoQueue
                          %        462

                          AREA ||.data||, DATA, ALIGN=2

                  thisCommonConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  sptAlgorithmInfo
                          DCD      0x00000000
                  tSWIPEvent
                          DCD      tSWIPEventFormat
                          DCD      0x00000000
                  tSWIPInfo
                          DCD      ktSWIPInfoPanel
                          DCD      ktSWIPInfoFirmwareSectionVersion
                          DCD      ktSWIPInfoFirmwareSectionAddress
                          DCD      ktSWIPInfoFirmwareIntegrity
                          DCD      ktSWIPInfoInterface
                          DCD      ktSWIPInfoExtra
                          DCD      ktSWIPInfoTrimCode
                  tSWIPTest
                          DCD      ktSWIPTestInfo
                          DCD      ktSWIPTestControl
                          DCD      0x00000000
                  tSWIPBufferInfo
                          DCD      vtProtocolBufferPointers
                          DCD      ktProtocolBufferStartAddr
                          DCD      0x00000002
                  vtMRmiMap
                          DCD      0x00000000
                          DCD      ktSubsetInfo
                          DCD      ktSubsetEvent
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ktSubsetCtrl
                          DCD      0x00000000
                          DCD      ktSubsetParam
                          DCD      0x00000000
                          DCD      ktSubsetTest
                          DCD      0x00000000
                          DCD      ktSubsetImage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ktSubsetLog
                          DCD      0x00000000
                          DCD      ktSubsetSpecialAction
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||area_number.42||, DATA, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.data||
                  ktSWIPInfoInterface
000000  53574950          DCB      0x53,0x57,0x49,0x50
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  011029bd          DCWU     0x0110,0x29bd
00000c  9902              DCWU     0x9902

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  ptDummyPacketInfo
000000  0000              DCWU     0x0000
000002  0100              DCB      0x01,0x00
                          %        56
00003c  00000000          DCB      0x00,0x00,0x00,0x00
000040  0000              DCWU     0x0000

                          AREA ||area_number.44||, DATA, ALIGN=0

                          EXPORTAS ||area_number.44||, ||.data||
                  ktSWIPTestInfo
000000  20100001          DCWU     0x2010,0x0001

                          AREA ||area_number.45||, DATA, ALIGN=0

                          EXPORTAS ||area_number.45||, ||.data||
                  ktSWIPTestControl
000000  ff000000          DCB      0xff,0x00,0x00,0x00
000004  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.46||, DATA, ALIGN=0

                          EXPORTAS ||area_number.46||, ||.data||
                  ktSWIPControlForTuning
000000  0000ff00          DCB      0x00,0x00,0xff,0x00

                          AREA ||area_number.47||, DATA, ALIGN=0

                          EXPORTAS ||area_number.47||, ||.data||
                  tSWIPSpecialAction
                          DCDU     ktSWIPControlForTuning
                          DCDU     0x00000000
                          DCDU     0x00000000

                          AREA ||area_number.48||, DATA, ALIGN=0

                          EXPORTAS ||area_number.48||, ||.data||
                  ktSWIPParameterInfo
000000  60000001          DCWU     0x6000,0x0001

                          AREA ||area_number.49||, DATA, ALIGN=0

                          EXPORTAS ||area_number.49||, ||.data||
                  tSWIPParameter
                          DCDU     ktSWIPParameterInfo

                          AREA ||area_number.50||, DATA, ALIGN=1

                          EXPORTAS ||area_number.50||, ||.data||
                  ktProtocolBufferStartAddr
000000  20106000          DCW      0x2010,0x6000

                          AREA ||area_number.51||, DATA, ALIGN=0

                          EXPORTAS ||area_number.51||, ||.data||
                  SWIP_REG_ADDR_INFO_LOWER_ADDR
000000  00203040          DCB      0x00,0x20,0x30,0x40
000004  5070a0c0          DCB      0x50,0x70,0xa0,0xc0

                          AREA ||area_number.52||, DATA, ALIGN=0

                          EXPORTAS ||area_number.52||, ||.data||
                  SWIP_REG_ADDR_EVENT_LOWER_ADDR
000000  001011            DCB      0x00,0x10,0x11

                          AREA ||area_number.53||, DATA, ALIGN=0

                          EXPORTAS ||area_number.53||, ||.data||
                  SWIP_REG_ADDR_CTRL_LOWER_ADDR
000000  0010              DCB      0x00,0x10

                          AREA ||area_number.54||, DATA, ALIGN=0

                          EXPORTAS ||area_number.54||, ||.data||
                  SWIP_REG_ADDR_PARAMETER_LOWER_ADDR
000000  00                DCB      0x00

                          AREA ||area_number.55||, DATA, ALIGN=0

                          EXPORTAS ||area_number.55||, ||.data||
                  SWIP_REG_ADDR_TEST_LOWER_ADDR
000000  001020            DCB      0x00,0x10,0x20

                          AREA ||area_number.56||, DATA, ALIGN=0

                          EXPORTAS ||area_number.56||, ||.data||
                  SWIP_REG_ADDR_IMAGE_LOWER_ADDR
000000  00102030          DCB      0x00,0x10,0x20,0x30
000004  31                DCB      0x31

                          AREA ||area_number.57||, DATA, ALIGN=0

                          EXPORTAS ||area_number.57||, ||.data||
                  SWIP_REG_ADDR_LOG_LOWER_ADDR
000000  001020            DCB      0x00,0x10,0x20

                          AREA ||area_number.58||, DATA, ALIGN=0

                          EXPORTAS ||area_number.58||, ||.data||
                  SWIP_REG_ADDR_SPECIAL_ACTION_LOWER_ADDR
000000  001030            DCB      0x00,0x10,0x30

                          AREA ||area_number.59||, DATA, ALIGN=0

                          EXPORTAS ||area_number.59||, ||.data||
                  ktSubsetInfo
                          DCDU     tSWIPInfo
                          DCDU     SWIP_REG_ADDR_INFO_LOWER_ADDR
                          DCDU     0x00000007

                          AREA ||area_number.60||, DATA, ALIGN=0

                          EXPORTAS ||area_number.60||, ||.data||
                  ktSubsetEvent
                          DCDU     tSWIPEvent
                          DCDU     SWIP_REG_ADDR_EVENT_LOWER_ADDR
                          DCDU     0x00000002

                          AREA ||area_number.61||, DATA, ALIGN=0

                          EXPORTAS ||area_number.61||, ||.data||
                  ktSubsetCtrl
                          DCDU     tProtocolCtrl
                          DCDU     SWIP_REG_ADDR_CTRL_LOWER_ADDR
                          DCDU     0x00000002

                          AREA ||area_number.62||, DATA, ALIGN=0

                          EXPORTAS ||area_number.62||, ||.data||
                  ktSubsetParam
                          DCDU     tSWIPParameter
                          DCDU     SWIP_REG_ADDR_PARAMETER_LOWER_ADDR
                          DCDU     0x00000001

                          AREA ||area_number.63||, DATA, ALIGN=0

                          EXPORTAS ||area_number.63||, ||.data||
                  ktSubsetTest
                          DCDU     tSWIPTest
                          DCDU     SWIP_REG_ADDR_TEST_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.64||, DATA, ALIGN=0

                          EXPORTAS ||area_number.64||, ||.data||
                  ktSubsetImage
                          DCDU     tProtocolImage
                          DCDU     SWIP_REG_ADDR_IMAGE_LOWER_ADDR
                          DCDU     0x00000005

                          AREA ||area_number.65||, DATA, ALIGN=0

                          EXPORTAS ||area_number.65||, ||.data||
                  ktSubsetLog
                          DCDU     tProtocolLog
                          DCDU     SWIP_REG_ADDR_LOG_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.66||, DATA, ALIGN=0

                          EXPORTAS ||area_number.66||, ||.data||
                  ktSubsetSpecialAction
                          DCDU     tSWIPSpecialAction
                          DCDU     SWIP_REG_ADDR_SPECIAL_ACTION_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.67||, DATA, ALIGN=0

                          EXPORTAS ||area_number.67||, ||.data||
                  ktSWIPInfoFirmwareSectionVersion
                          DCDU     0x00000000
000004  0000              DCB      0x00,0x00

                          AREA ||area_number.68||, DATA, ALIGN=0

                          EXPORTAS ||area_number.68||, ||.data||
                  ktSWIPInfoExtra
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.69||, DATA, ALIGN=0

                          EXPORTAS ||area_number.69||, ||.data||
                  tSWIPEventFormat
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Protocol\\protocol_swip.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___15_protocol_swip_c_c9478dad____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____REVSH|
#line 402
|__asm___15_protocol_swip_c_c9478dad____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____RRX|
#line 587
|__asm___15_protocol_swip_c_c9478dad____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
