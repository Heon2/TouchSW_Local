; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\pe_usb.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\pe_usb.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\pe_usb.crf ..\..\Hal\usb\FWOTG210_F000\Pe_usb.c]
                          THUMB

                          AREA ||i.CheckHIDReady||, CODE, READONLY, ALIGN=2

                  CheckHIDReady PROC
;;;263    // Touch Contact Count
;;;264    uint8_t CheckHIDReady(void)
000000  4801              LDR      r0,|L1.8|
;;;265    {
;;;266    	return g_HIDReady;
000002  7840              LDRB     r0,[r0,#1]  ; g_HIDReady
;;;267    }
000004  4770              BX       lr
;;;268    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.CheckUsbConfig||, CODE, READONLY, ALIGN=2

                  CheckUsbConfig PROC
;;;257    // Checking the USB device is ready to be used.
;;;258    uint8_t CheckUsbConfig(void)
000000  4801              LDR      r0,|L2.8|
;;;259    {
;;;260    	return g_Configuration;
000002  7800              LDRB     r0,[r0,#0]  ; g_Configuration
;;;261    }
000004  4770              BX       lr
;;;262    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.DMABulkData_USB||, CODE, READONLY, ALIGN=1

                  DMABulkData_USB PROC
;;;1832   // Device to Host
;;;1833   void DMABulkData_USB(void)
000000  4770              BX       lr
;;;1834   {
;;;1835   #ifndef MODE_I2C
;;;1836   	// Virtual DMA Mask - Bulk Custom IN
;;;1837   	mUsbEXIntDmaErrEn(BULK_CUSTOM_FIFO_IN);
;;;1838   	mUsbEXIntDmaFinishEn(BULK_CUSTOM_FIFO_IN);
;;;1839   
;;;1840   	// Virtual DMA Start !!!!
;;;1841   	mUsbEXDmaConfig(BULK_CUSTOM_FIFO_IN, MX_PA_SZ_64, DIRECTION_IN);
;;;1842   	mUsbEXDmaAddr(BULK_CUSTOM_FIFO_IN, (uint32_t)g_BulkCustomBuffer);
;;;1843   	mUsbEXDmaStart(BULK_CUSTOM_FIFO_IN);
;;;1844   #endif
;;;1845   	return;
;;;1846   }
;;;1847   
                          ENDP


                          AREA ||i.DMACustomData_USB||, CODE, READONLY, ALIGN=1

                  DMACustomData_USB PROC
;;;781    // Device to Host
;;;782    void DMACustomData_USB()
000000  4770              BX       lr
;;;783    {
;;;784    #ifndef MODE_I2C
;;;785    	// Virtual DMA Mask - Custom IN
;;;786    	mUsbEXIntDmaErrEn(CUSTOM_FIFO_IN);
;;;787    	mUsbEXIntDmaFinishEn(CUSTOM_FIFO_IN);
;;;788    
;;;789    	// Virtual DMA Start !!!!
;;;790    	mUsbEXDmaConfig(CUSTOM_FIFO_IN, MX_PA_SZ_64, DIRECTION_IN);
;;;791    	mUsbEXDmaAddr(CUSTOM_FIFO_IN, (uint32_t)g_CustomBuffer);
;;;792    	mUsbEXDmaStart(CUSTOM_FIFO_IN);
;;;793    #endif
;;;794    	return;
;;;795    }
;;;796    
                          ENDP


                          AREA ||i.DMATouchData_USB||, CODE, READONLY, ALIGN=1

                  DMATouchData_USB PROC
;;;557    
;;;558    void DMATouchData_USB(void)
000000  4770              BX       lr
;;;559    {
;;;560    #ifndef MODE_I2C
;;;561    	// Virtual DMA Mask - MultiTouch
;;;562    	mUsbEXIntDmaErrEn(TOUCH_FIFO_IN);
;;;563    	mUsbEXIntDmaFinishEn(TOUCH_FIFO_IN);
;;;564    
;;;565    	// Virtual DMA Start !!!!
;;;566    	mUsbEXDmaConfig(TOUCH_FIFO_IN, sizeof(HID_MULTITOUCH), DIRECTION_IN);
;;;567    	mUsbEXDmaAddr(TOUCH_FIFO_IN, (uint32_t)&g_Touch);
;;;568    	mUsbEXDmaStart(TOUCH_FIFO_IN);
;;;569    #endif
;;;570    	return;
;;;571    }
;;;572    
                          ENDP


                          AREA ||i.GetScanTime||, CODE, READONLY, ALIGN=2

                  GetScanTime PROC
;;;513    
;;;514    uint16_t GetScanTime(uint64_t* StartTime, uint32_t* ScanTime)
000000  b570              PUSH     {r4-r6,lr}
;;;515    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  e9d60100          LDRD     r0,r1,[r6,#0]
00000a  2400              MOVS     r4,#0
;;;516    	uint16_t Temp = 0;
;;;517    
;;;518    	if (*StartTime == 0)
00000c  ea500201          ORRS     r2,r0,r1
000010  d00e              BEQ      |L6.48|
;;;519    	{
;;;520    		goto GETSCANTIME__GOTO_END;
;;;521    	}
;;;522    
;;;523    	Temp = (uint16_t)(getElapsedUS(*StartTime) / 100);
000012  f7fffffe          BL       getElapsedLongSYSTICK
000016  4a10              LDR      r2,|L6.88|
000018  6812              LDR      r2,[r2,#0]  ; _timer_clock_
00001a  4623              MOV      r3,r4
00001c  f7fffffe          BL       __aeabi_uldivmod
000020  2264              MOVS     r2,#0x64
000022  2300              MOVS     r3,#0
000024  f7fffffe          BL       __aeabi_uldivmod
;;;524    	*ScanTime += Temp;
000028  6829              LDR      r1,[r5,#0]
00002a  b280              UXTH     r0,r0                 ;523
00002c  4408              ADD      r0,r0,r1
00002e  6028              STR      r0,[r5,#0]
                  |L6.48|
;;;525    
;;;526    GETSCANTIME__GOTO_END:
;;;527    
;;;528    	*StartTime = (uint64_t)getLongSysTick();
000030  480a              LDR      r0,|L6.92|
000032  6800              LDR      r0,[r0,#0]  ; _timertick_high_rank_count_
000034  03a2              LSLS     r2,r4,#14
000036  ea424190          ORR      r1,r2,r0,LSR #18
00003a  0382              LSLS     r2,r0,#14
00003c  f04f4080          MOV      r0,#0x40000000
000040  f8d001b8          LDR      r0,[r0,#0x1b8]
000044  f3c0000d          UBFX     r0,r0,#0,#14
000048  4310              ORRS     r0,r0,r2
00004a  4321              ORRS     r1,r1,r4
00004c  e9c60100          STRD     r0,r1,[r6,#0]
;;;529    	return *ScanTime;
000050  8828              LDRH     r0,[r5,#0]
000052  b280              UXTH     r0,r0
;;;530    }
000054  bd70              POP      {r4-r6,pc}
;;;531    
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      _timer_clock_
                  |L6.92|
                          DCD      _timertick_high_rank_count_

                          AREA ||i.HidReadWrite__Read||, CODE, READONLY, ALIGN=2

                  HidReadWrite__Read PROC
;;;899    
;;;900    void HidReadWrite__Read(PHJ_HID_CONTROL_STRUCT pOutBuffer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;901    {
000004  4604              MOV      r4,r0
;;;902    	uint16_t	index = 0;
;;;903    	uint8_t		nData = 0;
;;;904    
;;;905    	pOutBuffer->PacketID = HID_REPORT_ID__CUSTOM_IN;
000006  200a              MOVS     r0,#0xa
000008  7020              STRB     r0,[r4,#0]
;;;906    	pOutBuffer->DeviceID_b.addr = 0x34;
00000a  7860              LDRB     r0,[r4,#1]
00000c  2600              MOVS     r6,#0                 ;902
00000e  f02000fe          BIC      r0,r0,#0xfe
000012  3068              ADDS     r0,r0,#0x68
;;;907    	pOutBuffer->DeviceID_b.bRead = TRUE;
000014  f0400001          ORR      r0,r0,#1
000018  7060              STRB     r0,[r4,#1]
;;;908    	
;;;909    	for (index = 0; index< pOutBuffer->Length; index++)
00001a  8860              LDRH     r0,[r4,#2]
00001c  4d27              LDR      r5,|L7.188|
00001e  4637              MOV      r7,r6                 ;903
000020  2800              CMP      r0,#0
000022  bf88              IT       HI
000024  f8df8098          LDRHI    r8,|L7.192|
000028  d917              BLS      |L7.90|
                  |L7.42|
00002a  69e8              LDR      r0,[r5,#0x1c]         ;901  ; rmi_read_ptr
00002c  b180              CBZ      r0,|L7.80|
00002e  f8109b01          LDRB     r9,[r0],#1            ;901
000032  61e8              STR      r0,[r5,#0x1c]         ;901  ; rmi_read_ptr
000034  f8d81000          LDR      r1,[r8,#0]            ;901  ; protocol_ClearInterrupt
000038  b121              CBZ      r1,|L7.68|
00003a  88a8              LDRH     r0,[r5,#4]            ;901  ; g_usRegAddr
00003c  8caa              LDRH     r2,[r5,#0x24]         ;901  ; protocol_sent_byte
00003e  4410              ADD      r0,r0,r2              ;901
000040  b280              UXTH     r0,r0                 ;901
000042  4788              BLX      r1                    ;901
                  |L7.68|
000044  6a68              LDR      r0,[r5,#0x24]         ;901  ; protocol_sent_byte
000046  1c40              ADDS     r0,r0,#1              ;901
;;;910    	{
;;;911    		if (Protocol_hid_FromDeviceToHost(&nData, FALSE) == TRUE)
;;;912    		{
;;;913    			pOutBuffer->Data[index] = nData;
000048  6268              STR      r0,[r5,#0x24]  ; protocol_sent_byte
00004a  19a0              ADDS     r0,r4,r6
00004c  f8809004          STRB     r9,[r0,#4]
                  |L7.80|
000050  1c70              ADDS     r0,r6,#1              ;909
000052  b286              UXTH     r6,r0                 ;909
000054  8860              LDRH     r0,[r4,#2]            ;909
000056  42b0              CMP      r0,r6                 ;909
000058  d8e7              BHI      |L7.42|
                  |L7.90|
00005a  481a              LDR      r0,|L7.196|
;;;914    		}
;;;915    	}
;;;916    
;;;917    #ifdef ADD_CUSTOM
;;;918    	SendCustomData_USB((uint8_t*)pOutBuffer);
00005c  4621              MOV      r1,r4
00005e  f8d007c2          LDR      r0,[r0,#0x7c2]
000062  281e              CMP      r0,#0x1e
000064  d304              BCC      |L7.112|
000066  69a8              LDR      r0,[r5,#0x18]  ; g_Full
000068  1c40              ADDS     r0,r0,#1
00006a  61a8              STR      r0,[r5,#0x18]  ; g_Full
;;;919    #endif
;;;920    	return;
;;;921    }
00006c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.112|
000070  4c14              LDR      r4,|L7.196|
000072  2900              CMP      r1,#0
000074  bf08              IT       EQ
000076  e8bd87f0          POPEQ    {r4-r10,pc}
00007a  2001              MOVS     r0,#1
00007c  f88407c6          STRB     r0,[r4,#0x7c6]
000080  f89407c0          LDRB     r0,[r4,#0x7c0]
000084  2242              MOVS     r2,#0x42
000086  eb001040          ADD      r0,r0,r0,LSL #5
00008a  eb040040          ADD      r0,r4,r0,LSL #1
00008e  1d00              ADDS     r0,r0,#4
000090  f7fffffe          BL       __aeabi_memcpy
000094  f8d407c2          LDR      r0,[r4,#0x7c2]
000098  1c40              ADDS     r0,r0,#1
00009a  f8c407c2          STR      r0,[r4,#0x7c2]
00009e  f89407c0          LDRB     r0,[r4,#0x7c0]
0000a2  1c40              ADDS     r0,r0,#1
0000a4  b2c0              UXTB     r0,r0
0000a6  f88407c0          STRB     r0,[r4,#0x7c0]
0000aa  281e              CMP      r0,#0x1e
0000ac  bf28              IT       CS
0000ae  f88477c0          STRBCS   r7,[r4,#0x7c0]
0000b2  f88477c6          STRB     r7,[r4,#0x7c6]
0000b6  e8bd87f0          POP      {r4-r10,pc}
;;;922    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L7.188|
                          DCD      ||.data||
                  |L7.192|
                          DCD      protocol_ClearInterrupt
                  |L7.196|
                          DCD      ||area_number.37||+0xac

                          AREA ||i.HidReadWrite__Read_I2C||, CODE, READONLY, ALIGN=2

                  HidReadWrite__Read_I2C PROC
;;;924    #ifdef MODE_I2C
;;;925    void HidReadWrite__Read_I2C(PHJ_HID_CONTROL_STRUCT_I2C pHidControl)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;926    {
000004  4604              MOV      r4,r0
;;;927    	uint16_t	index = 0;
;;;928    	uint8_t		nData = 0;
;;;929    
;;;930    	pHidControl->Data.PacketID = HID_REPORT_ID__CUSTOM_IN;
000006  200a              MOVS     r0,#0xa
000008  70a0              STRB     r0,[r4,#2]
;;;931    	pHidControl->Data.DeviceID_b.addr = 0x34;
00000a  78e0              LDRB     r0,[r4,#3]
00000c  2500              MOVS     r5,#0                 ;927
00000e  f02000fe          BIC      r0,r0,#0xfe
000012  3068              ADDS     r0,r0,#0x68
;;;932    	pHidControl->Data.DeviceID_b.bRead = TRUE;
000014  f0400001          ORR      r0,r0,#1
000018  70e0              STRB     r0,[r4,#3]
;;;933    
;;;934    	for (index = 0; index < pHidControl->Data.Length; index++)
00001a  88a0              LDRH     r0,[r4,#4]
00001c  2800              CMP      r0,#0
00001e  bf84              ITT      HI
000020  4f0f              LDRHI    r7,|L8.96|
000022  4e10              LDRHI    r6,|L8.100|
000024  d916              BLS      |L8.84|
                  |L8.38|
000026  69f0              LDR      r0,[r6,#0x1c]         ;926  ; rmi_read_ptr
000028  b178              CBZ      r0,|L8.74|
00002a  f8108b01          LDRB     r8,[r0],#1            ;926
00002e  61f0              STR      r0,[r6,#0x1c]         ;926  ; rmi_read_ptr
000030  6839              LDR      r1,[r7,#0]            ;926  ; protocol_ClearInterrupt
000032  b121              CBZ      r1,|L8.62|
000034  88b0              LDRH     r0,[r6,#4]            ;926  ; g_usRegAddr
000036  8cb2              LDRH     r2,[r6,#0x24]         ;926  ; protocol_sent_byte
000038  4410              ADD      r0,r0,r2              ;926
00003a  b280              UXTH     r0,r0                 ;926
00003c  4788              BLX      r1                    ;926
                  |L8.62|
00003e  6a70              LDR      r0,[r6,#0x24]         ;926  ; protocol_sent_byte
000040  1c40              ADDS     r0,r0,#1              ;926
;;;935    	{
;;;936    		if (Protocol_hid_FromDeviceToHost(&nData, FALSE) == TRUE)
;;;937    		{
;;;938    			pHidControl->Data.Data[index] = nData;
000042  6270              STR      r0,[r6,#0x24]  ; protocol_sent_byte
000044  1960              ADDS     r0,r4,r5
000046  f8808006          STRB     r8,[r0,#6]
                  |L8.74|
00004a  1c68              ADDS     r0,r5,#1              ;934
00004c  b285              UXTH     r5,r0                 ;934
00004e  88a0              LDRH     r0,[r4,#4]            ;934
000050  42a8              CMP      r0,r5                 ;934
000052  d8e8              BHI      |L8.38|
                  |L8.84|
;;;939    		}
;;;940    	}
;;;941    
;;;942    	// Send
;;;943    	SendCustomData_I2C(pHidControl);
000054  4620              MOV      r0,r4
000056  e8bd41f0          POP      {r4-r8,lr}
00005a  f7ffbffe          B.W      SendCustomData_I2C
;;;944    	return;
;;;945    }
;;;946    #endif /* MODE_I2C */
                          ENDP

00005e  0000              DCW      0x0000
                  |L8.96|
                          DCD      protocol_ClearInterrupt
                  |L8.100|
                          DCD      ||.data||

                          AREA ||i.HidReadWrite__Write||, CODE, READONLY, ALIGN=2

                  HidReadWrite__Write PROC
;;;948    
;;;949    void HidReadWrite__Write(PHJ_HID_CONTROL_STRUCT pHidControl)
000000  b570              PUSH     {r4-r6,lr}
;;;950    {
000002  4604              MOV      r4,r0
;;;951    	uint16_t usRegAddr = 0;
;;;952    	uint16_t index = 0;
;;;953    
;;;954    	usRegAddr = pHidControl->Data[0] << 8;
000004  7900              LDRB     r0,[r0,#4]
;;;955    	usRegAddr |= pHidControl->Data[1];
000006  7961              LDRB     r1,[r4,#5]
000008  4e12              LDR      r6,|L9.84|
00000a  ea412000          ORR      r0,r1,r0,LSL #8
00000e  4910              LDR      r1,|L9.80|
000010  2500              MOVS     r5,#0                 ;952
000012  6809              LDR      r1,[r1,#0]            ;952  ; protocol_GetMappedPointer
000014  b131              CBZ      r1,|L9.36|
000016  80b0              STRH     r0,[r6,#4]            ;950
000018  4788              BLX      r1                    ;950
00001a  6230              STR      r0,[r6,#0x20]         ;950  ; rmi_write_ptr
00001c  61f0              STR      r0,[r6,#0x1c]         ;950  ; rmi_read_ptr
00001e  2000              MOVS     r0,#0                 ;950
000020  6270              STR      r0,[r6,#0x24]         ;950  ; protocol_sent_byte
000022  62b0              STR      r0,[r6,#0x28]         ;950  ; protocol_received_byte
                  |L9.36|
;;;956    
;;;957    	Protocol_hid__SetAddress(usRegAddr);
;;;958    	for (index = 0; index < (pHidControl->Length-2); index++)
000024  8860              LDRH     r0,[r4,#2]
000026  1e80              SUBS     r0,r0,#2
000028  2800              CMP      r0,#0
;;;959    	{
;;;960    		Protocol_hid__FromHostToDevice(pHidControl->Data[2+index]);
;;;961    	}
;;;962    
;;;963    	return;
;;;964    }
00002a  bfd8              IT       LE
00002c  bd70              POPLE    {r4-r6,pc}
                  |L9.46|
00002e  1960              ADDS     r0,r4,r5              ;960
000030  7981              LDRB     r1,[r0,#6]            ;960
000032  6a30              LDR      r0,[r6,#0x20]         ;960  ; rmi_write_ptr
000034  b128              CBZ      r0,|L9.66|
000036  f8001b01          STRB     r1,[r0],#1            ;960
00003a  6230              STR      r0,[r6,#0x20]         ;960  ; rmi_write_ptr
00003c  6ab0              LDR      r0,[r6,#0x28]         ;960  ; protocol_received_byte
00003e  1c40              ADDS     r0,r0,#1              ;960
000040  62b0              STR      r0,[r6,#0x28]         ;960  ; protocol_received_byte
                  |L9.66|
000042  1c68              ADDS     r0,r5,#1              ;958
000044  b285              UXTH     r5,r0                 ;958
000046  8860              LDRH     r0,[r4,#2]            ;958
000048  1e80              SUBS     r0,r0,#2              ;958
00004a  42a8              CMP      r0,r5                 ;958
00004c  dcef              BGT      |L9.46|
00004e  bd70              POP      {r4-r6,pc}
;;;965    
                          ENDP

                  |L9.80|
                          DCD      protocol_GetMappedPointer
                  |L9.84|
                          DCD      ||.data||

                          AREA ||i.Protocol_hid_FromDeviceToHost||, CODE, READONLY, ALIGN=2

                  Protocol_hid_FromDeviceToHost PROC
;;;856    
;;;857    uint8_t Protocol_hid_FromDeviceToHost(uint8_t* pRetData, uint8_t b2Byte)
000000  b510              PUSH     {r4,lr}
;;;858    {
;;;859    	uint8_t nRet = FALSE;
;;;860    
;;;861    	if (rmi_read_ptr)
000002  4c0c              LDR      r4,|L10.52|
000004  4602              MOV      r2,r0                 ;858
000006  2000              MOVS     r0,#0                 ;859
000008  69e1              LDR      r1,[r4,#0x1c]         ;858  ; rmi_read_ptr
00000a  2900              CMP      r1,#0                 ;858
;;;862    	{
;;;863    #if USED_I2C_READ_DATA_UNIT_2BYTE
;;;864    		if (b2Byte == TRUE)
;;;865    		{
;;;866    			if(bIsTempSend)
;;;867    			{
;;;868    				pRetData[0] = usTempSendData;
;;;869    				bIsTempSend = NO;
;;;870    			}
;;;871    			else
;;;872    			{
;;;873    				pRetData[0] = *(rmi_read_ptr++);
;;;874    				usTempSendData = *(rmi_read_ptr++);
;;;875    				bIsTempSend = YES;
;;;876    			}
;;;877    		}
;;;878    		else
;;;879    		{
;;;880    			pRetData[0] = *(rmi_read_ptr++);
;;;881    		}
;;;882    #else /* USED_I2C_READ_DATA_UNIT_2BYTE */
;;;883    		pRetData[0] = *(rmi_read_ptr++);
;;;884    #endif /* USED_I2C_READ_DATA_UNIT_2BYTE */
;;;885    
;;;886    		if (protocol_ClearInterrupt != NULL)
;;;887    		{
;;;888    			(*protocol_ClearInterrupt)(g_usRegAddr + protocol_sent_byte);
;;;889    		}
;;;890    		protocol_sent_byte++;
;;;891    
;;;892    		nRet = TRUE;
;;;893    	}
;;;894    
;;;895    	return nRet;
;;;896    }
00000c  bf08              IT       EQ
00000e  bd10              POPEQ    {r4,pc}
000010  7808              LDRB     r0,[r1,#0]            ;883
000012  7010              STRB     r0,[r2,#0]            ;883
000014  69e0              LDR      r0,[r4,#0x1c]         ;883  ; rmi_read_ptr
000016  1c40              ADDS     r0,r0,#1              ;883
000018  61e0              STR      r0,[r4,#0x1c]         ;886  ; rmi_read_ptr
00001a  4807              LDR      r0,|L10.56|
00001c  6801              LDR      r1,[r0,#0]            ;886  ; protocol_ClearInterrupt
00001e  b121              CBZ      r1,|L10.42|
000020  88a0              LDRH     r0,[r4,#4]            ;888  ; g_usRegAddr
000022  8ca2              LDRH     r2,[r4,#0x24]         ;888  ; protocol_sent_byte
000024  4410              ADD      r0,r0,r2              ;888
000026  b280              UXTH     r0,r0                 ;888
000028  4788              BLX      r1                    ;888
                  |L10.42|
00002a  6a60              LDR      r0,[r4,#0x24]         ;890  ; protocol_sent_byte
00002c  1c40              ADDS     r0,r0,#1              ;890
00002e  6260              STR      r0,[r4,#0x24]         ;892  ; protocol_sent_byte
000030  2001              MOVS     r0,#1                 ;892
000032  bd10              POP      {r4,pc}
;;;897    
                          ENDP

                  |L10.52|
                          DCD      ||.data||
                  |L10.56|
                          DCD      protocol_ClearInterrupt

                          AREA ||i.Protocol_hid_Init||, CODE, READONLY, ALIGN=2

                  Protocol_hid_Init PROC
;;;819    
;;;820    void Protocol_hid_Init(void)
000000  4802              LDR      r0,|L11.12|
;;;821    {
;;;822    	//rmi_read_ptr = NULL;
;;;823    	//protocol_sent_byte = 0;
;;;824    
;;;825    	rmi_write_ptr = NULL;
000002  2100              MOVS     r1,#0
;;;826    	protocol_received_byte = 0;
000004  6201              STR      r1,[r0,#0x20]  ; rmi_write_ptr
000006  6281              STR      r1,[r0,#0x28]  ; protocol_received_byte
;;;827    
;;;828    	return;
;;;829    }
000008  4770              BX       lr
;;;830    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      ||.data||

                          AREA ||i.Protocol_hid__FromHostToDevice||, CODE, READONLY, ALIGN=2

                  Protocol_hid__FromHostToDevice PROC
;;;844    
;;;845    void Protocol_hid__FromHostToDevice(uint8_t Data)
000000  4905              LDR      r1,|L12.24|
;;;846    {
000002  6a0a              LDR      r2,[r1,#0x20]  ; rmi_write_ptr
000004  2a00              CMP      r2,#0
;;;847    	if (rmi_write_ptr != NULL)
;;;848    	{
;;;849    		*(rmi_write_ptr++) = Data;
;;;850    		protocol_received_byte++;
;;;851    	}
;;;852    
;;;853    	return;
;;;854    }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  f8020b01          STRB     r0,[r2],#1            ;849
00000e  620a              STR      r2,[r1,#0x20]         ;850  ; rmi_write_ptr
000010  6a88              LDR      r0,[r1,#0x28]         ;850  ; protocol_received_byte
000012  1c40              ADDS     r0,r0,#1              ;850
000014  6288              STR      r0,[r1,#0x28]         ;850  ; protocol_received_byte
000016  4770              BX       lr
;;;855    
                          ENDP

                  |L12.24|
                          DCD      ||.data||

                          AREA ||i.Protocol_hid__SetAddress||, CODE, READONLY, ALIGN=2

                  Protocol_hid__SetAddress PROC
;;;830    
;;;831    void Protocol_hid__SetAddress(uint16_t usRegAddr)
000000  4907              LDR      r1,|L13.32|
;;;832    {
;;;833    	if (protocol_GetMappedPointer != NULL)
000002  6809              LDR      r1,[r1,#0]  ; protocol_GetMappedPointer
000004  2900              CMP      r1,#0
;;;834    	{
;;;835    		g_usRegAddr = usRegAddr;
;;;836    		rmi_read_ptr = rmi_write_ptr = (*protocol_GetMappedPointer)(usRegAddr);
;;;837    		protocol_sent_byte = 0;
;;;838    		protocol_received_byte = 0;
;;;839    	}
;;;840    
;;;841    	return;
;;;842    }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;832
00000c  4c05              LDR      r4,|L13.36|
00000e  80a0              STRH     r0,[r4,#4]            ;835
000010  4788              BLX      r1                    ;836
000012  6220              STR      r0,[r4,#0x20]         ;836  ; rmi_write_ptr
000014  61e0              STR      r0,[r4,#0x1c]         ;837  ; rmi_read_ptr
000016  2000              MOVS     r0,#0                 ;837
000018  6260              STR      r0,[r4,#0x24]         ;838  ; protocol_sent_byte
00001a  62a0              STR      r0,[r4,#0x28]         ;838  ; protocol_received_byte
00001c  bd10              POP      {r4,pc}
;;;843    
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      protocol_GetMappedPointer
                  |L13.36|
                          DCD      ||.data||

                          AREA ||i.QueueCommonData_USB||, CODE, READONLY, ALIGN=1

                  QueueCommonData_USB PROC
;;;1879   #endif
;;;1880   void QueueCommonData_USB(void)
000000  4770              BX       lr
;;;1881   {
;;;1882   #ifndef MODE_I2C
;;;1883   	uint8_t* pCheckID = NULL;
;;;1884   
;;;1885   	if ((CheckUsbConfig() == 0) || (CheckHIDReady() == 0) || (g_CXF_Done != CXF_STATUS__COMPLETE_DONE))
;;;1886   	{
;;;1887   		goto QUEUECOMMONDATA_USB__GOTO_END;
;;;1888   	}
;;;1889   	
;;;1890   	if (g_RemoteWakeup == 1)
;;;1891   	{
;;;1892   		goto QUEUECOMMONDATA_USB__GOTO_END;
;;;1893   	}
;;;1894   	
;;;1895   #if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
;;;1896   	if(bReportDelayFlag == 0)
;;;1897   #endif
;;;1898   	{
;;;1899   		if (StaticQueue_CheckEmpty(&g_Queue_Common) == 0)
;;;1900   		{
;;;1901   			pCheckID = StaticQueue_Get(&g_Queue_Common);
;;;1902   			switch (pCheckID[0])
;;;1903   			{
;;;1904   				case HID_REPORT_ID__MULTI_TOUCH:
;;;1905   	#if USED_S3_WAKEUP_MOUSE_DEVICE
;;;1906   				case HID_REPORT_ID__MOUSE:
;;;1907   	#endif /* USED_S3_WAKEUP_MOUSE_DEVICE */
;;;1908   				{
;;;1909   	#ifdef ADD_TOUCH
;;;1910   					if ((g_CheckVDMAComplete_Touch == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;1911   					{
;;;1912   						// Pop
;;;1913   						if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Touch) == TRUE)
;;;1914   	                    {
;;;1915   	                        g_CheckVDMAComplete_Touch = DMA_NOT_READY;
;;;1916   	                        mUsbIntF1INEn(); // Touch IN
;;;1917   	                    }
;;;1918   					}
;;;1919   	#endif
;;;1920   					break;
;;;1921   				}
;;;1922   
;;;1923   				case HID_REPORT_ID__PEN:
;;;1924   				case HID_REPORT_ID__PEN_SECOND:
;;;1925   				{
;;;1926   	#ifdef ADD_PEN
;;;1927   					if ((g_CheckVDMAComplete_Pen == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;1928   					{
;;;1929   						// Pop
;;;1930   						if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Pen) == TRUE)
;;;1931   	                    {
;;;1932   	                        g_CheckVDMAComplete_Pen = DMA_NOT_READY;
;;;1933   	                        mUsbIntF3INEn(); // Pen IN
;;;1934   	                    }
;;;1935   					}
;;;1936   	#endif
;;;1937   
;;;1938   					break;
;;;1939   				}
;;;1940   
;;;1941   				// Custom or Bulk
;;;1942   				case HID_REPORT_ID__CUSTOM_IN:
;;;1943   				default:
;;;1944   				{
;;;1945   	#ifdef ADD_CUSTOM
;;;1946   					if ((g_CheckVDMAComplete_Custom == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;1947   					{
;;;1948   						// Pop
;;;1949   						if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_CustomBuffer) == TRUE)
;;;1950   	                    {
;;;1951   	                        g_CheckVDMAComplete_Custom = DMA_NOT_READY;
;;;1952   	                        mUsbIntF0INEn(); // Custom IN
;;;1953   	                    }
;;;1954   					}
;;;1955   	#endif
;;;1956   
;;;1957   					break;
;;;1958   				}
;;;1959   			}
;;;1960   		}
;;;1961   	}
;;;1962   QUEUECOMMONDATA_USB__GOTO_END:
;;;1963   
;;;1964   #endif
;;;1965   	return;
;;;1966   }
;;;1967   
                          ENDP


                          AREA ||i.RecieveBulkCustomData||, CODE, READONLY, ALIGN=1

                  RecieveBulkCustomData PROC
;;;1849   // Host to Device
;;;1850   void RecieveBulkCustomData(uint8_t* pData)
000000  4770              BX       lr
;;;1851   {
;;;1852   #ifndef MODE_I2C
;;;1853   	// Something !!!
;;;1854   
;;;1855   	DMABulkData_USB();
;;;1856   
;;;1857   	// Something !!!
;;;1858   #endif
;;;1859   	return;
;;;1860   }
;;;1861   
                          ENDP


                          AREA ||i.RecieveBulkCustomData_DMA||, CODE, READONLY, ALIGN=1

                  RecieveBulkCustomData_DMA PROC
;;;1809   // Host to Device
;;;1810   void RecieveBulkCustomData_DMA(void)
000000  4770              BX       lr
;;;1811   {
;;;1812   #ifndef MODE_I2C
;;;1813   #ifdef ADD_BULK_CUSTOM
;;;1814   	// Bulk Custom OUT
;;;1815   	mUsbEXDmaFinishClr(BULK_CUSTOM_FIFO_OUT);
;;;1816   	mUsbEXIntDmaErrDis(BULK_CUSTOM_FIFO_OUT);
;;;1817   	mUsbEXIntDmaFinishDis(BULK_CUSTOM_FIFO_OUT);
;;;1818   
;;;1819   	// Virtual DMA Mask - Bulk Custom OUT
;;;1820   	mUsbEXIntDmaErrEn(BULK_CUSTOM_FIFO_OUT);
;;;1821   	mUsbEXIntDmaFinishEn(BULK_CUSTOM_FIFO_OUT);
;;;1822   
;;;1823   	// Virtual DMA Start !!!!
;;;1824   	mUsbEXDmaConfig(BULK_CUSTOM_FIFO_OUT, MX_PA_SZ_64, DIRECTION_OUT);
;;;1825   	mUsbEXDmaAddr(BULK_CUSTOM_FIFO_OUT, (uint32_t)g_BulkCustomBuffer);
;;;1826   	mUsbEXDmaStart(BULK_CUSTOM_FIFO_OUT);
;;;1827   #endif
;;;1828   #endif
;;;1829   	return;
;;;1830   }
;;;1831   
                          ENDP


                          AREA ||i.RecieveCustomData||, CODE, READONLY, ALIGN=2

                  RecieveCustomData PROC
;;;966    // Host to Device
;;;967    void RecieveCustomData(uint8_t* pData)
000000  b570              PUSH     {r4-r6,lr}
;;;968    {
;;;969    	PHJ_HID_CONTROL_STRUCT  pHidControl = (PHJ_HID_CONTROL_STRUCT)pData;
;;;970    
;;;971    	switch (pHidControl->PacketID)
000002  7801              LDRB     r1,[r0,#0]
000004  2909              CMP      r1,#9
;;;972    	{
;;;973    		case HID_REPORT_ID__CUSTOM_OUT:
;;;974    		{
;;;975    			if (pHidControl->DeviceID_b.bRead)
;;;976    			{
;;;977    				HidReadWrite__Read(pHidControl);
;;;978    			}
;;;979    			else
;;;980    			{
;;;981    				HidReadWrite__Write((PHJ_HID_CONTROL_STRUCT)pData);
;;;982    			}
;;;983    
;;;984    			break;
;;;985    		}
;;;986    	}
;;;987    
;;;988    	return;
;;;989    }
000006  bf18              IT       NE
000008  bd70              POPNE    {r4-r6,pc}
00000a  7841              LDRB     r1,[r0,#1]            ;975
00000c  f0110f01          TST      r1,#1                 ;975
000010  d003              BEQ      |L17.26|
000012  e8bd4070          POP      {r4-r6,lr}            ;977
000016  f7ffbffe          B.W      HidReadWrite__Read
                  |L17.26|
00001a  4604              MOV      r4,r0                 ;981
00001c  7900              LDRB     r0,[r0,#4]            ;981
00001e  7961              LDRB     r1,[r4,#5]            ;981
000020  4e12              LDR      r6,|L17.108|
000022  ea412000          ORR      r0,r1,r0,LSL #8       ;981
000026  4910              LDR      r1,|L17.104|
000028  2500              MOVS     r5,#0                 ;981
00002a  6809              LDR      r1,[r1,#0]            ;981  ; protocol_GetMappedPointer
00002c  b131              CBZ      r1,|L17.60|
00002e  80b0              STRH     r0,[r6,#4]            ;981
000030  4788              BLX      r1                    ;981
000032  6230              STR      r0,[r6,#0x20]         ;981  ; rmi_write_ptr
000034  61f0              STR      r0,[r6,#0x1c]         ;981  ; rmi_read_ptr
000036  2000              MOVS     r0,#0                 ;981
000038  6270              STR      r0,[r6,#0x24]         ;981  ; protocol_sent_byte
00003a  62b0              STR      r0,[r6,#0x28]         ;981  ; protocol_received_byte
                  |L17.60|
00003c  8860              LDRH     r0,[r4,#2]            ;981
00003e  1e80              SUBS     r0,r0,#2              ;981
000040  2800              CMP      r0,#0                 ;981
000042  bfd8              IT       LE
000044  bd70              POPLE    {r4-r6,pc}
                  |L17.70|
000046  1960              ADDS     r0,r4,r5
000048  7981              LDRB     r1,[r0,#6]
00004a  6a30              LDR      r0,[r6,#0x20]  ; rmi_write_ptr
00004c  b128              CBZ      r0,|L17.90|
00004e  f8001b01          STRB     r1,[r0],#1
000052  6230              STR      r0,[r6,#0x20]  ; rmi_write_ptr
000054  6ab0              LDR      r0,[r6,#0x28]  ; protocol_received_byte
000056  1c40              ADDS     r0,r0,#1
000058  62b0              STR      r0,[r6,#0x28]  ; protocol_received_byte
                  |L17.90|
00005a  1c68              ADDS     r0,r5,#1
00005c  b285              UXTH     r5,r0
00005e  8860              LDRH     r0,[r4,#2]
000060  1e80              SUBS     r0,r0,#2
000062  42a8              CMP      r0,r5
000064  dcef              BGT      |L17.70|
000066  bd70              POP      {r4-r6,pc}
;;;990    
                          ENDP

                  |L17.104|
                          DCD      protocol_GetMappedPointer
                  |L17.108|
                          DCD      ||.data||

                          AREA ||i.RecieveCustomData_DMA||, CODE, READONLY, ALIGN=1

                  RecieveCustomData_DMA PROC
;;;796    
;;;797    void RecieveCustomData_DMA(void)
000000  4770              BX       lr
;;;798    {
;;;799    #ifndef MODE_I2C
;;;800    #ifdef ADD_CUSTOM
;;;801    	// Custom OUT
;;;802    	mUsbEXDmaFinishClr(CUSTOM_FIFO_OUT);
;;;803    	mUsbEXIntDmaErrDis(CUSTOM_FIFO_OUT);
;;;804    	mUsbEXIntDmaFinishDis(CUSTOM_FIFO_OUT);
;;;805    
;;;806    	// Virtual DMA Mask - Custom OUT
;;;807    	mUsbEXIntDmaErrEn(CUSTOM_FIFO_OUT);
;;;808    	mUsbEXIntDmaFinishEn(CUSTOM_FIFO_OUT);
;;;809    
;;;810    	// Virtual DMA Start !!!!
;;;811    	mUsbEXDmaConfig(CUSTOM_FIFO_OUT, MX_PA_SZ_64, DIRECTION_OUT);
;;;812    	mUsbEXDmaAddr(CUSTOM_FIFO_OUT, (uint32_t)g_CustomBuffer);
;;;813    	mUsbEXDmaStart(CUSTOM_FIFO_OUT);
;;;814    #endif
;;;815    #endif
;;;816    	return;
;;;817    }
;;;818    
                          ENDP


                          AREA ||i.ResumeSigal||, CODE, READONLY, ALIGN=1

                  ResumeSigal PROC
;;;268    
;;;269    void ResumeSigal(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;270    {
;;;271    	mUsbRemoteWakeUpSet_1();
000004  f8101fa4          LDRB     r1,[r0,#0xa4]!
000008  f0410102          ORR      r1,r1,#2
00000c  7001              STRB     r1,[r0,#0]
;;;272    }
00000e  4770              BX       lr
;;;273    
                          ENDP


                          AREA ||i.SendCustomData_USB||, CODE, READONLY, ALIGN=2

                  SendCustomData_USB PROC
;;;765    
;;;766    void SendCustomData_USB(uint8_t* pUserData)
000000  4917              LDR      r1,|L20.96|
;;;767    {
000002  b510              PUSH     {r4,lr}
000004  f8d117c2          LDR      r1,[r1,#0x7c2]
000008  291e              CMP      r1,#0x1e
00000a  d304              BCC      |L20.22|
00000c  4815              LDR      r0,|L20.100|
00000e  6981              LDR      r1,[r0,#0x18]  ; g_Full
000010  1c49              ADDS     r1,r1,#1
000012  6181              STR      r1,[r0,#0x18]  ; g_Full
;;;768    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
;;;769    	{
;;;770    		goto SENDCUSTOMDATA_USB__GOTO_END;
;;;771    	}
;;;772    
;;;773    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
;;;774    
;;;775    SENDCUSTOMDATA_USB__GOTO_END:
;;;776    
;;;777    	return;
;;;778    }
000014  bd10              POP      {r4,pc}
                  |L20.22|
000016  4c12              LDR      r4,|L20.96|
000018  0001              MOVS     r1,r0                 ;773
00001a  bf08              IT       EQ
00001c  bd10              POPEQ    {r4,pc}
00001e  2001              MOVS     r0,#1
000020  f88407c6          STRB     r0,[r4,#0x7c6]
000024  f89407c0          LDRB     r0,[r4,#0x7c0]
000028  2242              MOVS     r2,#0x42
00002a  eb001040          ADD      r0,r0,r0,LSL #5
00002e  eb040040          ADD      r0,r4,r0,LSL #1
000032  1d00              ADDS     r0,r0,#4
000034  f7fffffe          BL       __aeabi_memcpy
000038  f8d407c2          LDR      r0,[r4,#0x7c2]
00003c  2100              MOVS     r1,#0
00003e  1c40              ADDS     r0,r0,#1
000040  f8c407c2          STR      r0,[r4,#0x7c2]
000044  f89407c0          LDRB     r0,[r4,#0x7c0]
000048  1c40              ADDS     r0,r0,#1
00004a  b2c0              UXTB     r0,r0
00004c  f88407c0          STRB     r0,[r4,#0x7c0]
000050  281e              CMP      r0,#0x1e
000052  bf28              IT       CS
000054  f88417c0          STRBCS   r1,[r4,#0x7c0]
000058  f88417c6          STRB     r1,[r4,#0x7c6]
00005c  bd10              POP      {r4,pc}
;;;779    
                          ENDP

00005e  0000              DCW      0x0000
                  |L20.96|
                          DCD      ||area_number.37||+0xac
                  |L20.100|
                          DCD      ||.data||

                          AREA ||i.SendTouchData||, CODE, READONLY, ALIGN=2

                  SendTouchData PROC
;;;574    
;;;575    void SendTouchData(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;576    {
000004  b091              SUB      sp,sp,#0x44
;;;577    	uint8_t				i = 0;
;;;578    	uint8_t				ContactCount = 0;
000006  2600              MOVS     r6,#0
;;;579    	uint8_t				TouchDownCount = 0;
000008  4637              MOV      r7,r6
;;;580    	HID_MULTITOUCH_I2C	TouchData_I2C = { 0, };
00000a  2144              MOVS     r1,#0x44
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;581    	PHID_MULTITOUCH		TouchData = &TouchData_I2C.Data;
000012  f10d0502          ADD      r5,sp,#2
;;;582    
;;;583    	if (module_Skip_Event())
000016  f7fffffe          BL       module_Skip_Event
00001a  2800              CMP      r0,#0
;;;584    	{
;;;585    		goto SENDTOUCHDATA__GOTO_END;
;;;586    	}
;;;587    
;;;588    	TouchData->ReportID = HID_REPORT_ID__MULTI_TOUCH;
;;;589    
;;;590    	for (i = 0; i < HID_MAX_TOUCH; i++)
;;;591    	{
;;;592    		if (HID_id[i] != 0)
;;;593    		{
;;;594    #if (ID_MAPPING_CHANGE)
;;;595    			ContactCount += 1;
;;;596    #else
;;;597    			if (g_TouchTip[HID_id[i]] != HID_status[i]) // It may be deleted on Current F/W... 200730, HanCH
;;;598    			{
;;;599    				g_TouchTip[HID_id[i]] = HID_status[i];
;;;600    				ContactCount += 1;
;;;601    			}
;;;602    			else
;;;603    			{
;;;604    				if (HID_status[i] == FINGER_STATUS__TIP_SWITCH)
;;;605    				{
;;;606    					ContactCount += 1;
;;;607    				}
;;;608    			}
;;;609    #endif
;;;610    			// ScanTime / Touch Down
;;;611    			if (HID_status[i] == FINGER_STATUS__TIP_SWITCH)
;;;612    			{
;;;613    				TouchDownCount += 1;
;;;614    			}
;;;615    		}
;;;616    
;;;617    		TouchData->Touch[i].Status = HID_status[i];
;;;618    		TouchData->Touch[i].ID = HID_id[i];
;;;619    		TouchData->Touch[i].x = HID_x[i];
;;;620    		TouchData->Touch[i].y = HID_y[i];
;;;621    	}
;;;622    
;;;623    
;;;624    	for (i = 0; i < HID_MAX_TOUCH; i++)
;;;625    	{
;;;626    		HID_status[i] = 0;
;;;627    		HID_id[i] = 0;
;;;628    		HID_x[i] = 0;
;;;629    		HID_y[i] = 0;
;;;630    	}
;;;631    
;;;632    	
;;;633    	if (ContactCount)
;;;634    	{
;;;635    		TouchData->ContactCount = ContactCount;
;;;636    		TouchData->ScanTime = GetScanTime(&g_StartTime, &g_ScanTime);
;;;637    
;;;638    		// ScanTime Init
;;;639    		if (TouchDownCount == 0)
;;;640    		{
;;;641    			g_ScanTime = 0;
;;;642    			g_StartTime = 0;
;;;643    		}
;;;644    	}
;;;645    
;;;646    #ifndef MODE_I2C
;;;647    #ifdef USB_SELECTIVE_SUSPEND
;;;648    //	if (g_RemoteWakeup == 0)
;;;649    //	{
;;;650    //		g_ScanTime_Recovery = 0;
;;;651    //		g_StartTime_Recovery = 0;
;;;652    //	}
;;;653    
;;;654    			
;;;655    	//for (i = 0; i < HID_MAX_TOUCH; i++)
;;;656    	{
;;;657    		//if (TouchData->Touch[i].Status != 0)
;;;658    		{
;;;659    			if (g_RemoteWakeup == 1)// || g_Status[0].Status.Global.RemoteWakeup == 1)
;;;660    			{
;;;661    				if (ContactCount)
;;;662    				{
;;;663    					ResumeSigal();
;;;664    					SendTouchData_USB(TouchData);
;;;665    					if(g_StartTime_Recovery == 0)
;;;666    					{
;;;667    						GetScanTime(&g_StartTime_Recovery, &g_ScanTime_Recovery);
;;;668    					}
;;;669    				}
;;;670    				
;;;671    				if(g_StartTime_Recovery > 0)
;;;672    				{
;;;673    					if (GetScanTime(&g_StartTime_Recovery, &g_ScanTime_Recovery) >= 20000)
;;;674    					{
;;;675    						g_RemoteWakeup = 0;
;;;676    						g_Status[0].Status.Global.RemoteWakeup = 0;
;;;677    						g_ScanTime_Recovery = 0;
;;;678    						g_StartTime_Recovery = 0;
;;;679    						ResumeCnt = 0;
;;;680    						
;;;681    						// H/W Reset !!
;;;682    						module_Protocol_Init();
;;;683    						while(1);
;;;684    					}
;;;685    				}
;;;686    			}
;;;687    #if (CUSTOMER == NEC)
;;;688    			else if(g_Status[0].Status.Global.RemoteWakeup == 1 && Recovery_ClearSus_Flag == 1)
;;;689    			{
;;;690    				if(ResumeCnt==5)
;;;691    				{
;;;692    					while(1);
;;;693    				}
;;;694    				else if(GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus )> 200 && ResumeCnt < 5) 
;;;695    				{
;;;696    					mUsbGoSuspend();						
;;;697    					g_RemoteWakeup = 1;	
;;;698    					ResumeSigal();
;;;699    					ResumeCnt++;
;;;700    					g_StartTime_Recovery_ClearSus = g_ScanTime_Recovery_ClearSus =0;
;;;701    					Recovery_ClearSus_Flag = 0;
;;;702    				}
;;;703    			}
;;;704    #endif				
;;;705    		}
;;;706    	}
;;;707    #endif
;;;708    #endif
;;;709    
;;;710    	
;;;711    
;;;712    	// USB
;;;713    	if (ContactCount 
;;;714    #ifndef MODE_I2C
;;;715    		&& g_RemoteWakeup==0
;;;716    #endif
;;;717    	)
;;;718    	{
;;;719    		if ((CheckUsbConfig() != 0) && (CheckHIDReady() != 0))
;;;720    		{
;;;721    			SendTouchData_USB(TouchData);
;;;722    		}
;;;723    #ifdef MODE_I2C
;;;724    		// I2C
;;;725    		//else if (CheckI2CReady() != 0 && (custom_tool == 0))
;;;726    		{
;;;727    			TouchData_I2C.I2C_Length = sizeof(HID_MULTITOUCH_I2C);
;;;728    			SendTouchData_I2C(&TouchData_I2C);
;;;729    		}
;;;730    #endif
;;;731    	}
;;;732    
;;;733    SENDTOUCHDATA__GOTO_END:
;;;734    
;;;735    	return;
;;;736    }
00001c  bf1c              ITT      NE
00001e  b011              ADDNE    sp,sp,#0x44
000020  e8bd8ff0          POPNE    {r4-r11,pc}
000024  2010              MOVS     r0,#0x10              ;588
000026  f88d0002          STRB     r0,[sp,#2]            ;588
00002a  4880              LDR      r0,|L21.556|
00002c  2200              MOVS     r2,#0                 ;590
00002e  f1000178          ADD      r1,r0,#0x78           ;590
000032  f1000c28          ADD      r12,r0,#0x28          ;590
000036  f1000350          ADD      r3,r0,#0x50           ;590
00003a  f04f080a          MOV      r8,#0xa               ;590
00003e  f1a00a0c          SUB      r10,r0,#0xc           ;597
000042  bf00              NOP                            ;592
                  |L21.68|
000044  f8d09000          LDR      r9,[r0,#0]            ;592
000048  f1b90f00          CMP      r9,#0                 ;592
00004c  d013              BEQ      |L21.118|
00004e  f81ab009          LDRB     r11,[r10,r9]          ;597
000052  680c              LDR      r4,[r1,#0]            ;597
000054  45a3              CMP      r11,r4                ;597
000056  d007              BEQ      |L21.104|
000058  f80a4009          STRB     r4,[r10,r9]           ;599
00005c  1c74              ADDS     r4,r6,#1              ;600
00005e  b2e6              UXTB     r6,r4                 ;600
000060  680c              LDR      r4,[r1,#0]            ;611
000062  2c01              CMP      r4,#1                 ;611
000064  d005              BEQ      |L21.114|
000066  e006              B        |L21.118|
                  |L21.104|
000068  2c01              CMP      r4,#1                 ;604
00006a  bf04              ITT      EQ                    ;606
00006c  1c74              ADDEQ    r4,r6,#1              ;606
00006e  b2e6              UXTBEQ   r6,r4                 ;606
000070  d101              BNE      |L21.118|
                  |L21.114|
000072  1c7c              ADDS     r4,r7,#1              ;613
000074  b2e7              UXTB     r7,r4                 ;613
                  |L21.118|
000076  eb020442          ADD      r4,r2,r2,LSL #1       ;617
00007a  eb050444          ADD      r4,r5,r4,LSL #1       ;617
00007e  f8119b04          LDRB     r9,[r1],#4            ;617
000082  f8849001          STRB     r9,[r4,#1]            ;617
000086  f8109b04          LDRB     r9,[r0],#4            ;618
00008a  f8849002          STRB     r9,[r4,#2]            ;618
00008e  f83c9b04          LDRH     r9,[r12],#4           ;619
000092  f8a49003          STRH     r9,[r4,#3]            ;619
000096  f8339b04          LDRH     r9,[r3],#4            ;620
00009a  1c52              ADDS     r2,r2,#1              ;620
00009c  f8a49005          STRH     r9,[r4,#5]            ;620
0000a0  f1b80801          SUBS     r8,r8,#1              ;620
0000a4  d1ce              BNE      |L21.68|
0000a6  4862              LDR      r0,|L21.560|
0000a8  2400              MOVS     r4,#0                 ;624
0000aa  2e00              CMP      r6,#0                 ;633
0000ac  f8c04084          STR      r4,[r0,#0x84]         ;624  ; HID_status
0000b0  f8c04088          STR      r4,[r0,#0x88]         ;624  ; HID_status
0000b4  f8c0408c          STR      r4,[r0,#0x8c]         ;624  ; HID_status
0000b8  f8c04090          STR      r4,[r0,#0x90]         ;624  ; HID_status
0000bc  f8c04094          STR      r4,[r0,#0x94]         ;624  ; HID_status
0000c0  f8c04098          STR      r4,[r0,#0x98]         ;624  ; HID_status
0000c4  f8c0409c          STR      r4,[r0,#0x9c]         ;624  ; HID_status
0000c8  f8c040a0          STR      r4,[r0,#0xa0]         ;624  ; HID_status
0000cc  f8c040a4          STR      r4,[r0,#0xa4]         ;624  ; HID_status
0000d0  f8c040a8          STR      r4,[r0,#0xa8]         ;624  ; HID_status
0000d4  60c4              STR      r4,[r0,#0xc]          ;624  ; HID_id
0000d6  6104              STR      r4,[r0,#0x10]         ;624  ; HID_id
0000d8  6144              STR      r4,[r0,#0x14]         ;624  ; HID_id
0000da  6184              STR      r4,[r0,#0x18]         ;624  ; HID_id
0000dc  61c4              STR      r4,[r0,#0x1c]         ;624  ; HID_id
0000de  6204              STR      r4,[r0,#0x20]         ;624  ; HID_id
0000e0  6244              STR      r4,[r0,#0x24]         ;624  ; HID_id
0000e2  6284              STR      r4,[r0,#0x28]         ;624  ; HID_id
0000e4  62c4              STR      r4,[r0,#0x2c]         ;624  ; HID_id
0000e6  6304              STR      r4,[r0,#0x30]         ;624  ; HID_id
0000e8  6344              STR      r4,[r0,#0x34]         ;624  ; HID_x
0000ea  6384              STR      r4,[r0,#0x38]         ;624  ; HID_x
0000ec  63c4              STR      r4,[r0,#0x3c]         ;624  ; HID_x
0000ee  6404              STR      r4,[r0,#0x40]         ;624  ; HID_x
0000f0  6444              STR      r4,[r0,#0x44]         ;624  ; HID_x
0000f2  6484              STR      r4,[r0,#0x48]         ;624  ; HID_x
0000f4  64c4              STR      r4,[r0,#0x4c]         ;624  ; HID_x
0000f6  6504              STR      r4,[r0,#0x50]         ;624  ; HID_x
0000f8  6544              STR      r4,[r0,#0x54]         ;624  ; HID_x
0000fa  6584              STR      r4,[r0,#0x58]         ;624  ; HID_x
0000fc  65c4              STR      r4,[r0,#0x5c]         ;624  ; HID_y
0000fe  6604              STR      r4,[r0,#0x60]         ;624  ; HID_y
000100  6644              STR      r4,[r0,#0x64]         ;624  ; HID_y
000102  6684              STR      r4,[r0,#0x68]         ;624  ; HID_y
000104  66c4              STR      r4,[r0,#0x6c]         ;624  ; HID_y
000106  6704              STR      r4,[r0,#0x70]         ;624  ; HID_y
000108  6744              STR      r4,[r0,#0x74]         ;624  ; HID_y
00010a  6784              STR      r4,[r0,#0x78]         ;624  ; HID_y
00010c  67c4              STR      r4,[r0,#0x7c]         ;624  ; HID_y
00010e  f8c04080          STR      r4,[r0,#0x80]         ;633  ; HID_y
000112  bf04              ITT      EQ
000114  b011              ADDEQ    sp,sp,#0x44
000116  e8bd8ff0          POPEQ    {r4-r11,pc}
00011a  f885603d          STRB     r6,[r5,#0x3d]         ;635
00011e  4e45              LDR      r6,|L21.564|
000120  f1a60930          SUB      r9,r6,#0x30           ;635
000124  e9d60100          LDRD     r0,r1,[r6,#0]         ;635
000128  ea500201          ORRS     r2,r0,r1              ;635
00012c  d010              BEQ      |L21.336|
00012e  f7fffffe          BL       getElapsedLongSYSTICK
000132  4a41              LDR      r2,|L21.568|
000134  6812              LDR      r2,[r2,#0]            ;636  ; _timer_clock_
000136  4623              MOV      r3,r4                 ;636
000138  f7fffffe          BL       __aeabi_uldivmod
00013c  2264              MOVS     r2,#0x64              ;636
00013e  2300              MOVS     r3,#0                 ;636
000140  f7fffffe          BL       __aeabi_uldivmod
000144  f8d91000          LDR      r1,[r9,#0]            ;636
000148  b280              UXTH     r0,r0                 ;636
00014a  4408              ADD      r0,r0,r1              ;636
00014c  f8c90000          STR      r0,[r9,#0]            ;636
                  |L21.336|
000150  483a              LDR      r0,|L21.572|
000152  6800              LDR      r0,[r0,#0]            ;636  ; _timertick_high_rank_count_
000154  03a2              LSLS     r2,r4,#14             ;636
000156  ea424190          ORR      r1,r2,r0,LSR #18      ;636
00015a  0382              LSLS     r2,r0,#14             ;636
00015c  f04f4080          MOV      r0,#0x40000000        ;636
000160  46a0              MOV      r8,r4                 ;636
000162  f8d001b8          LDR      r0,[r0,#0x1b8]        ;636
000166  ea410108          ORR      r1,r1,r8              ;636
00016a  f3c0000d          UBFX     r0,r0,#0,#14          ;636
00016e  4310              ORRS     r0,r0,r2              ;636
000170  e9c60100          STRD     r0,r1,[r6,#0]         ;636
000174  f8b90000          LDRH     r0,[r9,#0]            ;636
000178  87e8              STRH     r0,[r5,#0x3e]         ;636
00017a  4831              LDR      r0,|L21.576|
00017c  b927              CBNZ     r7,|L21.392|
00017e  2200              MOVS     r2,#0                 ;641
000180  f8c08008          STR      r8,[r0,#8]            ;641  ; g_ScanTime
000184  e9c0220e          STRD     r2,r2,[r0,#0x38]      ;641
                  |L21.392|
000188  7801              LDRB     r1,[r0,#0]            ;641  ; g_Configuration
00018a  2900              CMP      r1,#0                 ;719
00018c  bf1c              ITT      NE                    ;719
00018e  7841              LDRBNE   r1,[r0,#1]            ;719  ; g_HIDReady
000190  2900              CMPNE    r1,#0                 ;719
000192  d042              BEQ      |L21.538|
000194  4a2b              LDR      r2,|L21.580|
000196  4629              MOV      r1,r5                 ;721
000198  f8d237c2          LDR      r3,[r2,#0x7c2]        ;721
00019c  f04f0201          MOV      r2,#1                 ;597
0001a0  2b1e              CMP      r3,#0x1e              ;597
0001a2  d316              BCC      |L21.466|
0001a4  6983              LDR      r3,[r0,#0x18]         ;721  ; g_Full
0001a6  1c5b              ADDS     r3,r3,#1              ;721
0001a8  6183              STR      r3,[r0,#0x18]         ;721  ; g_Full
0001aa  4826              LDR      r0,|L21.580|
0001ac  f88027c6          STRB     r2,[r0,#0x7c6]        ;721
0001b0  f8d037c2          LDR      r3,[r0,#0x7c2]        ;721
0001b4  1e5b              SUBS     r3,r3,#1              ;721
0001b6  f8c037c2          STR      r3,[r0,#0x7c2]        ;721
0001ba  f89037c1          LDRB     r3,[r0,#0x7c1]        ;721
0001be  1c5b              ADDS     r3,r3,#1              ;721
0001c0  b2db              UXTB     r3,r3                 ;721
0001c2  f88037c1          STRB     r3,[r0,#0x7c1]        ;721
0001c6  2b1e              CMP      r3,#0x1e              ;721
0001c8  bf28              IT       CS                    ;721
0001ca  f88087c1          STRBCS   r8,[r0,#0x7c1]        ;721
0001ce  f88087c6          STRB     r8,[r0,#0x7c6]        ;721
                  |L21.466|
0001d2  4c1c              LDR      r4,|L21.580|
0001d4  2900              CMP      r1,#0                 ;721
0001d6  bf1c              ITT      NE                    ;721
0001d8  f8d407c2          LDRNE    r0,[r4,#0x7c2]        ;721
0001dc  281e              CMPNE    r0,#0x1e              ;721
0001de  d21c              BCS      |L21.538|
0001e0  f88427c6          STRB     r2,[r4,#0x7c6]        ;721
0001e4  f89407c0          LDRB     r0,[r4,#0x7c0]        ;721
0001e8  2242              MOVS     r2,#0x42              ;721
0001ea  eb001040          ADD      r0,r0,r0,LSL #5       ;721
0001ee  eb040040          ADD      r0,r4,r0,LSL #1       ;721
0001f2  1d00              ADDS     r0,r0,#4              ;721
0001f4  f7fffffe          BL       __aeabi_memcpy
0001f8  f8d407c2          LDR      r0,[r4,#0x7c2]        ;721
0001fc  1c40              ADDS     r0,r0,#1              ;721
0001fe  f8c407c2          STR      r0,[r4,#0x7c2]        ;721
000202  f89407c0          LDRB     r0,[r4,#0x7c0]        ;721
000206  1c40              ADDS     r0,r0,#1              ;721
000208  b2c0              UXTB     r0,r0                 ;721
00020a  f88407c0          STRB     r0,[r4,#0x7c0]        ;721
00020e  281e              CMP      r0,#0x1e              ;721
000210  bf28              IT       CS                    ;721
000212  f88487c0          STRBCS   r8,[r4,#0x7c0]        ;721
000216  f88487c6          STRB     r8,[r4,#0x7c6]        ;721
                  |L21.538|
00021a  2042              MOVS     r0,#0x42              ;727
00021c  f8ad0000          STRH     r0,[sp,#0]            ;727
000220  4668              MOV      r0,sp                 ;728
000222  f7fffffe          BL       SendTouchData_I2C
000226  b011              ADD      sp,sp,#0x44
000228  e8bd8ff0          POP      {r4-r11,pc}
;;;737    
                          ENDP

                  |L21.556|
                          DCD      ||area_number.37||+0xc
                  |L21.560|
                          DCD      ||area_number.37||
                  |L21.564|
                          DCD      ||.data||+0x38
                  |L21.568|
                          DCD      _timer_clock_
                  |L21.572|
                          DCD      _timertick_high_rank_count_
                  |L21.576|
                          DCD      ||.data||
                  |L21.580|
                          DCD      ||area_number.37||+0xac

                          AREA ||i.SendTouchData_USB||, CODE, READONLY, ALIGN=2

                  SendTouchData_USB PROC
;;;540    
;;;541    void SendTouchData_USB(PHID_MULTITOUCH pUserData)
000000  b570              PUSH     {r4-r6,lr}
;;;542    {
;;;543    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
000002  4923              LDR      r1,|L22.144|
000004  2301              MOVS     r3,#1
000006  2500              MOVS     r5,#0
000008  f8d117c2          LDR      r1,[r1,#0x7c2]
00000c  291e              CMP      r1,#0x1e
00000e  d317              BCC      |L22.64|
000010  4920              LDR      r1,|L22.148|
000012  698a              LDR      r2,[r1,#0x18]         ;542  ; g_Full
000014  1c52              ADDS     r2,r2,#1              ;542
;;;544    	{
;;;545    		StaticQueue_HeadDelete(&g_Queue_Common);
000016  618a              STR      r2,[r1,#0x18]  ; g_Full
000018  4a1d              LDR      r2,|L22.144|
00001a  f88237c6          STRB     r3,[r2,#0x7c6]
00001e  f8d217c2          LDR      r1,[r2,#0x7c2]
000022  1e49              SUBS     r1,r1,#1
000024  f8c217c2          STR      r1,[r2,#0x7c2]
000028  f89217c1          LDRB     r1,[r2,#0x7c1]
00002c  1c49              ADDS     r1,r1,#1
00002e  b2c9              UXTB     r1,r1
000030  f88217c1          STRB     r1,[r2,#0x7c1]
000034  291e              CMP      r1,#0x1e
000036  bf28              IT       CS
000038  f88257c1          STRBCS   r5,[r2,#0x7c1]
00003c  f88257c6          STRB     r5,[r2,#0x7c6]
                  |L22.64|
;;;546    	}
;;;547    
;;;548    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
000040  4c13              LDR      r4,|L22.144|
000042  0001              MOVS     r1,r0
;;;549    
;;;550    //SENDTOUCHDATA_USB__GOTO_END:
;;;551    
;;;552    	return;
;;;553    }
000044  bf08              IT       EQ
000046  bd70              POPEQ    {r4-r6,pc}
000048  f8d407c2          LDR      r0,[r4,#0x7c2]
00004c  281e              CMP      r0,#0x1e
00004e  bf28              IT       CS
000050  bd70              POPCS    {r4-r6,pc}
000052  f88437c6          STRB     r3,[r4,#0x7c6]
000056  f89407c0          LDRB     r0,[r4,#0x7c0]
00005a  2242              MOVS     r2,#0x42
00005c  eb001040          ADD      r0,r0,r0,LSL #5
000060  eb040040          ADD      r0,r4,r0,LSL #1
000064  1d00              ADDS     r0,r0,#4
000066  f7fffffe          BL       __aeabi_memcpy
00006a  f8d407c2          LDR      r0,[r4,#0x7c2]
00006e  1c40              ADDS     r0,r0,#1
000070  f8c407c2          STR      r0,[r4,#0x7c2]
000074  f89407c0          LDRB     r0,[r4,#0x7c0]
000078  1c40              ADDS     r0,r0,#1
00007a  b2c0              UXTB     r0,r0
00007c  f88407c0          STRB     r0,[r4,#0x7c0]
000080  281e              CMP      r0,#0x1e
000082  bf28              IT       CS
000084  f88457c0          STRBCS   r5,[r4,#0x7c0]
000088  f88457c6          STRB     r5,[r4,#0x7c6]
00008c  bd70              POP      {r4-r6,pc}
;;;554    
                          ENDP

00008e  0000              DCW      0x0000
                  |L22.144|
                          DCD      ||area_number.37||+0xac
                  |L22.148|
                          DCD      ||.data||

                          AREA ||i.StaticQueue_CheckEmpty||, CODE, READONLY, ALIGN=1

                  StaticQueue_CheckEmpty PROC
;;;491    
;;;492    uint8_t StaticQueue_CheckEmpty(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;493    {
000002  b120              CBZ      r0,|L23.14|
;;;494    	uint8_t nRet = 0;
;;;495    
;;;496    	if (pQueue == NULL)
;;;497    	{
;;;498    		goto STATICQUEUE_CHECKEMPTY__GOTO_END;
;;;499    	}
;;;500    
;;;501    	//EnterCriticalSection(&g_cs);
;;;502    	if (pQueue->Count <= 0)
000004  f8d007c2          LDR      r0,[r0,#0x7c2]
000008  2800              CMP      r0,#0
;;;503    	{
;;;504    		nRet = 1;
00000a  bf08              IT       EQ
00000c  2101              MOVEQ    r1,#1
                  |L23.14|
;;;505    	}
;;;506    	//LeaveCriticalSection(&g_cs);
;;;507    
;;;508    STATICQUEUE_CHECKEMPTY__GOTO_END:
;;;509    
;;;510    	return nRet;
00000e  4608              MOV      r0,r1
;;;511    }
000010  4770              BX       lr
;;;512    
                          ENDP


                          AREA ||i.StaticQueue_CheckFull||, CODE, READONLY, ALIGN=2

                  StaticQueue_CheckFull PROC
;;;468    
;;;469    uint8_t StaticQueue_CheckFull(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;470    {
000002  b140              CBZ      r0,|L24.22|
;;;471    	uint8_t nRet = 0;
;;;472    
;;;473    	if (pQueue == NULL)
;;;474    	{
;;;475    		goto STATICQUEUE_CHECKFULL__GOTO_END;
;;;476    	}
;;;477    
;;;478    	//EnterCriticalSection(&g_cs);
;;;479    	if (pQueue->Count >= QUEUE_MAX_COUNT__COMMON)
000004  f8d007c2          LDR      r0,[r0,#0x7c2]
000008  281e              CMP      r0,#0x1e
00000a  d304              BCC      |L24.22|
;;;480    	{
;;;481    		g_Full += 1;
00000c  4803              LDR      r0,|L24.28|
00000e  6981              LDR      r1,[r0,#0x18]  ; g_Full
000010  1c49              ADDS     r1,r1,#1
;;;482    		nRet = 1;
000012  6181              STR      r1,[r0,#0x18]  ; g_Full
000014  2101              MOVS     r1,#1
                  |L24.22|
;;;483    	}
;;;484    	//LeaveCriticalSection(&g_cs);
;;;485    
;;;486    STATICQUEUE_CHECKFULL__GOTO_END:
;;;487    
;;;488    	return nRet;
000016  4608              MOV      r0,r1
;;;489    }
000018  4770              BX       lr
;;;490    
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      ||.data||

                          AREA ||i.StaticQueue_CheckInit||, CODE, READONLY, ALIGN=1

                  StaticQueue_CheckInit PROC
;;;310    
;;;311    uint8_t StaticQueue_CheckInit(PSTATIC_QUEUE pQueue)
000000  2101              MOVS     r1,#1
;;;312    {
000002  b138              CBZ      r0,|L25.20|
;;;313    	uint8_t	nRet = 1;
;;;314    	uint8_t*	pCompare = (uint8_t*)QUEUE_SIGNATURE;
;;;315    	uint8_t	i = 0;
;;;316    
;;;317    	if (pQueue == NULL)
;;;318    	{
;;;319    		goto  STATICQUEUE_CHECKINIT__GOTO_END;
;;;320    	}
;;;321    
;;;322    	for (i = 0; i < 4; i++)
;;;323    	{
;;;324    		if (pQueue->Signature[i] != pCompare[i])
000004  7802              LDRB     r2,[r0,#0]
000006  2a53              CMP      r2,#0x53
000008  bf04              ITT      EQ
00000a  7842              LDRBEQ   r2,[r0,#1]
00000c  2a49              CMPEQ    r2,#0x49
00000e  d003              BEQ      |L25.24|
                  |L25.16|
;;;325    		{
;;;326    			nRet = 0;
000010  f04f0100          MOV      r1,#0
                  |L25.20|
;;;327    			break;
;;;328    		}
;;;329    	}
;;;330    
;;;331    STATICQUEUE_CHECKINIT__GOTO_END:
;;;332    
;;;333    	return nRet;
000014  4608              MOV      r0,r1
;;;334    }
000016  4770              BX       lr
                  |L25.24|
000018  7882              LDRB     r2,[r0,#2]            ;324
00001a  2a57              CMP      r2,#0x57              ;324
00001c  bf04              ITT      EQ                    ;324
00001e  78c0              LDRBEQ   r0,[r0,#3]            ;324
000020  2834              CMPEQ    r0,#0x34              ;324
000022  d1f5              BNE      |L25.16|
000024  e7f6              B        |L25.20|
;;;335    
                          ENDP


                          AREA ||i.StaticQueue_Get||, CODE, READONLY, ALIGN=1

                  StaticQueue_Get PROC
;;;443    
;;;444    uint8_t* StaticQueue_Get(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;445    {
;;;446    	uint8_t* pRet = 0;
;;;447    
;;;448    	if (pQueue == NULL)
000002  2800              CMP      r0,#0
;;;449    	{
;;;450    		goto STATICQUEUE_GET__GOTO_END;
;;;451    	}
;;;452    
;;;453    	// Empty
;;;454    	if (pQueue->Count <= 0)
000004  bf1c              ITT      NE
000006  f8d027c2          LDRNE    r2,[r0,#0x7c2]
00000a  2a00              CMPNE    r2,#0
00000c  d007              BEQ      |L26.30|
;;;455    	{
;;;456    		goto STATICQUEUE_GET__GOTO_END;
;;;457    	}
;;;458    
;;;459    	pRet = &pQueue->Buffer[pQueue->PopPoint * QUEUE_BLOCK_SIZE];
00000e  f89017c1          LDRB     r1,[r0,#0x7c1]
000012  eb011141          ADD      r1,r1,r1,LSL #5
000016  eb000041          ADD      r0,r0,r1,LSL #1
00001a  f1000104          ADD      r1,r0,#4
                  |L26.30|
;;;460    
;;;461    STATICQUEUE_GET__GOTO_END:
;;;462    
;;;463    	return pRet;
00001e  4608              MOV      r0,r1
;;;464    }
000020  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.StaticQueue_HeadDelete||, CODE, READONLY, ALIGN=1

                  StaticQueue_HeadDelete PROC
;;;405    
;;;406    uint8_t StaticQueue_HeadDelete(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;407    {
;;;408    	uint8_t nRet = 0;
;;;409    
;;;410    	if (pQueue == NULL)
000002  2800              CMP      r0,#0
;;;411    	{
;;;412    		goto STATICQUEUE_POP__GOTO_END;
;;;413    	}
;;;414    
;;;415    	//EnterCriticalSection(&g_cs);
;;;416    
;;;417    	// Empty
;;;418    	if (pQueue->Count <= 0)
000004  bf1c              ITT      NE
000006  f8d027c2          LDRNE    r2,[r0,#0x7c2]
00000a  2a00              CMPNE    r2,#0
00000c  d017              BEQ      |L27.62|
;;;419    	{
;;;420    		goto STATICQUEUE_POP__GOTO_END;
;;;421    	}
;;;422    
;;;423        pQueue->Doing = TRUE;
00000e  f04f0101          MOV      r1,#1
000012  f88017c6          STRB     r1,[r0,#0x7c6]
;;;424    
;;;425    	pQueue->Count -= 1;
000016  f1a20101          SUB      r1,r2,#1
00001a  f8c017c2          STR      r1,[r0,#0x7c2]
;;;426    	pQueue->PopPoint += 1;
00001e  f89017c1          LDRB     r1,[r0,#0x7c1]
000022  f04f0200          MOV      r2,#0
000026  f1010101          ADD      r1,r1,#1
00002a  b2c9              UXTB     r1,r1
00002c  f88017c1          STRB     r1,[r0,#0x7c1]
;;;427    	if (pQueue->PopPoint >= QUEUE_MAX_COUNT__COMMON)
000030  291e              CMP      r1,#0x1e
;;;428    	{
;;;429    		pQueue->PopPoint = 0;
000032  bf28              IT       CS
000034  f88027c1          STRBCS   r2,[r0,#0x7c1]
;;;430    	}
;;;431    
;;;432    	nRet = 1;
000038  2101              MOVS     r1,#1
;;;433    
;;;434        pQueue->Doing = FALSE;
00003a  f88027c6          STRB     r2,[r0,#0x7c6]
                  |L27.62|
;;;435    
;;;436    STATICQUEUE_POP__GOTO_END:
;;;437    
;;;438    	//LeaveCriticalSection(&g_cs);
;;;439    	return nRet;
00003e  4608              MOV      r0,r1
;;;440    }
000040  4770              BX       lr
;;;441    
                          ENDP


                          AREA ||i.StaticQueue_Init||, CODE, READONLY, ALIGN=2

                  StaticQueue_Init PROC
;;;286    
;;;287    uint8_t StaticQueue_Init(PSTATIC_QUEUE pQueue)
000000  b510              PUSH     {r4,lr}
;;;288    {
000002  0004              MOVS     r4,r0
;;;289    	uint8_t nRet = 0;
000004  f04f0000          MOV      r0,#0
;;;290    
;;;291    	if (pQueue == NULL)
;;;292    	{
;;;293    		goto STATICQUEUE_INIT__GOTO_END;
;;;294    	}
;;;295    
;;;296    	//InitializeCriticalSection(&g_cs);
;;;297    	memcpy(pQueue->Signature, (uint8_t*)QUEUE_SIGNATURE, 4);
;;;298    	memset(pQueue->Buffer, 0, QUEUE_BLOCK_SIZE * QUEUE_MAX_COUNT__COMMON);
;;;299    	pQueue->PushPoint = 0;
;;;300    	pQueue->PopPoint = 0;
;;;301    	pQueue->Count = 0;
;;;302    
;;;303    	nRet = 1;
;;;304    
;;;305    STATICQUEUE_INIT__GOTO_END:
;;;306    
;;;307    	return nRet;
;;;308    }
000008  bf08              IT       EQ
00000a  bd10              POPEQ    {r4,pc}
00000c  a008              ADR      r0,|L28.48|
00000e  f24071bc          MOV      r1,#0x7bc             ;298
000012  6800              LDR      r0,[r0,#0]            ;297
000014  6020              STR      r0,[r4,#0]            ;297
000016  1d20              ADDS     r0,r4,#4              ;298
000018  f7fffffe          BL       __aeabi_memclr
00001c  2000              MOVS     r0,#0                 ;299
00001e  f88407c0          STRB     r0,[r4,#0x7c0]        ;299
000022  f88407c1          STRB     r0,[r4,#0x7c1]        ;300
000026  f8c407c2          STR      r0,[r4,#0x7c2]        ;301
00002a  2001              MOVS     r0,#1                 ;303
00002c  bd10              POP      {r4,pc}
;;;309    
                          ENDP

00002e  0000              DCW      0x0000
                  |L28.48|
000030  53495734          DCB      "SIW4",0
000034  00      
000035  00                DCB      0
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.StaticQueue_Pop||, CODE, READONLY, ALIGN=1

                  StaticQueue_Pop PROC
;;;369    
;;;370    uint8_t StaticQueue_Pop(PSTATIC_QUEUE pQueue, uint8_t* pData)
000000  b510              PUSH     {r4,lr}
;;;371    {
000002  0004              MOVS     r4,r0
000004  460b              MOV      r3,r1
;;;372    	uint8_t nRet = FALSE;
000006  f04f0000          MOV      r0,#0
;;;373    
;;;374    	if ((pQueue == NULL) || (pData == NULL))
00000a  bf14              ITE      NE
00000c  2b00              CMPNE    r3,#0
;;;375    	{
;;;376    		goto STATICQUEUE_POP__GOTO_END;
;;;377    	}
;;;378    
;;;379    	// Empty
;;;380    	if (pQueue->Count <= 0)
;;;381    	{
;;;382    		goto STATICQUEUE_POP__GOTO_END;
;;;383    	}
;;;384        
;;;385        if (pQueue->Doing == TRUE)
;;;386        {
;;;387            goto STATICQUEUE_POP__GOTO_END;
;;;388        }
;;;389    
;;;390    	memcpy(pData, &pQueue->Buffer[pQueue->PopPoint * QUEUE_BLOCK_SIZE], QUEUE_BLOCK_SIZE);
;;;391    	pQueue->Count -= 1;
;;;392    	pQueue->PopPoint += 1;
;;;393    	if (pQueue->PopPoint >= QUEUE_MAX_COUNT__COMMON)
;;;394    	{
;;;395    		pQueue->PopPoint = 0;
;;;396    	}
;;;397    
;;;398    	nRet = TRUE;
;;;399    
;;;400    STATICQUEUE_POP__GOTO_END:
;;;401    
;;;402    	return nRet;
;;;403    }
00000e  bd10              POPEQ    {r4,pc}
000010  f8d417c2          LDR      r1,[r4,#0x7c2]        ;380
000014  2900              CMP      r1,#0                 ;380
000016  bf1a              ITTE     NE                    ;385
000018  f89417c6          LDRBNE   r1,[r4,#0x7c6]        ;385
00001c  2901              CMPNE    r1,#1                 ;385
00001e  bd10              POPEQ    {r4,pc}
000020  f89407c1          LDRB     r0,[r4,#0x7c1]        ;390
000024  f04f0242          MOV      r2,#0x42              ;390
000028  eb001040          ADD      r0,r0,r0,LSL #5       ;390
00002c  eb040040          ADD      r0,r4,r0,LSL #1       ;390
000030  f1000104          ADD      r1,r0,#4              ;390
000034  4618              MOV      r0,r3                 ;390
000036  f7fffffe          BL       __aeabi_memcpy
00003a  f8d407c2          LDR      r0,[r4,#0x7c2]        ;391
00003e  1e40              SUBS     r0,r0,#1              ;391
000040  f8c407c2          STR      r0,[r4,#0x7c2]        ;391
000044  f89407c1          LDRB     r0,[r4,#0x7c1]        ;392
000048  1c40              ADDS     r0,r0,#1              ;392
00004a  b2c0              UXTB     r0,r0                 ;392
00004c  f88407c1          STRB     r0,[r4,#0x7c1]        ;392
000050  281e              CMP      r0,#0x1e              ;393
000052  bf24              ITT      CS                    ;395
000054  2000              MOVCS    r0,#0                 ;395
000056  f88407c1          STRBCS   r0,[r4,#0x7c1]        ;395
00005a  2001              MOVS     r0,#1                 ;398
00005c  bd10              POP      {r4,pc}
;;;404    
                          ENDP


                          AREA ||i.StaticQueue_Push||, CODE, READONLY, ALIGN=1

                  StaticQueue_Push PROC
;;;335    
;;;336    uint8_t StaticQueue_Push(PSTATIC_QUEUE pQueue, uint8_t* pData)
000000  b510              PUSH     {r4,lr}
;;;337    {
000002  0004              MOVS     r4,r0
;;;338    	uint8_t nRet = 0;
000004  f04f0000          MOV      r0,#0
;;;339    
;;;340    	if ((pQueue == NULL) || (pData == NULL))
000008  bf14              ITE      NE
00000a  2900              CMPNE    r1,#0
;;;341    	{
;;;342    		goto STATICQUEUE_PUSH__GOTO_END;
;;;343    	}
;;;344    
;;;345    	// Full
;;;346    	if (pQueue->Count >= QUEUE_MAX_COUNT__COMMON)
;;;347    	{
;;;348    		goto STATICQUEUE_PUSH__GOTO_END;
;;;349    	}
;;;350    
;;;351        pQueue->Doing = TRUE;
;;;352        
;;;353    	memcpy(&pQueue->Buffer[pQueue->PushPoint * QUEUE_BLOCK_SIZE], pData, QUEUE_BLOCK_SIZE);
;;;354    	pQueue->Count += 1;
;;;355    	pQueue->PushPoint += 1;
;;;356    	if (pQueue->PushPoint >= QUEUE_MAX_COUNT__COMMON)
;;;357    	{
;;;358    		pQueue->PushPoint = 0;
;;;359    	}
;;;360    
;;;361    	nRet = 1;
;;;362        pQueue->Doing = FALSE;
;;;363    
;;;364    STATICQUEUE_PUSH__GOTO_END:
;;;365    
;;;366    	return nRet;
;;;367    }
00000c  bd10              POPEQ    {r4,pc}
00000e  f8d427c2          LDR      r2,[r4,#0x7c2]        ;346
000012  2a1e              CMP      r2,#0x1e              ;346
000014  bf28              IT       CS
000016  bd10              POPCS    {r4,pc}
000018  2001              MOVS     r0,#1                 ;351
00001a  f88407c6          STRB     r0,[r4,#0x7c6]        ;351
00001e  f89407c0          LDRB     r0,[r4,#0x7c0]        ;353
000022  2242              MOVS     r2,#0x42              ;353
000024  eb001040          ADD      r0,r0,r0,LSL #5       ;353
000028  eb040040          ADD      r0,r4,r0,LSL #1       ;353
00002c  1d00              ADDS     r0,r0,#4              ;353
00002e  f7fffffe          BL       __aeabi_memcpy
000032  f8d407c2          LDR      r0,[r4,#0x7c2]        ;354
000036  2100              MOVS     r1,#0                 ;355
000038  1c40              ADDS     r0,r0,#1              ;354
00003a  f8c407c2          STR      r0,[r4,#0x7c2]        ;354
00003e  f89407c0          LDRB     r0,[r4,#0x7c0]        ;355
000042  1c40              ADDS     r0,r0,#1              ;355
000044  b2c0              UXTB     r0,r0                 ;355
000046  f88407c0          STRB     r0,[r4,#0x7c0]        ;355
00004a  281e              CMP      r0,#0x1e              ;356
00004c  bf28              IT       CS                    ;358
00004e  f88417c0          STRBCS   r1,[r4,#0x7c0]        ;358
000052  2001              MOVS     r0,#1                 ;361
000054  f88417c6          STRB     r1,[r4,#0x7c6]        ;362
000058  bd10              POP      {r4,pc}
;;;368    
                          ENDP


                          AREA ||i.USB_DevInit||, CODE, READONLY, ALIGN=2

                  USB_DevInit PROC
;;;3358   
;;;3359   void USB_DevInit(void)
000000  b510              PUSH     {r4,lr}
000002  4809              LDR      r0,|L31.40|
;;;3360   {
;;;3361   #ifndef MODE_I2C
;;;3362   	Fncp_USB_IRQHandler = &USB_InterruptHandler;
;;;3363   	
;;;3364   	// suspend counter
;;;3365   	mUsbIdleCnt(7);
;;;3366   
;;;3367   	mUsbUnPLGClr();
;;;3368   
;;;3369   	// Clear interrupt
;;;3370   	mUsbIntBusRstClr();
;;;3371   	mUsbIntSuspClr();
;;;3372   	mUsbIntResmClr();
;;;3373   
;;;3374   	// Disable all fifo interrupt
;;;3375   	mUsbIntFIFO0_3OUTDis();
;;;3376   	mUsbIntFIFO0_3INDis();
;;;3377   
;;;3378   	// Clear all fifo
;;;3379   	mUsbClrAllFIFOSet();
;;;3380   
;;;3381   	mUsbIntWakebyVbusDis();
;;;3382   	mUsbIntDevIdleDis();
;;;3383   
;;;3384   	// Enable usb200 global interrupt
;;;3385   	mUsbGlobIntEnSet();
;;;3386   	mUsbChipEnSet();
;;;3387   	mUsbOTGDevFS();
;;;3388   
;;;3389   	// Interrupt Mode
;;;3390   	mUsbIntPolarityLow();
;;;3391   
;;;3392   	
;;;3393   	// Virtual DMA
;;;3394   	mUsbVDMAEnable();
;;;3395   
;;;3396   	// Virtual DMA Mask - CXF Enable
;;;3397   	mUsbCXIntDmaErrEn();
;;;3398   	mUsbCXIntDmaFinishEn();
;;;3399   	
;;;3400   
;;;3401   	// RemoteWakeup
;;;3402   	mUsbRmWkupSet(); 
;;;3403   #endif
;;;3404   
;;;3405   #ifdef ADD_PEN //ADD_CUSTOM // NOTE : In this case, used the Pen Mode status
;;;3406       sptAlgorithmInfo = algorithm_GetInfo();
;;;3407   #endif
;;;3408   
;;;3409   	// Queue
;;;3410   	StaticQueue_Init(&g_Queue_Common);
000004  4c07              LDR      r4,|L31.36|
000006  f24071bc          MOV      r1,#0x7bc
00000a  6800              LDR      r0,[r0,#0]
00000c  6020              STR      r0,[r4,#0]
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       __aeabi_memclr
000014  2000              MOVS     r0,#0
000016  f88407c0          STRB     r0,[r4,#0x7c0]
00001a  f88407c1          STRB     r0,[r4,#0x7c1]
00001e  f8c407c2          STR      r0,[r4,#0x7c2]
;;;3411   	return;
;;;3412   }
000022  bd10              POP      {r4,pc}
;;;3413   
                          ENDP

                  |L31.36|
                          DCD      ||area_number.37||+0xac
                  |L31.40|
                          DCD      ||i.StaticQueue_Init||+0x30

                          AREA ||i.USB_InterruptHandler||, CODE, READONLY, ALIGN=1

                  USB_InterruptHandler PROC
;;;3009   
;;;3010   void USB_InterruptHandler(void)
000000  4770              BX       lr
;;;3011   {
;;;3012   //	SCRB->USB_INTR_CLR.ulBulk = 0x7; // USB CM3 Internal Interrupt clear!!
;;;3013   
;;;3014   #ifndef MODE_I2C
;;;3015   	g_IntGroup = mUsbIntGroupRegRd();	// 0x140
;;;3016   	// EP0
;;;3017   	if (g_IntGroup & BIT0)
;;;3018   	{
;;;3019   		g_IntEP0 = mUsbIntSrc0Rd(); // 0x144
;;;3020   
;;;3021   		if (g_IntEP0 & BIT0)
;;;3022   		{
;;;3023   			//if ((g_CheckVDMAComplete_Touch == DMA_READY) && (g_CheckVDMAComplete_Custom == DMA_READY) && (g_CheckVDMAComplete_Pen == DMA_READY))
;;;3024   			if ((g_CXF_Done == CXF_STATUS__NORMAL) || (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3025   			{
;;;3026   				g_CXF_Done = CXF_STATUS__DOING;
;;;3027   
;;;3028   				mUsbCXIntDmaErrEn();
;;;3029   				mUsbCXIntDmaFinishEn();
;;;3030   
;;;3031   				mUsbCXDmaConfig(8, DIRECTION_OUT); // Memory To FIFO
;;;3032   				mUsbCXDmaAddr((uint32_t)g_EP0_Packet);
;;;3033   				mUsbCXDmaStart();
;;;3034   			}
;;;3035   
;;;3036   		}
;;;3037   	}
;;;3038   
;;;3039   
;;;3040   
;;;3041   	// Virtual DMA 
;;;3042   	if (g_IntGroup & BIT3)
;;;3043   	{
;;;3044   		g_IntVDMA = mUsbIntSrc3Rd();
;;;3045   
;;;3046   		// CXF Complete
;;;3047   		if (g_IntVDMA & BIT0)
;;;3048   		{
;;;3049   			// DMA g_CXF_Done CXF_STATUS__NEED_TO_DONE
;;;3050   			if (g_EP0_Check == 1)
;;;3051   			{
;;;3052   				// Buffer Host Done !!
;;;3053   				if ((g_EP0_Offset == g_EP0_BufferLength) || (g_EP0_Offset == g_pSetupPacket->wLength))
;;;3054   				{
;;;3055   					// Cx Done!!!
;;;3056   					g_CXF_Done = CXF_STATUS__NEED_TO_DONE;
;;;3057   
;;;3058   					g_EP0_Offset = 0;
;;;3059   					g_EP0_Remain = 0;
;;;3060   					g_EP0_BufferLength = 0;
;;;3061   				}
;;;3062   
;;;3063   				g_EP0_Check = 0;
;;;3064   			}
;;;3065   
;;;3066   			if (g_CXF_Done == CXF_STATUS__NEED_TO_DONE)
;;;3067   			{
;;;3068   				mUsbCXDmaFinishClr();
;;;3069   				mUsbCXDmaErrClr();
;;;3070   				mUsbCXIntDmaFinishDis();
;;;3071   				mUsbEP0DoneSet();
;;;3072   
;;;3073   				g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;3074   
;;;3075   				// DMA Flag
;;;3076   				SetupPacket_AfterCheck(g_pSetupPacket);
;;;3077   
;;;3078   				memset(g_pSetupPacket, 0, sizeof(SETUP_PACKET));
;;;3079   				return;
;;;3080   			}
;;;3081   			else if (g_CXF_Done == CXF_STATUS__DOING)
;;;3082   			{
;;;3083   				//if ((g_CheckVDMAComplete_Touch == DMA_READY) && (g_CheckVDMAComplete_Custom == DMA_READY) && (g_CheckVDMAComplete_Pen == DMA_READY))
;;;3084   				{
;;;3085   					mUsbCXDmaFinishClr();
;;;3086   					mUsbCXDmaErrClr();
;;;3087   					mUsbCXIntDmaFinishDis();
;;;3088   
;;;3089   					EP0_SetupPacket();
;;;3090   					return;
;;;3091   				}
;;;3092   			}
;;;3093   		}
;;;3094   
;;;3095   #ifdef ADD_TOUCH
;;;3096   		// FIFO Complete - MultiTouch
;;;3097   		if (g_IntVDMA & (BIT1 << TOUCH_FIFO_IN))
;;;3098   		{
;;;3099   			mUsbEXDmaFinishClr(TOUCH_FIFO_IN);
;;;3100   			mUsbEXIntDmaErrDis(TOUCH_FIFO_IN);
;;;3101   			mUsbEXIntDmaFinishDis(TOUCH_FIFO_IN);
;;;3102   
;;;3103   			// Touch DMA
;;;3104   			g_CheckVDMAComplete_Touch = DMA_READY;
;;;3105   		}
;;;3106   #endif
;;;3107   		
;;;3108   		
;;;3109   #ifdef ADD_CUSTOM
;;;3110   		// FIFO Complete - Custom OUT
;;;3111   		if (g_IntVDMA & (BIT1 << CUSTOM_FIFO_OUT))
;;;3112   		{
;;;3113   			// Custom OUT
;;;3114   			RecieveCustomData_DMA();
;;;3115   			
;;;3116   #ifdef JOSH3_LOOP_BACK_TEST
;;;3117   			g_CustomBuffer[0] = HID_REPORT_ID__CUSTOM_IN;
;;;3118   			SendCustomData_USB((UINT8*)g_CustomBuffer);
;;;3119   #else
;;;3120   			// App Call
;;;3121   			RecieveCustomData(g_CustomBuffer);
;;;3122   #endif
;;;3123   		}
;;;3124   
;;;3125   		// FIFO Complete - Custom IN
;;;3126   		if (g_IntVDMA & (BIT1 << CUSTOM_FIFO_IN))
;;;3127   		{
;;;3128   			mUsbEXDmaFinishClr(CUSTOM_FIFO_IN);
;;;3129   			mUsbEXIntDmaErrDis(CUSTOM_FIFO_IN);
;;;3130   			mUsbEXIntDmaFinishDis(CUSTOM_FIFO_IN);
;;;3131   
;;;3132   			// Custom DMA
;;;3133   			g_CheckVDMAComplete_Custom = DMA_READY;
;;;3134   		}
;;;3135   #endif
;;;3136   		
;;;3137   		
;;;3138   		
;;;3139   #ifdef ADD_PEN
;;;3140   		// FIFO Complete - Pen
;;;3141   		if (g_IntVDMA & (BIT1 << PEN_FIFO_IN))
;;;3142   		{
;;;3143   			mUsbEXDmaFinishClr(PEN_FIFO_IN);
;;;3144   			mUsbEXIntDmaErrDis(PEN_FIFO_IN);
;;;3145   			mUsbEXIntDmaFinishDis(PEN_FIFO_IN);
;;;3146   
;;;3147   			// Touch DMA
;;;3148   			g_CheckVDMAComplete_Pen = DMA_READY;
;;;3149   		}
;;;3150   #endif
;;;3151   
;;;3152   
;;;3153   
;;;3154   #ifdef ADD_BULK_CUSTOM
;;;3155   		// FIFO Complete - Bulk Custom OUT
;;;3156   		if (g_IntVDMA & (BIT1 << BULK_CUSTOM_FIFO_OUT))
;;;3157   		{
;;;3158   			// Bulk Custom OUT
;;;3159   			RecieveBulkCustomData_DMA();
;;;3160   
;;;3161   			// App Call
;;;3162   			RecieveBulkCustomData(g_BulkCustomBuffer);
;;;3163   		}
;;;3164   
;;;3165   		// FIFO Complete - Bulk Custom IN
;;;3166   		if (g_IntVDMA & (BIT1 << BULK_CUSTOM_FIFO_IN))
;;;3167   		{
;;;3168   			mUsbEXDmaFinishClr(BULK_CUSTOM_FIFO_IN);
;;;3169   			mUsbEXIntDmaErrDis(BULK_CUSTOM_FIFO_IN);
;;;3170   			mUsbEXIntDmaFinishDis(BULK_CUSTOM_FIFO_IN);
;;;3171   
;;;3172   			// Bulk Custom DMA
;;;3173   			g_CheckVDMAComplete_BulkCustom = DMA_READY;
;;;3174   		}
;;;3175   #endif
;;;3176   
;;;3177   
;;;3178   
;;;3179   		// CXF Error
;;;3180   		if (g_IntVDMA & BIT16)
;;;3181   		{
;;;3182   			mUsbCXDmaErrClr();
;;;3183   		}
;;;3184   
;;;3185   		// FIFO 0 Error
;;;3186   		if (g_IntVDMA & BIT17)
;;;3187   		{
;;;3188   			mUsbEXDmaErrClr(0);
;;;3189   		}
;;;3190   
;;;3191   		// FIFO 1 Error
;;;3192   		if (g_IntVDMA & BIT18)
;;;3193   		{
;;;3194   			mUsbEXDmaErrClr(1);
;;;3195   		}
;;;3196   
;;;3197   		// FIFO 2 Error
;;;3198   		if (g_IntVDMA & BIT19)
;;;3199   		{
;;;3200   			mUsbEXDmaErrClr(2);
;;;3201   		}
;;;3202   
;;;3203   		// FIFO 3 Error
;;;3204   		if (g_IntVDMA & BIT20)
;;;3205   		{
;;;3206   			mUsbEXDmaErrClr(3);
;;;3207   		}
;;;3208   	}
;;;3209   
;;;3210   
;;;3211   
;;;3212   	// USB Controll
;;;3213   	if (g_IntGroup & BIT2)
;;;3214   	{
;;;3215   		g_IntControl = mUsbIntSrc2Rd();
;;;3216   
;;;3217   		// USBRST_INT
;;;3218   		if (g_IntControl & BIT0)
;;;3219   		{
;;;3220   			g_RemoteWakeup = 0;
;;;3221   			g_Configuration = 0;
;;;3222   			g_HIDReady = 0;
;;;3223   
;;;3224   			// Clear
;;;3225   			mUsbIntBusRstClr();
;;;3226   
;;;3227   			// Addr
;;;3228   			mUsbDevAddrSet(0);
;;;3229   
;;;3230   			// FIFO
;;;3231   			mUsbClrAllFIFOSet();
;;;3232   
;;;3233   			// EP0 FIFO Clear
;;;3234   			mUsbCxFClr();
;;;3235   
;;;3236   			// Full Speed
;;;3237   			mUsbOTGDevFS();
;;;3238   
;;;3239   			// Init
;;;3240   			USB_ResetResume();
;;;3241   			
;;;3242   			// Queue
;;;3243   			StaticQueue_Init(&g_Queue_Common);
;;;3244   
;;;3245   			// SelfPowerd, RemoteWakeup Disable Status
;;;3246   			g_Status[0].Status.Global.SelfPowered = 1;
;;;3247   			g_Status[0].Status.Global.RemoteWakeup = 0;
;;;3248   		}
;;;3249   
;;;3250   		// SUSP_INT
;;;3251   		if (g_IntControl & BIT1)
;;;3252   		{
;;;3253   			g_Configuration = 0;
;;;3254   			g_HIDReady = 0;
;;;3255   
;;;3256   			mUsbIntSuspClr();
;;;3257   		}
;;;3258   
;;;3259   		// RESM_INT
;;;3260   		if (g_IntControl & BIT2)
;;;3261   		{
;;;3262   			if (g_RemoteWakeup == 1)
;;;3263   			{
;;;3264   				g_RemoteWakeup = 0;
;;;3265   				mUsbRemoteWakeUpSet_0();
;;;3266   				g_ScanTime_Recovery = 0;
;;;3267   				g_StartTime_Recovery = 0;
;;;3268   				GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus);
;;;3269   				Recovery_ClearSus_Flag = 1;
;;;3270   			}
;;;3271   
;;;3272   			mUsbIntResmClr();
;;;3273   			g_Configuration=1;
;;;3274   			g_HIDReady=1;
;;;3275   
;;;3276   			// Init
;;;3277   			USB_ResetResume();
;;;3278   		}
;;;3279   
;;;3280   		// DMA_COMPLT
;;;3281   		if (g_IntControl & BIT7)
;;;3282   		{
;;;3283   			// Finish
;;;3284   			mUsbIntDmaFinishClr();
;;;3285   
;;;3286   			// FIFO Control Stop
;;;3287   			mUsbDMA2FIFOSel(0);
;;;3288   		}
;;;3289   
;;;3290   	}
;;;3291   
;;;3292   
;;;3293   
;;;3294   
;;;3295   	if (g_IntGroup & BIT1)
;;;3296   	{
;;;3297   		g_IntEP = mUsbIntSrc1Rd(); // 0x148
;;;3298   
;;;3299   #ifdef ADD_TOUCH
;;;3300   		// Multi Touch (IN)
;;;3301   		if (g_IntEP & (BIT16 << TOUCH_FIFO_IN))
;;;3302   		{
;;;3303   			if ((g_CheckVDMAComplete_Touch == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3304   			{
;;;3305   				mUsbIntF1INDis();
;;;3306   				DMATouchData_USB();
;;;3307   				return;
;;;3308   			}
;;;3309   		}
;;;3310   #endif
;;;3311   
;;;3312   #ifdef ADD_CUSTOM
;;;3313   		// Custom (IN)
;;;3314   		if (g_IntEP & (BIT16 << CUSTOM_FIFO_IN))
;;;3315   		{
;;;3316   			if ((g_CheckVDMAComplete_Custom == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3317   			{
;;;3318   				mUsbIntF0INDis();
;;;3319   				DMACustomData_USB();
;;;3320   				return;
;;;3321   			}
;;;3322   		}
;;;3323   #endif
;;;3324   
;;;3325   #ifdef ADD_PEN
;;;3326   		// Pen (IN)
;;;3327   		if (g_IntEP & (BIT16 << PEN_FIFO_IN))
;;;3328   		{
;;;3329   			if ((g_CheckVDMAComplete_Pen == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3330   			{
;;;3331   				mUsbIntF3INDis();
;;;3332   				DMAPenData_USB();
;;;3333   				return;
;;;3334   			}
;;;3335   		}
;;;3336   #endif
;;;3337   
;;;3338   #ifdef ADD_BULK_CUSTOM
;;;3339   		// Bulk Custom (IN)
;;;3340   		if (g_IntEP & (BIT16 << BULK_CUSTOM_FIFO_IN))
;;;3341   		{
;;;3342   			if ((g_CheckVDMAComplete_BulkCustom == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3343   			{
;;;3344   				mUsbIntF0INDis();
;;;3345   				DMABulkData_USB();
;;;3346   				return;
;;;3347   			}
;;;3348   		}
;;;3349   #endif
;;;3350   
;;;3351   	}
;;;3352   
;;;3353   #endif
;;;3354   	return;
;;;3355   }
;;;3356   
                          ENDP


                          AREA ||i.protocol_hid_PushPenEvent||, CODE, READONLY, ALIGN=2

                  protocol_hid_PushPenEvent PROC
;;;1019   
;;;1020   void protocol_hid_PushPenEvent(const uSWIPTouchItem_t* _kptItem)
000000  490c              LDR      r1,|L33.52|
;;;1021   {
;;;1022   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1023   	HID_PEN_STATUS = (_kptItem->tItem00.tInfo.b1Status & 0x01);
;;;1024   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1025   	HID_PEN_STATUS = sptAlgorithmInfo->bLocal_sensing | (sptAlgorithmInfo->tPenInfo.bPenContact<<1);
000002  6aca              LDR      r2,[r1,#0x2c]  ; sptAlgorithmInfo
000004  f5025280          ADD      r2,r2,#0x1000
000008  f89230e0          LDRB     r3,[r2,#0xe0]
00000c  f89220e7          LDRB     r2,[r2,#0xe7]
000010  ea430242          ORR      r2,r3,r2,LSL #1
;;;1026   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1027   	HID_PEN_X = _kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow;
000014  614a              STR      r2,[r1,#0x14]  ; HID_PEN_STATUS
000016  78c2              LDRB     r2,[r0,#3]
000018  7843              LDRB     r3,[r0,#1]
00001a  ea422203          ORR      r2,r2,r3,LSL #8
;;;1028   	HID_PEN_Y = _kptItem->tItem00.ucYHigh << 8 | _kptItem->tItem00.ucYLow;
00001e  60ca              STR      r2,[r1,#0xc]  ; HID_PEN_X
000020  7902              LDRB     r2,[r0,#4]
000022  7880              LDRB     r0,[r0,#2]
000024  ea422000          ORR      r0,r2,r0,LSL #8
;;;1029   
;;;1030   	g_PenEventNum++;
000028  6108              STR      r0,[r1,#0x10]  ; HID_PEN_Y
00002a  7888              LDRB     r0,[r1,#2]  ; g_PenEventNum
00002c  1c40              ADDS     r0,r0,#1
00002e  7088              STRB     r0,[r1,#2]
;;;1031   }
000030  4770              BX       lr
;;;1032   
                          ENDP

000032  0000              DCW      0x0000
                  |L33.52|
                          DCD      ||.data||

                          AREA ||i.protocol_hid_PushTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_hid_PushTouchEvent PROC
;;;992    
;;;993    void protocol_hid_PushTouchEvent(const uSWIPTouchItem_t* _kptItem)
000000  4914              LDR      r1,|L34.84|
;;;994    {
;;;995    	if (hid_index < HID_MAX_TOUCH)
000002  6b0a              LDR      r2,[r1,#0x30]  ; hid_index
000004  2a0a              CMP      r2,#0xa
;;;996    	{
;;;997    #if USED_SHARP_SPECIFIC_PROTOCOL
;;;998    		HID_status[hid_index] = (_kptItem->tItem00.tInfo.b1Status & 0x01);
;;;999    #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1000   		HID_status[hid_index] = _kptItem->tItem00.tInfo.bTouch;
;;;1001   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1002   		HID_id[hid_index] = _kptItem->tItem00.tInfo.b4FingerID;;
;;;1003   #if USED_POOR_PANEL_COLLINE_DISABLE
;;;1004   		uint32_t ulTempXPos;
;;;1005   		ulTempXPos = ((uint32_t)((_kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow) * 10145))/10000;
;;;1006   		if(ulTempXPos > I2C_X_RESOLUTION)
;;;1007   			ulTempXPos = I2C_X_RESOLUTION;
;;;1008   		HID_x[hid_index] = ulTempXPos;
;;;1009   #else /* USED_POOR_PANEL_COLLINE_DISABLE */
;;;1010   		HID_x[hid_index] = _kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow;
;;;1011   #endif /* USED_POOR_PANEL_COLLINE_DISABLE */
;;;1012   		HID_y[hid_index] = _kptItem->tItem00.ucYHigh << 8 | _kptItem->tItem00.ucYLow;
;;;1013   
;;;1014   		hid_index++;
;;;1015   	}
;;;1016   }
000006  bfa8              IT       GE
000008  4770              BXGE     lr
00000a  7802              LDRB     r2,[r0,#0]            ;1000
00000c  f8d1c030          LDR      r12,[r1,#0x30]        ;1000  ; hid_index
000010  09d2              LSRS     r2,r2,#7              ;1000
000012  4b11              LDR      r3,|L34.88|
000014  f843202c          STR      r2,[r3,r12,LSL #2]    ;1000
000018  7802              LDRB     r2,[r0,#0]            ;1002
00001a  f8d1c030          LDR      r12,[r1,#0x30]        ;1002  ; hid_index
00001e  f002020f          AND      r2,r2,#0xf            ;1002
000022  3b78              SUBS     r3,r3,#0x78           ;1002
000024  f843202c          STR      r2,[r3,r12,LSL #2]    ;1002
000028  78c2              LDRB     r2,[r0,#3]            ;1010
00002a  7843              LDRB     r3,[r0,#1]            ;1010
00002c  f8d1c030          LDR      r12,[r1,#0x30]        ;1010  ; hid_index
000030  ea422203          ORR      r2,r2,r3,LSL #8       ;1010
000034  4b09              LDR      r3,|L34.92|
000036  f843202c          STR      r2,[r3,r12,LSL #2]    ;1010
00003a  7902              LDRB     r2,[r0,#4]            ;1012
00003c  7880              LDRB     r0,[r0,#2]            ;1012
00003e  ea422000          ORR      r0,r2,r0,LSL #8       ;1012
000042  f1030228          ADD      r2,r3,#0x28           ;1012
000046  6b0b              LDR      r3,[r1,#0x30]         ;1012  ; hid_index
000048  f8420023          STR      r0,[r2,r3,LSL #2]     ;1012
00004c  6b08              LDR      r0,[r1,#0x30]         ;1014  ; hid_index
00004e  1c40              ADDS     r0,r0,#1              ;1014
000050  6308              STR      r0,[r1,#0x30]         ;1014  ; hid_index
000052  4770              BX       lr
;;;1017   
                          ENDP

                  |L34.84|
                          DCD      ||.data||
                  |L34.88|
                          DCD      ||area_number.37||+0x84
                  |L34.92|
                          DCD      ||area_number.37||+0x34

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_Touch
                          %        66

                          AREA ||area_number.37||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.bss||
                  g_TouchTip
                          %        12
                  HID_id
                          %        40
                  HID_x
                          %        40
                  HID_y
                          %        40
                  HID_status
                          %        40
                  g_Queue_Common
                          %        1991

                          AREA ||area_number.38||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.38||, ||.bss||
                  g_CustomBuffer
                          %        64

                          AREA ||area_number.39||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.39||, ||.bss||
                  g_BulkCustomBuffer
                          %        66

                          AREA ||.data||, DATA, ALIGN=3

                  g_Configuration
000000  00                DCB      0x00
                  g_HIDReady
000001  00                DCB      0x00
                  g_PenEventNum
000002  0000              DCB      0x00,0x00
                  g_usRegAddr
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  g_ScanTime
                          DCD      0x00000000
                  HID_PEN_X
                          DCD      0x00000000
                  HID_PEN_Y
                          DCD      0x00000000
                  HID_PEN_STATUS
                          DCD      0x00000000
                  g_Full
                          DCD      0x00000000
                  rmi_read_ptr
                          DCD      0x00000000
                  rmi_write_ptr
                          DCD      0x00000000
                  protocol_sent_byte
                          DCD      0x00000000
                  protocol_received_byte
                          DCD      0x00000000
                  sptAlgorithmInfo
                          DCD      0x00000000
                  hid_index
                          DCD      0x00000000
                          DCD      0x00000000
                  g_StartTime
000038  00000000          DCQ      0x0000000000000000
00003c  00000000

                          AREA ||area_number.42||, DATA, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.data||
                  g_DeviceMode
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  g_LatencyMode
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.44||, DATA, ALIGN=0

                          EXPORTAS ||area_number.44||, ||.data||
                  g_MaxTouchCount
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.45||, DATA, ALIGN=0

                          EXPORTAS ||area_number.45||, ||.data||
                  g_CheckVDMAComplete_Touch
000000  01                DCB      0x01

                          AREA ||area_number.46||, DATA, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.data||
                  g_ScanTime_Recovery
                          DCD      0x00000000

                          AREA ||area_number.47||, DATA, ALIGN=3

                          EXPORTAS ||area_number.47||, ||.data||
                  g_StartTime_Recovery
000000  00000000          DCQ      0x0000000000000000
000004  00000000

                          AREA ||area_number.48||, DATA, ALIGN=0

                          EXPORTAS ||area_number.48||, ||.data||
                  ResumeCnt
000000  00                DCB      0x00

                          AREA ||area_number.49||, DATA, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.data||
                  g_ScanTime_Recovery_ClearSus
                          DCD      0x00000000

                          AREA ||area_number.50||, DATA, ALIGN=3

                          EXPORTAS ||area_number.50||, ||.data||
                  g_StartTime_Recovery_ClearSus
000000  00000000          DCQ      0x0000000000000000
000004  00000000

                          AREA ||area_number.51||, DATA, ALIGN=0

                          EXPORTAS ||area_number.51||, ||.data||
                  Recovery_ClearSus_Flag
000000  00                DCB      0x00

                          AREA ||area_number.52||, DATA, ALIGN=0

                          EXPORTAS ||area_number.52||, ||.data||
                  g_CheckVDMAComplete_Custom
000000  01                DCB      0x01

                          AREA ||area_number.53||, DATA, ALIGN=0

                          EXPORTAS ||area_number.53||, ||.data||
                  g_CheckVDMAComplete_Pen
000000  01                DCB      0x01

                          AREA ||area_number.54||, DATA, ALIGN=0

                          EXPORTAS ||area_number.54||, ||.data||
                  g_CheckVDMAComplete_BulkCustom
000000  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\usb\\FWOTG210_F000\\Pe_usb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___8_Pe_usb_c_669b9ed5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____REVSH|
#line 402
|__asm___8_Pe_usb_c_669b9ed5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____RRX|
#line 587
|__asm___8_Pe_usb_c_669b9ed5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
