; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\algorithm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\algorithm.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\algorithm.crf ..\..\App\Algorithm\algorithm.c]
                          THUMB

                          AREA ||i.GetOperTimeUS||, CODE, READONLY, ALIGN=2

                  GetOperTimeUS PROC
;;;456    uint32_t OperEndTime;
;;;457    void GetOperTimeUS(uint64_t* StartTime, uint32_t* ScanTime)
000000  b570              PUSH     {r4-r6,lr}
;;;458    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  e9d50100          LDRD     r0,r1,[r5,#0]
00000a  2400              MOVS     r4,#0
;;;459    	uint16_t Temp = 0;
;;;460    
;;;461    	if (*StartTime == 0)
00000c  ea500201          ORRS     r2,r0,r1
000010  d00a              BEQ      |L1.40|
;;;462    	{
;;;463    		goto GETSCANTIME__GOTO_END;
;;;464    	}
;;;465    	
;;;466    	Temp = (uint16_t)(getElapsedUS(*StartTime));
000012  f7fffffe          BL       getElapsedLongSYSTICK
000016  4a0d              LDR      r2,|L1.76|
000018  6812              LDR      r2,[r2,#0]  ; _timer_clock_
00001a  4623              MOV      r3,r4
00001c  f7fffffe          BL       __aeabi_uldivmod
;;;467    	*ScanTime += Temp;
000020  6831              LDR      r1,[r6,#0]
000022  b280              UXTH     r0,r0                 ;466
000024  4408              ADD      r0,r0,r1
000026  6030              STR      r0,[r6,#0]
                  |L1.40|
;;;468    
;;;469    GETSCANTIME__GOTO_END:
;;;470    
;;;471    	*StartTime = (uint64_t)getLongSysTick();
000028  4809              LDR      r0,|L1.80|
00002a  6800              LDR      r0,[r0,#0]  ; _timertick_high_rank_count_
00002c  03a2              LSLS     r2,r4,#14
00002e  ea424290          ORR      r2,r2,r0,LSR #18
000032  0381              LSLS     r1,r0,#14
000034  f04f4080          MOV      r0,#0x40000000
000038  f8d001b8          LDR      r0,[r0,#0x1b8]
00003c  f3c0000d          UBFX     r0,r0,#0,#14
000040  4308              ORRS     r0,r0,r1
000042  ea420104          ORR      r1,r2,r4
000046  e9c50100          STRD     r0,r1,[r5,#0]
;;;472    }
00004a  bd70              POP      {r4-r6,pc}
;;;473    
                          ENDP

                  |L1.76|
                          DCD      _timer_clock_
                  |L1.80|
                          DCD      _timertick_high_rank_count_

                          AREA ||i.algorithm_CheckFingerIdleModeControl||, CODE, READONLY, ALIGN=2

                  algorithm_CheckFingerIdleModeControl PROC
;;;195    #if USED_IDLE_MODE_CONTROL
;;;196    bool_t algorithm_CheckFingerIdleModeControl(void)
000000  b570              PUSH     {r4-r6,lr}
;;;197    {
;;;198    	eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
000002  f7fffffe          BL       HAL_GetSensingMode
;;;199    
;;;200    	if(IS_ACTIVE_MODE(eSensingMode))
;;;201    	{
;;;202    		if(thisInfo->bTouchExpect)
000006  4c1d              LDR      r4,|L2.124|
000008  4605              MOV      r5,r0                 ;198
00000a  f0100f01          TST      r0,#1                 ;200
;;;203    		{
;;;204    			thisInfo->ulIdleModeEnterCheckCount = 0;
;;;205    		}
;;;206    		else
;;;207    		{
;;;208    	#if USED_ENTER_IDLE_REAL_TIME_CHECK
;;;209    			if(thisInfo->ulIdleModeEnterCheckCount == 0)
;;;210    			{
;;;211    				TimerTick_ResetIdleModeCheckTime();
;;;212    				thisInfo->ulIdleModeEnterCheckCount++;
;;;213    			}
;;;214    	#else /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;215    			thisInfo->ulIdleModeEnterCheckCount++;
;;;216    	#endif /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;217    
;;;218    #if USED_NOISE_HOPPING_FREQ
;;;219    	#if USED_ENTER_IDLE_REAL_TIME_CHECK
;;;220    			if(IS_ACTIVE_MODE_FRQ_MAIN(eSensingMode))
;;;221    			{
;;;222    				if(TimerTick_GetIdleModeCheckTimeSec() >= thisInfo->ulIdleModeEnterFrameCntTHD)
;;;223    				{
;;;224    					thisInfo->ulIdleModeEnterCheckCount = 0;
;;;225    					HAL_SetSensingChangeMode(SM_CHANGE_IDLE_MODE);
;;;226    					return YES;
;;;227    				}
;;;228    			}
;;;229    	#else /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;230    			if(IS_ACTIVE_MODE_FRQ_MAIN(eSensingMode))
;;;231    			{
;;;232    				if(thisInfo->ulIdleModeEnterCheckCount > thisInfo->ulIdleModeEnterFrameCntTHD)
;;;233    				{
;;;234    					thisInfo->ulIdleModeEnterCheckCount = 0;
;;;235    					HAL_SetSensingChangeMode(SM_CHANGE_IDLE_MODE);
;;;236    					return YES;
;;;237    				}
;;;238    			}
;;;239    			else
;;;240    			{
;;;241    				if(thisInfo->ulIdleModeEnterCheckCount > thisInfo->ulHopFrqIdleModeFrameCntTHD)
;;;242    				{
;;;243    //					HoppingInitFlag = YES;
;;;244    					thisInfo->ulIdleModeEnterCheckCount = 0;
;;;245    					return YES;
;;;246    				}
;;;247    			}
;;;248    	#endif /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;249    #else /* USED_NOISE_HOPPING_FREQ */
;;;250    	#if USED_ENTER_IDLE_REAL_TIME_CHECK
;;;251    			if(TimerTick_GetIdleModeCheckTimeSec() >= thisInfo->ulIdleModeEnterFrameCntTHD)
;;;252    			{
;;;253    				thisInfo->ulIdleModeEnterCheckCount = 0;
;;;254    				HAL_SetSensingChangeMode(SM_CHANGE_IDLE_MODE);
;;;255    				return YES;
;;;256    			}
;;;257    	#else /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;258    			if(thisInfo->ulIdleModeEnterCheckCount > thisInfo->ulIdleModeEnterFrameCntTHD)
;;;259    			{
;;;260    				thisInfo->ulIdleModeEnterCheckCount = 0;
;;;261    				HAL_SetSensingChangeMode(SM_CHANGE_IDLE_MODE);
;;;262    				return YES;
;;;263    			}
;;;264    	#endif /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;265    #endif /* USED_NOISE_HOPPING_FREQ */
;;;266    		}
;;;267    	}
;;;268    	else
;;;269    	{
;;;270    		if(thisInfo->bTouchExpect)
00000e  68e0              LDR      r0,[r4,#0xc]  ; thisInfo
000010  f5005080          ADD      r0,r0,#0x1000
000014  d027              BEQ      |L2.102|
000016  f89010dd          LDRB     r1,[r0,#0xdd]         ;202
00001a  2600              MOVS     r6,#0                 ;202
00001c  2900              CMP      r1,#0                 ;202
00001e  bf18              IT       NE                    ;204
000020  f8c0616c          STRNE    r6,[r0,#0x16c]        ;204
000024  d127              BNE      |L2.118|
000026  f8d0016c          LDR      r0,[r0,#0x16c]        ;209
00002a  b948              CBNZ     r0,|L2.64|
00002c  f7fffffe          BL       TimerTick_ResetIdleModeCheckTime
000030  68e0              LDR      r0,[r4,#0xc]          ;212  ; thisInfo
000032  f5005080          ADD      r0,r0,#0x1000         ;212
000036  f8d0116c          LDR      r1,[r0,#0x16c]        ;212
00003a  1c49              ADDS     r1,r1,#1              ;212
00003c  f8c0116c          STR      r1,[r0,#0x16c]        ;212
                  |L2.64|
000040  f0150f02          TST      r5,#2                 ;220
000044  d017              BEQ      |L2.118|
000046  f7fffffe          BL       TimerTick_GetIdleModeCheckTimeSec
00004a  68e1              LDR      r1,[r4,#0xc]          ;222  ; thisInfo
00004c  f5015180          ADD      r1,r1,#0x1000         ;222
000050  f8d12168          LDR      r2,[r1,#0x168]        ;222
000054  4282              CMP      r2,r0                 ;222
000056  d80e              BHI      |L2.118|
000058  2001              MOVS     r0,#1                 ;225
00005a  f8c1616c          STR      r6,[r1,#0x16c]        ;225
00005e  f7fffffe          BL       HAL_SetSensingChangeMode
000062  2001              MOVS     r0,#1                 ;226
;;;271    		{
;;;272    			/*
;;;273    			 * NOTE : Idle -> Active Is Always Normal Frequency Operation
;;;274    			 */
;;;275    #if USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE
;;;276    			HAL_SetSensingChangeMode(SM_CHANGE_FULLSCAN_IDLE_MODE);
;;;277    #else /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
;;;278    	#if USED_FAST_SWITCH_IDLE_TO_ACTIVE
;;;279    			HAL_SetSensingChangeMode(SM_FAST_CHANGE_ACTIVE_MODE);
;;;280    	#else /* USED_FAST_SWITCH_IDLE_TO_ACTIVE */
;;;281    			HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_MODE);
;;;282    	#endif /* USED_FAST_SWITCH_IDLE_TO_ACTIVE */
;;;283    #endif /* USED_FULLSCAN_SWITCH_IDLE_TO_ACTIVE */
;;;284    #if USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE
;;;285    			thisInfo->bIsIdleToActive = YES;
;;;286    #endif /* USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE */
;;;287    
;;;288    			return YES;
;;;289    		}
;;;290    	}
;;;291    
;;;292    	return NO;
;;;293    }
000064  bd70              POP      {r4-r6,pc}
                  |L2.102|
000066  f89000dd          LDRB     r0,[r0,#0xdd]         ;270
00006a  b120              CBZ      r0,|L2.118|
00006c  2004              MOVS     r0,#4                 ;276
00006e  f7fffffe          BL       HAL_SetSensingChangeMode
000072  2001              MOVS     r0,#1                 ;288
000074  bd70              POP      {r4-r6,pc}
                  |L2.118|
000076  2000              MOVS     r0,#0                 ;292
000078  bd70              POP      {r4-r6,pc}
;;;294    #endif /* USED_IDLE_MODE_CONTROL */
                          ENDP

00007a  0000              DCW      0x0000
                  |L2.124|
                          DCD      ||.data||

                          AREA ||i.algorithm_Check_Mux_Delta||, CODE, READONLY, ALIGN=2

                  algorithm_Check_Mux_Delta PROC
;;;2564   
;;;2565   bool_t algorithm_Check_Mux_Delta(uint8_t _mux_num, uint8_t _col, uint16_t _delta_thd, bool_t _bUpperCnt)
000000  e92d03f0          PUSH     {r4-r9}
;;;2566   {
000004  4606              MOV      r6,r0
;;;2567   	bool_t bResult = NO;
000006  2000              MOVS     r0,#0
;;;2568   	uint8_t i, size, ucDeltaCnt;
;;;2569   	int16_t data;
;;;2570   
;;;2571   	ucDeltaCnt = 0;
000008  4604              MOV      r4,r0
;;;2572   	size = (_mux_num == LAST_MUX_NUM ? LAST_MUX_ROW : ROW_PER_MUX);
00000a  2e09              CMP      r6,#9
00000c  bf0c              ITE      EQ
00000e  2703              MOVEQ    r7,#3
000010  2705              MOVNE    r7,#5
;;;2573   
;;;2574   	for (i=0; i<size; i++)
000012  2500              MOVS     r5,#0
;;;2575   	{
;;;2576   		data = HAL_READ_DELTA_IMAGE((_mux_num * ROW_PER_MUX) + i, _col);
;;;2577   
;;;2578   		if (_bUpperCnt)
;;;2579   		{
;;;2580   			if (data >= _delta_thd)
000014  f8df8048          LDR      r8,|L3.96|
000018  46bc              MOV      r12,r7                ;2574
00001a  eb060686          ADD      r6,r6,r6,LSL #2
;;;2581   				ucDeltaCnt++;
;;;2582   		}
;;;2583   		else
;;;2584   		{
;;;2585   			if (data < _delta_thd)
00001e  bf00              NOP      
                  |L3.32|
000020  eb060905          ADD      r9,r6,r5
000024  ebc909c9          RSB      r9,r9,r9,LSL #3
000028  eb090949          ADD      r9,r9,r9,LSL #1
00002c  eb0809c9          ADD      r9,r8,r9,LSL #3
000030  eb090941          ADD      r9,r9,r1,LSL #1
000034  f5094970          ADD      r9,r9,#0xf000
000038  f9b996c0          LDRSH    r9,[r9,#0x6c0]
00003c  b113              CBZ      r3,|L3.68|
00003e  4591              CMP      r9,r2                 ;2580
000040  da02              BGE      |L3.72|
000042  e003              B        |L3.76|
                  |L3.68|
000044  4591              CMP      r9,r2
000046  da01              BGE      |L3.76|
                  |L3.72|
000048  1c64              ADDS     r4,r4,#1
;;;2586   				ucDeltaCnt++;
00004a  b2e4              UXTB     r4,r4
                  |L3.76|
00004c  1c6d              ADDS     r5,r5,#1
00004e  f1bc0c01          SUBS     r12,r12,#1
;;;2587   		}
;;;2588   	}
000052  d1e5              BNE      |L3.32|
;;;2589   
;;;2590   	if (ucDeltaCnt >= size)
000054  42bc              CMP      r4,r7
;;;2591   		bResult = YES;
000056  bf28              IT       CS
000058  2001              MOVCS    r0,#1
;;;2592   
;;;2593   	return bResult;
;;;2594   }
00005a  e8bd03f0          POP      {r4-r9}
00005e  4770              BX       lr
;;;2595   #endif /* USED_ESD_RECOVERY_GHOST_TOUCH_DELTA_PATTERN */
                          ENDP

                  |L3.96|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_PendTouchEvent||, CODE, READONLY, ALIGN=2

                  algorithm_PendTouchEvent PROC
;;;1043   //extern uint8_t	g_ConnectedDevice;
;;;1044   void algorithm_PendTouchEvent(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1045   {
000004  b087              SUB      sp,sp,#0x1c
;;;1046   	int i;
;;;1047   	int distX, distY;
;;;1048   	tXY_t pos, old_pos;
;;;1049   	uint8_t ucMoveTHD_X,ucMoveTHD_Y;
;;;1050   
;;;1051   #if (ID_MAPPING_CHANGE)
;;;1052   static uint8_t NewID = 50;
;;;1053   static uint8_t Id_Map[MAX_TOUCH_] = {0,};
;;;1054   static uint16_t NonTouchCnt = 0;
;;;1055   #endif
;;;1056   
;;;1057   	hal_set_overlap_pen();
000006  f7fffffe          BL       hal_set_overlap_pen
;;;1058   
;;;1059   	memset(HID_status,0,HID_MAX_TOUCH);
00000a  48bb              LDR      r0,|L4.760|
00000c  f7fffffe          BL       __ARM_common_memclr4_10
;;;1060   	memset(HID_id,0,HID_MAX_TOUCH);
000010  48ba              LDR      r0,|L4.764|
000012  f7fffffe          BL       __ARM_common_memclr4_10
;;;1061   	memset(HID_x,0,HID_MAX_TOUCH);
000016  48ba              LDR      r0,|L4.768|
000018  f7fffffe          BL       __ARM_common_memclr4_10
;;;1062   	memset(HID_y,0,HID_MAX_TOUCH);
00001c  48b9              LDR      r0,|L4.772|
00001e  f7fffffe          BL       __ARM_common_memclr4_10
;;;1063   
;;;1064   	eSWIPPacketFormatId_t id = protocol_swip_GetPacketFormatId();
000022  f7fffffe          BL       protocol_swip_GetPacketFormatId
000026  4682              MOV      r10,r0
;;;1065   #define SET_POS(tItem, pos)  \
;;;1066   	do{    \
;;;1067   			(tItem).tItem00.ucXHigh = ((pos).x >> 8) & 0xFF;    \
;;;1068   			(tItem).tItem00.ucYHigh = ((pos).y >> 8) & 0xFF;    \
;;;1069   			(tItem).tItem00.ucXLow = (pos).x & 0xFF;    \
;;;1070   			(tItem).tItem00.ucYLow = (pos).y & 0xFF;    \
;;;1071   		} while(0)
;;;1072   
;;;1073   	//if(g_ConnectedDevice == I2C_CONNECT_PC)
;;;1074   	{
;;;1075   		protocol_swip_InitTouchEventBuffer();
000028  f7fffffe          BL       protocol_swip_InitTouchEventBuffer
;;;1076   		//    protocol_hid_InitTouchEventBuffer();
;;;1077   	}
;;;1078   	
;;;1079   	hid_index=0;
00002c  48b6              LDR      r0,|L4.776|
;;;1080   	
;;;1081   #if (SWIP_QUEUE_MODE)
;;;1082   	thisInfo->bQueueStart 	= 0;
00002e  4db7              LDR      r5,|L4.780|
000030  2600              MOVS     r6,#0                 ;1079
000032  6006              STR      r6,[r0,#0]  ; hid_index
000034  68e9              LDR      r1,[r5,#0xc]  ; thisInfo
000036  f5015080          ADD      r0,r1,#0x1000
00003a  f880615a          STRB     r6,[r0,#0x15a]
;;;1083   	#if (SWIP_QUEUE_MODE == 2)
;;;1084   		thisInfo->bTouchOffFlag	= 0;
00003e  f880615b          STRB     r6,[r0,#0x15b]
;;;1085   	#endif
;;;1086   #endif
;;;1087   
;;;1088   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1089   	tTouchItemType_t touchItemType;
;;;1090   	memset(&touchItemType, 0, sizeof(tTouchItemType_t));
;;;1091   	/*
;;;1092   	 * TODO : finger mode를 기본으로 설정.
;;;1093   	 * algorithm을 거친 후 touch type에 따른 flag를 setting 해야 함.
;;;1094   	 */
;;;1095   	touchItemType.active_stylus_hover = YES;
;;;1096   	touchItemType.active_stylus = YES;
;;;1097   	touchItemType.passive_stylus = YES;
;;;1098   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1099   
;;;1100   #ifdef LocalFingerNoiseRemove
;;;1101   	#if (PEN_FINGER_1TOUCH_REPORT == NO)
;;;1102   	if(thisInfo->bLocal_sensing == YES /*&& thisInfo->tCoord_local_dsp.PenContactCnt < 100*/)
;;;1103   	{	
;;;1104   		uint8_t Label_num = 0;
;;;1105   		for( i=MAX_TOUCH_; i--; )
;;;1106   		{		
;;;1107   			if (thisInfo->tCoord.tPos.vusS[i] > 0)
;;;1108   			{
;;;1109   				Label_num++;
;;;1110   			}
;;;1111   		}
;;;1112   	
;;;1113   		for( i=MAX_TOUCH_; i--; )
;;;1114   		{
;;;1115   			distX = algorithm_coord_calc_distance(thisInfo->tCoord.tPos.tXY[i], thisInfo->tCoord_local_dsp.tPos.tXY);
;;;1116   			
;;;1117   			if( distX > 1024 && ((thisInfo->tCoord.tPos.MaxDelta[i] > thisModeConf->CoordTracking.sFirstTouchOnMaxCellVal && Label_num > 1) || (thisInfo->tCoord.tPos.MaxDelta[i] > (thisModeConf->CoordTracking.sFirstTouchOnMaxCellVal+20) && Label_num == 1)) )
;;;1118   			{
;;;1119   			}
;;;1120   			else
;;;1121   			{
;;;1122   				thisInfo->tCoord.tPos.vusS[i] = 0;
;;;1123   				thisInfo->tCoord.cScreenDebCnt[i] = 0;
;;;1124   			}
;;;1125   		}
;;;1126   	}
;;;1127   	#endif
;;;1128   #endif
;;;1129   	
;;;1130   	if(thisModeConf->Palm.bPalm_WholeTouchRemove && thisInfo->bIsPalm == YES)
000042  68aa              LDR      r2,[r5,#8]  ; thisModeConf
000044  f892220a          LDRB     r2,[r2,#0x20a]
000048  b1a2              CBZ      r2,|L4.116|
00004a  f89000da          LDRB     r0,[r0,#0xda]
00004e  2801              CMP      r0,#1
000050  d110              BNE      |L4.116|
;;;1131   	{
;;;1132   		for( i=MAX_TOUCH_; i--; )thisInfo->tCoord.tPos.vusS[i] = 0;
000052  200a              MOVS     r0,#0xa
000054  2201              MOVS     r2,#1
000056  f1000c01          ADD      r12,r0,#1
                  |L4.90|
00005a  1e43              SUBS     r3,r0,#1
00005c  eb010343          ADD      r3,r1,r3,LSL #1
000060  1e80              SUBS     r0,r0,#2
000062  f8a364ef          STRH     r6,[r3,#0x4ef]
000066  eb010340          ADD      r3,r1,r0,LSL #1
00006a  1c92              ADDS     r2,r2,#2
00006c  f8a364ef          STRH     r6,[r3,#0x4ef]
000070  4562              CMP      r2,r12
000072  dbf2              BLT      |L4.90|
                  |L4.116|
;;;1133   	}
;;;1134   
;;;1135   #if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN	
;;;1136   	algorithm_EdgeReportDelay();
;;;1137   #endif
;;;1138   	
;;;1139   	for (i = 0; i < MAX_TOUCH_; i++)
000074  2400              MOVS     r4,#0
000076  f04f0b01          MOV      r11,#1                ;1130
                  |L4.122|
;;;1140   	{
;;;1141   		//        bool_t bIsHover = NO;
;;;1142   		if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0)
00007a  68ea              LDR      r2,[r5,#0xc]  ; thisInfo
00007c  eb020144          ADD      r1,r2,r4,LSL #1
000080  f8b10cce          LDRH     r0,[r1,#0xcce]
000084  b138              CBZ      r0,|L4.150|
;;;1143   		{
;;;1144   //			old_pos = thisInfo->tCoord.tPastSentPos.tXY[i];
;;;1145   //			alogorithm_coord_modify_pos(&old_pos,&old_pos, i);
;;;1146   			old_pos.x = thisInfo->tCoord.tRealPastSentPos.tXY[i].x;
000086  eb0200c4          ADD      r0,r2,r4,LSL #3
00008a  f8d03d1f          LDR      r3,[r0,#0xd1f]
;;;1147   			old_pos.y = thisInfo->tCoord.tRealPastSentPos.tXY[i].y;
00008e  9302              STR      r3,[sp,#8]
000090  f8d00d23          LDR      r0,[r0,#0xd23]
000094  9003              STR      r0,[sp,#0xc]
                  |L4.150|
;;;1148   		}
;;;1149   
;;;1150   		if (thisInfo->tCoord.tPos.vusS[i] > 0)
000096  f8b104ef          LDRH     r0,[r1,#0x4ef]
00009a  2800              CMP      r0,#0
00009c  f00080c0          BEQ.W    |L4.544|
;;;1151   		{
;;;1152   			pos = thisInfo->tCoord.tPos.tXY[i];
0000a0  eb0200c4          ADD      r0,r2,r4,LSL #3
0000a4  f8d0249f          LDR      r2,[r0,#0x49f]
0000a8  9200              STR      r2,[sp,#0]
0000aa  f8d004a3          LDR      r0,[r0,#0x4a3]
;;;1153   			
;;;1154   //			if(thisModeConf->Palm.ucPalmDrawingOn > 1)
;;;1155   //				algorithm_width_height_calculation(i);
;;;1156   
;;;1157   			if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0)
0000ae  9001              STR      r0,[sp,#4]
0000b0  f8b10cce          LDRH     r0,[r1,#0xcce]
;;;1158   				alogorithm_coord_modify_pos(&old_pos,&pos, i);
;;;1159   			else
;;;1160   				alogorithm_coord_modify_pos(&pos, &pos, i);
0000b4  4622              MOV      r2,r4
0000b6  2800              CMP      r0,#0                 ;1157
0000b8  4669              MOV      r1,sp
0000ba  bf0c              ITE      EQ
0000bc  4608              MOVEQ    r0,r1
0000be  a802              ADDNE    r0,sp,#8              ;1158
0000c0  f7fffffe          BL       alogorithm_coord_modify_pos
;;;1161   		}
;;;1162   		
;;;1163   		if (thisInfo->tCoord.tPos.vusS[i] > 0)
0000c4  68ea              LDR      r2,[r5,#0xc]  ; thisInfo
0000c6  eb020044          ADD      r0,r2,r4,LSL #1
0000ca  f8b014ef          LDRH     r1,[r0,#0x4ef]
0000ce  2900              CMP      r1,#0
0000d0  d07e              BEQ      |L4.464|
;;;1164   		{
;;;1165   #if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
;;;1166   			if(i == 0)algorithm_BigFingerEdgeAccTest(&pos,&old_pos,0);
;;;1167   #endif
;;;1168   			
;;;1169   			distX = pos.x - old_pos.x;
0000d2  9b02              LDR      r3,[sp,#8]
0000d4  9900              LDR      r1,[sp,#0]
0000d6  eba10903          SUB      r9,r1,r3
;;;1170   			distY = pos.y - old_pos.y;
0000da  9b03              LDR      r3,[sp,#0xc]
0000dc  9901              LDR      r1,[sp,#4]
0000de  ebb10803          SUBS     r8,r1,r3
;;;1171   			if (distY < 0)
;;;1172   			distY = -distY;
0000e2  bf48              IT       MI
0000e4  f1c80800          RSBMI    r8,r8,#0
;;;1173   			if (distX < 0)
0000e8  f1b90f00          CMP      r9,#0
;;;1174   			distX = -distX;
0000ec  bfb8              IT       LT
0000ee  f1c90900          RSBLT    r9,r9,#0
;;;1175   
;;;1176   			if (!thisInfo->tCoord.bFirstLongDistanceMoved[i])
0000f2  1911              ADDS     r1,r2,r4
0000f4  f8911e23          LDRB     r1,[r1,#0xe23]
0000f8  2900              CMP      r1,#0
;;;1177   			{
;;;1178   				ucMoveTHD_X = thisModeConf->Coord.ucFirstMoveEventTHD;
;;;1179   				ucMoveTHD_Y = thisModeConf->Coord.ucFirstMoveEventTHD;
;;;1180   			}
;;;1181   			else
;;;1182   			{
;;;1183   				ucMoveTHD_X = thisModeConf->Coord.ucMoveEventTHD;
0000fa  68a9              LDR      r1,[r5,#8]  ; thisModeConf
0000fc  bf0c              ITE      EQ                    ;1178
0000fe  f8917097          LDRBEQ   r7,[r1,#0x97]         ;1178
000102  f8917098          LDRBNE   r7,[r1,#0x98]
;;;1184   				ucMoveTHD_Y = thisModeConf->Coord.ucMoveEventTHD;
;;;1185   			}
;;;1186   			
;;;1187   			if (thisInfo->tCoord.tPastSentPos.vusS[i] == 0 || (distY >= ucMoveTHD_Y) || (distX >= ucMoveTHD_X))
000106  f8b01cce          LDRH     r1,[r0,#0xcce]
00010a  2900              CMP      r1,#0
00010c  bf18              IT       NE
00010e  45b8              CMPNE    r8,r7
000110  bfb8              IT       LT
000112  45b9              CMPLT    r9,r7
;;;1188   			{
;;;1189   #if (ID_MAPPING_CHANGE)
;;;1190   				if (thisInfo->tCoord.tPastSentPos.vusS[i] == 0 )
;;;1191   				{
;;;1192   					NewID++;
;;;1193   					if(NewID > 30)NewID=1;
;;;1194   					Id_Map[i] = NewID;
;;;1195   				}
;;;1196   #endif				
;;;1197   				uSWIPTouchItem_t tItem;
;;;1198   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1199   				tItem.tItem00.tInfo.b4FingerID = i + 1;					// id
;;;1200   				tItem.tItem00.tInfo.b1Status = TOUCH_STATUS_PRESS;		// status
;;;1201   				tItem.tItem00.tInfo.b6Type = (touchItemType.finger << TOUCH_TYPE_FINGER) |
;;;1202   									  (touchItemType.glove << TOUCH_TYPE_GLOVE) |
;;;1203   									  (touchItemType.hover << TOUCH_TYPE_HOVER) |
;;;1204   									  (touchItemType.passive_stylus << TOUCH_TYPE_PASSIVE_STYLUS) |
;;;1205   									  (touchItemType.active_stylus << TOUCH_TYPE_ACTIVE_STYLUS) |
;;;1206   									  (touchItemType.active_stylus_hover << TOUCH_TYPE_ACTIVE_STYLUS_HOVER);
;;;1207   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1208   				tItem.tItem00.tInfo.bTouch = YES;
;;;1209   				tItem.tItem00.tInfo.bHover = NO;
;;;1210   				tItem.tItem00.tInfo.bScreen = YES;
;;;1211   				tItem.tItem00.tInfo.bPalm = thisInfo->bIsPalm;
;;;1212   	#if (ID_MAPPING_CHANGE)
;;;1213   				tItem.tItem00.tInfo.b4FingerID = Id_Map[i];
;;;1214   	#else
;;;1215   				tItem.tItem00.tInfo.b4FingerID = i + 1;
;;;1216   	#endif
;;;1217   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1218   				tItem.tItem00.ucRowStart = 0;
;;;1219   
;;;1220   				SET_POS(tItem, pos);
;;;1221   				tItem.tItem00.ucWidth = MIN(thisInfo->tCoord.tPos.vusR[i], UINT8_MAX);
;;;1222   				//                tItem.tItem00.ucWidth = thisInfo->tCoord.cScreenDebCnt[i];
;;;1223   				
;;;1224   //				tItem.tItem02.usWidth = thisInfo->tCoord.tPos.vusW[i];
;;;1225   //				tItem.tItem02.usHeight = thisInfo->tCoord.tPos.vusH[i];
;;;1226   				
;;;1227   				if(id == 0)
;;;1228   				{
;;;1229   					tItem.tItem00.usStrength = thisInfo->tCoord.tPos.vusS[i];
;;;1230   				}
;;;1231   #if !(ID_MAPPING_CHANGE)
;;;1232   				protocol_swip_PushTouchEvent(&tItem);
;;;1233   #endif				
;;;1234   				protocol_hid_PushTouchEvent(&tItem);
;;;1235   
;;;1236   				if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0 && ((distY >= ucMoveTHD_Y) || (distX >= ucMoveTHD_X)) ) //distance moved.
;;;1237   				{
;;;1238   					thisInfo->tCoord.bFirstLongDistanceMoved[i] = YES;
;;;1239   				}
;;;1240   				else //1st touch.
;;;1241   				{
;;;1242   					thisInfo->tCoord.bFirstLongDistanceMoved[i] = NO;
;;;1243   				}
;;;1244   
;;;1245   				thisInfo->tCoord.tPastSentPos.tXY[i].x = thisInfo->tCoord.tPos.tXY[i].x;
;;;1246   				thisInfo->tCoord.tPastSentPos.tXY[i].y = thisInfo->tCoord.tPos.tXY[i].y;
;;;1247   				thisInfo->tCoord.tPastSentPos.vusS[i] = thisInfo->tCoord.tPos.vusS[i];
;;;1248   				thisInfo->tCoord.tPastSentPos.vusR[i] = thisInfo->tCoord.tPos.vusR[i];
;;;1249   //				thisInfo->tCoord.tPastSentPos.vusW[i] = thisInfo->tCoord.tPos.vusW[i];
;;;1250   //				thisInfo->tCoord.tPastSentPos.vusH[i] = thisInfo->tCoord.tPos.vusH[i];
;;;1251   				
;;;1252   				thisInfo->tCoord.tRealPastSentPos.tXY[i].x = pos.x;
;;;1253   				thisInfo->tCoord.tRealPastSentPos.tXY[i].y = pos.y;
;;;1254   			}
;;;1255   			else
;;;1256   			{
;;;1257   				uSWIPTouchItem_t tItem;
;;;1258   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1259   				tItem.tItem00.tInfo.b4FingerID = i + 1;					// id
;;;1260   				tItem.tItem00.tInfo.b1Status = TOUCH_STATUS_PRESS;		// status
;;;1261   				tItem.tItem00.tInfo.b6Type = (touchItemType.finger << TOUCH_TYPE_FINGER) |
;;;1262   									  (touchItemType.glove << TOUCH_TYPE_GLOVE) |
;;;1263   									  (touchItemType.hover << TOUCH_TYPE_HOVER) |
;;;1264   									  (touchItemType.passive_stylus << TOUCH_TYPE_PASSIVE_STYLUS) |
;;;1265   									  (touchItemType.active_stylus << TOUCH_TYPE_ACTIVE_STYLUS) |
;;;1266   									  (touchItemType.active_stylus_hover << TOUCH_TYPE_ACTIVE_STYLUS_HOVER);
;;;1267   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1268   				tItem.tItem00.tInfo.bTouch = YES;
000114  f89d1010          LDRB     r1,[sp,#0x10]
;;;1269   				tItem.tItem00.tInfo.bHover = NO;
;;;1270   				tItem.tItem00.tInfo.bScreen = YES;
000118  f5025280          ADD      r2,r2,#0x1000
00011c  f0410180          ORR      r1,r1,#0x80           ;1268
000120  f0210120          BIC      r1,r1,#0x20           ;1269
;;;1271   				tItem.tItem00.tInfo.bPalm = thisInfo->bIsPalm;
000124  f89220da          LDRB     r2,[r2,#0xda]
000128  f0410140          ORR      r1,r1,#0x40           ;1270
00012c  f3621104          BFI      r1,r2,#4,#1
;;;1272   	#if (ID_MAPPING_CHANGE)
;;;1273   				tItem.tItem00.tInfo.b4FingerID = Id_Map[i];
;;;1274   	#else
;;;1275   				tItem.tItem00.tInfo.b4FingerID = i + 1;
000130  f1040201          ADD      r2,r4,#1
000134  f3620103          BFI      r1,r2,#0,#4
000138  f88d1010          STRB     r1,[sp,#0x10]
;;;1276   	#endif
;;;1277   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1278   				tItem.tItem00.ucRowStart = 0;
00013c  f88d6018          STRB     r6,[sp,#0x18]
000140  db4d              BLT      |L4.478|
000142  9900              LDR      r1,[sp,#0]            ;1220
000144  0a09              LSRS     r1,r1,#8              ;1220
000146  f88d1011          STRB     r1,[sp,#0x11]         ;1220
00014a  9901              LDR      r1,[sp,#4]            ;1220
00014c  0a09              LSRS     r1,r1,#8              ;1220
00014e  f88d1012          STRB     r1,[sp,#0x12]         ;1220
000152  9900              LDR      r1,[sp,#0]            ;1220
000154  f88d1013          STRB     r1,[sp,#0x13]         ;1220
000158  9901              LDR      r1,[sp,#4]            ;1220
00015a  f88d1014          STRB     r1,[sp,#0x14]         ;1220
00015e  f8b01503          LDRH     r1,[r0,#0x503]        ;1221
000162  29ff              CMP      r1,#0xff              ;1221
000164  bf28              IT       CS                    ;1221
000166  21ff              MOVCS    r1,#0xff              ;1221
000168  f88d1015          STRB     r1,[sp,#0x15]         ;1221
00016c  f1ba0f00          CMP      r10,#0                ;1227
000170  bf04              ITT      EQ                    ;1229
000172  f8b004ef          LDRHEQ   r0,[r0,#0x4ef]        ;1229
000176  f8ad0016          STRHEQ   r0,[sp,#0x16]         ;1229
00017a  a804              ADD      r0,sp,#0x10           ;1232
00017c  f7fffffe          BL       protocol_swip_PushTouchEvent
000180  a804              ADD      r0,sp,#0x10           ;1234
000182  f7fffffe          BL       protocol_hid_PushTouchEvent
000186  68e8              LDR      r0,[r5,#0xc]          ;1236  ; thisInfo
000188  eb000144          ADD      r1,r0,r4,LSL #1       ;1236
00018c  f8b12cce          LDRH     r2,[r1,#0xcce]        ;1236
000190  b13a              CBZ      r2,|L4.418|
000192  463a              MOV      r2,r7                 ;1236
000194  45b8              CMP      r8,r7                 ;1236
000196  bfb2              ITEE     LT                    ;1236
000198  4591              CMPLT    r9,r2                 ;1236
00019a  1902              ADDGE    r2,r0,r4              ;1238
00019c  f882be23          STRBGE   r11,[r2,#0xe23]       ;1238
0001a0  da02              BGE      |L4.424|
                  |L4.418|
0001a2  1902              ADDS     r2,r0,r4              ;1242
0001a4  f8826e23          STRB     r6,[r2,#0xe23]        ;1242
                  |L4.424|
0001a8  eb0000c4          ADD      r0,r0,r4,LSL #3       ;1245
0001ac  f8d0249f          LDR      r2,[r0,#0x49f]        ;1245
0001b0  f8c02c7e          STR      r2,[r0,#0xc7e]        ;1245
0001b4  f8d024a3          LDR      r2,[r0,#0x4a3]        ;1246
0001b8  f8c02c82          STR      r2,[r0,#0xc82]        ;1246
0001bc  f8b124ef          LDRH     r2,[r1,#0x4ef]        ;1247
0001c0  f8a12cce          STRH     r2,[r1,#0xcce]        ;1247
0001c4  f8b12503          LDRH     r2,[r1,#0x503]        ;1248
0001c8  f8a12ce2          STRH     r2,[r1,#0xce2]        ;1248
0001cc  9900              LDR      r1,[sp,#0]            ;1252
0001ce  e000              B        |L4.466|
                  |L4.464|
0001d0  e026              B        |L4.544|
                  |L4.466|
0001d2  f8c01d1f          STR      r1,[r0,#0xd1f]        ;1252
0001d6  9901              LDR      r1,[sp,#4]            ;1253
0001d8  f8c01d23          STR      r1,[r0,#0xd23]        ;1253
0001dc  e057              B        |L4.654|
                  |L4.478|
;;;1279   				SET_POS(tItem, old_pos);
0001de  9902              LDR      r1,[sp,#8]
0001e0  f88d3014          STRB     r3,[sp,#0x14]
0001e4  0a09              LSRS     r1,r1,#8
0001e6  f88d1011          STRB     r1,[sp,#0x11]
0001ea  0a19              LSRS     r1,r3,#8
0001ec  f88d1012          STRB     r1,[sp,#0x12]
0001f0  9902              LDR      r1,[sp,#8]
0001f2  f88d1013          STRB     r1,[sp,#0x13]
;;;1280   				tItem.tItem00.ucWidth = MIN(thisInfo->tCoord.tPos.vusR[i], UINT8_MAX);
0001f6  f8b01503          LDRH     r1,[r0,#0x503]
0001fa  29ff              CMP      r1,#0xff
0001fc  bf28              IT       CS
0001fe  21ff              MOVCS    r1,#0xff
000200  f88d1015          STRB     r1,[sp,#0x15]
;;;1281   
;;;1282   				//To do	-> Old Width, Height
;;;1283   //				tItem.tItem02.usWidth = thisInfo->tCoord.tPos.vusW[i];
;;;1284   //				tItem.tItem02.usHeight = thisInfo->tCoord.tPos.vusH[i];
;;;1285   				
;;;1286   				if(id == 0)
000204  f1ba0f00          CMP      r10,#0
;;;1287   				{
;;;1288   					tItem.tItem00.usStrength = thisInfo->tCoord.tPos.vusS[i];
000208  bf04              ITT      EQ
00020a  f8b004ef          LDRHEQ   r0,[r0,#0x4ef]
00020e  f8ad0016          STRHEQ   r0,[sp,#0x16]
                  |L4.530|
;;;1289   				}
;;;1290   #if !(ID_MAPPING_CHANGE)
;;;1291   				protocol_swip_PushTouchEvent(&tItem);
000212  a804              ADD      r0,sp,#0x10
000214  f7fffffe          BL       protocol_swip_PushTouchEvent
;;;1292   #endif				
;;;1293   				protocol_hid_PushTouchEvent(&tItem);
000218  a804              ADD      r0,sp,#0x10
00021a  f7fffffe          BL       protocol_hid_PushTouchEvent
;;;1294   				
;;;1295   			}
00021e  e036              B        |L4.654|
                  |L4.544|
;;;1296   #if USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE
;;;1297   			thisInfo->bIsIdleToActive = NO;
;;;1298   #endif /* USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE */
;;;1299   		}
;;;1300   		else if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0)
000220  4611              MOV      r1,r2
000222  eb020244          ADD      r2,r2,r4,LSL #1
000226  f8b20cce          LDRH     r0,[r2,#0xcce]
00022a  b378              CBZ      r0,|L4.652|
;;;1301   		{
;;;1302   			
;;;1303   		#if (SWIP_QUEUE_MODE == 2)
;;;1304   			thisInfo->bTouchOffFlag = 1;
00022c  f5015380          ADD      r3,r1,#0x1000
000230  f883b15b          STRB     r11,[r3,#0x15b]
;;;1305   		#endif
;;;1306   			
;;;1307   			uSWIPTouchItem_t tItem;
;;;1308   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1309   			tItem.tItem00.tInfo.b4FingerID = i + 1;					// id
;;;1310   			tItem.tItem00.tInfo.b1Status = TOUCH_STATUS_RELEASE;		// status
;;;1311   			tItem.tItem00.tInfo.b6Type = (touchItemType.finger << TOUCH_TYPE_FINGER) |
;;;1312   								  (touchItemType.glove << TOUCH_TYPE_GLOVE) |
;;;1313   								  (touchItemType.hover << TOUCH_TYPE_HOVER) |
;;;1314   								  (touchItemType.passive_stylus << TOUCH_TYPE_PASSIVE_STYLUS) |
;;;1315   								  (touchItemType.active_stylus << TOUCH_TYPE_ACTIVE_STYLUS) |
;;;1316   								  (touchItemType.active_stylus_hover << TOUCH_TYPE_ACTIVE_STYLUS_HOVER);
;;;1317   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1318   			tItem.tItem00.tInfo.bTouch = NO;
000234  f89d0010          LDRB     r0,[sp,#0x10]
;;;1319   			tItem.tItem00.tInfo.bHover = NO;
;;;1320   			tItem.tItem00.tInfo.bScreen = YES;
;;;1321   			tItem.tItem00.tInfo.bPalm = thisInfo->bIsPalm;
000238  f89330da          LDRB     r3,[r3,#0xda]
00023c  f02000a0          BIC      r0,r0,#0xa0           ;1319
000240  f0400040          ORR      r0,r0,#0x40           ;1320
000244  f3631004          BFI      r0,r3,#4,#1
;;;1322   	#if (ID_MAPPING_CHANGE)
;;;1323   			tItem.tItem00.tInfo.b4FingerID = Id_Map[i];
;;;1324   	#else
;;;1325   			tItem.tItem00.tInfo.b4FingerID = i + 1;
000248  1c63              ADDS     r3,r4,#1
00024a  f3630003          BFI      r0,r3,#0,#4
00024e  f88d0010          STRB     r0,[sp,#0x10]
;;;1326   	#endif
;;;1327   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1328   			tItem.tItem00.ucRowStart = 0;
;;;1329   
;;;1330   #if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
;;;1331   			if(i == 0)algorithm_BigFingerEdgeAccTest(&pos,&old_pos,1);			
;;;1332   #endif
;;;1333   			
;;;1334   			SET_POS(tItem, old_pos);	
000252  9802              LDR      r0,[sp,#8]
000254  f88d6018          STRB     r6,[sp,#0x18]         ;1328
000258  0a00              LSRS     r0,r0,#8
00025a  f88d0011          STRB     r0,[sp,#0x11]
00025e  9803              LDR      r0,[sp,#0xc]
000260  0a00              LSRS     r0,r0,#8
000262  f88d0012          STRB     r0,[sp,#0x12]
000266  9802              LDR      r0,[sp,#8]
000268  f88d0013          STRB     r0,[sp,#0x13]
00026c  9803              LDR      r0,[sp,#0xc]
00026e  f88d0014          STRB     r0,[sp,#0x14]
;;;1335   			tItem.tItem00.ucWidth = 0;
000272  f88d6015          STRB     r6,[sp,#0x15]
;;;1336   			//			thisInfo->bGhostState = NO;
;;;1337   
;;;1338   			if(id == 0)
000276  f1ba0f00          CMP      r10,#0
;;;1339   			{
;;;1340   				tItem.tItem00.usStrength =thisInfo->tCoord.tPos.vusS[i];
00027a  bf04              ITT      EQ
00027c  f8b204ef          LDRHEQ   r0,[r2,#0x4ef]
000280  f8ad0016          STRHEQ   r0,[sp,#0x16]
;;;1341   			}
;;;1342   
;;;1343   			thisInfo->tCoord.bFirstLongDistanceMoved[i] = NO;
000284  1908              ADDS     r0,r1,r4
000286  f8806e23          STRB     r6,[r0,#0xe23]
;;;1344   #if !(ID_MAPPING_CHANGE)
;;;1345   			protocol_swip_PushTouchEvent(&tItem);
;;;1346   #endif
;;;1347   			protocol_hid_PushTouchEvent(&tItem);
;;;1348   		}
00028a  e7c2              B        |L4.530|
                  |L4.652|
00028c  e7ff              B        |L4.654|
                  |L4.654|
;;;1349   		thisInfo->tCoord.tPastSentPos.vusS[i] = thisInfo->tCoord.tPos.vusS[i];
00028e  68e8              LDR      r0,[r5,#0xc]  ; thisInfo
000290  eb000044          ADD      r0,r0,r4,LSL #1
000294  1c64              ADDS     r4,r4,#1
000296  f8b014ef          LDRH     r1,[r0,#0x4ef]
00029a  f8a01cce          STRH     r1,[r0,#0xcce]
00029e  2c0a              CMP      r4,#0xa
0002a0  f6ffaeeb          BLT      |L4.122|
;;;1350   	}
;;;1351   #if (SWIP_QUEUE_MODE)
;;;1352   	if(thisInfo->bQueueStart == 1){
0002a4  68ea              LDR      r2,[r5,#0xc]  ; thisInfo
0002a6  f5025080          ADD      r0,r2,#0x1000
0002aa  f890115a          LDRB     r1,[r0,#0x15a]
0002ae  2901              CMP      r1,#1
0002b0  d115              BNE      |L4.734|
;;;1353   	#if (SWIP_QUEUE_MODE == 2)
;;;1354   		if(thisInfo->QueueFront == thisInfo->QueueRear || thisInfo->bTouchOffFlag )
0002b2  f8903159          LDRB     r3,[r0,#0x159]
0002b6  f8901158          LDRB     r1,[r0,#0x158]
0002ba  428b              CMP      r3,r1
0002bc  d002              BEQ      |L4.708|
0002be  f890315b          LDRB     r3,[r0,#0x15b]
0002c2  b163              CBZ      r3,|L4.734|
                  |L4.708|
;;;1355   	#endif
;;;1356   		{
;;;1357   			thisInfo->QueueRear++;
;;;1358   			thisInfo->QueueRear = (thisInfo->QueueRear) % SWIP_QUEUE_SIZE;
0002c4  4c12              LDR      r4,|L4.784|
0002c6  1c49              ADDS     r1,r1,#1              ;1354
0002c8  b2c9              UXTB     r1,r1                 ;1357
0002ca  46a4              MOV      r12,r4
0002cc  2300              MOVS     r3,#0
0002ce  fbe1c304          UMLAL    r12,r3,r1,r4
0002d2  085b              LSRS     r3,r3,#1
0002d4  eba303c3          SUB      r3,r3,r3,LSL #3
0002d8  4419              ADD      r1,r1,r3
0002da  f8801158          STRB     r1,[r0,#0x158]
                  |L4.734|
;;;1359   		}
;;;1360   	}
;;;1361   #endif	
;;;1362   	//°u°A A¤º¸ ¸ðμI ¾÷μ￥AIÆ®.
;;;1363   	thisInfo->tCoord.tPastSentPos.sFinger_ = thisInfo->tCoord.tPos.sFinger_;
0002de  f892049e          LDRB     r0,[r2,#0x49e]
0002e2  f8820c7d          STRB     r0,[r2,#0xc7d]
;;;1364   //	thisInfo->bWasPalm = thisInfo->bIsPalm;
;;;1365   
;;;1366   //	if ((CheckI2CReady() == 0))
;;;1367   #if !(ID_MAPPING_CHANGE)
;;;1368   	protocol_swip_SendTouchEvent(); // 여기서 뻗음
0002e6  f7fffffe          BL       protocol_swip_SendTouchEvent
;;;1369   #endif
;;;1370   //	 protocol_hid_SendTouchEvent();
;;;1371   
;;;1372   #ifdef JOSH3_PEN_TEST
;;;1373   	SendPenData();
;;;1374   #else
;;;1375   #ifdef ADD_TOUCH
;;;1376   	SendTouchData();
0002ea  f7fffffe          BL       SendTouchData
;;;1377   #endif
;;;1378   #endif
;;;1379   #if (ID_MAPPING_CHANGE)	
;;;1380   	if(thisInfo->tCoord.tPos.sFinger_ == 0 && thisInfo->tCoord.tPastPos[0].sFinger_ == 0){if(NonTouchCnt++ > 32767)NonTouchCnt=30;}
;;;1381   	else NonTouchCnt = 0;
;;;1382   	
;;;1383   	if(NonTouchCnt >= 30)
;;;1384   	{
;;;1385   		NewID = 30;
;;;1386   		memset(Id_Map,0,sizeof(Id_Map));
;;;1387   	}
;;;1388   #endif	
;;;1389   	hal_clear_overlap_pen();
0002ee  f7fffffe          BL       hal_clear_overlap_pen
;;;1390   
;;;1391   #if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
;;;1392   	if(thisInfo->tCoord.tPos.sFinger_==0 || thisInfo->tCoord.tPos.sFinger_>1)
;;;1393   	{
;;;1394   		if(bBigFingerEdgeTestEn[0] || bBigFingerEdgeTestEn[1] || bBigFingerEdgeTestEn[2] || bBigFingerEdgeTestEn[3])
;;;1395   		{
;;;1396   			ucBigFingerEdgeTest_MoveEventTHD_Change=0;
;;;1397   			memset(bBigFingerEdgeTestFlag,0,sizeof(bBigFingerEdgeTestFlag));
;;;1398   			if(thisInfo->tCoord.tPos.sFinger_==0)bBigFingerEdgeTestEn[0]=bBigFingerEdgeTestEn[1]=bBigFingerEdgeTestEn[2]=bBigFingerEdgeTestEn[3]=0;
;;;1399   		}
;;;1400   	}	
;;;1401   #endif	
;;;1402   }
0002f2  b007              ADD      sp,sp,#0x1c
0002f4  e8bd8ff0          POP      {r4-r11,pc}
;;;1403   
                          ENDP

                  |L4.760|
                          DCD      HID_status
                  |L4.764|
                          DCD      HID_id
                  |L4.768|
                          DCD      HID_x
                  |L4.772|
                          DCD      HID_y
                  |L4.776|
                          DCD      hid_index
                  |L4.780|
                          DCD      ||.data||
                  |L4.784|
                          DCD      0x49249249

                          AREA ||i.algorithm_calc_angle_inter_2points||, CODE, READONLY, ALIGN=2

                  algorithm_calc_angle_inter_2points PROC
;;;571    #ifndef TILT_OPCODE
;;;572    int32_t algorithm_calc_angle_inter_2points(int diff_x, int diff_y)
000000  e92d03f0          PUSH     {r4-r9}
;;;573    {
;;;574    	int angle = 0;
;;;575    
;;;576    //	int diff_x, diff_y;
;;;577    
;;;578    //	diff_x = _tPos2.x - _tPos1.x;
;;;579    //	diff_y = _tPos2.y - _tPos1.y;
;;;580    
;;;581    	if( diff_x > 0  )
;;;582    	{
;;;583    		if( diff_y > 0 )
;;;584    		{
;;;585    			if( diff_x >= diff_y )
;;;586    				angle = sucArcTanLookUpTable[(diff_y * 100)/diff_x];
000004  f04f0364          MOV      r3,#0x64
000008  fb01f503          MUL      r5,r1,r3
;;;587    			else
;;;588    				angle = 9000 - sucArcTanLookUpTable[(diff_x * 100)/diff_y];
;;;589    		}
;;;590    		else if( diff_y < 0 )
;;;591    		{
;;;592    			if( diff_x >= -(diff_y) )
;;;593    				angle = 36000 - sucArcTanLookUpTable[(-diff_y * 100)/diff_x];
00000c  f06f0c63          MVN      r12,#0x63
000010  1e02              SUBS     r2,r0,#0              ;573
000012  4b3d              LDR      r3,|L5.264|
000014  fb01f40c          MUL      r4,r1,r12
000018  f04f0000          MOV      r0,#0                 ;574
00001c  f2423728          MOV      r7,#0x2328            ;588
;;;594    			else
;;;595    				angle = 27000 + sucArcTanLookUpTable[(diff_x * 100)/-diff_y];
000020  f6461878          MOV      r8,#0x6978
000024  f1c10c00          RSB      r12,r1,#0             ;592
000028  dd2c              BLE      |L5.132|
00002a  2664              MOVS     r6,#0x64              ;588
00002c  4356              MULS     r6,r2,r6              ;588
00002e  2900              CMP      r1,#0                 ;583
000030  dd10              BLE      |L5.84|
000032  4291              CMP      r1,r2                 ;585
000034  bfdf              ITTTT    LE                    ;586
000036  fb95f0f2          SDIVLE   r0,r5,r2              ;586
00003a  f8330010          LDRHLE   r0,[r3,r0,LSL #1]     ;586
;;;596    		}
;;;597    		else
;;;598    		{
;;;599    			angle = 0;
;;;600    		}
;;;601    	}
;;;602    	else if( diff_x < 0 )
;;;603    	{
;;;604    		if( diff_y > 0 )
;;;605    		{
;;;606    			if( -diff_x < diff_y )
;;;607    				angle = 9000 + sucArcTanLookUpTable[(-diff_x * 100)/diff_y];
;;;608    			else
;;;609    				angle = 18000 - sucArcTanLookUpTable[(diff_y * 100)/-diff_x];
;;;610    		}
;;;611    		else if( diff_y < 0 )
;;;612    		{
;;;613    			if( -diff_x >= -diff_y )
;;;614    				angle = 18000 + sucArcTanLookUpTable[(-diff_y * 100)/-diff_x];
;;;615    			else
;;;616    				angle = 27000 - sucArcTanLookUpTable[(-diff_x * 100)/-diff_y];
;;;617    		}
;;;618    		else
;;;619    		{
;;;620    			angle = 18000;
;;;621    		}
;;;622    	}
;;;623    	else
;;;624    	{
;;;625    		if( diff_y > 0 )
;;;626    			angle = 9000;
;;;627    		else if( diff_y < 0 )
;;;628    		{
;;;629    			angle = 27000;
;;;630    		}
;;;631    	}
;;;632    
;;;633    	return angle;
;;;634    }
00003e  e8bd03f0          POPLE    {r4-r9}
000042  4770              BXLE     lr
000044  fb96f0f1          SDIV     r0,r6,r1              ;588
000048  f8330010          LDRH     r0,[r3,r0,LSL #1]     ;588
00004c  1a38              SUBS     r0,r7,r0              ;588
00004e  e8bd03f0          POP      {r4-r9}
000052  4770              BX       lr
                  |L5.84|
000054  bfa4              ITT      GE
000056  e8bd03f0          POPGE    {r4-r9}
00005a  4770              BXGE     lr
00005c  4562              CMP      r2,r12                ;592
00005e  db09              BLT      |L5.116|
000060  fb94f0f2          SDIV     r0,r4,r2              ;593
000064  f64841a0          MOV      r1,#0x8ca0            ;593
000068  f8330010          LDRH     r0,[r3,r0,LSL #1]     ;593
00006c  e8bd03f0          POP      {r4-r9}
000070  1a08              SUBS     r0,r1,r0              ;593
000072  4770              BX       lr
                  |L5.116|
000074  fb96f0fc          SDIV     r0,r6,r12             ;595
000078  f8330010          LDRH     r0,[r3,r0,LSL #1]     ;595
00007c  4440              ADD      r0,r0,r8              ;595
00007e  e8bd03f0          POP      {r4-r9}
000082  4770              BX       lr
                  |L5.132|
000084  da35              BGE      |L5.242|
000086  f06f0063          MVN      r0,#0x63              ;607
00008a  fb02f600          MUL      r6,r2,r0              ;607
00008e  4250              RSBS     r0,r2,#0              ;606
000090  f2446950          MOV      r9,#0x4650            ;609
000094  2900              CMP      r1,#0                 ;604
000096  bf08              IT       EQ                    ;620
000098  f2446050          MOVEQ    r0,#0x4650            ;620
00009c  dd12              BLE      |L5.196|
00009e  4281              CMP      r1,r0                 ;606
0000a0  dd07              BLE      |L5.178|
0000a2  fb96f0f1          SDIV     r0,r6,r1              ;607
0000a6  f8330010          LDRH     r0,[r3,r0,LSL #1]     ;607
0000aa  4438              ADD      r0,r0,r7              ;607
0000ac  e8bd03f0          POP      {r4-r9}
0000b0  4770              BX       lr
                  |L5.178|
0000b2  fb95f0f0          SDIV     r0,r5,r0              ;609
0000b6  f8330010          LDRH     r0,[r3,r0,LSL #1]     ;609
0000ba  eba90000          SUB      r0,r9,r0              ;609
0000be  e8bd03f0          POP      {r4-r9}
0000c2  4770              BX       lr
                  |L5.196|
0000c4  bfa4              ITT      GE
0000c6  e8bd03f0          POPGE    {r4-r9}
0000ca  4770              BXGE     lr
0000cc  4560              CMP      r0,r12                ;613
0000ce  db07              BLT      |L5.224|
0000d0  fb94f0f0          SDIV     r0,r4,r0              ;614
0000d4  f8330010          LDRH     r0,[r3,r0,LSL #1]     ;614
0000d8  4448              ADD      r0,r0,r9              ;614
0000da  e8bd03f0          POP      {r4-r9}
0000de  4770              BX       lr
                  |L5.224|
0000e0  fb96f0fc          SDIV     r0,r6,r12             ;616
0000e4  f8330010          LDRH     r0,[r3,r0,LSL #1]     ;616
0000e8  eba80000          SUB      r0,r8,r0              ;616
0000ec  e8bd03f0          POP      {r4-r9}
0000f0  4770              BX       lr
                  |L5.242|
0000f2  2900              CMP      r1,#0                 ;625
0000f4  bfb8              IT       LT                    ;629
0000f6  f6461078          MOVLT    r0,#0x6978            ;629
0000fa  bfc8              IT       GT                    ;626
0000fc  f2423028          MOVGT    r0,#0x2328            ;626
000100  e8bd03f0          POP      {r4-r9}
000104  4770              BX       lr
;;;635    #endif /* TILT_OPCODE */
                          ENDP

000106  0000              DCW      0x0000
                  |L5.264|
                          DCD      sucArcTanLookUpTable

                          AREA ||i.algorithm_calc_sqrt||, CODE, READONLY, ALIGN=1

                  algorithm_calc_sqrt PROC
;;;473    
;;;474    int32_t algorithm_calc_sqrt(int32_t d)
000000  2101              MOVS     r1,#1
;;;475    {
;;;476        uint32_t x = 1;
;;;477    
;;;478        x = (x + d/x)>>1;
000002  fbb0f1f1          UDIV     r1,r0,r1
000006  1c49              ADDS     r1,r1,#1
000008  0849              LSRS     r1,r1,#1
;;;479        x = (x + d/x)>>1;
00000a  fbb0f2f1          UDIV     r2,r0,r1
00000e  4411              ADD      r1,r1,r2
000010  0849              LSRS     r1,r1,#1
;;;480        x = (x + d/x)>>1;
000012  fbb0f2f1          UDIV     r2,r0,r1
000016  4411              ADD      r1,r1,r2
000018  0849              LSRS     r1,r1,#1
;;;481        x = (x + d/x)>>1;
00001a  fbb0f2f1          UDIV     r2,r0,r1
00001e  4411              ADD      r1,r1,r2
000020  0849              LSRS     r1,r1,#1
;;;482        x = (x + d/x)>>1;
000022  fbb0f2f1          UDIV     r2,r0,r1
000026  4411              ADD      r1,r1,r2
000028  0849              LSRS     r1,r1,#1
;;;483        x = (x + d/x)>>1;
00002a  fbb0f2f1          UDIV     r2,r0,r1
00002e  4411              ADD      r1,r1,r2
000030  0849              LSRS     r1,r1,#1
;;;484        x = (x + d/x)>>1;
000032  fbb0f2f1          UDIV     r2,r0,r1
000036  4411              ADD      r1,r1,r2
000038  0849              LSRS     r1,r1,#1
;;;485        x = (x + d/x)>>1;
00003a  fbb0f2f1          UDIV     r2,r0,r1
00003e  4411              ADD      r1,r1,r2
000040  0849              LSRS     r1,r1,#1
;;;486        x = (x + d/x)>>1;
000042  fbb0f2f1          UDIV     r2,r0,r1
000046  4411              ADD      r1,r1,r2
000048  0849              LSRS     r1,r1,#1
;;;487        x = (x + d/x)>>1;
00004a  fbb0f2f1          UDIV     r2,r0,r1
00004e  4411              ADD      r1,r1,r2
000050  0849              LSRS     r1,r1,#1
;;;488        x = (x + d/x)>>1;
000052  fbb0f2f1          UDIV     r2,r0,r1
000056  4411              ADD      r1,r1,r2
000058  0849              LSRS     r1,r1,#1
;;;489        x = (x + d/x)>>1;
00005a  fbb0f2f1          UDIV     r2,r0,r1
00005e  4411              ADD      r1,r1,r2
000060  0849              LSRS     r1,r1,#1
;;;490        x = (x + d/x)>>1;
000062  fbb0f2f1          UDIV     r2,r0,r1
000066  4411              ADD      r1,r1,r2
000068  0849              LSRS     r1,r1,#1
;;;491        x = (x + d/x)>>1;
00006a  fbb0f2f1          UDIV     r2,r0,r1
00006e  4411              ADD      r1,r1,r2
000070  0849              LSRS     r1,r1,#1
;;;492        x = (x + d/x)>>1;
000072  fbb0f0f1          UDIV     r0,r0,r1
000076  4408              ADD      r0,r0,r1
000078  0840              LSRS     r0,r0,#1
;;;493    
;;;494        return x;
;;;495    }
00007a  4770              BX       lr
;;;496    
                          ENDP


                          AREA ||i.algorithm_check_recal_cond||, CODE, READONLY, ALIGN=2

                  algorithm_check_recal_cond PROC
;;;1403   
;;;1404   void algorithm_check_recal_cond(void)
000000  4912              LDR      r1,|L7.76|
;;;1405   {
;;;1406   	thisInfo->bIsRecalCond  = NO;
000002  2200              MOVS     r2,#0
000004  68c8              LDR      r0,[r1,#0xc]  ; thisInfo
000006  7082              STRB     r2,[r0,#2]
;;;1407   	thisInfo->bIsRecalCond2 = NO;
000008  70c2              STRB     r2,[r0,#3]
;;;1408   
;;;1409   	thisInfo->bIsRecalCond = (
00000a  6889              LDR      r1,[r1,#8]  ; thisModeConf
00000c  f8d02025          LDR      r2,[r0,#0x25]
000010  f8d13027          LDR      r3,[r1,#0x27]
000014  429a              CMP      r2,r3
000016  db08              BLT      |L7.42|
;;;1410   			   (thisInfo->tDelta.iPosSum >= thisModeConf->BaseLine.iRecalCond1_PosSum_Thd)
;;;1411   			&& ((thisInfo->tDelta.iNegSum + thisInfo->tDelta.iPosSum) < thisModeConf->BaseLine.iRecalCond1_AccSum_Thd)
000018  f8d0302d          LDR      r3,[r0,#0x2d]
00001c  441a              ADD      r2,r2,r3
00001e  f8d1302b          LDR      r3,[r1,#0x2b]
000022  429a              CMP      r2,r3
000024  bfb8              IT       LT
000026  2201              MOVLT    r2,#1
000028  db00              BLT      |L7.44|
                  |L7.42|
00002a  2200              MOVS     r2,#0
                  |L7.44|
00002c  7082              STRB     r2,[r0,#2]
;;;1412   	);
;;;1413   	thisInfo->bIsRecalCond2 = (
00002e  f24102dd          MOV      r2,#0x10dd
000032  5c12              LDRB     r2,[r2,r0]
000034  b93a              CBNZ     r2,|L7.70|
;;;1414   			   (thisInfo->bTouchExpect == NO)
;;;1415   			&& (thisInfo->tDelta.iNegSum < thisModeConf->BaseLine.iRecalCond2_AccSum_Thd)
000036  f8d0202d          LDR      r2,[r0,#0x2d]
00003a  f8d1102f          LDR      r1,[r1,#0x2f]
00003e  428a              CMP      r2,r1
000040  bfb8              IT       LT
000042  2101              MOVLT    r1,#1
000044  db00              BLT      |L7.72|
                  |L7.70|
000046  2100              MOVS     r1,#0
                  |L7.72|
000048  70c1              STRB     r1,[r0,#3]
;;;1416   	);
;;;1417   }
00004a  4770              BX       lr
;;;1418   
                          ENDP

                  |L7.76|
                          DCD      ||.data||

                          AREA ||i.algorithm_init||, CODE, READONLY, ALIGN=2

                  algorithm_init PROC
;;;120    tAlgorithmInfo_t * tTempAlgorithmInfoDebug;
;;;121    void algorithm_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
;;;123    #if (USED_IDLE_MODE_CONTROL || USED_PEN_MODE_OPERATION || USED_LOCAL_IDLE_MODE_CONTROL || USED_NOISE_HOPPING_FREQ)
;;;124    	const tAppCommonConf_t * _ptAppCommonConf = NULL;
;;;125    	_ptAppCommonConf = app_GetCommonConfig();
000002  f7fffffe          BL       app_GetCommonConfig
000006  4605              MOV      r5,r0
000008  f7fffffe          BL       module_GetModeConfig
00000c  4c19              LDR      r4,|L8.116|
00000e  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
000010  f7fffffe          BL       algorithm_GetModeConfig
000014  60a0              STR      r0,[r4,#8]  ; thisModeConf
000016  f7fffffe          BL       algorithm_baseline_init_param
00001a  f7fffffe          BL       algorithm_label_init_param
00001e  f7fffffe          BL       algorithm_coord_init_param
;;;126    #endif
;;;127    	
;;;128    	algorithm_init_param();
;;;129    	thisInfo = algorithm_GetInfo();
000022  f7fffffe          BL       algorithm_GetInfo
;;;130    #if USED_NOISE_HOPPING_FREQ
;;;131    	ptAppInfo = app_GetInfo();
000026  60e0              STR      r0,[r4,#0xc]  ; thisInfo
000028  f7fffffe          BL       app_GetInfo
;;;132    #endif /* USED_NOISE_HOPPING_FREQ */
;;;133    
;;;134    	DebugAlgorithmInfo = thisInfo;
00002c  6120              STR      r0,[r4,#0x10]  ; ptAppInfo
00002e  68e1              LDR      r1,[r4,#0xc]  ; thisInfo
;;;135    	tTempAlgorithmInfoDebug = thisInfo;
000030  6161              STR      r1,[r4,#0x14]  ; DebugAlgorithmInfo
;;;136    
;;;137    #if USED_IDLE_MODE_CONTROL
;;;138    	#if USED_ENTER_IDLE_REAL_TIME_CHECK
;;;139    		thisInfo->ulIdleModeEnterFrameCntTHD = _ptAppCommonConf->ucIdleModeEnterSec;
000032  61a1              STR      r1,[r4,#0x18]  ; tTempAlgorithmInfoDebug
000034  4602              MOV      r2,r0                 ;131
000036  f5015380          ADD      r3,r1,#0x1000
00003a  f8b50013          LDRH     r0,[r5,#0x13]
;;;140    	#else
;;;141    		thisInfo->ulIdleModeEnterFrameCntTHD = _ptAppCommonConf->ucIdleModeEnterSec * _ptAppCommonConf->ucFrameRate;
;;;142    	#endif /* USED_ENTER_IDLE_REAL_TIME_CHECK */
;;;143    	thisInfo->ulIdleModeEnterCheckCount = 0;
00003e  2100              MOVS     r1,#0
000040  e9c3015a          STRD     r0,r1,[r3,#0x168]
;;;144    #if USED_NOISE_HOPPING_FREQ
;;;145    	thisInfo->ulHopFrqIdleModeFrameCntTHD = thisInfo->ulIdleModeEnterFrameCntTHD;
;;;146    #endif /* USED_NOISE_HOPPING_FREQ */
;;;147    
;;;148    #endif /* USED_IDLE_MODE_CONTROL */
;;;149    
;;;150    #if USED_PEN_MODE_OPERATION
;;;151    	thisInfo->uPenLocalModeEnterFrameCntTHD = _ptAppCommonConf->ucPenLocalModeEnterSec * _ptAppCommonConf->ucFrameRate;
;;;152    	thisInfo->ulPenLocalModeEnterCheckCount = 0;
;;;153    
;;;154    	thisInfo->ulPenLocalModeChangeFrameCntTHD = _ptAppCommonConf->ucPenLocalModeChangeFrameCntTHD;
;;;155    	thisInfo->ulPenLocalModeChangeCheckCount = 0;
;;;156    	thisInfo->ulPenFullModeChangeFrameCntTHD = _ptAppCommonConf->ucPenFullModeChangeFrameCntTHD;
;;;157    	thisInfo->ulPenFullModeChangeCheckCount = 0;
;;;158    
;;;159    #if USED_LOCAL_IDLE_MODE_CONTROL
;;;160    	thisInfo->ulPenLocalIdleModeEnterFrameCntTHD = _ptAppCommonConf->ucIdleModeEnterSec * (_ptAppCommonConf->ucFrameRate / 2);
;;;161    	thisInfo->ulPenLocalIdleModeEnterCheckCount = 0;
;;;162    #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;163    #endif /* USED_PEN_MODE_OPERATION */
;;;164    
;;;165    #if USED_NOISE_HOPPING_FREQ
;;;166    	thisInfo->ulHoppMainRollbackFrameCntTHD = _ptAppCommonConf->HoppMainRollbackSec * _ptAppCommonConf->ucFrameRate;
000044  f8c3015c          STR      r0,[r3,#0x15c]
000048  f8b50017          LDRH     r0,[r5,#0x17]
00004c  f895c010          LDRB     r12,[r5,#0x10]
000050  fb00f00c          MUL      r0,r0,r12
000054  e9c30158          STRD     r0,r1,[r3,#0x160]
;;;167    	thisInfo->ulHoppMainRollbackCheckCount = 0;
;;;168    #if USE_FREQ_HOPPING_BASELINE_CONTI_UPDATE
;;;169    	ptAppInfo->bIsHoppFreqBaseUpdateContinueCheckStart = NO;
000058  75d1              STRB     r1,[r2,#0x17]
;;;170    	ptAppInfo->bIsNormalReadyIdleCheckCountMaintain = NO;
00005a  7591              STRB     r1,[r2,#0x16]
;;;171    	ptAppInfo->ulHoppFreqBaseUpdateFrameCheckCnt = 0;
00005c  6191              STR      r1,[r2,#0x18]
;;;172    	ptAppInfo->ulHoppFreqBaseUpdateContinueCheckCnt = 0;
00005e  61d1              STR      r1,[r2,#0x1c]
;;;173    #endif /* USE_FREQ_HOPPING_BASELINE_CONTI_UPDATE */
;;;174    #endif /* USED_NOISE_HOPPING_FREQ */
;;;175    //	thisInfo-> = _ptAppCommonConf->ucIdleModeEnterSec * _ptAppCommonConf->ucFrameRate;
;;;176    
;;;177    	algorithm_baseline_init();
000060  f7fffffe          BL       algorithm_baseline_init
;;;178    	algorithm_label_init();
000064  f7fffffe          BL       algorithm_label_init
;;;179    	algorithm_coord_init();
000068  f7fffffe          BL       algorithm_coord_init
;;;180    #if USED_NOISE_HOPPING_FREQ
;;;181    	algorithm_noise_init();
00006c  e8bd4070          POP      {r4-r6,lr}
000070  f7ffbffe          B.W      algorithm_noise_init
;;;182    #endif /* USED_NOISE_HOPPING_FREQ */
;;;183    }
;;;184    
                          ENDP

                  |L8.116|
                          DCD      ||.data||

                          AREA ||i.algorithm_init_param||, CODE, READONLY, ALIGN=2

                  algorithm_init_param PROC
;;;184    
;;;185    void algorithm_init_param(void)
000000  b510              PUSH     {r4,lr}
;;;186    {
;;;187    	ptModuleModeConf = module_GetModeConfig();
000002  f7fffffe          BL       module_GetModeConfig
000006  4c06              LDR      r4,|L9.32|
;;;188    	thisModeConf = algorithm_GetModeConfig();
000008  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
00000a  f7fffffe          BL       algorithm_GetModeConfig
;;;189    	algorithm_baseline_init_param();
00000e  60a0              STR      r0,[r4,#8]  ; thisModeConf
000010  f7fffffe          BL       algorithm_baseline_init_param
;;;190    	algorithm_label_init_param();
000014  f7fffffe          BL       algorithm_label_init_param
;;;191    //	algorithm_coord_init();
;;;192    	algorithm_coord_init_param();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      algorithm_coord_init_param
;;;193    }
;;;194    
                          ENDP

                  |L9.32|
                          DCD      ||.data||

                          AREA ||i.algorithm_is_recalibrate||, CODE, READONLY, ALIGN=2

                  algorithm_is_recalibrate PROC
;;;1418   
;;;1419   bool_t algorithm_is_recalibrate(void)
000000  4811              LDR      r0,|L10.72|
;;;1420   {
;;;1421     
;;;1422       /*
;;;1423        * Debouncing.
;;;1424        */
;;;1425       if (thisInfo->bIsRecalCond)
000002  4911              LDR      r1,|L10.72|
000004  2200              MOVS     r2,#0
000006  68c0              LDR      r0,[r0,#0xc]  ; thisInfo
;;;1426       {
;;;1427           if (thisInfo->iRecalCondCnt <= thisModeConf->BaseLine.ucRecalCond1_WaitCnt)
000008  6889              LDR      r1,[r1,#8]
00000a  7883              LDRB     r3,[r0,#2]            ;1425
00000c  b153              CBZ      r3,|L10.36|
00000e  f8911033          LDRB     r1,[r1,#0x33]
000012  6843              LDR      r3,[r0,#4]
000014  428b              CMP      r3,r1
;;;1428           {
;;;1429               thisInfo->iRecalCondCnt++;
000016  bfda              ITTE     LE
000018  1c59              ADDLE    r1,r3,#1
00001a  6041              STRLE    r1,[r0,#4]
;;;1430           }
;;;1431           else
;;;1432           {
;;;1433               thisInfo->iRecalCondCnt = 0;   // added
00001c  6042              STRGT    r2,[r0,#4]
00001e  dd10              BLE      |L10.66|
                  |L10.32|
;;;1434               return YES;
;;;1435           }
;;;1436       }
;;;1437       else if (thisInfo->bIsRecalCond2)
;;;1438       {
;;;1439           if (thisInfo->iRecalCond2Cnt <= thisModeConf->BaseLine.ucRecalCond2_WaitCnt)     // 300 msec
;;;1440           {
;;;1441           	thisInfo->iRecalCond2Cnt++;
;;;1442           }
;;;1443           else
;;;1444           {
;;;1445           	thisInfo->iRecalCond2Cnt = 0;   // added
;;;1446               return YES;
000020  2001              MOVS     r0,#1
;;;1447           }
;;;1448       }
;;;1449       else
;;;1450       {
;;;1451           thisInfo->iRecalCondCnt = 0;
;;;1452           thisInfo->iRecalCond2Cnt = 0;
;;;1453       }
;;;1454   
;;;1455       return NO;
;;;1456   }
000022  4770              BX       lr
                  |L10.36|
000024  78c3              LDRB     r3,[r0,#3]            ;1437
000026  2b00              CMP      r3,#0                 ;1437
000028  bf04              ITT      EQ                    ;1452
00002a  6042              STREQ    r2,[r0,#4]            ;1452
00002c  6082              STREQ    r2,[r0,#8]            ;1452
00002e  d008              BEQ      |L10.66|
000030  f8911034          LDRB     r1,[r1,#0x34]         ;1439
000034  6883              LDR      r3,[r0,#8]            ;1439
000036  428b              CMP      r3,r1                 ;1439
000038  bfda              ITTE     LE                    ;1441
00003a  1c59              ADDLE    r1,r3,#1              ;1441
00003c  6081              STRLE    r1,[r0,#8]            ;1441
00003e  6082              STRGT    r2,[r0,#8]            ;1445
000040  dcee              BGT      |L10.32|
                  |L10.66|
000042  2000              MOVS     r0,#0                 ;1455
000044  4770              BX       lr
;;;1457   
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      ||.data||

                          AREA ||i.algorithm_process||, CODE, READONLY, ALIGN=2

                  algorithm_process PROC
;;;2596   
;;;2597   bool_t algorithm_process(uint8_t mode)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;2598   {
000004  b08e              SUB      sp,sp,#0x38
;;;2599   	bool_t bIsRecalState = NO;
000006  2000              MOVS     r0,#0
;;;2600   	eSENSING_MODE_t eSensingMode;
;;;2601   	eSensingMode = HAL_GetSensingMode();
000008  9001              STR      r0,[sp,#4]
00000a  f7fffffe          BL       HAL_GetSensingMode
;;;2602   #if (INTERPOLATION_VER1_En == YES || INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES) 
;;;2603   	uint8_t ucInterpolation_Ver = 0;
;;;2604   #endif
;;;2605   	
;;;2606   #if USED_NOISE_HOPPING_FREQ
;;;2607   	{
;;;2608   #if USED_PEN_MODE_OPERATION
;;;2609   #define RAWDATA_STABLE_CNT		(1)
;;;2610   #else
;;;2611   #define RAWDATA_STABLE_CNT		(2)
;;;2612   #endif /* USED_PEN_MODE_OPERATION */
;;;2613   
;;;2614   		if (ptAppInfo->eHoppingStatus == FREQ_HOPPING_CHANGED)
00000e  4cfe              LDR      r4,|L11.1032|
000010  9000              STR      r0,[sp,#0]
000012  6920              LDR      r0,[r4,#0x10]  ; ptAppInfo
000014  7d01              LDRB     r1,[r0,#0x14]
000016  2901              CMP      r1,#1
000018  d07d              BEQ      |L11.278|
;;;2615   		{
;;;2616   			ptAppInfo->ucHoppFrameCnt++;
;;;2617   
;;;2618   			if (ptAppInfo->ucHoppFrameCnt > RAWDATA_STABLE_CNT)
;;;2619   			{
;;;2620   				ptAppInfo->eHoppingStatus = FREQ_HOPPING_NONE;
;;;2621   			}
;;;2622   			else
;;;2623   			{
;;;2624   				return YES;
;;;2625   			}
;;;2626   		}
;;;2627   	}
;;;2628   #endif
;;;2629   	
;;;2630   #if (INTERPOLATION_VER1_En == YES || INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES) 
;;;2631   	if( (thisModeConf->Coord.ucFullFingerInterpolation_On > 0 && mode == FULL_MODE) || (thisModeConf->Coord.ucLocalFingerInterpolation_On > 0 && mode == LOCAL_FINGER_MODE) )
;;;2632   	{
;;;2633   		if(mode == FULL_MODE)ucInterpolation_Ver = thisModeConf->Coord.ucFullFingerInterpolation_On;
;;;2634   		else ucInterpolation_Ver = thisModeConf->Coord.ucLocalFingerInterpolation_On;
;;;2635   	}
;;;2636   	
;;;2637   #if !USED_DO_NOT_FINGER_TOUCH_REPORT
;;;2638   	if(ucInterpolation_Ver > 0)
;;;2639   	{
;;;2640   
;;;2641   #if (INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES)
;;;2642   		if(ucInterpolation_Ver == 2 || ucInterpolation_Ver == 3)
;;;2643   		{
;;;2644   	#if (PEN_FINGER_1TOUCH_REPORT == NO)
;;;2645   			algorithm_PendTouchEvent();
;;;2646   	#endif
;;;2647   			algorithm_coord_UpdatePosHistoryInfo();
;;;2648   		}
;;;2649   #endif
;;;2650   		
;;;2651   		thisInfo->tCoord.bInterpolation_On = YES;
;;;2652   		algorithm_coord_interpolation(ucInterpolation_Ver);
;;;2653   		
;;;2654   #if (INTERPOLATION_VER1_En == YES)
;;;2655   		if(ucInterpolation_Ver == 1)
;;;2656   		{
;;;2657   	#if (PEN_FINGER_1TOUCH_REPORT == NO)
;;;2658   			algorithm_PendTouchEvent();
;;;2659   	#endif
;;;2660   			algorithm_coord_UpdatePosHistoryInfo();
;;;2661   		}
;;;2662   #endif
;;;2663   	}
;;;2664   	else
;;;2665   #endif /* !USED_DO_NOT_FINGER_TOUCH_REPORT */
;;;2666   	{
;;;2667   		thisInfo->tCoord.bInterpolation_On = NO;
;;;2668   	}
;;;2669   #endif
;;;2670   	
;;;2671   	algorithm_coord_initialise_pos_buffer();
00001a  bf00              NOP      
                  |L11.28|
00001c  f7fffffe          BL       algorithm_coord_initialise_pos_buffer
000020  f8df93ec          LDR      r9,|L11.1040|
000024  f8dfe3e4          LDR      lr,|L11.1036|
000028  2000              MOVS     r0,#0
00002a  f10901a0          ADD      r1,r9,#0xa0
00002e  bf00              NOP      
                  |L11.48|
000030  4ff9              LDR      r7,|L11.1048|
000032  f04f0b00          MOV      r11,#0
000036  4ef7              LDR      r6,|L11.1044|
000038  eb000340          ADD      r3,r0,r0,LSL #1
00003c  465a              MOV      r2,r11
00003e  4675              MOV      r5,lr
000040  f10708a0          ADD      r8,r7,#0xa0
000044  eb0304c0          ADD      r4,r3,r0,LSL #3
                  |L11.72|
000048  f8553022          LDR      r3,[r5,r2,LSL #2]
00004c  2a02              CMP      r2,#2
00004e  ebc31303          RSB      r3,r3,r3,LSL #4
000052  ebc303c3          RSB      r3,r3,r3,LSL #3
000056  eb0603c3          ADD      r3,r6,r3,LSL #3
00005a  f833c014          LDRH     r12,[r3,r4,LSL #1]
00005e  eb030344          ADD      r3,r3,r4,LSL #1
000062  f8b33154          LDRH     r3,[r3,#0x154]
000066  d921              BLS      |L11.172|
000068  eb091a02          ADD      r10,r9,r2,LSL #4
00006c  eb0a0a40          ADD      r10,r10,r0,LSL #1
000070  f93aac30          LDRSH    r10,[r10,#-0x30]
000074  45e2              CMP      r10,r12
000076  d119              BNE      |L11.172|
000078  eb071a02          ADD      r10,r7,r2,LSL #4
00007c  eb0a0a40          ADD      r10,r10,r0,LSL #1
000080  f93aac30          LDRSH    r10,[r10,#-0x30]
000084  45e2              CMP      r10,r12
000086  d111              BNE      |L11.172|
000088  eb011a02          ADD      r10,r1,r2,LSL #4
00008c  eb0a0a40          ADD      r10,r10,r0,LSL #1
000090  f93aac30          LDRSH    r10,[r10,#-0x30]
000094  459a              CMP      r10,r3
000096  d109              BNE      |L11.172|
000098  eb081a02          ADD      r10,r8,r2,LSL #4
00009c  eb0a0a40          ADD      r10,r10,r0,LSL #1
0000a0  f93aac30          LDRSH    r10,[r10,#-0x30]
0000a4  459a              CMP      r10,r3
0000a6  bf08              IT       EQ
0000a8  f10b0b01          ADDEQ    r11,r11,#1
                  |L11.172|
0000ac  eb091a02          ADD      r10,r9,r2,LSL #4
0000b0  f82ac010          STRH     r12,[r10,r0,LSL #1]
0000b4  eb011c02          ADD      r12,r1,r2,LSL #4
0000b8  1c52              ADDS     r2,r2,#1
0000ba  f82c3010          STRH     r3,[r12,r0,LSL #1]
0000be  2a0a              CMP      r2,#0xa
0000c0  d3c2              BCC      |L11.72|
0000c2  2200              MOVS     r2,#0
0000c4  4614              MOV      r4,r2
0000c6  4694              MOV      r12,r2
                  |L11.200|
0000c8  f00c03ff          AND      r3,r12,#0xff
0000cc  eb091503          ADD      r5,r9,r3,LSL #4
0000d0  eb011303          ADD      r3,r1,r3,LSL #4
0000d4  f8358010          LDRH     r8,[r5,r0,LSL #1]
0000d8  f8337010          LDRH     r7,[r3,r0,LSL #1]
0000dc  f10c0303          ADD      r3,r12,#3
0000e0  b2dd              UXTB     r5,r3
0000e2  eb091305          ADD      r3,r9,r5,LSL #4
0000e6  eb011505          ADD      r5,r1,r5,LSL #4
0000ea  f8333010          LDRH     r3,[r3,r0,LSL #1]
0000ee  f8356010          LDRH     r6,[r5,r0,LSL #1]
0000f2  f10c0506          ADD      r5,r12,#6
0000f6  b2ed              UXTB     r5,r5
0000f8  eb091a05          ADD      r10,r9,r5,LSL #4
0000fc  eb011505          ADD      r5,r1,r5,LSL #4
000100  f83aa010          LDRH     r10,[r10,r0,LSL #1]
000104  f8355010          LDRH     r5,[r5,r0,LSL #1]
000108  4598              CMP      r8,r3
00010a  bf02              ITTT     EQ
00010c  4553              CMPEQ    r3,r10
00010e  1c63              ADDEQ    r3,r4,#1
000110  b2dc              UXTBEQ   r4,r3
000112  42b7              CMP      r7,r6
000114  e000              B        |L11.280|
                  |L11.278|
000116  e02c              B        |L11.370|
                  |L11.280|
000118  bf02              ITTT     EQ
00011a  42ae              CMPEQ    r6,r5
00011c  1c52              ADDEQ    r2,r2,#1
00011e  b2d2              UXTBEQ   r2,r2
000120  f10c0c01          ADD      r12,r12,#1
000124  f1bc0f03          CMP      r12,#3
000128  d3ce              BCC      |L11.200|
00012a  2c03              CMP      r4,#3
00012c  bf28              IT       CS
00012e  2a03              CMPCS    r2,#3
000130  d302              BCC      |L11.312|
000132  4bb5              LDR      r3,|L11.1032|
000134  2201              MOVS     r2,#1
000136  701a              STRB     r2,[r3,#0]
                  |L11.312|
000138  f1bb0f07          CMP      r11,#7
00013c  d024              BEQ      |L11.392|
00013e  1c40              ADDS     r0,r0,#1
000140  2808              CMP      r0,#8
000142  f4ffaf75          BCC      |L11.48|
000146  49b2              LDR      r1,|L11.1040|
000148  22a0              MOVS     r2,#0xa0
00014a  f50170a0          ADD      r0,r1,#0x140
00014e  f7fffffe          BL       __aeabi_memcpy
000152  49b2              LDR      r1,|L11.1052|
000154  22a0              MOVS     r2,#0xa0
000156  f50170a0          ADD      r0,r1,#0x140
00015a  f7fffffe          BL       __aeabi_memcpy
00015e  2000              MOVS     r0,#0
                  |L11.352|
;;;2672   
;;;2673   #if USED_ESD_RECOERY_DETECTION_RAWDATA_STUCK
;;;2674   	thisInfo->bIsESDRecovery = algorithm_CheckRawDataStuck();
000160  4da9              LDR      r5,|L11.1032|
;;;2675   	if(thisInfo->bIsESDRecovery)
000162  2800              CMP      r0,#0
000164  68e9              LDR      r1,[r5,#0xc]          ;2674  ; thisInfo
000166  f5015180          ADD      r1,r1,#0x1000         ;2674
00016a  f88102a8          STRB     r0,[r1,#0x2a8]        ;2674
00016e  d15c              BNE      |L11.554|
000170  e00c              B        |L11.396|
                  |L11.370|
000172  7d41              LDRB     r1,[r0,#0x15]         ;2616
000174  1c49              ADDS     r1,r1,#1              ;2616
000176  b2c9              UXTB     r1,r1                 ;2616
000178  7541              STRB     r1,[r0,#0x15]         ;2616
00017a  2902              CMP      r1,#2                 ;2618
00017c  bf84              ITT      HI                    ;2620
00017e  2100              MOVHI    r1,#0                 ;2620
000180  7501              STRBHI   r1,[r0,#0x14]         ;2620
000182  f63faf4b          BHI      |L11.28|
000186  e050              B        |L11.554|
                  |L11.392|
000188  2001              MOVS     r0,#1                 ;2618
00018a  e7e9              B        |L11.352|
                  |L11.396|
;;;2676   	{
;;;2677   	#if USED_ESD_DEBUG
;;;2678   		gbRawdataStuckReset = thisInfo->bIsESDRecovery;
;;;2679   	#endif
;;;2680   		return YES; //
;;;2681   //		while(1); // watch-dog Reset!!
;;;2682   	}
;;;2683   #endif /* USED_ESD_RECOERY_DETECTION_RAWDATA_STUCK */
;;;2684   
;;;2685   #if DEF_ESD_DEBUG_RAWDATA_BEFORE_LINEFILTER
;;;2686   	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_GET_RAW_IMAGE_PTR(), COL_MAX, ROW_MAX, 84/*Raw Data*/);
00018c  4ca4              LDR      r4,|L11.1056|
00018e  e9d40100          LDRD     r0,r1,[r4,#0]
000192  68a2              LDR      r2,[r4,#8]  ; <Data5>
000194  9002              STR      r0,[sp,#8]
000196  e9cd1203          STRD     r1,r2,[sp,#0xc]
00019a  4a9e              LDR      r2,|L11.1044|
00019c  a902              ADD      r1,sp,#8
00019e  2003              MOVS     r0,#3
0001a0  f7fffffe          BL       protocol_Log
;;;2687   	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;2688   		protocol_LogMatrix(LT_PENPOS_RAWDATA, COL_MAX, HAL_GET_ESD_RAW_IMAGE_PTR(), COL_MAX, FINGER_ESD_SCAN_ROW_MAX_NUM, 84/*Raw Data*/);
0001a4  e9d40103          LDRD     r0,r1,[r4,#0xc]
0001a8  6962              LDR      r2,[r4,#0x14]  ; <Data6>
0001aa  9207              STR      r2,[sp,#0x1c]
0001ac  e9cd0105          STRD     r0,r1,[sp,#0x14]
0001b0  4a9c              LDR      r2,|L11.1060|
0001b2  a905              ADD      r1,sp,#0x14
0001b4  2019              MOVS     r0,#0x19
0001b6  f7fffffe          BL       protocol_Log
;;;2689   	#endif
;;;2690   #endif
;;;2691   
;;;2692   	memset(sLFOffsetRow, 0, sizeof(sLFOffsetRow));
0001ba  2160              MOVS     r1,#0x60
0001bc  489a              LDR      r0,|L11.1064|
0001be  f7fffffe          BL       __aeabi_memclr
;;;2693   	memset(sLFOffsetCol, 0, sizeof(sLFOffsetCol));
0001c2  21a8              MOVS     r1,#0xa8
0001c4  4899              LDR      r0,|L11.1068|
0001c6  f7fffffe          BL       __aeabi_memclr
;;;2694   
;;;2695   	if(!IS_S3_MODE(eSensingMode))
0001ca  9800              LDR      r0,[sp,#0]
0001cc  f4106f00          TST      r0,#0x800
0001d0  d106              BNE      |L11.480|
;;;2696   	{
;;;2697   	#if FINGER_LF_VER1_EN
;;;2698   		if(thisModeConf->SensingFilter.cLineFilter == 1)
;;;2699   		{
;;;2700   			alogorithm_linefilter(eSensingMode);
;;;2701   		}
;;;2702   	#endif
;;;2703   	#if FINGER_LF_VER2_EN
;;;2704   		if(thisModeConf->SensingFilter.cLineFilter == 2)
0001d2  68a8              LDR      r0,[r5,#8]  ; thisModeConf
0001d4  f890004c          LDRB     r0,[r0,#0x4c]
0001d8  2802              CMP      r0,#2
;;;2705   		{
;;;2706   			alogorithm_linefilter_2();
0001da  bf08              IT       EQ
0001dc  f7fffffe          BLEQ     alogorithm_linefilter_2
                  |L11.480|
;;;2707   		}
;;;2708   	#endif
;;;2709   	#if	USED_DSPA_FUNC_FOR_FINGER && USED_DSPA_FUNC_FOR_FINGER_LF
;;;2710   		if(thisModeConf->SensingFilter.cLineFilter == 3)
;;;2711   		{
;;;2712   			uint16_t * pBaseImage;
;;;2713   		#if USED_NOISE_HOPPING_FREQ
;;;2714   			if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;2715   			{
;;;2716   				pBaseImage = g_pFingerBaseImage;
;;;2717   			}
;;;2718   			else
;;;2719   			{
;;;2720   				pBaseImage = g_pFingerHop1BaseImage;
;;;2721   			}
;;;2722   //			pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;2723   		#else /* USED_NOISE_HOPPING_FREQ */
;;;2724   			pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;2725   		#endif /* USED_NOISE_HOPPING_FREQ */
;;;2726   			alogorithm_linefilter_dspA((uint32_t)&RAWIMAGE[0][0],(uint32_t)(&pBaseImage[0]),(uint32_t)&DSPATMPDELTA_Finger[0][0],(uint32_t)&LINEFILTERBUFST2_Finger[0],(uint32_t)&LINEFILTERBUFST3_Finger[0],ROW_MAX,
;;;2727   			(uint32_t)(thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift),(uint32_t)(thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift),0);
;;;2728   		}
;;;2729   	#endif
;;;2730   	#if FINGER_LF_VER4_EN
;;;2731   		if(thisModeConf->SensingFilter.cLineFilter == 4)
;;;2732   		{
;;;2733   			alogorithm_linefilter_simple(eSensingMode);
;;;2734   			alogorithm_vertical_linefilter_simple(eSensingMode);
;;;2735   		}
;;;2736   	#endif /* (CUSTOMER != MODEL_DEF_FHD_92503B) */
;;;2737   	}
;;;2738   
;;;2739   #if (DEF_ESD_DEBUG_RAWDATA_BEFORE_LINEFILTER == NO)
;;;2740   	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_GET_RAW_IMAGE_PTR(), COL_MAX, ROW_MAX, 84/*Raw Data*/);
;;;2741   #endif
;;;2742   
;;;2743   	algorithm_baseline_calculate_delta(mode);
0001e0  980e              LDR      r0,[sp,#0x38]
0001e2  f7fffffe          BL       algorithm_baseline_calculate_delta
;;;2744   	
;;;2745   	#if USED_ESD_RECOVERY_RESET_TOUCH_AT_FIRST_FRAME
;;;2746   	if(thisInfo->bIsESDGhostRecoveryATFirstFrame_Check)
0001e6  68e8              LDR      r0,[r5,#0xc]  ; thisInfo
0001e8  f5005080          ADD      r0,r0,#0x1000
0001ec  f89012a9          LDRB     r1,[r0,#0x2a9]
0001f0  b1f9              CBZ      r1,|L11.562|
;;;2747   	{
;;;2748   		if(thisInfo->ulESDGhostRecoveryATFirstFrame_Check_Count == 0)
0001f2  f8d012ac          LDR      r1,[r0,#0x2ac]
0001f6  2900              CMP      r1,#0
;;;2749   		{
;;;2750   			thisInfo->ulESDGhostRecoveryATFirstFrame_TouchExpect_Count = 0;
0001f8  bf04              ITT      EQ
0001fa  2200              MOVEQ    r2,#0
0001fc  f8c022b0          STREQ    r2,[r0,#0x2b0]
000200  1c49              ADDS     r1,r1,#1
;;;2751   		}
;;;2752   
;;;2753   		thisInfo->ulESDGhostRecoveryATFirstFrame_Check_Count++;
;;;2754   		if(thisInfo->ulESDGhostRecoveryATFirstFrame_Check_Count < DEF_ESD_RECOVERY_RESET_TOUCH_AT_FIRST_FRAME_CNT_THD)
000202  f8c012ac          STR      r1,[r0,#0x2ac]
000206  290a              CMP      r1,#0xa
000208  d208              BCS      |L11.540|
;;;2755   		{
;;;2756   			if(thisInfo->bTouchExpect)
00020a  f89010dd          LDRB     r1,[r0,#0xdd]
00020e  b181              CBZ      r1,|L11.562|
;;;2757   			{
;;;2758   				thisInfo->ulESDGhostRecoveryATFirstFrame_TouchExpect_Count++;
000210  f8d012b0          LDR      r1,[r0,#0x2b0]
000214  1c49              ADDS     r1,r1,#1
;;;2759   				// Touch Skip!!
;;;2760   				return YES;
000216  f8c012b0          STR      r1,[r0,#0x2b0]
00021a  e006              B        |L11.554|
                  |L11.540|
;;;2761   			}
;;;2762   		}
;;;2763   		else
;;;2764   		{
;;;2765   			thisInfo->bIsESDGhostRecoveryATFirstFrame_Check = NO;
00021c  2100              MOVS     r1,#0
00021e  f88012a9          STRB     r1,[r0,#0x2a9]
;;;2766   			if(thisInfo->ulESDGhostRecoveryATFirstFrame_TouchExpect_Count > 0)
000222  f8d012b0          LDR      r1,[r0,#0x2b0]
000226  b939              CBNZ     r1,|L11.568|
000228  e003              B        |L11.562|
                  |L11.554|
;;;2767   			{
;;;2768   				thisInfo->bIsESDRecovery = YES;
;;;2769   				// Reset For ESD!!
;;;2770   				return YES;
;;;2771   			}
;;;2772   		}
;;;2773   	}
;;;2774   	#endif /* USED_ESD_RECOVERY_RESET_TOUCH_AT_FIRST_FRAME */
;;;2775   
;;;2776   	#if USED_ESD_RECOVERY_CHECK_ABNORMAL_PEN_DELTA
;;;2777   	if (thisInfo->bIsESD_Abnormal_Delta_Reset)
;;;2778   	{
;;;2779   		thisInfo->bIsESDRecovery = YES;
;;;2780   		// Reset For ESD!!
;;;2781   		return YES;
;;;2782   	}
;;;2783   	#endif
;;;2784   
;;;2785   	protocol_LogPaddedMatrix(LT_INTENSITY, COL_MAX, HAL_GET_DELTA_IMAGE_PTR(), COL_MAX, ROW_MAX, 81/*MAX Intensity*/);
;;;2786   	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;2787   		protocol_LogMatrix(LT_PENPOS_INTENSITY, COL_MAX, HAL_GET_ESD_DELTA_IMAGE_PTR(), COL_MAX, FINGER_ESD_SCAN_ROW_MAX_NUM, 81/*MAX Intensity*/);
;;;2788   	#endif
;;;2789   
;;;2790   	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;2791   	{
;;;2792   		if(thisInfo->bIsESD_ReportSkip_ByESDScan == YES)
;;;2793   		{
;;;2794   			if(thisInfo->ulESD_ReportSkip_Count_ByESDScan < DEF_ESD_SCAN_REPORT_SKIP_CNT_THD)
;;;2795   			{
;;;2796   				thisInfo->ulESD_ReportSkip_Count_ByESDScan++;
;;;2797   				// Touch Skip!!
;;;2798   				return YES;
;;;2799   			}
;;;2800   			else
;;;2801   			{
;;;2802   				thisInfo->bIsESD_ReportSkip_ByESDScan = NO;
;;;2803   				thisInfo->ulESD_ReportSkip_Count_ByESDScan = 0;
;;;2804   			}
;;;2805   		}
;;;2806   	}
;;;2807   	#endif
;;;2808   //	return YES;
;;;2809   		
;;;2810   	if((mode == FULL_MODE && !thisModeConf->BaseLine.bFullModeReBaseCheckOff) || (mode == LOCAL_FINGER_MODE && !thisModeConf->BaseLine.bLocalModeReBaseCheckOff))
;;;2811   	{
;;;2812   		algorithm_check_recal_cond();
;;;2813   		bIsRecalState = algorithm_is_recalibrate();
;;;2814   	#if USED_ESD_DEBUG
;;;2815   		gbRecalReset = bIsRecalState;
;;;2816   	#endif
;;;2817   	}
;;;2818   	
;;;2819   	if(IS_S3_MODE(eSensingMode) && IS_IDLE_MODE(eSensingMode))
;;;2820   	{
;;;2821   		algorithm_baseline_tracking_continuous(mode);
;;;2822   	}
;;;2823   	else
;;;2824   	{
;;;2825   		if(bIsRecalState == NO)
;;;2826   		{
;;;2827   #if (FingerAreaPenDeltaDelete==1 || FingerAreaPenDeltaNoAcc==1 || FingerAreaLineFilter == 1)
;;;2828   			if(mode == LOCAL_FINGER_MODE)
;;;2829   			{
;;;2830   				if(thisModeConf->BaseLine.cFingerAreaPenDeltaDelete != 0 || thisModeConf->BaseLine.cFingerAreaPenDeltaNoAcc != 0 || thisModeConf->SensingFilter.sFingerAreaLineFilterLimit != 0)
;;;2831   				{
;;;2832   					thisInfo->tPenInfo.LocalFingerArea.rs = ROW_MAX;
;;;2833   					thisInfo->tPenInfo.LocalFingerArea.re = 0;
;;;2834   					thisInfo->tPenInfo.LocalFingerArea.cs = COL_MAX;
;;;2835   					thisInfo->tPenInfo.LocalFingerArea.ce = 0;	
;;;2836   				}
;;;2837   			}
;;;2838   #endif			
;;;2839   			// process label image from delta image
;;;2840   			algorithm_label_process(mode);
;;;2841   			algorithm_coord_process(FULL_MODE);
;;;2842   #if (INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES)
;;;2843   			if(ucInterpolation_Ver >= 2)
;;;2844   			{		
;;;2845   				algorithm_coord_interpolation_v02(ucInterpolation_Ver);
;;;2846   			}
;;;2847   #endif
;;;2848   		}
;;;2849   
;;;2850   #if USED_NOISE_HOPPING_FREQ
;;;2851   //		if(mode == FULL_MODE)
;;;2852   		{
;;;2853   			algorithm_noise_process(eSensingMode);
;;;2854   		}
;;;2855   #endif /* USED_NOISE_HOPPING_FREQ */
;;;2856   
;;;2857   #if PALM_VER1_EN
;;;2858   		if(thisModeConf->Palm.ucPalmDetectionOn == 1 || (thisModeConf->Palm.ucPalmDetectionOn == 3 && thisInfo->bNewVersionPalm == 0))
;;;2859   			public_func_PalmTouch_handler();
;;;2860   		
;;;2861   		if(thisInfo->bIsPalm || thisInfo->tCoord.tPos.sFinger_ > 5) thisInfo->bNewVersionPalm = 1;
;;;2862   		if(!thisInfo->bTouchExpect) thisInfo->bNewVersionPalm = 0;
;;;2863   #endif
;;;2864   		if(thisInfo->bIsPalm)
;;;2865   		{
;;;2866   			if(thisInfo->tLabel.ucPalmCnt < 100)
;;;2867   				thisInfo->tLabel.ucPalmCnt++;
;;;2868   		}
;;;2869   		else
;;;2870   			thisInfo->tLabel.ucPalmCnt = 0;
;;;2871   
;;;2872   #if USED_ESD_RECOVERY_GHOST_TOUCH_DELTA_PATTERN
;;;2873   		{
;;;2874   			bool_t bTopMuxDelta, bBottomMuxDelta;
;;;2875   			uint8_t max_c, mux_num;
;;;2876   			uint16_t min_delta;
;;;2877   
;;;2878   //			usLabelThd  = thisModeConf->Label.usSeedBase;
;;;2879   //			usLabelThd += ((temp_delta->iMaxStrength - thisModeConf->Label.usSeedBase) * thisModeConf->Label.ucSeedSlope)>>6;
;;;2880   
;;;2881   			if (thisInfo->tDelta.iMaxStrength > thisModeConf->Label.usSeedBase)
;;;2882   			{
;;;2883   				max_c = thisInfo->tDelta.tMaxCellPos.c;
;;;2884   				mux_num = thisInfo->tDelta.tMaxCellPos.r / ROW_PER_MUX;
;;;2885   				min_delta = thisInfo->tDelta.iMaxStrength * MIN_DELTA_RATIO / 10;
;;;2886   
;;;2887   				//	1. Check current mux delta
;;;2888   				if (algorithm_Check_Mux_Delta(mux_num, max_c, min_delta, YES))
;;;2889   				{
;;;2890   					//	2. Check top/bottom mux delta
;;;2891   
;;;2892   					bTopMuxDelta = bBottomMuxDelta = YES;
;;;2893   
;;;2894   					if (mux_num != FIRST_MUX_NUM)
;;;2895   						bTopMuxDelta = algorithm_Check_Mux_Delta(mux_num - 1, max_c, MIN_DELTA, NO);
;;;2896   
;;;2897   					if (mux_num != LAST_MUX_NUM)
;;;2898   						bBottomMuxDelta = algorithm_Check_Mux_Delta(mux_num + 1, max_c, MIN_DELTA, NO);
;;;2899   
;;;2900   
;;;2901   					if (bTopMuxDelta && bBottomMuxDelta)
;;;2902   						gbSkipTouch = YES;	//	ESD Ghost Touch
;;;2903   				}
;;;2904   			}
;;;2905   
;;;2906   //			while(gbSkipTouch)	//	Debug
;;;2907   //			{
;;;2908   //				protocol_LogPaddedMatrix(LT_INTENSITY, COL_MAX, HAL_GET_DELTA_IMAGE_PTR(), COL_MAX, ROW_MAX, 81/*MAX Intensity*/);
;;;2909   //				medium_delay(300);
;;;2910   //#ifdef MODE_WDT
;;;2911   //				KICK_DOG();
;;;2912   //#endif
;;;2913   //			};
;;;2914   		}
;;;2915   #endif /* USED_ESD_RECOVERY_GHOST_TOUCH_DELTA_PATTERN */
;;;2916   
;;;2917   #if USED_PEN_MODE_OPERATION
;;;2918   		if(mode == FULL_MODE)
;;;2919   		{
;;;2920   			thisInfo->sFullLcoalChangeMinTh = thisModeConf->BaseLine.sFullLcoalChangeMinTh;
;;;2921   			if((thisInfo->bIsPalm == YES && thisInfo->tCoord.tPos.sFinger_ >= 1) || thisInfo->tCoord.tPos.sFinger_ >= 6)
;;;2922   				thisInfo->sFullLcoalChangeMinTh += thisModeConf->BaseLine.cFullLcoalChangeMinThOffset;
;;;2923   			if(thisInfo->tDelta.iMinStrength < thisInfo->sFullLcoalChangeMinTh)
;;;2924   			{
;;;2925   				thisInfo->bLocal_sensing = YES;
;;;2926   				algorithm_baseline_calculate_mux_range(thisInfo->tDelta.tMinCellPos.r, thisInfo->tDelta.tMinCellPos.c);
;;;2927   			}
;;;2928   		}
;;;2929   #endif
;;;2930   	
;;;2931   #if !USED_DO_NOT_FINGER_TOUCH_REPORT
;;;2932   #if (INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES) 
;;;2933   		if(ucInterpolation_Ver < 2)
;;;2934   #endif
;;;2935   		{
;;;2936   	#if (FINGER_Latency_Test_ByFW == YES)
;;;2937   			algorithm_coord_latency_cal_test();
;;;2938   	#endif
;;;2939   	#if (PEN_FINGER_1TOUCH_REPORT == NO)
;;;2940   #if (DEF_ESD_RECOVERY_CHECK_CURRENT_FRAME_RAWDATA_STUCK || USED_ESD_RECOVERY_GHOST_TOUCH_DELTA_PATTERN)
;;;2941   			if (!gbSkipTouch)
;;;2942   				algorithm_PendTouchEvent();
;;;2943   			else
;;;2944   			{
;;;2945   				gbSkipTouch = NO;
;;;2946   				gusSkipTouchCnt++;
;;;2947   			}
;;;2948   #else /* (DEF_ESD_RECOVERY_CHECK_CURRENT_FRAME_RAWDATA_STUCK || USED_ESD_RECOVERY_GHOST_TOUCH_DELTA_PATTERN) */
;;;2949   			algorithm_PendTouchEvent();
;;;2950   #endif /* (DEF_ESD_RECOVERY_CHECK_CURRENT_FRAME_RAWDATA_STUCK || USED_ESD_RECOVERY_GHOST_TOUCH_DELTA_PATTERN) */
;;;2951   	#endif
;;;2952   			algorithm_coord_UpdatePosHistoryInfo();
;;;2953   		}
;;;2954   #endif /* !USED_DO_NOT_FINGER_TOUCH_REPORT */
;;;2955   		
;;;2956   		if(thisModeConf->BaseLine.bFingerBaseTracking == 1 && ((mode == FULL_MODE && thisModeConf->BaseLine.bFullFingerBaseTracking == 1) || (mode == LOCAL_FINGER_MODE)))
;;;2957   			algorithm_baseline_tracking_continuous(mode);
;;;2958   	}
;;;2959   
;;;2960   	return (bIsRecalState == NO);
;;;2961   }
00022a  b00f              ADD      sp,sp,#0x3c
00022c  2001              MOVS     r0,#1                 ;2770
00022e  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.562|
000232  f89012bc          LDRB     r1,[r0,#0x2bc]        ;2777
000236  b119              CBZ      r1,|L11.576|
                  |L11.568|
000238  2101              MOVS     r1,#1                 ;2779
00023a  f88012a8          STRB     r1,[r0,#0x2a8]        ;2779
00023e  e7f4              B        |L11.554|
                  |L11.576|
000240  e9d40106          LDRD     r0,r1,[r4,#0x18]      ;2785
000244  6a22              LDR      r2,[r4,#0x20]         ;2785  ; <Data7>
000246  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;2785
00024a  920a              STR      r2,[sp,#0x28]         ;2785
00024c  4a78              LDR      r2,|L11.1072|
00024e  a908              ADD      r1,sp,#0x20           ;2785
000250  2004              MOVS     r0,#4                 ;2785
000252  f7fffffe          BL       protocol_Log
000256  e9d40109          LDRD     r0,r1,[r4,#0x24]      ;2787
00025a  6ae2              LDR      r2,[r4,#0x2c]         ;2787  ; <Data8>
00025c  920d              STR      r2,[sp,#0x34]         ;2787
00025e  e9cd010b          STRD     r0,r1,[sp,#0x2c]      ;2787
000262  4a74              LDR      r2,|L11.1076|
000264  a90b              ADD      r1,sp,#0x2c           ;2787
000266  201b              MOVS     r0,#0x1b              ;2787
000268  f7fffffe          BL       protocol_Log
00026c  68e8              LDR      r0,[r5,#0xc]          ;2792  ; thisInfo
00026e  f5005180          ADD      r1,r0,#0x1000         ;2792
000272  f89122b4          LDRB     r2,[r1,#0x2b4]        ;2792
000276  2a01              CMP      r2,#1                 ;2792
000278  d004              BEQ      |L11.644|
                  |L11.634|
00027a  9a0e              LDR      r2,[sp,#0x38]         ;2810
00027c  b18a              CBZ      r2,|L11.674|
00027e  2a02              CMP      r2,#2                 ;2810
000280  d014              BEQ      |L11.684|
000282  e05b              B        |L11.828|
                  |L11.644|
000284  f8d122b8          LDR      r2,[r1,#0x2b8]        ;2794
000288  2a0a              CMP      r2,#0xa               ;2794
00028a  bf39              ITTEE    CC                    ;2796
00028c  1c50              ADDCC    r0,r2,#1              ;2796
00028e  f8c102b8          STRCC    r0,[r1,#0x2b8]        ;2796
000292  2200              MOVCS    r2,#0                 ;2802
000294  f88122b4          STRBCS   r2,[r1,#0x2b4]        ;2802
000298  bf28              IT       CS                    ;2803
00029a  f8c122b8          STRCS    r2,[r1,#0x2b8]        ;2803
00029e  d3c4              BCC      |L11.554|
0002a0  e7eb              B        |L11.634|
                  |L11.674|
0002a2  68aa              LDR      r2,[r5,#8]            ;2810  ; thisModeConf
0002a4  f8922035          LDRB     r2,[r2,#0x35]         ;2810
0002a8  bbba              CBNZ     r2,|L11.794|
0002aa  e003              B        |L11.692|
                  |L11.684|
0002ac  68aa              LDR      r2,[r5,#8]            ;2810  ; thisModeConf
0002ae  f8922036          LDRB     r2,[r2,#0x36]         ;2810
0002b2  bb92              CBNZ     r2,|L11.794|
                  |L11.692|
0002b4  2300              MOVS     r3,#0                 ;2810
0002b6  7083              STRB     r3,[r0,#2]            ;2810
0002b8  70c3              STRB     r3,[r0,#3]            ;2810
0002ba  68aa              LDR      r2,[r5,#8]            ;2810  ; thisModeConf
0002bc  f8d0c025          LDR      r12,[r0,#0x25]        ;2810
0002c0  f8d24027          LDR      r4,[r2,#0x27]         ;2810
0002c4  45a4              CMP      r12,r4                ;2810
0002c6  db09              BLT      |L11.732|
0002c8  f8d0402d          LDR      r4,[r0,#0x2d]         ;2810
0002cc  44a4              ADD      r12,r12,r4            ;2810
0002ce  f8d2402b          LDR      r4,[r2,#0x2b]         ;2810
0002d2  45a4              CMP      r12,r4                ;2810
0002d4  bfb8              IT       LT                    ;2810
0002d6  f04f0c01          MOVLT    r12,#1                ;2810
0002da  db01              BLT      |L11.736|
                  |L11.732|
0002dc  f04f0c00          MOV      r12,#0                ;2810
                  |L11.736|
0002e0  f880c002          STRB     r12,[r0,#2]           ;2810
0002e4  f89110dd          LDRB     r1,[r1,#0xdd]         ;2810
0002e8  b939              CBNZ     r1,|L11.762|
0002ea  f8d0102d          LDR      r1,[r0,#0x2d]         ;2810
0002ee  f8d2402f          LDR      r4,[r2,#0x2f]         ;2810
0002f2  42a1              CMP      r1,r4                 ;2810
0002f4  bfb8              IT       LT                    ;2810
0002f6  2101              MOVLT    r1,#1                 ;2810
0002f8  db00              BLT      |L11.764|
                  |L11.762|
0002fa  2100              MOVS     r1,#0                 ;2810
                  |L11.764|
0002fc  70c1              STRB     r1,[r0,#3]            ;2810
0002fe  f1bc0f00          CMP      r12,#0                ;2810
000302  d00b              BEQ      |L11.796|
000304  f8922033          LDRB     r2,[r2,#0x33]         ;2810
000308  6841              LDR      r1,[r0,#4]            ;2810
00030a  4291              CMP      r1,r2                 ;2810
00030c  bfda              ITTE     LE                    ;2810
00030e  1c49              ADDLE    r1,r1,#1              ;2810
000310  6041              STRLE    r1,[r0,#4]            ;2810
000312  6043              STRGT    r3,[r0,#4]            ;2810
000314  dd10              BLE      |L11.824|
                  |L11.790|
000316  2001              MOVS     r0,#1                 ;2810
000318  e00f              B        |L11.826|
                  |L11.794|
00031a  e00f              B        |L11.828|
                  |L11.796|
00031c  2900              CMP      r1,#0                 ;2810
00031e  bf04              ITT      EQ                    ;2810
000320  6043              STREQ    r3,[r0,#4]            ;2810
000322  6083              STREQ    r3,[r0,#8]            ;2810
000324  d008              BEQ      |L11.824|
000326  f8922034          LDRB     r2,[r2,#0x34]         ;2810
00032a  6881              LDR      r1,[r0,#8]            ;2810
00032c  4291              CMP      r1,r2                 ;2810
00032e  bfda              ITTE     LE                    ;2810
000330  1c49              ADDLE    r1,r1,#1              ;2810
000332  6081              STRLE    r1,[r0,#8]            ;2810
000334  6083              STRGT    r3,[r0,#8]            ;2810
000336  dcee              BGT      |L11.790|
                  |L11.824|
000338  2000              MOVS     r0,#0                 ;2810
                  |L11.826|
00033a  9001              STR      r0,[sp,#4]            ;2813
                  |L11.828|
00033c  9800              LDR      r0,[sp,#0]            ;2819
00033e  f4106f00          TST      r0,#0x800             ;2819
000342  bf1e              ITTT     NE                    ;2819
000344  9800              LDRNE    r0,[sp,#0]            ;2819
000346  f4107f80          TSTNE    r0,#0x100             ;2819
00034a  980e              LDRNE    r0,[sp,#0x38]         ;2821
00034c  d176              BNE      |L11.1084|
00034e  9801              LDR      r0,[sp,#4]            ;2825
000350  b928              CBNZ     r0,|L11.862|
000352  980e              LDR      r0,[sp,#0x38]         ;2840
000354  f7fffffe          BL       algorithm_label_process
000358  2000              MOVS     r0,#0                 ;2841
00035a  f7fffffe          BL       algorithm_coord_process
                  |L11.862|
00035e  9800              LDR      r0,[sp,#0]            ;2853
000360  f7fffffe          BL       algorithm_noise_process
000364  68e8              LDR      r0,[r5,#0xc]          ;2864  ; thisInfo
000366  f24101da          MOV      r1,#0x10da            ;2864
00036a  5c09              LDRB     r1,[r1,r0]            ;2864
00036c  b129              CBZ      r1,|L11.890|
00036e  f8901368          LDRB     r1,[r0,#0x368]        ;2866
000372  2964              CMP      r1,#0x64              ;2866
000374  bf38              IT       CC                    ;2866
000376  1c49              ADDCC    r1,r1,#1              ;2866
000378  d201              BCS      |L11.894|
                  |L11.890|
00037a  f8801368          STRB     r1,[r0,#0x368]        ;2867
                  |L11.894|
00037e  68aa              LDR      r2,[r5,#8]            ;2881  ; thisModeConf
000380  f8d01015          LDR      r1,[r0,#0x15]         ;2881
000384  f8b22064          LDRH     r2,[r2,#0x64]         ;2881
000388  4291              CMP      r1,r2                 ;2881
00038a  dd33              BLE      |L11.1012|
00038c  f8906035          LDRB     r6,[r0,#0x35]         ;2883
000390  f9900036          LDRSB    r0,[r0,#0x36]         ;2884
000394  2267              MOVS     r2,#0x67              ;2884
000396  4350              MULS     r0,r2,r0              ;2884
000398  1242              ASRS     r2,r0,#9              ;2884
00039a  eba270e0          SUB      r0,r2,r0,ASR #31      ;2884
00039e  b2c4              UXTB     r4,r0                 ;2884
0003a0  00c8              LSLS     r0,r1,#3              ;2884
0003a2  4925              LDR      r1,|L11.1080|
0003a4  2301              MOVS     r3,#1                 ;2888
0003a6  fb811000          SMULL    r1,r0,r1,r0           ;2885
0003aa  1081              ASRS     r1,r0,#2              ;2885
0003ac  eba170e0          SUB      r0,r1,r0,ASR #31      ;2885
0003b0  b282              UXTH     r2,r0                 ;2885
0003b2  4631              MOV      r1,r6                 ;2888
0003b4  4620              MOV      r0,r4                 ;2888
0003b6  f7fffffe          BL       algorithm_Check_Mux_Delta
0003ba  b1d8              CBZ      r0,|L11.1012|
0003bc  2701              MOVS     r7,#1                 ;2892
0003be  46b8              MOV      r8,r7                 ;2892
0003c0  b14c              CBZ      r4,|L11.982|
0003c2  1e60              SUBS     r0,r4,#1              ;2895
0003c4  b2c0              UXTB     r0,r0                 ;2895
0003c6  2300              MOVS     r3,#0                 ;2895
0003c8  220a              MOVS     r2,#0xa               ;2895
0003ca  4631              MOV      r1,r6                 ;2895
0003cc  f7fffffe          BL       algorithm_Check_Mux_Delta
0003d0  4607              MOV      r7,r0                 ;2895
0003d2  2c09              CMP      r4,#9                 ;2897
0003d4  d007              BEQ      |L11.998|
                  |L11.982|
0003d6  1c60              ADDS     r0,r4,#1              ;2898
0003d8  b2c0              UXTB     r0,r0                 ;2898
0003da  2300              MOVS     r3,#0                 ;2898
0003dc  220a              MOVS     r2,#0xa               ;2898
0003de  4631              MOV      r1,r6                 ;2898
0003e0  f7fffffe          BL       algorithm_Check_Mux_Delta
0003e4  4680              MOV      r8,r0                 ;2898
                  |L11.998|
0003e6  2f00              CMP      r7,#0                 ;2901
0003e8  bf1e              ITTT     NE                    ;2901
0003ea  f1b80f00          CMPNE    r8,#0                 ;2901
0003ee  2001              MOVNE    r0,#1                 ;2902
0003f0  7028              STRBNE   r0,[r5,#0]            ;2902
0003f2  d101              BNE      |L11.1016|
                  |L11.1012|
0003f4  7828              LDRB     r0,[r5,#0]            ;2941  ; gbSkipTouch
0003f6  b350              CBZ      r0,|L11.1102|
                  |L11.1016|
0003f8  f04f0000          MOV      r0,#0                 ;2945
0003fc  7028              STRB     r0,[r5,#0]            ;2945
0003fe  8868              LDRH     r0,[r5,#2]            ;2946  ; gusSkipTouchCnt
000400  f1000001          ADD      r0,r0,#1              ;2946
000404  8068              STRH     r0,[r5,#2]            ;2946
                  |L11.1030|
000406  e01a              B        |L11.1086|
                  |L11.1032|
                          DCD      ||.data||
                  |L11.1036|
                          DCD      ||.data||+0x1c
                  |L11.1040|
                          DCD      ||.bss||+0x60
                  |L11.1044|
                          DCD      FullSharedBuff
                  |L11.1048|
                          DCD      ||.bss||+0x1a0
                  |L11.1052|
                          DCD      ||.bss||+0x100
                  |L11.1056|
                          DCD      ||.constdata||
                  |L11.1060|
                          DCD      FullSharedBuff+0x1f80
                  |L11.1064|
                          DCD      ||.bss||
                  |L11.1068|
                          DCD      ||.bss||+0x376
                  |L11.1072|
                          DCD      FullSharedBuff+0xf6c0
                  |L11.1076|
                          DCD      FullSharedBuff+0x3330
                  |L11.1080|
                          DCD      0x66666667
                  |L11.1084|
00043c  e014              B        |L11.1128|
                  |L11.1086|
00043e  f7fffffe          BL       algorithm_coord_UpdatePosHistoryInfo
000442  68a8              LDR      r0,[r5,#8]            ;2956  ; thisModeConf
000444  f8901043          LDRB     r1,[r0,#0x43]         ;2956
000448  2901              CMP      r1,#1                 ;2956
00044a  d003              BEQ      |L11.1108|
00044c  e00e              B        |L11.1132|
                  |L11.1102|
00044e  f7fffffe          BL       algorithm_PendTouchEvent
000452  e7d8              B        |L11.1030|
                  |L11.1108|
000454  990e              LDR      r1,[sp,#0x38]         ;2956
000456  b111              CBZ      r1,|L11.1118|
000458  2902              CMP      r1,#2                 ;2956
00045a  d004              BEQ      |L11.1126|
00045c  e006              B        |L11.1132|
                  |L11.1118|
00045e  f890004a          LDRB     r0,[r0,#0x4a]         ;2956
000462  2801              CMP      r0,#1                 ;2956
000464  d102              BNE      |L11.1132|
                  |L11.1126|
000466  4608              MOV      r0,r1                 ;2957
                  |L11.1128|
000468  f7fffffe          BL       algorithm_baseline_tracking_continuous
                  |L11.1132|
00046c  9801              LDR      r0,[sp,#4]            ;2960
00046e  2800              CMP      r0,#0                 ;2960
000470  bf18              IT       NE                    ;2960
000472  2000              MOVNE    r0,#0                 ;2960
000474  f43faed9          BEQ      |L11.554|
000478  b00f              ADD      sp,sp,#0x3c
00047a  e8bd8ff0          POP      {r4-r11,pc}
;;;2962   
                          ENDP


                          AREA ||i.algorithm_process_Idle||, CODE, READONLY, ALIGN=2

                  algorithm_process_Idle PROC
;;;3012   #if USED_IDLE_MODE_CONTROL
;;;3013   bool_t algorithm_process_Idle(void)
000000  b510              PUSH     {r4,lr}
;;;3014   {
000002  b086              SUB      sp,sp,#0x18
;;;3015   	bool_t bIsRecalState = NO;
;;;3016   
;;;3017   	memset(sLFOffsetRow, 0, sizeof(sLFOffsetRow));
000004  2160              MOVS     r1,#0x60
000006  4813              LDR      r0,|L12.84|
000008  f7fffffe          BL       __aeabi_memclr
;;;3018   	memset(sLFOffsetCol, 0, sizeof(sLFOffsetCol));
00000c  21a8              MOVS     r1,#0xa8
00000e  4812              LDR      r0,|L12.88|
000010  f7fffffe          BL       __aeabi_memclr
;;;3019   	alogorithm_linefilter_idle();
000014  f7fffffe          BL       alogorithm_linefilter_idle
;;;3020   	algorithm_baseline_calculate_delta_idle();
000018  f7fffffe          BL       algorithm_baseline_calculate_delta_idle
;;;3021   	algorithm_baseline_tracking_continuous_idle();
00001c  f7fffffe          BL       algorithm_baseline_tracking_continuous_idle
;;;3022   
;;;3023   	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_NI_GET_RAW_IMAGE_PTR(), COL_MAX, NI_ROW_MAX, 84/*MAX Intensity*/);
000020  4c0e              LDR      r4,|L12.92|
000022  e9d4010c          LDRD     r0,r1,[r4,#0x30]
000026  6ba2              LDR      r2,[r4,#0x38]  ; <Data11>
000028  9000              STR      r0,[sp,#0]
00002a  e9cd1201          STRD     r1,r2,[sp,#4]
00002e  4a0c              LDR      r2,|L12.96|
000030  4669              MOV      r1,sp
000032  2003              MOVS     r0,#3
000034  f7fffffe          BL       protocol_Log
;;;3024   //	#if USED_IDLE_FINGER_EVEN_ODD
;;;3025   //		protocol_LogMatrix(LT_INTENSITY, COL_MAX, HAL_NI_GET_DELTA_IMAGE_PTR(), COL_MAX, (LOCAL_FINGER_1MUX_ROW_NUM<<1), 84/*MAX Intensity*/);
;;;3026   //	#else
;;;3027   		protocol_LogMatrix(LT_INTENSITY, COL_MAX, HAL_NI_GET_DELTA_IMAGE_PTR(), COL_MAX, LOCAL_FINGER_1MUX_ROW_NUM, 84/*MAX Intensity*/);
000038  e9d4010f          LDRD     r0,r1,[r4,#0x3c]
00003c  6c62              LDR      r2,[r4,#0x44]  ; <Data12>
00003e  9205              STR      r2,[sp,#0x14]
000040  e9cd0103          STRD     r0,r1,[sp,#0xc]
000044  4a07              LDR      r2,|L12.100|
000046  a903              ADD      r1,sp,#0xc
000048  2004              MOVS     r0,#4
00004a  f7fffffe          BL       protocol_Log
;;;3028   //	#endif
;;;3029   
;;;3030   	return (bIsRecalState == NO);
;;;3031   }
00004e  b006              ADD      sp,sp,#0x18
000050  2001              MOVS     r0,#1                 ;3030
000052  bd10              POP      {r4,pc}
;;;3032   #endif /* USED_IDLE_MODE_CONTROL */
                          ENDP

                  |L12.84|
                          DCD      ||.bss||
                  |L12.88|
                          DCD      ||.bss||+0x376
                  |L12.92|
                          DCD      ||.constdata||
                  |L12.96|
                          DCD      FullSharedBuff
                  |L12.100|
                          DCD      FullSharedBuff+0x12600

                          AREA ||i.alogorithm_linefilter_2||, CODE, READONLY, ALIGN=2

                  alogorithm_linefilter_2 PROC
;;;1730    */
;;;1731   void alogorithm_linefilter_2(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1732   {
;;;1733   	uint32_t r, c;
;;;1734   	uint32_t i, j;
;;;1735   	int16_t d;
;;;1736   	int16_t SortBufCol[COL_MAX], TempBuf;
;;;1737   	uint8_t sort_cnt, sort_range;
;;;1738   	int16_t sub_offset;
;;;1739   	uint16_t * pBaseImage;
;;;1740   	int Max_Val, Min_Val;
;;;1741   	int lDiff, lDiffSum = 0, lDiffSumCnt = 0;
;;;1742   	int min_delta_th = (thisModeConf->SensingFilter.ucMinDeltaTh << ptModuleModeConf->ucOvrShift);
000004  495b              LDR      r1,|L13.372|
000006  b0c7              SUB      sp,sp,#0x11c          ;1732
;;;1743   	int lUpperTHD = thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift, lLowTHD = thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
;;;1744   //	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
;;;1745   
;;;1746   	//int max_compan_val = 11;
;;;1747   #if (ROW_MAX == 45)
;;;1748   	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44};
;;;1749   #elif (ROW_MAX == 47)
;;;1750   	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46};
;;;1751   #elif (ROW_MAX == 48)
;;;1752   	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47};
000008  ad30              ADD      r5,sp,#0xc0
00000a  688a              LDR      r2,[r1,#8]            ;1742  ; thisModeConf
00000c  6848              LDR      r0,[r1,#4]            ;1742  ; ptModuleModeConf
00000e  f8923054          LDRB     r3,[r2,#0x54]         ;1742
000012  7800              LDRB     r0,[r0,#0]            ;1742
000014  4083              LSLS     r3,r3,r0              ;1742
000016  9340              STR      r3,[sp,#0x100]        ;1743
000018  f9b2304d          LDRSH    r3,[r2,#0x4d]         ;1743
00001c  f9b2204f          LDRSH    r2,[r2,#0x4f]         ;1743
000020  fa03f700          LSL      r7,r3,r0              ;1743
000024  fa02f800          LSL      r8,r2,r0              ;1743
000028  a053              ADR      r0,|L13.376|
00002a  e8b0101c          LDM      r0!,{r2-r4,r12}
00002e  e885101c          STM      r5,{r2-r4,r12}
000032  e8b0101c          LDM      r0!,{r2-r4,r12}
000036  ad34              ADD      r5,sp,#0xd0
000038  e885101c          STM      r5,{r2-r4,r12}
00003c  e890100d          LDM      r0,{r0,r2,r3,r12}
000040  ac38              ADD      r4,sp,#0xe0
000042  e884100d          STM      r4,{r0,r2,r3,r12}
;;;1753   #elif (ROW_MAX == 50)
;;;1754   	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49};
;;;1755   #endif
;;;1756   	uint8_t row_cnt = sizeof(do_row);
;;;1757   	uint8_t real_row;
;;;1758   	
;;;1759   	sort_cnt = 4;//(uint8_t)(((int)COL_MAX * 5)/100);
;;;1760   	sort_range = COL_MAX/4 + COL_MAX%4;
;;;1761   
;;;1762   #if USED_NOISE_HOPPING_FREQ
;;;1763   	if(ptAppInfo->eCurrentSelectFreq == FREQ_MAIN)
000046  6908              LDR      r0,[r1,#0x10]  ; ptAppInfo
000048  7c80              LDRB     r0,[r0,#0x12]
00004a  2801              CMP      r0,#1
;;;1764   //	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;1765   	{
;;;1766   		pBaseImage = g_pFingerBaseImage;
00004c  bf0c              ITE      EQ
00004e  4856              LDREQ    r0,|L13.424|
;;;1767   	}
;;;1768   	else
;;;1769   	{
;;;1770   		pBaseImage = g_pFingerHop1BaseImage;
000050  4856              LDRNE    r0,|L13.428|
000052  6800              LDR      r0,[r0,#0]  ; g_pFingerHop1BaseImage
;;;1771   	}
;;;1772   #else /* USED_NOISE_HOPPING_FREQ */
;;;1773   	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;1774   #endif /* USED_NOISE_HOPPING_FREQ */
;;;1775   	
;;;1776   	for(r = 0; r < row_cnt; r++)
;;;1777   	{
;;;1778   		real_row = do_row[r];
;;;1779   		lDiffSum = 0, lDiffSumCnt = 0;
;;;1780   		Max_Val = INT16_MIN, Min_Val = INT16_MAX;
;;;1781   		for( c = 0; c < sort_range; c++ )
;;;1782   		{
;;;1783   			SortBufCol[c] = lDiff = (int16_t)HAL_READ_RAW_IMAGE(real_row, (c*4)) - (int16_t)pBaseImage[real_row*COL_MAX + c*4];
;;;1784   			
;;;1785   			if(lDiff < lUpperTHD && lDiff > lLowTHD)
;;;1786   			{
;;;1787   				if(Max_Val < lDiff)Max_Val = lDiff;
;;;1788   				if(Min_Val > lDiff)Min_Val = lDiff;
;;;1789   				lDiffSum += lDiff;
;;;1790   				lDiffSumCnt++;
;;;1791   			}
;;;1792   		}
;;;1793   		
;;;1794   		if(min_delta_th && Min_Val < -min_delta_th && thisInfo->tLabel.ucPalmCnt < 10)
000054  9041              STR      r0,[sp,#0x104]
000056  68c8              LDR      r0,[r1,#0xc]  ; thisInfo
000058  9042              STR      r0,[sp,#0x108]        ;1742
00005a  9840              LDR      r0,[sp,#0x100]
00005c  2500              MOVS     r5,#0                 ;1776
00005e  4240              RSBS     r0,r0,#0
000060  902e              STR      r0,[sp,#0xb8]
                  |L13.98|
000062  a830              ADD      r0,sp,#0xc0           ;1778
000064  9941              LDR      r1,[sp,#0x104]        ;1781
000066  5d46              LDRB     r6,[r0,r5]            ;1778
000068  4a52              LDR      r2,|L13.436|
00006a  ebc600c6          RSB      r0,r6,r6,LSL #3       ;1781
00006e  eb000040          ADD      r0,r0,r0,LSL #1       ;1781
000072  f04f0b00          MOV      r11,#0                ;1779
000076  f8dfa138          LDR      r10,|L13.432|
00007a  465c              MOV      r4,r11                ;1779
00007c  f64779ff          MOV      r9,#0x7fff            ;1780
000080  eb0101c0          ADD      r1,r1,r0,LSL #3       ;1781
000084  466b              MOV      r3,sp                 ;1781
000086  eb0202c0          ADD      r2,r2,r0,LSL #3       ;1781
00008a  f04f0c15          MOV      r12,#0x15             ;1781
00008e  bf00              NOP                            ;1783
                  |L13.144|
000090  f9b20000          LDRSH    r0,[r2,#0]            ;1783
000094  f9b1e000          LDRSH    lr,[r1,#0]            ;1783
000098  eba0000e          SUB      r0,r0,lr              ;1783
00009c  f8230b02          STRH     r0,[r3],#2            ;1783
0000a0  42b8              CMP      r0,r7                 ;1785
0000a2  bfb8              IT       LT                    ;1785
0000a4  4580              CMPLT    r8,r0                 ;1785
0000a6  da05              BGE      |L13.180|
0000a8  4582              CMP      r10,r0                ;1787
0000aa  db5e              BLT      |L13.362|
                  |L13.172|
0000ac  4581              CMP      r9,r0                 ;1788
0000ae  dc5e              BGT      |L13.366|
                  |L13.176|
0000b0  4483              ADD      r11,r11,r0            ;1789
0000b2  1c64              ADDS     r4,r4,#1              ;1789
                  |L13.180|
0000b4  3108              ADDS     r1,r1,#8              ;1789
0000b6  3208              ADDS     r2,r2,#8              ;1789
0000b8  f1bc0c01          SUBS     r12,r12,#1            ;1789
0000bc  d1e8              BNE      |L13.144|
0000be  9840              LDR      r0,[sp,#0x100]
0000c0  b188              CBZ      r0,|L13.230|
0000c2  982e              LDR      r0,[sp,#0xb8]
0000c4  4581              CMP      r9,r0
0000c6  da0d              BGE      |L13.228|
0000c8  9842              LDR      r0,[sp,#0x108]
0000ca  f8900368          LDRB     r0,[r0,#0x368]
0000ce  280a              CMP      r0,#0xa
0000d0  d208              BCS      |L13.228|
;;;1795   		{
;;;1796   			if(lDiffSumCnt > 3)
0000d2  2c03              CMP      r4,#3
0000d4  dd27              BLE      |L13.294|
;;;1797   			{
;;;1798   				sLFOffsetRow[real_row] = lDiffSum / ((int16_t)lDiffSumCnt);
0000d6  b220              SXTH     r0,r4
0000d8  fb9bf0f0          SDIV     r0,r11,r0
0000dc  4936              LDR      r1,|L13.440|
0000de  f8210016          STRH     r0,[r1,r6,LSL #1]
0000e2  e020              B        |L13.294|
                  |L13.228|
;;;1799   			}
;;;1800   		}
;;;1801   		else
;;;1802   		{
;;;1803   			for( i=0; i<=(sort_cnt); i++ )
0000e4  2000              MOVS     r0,#0
                  |L13.230|
0000e6  4669              MOV      r1,sp                 ;1736
                  |L13.232|
;;;1804   			{
;;;1805   				for( j=(i+1); j<sort_range; j++ )
0000e8  eb010240          ADD      r2,r1,r0,LSL #1
0000ec  f1c00c14          RSB      r12,r0,#0x14
0000f0  f1120202          ADDS.W   r2,r2,#2
                  |L13.244|
;;;1806   				{
;;;1807   					if( SortBufCol[i] > SortBufCol[j] )
0000f4  f9313010          LDRSH    r3,[r1,r0,LSL #1]
0000f8  f9b24000          LDRSH    r4,[r2,#0]
0000fc  42a3              CMP      r3,r4
;;;1808   					{
;;;1809   						TempBuf = SortBufCol[i];
;;;1810   						SortBufCol[i] = SortBufCol[j];
0000fe  bfc4              ITT      GT
000100  f8214010          STRHGT   r4,[r1,r0,LSL #1]
;;;1811   						SortBufCol[j] = TempBuf;
000104  8013              STRHGT   r3,[r2,#0]
000106  1c92              ADDS     r2,r2,#2
000108  f1bc0c01          SUBS     r12,r12,#1
00010c  d1f2              BNE      |L13.244|
                  |L13.270|
00010e  1c40              ADDS     r0,r0,#1              ;1807
;;;1812   					}
000110  2805              CMP      r0,#5
000112  d203              BCS      |L13.284|
000114  1c42              ADDS     r2,r0,#1              ;1805
000116  2a15              CMP      r2,#0x15              ;1805
000118  d2f9              BCS      |L13.270|
00011a  e7e5              B        |L13.232|
                  |L13.284|
;;;1813   				}
;;;1814   			}
;;;1815   			TempBuf = SortBufCol[sort_cnt];
;;;1816   			
;;;1817   			sLFOffsetRow[real_row] = TempBuf;
00011c  4926              LDR      r1,|L13.440|
00011e  f8bd0008          LDRH     r0,[sp,#8]            ;1815
000122  f8210016          STRH     r0,[r1,r6,LSL #1]
                  |L13.294|
000126  1c6d              ADDS     r5,r5,#1
000128  2d30              CMP      r5,#0x30
00012a  d39a              BCC      |L13.98|
00012c  4d21              LDR      r5,|L13.436|
00012e  4e22              LDR      r6,|L13.440|
;;;1818   		}
;;;1819   	}
;;;1820   
;;;1821   #if !FAST_LF_EN		
;;;1822   	for(r = 0; r < row_cnt; r++)
000130  2300              MOVS     r3,#0
000132  ac30              ADD      r4,sp,#0xc0           ;1752
                  |L13.308|
;;;1823   	{
;;;1824   		real_row = do_row[r];
;;;1825   		for( c=0; c<COL_MAX; c++ )
000134  2254              MOVS     r2,#0x54
000136  5ce0              LDRB     r0,[r4,r3]            ;1824
;;;1826   		{
;;;1827   			d = (int16_t)HAL_READ_RAW_IMAGE(real_row, c);
;;;1828   			sub_offset = sLFOffsetRow[real_row];
000138  f936c010          LDRSH    r12,[r6,r0,LSL #1]
00013c  ebc000c0          RSB      r0,r0,r0,LSL #3       ;1825
000140  eb000040          ADD      r0,r0,r0,LSL #1       ;1825
000144  eb0500c0          ADD      r0,r5,r0,LSL #3       ;1825
                  |L13.328|
000148  8801              LDRH     r1,[r0,#0]            ;1827
;;;1829   			d = d - sub_offset;
00014a  eba1010c          SUB      r1,r1,r12
00014e  b209              SXTH     r1,r1
;;;1830   			if(d < 0)
000150  2900              CMP      r1,#0
;;;1831   			{
;;;1832   				d = 0;
000152  bfb8              IT       LT
000154  2100              MOVLT    r1,#0
;;;1833   			}
;;;1834   			HAL_WRITE_RAW_IMAGE(real_row, c, (uint16_t)d);
000156  f8201b02          STRH     r1,[r0],#2
00015a  1e52              SUBS     r2,r2,#1
00015c  d1f4              BNE      |L13.328|
00015e  1c5b              ADDS     r3,r3,#1              ;1830
000160  2b30              CMP      r3,#0x30
000162  d3e7              BCC      |L13.308|
;;;1835   		}
;;;1836   	}
;;;1837   #endif
;;;1838   }
000164  b047              ADD      sp,sp,#0x11c
000166  e8bd8ff0          POP      {r4-r11,pc}
                  |L13.362|
00016a  4682              MOV      r10,r0                ;1787
00016c  e79e              B        |L13.172|
                  |L13.366|
00016e  4681              MOV      r9,r0                 ;1788
000170  e79e              B        |L13.176|
;;;1839   #if FINGER_LF_VER1_EN
                          ENDP

000172  0000              DCW      0x0000
                  |L13.372|
                          DCD      ||.data||
                  |L13.376|
000178  00                DCB      0
000179  01020304          DCB      1,2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,17,18,19,20,21,22,23
00017d  05060708
000181  090a0b0c
000185  0d0e0f10
000189  11121314
00018d  151617  
000190  18191a1b          DCB      24,25,26,27,28,29,30,31," !""#$$%&'()*+,-./"
000194  1c1d1e1f
000198  20212223
00019c  24252627
0001a0  28292a2b
0001a4  2c2d2e2f
                  |L13.424|
                          DCD      g_pFingerBaseImage
                  |L13.428|
                          DCD      g_pFingerHop1BaseImage
                  |L13.432|
                          DCD      0xffff8000
                  |L13.436|
                          DCD      FullSharedBuff
                  |L13.440|
                          DCD      ||.bss||

                          AREA ||i.alogorithm_linefilter_idle||, CODE, READONLY, ALIGN=2

                  alogorithm_linefilter_idle PROC
;;;2030   #if (USED_LOCAL_IDLE_MODE_CONTROL || USED_IDLE_MODE_CONTROL)
;;;2031   void alogorithm_linefilter_idle(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2032   {
;;;2033   	int32_t r, c;
;;;2034   	int16_t LINE_FILTER_UPPER_LIMIT			= (thisModeConf->SensingFilter.sLineFilterUpLimit_Idle) << ptModuleModeConf->ucIdleOvrShift; //thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
000004  492a              LDR      r1,|L14.176|
;;;2035   	int16_t LINE_FILTER_LOWER_LIMIT			= (thisModeConf->SensingFilter.sLineFilterLowLimit_Idle) << ptModuleModeConf->ucIdleOvrShift; //thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
;;;2036   	uint8_t LINE_FILTER_COL_OFFSET			= (thisModeConf->SensingFilter.ucLineFilterColOffset);
;;;2037   	int16_t sDiff;
;;;2038   	int16_t sDiffSum = 0;
;;;2039   	uint32_t ulDiffSumCnt = 0;
;;;2040   
;;;2041   	uint16_t *pBaseImage, *pRawImage;
;;;2042   
;;;2043   	pRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
;;;2044   	pBaseImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
000006  f8dfb0b0          LDR      r11,|L14.184|
00000a  6888              LDR      r0,[r1,#8]            ;2034  ; thisModeConf
00000c  6849              LDR      r1,[r1,#4]            ;2034  ; ptModuleModeConf
00000e  f8b0205c          LDRH     r2,[r0,#0x5c]         ;2034
000012  7849              LDRB     r1,[r1,#1]            ;2034
000014  f890c051          LDRB     r12,[r0,#0x51]        ;2036
000018  408a              LSLS     r2,r2,r1              ;2034
00001a  fa0ff882          SXTH     r8,r2                 ;2034
00001e  f8b0205e          LDRH     r2,[r0,#0x5e]         ;2035
000022  4824              LDR      r0,|L14.180|
000024  fa02f101          LSL      r1,r2,r1              ;2035
000028  fa0ff981          SXTH     r9,r1                 ;2035
;;;2045   
;;;2046   	for(r = 0; r < NI_ROW_MAX; r++)
00002c  2100              MOVS     r1,#0
;;;2047   	{
;;;2048   		sDiffSum = 0;
;;;2049   		ulDiffSumCnt = 0;
;;;2050   		for(c = 0; c < COL_MAX; c+=LINE_FILTER_COL_OFFSET)
00002e  f10c0a53          ADD      r10,r12,#0x53
000032  9000              STR      r0,[sp,#0]
                  |L14.52|
000034  fbbaf3fc          UDIV     r3,r10,r12
000038  2700              MOVS     r7,#0                 ;2048
00003a  463c              MOV      r4,r7                 ;2049
00003c  2b00              CMP      r3,#0
00003e  dd31              BLE      |L14.164|
000040  ebc100c1          RSB      r0,r1,r1,LSL #3
000044  eb000540          ADD      r5,r0,r0,LSL #1
000048  9800              LDR      r0,[sp,#0]
00004a  eb0b06c5          ADD      r6,r11,r5,LSL #3
00004e  eb0000c5          ADD      r0,r0,r5,LSL #3
000052  4602              MOV      r2,r0
                  |L14.84|
;;;2051   		{
;;;2052   			sDiff = (int16_t)(pRawImage[r*COL_MAX+c] - pBaseImage[r*COL_MAX+c]);
000054  f8b6e000          LDRH     lr,[r6,#0]
000058  8815              LDRH     r5,[r2,#0]
00005a  eba5050e          SUB      r5,r5,lr
00005e  b22d              SXTH     r5,r5
;;;2053   			if(sDiff < LINE_FILTER_UPPER_LIMIT || sDiff > LINE_FILTER_LOWER_LIMIT)
000060  4545              CMP      r5,r8
000062  db01              BLT      |L14.104|
000064  454d              CMP      r5,r9
000066  dd02              BLE      |L14.110|
                  |L14.104|
;;;2054   			{
;;;2055   				sDiffSum += sDiff;
000068  443d              ADD      r5,r5,r7
00006a  b22f              SXTH     r7,r5
00006c  1c64              ADDS     r4,r4,#1
                  |L14.110|
;;;2056   				ulDiffSumCnt++;
;;;2057   			}
00006e  eb02024c          ADD      r2,r2,r12,LSL #1
000072  eb06064c          ADD      r6,r6,r12,LSL #1
000076  1e5b              SUBS     r3,r3,#1
000078  d1ec              BNE      |L14.84|
;;;2058   		}
;;;2059   
;;;2060   		if(ulDiffSumCnt > 3)
00007a  2c03              CMP      r4,#3
00007c  d912              BLS      |L14.164|
;;;2061   		{
;;;2062   			sLFOffsetRow[r] = sDiffSum / ((int16_t)ulDiffSumCnt);
00007e  b222              SXTH     r2,r4
000080  fb97f2f2          SDIV     r2,r7,r2
000084  4c0d              LDR      r4,|L14.188|
;;;2063   
;;;2064   			for(c = 0; c < COL_MAX; c++)
000086  2354              MOVS     r3,#0x54
000088  f8242011          STRH     r2,[r4,r1,LSL #1]     ;2062
                  |L14.140|
;;;2065   			{
;;;2066   				sDiff = (int16_t)pRawImage[r*COL_MAX+c] - sLFOffsetRow[r];
00008c  8802              LDRH     r2,[r0,#0]
00008e  f8345011          LDRH     r5,[r4,r1,LSL #1]
000092  1b52              SUBS     r2,r2,r5
000094  b212              SXTH     r2,r2
;;;2067   				if(sDiff < 0)
000096  2a00              CMP      r2,#0
;;;2068   					sDiff = 0;
000098  bfb8              IT       LT
00009a  2200              MOVLT    r2,#0
;;;2069   				pRawImage[r*COL_MAX+c] = (uint16_t)sDiff;
00009c  f8202b02          STRH     r2,[r0],#2
0000a0  1e5b              SUBS     r3,r3,#1
0000a2  d1f3              BNE      |L14.140|
                  |L14.164|
0000a4  1c49              ADDS     r1,r1,#1              ;2067
0000a6  290a              CMP      r1,#0xa
0000a8  dbc4              BLT      |L14.52|
;;;2070   			}
;;;2071   		}
;;;2072   	}
;;;2073   }
0000aa  e8bd8ff8          POP      {r3-r11,pc}
;;;2074   #endif /* (USED_LOCAL_IDLE_MODE_CONTROL || USED_IDLE_MODE_CONTROL) */
                          ENDP

0000ae  0000              DCW      0x0000
                  |L14.176|
                          DCD      ||.data||
                  |L14.180|
                          DCD      FullSharedBuff
                  |L14.184|
                          DCD      FullSharedBuff+0x12c90
                  |L14.188|
                          DCD      ||.bss||

                          AREA ||i.alogorithm_linefilter_simple||, CODE, READONLY, ALIGN=2

                  alogorithm_linefilter_simple PROC
;;;1966   #endif
;;;1967   void alogorithm_linefilter_simple(eSENSING_MODE_t eSensingMode)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1968   {
;;;1969   	uint32_t r, c, pos;
;;;1970   	int16_t LINE_FILTER_UPPER_LIMIT			= thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
000004  482e              LDR      r0,|L15.192|
000006  6881              LDR      r1,[r0,#8]  ; thisModeConf
000008  6842              LDR      r2,[r0,#4]  ; ptModuleModeConf
;;;1971   	int16_t LINE_FILTER_LOWER_LIMIT			= thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
;;;1972   	uint8_t LINE_FILTER_COL_OFFSET			= (thisModeConf->SensingFilter.ucLineFilterColOffset);
;;;1973   	
;;;1974   	int16_t lDiff;
;;;1975   	int16_t lDiffSum = 0;//, lDiffSum2 = 0;
;;;1976   	uint32_t lDiffSumCnt = 0;//, lDiffSumCnt2 = 0;
;;;1977   	int32_t lLowTHD, lUpperTHD;
;;;1978   	uint16_t * pBaseImage;
;;;1979   //	uint16_t rawdata;
;;;1980   //	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
;;;1981   
;;;1982   	lUpperTHD = LINE_FILTER_UPPER_LIMIT;
;;;1983   	lLowTHD = LINE_FILTER_LOWER_LIMIT;
;;;1984   
;;;1985   #if USED_NOISE_HOPPING_FREQ
;;;1986   	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
00000a  6900              LDR      r0,[r0,#0x10]  ; ptAppInfo
00000c  f8b1304d          LDRH     r3,[r1,#0x4d]         ;1970
000010  7812              LDRB     r2,[r2,#0]            ;1970
000012  7cc0              LDRB     r0,[r0,#0x13]
000014  4093              LSLS     r3,r3,r2              ;1970
000016  b21c              SXTH     r4,r3                 ;1970
000018  f8b1304f          LDRH     r3,[r1,#0x4f]         ;1971
00001c  f891c051          LDRB     r12,[r1,#0x51]        ;1972
000020  fa03f202          LSL      r2,r3,r2              ;1971
000024  fa0ff882          SXTH     r8,r2                 ;1971
000028  2801              CMP      r0,#1
;;;1987   	{
;;;1988   		pBaseImage = g_pFingerBaseImage;
00002a  bf0c              ITE      EQ
00002c  4825              LDREQ    r0,|L15.196|
;;;1989   	}
;;;1990   	else
;;;1991   	{
;;;1992   		pBaseImage = g_pFingerHop1BaseImage;
00002e  4826              LDRNE    r0,|L15.200|
000030  6800              LDR      r0,[r0,#0]  ; g_pFingerHop1BaseImage
;;;1993   	}
;;;1994   //	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;1995   #else /* USED_NOISE_HOPPING_FREQ */
;;;1996   	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;1997   #endif /* USED_NOISE_HOPPING_FREQ */
;;;1998   
;;;1999   	pos = 0;
000032  f04f0900          MOV      r9,#0
;;;2000   	for(r=0; r< ROW_MAX; r++, pos += COL_MAX)
000036  4649              MOV      r1,r9
;;;2001   	{
;;;2002   		lDiffSumCnt = 0;
;;;2003   		lDiffSum = 0;
;;;2004   
;;;2005   		for(c = 0; c < COL_MAX; c+=LINE_FILTER_COL_OFFSET)
000038  f10c0b53          ADD      r11,r12,#0x53
00003c  9000              STR      r0,[sp,#0]
                  |L15.62|
00003e  fbbbf3fc          UDIV     r3,r11,r12
000042  2600              MOVS     r6,#0                 ;2002
000044  46b2              MOV      r10,r6                ;2003
000046  2b00              CMP      r3,#0
000048  d033              BEQ      |L15.178|
00004a  9800              LDR      r0,[sp,#0]
00004c  eb000549          ADD      r5,r0,r9,LSL #1
000050  ebc100c1          RSB      r0,r1,r1,LSL #3
000054  eb000240          ADD      r2,r0,r0,LSL #1
000058  481c              LDR      r0,|L15.204|
00005a  eb0000c2          ADD      r0,r0,r2,LSL #3
00005e  4602              MOV      r2,r0
                  |L15.96|
;;;2006   		{
;;;2007   			lDiff = (int16_t)(HAL_READ_RAW_IMAGE(r, c) - pBaseImage[pos+c]);
000060  f8b5e000          LDRH     lr,[r5,#0]
000064  8817              LDRH     r7,[r2,#0]
000066  eba7070e          SUB      r7,r7,lr
00006a  b23f              SXTH     r7,r7
;;;2008   			if(lDiff < lUpperTHD && lDiff > lLowTHD)
00006c  42a7              CMP      r7,r4
00006e  bfb8              IT       LT
000070  45b8              CMPLT    r8,r7
000072  da03              BGE      |L15.124|
;;;2009   			{
;;;2010   				lDiffSum += lDiff;
000074  4457              ADD      r7,r7,r10
000076  fa0ffa87          SXTH     r10,r7
00007a  1c76              ADDS     r6,r6,#1
                  |L15.124|
;;;2011   				lDiffSumCnt++;
;;;2012   			}
00007c  eb05054c          ADD      r5,r5,r12,LSL #1
000080  eb02024c          ADD      r2,r2,r12,LSL #1
000084  1e5b              SUBS     r3,r3,#1
000086  d1eb              BNE      |L15.96|
;;;2013   		}
;;;2014   
;;;2015   		if(lDiffSumCnt > 3)
000088  2e03              CMP      r6,#3
00008a  d912              BLS      |L15.178|
;;;2016   		{
;;;2017   			sLFOffsetRow[r] = lDiffSum / ((int16_t)lDiffSumCnt);
00008c  b232              SXTH     r2,r6
00008e  fb9af2f2          SDIV     r2,r10,r2
000092  4d0f              LDR      r5,|L15.208|
;;;2018   #if !FAST_LF_EN		
;;;2019   			for(c = 0; c < COL_MAX; c++)
000094  2354              MOVS     r3,#0x54
000096  f8252011          STRH     r2,[r5,r1,LSL #1]     ;2017
                  |L15.154|
;;;2020   			{
;;;2021   				lDiff = (((int16_t)HAL_READ_RAW_IMAGE(r, c)) - sLFOffsetRow[r]);
00009a  8802              LDRH     r2,[r0,#0]
00009c  f8356011          LDRH     r6,[r5,r1,LSL #1]
0000a0  1b92              SUBS     r2,r2,r6
0000a2  b212              SXTH     r2,r2
;;;2022   				if(lDiff<0)lDiff=0;
0000a4  2a00              CMP      r2,#0
0000a6  bfb8              IT       LT
0000a8  2200              MOVLT    r2,#0
;;;2023   				HAL_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
0000aa  f8202b02          STRH     r2,[r0],#2
0000ae  1e5b              SUBS     r3,r3,#1
0000b0  d1f3              BNE      |L15.154|
                  |L15.178|
0000b2  1c49              ADDS     r1,r1,#1              ;2022
0000b4  f1090954          ADD      r9,r9,#0x54           ;2022
;;;2024   			}
;;;2025   #endif
;;;2026   		}
;;;2027   	}
0000b8  2930              CMP      r1,#0x30
0000ba  d3c0              BCC      |L15.62|
;;;2028   }
0000bc  e8bd8ff8          POP      {r3-r11,pc}
;;;2029   
                          ENDP

                  |L15.192|
                          DCD      ||.data||
                  |L15.196|
                          DCD      g_pFingerBaseImage
                  |L15.200|
                          DCD      g_pFingerHop1BaseImage
                  |L15.204|
                          DCD      FullSharedBuff
                  |L15.208|
                          DCD      ||.bss||

                          AREA ||i.alogorithm_vertical_linefilter||, CODE, READONLY, ALIGN=2

                  alogorithm_vertical_linefilter PROC
;;;2128   int16_t sLFOffsetCol[COL_MAX];
;;;2129   void alogorithm_vertical_linefilter(eSENSING_MODE_t eSensingMode)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2130   {
;;;2131   	uint32_t r, c;
;;;2132   	int16_t LINE_FILTER_UPPER_LIMIT			= ((15)<<ptModuleModeConf->ucOvrShift); //thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
000004  492b              LDR      r1,|L16.180|
000006  6848              LDR      r0,[r1,#4]  ; ptModuleModeConf
000008  7802              LDRB     r2,[r0,#0]
00000a  200f              MOVS     r0,#0xf
00000c  fa00f202          LSL      r2,r0,r2
000010  b210              SXTH     r0,r2
;;;2133   	int16_t LINE_FILTER_LOWER_LIMIT			= (-((15)<<ptModuleModeConf->ucOvrShift)); //thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
;;;2134   	uint8_t LINE_FILTER_ROW_OFFSET			= 3;//(thisModeConf->SensingFilter.ucLineFilterColOffset);
;;;2135   
;;;2136   	int16_t lDiff;
;;;2137   	int16_t lDiffSum = 0;
;;;2138   	uint32_t lDiffSumCnt = 0;
;;;2139   	int32_t lLowTHD, lUpperTHD;
;;;2140   	uint16_t * pBaseImage;
;;;2141   
;;;2142   	lUpperTHD = (LINE_FILTER_UPPER_LIMIT>>1);
000012  1047              ASRS     r7,r0,#1
;;;2143   	lLowTHD = (LINE_FILTER_LOWER_LIMIT>>1);
;;;2144   
;;;2145   #if USED_NOISE_HOPPING_FREQ
;;;2146   	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
000014  6908              LDR      r0,[r1,#0x10]  ; ptAppInfo
000016  4252              RSBS     r2,r2,#0              ;2133
000018  b212              SXTH     r2,r2                 ;2133
00001a  7cc0              LDRB     r0,[r0,#0x13]
00001c  ea4f0862          ASR      r8,r2,#1              ;2143
000020  2801              CMP      r0,#1
;;;2147   	{
;;;2148   		pBaseImage = g_pFingerBaseImage;
000022  bf0c              ITE      EQ
000024  4824              LDREQ    r0,|L16.184|
;;;2149   	}
;;;2150   	else
;;;2151   	{
;;;2152   		pBaseImage = g_pFingerHop1BaseImage;
000026  4825              LDRNE    r0,|L16.188|
;;;2153   	}
;;;2154   //	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;2155   #else /* USED_NOISE_HOPPING_FREQ */
;;;2156   	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;2157   #endif /* USED_NOISE_HOPPING_FREQ */
;;;2158   
;;;2159   	for(c=0; c<COL_MAX; c++)
000028  2100              MOVS     r1,#0
;;;2160   	{
;;;2161   		lDiffSumCnt = 0;
;;;2162   		lDiffSum = 0;
;;;2163   		for(r = 0; r < ROW_MAX; r+=LINE_FILTER_ROW_OFFSET)
00002a  f8dfb094          LDR      r11,|L16.192|
;;;2164   		{
;;;2165   			lDiff = (int16_t)(HAL_READ_RAW_IMAGE(r, c) - pBaseImage[(r*COL_MAX)+c]);
;;;2166   			if(lDiff < lUpperTHD && lDiff > lLowTHD)
;;;2167   			{
;;;2168   				lDiffSum += lDiff;
;;;2169   				lDiffSumCnt++;
;;;2170   			}
;;;2171   			else
;;;2172   			{
;;;2173   				if(lDiff > lUpperTHD)
;;;2174   				{
;;;2175   					lDiff += lUpperTHD;
;;;2176   					lDiffSumCnt++;
;;;2177   				}
;;;2178   				else if(lDiff < lLowTHD)
;;;2179   				{
;;;2180   					lDiff += lLowTHD;
;;;2181   					lDiffSumCnt++;
;;;2182   				}
;;;2183   			}
;;;2184   		}
;;;2185   
;;;2186   		if(lDiffSumCnt > 3)
;;;2187   		{
;;;2188   			sLFOffsetCol[c] = lDiffSum / ((int16_t)lDiffSumCnt);
00002e  f8dfa094          LDR      r10,|L16.196|
000032  f8d09000          LDR      r9,[r0,#0]  ; g_pFingerHop1BaseImage
                  |L16.54|
000036  2000              MOVS     r0,#0                 ;2161
000038  eb0b0241          ADD      r2,r11,r1,LSL #1      ;2163
00003c  4606              MOV      r6,r0                 ;2162
00003e  2410              MOVS     r4,#0x10              ;2163
000040  eb090541          ADD      r5,r9,r1,LSL #1       ;2163
000044  ea4f0302          MOV.W    r3,r2                 ;2163
                  |L16.72|
000048  f8b5e000          LDRH     lr,[r5,#0]            ;2165
00004c  f8b3c000          LDRH     r12,[r3,#0]           ;2165
000050  ebac0c0e          SUB      r12,r12,lr            ;2165
000054  fa0ffc8c          SXTH     r12,r12               ;2165
000058  45bc              CMP      r12,r7                ;2166
00005a  bfb8              IT       LT                    ;2166
00005c  45e0              CMPLT    r8,r12                ;2166
00005e  da04              BGE      |L16.106|
000060  44b4              ADD      r12,r12,r6            ;2168
000062  fa0ff68c          SXTH     r6,r12                ;2168
000066  1c40              ADDS     r0,r0,#1              ;2168
000068  e004              B        |L16.116|
                  |L16.106|
00006a  4567              CMP      r7,r12                ;2173
00006c  db01              BLT      |L16.114|
00006e  45e0              CMP      r8,r12                ;2178
000070  dd00              BLE      |L16.116|
                  |L16.114|
000072  1c40              ADDS     r0,r0,#1              ;2178
                  |L16.116|
000074  f50373fc          ADD      r3,r3,#0x1f8          ;2178
000078  1e64              SUBS     r4,r4,#1              ;2178
00007a  f50575fc          ADD      r5,r5,#0x1f8          ;2178
00007e  d1e3              BNE      |L16.72|
000080  2803              CMP      r0,#3                 ;2186
000082  d912              BLS      |L16.170|
000084  b200              SXTH     r0,r0
000086  fb96f0f0          SDIV     r0,r6,r0
00008a  f82a0011          STRH     r0,[r10,r1,LSL #1]
;;;2189   #if !FAST_LF_EN		
;;;2190   			for(r = 0; r < ROW_MAX; r++)
00008e  2330              MOVS     r3,#0x30
                  |L16.144|
;;;2191   			{
;;;2192   				lDiff = (((int16_t)HAL_READ_RAW_IMAGE(r, c)) - sLFOffsetCol[c]);
000090  8810              LDRH     r0,[r2,#0]
000092  f83ac011          LDRH     r12,[r10,r1,LSL #1]
000096  eba0000c          SUB      r0,r0,r12
00009a  b200              SXTH     r0,r0
;;;2193   				if(lDiff<0)
00009c  2800              CMP      r0,#0
;;;2194   					lDiff=0;
00009e  bfb8              IT       LT
0000a0  2000              MOVLT    r0,#0
;;;2195   				HAL_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
0000a2  f8220ba8          STRH     r0,[r2],#0xa8
0000a6  1e5b              SUBS     r3,r3,#1
0000a8  d1f2              BNE      |L16.144|
                  |L16.170|
0000aa  1c49              ADDS     r1,r1,#1              ;2193
0000ac  2954              CMP      r1,#0x54
0000ae  d3c2              BCC      |L16.54|
;;;2196   			}
;;;2197   #endif
;;;2198   		}
;;;2199   	}
;;;2200   }
0000b0  e8bd8ff0          POP      {r4-r11,pc}
;;;2201   
                          ENDP

                  |L16.180|
                          DCD      ||.data||
                  |L16.184|
                          DCD      g_pFingerBaseImage
                  |L16.188|
                          DCD      g_pFingerHop1BaseImage
                  |L16.192|
                          DCD      FullSharedBuff
                  |L16.196|
                          DCD      ||.bss||+0x376

                          AREA ||i.alogorithm_vertical_linefilter_simple||, CODE, READONLY, ALIGN=2

                  alogorithm_vertical_linefilter_simple PROC
;;;2201   
;;;2202   void alogorithm_vertical_linefilter_simple(eSENSING_MODE_t eSensingMode)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2203   {
;;;2204   	uint32_t r, c, pos;
;;;2205   	int16_t LINE_FILTER_UPPER_LIMIT			= thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
000004  4e2a              LDR      r6,|L17.176|
000006  b0ab              SUB      sp,sp,#0xac           ;2203
000008  68b1              LDR      r1,[r6,#8]  ; thisModeConf
00000a  6870              LDR      r0,[r6,#4]  ; ptModuleModeConf
00000c  f8b1204d          LDRH     r2,[r1,#0x4d]
000010  7800              LDRB     r0,[r0,#0]
;;;2206   	int16_t LINE_FILTER_LOWER_LIMIT			= thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
000012  f8b1104f          LDRH     r1,[r1,#0x4f]
000016  4082              LSLS     r2,r2,r0              ;2205
000018  fa01f000          LSL      r0,r1,r0
00001c  b205              SXTH     r5,r0
00001e  b214              SXTH     r4,r2                 ;2205
;;;2207   //	uint8_t LINE_FILTER_COL_OFFSET			= (thisModeConf->SensingFilter.ucLineFilterColOffset);
;;;2208   	
;;;2209   	int16_t sLFOffsetCol[COL_MAX] = {0};
000020  21a8              MOVS     r1,#0xa8
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       __aeabi_memclr4
;;;2210   	int16_t lDiff;
;;;2211   	int16_t lDiffSum = 0;
;;;2212   	uint32_t lDiffSumCnt = 0;
;;;2213   	int32_t lLowTHD, lUpperTHD;
;;;2214   	uint16_t * pBaseImage;
;;;2215   //	uint16_t rawdata;
;;;2216   //	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
;;;2217   
;;;2218   	lUpperTHD = LINE_FILTER_UPPER_LIMIT;
;;;2219   	lLowTHD = LINE_FILTER_LOWER_LIMIT;
;;;2220   
;;;2221   #if USED_NOISE_HOPPING_FREQ
;;;2222   	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
000028  6930              LDR      r0,[r6,#0x10]  ; ptAppInfo
00002a  7cc0              LDRB     r0,[r0,#0x13]
00002c  2801              CMP      r0,#1
;;;2223   	{
;;;2224   		pBaseImage = g_pFingerBaseImage;
00002e  bf0c              ITE      EQ
000030  4820              LDREQ    r0,|L17.180|
;;;2225   	}
;;;2226   	else
;;;2227   	{
;;;2228   		pBaseImage = g_pFingerHop1BaseImage;
000032  4821              LDRNE    r0,|L17.184|
;;;2229   	}
;;;2230   //	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;2231   #else /* USED_NOISE_HOPPING_FREQ */
;;;2232   	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;2233   #endif /* USED_NOISE_HOPPING_FREQ */
;;;2234   
;;;2235   	for(c=0; c<COL_MAX; c++)
000034  f8d09000          LDR      r9,[r0,#0]  ; g_pFingerHop1BaseImage
;;;2236   	{
;;;2237   		lDiffSumCnt = 0;
;;;2238   		lDiffSum = 0;
;;;2239   		
;;;2240   		pos = c;
;;;2241   		for(r = 0; r < ROW_MAX; r+=2,pos += (COL_MAX<<1))
000038  f8dfb080          LDR      r11,|L17.188|
00003c  2000              MOVS     r0,#0                 ;2235
00003e  46ea              MOV      r10,sp                ;2209
                  |L17.64|
000040  2300              MOVS     r3,#0                 ;2237
000042  eb0b0140          ADD      r1,r11,r0,LSL #1
000046  461e              MOV      r6,r3                 ;2238
000048  eb090c40          ADD      r12,r9,r0,LSL #1
00004c  460a              MOV      r2,r1
00004e  f04f0818          MOV      r8,#0x18
                  |L17.82|
;;;2242   		{
;;;2243   			lDiff = (int16_t)(HAL_READ_RAW_IMAGE(r, c) - pBaseImage[pos]);
000052  8817              LDRH     r7,[r2,#0]
000054  f8bce000          LDRH     lr,[r12,#0]
000058  eba7070e          SUB      r7,r7,lr
00005c  b23f              SXTH     r7,r7
;;;2244   			if(lDiff < lUpperTHD && lDiff > lLowTHD)
00005e  42a7              CMP      r7,r4
000060  bfb8              IT       LT
000062  42bd              CMPLT    r5,r7
000064  da02              BGE      |L17.108|
;;;2245   			{
;;;2246   				lDiffSum += lDiff;
000066  443e              ADD      r6,r6,r7
000068  b236              SXTH     r6,r6
00006a  1c5b              ADDS     r3,r3,#1
                  |L17.108|
00006c  f50272a8          ADD      r2,r2,#0x150
000070  f1b80801          SUBS     r8,r8,#1
000074  f50c7ca8          ADD      r12,r12,#0x150
;;;2247   				lDiffSumCnt++;
;;;2248   			}
000078  d1eb              BNE      |L17.82|
;;;2249   		}
;;;2250   
;;;2251   		if(lDiffSumCnt > 3)
00007a  2b03              CMP      r3,#3
00007c  d912              BLS      |L17.164|
;;;2252   		{
;;;2253   			sLFOffsetCol[c] = lDiffSum / ((int16_t)lDiffSumCnt);
00007e  b21a              SXTH     r2,r3
000080  fb96f2f2          SDIV     r2,r6,r2
000084  f82a2010          STRH     r2,[r10,r0,LSL #1]
;;;2254   #if !FAST_LF_EN		
;;;2255   			for(r = 0; r < ROW_MAX; r++)
000088  2330              MOVS     r3,#0x30
                  |L17.138|
;;;2256   			{
;;;2257   				lDiff = (((int16_t)HAL_READ_RAW_IMAGE(r, c)) - sLFOffsetCol[c]);
00008a  880a              LDRH     r2,[r1,#0]
00008c  f83ac010          LDRH     r12,[r10,r0,LSL #1]
000090  eba2020c          SUB      r2,r2,r12
000094  b212              SXTH     r2,r2
;;;2258   				if(lDiff<0)lDiff=0;
000096  2a00              CMP      r2,#0
000098  bfb8              IT       LT
00009a  2200              MOVLT    r2,#0
;;;2259   				HAL_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
00009c  f8212ba8          STRH     r2,[r1],#0xa8
0000a0  1e5b              SUBS     r3,r3,#1
0000a2  d1f2              BNE      |L17.138|
                  |L17.164|
0000a4  1c40              ADDS     r0,r0,#1              ;2258
0000a6  2854              CMP      r0,#0x54
0000a8  d3ca              BCC      |L17.64|
;;;2260   			}
;;;2261   #endif
;;;2262   		}
;;;2263   	}
;;;2264   }
0000aa  b02b              ADD      sp,sp,#0xac
0000ac  e8bd8ff0          POP      {r4-r11,pc}
;;;2265   
                          ENDP

                  |L17.176|
                          DCD      ||.data||
                  |L17.180|
                          DCD      g_pFingerBaseImage
                  |L17.184|
                          DCD      g_pFingerHop1BaseImage
                  |L17.188|
                          DCD      FullSharedBuff

                          AREA ||i.public_func_PalmTouch_handler||, CODE, READONLY, ALIGN=2

                  public_func_PalmTouch_handler PROC
;;;1467   #define PALM_KEEP_FRM		(10)
;;;1468   void public_func_PalmTouch_handler(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1469   {
000004  b08f              SUB      sp,sp,#0x3c
;;;1470   	static uint8_t ucFrameCnt[POSBUF_]  = {0,};
;;;1471   //	static uint16_t usPrevMaxCellNum[POSBUF_]  = {0,}; // NOTE : Not used!!
;;;1472   	static uint8_t ucPalmContCnt[POSBUF_]  = {0,};
;;;1473   	static uint8_t ucParNum[POSBUF_]  = {0,};
;;;1474   	static tXY_t ucPalmPos[POSBUF_] ;
;;;1475   	static tRect_t ucPalmRect[POSBUF_] ;
;;;1476   	uint8_t ucParCnt[POSBUF_] = {0,};
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  9001              STR      r0,[sp,#4]
;;;1477   	uint8_t ucParBF[POSBUF_] = {0,};
;;;1478   	bool_t bIsPalm[POSBUF_] = {0,};
;;;1479   	uint8_t ucPalmExpect[POSBUF_] = {0,};
;;;1480   	int cl;
;;;1481   	
;;;1482   //    if(!sptPalmTouchConf->bEnable) return;
;;;1483   
;;;1484   //	tMemConf_t       * ptMemConf = (tMemConf_t *)param1;
;;;1485   //	tAlgorithmInfo_t * ptInfo     = (tAlgorithmInfo_t *)param2;
;;;1486   
;;;1487   //	sptPalmTouchConf->bPalmExpect = NO;
;;;1488   
;;;1489   	thisInfo->bIsPalm = NO;
00000c  f8dfa440          LDR      r10,|L18.1104|
000010  9002              STR      r0,[sp,#8]            ;1477
000012  9003              STR      r0,[sp,#0xc]          ;1477
000014  9004              STR      r0,[sp,#0x10]         ;1477
000016  9005              STR      r0,[sp,#0x14]         ;1478
000018  9006              STR      r0,[sp,#0x18]         ;1478
00001a  9007              STR      r0,[sp,#0x1c]         ;1478
00001c  9008              STR      r0,[sp,#0x20]         ;1479
00001e  9009              STR      r0,[sp,#0x24]         ;1479
000020  900a              STR      r0,[sp,#0x28]         ;1479
000022  900b              STR      r0,[sp,#0x2c]
000024  f8da100c          LDR      r1,[r10,#0xc]  ; thisInfo
;;;1490   	
;;;1491   	for( cl=MAX_TOUCH_; cl--; )
;;;1492   	{
;;;1493   		if(thisInfo->tCoord.tPos.vusR[cl] != 0)
;;;1494   		{
;;;1495   			if(thisInfo->tCoord.tPos.vusR[cl] > thisModeConf->Palm.usPalmLevel)
;;;1496   			{
;;;1497   				bIsPalm[cl] = YES;
;;;1498   				ucParNum[cl] = cl;
;;;1499   				ucPalmPos[cl] = thisInfo->tCoord.tPos.tXY[cl];
;;;1500   			}
;;;1501   //			else if(ucFrameCnt[cl] < 10
;;;1502   //				&& ((thisInfo->tCoord.tPos.vusR[cl] > 10
;;;1503   //				&& (int16_t)(thisInfo->tCoord.tPos.vusR[cl] - usPrevMaxCellNum[cl]) > 3 )
;;;1504   //				|| ((int16_t)(thisInfo->tCoord.tPos.vusR[cl] - usPrevMaxCellNum[cl]) > (3*2+1))))
;;;1505   //			{
;;;1506   //				thisInfo->tCoord.tPos.vusS[cl] = 0;
;;;1507   //				ucPalmExpect[cl] = 1;
;;;1508   //			}
;;;1509   			else
;;;1510   			{
;;;1511   				int pl, i;
;;;1512   				uint8_t ucOverlap[POSBUF_] = {0,};
;;;1513   				uint8_t ucOverlapCnt = 0;
;;;1514   
;;;1515   				for( pl=MAX_TOUCH_; pl--; )
;;;1516   				{
;;;1517   					if(ucPalmContCnt[pl] != 0)
;;;1518   					{
;;;1519   						if(ucPalmRect[pl].rs <= thisInfo->tCoord.tPos.rect[cl].re && thisInfo->tCoord.tPos.rect[cl].rs <= ucPalmRect[pl].re)
;;;1520   						{
;;;1521   							if(ucPalmRect[pl].cs <= thisInfo->tCoord.tPos.rect[cl].ce && thisInfo->tCoord.tPos.rect[cl].cs <= ucPalmRect[pl].ce)
;;;1522   								ucOverlap[ucOverlapCnt++] = pl;
;;;1523   						}
;;;1524   					}
;;;1525   				}
;;;1526   
;;;1527   				if(ucOverlapCnt != 0)
;;;1528   				{
;;;1529   					if(ucOverlapCnt > 1)
;;;1530   					{
;;;1531   						int palm_dist;
;;;1532   						int min_dist = INT32_MAX;
;;;1533   
;;;1534   						for(i=0; i<ucOverlapCnt; i++)
;;;1535   						{
;;;1536   							palm_dist = algorithm_coord_calc_distance(ucPalmPos[ucOverlap[i]], thisInfo->tCoord.tPos.tXY[cl]);
;;;1537   							if(min_dist > palm_dist)
;;;1538   								min_dist = palm_dist, pl = ucOverlap[i];
;;;1539   						}
;;;1540   					}
;;;1541   					else
;;;1542   						pl = ucOverlap[0];
;;;1543   
;;;1544   					bIsPalm[cl] = YES;
;;;1545   					ucParCnt[pl]++;
;;;1546   					ucParBF[pl] |= _BV(cl);
;;;1547   					if(ucPalmContCnt[cl] == 0)
;;;1548   						ucParNum[cl] = ucParNum[pl];
;;;1549   
;;;1550   					ucPalmPos[cl] = thisInfo->tCoord.tPos.tXY[cl];
;;;1551   				}
;;;1552   			}
;;;1553   
;;;1554   			if( ucFrameCnt[cl] < 10 )
;;;1555   				ucFrameCnt[cl]++;
;;;1556   		}
;;;1557   		else
;;;1558   			ucFrameCnt[cl] = 0;
;;;1559   	}
;;;1560   
;;;1561   	for( cl=MAX_TOUCH_; cl--;)
;;;1562   	{
;;;1563   		if(ucParCnt[cl] > 1)
;;;1564   		{
;;;1565   			int max_palm_num = -1;
;;;1566   			int max_palm_size = 0;
;;;1567   
;;;1568   			if(bIsPalm[cl] == NO)
;;;1569   			{
;;;1570   				int pl;
;;;1571   
;;;1572   				for( pl=MAX_TOUCH_; pl--;)
;;;1573   				{
;;;1574   					if((ucParBF[cl] & _BV(pl)) != 0)
;;;1575   					{
;;;1576   						if(max_palm_size < thisInfo->tCoord.tPos.vusR[pl])
;;;1577   						{
;;;1578   							max_palm_num = pl;
;;;1579   							max_palm_size = thisInfo->tCoord.tPos.vusR[pl];
;;;1580   						}
;;;1581   					}
;;;1582   				}
;;;1583   
;;;1584   				for( pl=MAX_TOUCH_; pl--;)
;;;1585   				{
;;;1586   					if((ucParBF[cl] & _BV(pl)) != 0)
;;;1587   						ucParNum[pl] = max_palm_num;
;;;1588   				}
;;;1589   
;;;1590   				ucPalmContCnt[cl] = 0;
;;;1591   			}
;;;1592   		}
;;;1593   	}
;;;1594   
;;;1595   	for( cl=MAX_TOUCH_; cl--;)
;;;1596   	{
;;;1597   		if(bIsPalm[cl] == YES)
;;;1598   		{
;;;1599   			if(ucParNum[cl] != cl)
;;;1600   			{
;;;1601   				int pl = ucParNum[cl];
;;;1602   				int palm_dist;
;;;1603   
;;;1604   				if(thisInfo->tCoord.tPos.vusR[pl] == 0 && ucPalmContCnt[cl] != 0)
;;;1605   				{
;;;1606   					int pcl;
;;;1607   					int max_palm_num = -1;
;;;1608   					int max_palm_size = 0;
;;;1609   
;;;1610   					for( pcl=MAX_TOUCH_; pcl--;)
;;;1611   					{
;;;1612   						if(pcl != cl && bIsPalm[pcl] == YES)
;;;1613   						{
;;;1614   							if(ucPalmRect[pl].rs <= thisInfo->tCoord.tPos.rect[pcl].re && thisInfo->tCoord.tPos.rect[pcl].rs <= ucPalmRect[pl].re)
;;;1615   							{
;;;1616   								if(max_palm_size < thisInfo->tCoord.tPos.vusR[pcl])
;;;1617   									max_palm_size = thisInfo->tCoord.tPos.vusR[pcl], max_palm_num = pcl;
;;;1618   							}
;;;1619   						}
;;;1620   					}
;;;1621   
;;;1622   					if(max_palm_num != -1)
;;;1623   					{
;;;1624   
;;;1625   						ucParNum[cl] = max_palm_num;
;;;1626   						for( pcl=MAX_TOUCH_; pcl--;)
;;;1627   						{
;;;1628   							if(ucPalmContCnt[pcl] != 0)
;;;1629   							{
;;;1630   								if(ucParNum[pcl] == pl)
;;;1631   									ucParNum[pcl] = max_palm_num;
;;;1632   							}
;;;1633   						}
;;;1634   					}
;;;1635   					else
;;;1636   						ucParNum[cl] = cl;
;;;1637   				}
;;;1638   
;;;1639   				if(ucPalmContCnt[pl] != 0)
;;;1640   				{
;;;1641   					palm_dist = algorithm_coord_calc_distance(ucPalmPos[pl], ucPalmPos[cl]);
;;;1642   					if(PALM_VALID_AREA < palm_dist)
;;;1643   						bIsPalm[cl] = NO;
;;;1644   				}
;;;1645   				else
;;;1646   					bIsPalm[cl] = NO;
;;;1647   			}
;;;1648   		}
;;;1649   
;;;1650   		if(bIsPalm[cl] == YES)
;;;1651   		{
;;;1652   			ucPalmExpect[cl] = 1;
;;;1653   			ucPalmContCnt[cl] = PALM_KEEP_FRM;
;;;1654   			ucPalmRect[cl] = thisInfo->tCoord.tPos.rect[cl];
;;;1655   			ucPalmPos[cl] = thisInfo->tCoord.tPos.tXY[cl];
;;;1656   			thisInfo->tCoord.tPos.vusS[cl] = 0;
;;;1657   
;;;1658   			if(ucPalmRect[cl].rs > 0)
;;;1659   				ucPalmRect[cl].rs--;
;;;1660   			if(ucPalmRect[cl].re < (ROW_MAX - 1))
;;;1661   				ucPalmRect[cl].re++;
;;;1662   			if(ucPalmRect[cl].cs > 0)
;;;1663   				ucPalmRect[cl].cs--;
;;;1664   			if(ucPalmRect[cl].ce < (COL_MAX - 1))
;;;1665   				ucPalmRect[cl].ce++;
;;;1666   			
;;;1667   			thisInfo->bIsPalm = YES;
;;;1668   			thisInfo->tCoord.tPos.sFinger_--;
;;;1669   		}
;;;1670   	}
;;;1671   
;;;1672   	for( cl=MAX_TOUCH_; cl--;)
;;;1673   	{
;;;1674   		if(ucPalmExpect[cl] != 0)
;;;1675   		{
;;;1676   			int pl;
;;;1677   //			tRect_t ori_rect, cmp_rect; // NOTE : not used
;;;1678   			tRect_t ori_rect;
;;;1679   
;;;1680   #if (CUSTOMER == MODEL_DEF_QHD_92407 || CUSTOMER == MODEL_DEF_QHD_92407_FLIP)
;;;1681   			int offset = 5;
;;;1682   #else
;;;1683   			int offset = 1;
;;;1684   #endif
;;;1685   			
;;;1686               if(thisInfo->tCoord.tPos.rect[cl].rs > (offset-1))
;;;1687   				ori_rect.rs = thisInfo->tCoord.tPos.rect[cl].rs - offset;
;;;1688               else
;;;1689                   ori_rect.rs = 0;
;;;1690   			if(thisInfo->tCoord.tPos.rect[cl].re < (ROW_MAX - offset))
;;;1691   				ori_rect.re = thisInfo->tCoord.tPos.rect[cl].re + offset;
;;;1692               else
;;;1693                   ori_rect.re = ROW_MAX - 1;
;;;1694   			if(thisInfo->tCoord.tPos.rect[cl].cs > (offset-1))
;;;1695   				ori_rect.cs = thisInfo->tCoord.tPos.rect[cl].cs - offset;
;;;1696               else
;;;1697                   ori_rect.cs = 0;
;;;1698   			if(thisInfo->tCoord.tPos.rect[cl].ce < (COL_MAX - offset))
;;;1699   				ori_rect.ce = thisInfo->tCoord.tPos.rect[cl].ce + offset;
;;;1700               else
;;;1701                   ori_rect.ce = COL_MAX - 1;
;;;1702               
;;;1703               for( pl=MAX_TOUCH_; pl--;)
;;;1704   			{
;;;1705   				if(thisInfo->tCoord.tPos.vusS[pl])
;;;1706   				{
;;;1707   					if(ori_rect.rs <= thisInfo->tCoord.tPos.rect[pl].re+1 && thisInfo->tCoord.tPos.rect[pl].rs-1 <= ori_rect.re)
;;;1708   					{
;;;1709   						if(ori_rect.cs <= thisInfo->tCoord.tPos.rect[pl].ce+1 && thisInfo->tCoord.tPos.rect[pl].cs-1 <= ori_rect.ce)
;;;1710   						{
;;;1711   							thisInfo->tCoord.tPos.vusS[pl] = 0;
;;;1712   						}
;;;1713   					}
;;;1714   				}
;;;1715   			}
;;;1716   		}
;;;1717   
;;;1718   		if(ucPalmContCnt[cl] != 0)
;;;1719   			ucPalmContCnt[cl]--;
;;;1720   
;;;1721   //		usPrevMaxCellNum[cl] = thisInfo->tCoord.tPos.vusR[cl];  // NOTE : Not used!!		
;;;1722   	}
;;;1723   
;;;1724   //	public_protocol_LogCode(LT_DIAGNOSIS, (220)/*System is Entered!*/);
;;;1725   }
000028  2409              MOVS     r4,#9
00002a  f5015180          ADD      r1,r1,#0x1000         ;1489
00002e  f10d0930          ADD      r9,sp,#0x30           ;1512
000032  f88100da          STRB     r0,[r1,#0xda]         ;1489
000036  bf00              NOP                            ;1493
                  |L18.56|
000038  f8da000c          LDR      r0,[r10,#0xc]         ;1493  ; thisInfo
00003c  eb000144          ADD      r1,r0,r4,LSL #1       ;1493
000040  f8b11503          LDRH     r1,[r1,#0x503]        ;1493
000044  2900              CMP      r1,#0                 ;1493
000046  d07d              BEQ      |L18.324|
000048  f8da2008          LDR      r2,[r10,#8]           ;1495  ; thisModeConf
00004c  f8b22201          LDRH     r2,[r2,#0x201]        ;1495
000050  4291              CMP      r1,r2                 ;1495
000052  d910              BLS      |L18.118|
000054  a906              ADD      r1,sp,#0x18           ;1497
000056  2201              MOVS     r2,#1                 ;1497
000058  550a              STRB     r2,[r1,r4]            ;1497
00005a  49fe              LDR      r1,|L18.1108|
00005c  eb0000c4          ADD      r0,r0,r4,LSL #3       ;1499
000060  550c              STRB     r4,[r1,r4]            ;1498
000062  310a              ADDS     r1,r1,#0xa            ;1499
000064  eb0101c4          ADD      r1,r1,r4,LSL #3       ;1499
000068  f8d0249f          LDR      r2,[r0,#0x49f]        ;1499
00006c  600a              STR      r2,[r1,#0]            ;1499
00006e  f8d004a3          LDR      r0,[r0,#0x4a3]        ;1499
000072  6048              STR      r0,[r1,#4]            ;1499
000074  e08b              B        |L18.398|
                  |L18.118|
000076  2100              MOVS     r1,#0                 ;1512
000078  910c              STR      r1,[sp,#0x30]         ;1512
00007a  910d              STR      r1,[sp,#0x34]         ;1512
00007c  460d              MOV      r5,r1                 ;1513
00007e  910e              STR      r1,[sp,#0x38]         ;1515
000080  49f5              LDR      r1,|L18.1112|
000082  2700              MOVS     r7,#0                 ;1515
000084  f101065b          ADD      r6,r1,#0x5b           ;1515
000088  f1060224          ADD      r2,r6,#0x24           ;1515
00008c  1c53              ADDS     r3,r2,#1              ;1515
00008e  f1060c26          ADD      r12,r6,#0x26          ;1515
000092  f04f080a          MOV      r8,#0xa               ;1515
000096  eb000084          ADD      r0,r0,r4,LSL #2       ;1519
00009a  3627              ADDS     r6,r6,#0x27           ;1519
                  |L18.156|
00009c  f811b901          LDRB     r11,[r1],#-1          ;1517
0000a0  f1bb0f00          CMP      r11,#0                ;1517
0000a4  d01d              BEQ      |L18.226|
0000a6  f992b000          LDRSB    r11,[r2,#0]           ;1519
0000aa  f990e518          LDRSB    lr,[r0,#0x518]        ;1519
0000ae  45f3              CMP      r11,lr                ;1519
0000b0  dc17              BGT      |L18.226|
0000b2  f990b517          LDRSB    r11,[r0,#0x517]       ;1519
0000b6  f993e000          LDRSB    lr,[r3,#0]            ;1519
0000ba  45f3              CMP      r11,lr                ;1519
0000bc  dc11              BGT      |L18.226|
0000be  f99cb000          LDRSB    r11,[r12,#0]          ;1521
0000c2  f990e51a          LDRSB    lr,[r0,#0x51a]        ;1521
0000c6  45f3              CMP      r11,lr                ;1521
0000c8  dc0b              BGT      |L18.226|
0000ca  f990b519          LDRSB    r11,[r0,#0x519]       ;1521
0000ce  f996e000          LDRSB    lr,[r6,#0]            ;1521
0000d2  45f3              CMP      r11,lr                ;1521
0000d4  dc05              BGT      |L18.226|
0000d6  f1c70b09          RSB      r11,r7,#9             ;1522
0000da  f809b005          STRB     r11,[r9,r5]           ;1522
0000de  1c6d              ADDS     r5,r5,#1              ;1522
0000e0  b2ed              UXTB     r5,r5                 ;1522
                  |L18.226|
0000e2  1f12              SUBS     r2,r2,#4              ;1522
0000e4  1f1b              SUBS     r3,r3,#4              ;1522
0000e6  1f36              SUBS     r6,r6,#4              ;1522
0000e8  1c7f              ADDS     r7,r7,#1              ;1522
0000ea  f1b80801          SUBS     r8,r8,#1              ;1522
0000ee  f1ac0c04          SUB      r12,r12,#4            ;1522
0000f2  d1d3              BNE      |L18.156|
0000f4  f04f36ff          MOV      r6,#0xffffffff        ;1515
0000f8  2d00              CMP      r5,#0                 ;1527
0000fa  d048              BEQ      |L18.398|
0000fc  2d01              CMP      r5,#1                 ;1529
0000fe  bf98              IT       LS                    ;1542
000100  f89d6030          LDRBLS   r6,[sp,#0x30]         ;1542
000104  d923              BLS      |L18.334|
000106  f06f4700          MVN      r7,#0x80000000        ;1532
00010a  f04f0800          MOV      r8,#0                 ;1534
00010e  2d00              CMP      r5,#0                 ;1534
000110  bfc8              IT       GT                    ;1499
000112  f8dfb348          LDRGT    r11,|L18.1116|
000116  dd1a              BLE      |L18.334|
                  |L18.280|
000118  f8da000c          LDR      r0,[r10,#0xc]         ;1536  ; thisInfo
00011c  eb0000c4          ADD      r0,r0,r4,LSL #3       ;1536
000120  f8d0249f          LDR      r2,[r0,#0x49f]        ;1536
000124  f8d034a3          LDR      r3,[r0,#0x4a3]        ;1536
000128  f8190008          LDRB     r0,[r9,r8]            ;1536
00012c  eb0b01c0          ADD      r1,r11,r0,LSL #3      ;1536
000130  6808              LDR      r0,[r1,#0]            ;1536
000132  6849              LDR      r1,[r1,#4]            ;1536
000134  f7fffffe          BL       algorithm_coord_calc_distance
000138  4287              CMP      r7,r0                 ;1537
00013a  bfc4              ITT      GT                    ;1538
00013c  4607              MOVGT    r7,r0                 ;1538
00013e  f8196008          LDRBGT   r6,[r9,r8]            ;1538
000142  e000              B        |L18.326|
                  |L18.324|
000144  e02a              B        |L18.412|
                  |L18.326|
000146  f1080801          ADD      r8,r8,#1              ;1538
00014a  45a8              CMP      r8,r5                 ;1538
00014c  dbe4              BLT      |L18.280|
                  |L18.334|
00014e  a906              ADD      r1,sp,#0x18           ;1544
000150  2001              MOVS     r0,#1                 ;1544
000152  5508              STRB     r0,[r1,r4]            ;1544
000154  f81d2006          LDRB     r2,[sp,r6]            ;1545
000158  a903              ADD      r1,sp,#0xc            ;1546
00015a  1c52              ADDS     r2,r2,#1              ;1545
00015c  f80d2006          STRB     r2,[sp,r6]            ;1545
000160  5d8a              LDRB     r2,[r1,r6]            ;1546
000162  40a0              LSLS     r0,r0,r4              ;1546
000164  4310              ORRS     r0,r0,r2              ;1546
000166  5588              STRB     r0,[r1,r6]            ;1546
000168  48bd              LDR      r0,|L18.1120|
00016a  5d00              LDRB     r0,[r0,r4]            ;1547
00016c  b910              CBNZ     r0,|L18.372|
00016e  48b9              LDR      r0,|L18.1108|
000170  5d81              LDRB     r1,[r0,r6]            ;1548
000172  5501              STRB     r1,[r0,r4]            ;1548
                  |L18.372|
000174  f8da100c          LDR      r1,[r10,#0xc]         ;1550  ; thisInfo
000178  48b8              LDR      r0,|L18.1116|
00017a  eb0101c4          ADD      r1,r1,r4,LSL #3       ;1550
00017e  eb0000c4          ADD      r0,r0,r4,LSL #3       ;1550
000182  f8d1249f          LDR      r2,[r1,#0x49f]        ;1550
000186  6002              STR      r2,[r0,#0]            ;1550
000188  f8d114a3          LDR      r1,[r1,#0x4a3]        ;1550
00018c  6041              STR      r1,[r0,#4]            ;1550
                  |L18.398|
00018e  48b5              LDR      r0,|L18.1124|
000190  5d01              LDRB     r1,[r0,r4]            ;1554
000192  290a              CMP      r1,#0xa               ;1554
000194  bf3c              ITT      CC                    ;1554
000196  1c49              ADDCC    r1,r1,#1              ;1554
000198  5501              STRBCC   r1,[r0,r4]            ;1555
00019a  e002              B        |L18.418|
                  |L18.412|
00019c  49b1              LDR      r1,|L18.1124|
00019e  2000              MOVS     r0,#0                 ;1558
0001a0  5508              STRB     r0,[r1,r4]            ;1558
                  |L18.418|
0001a2  1e64              SUBS     r4,r4,#1              ;1558
0001a4  f4bfaf48          BCS      |L18.56|
0001a8  48a9              LDR      r0,|L18.1104|
0001aa  f8dfa2a8          LDR      r10,|L18.1108|
0001ae  2209              MOVS     r2,#9
0001b0  f8d0900c          LDR      r9,[r0,#0xc]          ;1497  ; thisInfo
0001b4  46eb              MOV      r11,sp                ;1476
0001b6  ad06              ADD      r5,sp,#0x18           ;1478
0001b8  2001              MOVS     r0,#1                 ;1497
0001ba  f04f0e00          MOV      lr,#0                 ;1497
0001be  f1aa060a          SUB      r6,r10,#0xa           ;1515
0001c2  bf00              NOP                            ;1563
                  |L18.452|
0001c4  f81b1002          LDRB     r1,[r11,r2]           ;1563
0001c8  2901              CMP      r1,#1                 ;1563
0001ca  d939              BLS      |L18.576|
0001cc  5ca9              LDRB     r1,[r5,r2]            ;1568
0001ce  f04f37ff          MOV      r7,#0xffffffff        ;1565
0001d2  2300              MOVS     r3,#0                 ;1566
0001d4  bba1              CBNZ     r1,|L18.576|
0001d6  f10d0c0c          ADD      r12,sp,#0xc           ;1477
0001da  210a              MOVS     r1,#0xa               ;1572
0001dc  f81cc002          LDRB     r12,[r12,r2]          ;1574
0001e0  2401              MOVS     r4,#1                 ;1572
                  |L18.482|
0001e2  1e49              SUBS     r1,r1,#1              ;1574
0001e4  fa00f801          LSL      r8,r0,r1              ;1574
0001e8  ea1c0f08          TST      r12,r8                ;1574
0001ec  d007              BEQ      |L18.510|
0001ee  eb090841          ADD      r8,r9,r1,LSL #1       ;1576
0001f2  f8b88503          LDRH     r8,[r8,#0x503]        ;1576
0001f6  4598              CMP      r8,r3                 ;1576
0001f8  bfc4              ITT      GT                    ;1578
0001fa  460f              MOVGT    r7,r1                 ;1578
0001fc  4643              MOVGT    r3,r8                 ;1578
                  |L18.510|
0001fe  1c64              ADDS     r4,r4,#1              ;1578
000200  2c0a              CMP      r4,#0xa               ;1579
000202  ddee              BLE      |L18.482|
000204  2100              MOVS     r1,#0
000206  f10a030a          ADD      r3,r10,#0xa           ;1584
00020a  2405              MOVS     r4,#5                 ;1584
00020c  fa5ff787          UXTB.W   r7,r7                 ;1587
                  |L18.528|
000210  f1c10809          RSB      r8,r1,#9              ;1586
000214  fa00f808          LSL      r8,r0,r8              ;1586
000218  ea1c0f08          TST      r12,r8                ;1586
00021c  bf18              IT       NE                    ;1587
00021e  f8037c01          STRBNE   r7,[r3,#-1]           ;1587
000222  f1c10808          RSB      r8,r1,#8              ;1586
000226  fa00f808          LSL      r8,r0,r8              ;1586
00022a  ea1c0f08          TST      r12,r8                ;1586
00022e  bf18              IT       NE                    ;1587
000230  f8037c02          STRBNE   r7,[r3,#-2]           ;1587
000234  1c89              ADDS     r1,r1,#2              ;1587
000236  1e9b              SUBS     r3,r3,#2              ;1587
000238  1e64              SUBS     r4,r4,#1              ;1587
00023a  d1e9              BNE      |L18.528|
00023c  f806e002          STRB     lr,[r6,r2]            ;1590
                  |L18.576|
000240  1e52              SUBS     r2,r2,#1              ;1590
000242  d2bf              BCS      |L18.452|
000244  2409              MOVS     r4,#9
                  |L18.582|
000246  5d28              LDRB     r0,[r5,r4]            ;1597
000248  2801              CMP      r0,#1                 ;1597
00024a  d178              BNE      |L18.830|
00024c  f8dfe204          LDR      lr,|L18.1108|
000250  f81e1004          LDRB     r1,[lr,r4]            ;1599
000254  42a1              CMP      r1,r4                 ;1599
000256  d06e              BEQ      |L18.822|
000258  487d              LDR      r0,|L18.1104|
00025a  68c3              LDR      r3,[r0,#0xc]          ;1604  ; thisInfo
00025c  eb030041          ADD      r0,r3,r1,LSL #1       ;1604
000260  f8b00503          LDRH     r0,[r0,#0x503]        ;1604
000264  bbe8              CBNZ     r0,|L18.738|
000266  5d30              LDRB     r0,[r6,r4]            ;1604
000268  b3d8              CBZ      r0,|L18.738|
00026a  200a              MOVS     r0,#0xa               ;1610
00026c  f10e0c5a          ADD      r12,lr,#0x5a          ;1515
000270  f04f3aff          MOV      r10,#0xffffffff       ;1607
000274  f04f0800          MOV      r8,#0                 ;1608
000278  2201              MOVS     r2,#1                 ;1610
00027a  eb0c0981          ADD      r9,r12,r1,LSL #2      ;1614
                  |L18.638|
00027e  1e40              SUBS     r0,r0,#1              ;1614
000280  42a0              CMP      r0,r4                 ;1612
000282  d01a              BEQ      |L18.698|
000284  f815c000          LDRB     r12,[r5,r0]           ;1612
000288  f1bc0f01          CMP      r12,#1                ;1612
00028c  d115              BNE      |L18.698|
00028e  eb030c80          ADD      r12,r3,r0,LSL #2      ;1614
000292  f9997000          LDRSB    r7,[r9,#0]            ;1614
000296  f99cb518          LDRSB    r11,[r12,#0x518]      ;1614
00029a  455f              CMP      r7,r11                ;1614
00029c  dc0d              BGT      |L18.698|
00029e  f99cc517          LDRSB    r12,[r12,#0x517]      ;1614
0002a2  f9997001          LDRSB    r7,[r9,#1]            ;1614
0002a6  45bc              CMP      r12,r7                ;1614
0002a8  dc07              BGT      |L18.698|
0002aa  eb030c40          ADD      r12,r3,r0,LSL #1      ;1616
0002ae  f8bcc503          LDRH     r12,[r12,#0x503]      ;1616
0002b2  45e0              CMP      r8,r12                ;1616
0002b4  bfbc              ITT      LT                    ;1616
0002b6  46e0              MOVLT    r8,r12                ;1616
0002b8  4682              MOVLT    r10,r0                ;1617
                  |L18.698|
0002ba  1c52              ADDS     r2,r2,#1              ;1617
0002bc  2a0a              CMP      r2,#0xa               ;1617
0002be  ddde              BLE      |L18.638|
0002c0  f1ba3fff          CMP      r10,#0xffffffff       ;1622
0002c4  bf08              IT       EQ                    ;1636
0002c6  f80e4004          STRBEQ   r4,[lr,r4]            ;1636
0002ca  d021              BEQ      |L18.784|
0002cc  f00a03ff          AND      r3,r10,#0xff          ;1625
0002d0  f80e3004          STRB     r3,[lr,r4]            ;1625
0002d4  f106020a          ADD      r2,r6,#0xa            ;1626
0002d8  f10e000a          ADD      r0,lr,#0xa            ;1626
0002dc  f04f0c05          MOV      r12,#5                ;1626
                  |L18.736|
0002e0  e000              B        |L18.740|
                  |L18.738|
0002e2  e015              B        |L18.784|
                  |L18.740|
0002e4  f8127c01          LDRB     r7,[r2,#-1]           ;1628
0002e8  b12f              CBZ      r7,|L18.758|
0002ea  f8107c01          LDRB     r7,[r0,#-1]           ;1630
0002ee  428f              CMP      r7,r1                 ;1630
0002f0  bf08              IT       EQ                    ;1631
0002f2  f8003c01          STRBEQ   r3,[r0,#-1]           ;1631
                  |L18.758|
0002f6  f8127d02          LDRB     r7,[r2,#-2]!          ;1628
0002fa  b12f              CBZ      r7,|L18.776|
0002fc  f8107c02          LDRB     r7,[r0,#-2]           ;1630
000300  428f              CMP      r7,r1                 ;1630
000302  bf08              IT       EQ                    ;1631
000304  f8003c02          STRBEQ   r3,[r0,#-2]           ;1631
                  |L18.776|
000308  1e80              SUBS     r0,r0,#2              ;1631
00030a  f1bc0c01          SUBS     r12,r12,#1            ;1631
00030e  d1e7              BNE      |L18.736|
                  |L18.784|
000310  5c70              LDRB     r0,[r6,r1]            ;1639
000312  b168              CBZ      r0,|L18.816|
000314  4851              LDR      r0,|L18.1116|
000316  eb0003c4          ADD      r3,r0,r4,LSL #3       ;1641
00031a  eb0001c1          ADD      r1,r0,r1,LSL #3       ;1641
00031e  681a              LDR      r2,[r3,#0]            ;1641
000320  6808              LDR      r0,[r1,#0]            ;1641
000322  685b              LDR      r3,[r3,#4]            ;1641
000324  6849              LDR      r1,[r1,#4]            ;1641
000326  f7fffffe          BL       algorithm_coord_calc_distance
00032a  f5b05fb0          CMP      r0,#0x1600            ;1642
00032e  dd03              BLE      |L18.824|
                  |L18.816|
000330  2000              MOVS     r0,#0                 ;1646
000332  5528              STRB     r0,[r5,r4]            ;1646
000334  e003              B        |L18.830|
                  |L18.822|
000336  e073              B        |L18.1056|
                  |L18.824|
000338  5d28              LDRB     r0,[r5,r4]            ;1650
00033a  2801              CMP      r0,#1                 ;1650
00033c  d071              BEQ      |L18.1058|
                  |L18.830|
00033e  1e64              SUBS     r4,r4,#1              ;1650
000340  d281              BCS      |L18.582|
000342  4843              LDR      r0,|L18.1104|
000344  2209              MOVS     r2,#9
000346  f10d0e24          ADD      lr,sp,#0x24           ;1479
00034a  68c3              LDR      r3,[r0,#0xc]          ;1479  ; thisInfo
00034c  f04f0900          MOV      r9,#0                 ;1479
                  |L18.848|
000350  f81e0002          LDRB     r0,[lr,r2]            ;1674
000354  b3f0              CBZ      r0,|L18.980|
000356  eb030082          ADD      r0,r3,r2,LSL #2       ;1686
00035a  f9901517          LDRSB    r1,[r0,#0x517]        ;1686
00035e  2900              CMP      r1,#0                 ;1686
000360  bfd2              ITEE     LE                    ;1686
000362  f3690c07          BFILE    r12,r9,#0,#8          ;1686
000366  1e49              SUBGT    r1,r1,#1              ;1686
000368  f3610c07          BFIGT    r12,r1,#0,#8          ;1686
00036c  f9901518          LDRSB    r1,[r0,#0x518]        ;1690
000370  242f              MOVS     r4,#0x2f              ;1690
000372  292f              CMP      r1,#0x2f              ;1690
000374  bfba              ITTE     LT                    ;1690
000376  1c49              ADDLT    r1,r1,#1              ;1690
000378  f3612c0f          BFILT    r12,r1,#8,#8          ;1690
00037c  f3642c0f          BFIGE    r12,r4,#8,#8          ;1690
000380  f9901519          LDRSB    r1,[r0,#0x519]        ;1694
000384  2900              CMP      r1,#0                 ;1694
000386  bfc6              ITTE     GT                    ;1694
000388  1e49              SUBGT    r1,r1,#1              ;1694
00038a  f3614c17          BFIGT    r12,r1,#16,#8         ;1694
00038e  f3694c17          BFILE    r12,r9,#16,#8         ;1694
000392  f990051a          LDRSB    r0,[r0,#0x51a]        ;1698
000396  2153              MOVS     r1,#0x53              ;1698
000398  2853              CMP      r0,#0x53              ;1698
00039a  bfba              ITTE     LT                    ;1698
00039c  1c40              ADDLT    r0,r0,#1              ;1698
00039e  f3606c1f          BFILT    r12,r0,#24,#8         ;1698
0003a2  f3616c1f          BFIGE    r12,r1,#24,#8         ;1698
0003a6  200a              MOVS     r0,#0xa               ;1703
0003a8  2101              MOVS     r1,#1                 ;1703
0003aa  fa4ff78c          SXTB     r7,r12                ;1703
0003ae  f34c2507          SBFX     r5,r12,#8,#8          ;1703
0003b2  f34c4a07          SBFX     r10,r12,#16,#8        ;1703
0003b6  ea4f6b2c          ASR      r11,r12,#24           ;1703
                  |L18.954|
0003ba  1e40              SUBS     r0,r0,#1              ;1703
0003bc  eb030440          ADD      r4,r3,r0,LSL #1       ;1705
0003c0  f8b4c4ef          LDRH     r12,[r4,#0x4ef]       ;1705
0003c4  f1bc0f00          CMP      r12,#0                ;1705
0003c8  d01d              BEQ      |L18.1030|
0003ca  eb030c80          ADD      r12,r3,r0,LSL #2      ;1707
0003ce  f99c8518          LDRSB    r8,[r12,#0x518]       ;1707
0003d2  e000              B        |L18.982|
                  |L18.980|
0003d4  e01a              B        |L18.1036|
                  |L18.982|
0003d6  f1080801          ADD      r8,r8,#1              ;1707
0003da  4547              CMP      r7,r8                 ;1707
0003dc  dc13              BGT      |L18.1030|
0003de  f99c8517          LDRSB    r8,[r12,#0x517]       ;1707
0003e2  f1a80801          SUB      r8,r8,#1              ;1707
0003e6  45a8              CMP      r8,r5                 ;1707
0003e8  dc0d              BGT      |L18.1030|
0003ea  f99c851a          LDRSB    r8,[r12,#0x51a]       ;1709
0003ee  f1080801          ADD      r8,r8,#1              ;1709
0003f2  45c2              CMP      r10,r8                ;1709
0003f4  dc07              BGT      |L18.1030|
0003f6  f99cc519          LDRSB    r12,[r12,#0x519]      ;1709
0003fa  f1ac0c01          SUB      r12,r12,#1            ;1709
0003fe  45dc              CMP      r12,r11               ;1709
000400  bfd8              IT       LE                    ;1711
000402  f8a494ef          STRHLE   r9,[r4,#0x4ef]        ;1711
                  |L18.1030|
000406  1c49              ADDS     r1,r1,#1              ;1711
000408  290a              CMP      r1,#0xa               ;1711
00040a  ddd6              BLE      |L18.954|
                  |L18.1036|
00040c  5cb0              LDRB     r0,[r6,r2]            ;1718
00040e  2800              CMP      r0,#0                 ;1718
000410  bf1c              ITT      NE                    ;1718
000412  1e40              SUBNE    r0,r0,#1              ;1718
000414  54b0              STRBNE   r0,[r6,r2]            ;1719
000416  1e52              SUBS     r2,r2,#1              ;1719
000418  d29a              BCS      |L18.848|
00041a  b00f              ADD      sp,sp,#0x3c
00041c  e8bd8ff0          POP      {r4-r11,pc}
                  |L18.1056|
000420  e7ff              B        |L18.1058|
                  |L18.1058|
000422  a809              ADD      r0,sp,#0x24           ;1652
000424  2301              MOVS     r3,#1                 ;1652
000426  5503              STRB     r3,[r0,r4]            ;1652
000428  4909              LDR      r1,|L18.1104|
00042a  200a              MOVS     r0,#0xa               ;1653
00042c  5530              STRB     r0,[r6,r4]            ;1653
00042e  68c9              LDR      r1,[r1,#0xc]          ;1654  ; thisInfo
000430  480d              LDR      r0,|L18.1128|
000432  eb010284          ADD      r2,r1,r4,LSL #2       ;1654
000436  eb000084          ADD      r0,r0,r4,LSL #2       ;1654
00043a  f8d22517          LDR      r2,[r2,#0x517]        ;1654
00043e  6002              STR      r2,[r0,#0]            ;1654
000440  4a06              LDR      r2,|L18.1116|
000442  eb020cc4          ADD      r12,r2,r4,LSL #3      ;1655
000446  eb0102c4          ADD      r2,r1,r4,LSL #3       ;1655
00044a  f8d2749f          LDR      r7,[r2,#0x49f]        ;1655
00044e  e00d              B        |L18.1132|
                  |L18.1104|
                          DCD      ||.data||
                  |L18.1108|
                          DCD      ||.bss||+0x2f4
                  |L18.1112|
                          DCD      ||.bss||+0x2f3
                  |L18.1116|
                          DCD      ||.bss||+0x2fe
                  |L18.1120|
                          DCD      ||.bss||+0x2ea
                  |L18.1124|
                          DCD      ||.bss||+0x2e0
                  |L18.1128|
                          DCD      ||.bss||+0x34e
                  |L18.1132|
00046c  f8cc7000          STR      r7,[r12,#0]           ;1655
000470  f8d224a3          LDR      r2,[r2,#0x4a3]        ;1655
000474  f8cc2004          STR      r2,[r12,#4]           ;1655
000478  eb010c44          ADD      r12,r1,r4,LSL #1      ;1656
00047c  2200              MOVS     r2,#0                 ;1656
00047e  f8ac24ef          STRH     r2,[r12,#0x4ef]       ;1656
000482  f9902000          LDRSB    r2,[r0,#0]            ;1658
000486  2a00              CMP      r2,#0                 ;1658
000488  bfc4              ITT      GT                    ;1658
00048a  1e52              SUBGT    r2,r2,#1              ;1658
00048c  7002              STRBGT   r2,[r0,#0]            ;1659
00048e  f9902001          LDRSB    r2,[r0,#1]            ;1660
000492  2a2f              CMP      r2,#0x2f              ;1660
000494  bfbc              ITT      LT                    ;1660
000496  1c52              ADDLT    r2,r2,#1              ;1660
000498  7042              STRBLT   r2,[r0,#1]            ;1661
00049a  f9902002          LDRSB    r2,[r0,#2]            ;1662
00049e  2a00              CMP      r2,#0                 ;1662
0004a0  bfc4              ITT      GT                    ;1662
0004a2  1e52              SUBGT    r2,r2,#1              ;1662
0004a4  7082              STRBGT   r2,[r0,#2]            ;1663
0004a6  f9902003          LDRSB    r2,[r0,#3]            ;1664
0004aa  2a53              CMP      r2,#0x53              ;1664
0004ac  bfbc              ITT      LT                    ;1664
0004ae  1c52              ADDLT    r2,r2,#1              ;1664
0004b0  70c2              STRBLT   r2,[r0,#3]            ;1665
0004b2  f24100da          MOV      r0,#0x10da            ;1667
0004b6  5443              STRB     r3,[r0,r1]            ;1667
0004b8  f891049e          LDRB     r0,[r1,#0x49e]        ;1668
0004bc  1e40              SUBS     r0,r0,#1              ;1668
0004be  f881049e          STRB     r0,[r1,#0x49e]        ;1668
0004c2  e73c              B        |L18.830|
;;;1726   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  sLFOffsetRow
                          %        96
                  gvsCurrentCheckRawData_AFE_1
                          %        160
                  gvsCurrentCheckRawData_AFE_2
                          %        160
                  gvsPastCheckRawData_AFE_1
                          %        160
                  gvsPastCheckRawData_AFE_2
                          %        160
                  ucFrameCnt
                          %        10
                  ucPalmContCnt
                          %        10
                  ucParNum
                          %        10
                  ucPalmPos
                          %        80
                  ucPalmRect
                          %        40
                  sLFOffsetCol
                          %        168

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  30545482          DCB      0x30,0x54,0x54,0x82
000004  5400              DCB      0x54,0x00
000006  0000              DCW      0x0000
000008  0000              DCW      0x0000
00000a  0000              DCB      0x00,0x00
00000c  0a545482          DCB      0x0a,0x54,0x54,0x82
000010  5400              DCB      0x54,0x00
000012  0000              DCW      0x0000
000014  0000              DCW      0x0000
000016  0000              DCB      0x00,0x00
000018  30545482          DCB      0x30,0x54,0x54,0x82
00001c  5100              DCB      0x51,0x00
00001e  0000              DCW      0x0000
000020  0000              DCW      0x0000
000022  0000              DCB      0x00,0x00
000024  0a545482          DCB      0x0a,0x54,0x54,0x82
000028  5100              DCB      0x51,0x00
00002a  0000              DCW      0x0000
00002c  0000              DCW      0x0000
00002e  0000              DCB      0x00,0x00
000030  0a545482          DCB      0x0a,0x54,0x54,0x82
000034  5400              DCB      0x54,0x00
000036  0000              DCW      0x0000
000038  0000              DCW      0x0000
00003a  0000              DCB      0x00,0x00
00003c  05545482          DCB      0x05,0x54,0x54,0x82
000040  5400              DCB      0x54,0x00
000042  0000              DCW      0x0000
000044  0000              DCW      0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  gbSkipTouch
000000  0000              DCB      0x00,0x00
                  gusSkipTouchCnt
000002  0000              DCW      0x0000
                  ptModuleModeConf
                          DCD      0x00000000
                  thisModeConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  ptAppInfo
                          DCD      0x00000000
                  DebugAlgorithmInfo
                          DCD      0x00000000
                  tTempAlgorithmInfoDebug
                          DCD      0x00000000
                  ulMuxSensingOrder
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000003
                          DCD      0x00000004
                          DCD      0x00000005
                          DCD      0x00000006
                          DCD      0x00000007
                          DCD      0x00000008
                          DCD      0x00000009
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||area_number.24||, DATA, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.data||
                  DoReportOrgPos
000000  00                DCB      0x00

                          AREA ||area_number.25||, DATA, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.data||
                  ErrorFrameProcessMode
000000  00                DCB      0x00

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  bRawdataStuckDebug
000000  00                DCB      0x00

                          AREA ||area_number.27||, DATA, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.data||
                  ulDetecForRecovery_Cnt
                          DCD      0x00000000

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  gbMuxDeltaDebug
000000  00                DCB      0x00

                          AREA ||area_number.29||, DATA, ALIGN=0

                          EXPORTAS ||area_number.29||, ||.data||
                  gucDebugCol
000000  49                DCB      0x49

                          AREA ||area_number.30||, DATA, ALIGN=0

                          EXPORTAS ||area_number.30||, ||.data||
                  gucDebugRow
000000  1a                DCB      0x1a

                          AREA ||area_number.31||, DATA, ALIGN=3

                          EXPORTAS ||area_number.31||, ||.data||
                  OperStartTime
                          %        8

                          AREA ||area_number.32||, DATA, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.data||
                  OperEndTime
                          DCD      0x00000000

                          AREA ||i.__ARM_common_memclr4_10||, COMGROUP=__ARM_common_memclr4_10, CODE, READONLY, ALIGN=1

                  __ARM_common_memclr4_10 PROC
000000  2100              MOVS     r1,#0
000002  6001              STR      r1,[r0,#0]
000004  6041              STR      r1,[r0,#4]
000006  8101              STRH     r1,[r0,#8]
000008  4770              BX       lr
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\App\\Algorithm\\algorithm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_algorithm_c_e1335427____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___11_algorithm_c_e1335427____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_algorithm_c_e1335427____REVSH|
#line 402
|__asm___11_algorithm_c_e1335427____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_algorithm_c_e1335427____RRX|
#line 587
|__asm___11_algorithm_c_e1335427____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
