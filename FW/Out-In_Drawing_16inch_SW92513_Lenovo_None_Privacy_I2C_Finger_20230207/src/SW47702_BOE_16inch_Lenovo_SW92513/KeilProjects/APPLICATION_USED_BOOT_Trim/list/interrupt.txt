; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\interrupt.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\interrupt.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\interrupt.crf ..\..\Hal\interrupt.c]
                          THUMB

                          AREA ||i.HAL_PendSVHandlerInitialize||, CODE, READONLY, ALIGN=2

                  HAL_PendSVHandlerInitialize PROC
;;;635    
;;;636    void HAL_PendSVHandlerInitialize(void)
000000  4904              LDR      r1,|L1.20|
;;;637    {
;;;638    	Fncp_PendSV_IRQHandler = &PendSV_InterruptHandler;
000002  4803              LDR      r0,|L1.16|
000004  6008              STR      r0,[r1,#0]  ; Fncp_PendSV_IRQHandler
000006  4904              LDR      r1,|L1.24|
000008  20e0              MOVS     r0,#0xe0
00000a  f8810d14          STRB     r0,[r1,#0xd14]
;;;639    	NVIC_SetPriority(PendSV_IRQn, PendSV_IRQn_Priority);
;;;640    }
00000e  4770              BX       lr
;;;641    
                          ENDP

                  |L1.16|
                          DCD      PendSV_InterruptHandler
                  |L1.20|
                          DCD      Fncp_PendSV_IRQHandler
                  |L1.24|
                          DCD      0xe000e00e

                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L2.0|
;;;57     #if 1
;;;58     void HardFault_Handler(void)
000000  e7fe              B        |L2.0|
;;;59     {
;;;60     //	SCRB->SYS_RST_CTL.tBit.sys_rst = 0;
;;;61     	while (1);
;;;62     }
;;;63     #else
                          ENDP


                          AREA ||i.PendSV_InterruptHandler||, CODE, READONLY, ALIGN=1

                  PendSV_InterruptHandler PROC
;;;106    #endif
;;;107    void PendSV_InterruptHandler(void)
000000  f7ffbffe          B.W      HAL_GetSensingMode
;;;108    {
;;;109    #if IS_MULTI_PROTOCOL_OPERATION
;;;110    	eActivePenType_t eActivePenOpType = hal_Info_GetControlActivePenOPType();
;;;111    #endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;112    	eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
;;;113    
;;;114    	// _gT(_GPIO_TP_INTR);
;;;115    
;;;116    	switch (eSensingMode)
;;;117    	{
;;;118    #if USED_PEN_MODE_OPERATION
;;;119    		case SM_FINGER_PEN_ACTIVE_FRQ_MAIN_MODE:
;;;120    		case SM_FINGER_PEN_ACTIVE_FRQ_HOP1_MODE:
;;;121    		case SM_FINGER_PEN_ACTIVE_FRQ_HOP2_MODE:
;;;122    		{
;;;123    //			tAlgorithmInfo_t *ptAlgorithmInfo = algorithm_GetInfo();
;;;124    			tPenInfo_t *ptPenInfo = &sptAlgorithmInfo->tPenInfo;
;;;125    			volatile ePartialSensing_t RetVal = PARTIAL_PEN_BEACON;
;;;126    			RetVal = tHalIntrHandle.eLocalSensingType;
;;;127    
;;;128    			hal_set_LocalType_flag(RetVal);
;;;129    
;;;130    			if(TEST_LOCAL_STATE == 1)
;;;131    			{
;;;132    				switch (RetVal)
;;;133    				{
;;;134    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;135    					case PARTIAL_PEN_COORD_DATA1:
;;;136    					case PARTIAL_PEN_COORD_DATA2:
;;;137    					case PARTIAL_PEN_COORD_DATA3:
;;;138    					case PARTIAL_PEN_COORD_DATA4:
;;;139    		#if USED_WGP_PEN_UHD_16LHB_OPERATION
;;;140    					case PARTIAL_PEN_COORD_DATA5:
;;;141    					case PARTIAL_PEN_COORD_DATA6:
;;;142    					case PARTIAL_PEN_COORD_DATA7:
;;;143    					case PARTIAL_PEN_COORD_DATA8:
;;;144    		#endif /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;145    					{
;;;146    						module_read_local_penposition_pendata_sample_data(RetVal);
;;;147    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;148    		#if 1
;;;149    						if(ptPenInfo->bSearch_Mode_Flag == 0)
;;;150    						{
;;;151    			#if USED_WGP_PEN_UHD_16LHB_OPERATION
;;;152    							{
;;;153    								ePartialSensing_t eTempRetVal = RetVal;
;;;154    								if(eTempRetVal > PARTIAL_PEN_COORD_DATA4)
;;;155    								{
;;;156    									eTempRetVal -= 4;
;;;157    								}
;;;158    								algorithm_data_local_process(eTempRetVal);
;;;159    							}
;;;160    			#else /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;161    							algorithm_data_local_process(RetVal);
;;;162    			#endif /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;163    
;;;164    							if(ptPenInfo->usPen_Coord_Cnt==0)
;;;165    							{
;;;166    			#if USED_PEN_ID_GET_FUNCTION
;;;167    								hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETHASH_BEACON);
;;;168    			#else /* USED_PEN_ID_GET_FUNCTION */
;;;169    								hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;170    			#endif /* USED_PEN_ID_GET_FUNCTION */
;;;171    
;;;172    			#ifdef OUT_IN_DRAWING
;;;173    								ptPenInfo->PrePos.x = 0;
;;;174    								ptPenInfo->PrePos.y = 0;
;;;175    			#endif
;;;176    								algorithm_coord_init_local_DSP();
;;;177    								sptAlgorithmInfo->tCoord_local_dsp.PenContactCnt = 0;
;;;178    								sensingRowStart_Tilt = sensingRowStart;
;;;179    								sptAlgorithmInfo->tTiltInfo.sTilt_cnt = 1;
;;;180    								sptAlgorithmInfo->tTiltInfo.HID_TILT_X = sptAlgorithmInfo->tTiltInfo.Smooth_PastTilt.x = 9000;
;;;181    								sptAlgorithmInfo->tTiltInfo.HID_TILT_Y = sptAlgorithmInfo->tTiltInfo.Smooth_PastTilt.y = 9000;
;;;182    			#if (TiltMedianFilter == YES)
;;;183    								for(uint8_t i = 1; i < 6 ; i++)
;;;184    								{
;;;185    									sptAlgorithmInfo->tTiltInfo.Median_PastTilt[i].x = 9000;
;;;186    									sptAlgorithmInfo->tTiltInfo.Median_PastTilt[i].y = 9000;
;;;187    								}
;;;188    			#endif
;;;189    							}
;;;190    
;;;191    							if(ptPenInfo->bPenContact == YES || ptPenInfo->bPrevPenContact == YES)
;;;192    							{
;;;193    								algorithm_local_dsp_process(1, RetVal, LOCAL_MODE);
;;;194    							}
;;;195    							else
;;;196    							{
;;;197    								algorithm_local_dsp_process(1, RetVal, LOCAL_HOVER_MODE);
;;;198    							}
;;;199    								
;;;200    							if(ptPenInfo->usPen_Coord_Cnt++ > 32760)
;;;201    							{
;;;202    								ptPenInfo->usPen_Coord_Cnt = 10;
;;;203    							}
;;;204    						}
;;;205    						else
;;;206    						{
;;;207    							algorithm_hover_full_search(RetVal);
;;;208    
;;;209    							ptPenInfo->usPen_Coord_Cnt = 0;
;;;210    							ptPenInfo->bPenContact = NO;
;;;211    							ptPenInfo->bReportEraser = 0;
;;;212    						}
;;;213    
;;;214    			#if USED_PEN_ID_GET_FUNCTION
;;;215    						if(RetVal == PARTIAL_PEN_COORD_DATA2 || RetVal == PARTIAL_PEN_COORD_DATA6)
;;;216    						{
;;;217    							if(ptPenInfo->bGetHashIDComplete == NO)
;;;218    							{
;;;219    //									if (ptPenInfo->bPenContact == YES || ptPenInfo->bPrevPenContact == YES)
;;;220    //									{
;;;221    //										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETHASH_BEACON);
;;;222    //									}
;;;223    								ptPenInfo->bHashnIDCompareDone = NO;
;;;224    							}
;;;225    							else
;;;226    							{
;;;227    								if(ptPenInfo->bHashnIDCompareDone == NO)
;;;228    								{
;;;229    									if(ptPenInfo->ucPrevPenHashVal == ptPenInfo->ucCurPenHashVal)
;;;230    									{
;;;231    										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;232    										ptPenInfo->bGetPenIDComplete = YES;
;;;233    										ptPenInfo->bHashnIDCompareDone = YES;
;;;234    									}
;;;235    									else
;;;236    									{
;;;237    										if(ptPenInfo->bPenContact == YES || ptPenInfo->bPrevPenContact == YES)
;;;238    										{
;;;239    											ptPenInfo->bGetPenIDComplete = NO;
;;;240    											ptPenInfo->ucPrevPenHashVal = ptPenInfo->ucCurPenHashVal;
;;;241    											ptPenInfo->bHashnIDCompareDone = YES;
;;;242    											hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETID_1st_BEACON);
;;;243    										}
;;;244    									}
;;;245    								}
;;;246    								else if(ptPenInfo->bGetPenIDComplete == NO)
;;;247    								{
;;;248    									uint32_t currentBeacontype = hal_Info_GetCurrentWGPPenBeaconType();
;;;249    									if (currentBeacontype == PWM_WGP_PEN_GETID_1st_BEACON)
;;;250    									{
;;;251    										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETID_2nd_BEACON);
;;;252    									}
;;;253    									else if (currentBeacontype == PWM_WGP_PEN_GETID_2nd_BEACON)
;;;254    									{
;;;255    										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETID_3rd_BEACON);
;;;256    									}
;;;257    									else if (currentBeacontype == PWM_WGP_PEN_GETID_3rd_BEACON)
;;;258    									{
;;;259    										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;260    									}
;;;261    								}
;;;262    							}
;;;263    						}
;;;264    			#endif /* USED_PEN_ID_GET_FUNCTION */
;;;265    
;;;266    
;;;267    		#endif
;;;268    						break;
;;;269    					}
;;;270    	#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;271    					case PARTIAL_PEN_COORD1:
;;;272    					case PARTIAL_PEN_COORD2:
;;;273    					case PARTIAL_PEN_COORD3:
;;;274    					case PARTIAL_PEN_COORD4:
;;;275    					{
;;;276    						// _gOut(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;277    						module_read_local_penposition_sample_data(RetVal);
;;;278    						// _gOut(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;279    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;280    		#if 1
;;;281    						if(ptPenInfo->bSearch_Mode_Flag == 0)
;;;282    						{
;;;283    							if(ptPenInfo->usPen_Coord_Cnt == 0)
;;;284    							{
;;;285    								ptPenInfo->usSearch_Mode_Cnt = 0;
;;;286    
;;;287    			#if IS_MULTI_PROTOCOL_OPERATION
;;;288    								if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;289    			#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;290    			#if (IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;291    								{
;;;292    									hal_Info_SetMPPPen1stBeaconType(PWM_MPP_PEN_1st_PEN_BEACON);
;;;293    								}
;;;294    			#endif /* (IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;295    			#if IS_MULTI_PROTOCOL_OPERATION
;;;296    								else if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;297    			#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;298    			#if (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;299    								{
;;;300    				#if USED_PEN_ID_GET_FUNCTION
;;;301    									hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETHASH_BEACON);
;;;302    				#else /* USED_PEN_ID_GET_FUNCTION */
;;;303    									hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;304    				#endif /* USED_PEN_ID_GET_FUNCTION */
;;;305    								}
;;;306    			#endif  /* (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;307    								
;;;308    			#ifdef OUT_IN_DRAWING
;;;309    								ptPenInfo->PrePos.x = 0;
;;;310    								ptPenInfo->PrePos.y = 0;
;;;311    			#endif
;;;312    								algorithm_coord_init_local_DSP();
;;;313    								sptAlgorithmInfo->tCoord_local_dsp.PenContactCnt = 0;
;;;314    								sensingRowStart_Tilt = sensingRowStart;
;;;315    			#if (TiltMedianFilter == YES)
;;;316    								for(uint8_t i = 1; i < 6 ; i++)
;;;317    								{
;;;318    									sptAlgorithmInfo->tTiltInfo.Median_PastTilt[i].x = 9000;
;;;319    									sptAlgorithmInfo->tTiltInfo.Median_PastTilt[i].y = 9000;
;;;320    								}
;;;321    			#endif
;;;322    							}
;;;323    
;;;324    							if(ptPenInfo->bPenContact == YES || ptPenInfo->bPrevPenContact == YES)
;;;325    							{
;;;326    								algorithm_local_dsp_process(1, RetVal, LOCAL_MODE);
;;;327    							}
;;;328    							else
;;;329    							{
;;;330    								algorithm_local_dsp_process(1, RetVal, LOCAL_HOVER_MODE);
;;;331    							}
;;;332    							if(ptPenInfo->usPen_Coord_Cnt++ > 32760)
;;;333    							{
;;;334    								ptPenInfo->usPen_Coord_Cnt = 10;
;;;335    							}
;;;336    						}
;;;337    						else
;;;338    						{
;;;339    							algorithm_hover_full_search(RetVal);
;;;340    
;;;341    							sensingRowStart_Tilt = sensingRowStart;
;;;342    							ptPenInfo->usPen_Coord_Cnt = 0;
;;;343    							ptPenInfo->bPenContact = NO;
;;;344    							ptPenInfo->bReportEraser = 0;
;;;345    			#ifdef TILT_ON
;;;346    							sensingRowStart_Tilt_Offset = 0;
;;;347    			#endif
;;;348    						}
;;;349    		#endif
;;;350    						break;
;;;351    					}
;;;352    					case PARTIAL_PEN_DATA1:
;;;353    					case PARTIAL_PEN_DATA2:
;;;354    					case PARTIAL_PEN_DATA3:
;;;355    					case PARTIAL_PEN_DATA4:
;;;356    					case PARTIAL_PEN_DATA5:
;;;357    					{
;;;358    						module_read_local_pendata_sample_data(RetVal);
;;;359    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;360    
;;;361    						algorithm_data_local_process(RetVal);
;;;362    
;;;363    		#if IS_MULTI_PROTOCOL_OPERATION
;;;364    						if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;365    		#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;366    		#if (IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;367    						{
;;;368    							if(RetVal == PARTIAL_PEN_DATA3 ||
;;;369    								RetVal == PARTIAL_PEN_DATA4)
;;;370    							{
;;;371    								p_currentRowStart = currentRowStart;
;;;372    								currentRowStart = sensingRowStart;
;;;373    								currentColStart = ptPenInfo->ucCurrentColumnStart;
;;;374    							}
;;;375    						}
;;;376    		#endif /* (IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;377    		#if IS_MULTI_PROTOCOL_OPERATION
;;;378    						else if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;379    		#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;380    		#if (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;381    						{
;;;382    			#if USED_PEN_ID_GET_FUNCTION
;;;383    							if(RetVal == PARTIAL_PEN_DATA2)
;;;384    							{
;;;385    								if(ptPenInfo->bGetHashIDComplete == NO)
;;;386    								{
;;;387    //									if (ptPenInfo->bPenContact == YES || ptPenInfo->bPrevPenContact == YES)
;;;388    //									{
;;;389    //										hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETHASH_BEACON);
;;;390    //									}
;;;391    									ptPenInfo->bHashnIDCompareDone = NO;
;;;392    								}
;;;393    								else
;;;394    								{
;;;395    									if(ptPenInfo->bHashnIDCompareDone == NO)
;;;396    									{
;;;397    										if(ptPenInfo->ucPrevPenHashVal == ptPenInfo->ucCurPenHashVal)
;;;398    										{
;;;399    											hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;400    											ptPenInfo->bGetPenIDComplete = YES;
;;;401    											ptPenInfo->bHashnIDCompareDone = YES;
;;;402    										}
;;;403    										else
;;;404    										{
;;;405    											if(ptPenInfo->bPenContact == YES || ptPenInfo->bPrevPenContact == YES)
;;;406    											{
;;;407    												ptPenInfo->bGetPenIDComplete = NO;
;;;408    												ptPenInfo->ucPrevPenHashVal = ptPenInfo->ucCurPenHashVal;
;;;409    												ptPenInfo->bHashnIDCompareDone = YES;
;;;410    												hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETID_1st_BEACON);
;;;411    											}
;;;412    										}
;;;413    									}
;;;414    									else if(ptPenInfo->bGetPenIDComplete == NO)
;;;415    									{
;;;416    										uint32_t currentBeacontype = hal_Info_GetCurrentWGPPenBeaconType();
;;;417    										if (currentBeacontype == PWM_WGP_PEN_GETID_1st_BEACON)
;;;418    										{
;;;419    											hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETID_2nd_BEACON);
;;;420    										}
;;;421    										else if (currentBeacontype == PWM_WGP_PEN_GETID_2nd_BEACON)
;;;422    										{
;;;423    											hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETID_3rd_BEACON);
;;;424    										}
;;;425    										else if (currentBeacontype == PWM_WGP_PEN_GETID_3rd_BEACON)
;;;426    										{
;;;427    											hal_Info_SetChangeWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;428    										}
;;;429    									}
;;;430    								}
;;;431    							}
;;;432    			#endif /* #if USED_PEN_ID_GET_FUNCTION */
;;;433    
;;;434    							if(RetVal == PARTIAL_PEN_DATA4)
;;;435    							{
;;;436    								p_currentRowStart = currentRowStart;
;;;437    								currentRowStart = sensingRowStart;
;;;438    								currentColStart = ptPenInfo->ucCurrentColumnStart;
;;;439    							}
;;;440    						}
;;;441    		#endif  /* (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;442    						break;
;;;443    					}
;;;444    	#endif /* (USED_PEN_PROTOCOL != PEN_PROTOCOL_WGP_UHD_PEN) */
;;;445    					case PARTIAL_FINGER1:
;;;446    					case PARTIAL_FINGER2:
;;;447    					case PARTIAL_FINGER3:
;;;448    					case PARTIAL_FINGER4:
;;;449    					case PARTIAL_FINGER5:
;;;450    					{
;;;451    						module_read_local_finger_sample_data(RetVal);
;;;452    	#if IS_MULTI_PROTOCOL_OPERATION
;;;453    						if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;454    	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;455    	#if (IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;456    						{
;;;457    #if ((CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP) || (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_MPP) || (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_SPLIT_MPP) || (CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_WGP_Pen) || (CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_MPP_Pen))
;;;458    							if(RetVal == PARTIAL_FINGER2 ||
;;;459    								RetVal == PARTIAL_FINGER4)
;;;460    #else /* (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP) */
;;;461    							if(RetVal == PARTIAL_FINGER1 ||
;;;462    								RetVal == PARTIAL_FINGER3)
;;;463    #endif /* (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP) */
;;;464    							{
;;;465    								p_currentRowStart = currentRowStart;
;;;466    								currentRowStart = sensingRowStart;
;;;467    								currentColStart = ptPenInfo->ucCurrentColumnStart;
;;;468    							}
;;;469    						}
;;;470    	#endif /* (IS_MSPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;471    	#if IS_MULTI_PROTOCOL_OPERATION
;;;472    						else if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;473    	#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;474    	#if (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;475    						{
;;;476    		#if IS_WGPUHDPEN_PROTOCOL_OPERATION
;;;477    			#if USED_WGP_PEN_UHD_16LHB_OPERATION
;;;478    							if(RetVal == PARTIAL_FINGER1 ||
;;;479    								RetVal == PARTIAL_FINGER2 ||
;;;480    								RetVal == PARTIAL_FINGER3 ||
;;;481    								RetVal == PARTIAL_FINGER4)
;;;482    			#else /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;483    							if(RetVal == PARTIAL_FINGER1 ||
;;;484    								RetVal == PARTIAL_FINGER2)
;;;485    			#endif /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;486    		#else /* IS_WGPUHDPEN_PROTOCOL_OPERATION */
;;;487    			#if ((CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP) || (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_MPP) || (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_SPLIT_MPP) || (CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_WGP_Pen) || (CUSTOMER == MODEL_DEF_FHD_PLUSE_92510_Dell_Wendy_WGP_Pen) || (CUSTOMER == MODEL_DEF_UHD_PLUSE_92508_Dell_Yolanda_MPP_Pen))
;;;488    							if(RetVal == PARTIAL_FINGER2)
;;;489    			#else /* (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP) */
;;;490    							if(RetVal == PARTIAL_FINGER1)
;;;491    			#endif /* (CUSTOMER == MODEL_DEF_SQHD_92509_HUANAN_WGP) */
;;;492    		#endif /* IS_WGPUHDPEN_PROTOCOL_OPERATION */
;;;493    							{
;;;494    								p_currentRowStart = currentRowStart;
;;;495    								currentRowStart = sensingRowStart;
;;;496    								currentColStart = ptPenInfo->ucCurrentColumnStart;
;;;497    							}
;;;498    						}
;;;499    	#endif  /* (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;500    
;;;501    						if (RetVal == LOCAL_FINGER_LAST_LHB)
;;;502    						{
;;;503    							hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;504    						}
;;;505    						break;
;;;506    					}
;;;507    	#if (IS_WGPPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION)
;;;508    					case PARTIAL_TILT1:
;;;509    					case PARTIAL_TILT2:
;;;510    					{
;;;511    						module_read_local_pentilt_sample_data(RetVal);
;;;512    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;513    		#ifdef TILT_ON
;;;514    			#if IS_NOT_WGPUHDPEN_PROTOCOL_OPERATION
;;;515    						if (ptPenInfo->bSearch_Mode_Flag == 0)
;;;516    						{
;;;517    							algorithm_local_dsp_process(1, RetVal, LOCAL_TILT_MODE);
;;;518    						}
;;;519    			#else /* IS_NOT_WGPUHDPEN_PROTOCOL_OPERATION */
;;;520    				#if (CUSTOMER == MODEL_DEF_QHD_92512_Dell_WGP_UHD_PEN)
;;;521    						if (ptPenInfo->bSearch_Mode_Flag == 0)
;;;522    						{
;;;523    							algorithm_local_dsp_process(1, RetVal, LOCAL_TILT_MODE);
;;;524    						}
;;;525    						else 
;;;526    				#endif
;;;527    						if (ptPenInfo->bSearch_Mode_Flag == 1)
;;;528    							algorithm_baseline_tracking_continuous_local_ring();
;;;529    			#endif /* IS_NOT_WGPUHDPEN_PROTOCOL_OPERATION */
;;;530    		#else
;;;531    						sensingRowStart_Tilt = sensingRowStart;
;;;532    		#endif
;;;533    		#if IS_MULTI_PROTOCOL_OPERATION
;;;534    						if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;535    		#endif /* IS_MULTI_PROTOCOL_OPERATION */
;;;536    		#if (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;537    						{
;;;538    							p_currentRowStart = currentRowStart;
;;;539    							currentRowStart = sensingRowStart;
;;;540    							currentColStart = ptPenInfo->ucCurrentColumnStart;
;;;541    						}
;;;542    		#endif /* (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;543    						break;
;;;544    					}
;;;545    	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;546    					case PARTIAL_MAX:
;;;547    					{
;;;548    						while(1);
;;;549    					}
;;;550    
;;;551    					default:
;;;552    					break;
;;;553    				}
;;;554    			}
;;;555    			else
;;;556    			{
;;;557    				switch (RetVal)
;;;558    				{
;;;559    	#if (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION)
;;;560    					case PARTIAL_TILT1:
;;;561    					case PARTIAL_TILT2:
;;;562    					{
;;;563    						module_read_local_pentilt_sample_data(RetVal);
;;;564    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;565    						break;
;;;566    					}
;;;567    	#endif /* (IS_WGPPEN_PROTOCOL_OPERATION || IS_WGPUHDPEN_PROTOCOL_OPERATION || IS_MULTI_PROTOCOL_OPERATION) */
;;;568    	#if IS_WGPUHDPEN_PROTOCOL_OPERATION
;;;569    					case PARTIAL_PEN_COORD_DATA1:
;;;570    					case PARTIAL_PEN_COORD_DATA2:
;;;571    					case PARTIAL_PEN_COORD_DATA3:
;;;572    					case PARTIAL_PEN_COORD_DATA4:
;;;573    		#if USED_WGP_PEN_UHD_16LHB_OPERATION
;;;574    					case PARTIAL_PEN_COORD_DATA5:
;;;575    					case PARTIAL_PEN_COORD_DATA6:
;;;576    					case PARTIAL_PEN_COORD_DATA7:
;;;577    					case PARTIAL_PEN_COORD_DATA8:
;;;578    		#endif /* USED_WGP_PEN_UHD_16LHB_OPERATION */
;;;579    					{
;;;580    						module_read_local_penposition_pendata_sample_data(RetVal);
;;;581    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;582    						break;
;;;583    					}
;;;584    	#else /* IS_WGPUHDPEN_PROTOCOL_OPERATION */
;;;585    					case PARTIAL_PEN_COORD1:
;;;586    					case PARTIAL_PEN_COORD2:
;;;587    					case PARTIAL_PEN_COORD3:
;;;588    					case PARTIAL_PEN_COORD4:
;;;589    					{
;;;590    						module_read_local_penposition_sample_data(RetVal);
;;;591    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;592    						break;
;;;593    					}
;;;594    					case PARTIAL_PEN_DATA1:
;;;595    					case PARTIAL_PEN_DATA2:
;;;596    					case PARTIAL_PEN_DATA3:
;;;597    					case PARTIAL_PEN_DATA4:
;;;598    					case PARTIAL_PEN_DATA5:
;;;599    					{
;;;600    						module_read_local_pendata_sample_data(RetVal);
;;;601    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;602    						break;
;;;603    					}
;;;604    	#endif /* IS_WGPUHDPEN_PROTOCOL_OPERATION */
;;;605    					case PARTIAL_FINGER1:
;;;606    					case PARTIAL_FINGER2:
;;;607    					case PARTIAL_FINGER3:
;;;608    					case PARTIAL_FINGER4:
;;;609    					case PARTIAL_FINGER5:
;;;610    					{
;;;611    						module_read_local_finger_sample_data(RetVal);
;;;612    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;613    						break;
;;;614    					}
;;;615    					default:
;;;616    						break;
;;;617    				}
;;;618    			}
;;;619    			break;
;;;620    		}
;;;621    #endif /* USED_PEN_MODE_OPERATION */
;;;622    		case SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE:
;;;623    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE:
;;;624    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP2_MODE:
;;;625    		case SM_FINGER_ONLY_IDLE_MODE:
;;;626    		case SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE:
;;;627    		case SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP1_MODE:
;;;628    		case SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP2_MODE:
;;;629    //		case SM_FINGER_PEN_SEARCH_IDLE_MODE:
;;;630    		{
;;;631    			break;
;;;632    		}
;;;633    	}
;;;634    }
;;;635    
                          ENDP


                          AREA ||i.SensingBufferInit||, CODE, READONLY, ALIGN=2

                  SensingBufferInit PROC
;;;641    
;;;642    void SensingBufferInit(void)
000000  b510              PUSH     {r4,lr}
;;;643    {
;;;644    	p_currentRowStart =			0;
000002  4809              LDR      r0,|L4.40|
000004  2400              MOVS     r4,#0
000006  8004              STRH     r4,[r0,#0]
;;;645    	sensingRowStart =			0;
000008  8044              STRH     r4,[r0,#2]
;;;646    	currentRowStart =			0;
00000a  8084              STRH     r4,[r0,#4]
;;;647    	sensingRowStart_Tilt = 		0;
00000c  80c4              STRH     r4,[r0,#6]
;;;648    
;;;649    	pFreqHoppingAndModeTest =	0;
00000e  6084              STR      r4,[r0,#8]  ; pFreqHoppingAndModeTest
;;;650    #if USED_ECLK_ON_OFF_CONTROL
;;;651    	HAL_SetECLKOnOffControl(NO);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_SetECLKOnOffControl
;;;652    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;653    	tHalIntrHandle.ulMSPIPenModeIntrCnt = 0;
000016  4805              LDR      r0,|L4.44|
000018  6004              STR      r4,[r0,#0]  ; tHalIntrHandle
;;;654    	tHalIntrHandle.ulInitFirstFrame = 1;
00001a  2101              MOVS     r1,#1
00001c  6281              STR      r1,[r0,#0x28]  ; tHalIntrHandle
;;;655    	tHalIntrHandle.ulVSyncFlag = 0;
00001e  6184              STR      r4,[r0,#0x18]  ; tHalIntrHandle
;;;656    	tHalIntrHandle.ulTSyncInFallingCnt = 0;
000020  61c4              STR      r4,[r0,#0x1c]  ; tHalIntrHandle
;;;657    	tHalIntrHandle.ulTSyncInRisingCnt = 0;
000022  6204              STR      r4,[r0,#0x20]  ; tHalIntrHandle
;;;658    	tHalIntrHandle.ulLocalIndexChangeStart = 0;
000024  6084              STR      r4,[r0,#8]  ; tHalIntrHandle
;;;659    #if USED_PWM_PULSE_END_FLAG_CHECK
;;;660    	tHalIntrHandle.ulPWM_Pulse_End_Flag = NO;
;;;661    #endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;662    }
000026  bd10              POP      {r4,pc}
                          ENDP

                  |L4.40|
                          DCD      ||.data||
                  |L4.44|
                          DCD      tHalIntrHandle

                          AREA ||.data||, DATA, ALIGN=2

                  p_currentRowStart
000000  0000              DCW      0x0000
                  sensingRowStart
000002  0000              DCW      0x0000
                  currentRowStart
000004  0000              DCW      0x0000
                  sensingRowStart_Tilt
000006  0000              DCB      0x00,0x00
                  pFreqHoppingAndModeTest
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\interrupt.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_631c50be____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___11_interrupt_c_631c50be____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_631c50be____REVSH|
#line 402
|__asm___11_interrupt_c_631c50be____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_631c50be____RRX|
#line 587
|__asm___11_interrupt_c_631c50be____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
