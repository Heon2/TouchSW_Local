; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\algorithm_baseline.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\algorithm_baseline.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\algorithm_baseline.crf ..\..\App\Algorithm\Baseline\algorithm_baseline.c]
                          THUMB

                          AREA ||i.abnormal_rawdata_detection_for_hopping||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_detection_for_hopping PROC
;;;828    
;;;829    bool_t abnormal_rawdata_detection_for_hopping(bool_t SET)
000000  4907              LDR      r1,|L1.32|
;;;830    {
;;;831    	static uint32_t AbnormalCnt  = 0;
;;;832    	uint32_t lAbnormalCnt = 0;
;;;833    
;;;834    	if( SET )
000002  2800              CMP      r0,#0
000004  69ca              LDR      r2,[r1,#0x1c]
;;;835    	{
;;;836    		AbnormalCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  61c8              STRNE    r0,[r1,#0x1c]  ; AbnormalCnt
00000c  d105              BNE      |L1.26|
;;;837    	}
;;;838    	else
;;;839    	{
;;;840    		lAbnormalCnt = AbnormalCnt;
;;;841    		AbnormalCnt = 0;
00000e  2000              MOVS     r0,#0
;;;842    
;;;843    		if(lAbnormalCnt > 0)
000010  61c8              STR      r0,[r1,#0x1c]  ; AbnormalCnt
000012  2a00              CMP      r2,#0
;;;844    		{
;;;845    			return TRUE;
000014  bf1c              ITT      NE
000016  2001              MOVNE    r0,#1
;;;846    		}
;;;847    	}
;;;848    	return FALSE;
;;;849    }
000018  4770              BXNE     lr
                  |L1.26|
00001a  2000              MOVS     r0,#0                 ;848
00001c  4770              BX       lr
;;;850    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||

                          AREA ||i.abnormal_rawdata_temp||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_temp PROC
;;;805    
;;;806    bool_t abnormal_rawdata_temp(bool_t SET)
000000  4907              LDR      r1,|L2.32|
;;;807    {
;;;808    	static uint32_t dataCnt = 0;
;;;809    	uint32_t ldataCnt = 0;
;;;810    
;;;811    	if(SET)
000002  2800              CMP      r0,#0
000004  698a              LDR      r2,[r1,#0x18]
;;;812    	{
;;;813    		dataCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  6188              STRNE    r0,[r1,#0x18]  ; dataCnt
00000c  d105              BNE      |L2.26|
;;;814    	}
;;;815    	else
;;;816    	{
;;;817    		ldataCnt = dataCnt;
;;;818    		dataCnt = 0;
00000e  2000              MOVS     r0,#0
;;;819    
;;;820    		if(ldataCnt > 10)
000010  6188              STR      r0,[r1,#0x18]  ; dataCnt
000012  2a0a              CMP      r2,#0xa
;;;821    		{
;;;822    			return TRUE;
000014  bf84              ITT      HI
000016  2001              MOVHI    r0,#1
;;;823    		}
;;;824    	}
;;;825    
;;;826    	return FALSE;
;;;827    }
000018  4770              BXHI     lr
                  |L2.26|
00001a  2000              MOVS     r0,#0                 ;826
00001c  4770              BX       lr
;;;828    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_calculate_delta||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta PROC
;;;931    uint32_t gulESD_DletaSum = 0;
;;;932    bool_t algorithm_baseline_calculate_delta(int mode)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;933    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
;;;934    	int r, c;
;;;935    	int delta;	
;;;936    //	int local_rs;
;;;937    //	int pen_touch_data = 0;
;;;938    	uint16_t read_raw_data;
;;;939    //	tCell_t pen_pos;
;;;940    //	int pen_touch_data2 = 0;
;;;941    	tOrigDeltaInfo_t * temp_delta;
;;;942    	uint16_t * pBaseImage;
;;;943    #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;944    	uint16_t * pESDBaseImage;
;;;945    #endif
;;;946    	tAppInfo_t * ptAppInfo = app_GetInfo();
000008  f7fffffe          BL       app_GetInfo
;;;947    	
;;;948    	//Adaptive SeedBase LYB_200819
;;;949    	uint16_t AdaptiveSeedBase = 0;
;;;950    	
;;;951    #if CPI_TEST_EN
;;;952    	uint16_t AbnormalRawCnt = 0;	
;;;953    	uint32_t RawPartSum[COL_MAX/5+1] = {0};
;;;954    	uint16_t RawPartSumCnt[COL_MAX/5+1] = {0};
;;;955    	uint16_t AbnormalDeltaCntInMux[COL_MAX/5+1] = {0};
;;;956    	int DeltaEdgeCntInMux = 0;
;;;957    	uint8_t PhoneNoiseConditionCnt = 0;
;;;958    #endif
;;;959    #if LGD_ERROR_FRAME_PROCESS_EN
;;;960    	int EvenDelta = 0, OddDelta = 0;
;;;961    #endif
;;;962    	thisInfo->bBlockTracking = NO;
00000c  4dae              LDR      r5,|L3.712|
00000e  2700              MOVS     r7,#0
000010  4680              MOV      r8,r0                 ;946
000012  68ec              LDR      r4,[r5,#0xc]  ; thisInfo
;;;963    //	local_rs = 0;
;;;964    	temp_delta = &thisInfo->tDelta;
;;;965    
;;;966    	memset((void *)temp_delta, 0x00, sizeof(tOrigDeltaInfo_t));
000014  2138              MOVS     r1,#0x38
000016  f8047b0d          STRB     r7,[r4],#0xd          ;962
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       __aeabi_memclr
;;;967    	temp_delta->tValidRect.cs = COL_MAX - 1; temp_delta->tValidRect.ce = 0;
000020  2053              MOVS     r0,#0x53
000022  70a0              STRB     r0,[r4,#2]
000024  70e7              STRB     r7,[r4,#3]
;;;968    	temp_delta->tValidRect.rs = ROW_MAX - 1; temp_delta->tValidRect.re = 0;
000026  202f              MOVS     r0,#0x2f
000028  7020              STRB     r0,[r4,#0]
00002a  7067              STRB     r7,[r4,#1]
;;;969    #if USED_NOISE_HOPPING_FREQ
;;;970    	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;971    		if(ptAppInfo->eCurrentSelectFreq == FREQ_MAIN)
00002c  f8980012          LDRB     r0,[r8,#0x12]
000030  2801              CMP      r0,#1
000032  bf0c              ITE      EQ
000034  e9d5c008          LDRDEQ   r12,r0,[r5,#0x20]
000038  e9d5c00a          LDRDNE   r12,r0,[r5,#0x28]
;;;972    	//	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;973    		{
;;;974    			pBaseImage = g_pFingerBaseImage;
;;;975    			pESDBaseImage = g_pFingerESDBaseImage;
;;;976    		}
;;;977    		else
;;;978    		{
;;;979    			pBaseImage = g_pFingerHop1BaseImage;
;;;980    			pESDBaseImage = g_pFingerHop1ESDBaseImage;
;;;981    		}
;;;982    	//	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;983    	#else
;;;984    		if(ptAppInfo->eCurrentSelectFreq == FREQ_MAIN)
;;;985    	//	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;986    		{
;;;987    			pBaseImage = g_pFingerBaseImage;
;;;988    		}
;;;989    		else
;;;990    		{
;;;991    			pBaseImage = g_pFingerHop1BaseImage;
;;;992    		}
;;;993    	//	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;994    	#endif
;;;995    #else /* USED_NOISE_HOPPING_FREQ */
;;;996    	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;997    	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;998    		pESDBaseImage = g_pFingerESDBaseImage;
;;;999    	#endif
;;;1000   #endif /* USED_NOISE_HOPPING_FREQ */
;;;1001   	
;;;1002   	temp_delta->iPosCnt = 0;
00003c  9001              STR      r0,[sp,#4]
00003e  2000              MOVS     r0,#0
000040  6160              STR      r0,[r4,#0x14]
;;;1003   	temp_delta->iNegCnt = 0;
000042  61e0              STR      r0,[r4,#0x1c]
;;;1004   
;;;1005   
;;;1006   #if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)	
;;;1007   	tRect_t FingerNonSumOnPenArea;
;;;1008   	bool_t bNonSumFlag = 0;
;;;1009   	FingerNonSumOnPenArea.cs = COL_MAX-1; FingerNonSumOnPenArea.ce = 0;
;;;1010   	FingerNonSumOnPenArea.rs = ROW_MAX-1; FingerNonSumOnPenArea.re = 0;
;;;1011   	if(thisInfo->tDelta_local.iMaxStrength > FingerNonSumThOnPenAreaForReBase
;;;1012   	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;1013   	&& hal_Info_GetControlLocalFingerOPType() == ACTIVEPEN_TYPE_LOCAL_MS
;;;1014   	#endif
;;;1015   	)
;;;1016   	{
;;;1017   		FingerNonSumOnPenArea.cs = MAX(0,thisInfo->tDelta_local.tMaxCellPos.c-3);
;;;1018   		FingerNonSumOnPenArea.ce = MIN(COL_MAX-1,thisInfo->tDelta_local.tMaxCellPos.c+3);
;;;1019   		FingerNonSumOnPenArea.rs = MAX(0,thisInfo->tDelta_local.tMaxCellPos.r+currentRowStart-3);
;;;1020   		FingerNonSumOnPenArea.re = MIN(ROW_MAX-1,thisInfo->tDelta_local.tMaxCellPos.r+currentRowStart+3);
;;;1021   		bNonSumFlag = 1;
;;;1022   	}
;;;1023   #endif
;;;1024   
;;;1025   #if (LABEL_FAST_EN)	
;;;1026   	memset(thisInfo->tLabel.ucLabel_Check,0,sizeof(thisInfo->tLabel.ucLabel_Check));
;;;1027   	#if (LABEL_FAST_EN == 2)
;;;1028   	memset(LABELIMAGE,0,sizeof(LABELIMAGE));
;;;1029   	g_label_num = 0;
;;;1030   	memset((void *)g_ucEqTbl, 0x00, sizeof(uint8_t)*LOOSE_POSBUF_);
;;;1031   	uint8_t u_val, l_val, ul_val, ur_val, max_val1, max_val2, max_val3, min_val1, min_val2, min_val3, map_val, remap_index;
;;;1032   	#endif
;;;1033   #endif
;;;1034   	
;;;1035   #if (USED_DSPA_FUNC_FOR_FINGER && USED_DSPA_FUNC_FOR_FINGER_CAL_DELTA)
;;;1036   	if(!thisModeConf->BaseLine.bDspA_Finger_CalculateDelta)
000044  48a0              LDR      r0,|L3.712|
000046  6882              LDR      r2,[r0,#8]  ; thisModeConf
000048  f8920045          LDRB     r0,[r2,#0x45]
00004c  b340              CBZ      r0,|L3.160|
;;;1037   #endif
;;;1038   	{
;;;1039   		
;;;1040   #if ADAPTIVE_SEEDBASE
;;;1041   		//Adaptive SeedBase LYB_200819
;;;1042   		if(thisInfo->bIsPalm)	AdaptiveSeedBase = (thisModeConf->Label.usSeedBase>>1);
;;;1043   		else					AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
;;;1044   #else
;;;1045   		AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
;;;1046   #endif
;;;1047   		
;;;1048   		for( r=0; r<ROW_MAX; r++ )
;;;1049   		{
;;;1050   #if LGD_ERROR_FRAME_PROCESS_EN
;;;1051   			if(thisModeConf->Noise.ucErrorFrameProcess == 2){
;;;1052   				EvenDelta = 0, OddDelta = 0;
;;;1053   			}
;;;1054   #endif
;;;1055   			for( c=0; c<COL_MAX; c++ )
;;;1056   			{
;;;1057   #if FAST_LF_EN
;;;1058   				read_raw_data = HAL_READ_RAW_IMAGE(r,c) - sLFOffsetRow[r];
;;;1059   #else
;;;1060   				read_raw_data = HAL_READ_RAW_IMAGE(r, c);
;;;1061   #endif
;;;1062   				
;;;1063   #if CPI_TEST_EN
;;;1064   				if(thisModeConf->Noise.ucCPITestOn){
;;;1065   					RawPartSum[c/5] += read_raw_data;
;;;1066   					RawPartSumCnt[c/5]++;
;;;1067   					if(read_raw_data <= 0)	AbnormalRawCnt++;
;;;1068   				}
;;;1069   #endif
;;;1070   				
;;;1071   				delta = (signed)read_raw_data - (signed)(*(pBaseImage++));
;;;1072   
;;;1073   				if(mode == FULL_MODE)
;;;1074   				{							
;;;1075   					if(read_raw_data < MINRAWDATA_MARGIN)
;;;1076   					{
;;;1077   						abnormal_rawdata_temp(TRUE);
;;;1078   					}
;;;1079   #if USED_NOISE_HOPPING_FREQ
;;;1080   					if( read_raw_data < thisModeConf->Noise.usRawDataThd )
;;;1081   					{
;;;1082   						if( HAL_READ_DELTA_IMAGE(r,c) < thisModeConf->Noise.sDeltaDataThd )
;;;1083   						{
;;;1084   							abnormal_rawdata_detection_for_hopping(TRUE);
;;;1085   						}
;;;1086   					}
;;;1087   
;;;1088   #endif /* USED_NOISE_HOPPING_FREQ */
;;;1089   				}
;;;1090   				
;;;1091   #if NORMALIZE_DELTA_EN
;;;1092   				//Normalize Active 190612 limyb
;;;1093   				if(thisModeConf->BaseLine.cNormalizeDelta != 0 && delta > (AdaptiveSeedBase>>1))
;;;1094   				{
;;;1095   	//				int left_top = 1;
;;;1096   	//				int right_bottom = 128;
;;;1097   					int nDelta = delta;
;;;1098   					
;;;1099   	//				nDelta = nDelta * (2*ROW_MAX + r) * (2*COL_MAX + c) / (ROW_MAX * COL_MAX);
;;;1100   					delta = nDelta * ( ((ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta)<<1) - r) / (ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta);
;;;1101   	//				delta = nDelta * (2*ROW_MAX - r + (ROW_MAX>>1)) / ROW_MAX;
;;;1102   				}
;;;1103   #endif
;;;1104   				
;;;1105   				delta >>= ptModuleModeConf->ucOvrShift;
;;;1106   				HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;1107   				
;;;1108   #if LGD_ERROR_FRAME_PROCESS_EN
;;;1109   				//LGD Kiosk error data rejection
;;;1110   				if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;1111   				{
;;;1112   					if(c%2 == 0)	EvenDelta += delta;
;;;1113   					else			OddDelta += delta;
;;;1114   				}
;;;1115   #endif
;;;1116   				
;;;1117   				//Mux baundary
;;;1118   #if CPI_TEST_EN
;;;1119   				if(thisModeConf->Noise.ucCPITestOn){
;;;1120   					if(c != 0 && c < COL_MAX-1)
;;;1121   					{
;;;1122   						if(c%5 == 0){
;;;1123   							if( abs(delta) > 10 && abs(delta - HAL_READ_DELTA_IMAGE(r,c-1)) > (abs(delta - HAL_READ_DELTA_IMAGE(r,c+1))<<1) )
;;;1124   								DeltaEdgeCntInMux++;
;;;1125   						}
;;;1126   					}
;;;1127   				
;;;1128   					if(c%5 == 0)	PhoneNoiseConditionCnt = 0;
;;;1129   					if(delta < -100)	PhoneNoiseConditionCnt++;
;;;1130   					if(PhoneNoiseConditionCnt == 5)	AbnormalDeltaCntInMux[c/5] += 200;
;;;1131   				}
;;;1132   #endif
;;;1133   				
;;;1134   				if( delta > 0 )
;;;1135   				{	
;;;1136   					if( delta > thisModeConf->BaseLine.sAccumPosSumThd )
;;;1137   					{
;;;1138   #if CPI_TEST_EN
;;;1139   						if(thisModeConf->Noise.ucCPITestOn){
;;;1140   							if(delta > 511)	AbnormalDeltaCntInMux[c/5] += 200;
;;;1141   						}
;;;1142   #endif
;;;1143   #if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)							
;;;1144   						if((FingerNonSumOnPenArea.cs > c || FingerNonSumOnPenArea.ce < c || FingerNonSumOnPenArea.rs > r || FingerNonSumOnPenArea.re < r) && bNonSumFlag)
;;;1145   #endif
;;;1146   						{
;;;1147   							temp_delta->iPosCnt++;
;;;1148   							temp_delta->iPosSum += delta - thisModeConf->BaseLine.sAccumPosSumThd;
;;;1149   						}
;;;1150   					}
;;;1151   
;;;1152   //					if( delta > thisModeConf->Label.usSeedBase )
;;;1153   					if( delta > AdaptiveSeedBase )
;;;1154   					{
;;;1155   						if( temp_delta->tValidRect.cs > c )
;;;1156   							temp_delta->tValidRect.cs = c;
;;;1157   						if( temp_delta->tValidRect.ce < c )
;;;1158   							temp_delta->tValidRect.ce = c;
;;;1159   						if( temp_delta->tValidRect.rs > r )
;;;1160   							temp_delta->tValidRect.rs = r;
;;;1161   						if( temp_delta->tValidRect.re < r )
;;;1162   							temp_delta->tValidRect.re = r;
;;;1163   
;;;1164   						temp_delta->iGroupedCellCnt++;						
;;;1165   #if LABEL_FAST_EN
;;;1166   						int idx_r = r/ROW_IN_ARRAY;
;;;1167   						int idx_c = c/COL_IN_ARRAY;
;;;1168   						if(thisInfo->tLabel.ucLabel_Check[idx_r][idx_c]==0)thisInfo->tLabel.ucLabel_Check[idx_r][idx_c] = 1;
;;;1169   #if (LABEL_FAST_EN == 2)
;;;1170   	#if (PAD_ == 0)
;;;1171   						if(r == 0)
;;;1172   						{
;;;1173   							u_val  = 0;
;;;1174   							ul_val = 0;
;;;1175   							ur_val = 0;
;;;1176   						}
;;;1177   						else
;;;1178   						{
;;;1179   							u_val  = HAL_READ_LABEL_IMAGE(r-1, c  );
;;;1180   							if(c == 0)
;;;1181   								ul_val = 0;
;;;1182   							else 
;;;1183   								ul_val = HAL_READ_LABEL_IMAGE(r-1, c-1);
;;;1184   							
;;;1185   							if(c == COL_MAX-1)
;;;1186   								ur_val = 0;
;;;1187   							else 
;;;1188   								ur_val = HAL_READ_LABEL_IMAGE(r-1, c+1);
;;;1189   						}
;;;1190   						
;;;1191   						if(c == 0)
;;;1192   							l_val  = 0;
;;;1193   						else
;;;1194   							l_val  = HAL_READ_LABEL_IMAGE(r  , c-1);
;;;1195   	#else
;;;1196   						u_val  = HAL_READ_LABEL_IMAGE(r-1, c  );
;;;1197   						ul_val = HAL_READ_LABEL_IMAGE(r-1, c-1);
;;;1198   						ur_val = HAL_READ_LABEL_IMAGE(r-1, c+1);
;;;1199   						l_val  = HAL_READ_LABEL_IMAGE(r  , c-1);
;;;1200   	#endif
;;;1201   						max_val1 = MAX(ul_val, l_val);
;;;1202   						max_val2 = MAX(u_val, ur_val);
;;;1203   						max_val3 = MAX(max_val1, max_val2);
;;;1204   
;;;1205   						if (max_val3 != 0)
;;;1206   						{
;;;1207   							if (u_val == 0)  u_val  = 127;
;;;1208   							if (l_val == 0)  l_val  = 127;
;;;1209   							if (ul_val == 0) ul_val = 127;
;;;1210   							if (ur_val == 0) ur_val = 127;
;;;1211   
;;;1212   							min_val1 = MIN(u_val, l_val);
;;;1213   							min_val2 = MIN(ul_val, ur_val);
;;;1214   							min_val3 = MIN(min_val1, min_val2);
;;;1215   
;;;1216   							if (min_val3 != max_val3)
;;;1217   							{
;;;1218   								map_val = min_val3;
;;;1219   								//*(thisInfo->ucEqTbl+max_val3) = min_val3;
;;;1220   
;;;1221   								if(u_val != 127)
;;;1222   								{
;;;1223   									remap_index = u_val;
;;;1224   									while(remap_index != g_ucEqTbl[remap_index])
;;;1225   									{
;;;1226   										remap_index = g_ucEqTbl[remap_index];
;;;1227   										if(min_val3 < remap_index)
;;;1228   											g_ucEqTbl[remap_index] = min_val3;
;;;1229   									}
;;;1230   
;;;1231   									if( g_ucEqTbl[u_val] > min_val3 )
;;;1232   										g_ucEqTbl[u_val] = min_val3;
;;;1233   								}
;;;1234   								if(l_val != 127)
;;;1235   								{
;;;1236   									remap_index = l_val;
;;;1237   									while(remap_index != g_ucEqTbl[remap_index])
;;;1238   									{
;;;1239   										remap_index = g_ucEqTbl[remap_index];
;;;1240   										if(min_val3 < remap_index)
;;;1241   											g_ucEqTbl[remap_index] = min_val3;
;;;1242   									}
;;;1243   
;;;1244   									if( g_ucEqTbl[l_val] > min_val3 )
;;;1245   										g_ucEqTbl[l_val] = min_val3;
;;;1246   								}
;;;1247   								if(ul_val != 127)
;;;1248   								{
;;;1249   									remap_index = ul_val;
;;;1250   									while(remap_index != g_ucEqTbl[remap_index])
;;;1251   									{
;;;1252   										remap_index = g_ucEqTbl[remap_index];
;;;1253   										if(min_val3 < remap_index)
;;;1254   											g_ucEqTbl[remap_index] = min_val3;
;;;1255   									}
;;;1256   
;;;1257   									if( g_ucEqTbl[ul_val] > min_val3 )
;;;1258   										g_ucEqTbl[ul_val] = min_val3;
;;;1259   								}
;;;1260   								if(ur_val != 127)
;;;1261   								{
;;;1262   									remap_index = ur_val;
;;;1263   									while(remap_index != g_ucEqTbl[remap_index])
;;;1264   									{
;;;1265   										remap_index = g_ucEqTbl[remap_index];
;;;1266   										if(min_val3 < remap_index)
;;;1267   											g_ucEqTbl[remap_index] = min_val3;
;;;1268   									}
;;;1269   
;;;1270   									if( g_ucEqTbl[ur_val] > min_val3 )
;;;1271   										g_ucEqTbl[ur_val] = min_val3;
;;;1272   								}
;;;1273   							}
;;;1274   							else
;;;1275   							{
;;;1276   								map_val = max_val3;
;;;1277   							}
;;;1278   						}
;;;1279   						else
;;;1280   						{
;;;1281   							if( g_label_num < LOOSE_POSBUF_ )
;;;1282   							{
;;;1283   								g_label_num++;
;;;1284   							}
;;;1285   
;;;1286   							map_val = g_label_num;
;;;1287   							g_ucEqTbl[g_label_num] = g_label_num;
;;;1288   						}
;;;1289   						
;;;1290   						HAL_WRITE_LABEL_IMAGE(r, c, map_val);
;;;1291   	#endif
;;;1292   #endif
;;;1293   					}
;;;1294   
;;;1295   					if( temp_delta->iMaxStrength < delta )
;;;1296   					{
;;;1297   						temp_delta->iMaxStrength = delta;
;;;1298   					}
;;;1299   				}
;;;1300   				else
;;;1301   				{
;;;1302   					if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;1303   					{
;;;1304   #if CPI_TEST_EN
;;;1305   						if(thisModeConf->Noise.ucCPITestOn){
;;;1306   							AbnormalDeltaCntInMux[c/5]+=5;
;;;1307   							if(delta < -300)	AbnormalDeltaCntInMux[c/5] += 200;
;;;1308   						}
;;;1309   #endif
;;;1310   #if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)				
;;;1311   						if((FingerNonSumOnPenArea.cs > c || FingerNonSumOnPenArea.ce < c || FingerNonSumOnPenArea.rs > r || FingerNonSumOnPenArea.re < r) && bNonSumFlag)
;;;1312   #endif
;;;1313   						{						
;;;1314   							temp_delta->iNegCnt++;
;;;1315   							temp_delta->iNegSum += delta - thisModeConf->BaseLine.sAccumNegSumThd;
;;;1316   						}
;;;1317   					}
;;;1318   
;;;1319   					if( temp_delta->iMinStrength > delta )
;;;1320   					{
;;;1321   						temp_delta->iMinStrength = delta;
;;;1322   						temp_delta->tMinCellPos.r = r;
;;;1323   						temp_delta->tMinCellPos.c = c;
;;;1324   	//					pen_touch_data = -delta;
;;;1325   //						pen_pos.r = r;
;;;1326   //						pen_pos.c = c;
;;;1327   					}
;;;1328   				}
;;;1329   			}
;;;1330   #if LGD_ERROR_FRAME_PROCESS_EN
;;;1331   			//LGD Kiosk error data rejection
;;;1332   			if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;1333   			{
;;;1334   				if(COL_MAX>1)
;;;1335   				{
;;;1336   					EvenDelta /= ( (COL_MAX+1)>>1);
;;;1337   					OddDelta /= (COL_MAX>>1);
;;;1338   					if(abs(EvenDelta - OddDelta) > 5)
;;;1339   					{
;;;1340   						for( c=0; c<COL_MAX; c++ ){
;;;1341   							delta = HAL_READ_DELTA_IMAGE(r,c);
;;;1342   							if(c%2 == 0)
;;;1343   								delta = (delta - EvenDelta < 0) ? 0 : delta - EvenDelta;
;;;1344   							else
;;;1345   								delta = (delta - OddDelta < 0) ? 0 : delta - OddDelta;
;;;1346   							HAL_WRITE_DELTA_IMAGE(r,c,delta);
;;;1347   						}
;;;1348   						
;;;1349   					}
;;;1350   				}
;;;1351   			}
;;;1352   #endif			
;;;1353   		}
;;;1354   		
;;;1355   		thisInfo->bTouchExpect = (temp_delta->iGroupedCellCnt > 0);
;;;1356   	}
;;;1357   #if (USED_DSPA_FUNC_FOR_FINGER && USED_DSPA_FUNC_FOR_FINGER_CAL_DELTA)
;;;1358   	else
;;;1359   	{
;;;1360   		algorithm_baseline_calculate_delta_dspA(mode);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       algorithm_baseline_calculate_delta_dspA
                  |L3.84|
;;;1361   
;;;1362   	#if LOCAL_REBASE_ALGO_EN
;;;1363   		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;1364   		if(bNonSumFlag)
;;;1365   		{
;;;1366   			for(r = FingerNonSumOnPenArea.rs; r <= FingerNonSumOnPenArea.re; r++)for(c = FingerNonSumOnPenArea.cs; c <= FingerNonSumOnPenArea.ce; c++)
;;;1367   			{
;;;1368   				delta = HAL_READ_DELTA_IMAGE(r,c);
;;;1369   				if(delta > thisModeConf->BaseLine.sAccumPosSumThd)
;;;1370   				{
;;;1371   					temp_delta->iPosCnt--;
;;;1372   					temp_delta->iPosSum -= (delta - thisModeConf->BaseLine.sAccumPosSumThd);				
;;;1373   				}
;;;1374   				else if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;1375   				{						
;;;1376   					temp_delta->iNegCnt--;
;;;1377   					temp_delta->iNegSum -= (delta - thisModeConf->BaseLine.sAccumNegSumThd);
;;;1378   				}
;;;1379   			}
;;;1380   		}
;;;1381   		#endif
;;;1382   	#endif
;;;1383   	}
;;;1384   #endif
;;;1385   
;;;1386   #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;1387   //	if(thisInfo->bIsESD_ReportSkip_ByESDScan == NO)
;;;1388   	{
;;;1389   		int32_t sMaxDelta = 0;
000054  2300              MOVS     r3,#0
000056  f8dfa274          LDR      r10,|L3.716|
;;;1390   		int32_t sMinDelta = 0;
00005a  461a              MOV      r2,r3
;;;1391   		uint32_t ulDeltaSum = 0;
00005c  4619              MOV      r1,r3
;;;1392   		for(r=0; r<FINGER_ESD_SCAN_ROW_MAX_NUM; r++)
00005e  4699              MOV      r9,r3
000060  461f              MOV      r7,r3
;;;1393   		{
;;;1394   			for(c=0; c<COL_MAX; c++)
000062  f2433b30          MOV      r11,#0x3330
                  |L3.102|
000066  9801              LDR      r0,[sp,#4]
000068  f04f0854          MOV      r8,#0x54
00006c  eb000649          ADD      r6,r0,r9,LSL #1
000070  ebc700c7          RSB      r0,r7,r7,LSL #3
000074  eb000040          ADD      r0,r0,r0,LSL #1
000078  eb0a00c0          ADD      r0,r10,r0,LSL #3
00007c  f50055fc          ADD      r5,r0,#0x1f80
000080  eb000c0b          ADD      r12,r0,r11
                  |L3.132|
;;;1395   			{
;;;1396   				read_raw_data = HAL_READ_ESD_RAW_IMAGE(r, c);
;;;1397   				delta = (signed)read_raw_data - (signed)(*(pESDBaseImage++));
000084  f8350b02          LDRH     r0,[r5],#2
000088  f836eb02          LDRH     lr,[r6],#2
00008c  eba0000e          SUB      r0,r0,lr
;;;1398   				HAL_WRITE_ESD_DELTA_IMAGE(r, c, delta);
000090  f82c0b02          STRH     r0,[r12],#2
;;;1399   
;;;1400   				if(delta > 0)
000094  2800              CMP      r0,#0
000096  dd7c              BLE      |L3.402|
;;;1401   				{
;;;1402   					if(sMaxDelta < delta)
;;;1403   					{
;;;1404   						sMaxDelta = delta;
000098  4298              CMP      r0,r3
00009a  dd7b              BLE      |L3.404|
00009c  f000b910          B.W      |L3.704|
                  |L3.160|
0000a0  4889              LDR      r0,|L3.712|
0000a2  f8b2a064          LDRH     r10,[r2,#0x64]        ;1045
0000a6  2300              MOVS     r3,#0                 ;1048
0000a8  69c1              LDR      r1,[r0,#0x1c]         ;1048  ; AbnormalCnt
0000aa  9100              STR      r1,[sp,#0]            ;1048
0000ac  f8d09004          LDR      r9,[r0,#4]            ;1105  ; ptModuleModeConf
0000b0  6985              LDR      r5,[r0,#0x18]         ;1105  ; dataCnt
                  |L3.178|
0000b2  4886              LDR      r0,|L3.716|
0000b4  ebc307c3          RSB      r7,r3,r3,LSL #3       ;1060
0000b8  eb070747          ADD      r7,r7,r7,LSL #1       ;1060
0000bc  2100              MOVS     r1,#0                 ;1055
0000be  fa4ffb83          SXTB     r11,r3                ;1322
0000c2  eb0007c7          ADD      r7,r0,r7,LSL #3       ;1060
0000c6  bf00              NOP                            ;1060
                  |L3.200|
0000c8  f8370011          LDRH     r0,[r7,r1,LSL #1]     ;1060
0000cc  f83c8b02          LDRH     r8,[r12],#2           ;1071
0000d0  eba00808          SUB      r8,r0,r8              ;1071
0000d4  b99e              CBNZ     r6,|L3.254|
0000d6  280a              CMP      r0,#0xa               ;1075
0000d8  bf38              IT       CC                    ;1075
0000da  1c6d              ADDCC    r5,r5,#1              ;1075
0000dc  f8b2e1e3          LDRH     lr,[r2,#0x1e3]        ;1080
0000e0  4586              CMP      lr,r0                 ;1080
0000e2  d90c              BLS      |L3.254|
0000e4  eb070041          ADD      r0,r7,r1,LSL #1       ;1082
0000e8  f5004070          ADD      r0,r0,#0xf000         ;1082
0000ec  f9b2e1e5          LDRSH    lr,[r2,#0x1e5]        ;1082
0000f0  f9b006c0          LDRSH    r0,[r0,#0x6c0]        ;1082
0000f4  4570              CMP      r0,lr                 ;1082
0000f6  da02              BGE      |L3.254|
0000f8  9800              LDR      r0,[sp,#0]            ;1082
0000fa  1c40              ADDS     r0,r0,#1              ;1082
0000fc  9000              STR      r0,[sp,#0]            ;1082
                  |L3.254|
0000fe  f8990000          LDRB     r0,[r9,#0]            ;1105
000102  fa48f000          ASR      r0,r8,r0              ;1105
000106  eb070841          ADD      r8,r7,r1,LSL #1       ;1106
00010a  f5084870          ADD      r8,r8,#0xf000         ;1106
00010e  2800              CMP      r0,#0                 ;1134
000110  f8a806c0          STRH     r0,[r8,#0x6c0]        ;1106
000114  dd3f              BLE      |L3.406|
000116  f9b28009          LDRSH    r8,[r2,#9]            ;1136
00011a  4540              CMP      r0,r8                 ;1136
00011c  dd0e              BLE      |L3.316|
00011e  f8d48014          LDR      r8,[r4,#0x14]         ;1147
000122  f1080801          ADD      r8,r8,#1              ;1147
000126  f8c48014          STR      r8,[r4,#0x14]         ;1147
00012a  f9b2e009          LDRSH    lr,[r2,#9]            ;1148
00012e  f8d48018          LDR      r8,[r4,#0x18]         ;1148
000132  eba00e0e          SUB      lr,r0,lr              ;1148
000136  44f0              ADD      r8,r8,lr              ;1148
000138  f8c48018          STR      r8,[r4,#0x18]         ;1148
                  |L3.316|
00013c  4550              CMP      r0,r10                ;1153
00013e  dd21              BLE      |L3.388|
000140  f9948002          LDRSB    r8,[r4,#2]            ;1156
000144  4588              CMP      r8,r1                 ;1156
000146  bfc8              IT       GT                    ;1156
000148  4688              MOVGT    r8,r1                 ;1156
00014a  f8848002          STRB     r8,[r4,#2]            ;1156
00014e  f9948003          LDRSB    r8,[r4,#3]            ;1158
000152  4588              CMP      r8,r1                 ;1158
000154  bfd8              IT       LE                    ;1158
000156  4688              MOVLE    r8,r1                 ;1158
000158  f8848003          STRB     r8,[r4,#3]            ;1158
00015c  f9948000          LDRSB    r8,[r4,#0]            ;1160
000160  4598              CMP      r8,r3                 ;1160
000162  bfc8              IT       GT                    ;1160
000164  4698              MOVGT    r8,r3                 ;1160
000166  f8848000          STRB     r8,[r4,#0]            ;1160
00016a  f9948001          LDRSB    r8,[r4,#1]            ;1162
00016e  4598              CMP      r8,r3                 ;1162
000170  bfd8              IT       LE                    ;1162
000172  4698              MOVLE    r8,r3                 ;1162
000174  f8848001          STRB     r8,[r4,#1]            ;1162
000178  f8d48004          LDR      r8,[r4,#4]            ;1164
00017c  f1080801          ADD      r8,r8,#1              ;1164
000180  f8c48004          STR      r8,[r4,#4]            ;1164
                  |L3.388|
000184  f8d48008          LDR      r8,[r4,#8]            ;1297
000188  4580              CMP      r8,r0                 ;1297
00018a  bfc8              IT       GT                    ;1297
00018c  4640              MOVGT    r0,r8                 ;1297
00018e  60a0              STR      r0,[r4,#8]            ;1297
000190  e01d              B        |L3.462|
                  |L3.402|
000192  e032              B        |L3.506|
                  |L3.404|
000194  e036              B        |L3.516|
                  |L3.406|
000196  f9b2800b          LDRSH    r8,[r2,#0xb]          ;1302
00019a  4540              CMP      r0,r8                 ;1302
00019c  da0e              BGE      |L3.444|
00019e  f8d4801c          LDR      r8,[r4,#0x1c]         ;1314
0001a2  f1080801          ADD      r8,r8,#1              ;1314
0001a6  f8c4801c          STR      r8,[r4,#0x1c]         ;1314
0001aa  f9b2e00b          LDRSH    lr,[r2,#0xb]          ;1315
0001ae  f8d48020          LDR      r8,[r4,#0x20]         ;1315
0001b2  eba00e0e          SUB      lr,r0,lr              ;1315
0001b6  44f0              ADD      r8,r8,lr              ;1315
0001b8  f8c48020          STR      r8,[r4,#0x20]         ;1315
                  |L3.444|
0001bc  f8d48024          LDR      r8,[r4,#0x24]         ;1319
0001c0  4580              CMP      r8,r0                 ;1319
0001c2  dd04              BLE      |L3.462|
0001c4  6260              STR      r0,[r4,#0x24]         ;1321
0001c6  f884b02b          STRB     r11,[r4,#0x2b]        ;1322
0001ca  f884102a          STRB     r1,[r4,#0x2a]         ;1323
                  |L3.462|
0001ce  1c49              ADDS     r1,r1,#1              ;1323
0001d0  2954              CMP      r1,#0x54              ;1323
0001d2  f6ffaf79          BLT      |L3.200|
0001d6  1c5b              ADDS     r3,r3,#1              ;1323
0001d8  2b30              CMP      r3,#0x30              ;1323
0001da  f6ffaf6a          BLT      |L3.178|
0001de  483a              LDR      r0,|L3.712|
0001e0  9900              LDR      r1,[sp,#0]            ;1323
0001e2  e9c05106          STRD     r5,r1,[r0,#0x18]      ;1323
0001e6  6861              LDR      r1,[r4,#4]            ;1355
0001e8  2900              CMP      r1,#0                 ;1355
0001ea  bf18              IT       NE                    ;1355
0001ec  2101              MOVNE    r1,#1                 ;1355
0001ee  68c0              LDR      r0,[r0,#0xc]          ;1355  ; thisInfo
0001f0  f5005080          ADD      r0,r0,#0x1000         ;1355
0001f4  f88010dd          STRB     r1,[r0,#0xdd]         ;1355
0001f8  e72c              B        |L3.84|
                  |L3.506|
;;;1405   					}
;;;1406   				}
;;;1407   				else
;;;1408   				{
;;;1409   					if(sMinDelta > delta )
;;;1410   					{
;;;1411   						sMinDelta = delta;
0001fa  4290              CMP      r0,r2
0001fc  db62              BLT      |L3.708|
                  |L3.510|
;;;1412   					}
;;;1413   				}
;;;1414   
;;;1415   				delta = ABS(delta);
0001fe  2800              CMP      r0,#0
000200  bfb8              IT       LT
000202  4240              RSBLT    r0,r0,#0
                  |L3.516|
;;;1416   				if(delta > DEF_ESD_SCAN_POS_NEG_ACCUM_BLOCK_THD)
000204  281e              CMP      r0,#0x1e
;;;1417   				{
;;;1418   					ulDeltaSum += (uint32_t)delta;
000206  bfc8              IT       GT
000208  4401              ADDGT    r1,r0
00020a  f1b80801          SUBS     r8,r8,#1
00020e  f47faf39          BNE      |L3.132|
000212  1c7f              ADDS     r7,r7,#1              ;1416
000214  f1090954          ADD      r9,r9,#0x54           ;1416
;;;1419   				}
;;;1420   			}
000218  2f0a              CMP      r7,#0xa
00021a  f6ffaf24          BLT      |L3.102|
;;;1421   		}
;;;1422   
;;;1423   		temp_delta->iESDMaxStrength = sMaxDelta;
00021e  62e3              STR      r3,[r4,#0x2c]
;;;1424   		temp_delta->iESDMinStrength = sMinDelta;
000220  6322              STR      r2,[r4,#0x30]
;;;1425   		temp_delta->ulESDDeltaSum = ulDeltaSum;
000222  6361              STR      r1,[r4,#0x34]
000224  2201              MOVS     r2,#1                 ;971
;;;1426   
;;;1427   		if(ulDeltaSum > 0)
000226  b1d1              CBZ      r1,|L3.606|
;;;1428   		{
;;;1429   			gulESD_DletaSum = ulDeltaSum;
000228  4827              LDR      r0,|L3.712|
;;;1430   			if(thisInfo->bIsESD_ReportSkip_ByESDScan == NO)
00022a  6141              STR      r1,[r0,#0x14]  ; gulESD_DletaSum
00022c  68c3              LDR      r3,[r0,#0xc]  ; thisInfo
00022e  f5035380          ADD      r3,r3,#0x1000
000232  f893c2b4          LDRB     r12,[r3,#0x2b4]
000236  f1bc0f00          CMP      r12,#0
00023a  d109              BNE      |L3.592|
;;;1431   			{
;;;1432   				if(ulDeltaSum > DEF_ESD_SCAN_REPORT_SKIP_DELTASUM_THD)
00023c  f6432c98          MOV      r12,#0x3a98
000240  4561              CMP      r1,r12
000242  d905              BLS      |L3.592|
;;;1433   				{
;;;1434   					thisInfo->bIsESD_ReportSkip_ByESDScan = YES;
000244  f88322b4          STRB     r2,[r3,#0x2b4]
;;;1435   					thisInfo->ulESD_ReportSkip_Count_ByESDScan = 0;
000248  f04f0c00          MOV      r12,#0
00024c  f8c3c2b8          STR      r12,[r3,#0x2b8]
                  |L3.592|
;;;1436   				}
;;;1437   			}
;;;1438   		}
;;;1439   #if USED_ESD_RECOVERY_CHECK_ABNORMAL_PEN_DELTA
;;;1440   //		g_ulDebugDeltaSum = ulDeltaSum;		//	debug
;;;1441   
;;;1442   		if(ulDeltaSum > DEF_ESD_CHECK_ABNORMAL_PEN_DELTA_SUM_THD)
000250  f6446320          MOV      r3,#0x4e20
000254  4299              CMP      r1,r3
000256  d902              BLS      |L3.606|
;;;1443   		{
;;;1444   			g_ucAbnormalDeltaCnt++;
000258  7841              LDRB     r1,[r0,#1]  ; g_ucAbnormalDeltaCnt
00025a  1c49              ADDS     r1,r1,#1
00025c  7041              STRB     r1,[r0,#1]
                  |L3.606|
;;;1445   		}
;;;1446   
;;;1447   		if (g_ucAbnormalDeltaCnt >= DEF_ESD_CHECK_ABNORMAL_PEN_DELTA_RESET_THD)
00025e  491a              LDR      r1,|L3.712|
000260  7848              LDRB     r0,[r1,#1]  ; g_ucAbnormalDeltaCnt
000262  2803              CMP      r0,#3
000264  d304              BCC      |L3.624|
;;;1448   		{
;;;1449   			//	reset
;;;1450   			thisInfo->bIsESD_Abnormal_Delta_Reset = YES;
000266  68c8              LDR      r0,[r1,#0xc]  ; thisInfo
000268  f5005080          ADD      r0,r0,#0x1000
00026c  f88022bc          STRB     r2,[r0,#0x2bc]
                  |L3.624|
;;;1451   		}
;;;1452   
;;;1453   		if (g_ucFrameCnt >= DEF_ESD_CHECK_ABNORMAL_PEN_DELTA_FRAME_NUM)
000270  7808              LDRB     r0,[r1,#0]  ; g_ucFrameCnt
000272  280a              CMP      r0,#0xa
;;;1454   		{
;;;1455   			g_ucFrameCnt = 0;
000274  bf2c              ITE      CS
000276  2000              MOVCS    r0,#0
000278  1c40              ADDCC    r0,r0,#1
;;;1456   			g_ucAbnormalDeltaCnt = 0;
;;;1457   		}
;;;1458   		else
;;;1459   		{
;;;1460   			g_ucFrameCnt++;
00027a  7008              STRB     r0,[r1,#0]
00027c  bf28              IT       CS                    ;1456
00027e  7048              STRBCS   r0,[r1,#1]            ;1456
;;;1461   		}
;;;1462   #endif /*USED_ESD_RECOVERY_CHECK_ABNORMAL_PEN_DELTA*/
;;;1463   
;;;1464   	}
;;;1465   #endif /* USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION */
;;;1466   
;;;1467   	if(thisInfo->bTouchExpect && !thisInfo->bLineFilterRepeatCheck)thisInfo->bLineFilterRepeatCheck = 1;
000280  68c8              LDR      r0,[r1,#0xc]  ; thisInfo
000282  f5005380          ADD      r3,r0,#0x1000
000286  f893c0dd          LDRB     r12,[r3,#0xdd]
00028a  f1bc0f00          CMP      r12,#0
00028e  d006              BEQ      |L3.670|
000290  f893c2a7          LDRB     r12,[r3,#0x2a7]
000294  f1bc0f00          CMP      r12,#0
000298  bf08              IT       EQ
00029a  f88322a7          STRBEQ   r2,[r3,#0x2a7]
                  |L3.670|
;;;1468   
;;;1469   #if CPI_TEST_EN
;;;1470   	//LGD Phone noise
;;;1471   	if(thisModeConf->Noise.ucCPITestOn)
;;;1472   	{
;;;1473   		if(!thisInfo->WinCertMode && thisInfo->tCoord.cScreenDebCnt[0]<COORD_HISTORY_NUM){
;;;1474   			for(idx=0;idx<COL_MAX/5;idx++){
;;;1475   				if(RawPartSumCnt[idx] != 0)
;;;1476   					RawPartSum[idx] /= RawPartSumCnt[idx];
;;;1477   				if(idx>0){
;;;1478   					if(abs(RawPartSum[idx] - RawPartSum[idx-1])>1000)
;;;1479   						AbnormalRawCnt = RawPartSumCnt[idx];
;;;1480   				}
;;;1481   				
;;;1482   				if(AbnormalDeltaCntInMux[idx] > 50 || DeltaEdgeCntInMux > (ROW_MAX>>1) )
;;;1483   					thisInfo->UnstableStateFrm = 400;
;;;1484   		//		if(AbnormalDeltaCntInMux[idx] >= 200)
;;;1485   		//			thisInfo->UnstableStateFrm = 400;
;;;1486   			}
;;;1487   			
;;;1488   			if(thisInfo->UnstableStateFrm && wdt_init)
;;;1489   			{
;;;1490   				KICK_DOG();
;;;1491   				Hal_WDT_DeInit();
;;;1492   			}
;;;1493   			
;;;1494   			if(AbnormalRawCnt >= 5){
;;;1495   				memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;1496   				GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;1497   				thisInfo->UnstableStateFrm = 0;
;;;1498   			}
;;;1499   			
;;;1500   			{
;;;1501   				static uint16_t AbnormalFrmCnt = 0;
;;;1502   				static uint8_t ResetDelayCount = 0;
;;;1503   
;;;1504   				if(thisInfo->UnstableStateFrm){
;;;1505   					memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;1506   					if(ResetDelayCount++ > 10){
;;;1507   						GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;1508   					}	
;;;1509   				}
;;;1510   				if(GoToThisState == TOUCH_NORMAL_OPER_RESET_HAL)
;;;1511   				{
;;;1512   					thisInfo->UnstableStateFrm = 0;
;;;1513   					AbnormalFrmCnt = 0;
;;;1514   					ResetDelayCount = 0;
;;;1515   				}
;;;1516   			}
;;;1517   		}
;;;1518   	}
;;;1519   #endif
;;;1520   	
;;;1521   	if(temp_delta->iMaxStrength > thisModeConf->BaseLine.sBlockPosThd)
00029e  68a3              LDR      r3,[r4,#8]
0002a0  6889              LDR      r1,[r1,#8]  ; thisModeConf
0002a2  f9b1c005          LDRSH    r12,[r1,#5]
0002a6  4563              CMP      r3,r12
;;;1522   	{
;;;1523   		thisInfo->bBlockTracking = YES;
0002a8  bfc8              IT       GT
0002aa  7002              STRBGT   r2,[r0,#0]
;;;1524   	}
;;;1525   	
;;;1526   	if(temp_delta->iMinStrength < thisModeConf->BaseLine.sBlockNegThd)
0002ac  6a63              LDR      r3,[r4,#0x24]
0002ae  f9b11007          LDRSH    r1,[r1,#7]
0002b2  428b              CMP      r3,r1
;;;1527   	{
;;;1528   		thisInfo->bBlockTracking = YES;
0002b4  bfb8              IT       LT
0002b6  7002              STRBLT   r2,[r0,#0]
;;;1529   	}
;;;1530   	
;;;1531   #if USED_PEN_MODE_OPERATION
;;;1532   	if(mode == FULL_MODE)
;;;1533   	{
;;;1534   		if(thisInfo->sLFingerMinVal < -30 && 
;;;1535   			((thisInfo->tLFingerMinCell.r-1 <= temp_delta->tMinCellPos.r && temp_delta->tMinCellPos.r <= thisInfo->tLFingerMinCell.r+1) && 
;;;1536   			(thisInfo->tLFingerMinCell.c-1 <= temp_delta->tMinCellPos.c && temp_delta->tMinCellPos.c <= thisInfo->tLFingerMinCell.c+1)))
;;;1537   			temp_delta->iMinStrength = /*pen_touch_data =*/ 0;
;;;1538   		
;;;1539   	//	if(pen_touch_data > 30 || pen_touch_data2 < -70)
;;;1540   	//	{
;;;1541   	//		thisInfo->bLocal_sensing = YES;
;;;1542   	////		hal_Info_SetPenDectionEnable(YES);
;;;1543   	//		algorithm_baseline_calculate_mux_range(pen_pos.r+local_rs, pen_pos.c);
;;;1544   	//	}
;;;1545   	}
;;;1546   	else
;;;1547   	{
;;;1548   		thisInfo->sLFingerMinVal = temp_delta->iMinStrength;
;;;1549   		thisInfo->tLFingerMinCell = temp_delta->tMinCellPos;		
;;;1550   	}
;;;1551   #endif /* USED_PEN_MODE_OPERATION */
;;;1552   
;;;1553   	return thisInfo->bBlockTracking;
0002b8  7800              LDRB     r0,[r0,#0]
;;;1554   }
0002ba  b003              ADD      sp,sp,#0xc
0002bc  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.704|
0002c0  4603              MOV      r3,r0                 ;1404
0002c2  e79f              B        |L3.516|
                  |L3.708|
0002c4  4602              MOV      r2,r0                 ;1411
0002c6  e79a              B        |L3.510|
;;;1555   
                          ENDP

                  |L3.712|
                          DCD      ||.data||
                  |L3.716|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_calculate_delta_idle||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta_idle PROC
;;;1786   
;;;1787   void algorithm_baseline_calculate_delta_idle(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1788   {
;;;1789   	uint32_t r, c;
;;;1790   	int16_t delta;
;;;1791   	uint16_t read_raw_data;
;;;1792   	uint16_t * pIdleBaseImage;
;;;1793   	tIdleDeltaInfo_t * ptTempIdleDeltaInfo;
;;;1794   #if USED_IDLE_FINGER_EVEN_ODD
;;;1795   	int16_t delta2, delta_sum;
;;;1796   	uint16_t * pIdleBaseImage_2;
;;;1797   #endif /* USED_IDLE_FINGER_EVEN_ODD */
;;;1798   
;;;1799   	thisInfo->bBlockTracking = NO;
000004  4d80              LDR      r5,|L4.520|
000006  b083              SUB      sp,sp,#0xc            ;1788
000008  2000              MOVS     r0,#0
00000a  68ec              LDR      r4,[r5,#0xc]  ; thisInfo
;;;1800   	thisInfo->bTouchExpect = NO;
00000c  f24101dd          MOV      r1,#0x10dd
000010  7020              STRB     r0,[r4,#0]            ;1799
000012  5508              STRB     r0,[r1,r4]
;;;1801   
;;;1802   	ptTempIdleDeltaInfo = &thisInfo->tIdleDeltaInfo;
;;;1803   
;;;1804   	ptTempIdleDeltaInfo->sMaxStrength = -4096;
000014  f5045482          ADD      r4,r4,#0x1040
000018  f44f4070          MOV      r0,#0xf000
00001c  8220              STRH     r0,[r4,#0x10]
;;;1805   	ptTempIdleDeltaInfo->sMinStrength = 4096;
00001e  f44f5080          MOV      r0,#0x1000
000022  8260              STRH     r0,[r4,#0x12]
;;;1806   
;;;1807   	pIdleBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
000024  f7fffffe          BL       HAL_GetSensingMode
000028  2101              MOVS     r1,#1
00002a  f7fffffe          BL       HAL_GetBaseImagePointer
00002e  9000              STR      r0,[sp,#0]
000030  f5007052          ADD      r0,r0,#0x348
;;;1808   #if USED_IDLE_FINGER_EVEN_ODD
;;;1809   	pIdleBaseImage_2 = pIdleBaseImage + (LOCAL_FINGER_1MUX_ROW_NUM * COL_MAX);
;;;1810   	for(r=0; r<LOCAL_FINGER_1MUX_ROW_NUM; r++)
;;;1811   	{
;;;1812   		for(c=0; c<COL_MAX; c++)
;;;1813   		{
;;;1814   			read_raw_data = HAL_NI_READ_RAW_IMAGE(r, c);
;;;1815   			delta = (int16_t)read_raw_data - (int16_t)(*(pIdleBaseImage++));
;;;1816   			delta >>= ptModuleModeConf->ucIdleOvrShift;
000034  9001              STR      r0,[sp,#4]
000036  f8d59004          LDR      r9,[r5,#4]  ; ptModuleModeConf
00003a  2100              MOVS     r1,#0                 ;1810
                  |L4.60|
00003c  4684              MOV      r12,r0                ;1812
00003e  ebc100c1          RSB      r0,r1,r1,LSL #3       ;1812
000042  eb000240          ADD      r2,r0,r0,LSL #1       ;1812
000046  4871              LDR      r0,|L4.524|
000048  9d00              LDR      r5,[sp,#0]            ;1812
00004a  eb0000c2          ADD      r0,r0,r2,LSL #3       ;1812
00004e  f5007752          ADD      r7,r0,#0x348          ;1812
000052  f5003693          ADD      r6,r0,#0x12600        ;1812
000056  2300              MOVS     r3,#0                 ;1812
000058  f04f0854          MOV      r8,#0x54              ;1812
                  |L4.92|
00005c  f8302b02          LDRH     r2,[r0],#2            ;1815
000060  f835ab02          LDRH     r10,[r5],#2           ;1815
;;;1817   
;;;1818   			read_raw_data = HAL_NI_READ_RAW_IMAGE(r+LOCAL_FINGER_1MUX_ROW_NUM, c);
;;;1819   			delta2 = (int16_t)read_raw_data - (int16_t)(*(pIdleBaseImage_2++));
000064  f837bb02          LDRH     r11,[r7],#2
000068  eba2020a          SUB      r2,r2,r10             ;1815
00006c  fa0ffa82          SXTH     r10,r2                ;1815
000070  f83ceb02          LDRH     lr,[r12],#2
000074  f8992001          LDRB     r2,[r9,#1]            ;1816
000078  ebab0b0e          SUB      r11,r11,lr
00007c  fa4afa02          ASR      r10,r10,r2            ;1816
000080  fa0ffb8b          SXTH     r11,r11
;;;1820   			delta2 >>= ptModuleModeConf->ucIdleOvrShift;
000084  fa4bf202          ASR      r2,r11,r2
;;;1821   
;;;1822   			delta_sum = delta + delta2;
000088  4452              ADD      r2,r2,r10
00008a  b212              SXTH     r2,r2
;;;1823   			HAL_NI_WRITE_DELTA_IMAGE(r, c, delta_sum);
00008c  f8262b02          STRH     r2,[r6],#2
;;;1824   
;;;1825   			if(ptTempIdleDeltaInfo->sMaxStrength < delta_sum)
000090  f9b4a010          LDRSH    r10,[r4,#0x10]
000094  4592              CMP      r10,r2
000096  da02              BGE      |L4.158|
;;;1826   			{
;;;1827   				ptTempIdleDeltaInfo->sMaxStrength = delta_sum;
000098  8222              STRH     r2,[r4,#0x10]
;;;1828   				ptTempIdleDeltaInfo->ulMaxNodeColIndex = c;
00009a  6023              STR      r3,[r4,#0]
;;;1829   				ptTempIdleDeltaInfo->ulMaxNodeRowIndex = r;
00009c  6061              STR      r1,[r4,#4]
                  |L4.158|
;;;1830   			}
;;;1831   
;;;1832   			if(ptTempIdleDeltaInfo->sMinStrength > delta_sum)
00009e  f9b4a012          LDRSH    r10,[r4,#0x12]
0000a2  4592              CMP      r10,r2
0000a4  dd02              BLE      |L4.172|
;;;1833   			{
;;;1834   				ptTempIdleDeltaInfo->sMinStrength = delta_sum;
0000a6  8262              STRH     r2,[r4,#0x12]
;;;1835   				ptTempIdleDeltaInfo->ulMinNodeColIndex = c;
0000a8  60a3              STR      r3,[r4,#8]
;;;1836   				ptTempIdleDeltaInfo->ulMinNodeRowIndex = r;
0000aa  60e1              STR      r1,[r4,#0xc]
                  |L4.172|
0000ac  1c5b              ADDS     r3,r3,#1
0000ae  f1b80801          SUBS     r8,r8,#1
;;;1837   			}
;;;1838   		}
0000b2  d1d3              BNE      |L4.92|
0000b4  9800              LDR      r0,[sp,#0]
0000b6  1c49              ADDS     r1,r1,#1
0000b8  30a8              ADDS     r0,r0,#0xa8
0000ba  9000              STR      r0,[sp,#0]
0000bc  9801              LDR      r0,[sp,#4]
0000be  30a8              ADDS     r0,r0,#0xa8
0000c0  9001              STR      r0,[sp,#4]
0000c2  2905              CMP      r1,#5
0000c4  d3ba              BCC      |L4.60|
;;;1839   	}
;;;1840   #else /* USED_IDLE_FINGER_EVEN_ODD */
;;;1841   	for(r=0; r<NI_ROW_MAX; r++)
;;;1842   	{
;;;1843   		for(c=0; c<COL_MAX; c++)
;;;1844   		{
;;;1845   			read_raw_data = HAL_NI_READ_RAW_IMAGE(r, c);
;;;1846   			delta = (int16_t)read_raw_data - (int16_t)(*(pIdleBaseImage++));
;;;1847   			delta >>= ptModuleModeConf->ucIdleOvrShift;
;;;1848   
;;;1849   			HAL_NI_WRITE_DELTA_IMAGE(r, c, delta);
;;;1850   
;;;1851   			if(ptTempIdleDeltaInfo->sMaxStrength < delta)
;;;1852   			{
;;;1853   				ptTempIdleDeltaInfo->sMaxStrength = delta;
;;;1854   				ptTempIdleDeltaInfo->ulMaxNodeColIndex = c;
;;;1855   				ptTempIdleDeltaInfo->ulMaxNodeRowIndex = r;
;;;1856   			}
;;;1857   
;;;1858   			if(ptTempIdleDeltaInfo->sMinStrength > delta)
;;;1859   			{
;;;1860   				ptTempIdleDeltaInfo->sMinStrength = delta;
;;;1861   				ptTempIdleDeltaInfo->ulMinNodeColIndex = c;
;;;1862   				ptTempIdleDeltaInfo->ulMinNodeRowIndex = r;
;;;1863   			}
;;;1864   		}
;;;1865   	}
;;;1866   #endif /* USED_IDLE_FINGER_EVEN_ODD */
;;;1867   
;;;1868   	if(ptTempIdleDeltaInfo->sMaxStrength > thisModeConf->BaseLine.sIdle_BlockPosThd ||
0000c6  f8df9140          LDR      r9,|L4.520|
0000ca  f9b41010          LDRSH    r1,[r4,#0x10]
0000ce  f8d93008          LDR      r3,[r9,#8]  ; thisModeConf
0000d2  f9b3000d          LDRSH    r0,[r3,#0xd]
0000d6  4281              CMP      r1,r0
0000d8  dc08              BGT      |L4.236|
0000da  f9b40012          LDRSH    r0,[r4,#0x12]
0000de  f9b3200f          LDRSH    r2,[r3,#0xf]
0000e2  4282              CMP      r2,r0
;;;1869   		ptTempIdleDeltaInfo->sMinStrength < thisModeConf->BaseLine.sIdle_BlockNegThd)
;;;1870   	{
;;;1871   		uint32_t ulCheckNodeColIdx;
;;;1872   		uint32_t ulCheckNodeRowIdx;
;;;1873   		uint32_t ulTotalPosSumTHD;
;;;1874   		uint32_t ulTotalNegSumTHD;
;;;1875   		uint32_t ulCheckNodeSeed;
;;;1876   		if(ABS(ptTempIdleDeltaInfo->sMaxStrength) > ABS(ptTempIdleDeltaInfo->sMinStrength))
;;;1877   		{
;;;1878   			ulCheckNodeColIdx = ptTempIdleDeltaInfo->ulMaxNodeColIndex;
;;;1879   			ulCheckNodeRowIdx = ptTempIdleDeltaInfo->ulMaxNodeRowIndex;
;;;1880   			ulCheckNodeSeed = ABS(ptTempIdleDeltaInfo->sMaxStrength);
;;;1881   		}
;;;1882   		else
;;;1883   		{
;;;1884   			ulCheckNodeColIdx = ptTempIdleDeltaInfo->ulMinNodeColIndex;
;;;1885   			ulCheckNodeRowIdx = ptTempIdleDeltaInfo->ulMinNodeRowIndex;
;;;1886   			ulCheckNodeSeed = ABS(ptTempIdleDeltaInfo->sMinStrength);
;;;1887   		}
;;;1888   		ptTempIdleDeltaInfo->sColumStrengthTotalSum = 0;
;;;1889   
;;;1890   		if(ulCheckNodeSeed > thisModeConf->BaseLine.sIdle_SeedThd)
;;;1891   		{
;;;1892   			if(ulCheckNodeColIdx < COL_MAX-1)
;;;1893   			{
;;;1894   				ptTempIdleDeltaInfo->sColumStrengthTotalSum += HAL_NI_READ_DELTA_IMAGE(ulCheckNodeRowIdx, ulCheckNodeColIdx+1);
;;;1895   			}
;;;1896   
;;;1897   			if(ulCheckNodeColIdx > 0)
;;;1898   			{
;;;1899   				ptTempIdleDeltaInfo->sColumStrengthTotalSum += HAL_NI_READ_DELTA_IMAGE(ulCheckNodeRowIdx, ulCheckNodeColIdx-1);
;;;1900   			}
;;;1901   
;;;1902   			for(r=0; r<NI_ROW_MAX; r++)
;;;1903   			{
;;;1904   				ptTempIdleDeltaInfo->sColumStrengthTotalSum += HAL_NI_READ_DELTA_IMAGE(r, ulCheckNodeColIdx);
;;;1905   			}
;;;1906   
;;;1907   			// Corner Intensity Check!!
;;;1908   			if((ulCheckNodeColIdx == 0 || ulCheckNodeColIdx == COL_MAX-1) && (ulCheckNodeRowIdx == 0 || ulCheckNodeRowIdx == NI_ROW_MAX - 1))
;;;1909   			{
;;;1910   				ulTotalPosSumTHD = thisModeConf->BaseLine.sIdle_PosTotalSumThd >> 2;
;;;1911   				ulTotalNegSumTHD = thisModeConf->BaseLine.sIdle_NegTotalSumThd >> 2;
;;;1912   			}
;;;1913   			else
;;;1914   			{
;;;1915   				ulTotalPosSumTHD = thisModeConf->BaseLine.sIdle_PosTotalSumThd;
;;;1916   				ulTotalNegSumTHD = thisModeConf->BaseLine.sIdle_NegTotalSumThd;
;;;1917   			}
;;;1918   
;;;1919   			if(ptTempIdleDeltaInfo->sColumStrengthTotalSum > ulTotalPosSumTHD ||
;;;1920   				ptTempIdleDeltaInfo->sColumStrengthTotalSum < ulTotalNegSumTHD)
;;;1921   			{
;;;1922   				ptTempIdleDeltaInfo->sPrevMaxStrength = ptTempIdleDeltaInfo->sMaxStrength;
;;;1923   				ptTempIdleDeltaInfo->sPrevMinStrength = ptTempIdleDeltaInfo->sMinStrength;
;;;1924   
;;;1925   	#if !USED_ONLY_IDLE_MODE
;;;1926   				thisInfo->bTouchExpect = YES;
;;;1927   	#endif /* !USED_ONLY_IDLE_MODE */
;;;1928   			}
;;;1929   		}
;;;1930   
;;;1931   		thisInfo->bBlockTracking = YES;
;;;1932   	}
;;;1933   }
0000e4  bfdc              ITT      LE
0000e6  b003              ADDLE    sp,sp,#0xc
0000e8  e8bd8ff0          POPLE    {r4-r11,pc}
                  |L4.236|
0000ec  2900              CMP      r1,#0                 ;1876
0000ee  bfac              ITE      GE                    ;1876
0000f0  4608              MOVGE    r0,r1                 ;1876
0000f2  4248              RSBLT    r0,r1,#0              ;1876
0000f4  f9b42012          LDRSH    r2,[r4,#0x12]         ;1876
0000f8  2a00              CMP      r2,#0                 ;1876
0000fa  bfac              ITE      GE                    ;1876
0000fc  4694              MOVGE    r12,r2                ;1876
0000fe  f1c20c00          RSBLT    r12,r2,#0             ;1876
000102  4584              CMP      r12,r0                ;1876
000104  da69              BGE      |L4.474|
000106  6827              LDR      r7,[r4,#0]            ;1878
000108  f8d48004          LDR      r8,[r4,#4]            ;1879
00010c  2900              CMP      r1,#0                 ;1880
00010e  bfac              ITE      GE                    ;1880
000110  4608              MOVGE    r0,r1                 ;1880
000112  4248              RSBLT    r0,r1,#0              ;1880
                  |L4.276|
000114  f04f0c00          MOV      r12,#0                ;1888
000118  f8a4c018          STRH     r12,[r4,#0x18]        ;1888
00011c  f9b35011          LDRSH    r5,[r3,#0x11]         ;1890
000120  f04f0a01          MOV      r10,#1                ;1807
000124  4285              CMP      r5,r0                 ;1890
000126  d251              BCS      |L4.460|
000128  2f53              CMP      r7,#0x53              ;1892
00012a  d20e              BCS      |L4.330|
00012c  ebc800c8          RSB      r0,r8,r8,LSL #3       ;1894
000130  eb000540          ADD      r5,r0,r0,LSL #1       ;1894
000134  4835              LDR      r0,|L4.524|
000136  eb0000c5          ADD      r0,r0,r5,LSL #3       ;1894
00013a  eb000047          ADD      r0,r0,r7,LSL #1       ;1894
00013e  f5003090          ADD      r0,r0,#0x12000        ;1894
000142  f8b00602          LDRH     r0,[r0,#0x602]        ;1894
000146  4460              ADD      r0,r0,r12             ;1894
000148  8320              STRH     r0,[r4,#0x18]         ;1894
                  |L4.330|
00014a  b187              CBZ      r7,|L4.366|
00014c  ebc800c8          RSB      r0,r8,r8,LSL #3       ;1899
000150  eb000c40          ADD      r12,r0,r0,LSL #1      ;1899
000154  482d              LDR      r0,|L4.524|
000156  eb0000cc          ADD      r0,r0,r12,LSL #3      ;1899
00015a  eb000047          ADD      r0,r0,r7,LSL #1       ;1899
00015e  f5003090          ADD      r0,r0,#0x12000        ;1899
000162  f8b4c018          LDRH     r12,[r4,#0x18]        ;1899
000166  f8b005fe          LDRH     r0,[r0,#0x5fe]        ;1899
00016a  4460              ADD      r0,r0,r12             ;1899
00016c  8320              STRH     r0,[r4,#0x18]         ;1899
                  |L4.366|
00016e  4827              LDR      r0,|L4.524|
000170  f04f0c00          MOV      r12,#0
000174  eb000047          ADD      r0,r0,r7,LSL #1       ;1902
000178  f5003090          ADD      r0,r0,#0x12000        ;1902
00017c  2505              MOVS     r5,#5                 ;1902
00017e  f50060ab          ADD      r0,r0,#0x558          ;1902
                  |L4.386|
000182  8b26              LDRH     r6,[r4,#0x18]         ;1904
000184  f830bfa8          LDRH     r11,[r0,#0xa8]!       ;1904
000188  1e6d              SUBS     r5,r5,#1              ;1904
00018a  445e              ADD      r6,r6,r11             ;1904
00018c  8326              STRH     r6,[r4,#0x18]         ;1904
00018e  f8306fa8          LDRH     r6,[r0,#0xa8]!        ;1904
000192  44b4              ADD      r12,r12,r6            ;1904
000194  fa0ffc8c          SXTH     r12,r12               ;1904
000198  d1f3              BNE      |L4.386|
00019a  8b20              LDRH     r0,[r4,#0x18]
00019c  2f00              CMP      r7,#0                 ;1908
00019e  4460              ADD      r0,r0,r12
0001a0  b205              SXTH     r5,r0
0001a2  8325              STRH     r5,[r4,#0x18]
0001a4  bf18              IT       NE                    ;1908
0001a6  2f53              CMPNE    r7,#0x53              ;1908
0001a8  d01f              BEQ      |L4.490|
0001aa  bf00              NOP                            ;1915
                  |L4.428|
0001ac  f9b3c013          LDRSH    r12,[r3,#0x13]        ;1915
0001b0  f9b30015          LDRSH    r0,[r3,#0x15]         ;1916
                  |L4.436|
0001b4  4565              CMP      r5,r12                ;1919
0001b6  d801              BHI      |L4.444|
0001b8  4285              CMP      r5,r0                 ;1919
0001ba  d207              BCS      |L4.460|
                  |L4.444|
0001bc  82a1              STRH     r1,[r4,#0x14]         ;1922
0001be  82e2              STRH     r2,[r4,#0x16]         ;1923
0001c0  f8d9000c          LDR      r0,[r9,#0xc]          ;1926  ; thisInfo
0001c4  f5005080          ADD      r0,r0,#0x1000         ;1926
0001c8  f880a0dd          STRB     r10,[r0,#0xdd]        ;1926
                  |L4.460|
0001cc  f8d9000c          LDR      r0,[r9,#0xc]          ;1931  ; thisInfo
0001d0  f880a000          STRB     r10,[r0,#0]           ;1931
0001d4  b003              ADD      sp,sp,#0xc
0001d6  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.474|
0001da  68a7              LDR      r7,[r4,#8]            ;1884
0001dc  f8d4800c          LDR      r8,[r4,#0xc]          ;1885
0001e0  2a00              CMP      r2,#0                 ;1886
0001e2  bfac              ITE      GE                    ;1886
0001e4  4610              MOVGE    r0,r2                 ;1886
0001e6  4250              RSBLT    r0,r2,#0              ;1886
0001e8  e794              B        |L4.276|
                  |L4.490|
0001ea  f1b80f00          CMP      r8,#0                 ;1908
0001ee  bf18              IT       NE                    ;1908
0001f0  f1b80f09          CMPNE    r8,#9                 ;1908
0001f4  d1da              BNE      |L4.428|
0001f6  f9b30013          LDRSH    r0,[r3,#0x13]         ;1910
0001fa  ea4f0ca0          ASR      r12,r0,#2             ;1910
0001fe  f9b30015          LDRSH    r0,[r3,#0x15]         ;1911
000202  ea4f00a0          ASR      r0,r0,#2              ;1911
000206  e7d5              B        |L4.436|
;;;1934   #endif /* USED_IDLE_MODE_CONTROL */
                          ENDP

                  |L4.520|
                          DCD      ||.data||
                  |L4.524|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_calculate_mux_range||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_mux_range PROC
;;;855    
;;;856    void algorithm_baseline_calculate_mux_range(int r, int c)
000000  4a12              LDR      r2,|L5.76|
;;;857    {
;;;858    #if 1
;;;859    #define COL_CAL_SIZE						(8)
;;;860    #define COL_CAL_HALF						(COL_CAL_SIZE>>1)
;;;861    #define PEN_LOCAL_ROW_HALF_IDX				(PEN_COORD_ROW_MAX>>1)
;;;862    //	int sub_r = r;
;;;863    
;;;864    	if(r <= PEN_LOCAL_ROW_HALF_IDX)
;;;865    	{
;;;866    		sensingRowStart = 0;
000002  2300              MOVS     r3,#0
000004  2802              CMP      r0,#2                 ;864
000006  bfd8              IT       LE
000008  8013              STRHLE   r3,[r2,#0]
00000a  dd04              BLE      |L5.22|
;;;867    	}
;;;868    	else if(r >= (ROW_MAX-1) - PEN_LOCAL_ROW_HALF_IDX)
00000c  282d              CMP      r0,#0x2d
;;;869    	{
;;;870    		sensingRowStart = ROW_MAX - PEN_COORD_ROW_MAX;
00000e  bfac              ITE      GE
000010  202b              MOVGE    r0,#0x2b
000012  1e80              SUBLT    r0,r0,#2
000014  8010              STRH     r0,[r2,#0]
                  |L5.22|
;;;871    	}
;;;872    	else
;;;873    	{
;;;874    		sensingRowStart = r - PEN_LOCAL_ROW_HALF_IDX;
;;;875    	}
;;;876    
;;;877    //	currentRowStart = sensingRowStart;
;;;878    	if(c<COL_CAL_HALF)
;;;879    	{
;;;880    		thisInfo->tPenInfo.ucCurrentColumnStart = 0;
000016  480e              LDR      r0,|L5.80|
000018  2904              CMP      r1,#4                 ;878
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  f5005080          ADD      r0,r0,#0x1000
000020  bfbc              ITT      LT
000022  f88030e3          STRBLT   r3,[r0,#0xe3]
;;;881    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_CAL_SIZE;
000026  2108              MOVLT    r1,#8
000028  db06              BLT      |L5.56|
;;;882    	}
;;;883    	else if(c+COL_CAL_HALF >= COL_MAX)
00002a  1d0a              ADDS     r2,r1,#4
00002c  2a54              CMP      r2,#0x54
00002e  db06              BLT      |L5.62|
;;;884    	{
;;;885    		thisInfo->tPenInfo.ucCurrentColumnStart = COL_MAX - COL_CAL_SIZE - 1;
000030  214b              MOVS     r1,#0x4b
000032  f88010e3          STRB     r1,[r0,#0xe3]
;;;886    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_MAX - 1;
000036  2153              MOVS     r1,#0x53
                  |L5.56|
000038  f88010e4          STRB     r1,[r0,#0xe4]         ;881
;;;887    	}
;;;888    	else
;;;889    	{
;;;890    		thisInfo->tPenInfo.ucCurrentColumnStart = c-COL_CAL_HALF;
;;;891    		thisInfo->tPenInfo.ucCurrentColumnEnd = c+COL_CAL_HALF;
;;;892    	}
;;;893    #else
;;;894    	int sub_r = r;
;;;895    	
;;;896    	if(currentRowStart == sensingRowStart)
;;;897    	{
;;;898    		sub_r = sub_r-MAX_MUX_HALF;
;;;899    		
;;;900    		if(sub_r < 0)
;;;901    			sensingRowStart = 0;
;;;902    		else if(sub_r >= MUX_MAX_ROW)
;;;903    			sensingRowStart = MUX_MAX_ROW;
;;;904    		else
;;;905    			sensingRowStart = sub_r;
;;;906    	}
;;;907    
;;;908    	if(c<MAX_MUX_HALF)
;;;909    	{
;;;910    		thisInfo->tPenInfo.ucCurrentColumnStart = 0;
;;;911    		thisInfo->tPenInfo.ucCurrentColumnEnd = MAX_MUX_SIZE;
;;;912    	}
;;;913    	else if(c+MAX_MUX_HALF > COL_MAX)
;;;914    	{
;;;915    		thisInfo->tPenInfo.ucCurrentColumnStart = COL_MAX - MAX_MUX_SIZE;
;;;916    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_MAX;
;;;917    	}
;;;918    	else
;;;919    	{
;;;920    		thisInfo->tPenInfo.ucCurrentColumnStart = c-MAX_MUX_HALF;
;;;921    		thisInfo->tPenInfo.ucCurrentColumnEnd = c+MAX_MUX_HALF;
;;;922    	}
;;;923    #endif
;;;924    }
00003c  4770              BX       lr
                  |L5.62|
00003e  1f09              SUBS     r1,r1,#4
000040  f88010e3          STRB     r1,[r0,#0xe3]         ;890
000044  f88020e4          STRB     r2,[r0,#0xe4]         ;891
000048  4770              BX       lr
;;;925    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      sensingRowStart
                  |L5.80|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_init||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init PROC
;;;70     
;;;71     void algorithm_baseline_init(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c0d              LDR      r4,|L6.60|
000008  60a0              STR      r0,[r4,#8]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
;;;72     {
;;;73     	algorithm_baseline_init_param();
;;;74     	thisInfo = algorithm_GetInfo();
00000e  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
000010  f7fffffe          BL       algorithm_GetInfo
;;;75     #if USED_NOISE_HOPPING_FREQ
;;;76     	ptAppInfo = app_GetInfo();
000014  60e0              STR      r0,[r4,#0xc]  ; thisInfo
000016  f7fffffe          BL       app_GetInfo
00001a  6120              STR      r0,[r4,#0x10]  ; ptAppInfo
00001c  4808              LDR      r0,|L6.64|
00001e  6220              STR      r0,[r4,#0x20]  ; g_pFingerBaseImage
000020  4808              LDR      r0,|L6.68|
000022  6260              STR      r0,[r4,#0x24]  ; g_pFingerESDBaseImage
000024  4808              LDR      r0,|L6.72|
000026  62a0              STR      r0,[r4,#0x28]  ; g_pFingerHop1BaseImage
000028  f5a06052          SUB      r0,r0,#0xd20
;;;77     #endif
;;;78     	algorithm_baseline_init_FingerPoint();	
;;;79     	memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
00002c  62e0              STR      r0,[r4,#0x2c]  ; g_pFingerHop1ESDBaseImage
00002e  e8bd4010          POP      {r4,lr}
000032  f44f51fc          MOV      r1,#0x1f80
000036  4805              LDR      r0,|L6.76|
000038  f7ffbffe          B.W      __aeabi_memclr4
;;;80     }
;;;81     
                          ENDP

                  |L6.60|
                          DCD      ||.data||
                  |L6.64|
                          DCD      FullSharedBuff+0x5940
                  |L6.68|
                          DCD      FullSharedBuff+0x2610
                  |L6.72|
                          DCD      FullSharedBuff+0x39c0
                  |L6.76|
                          DCD      FullSharedBuff+0xf6c0

                          AREA ||i.algorithm_baseline_init_FingerPoint||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_FingerPoint PROC
;;;87     
;;;88     void algorithm_baseline_init_FingerPoint(void)
000000  4806              LDR      r0,|L7.28|
;;;89     {
;;;90     #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN)
;;;91     	g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
000002  4905              LDR      r1,|L7.24|
;;;92     	#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;93     		g_pFingerESDBaseImage = HAL_GET_ESD_BASELINE_IMAGE_PTR();
000004  6201              STR      r1,[r0,#0x20]  ; g_pFingerBaseImage
000006  4906              LDR      r1,|L7.32|
;;;94     	#endif
;;;95     	#if USED_NOISE_HOPPING_FREQ
;;;96     		g_pFingerHop1BaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
000008  6241              STR      r1,[r0,#0x24]  ; g_pFingerESDBaseImage
00000a  4906              LDR      r1,|L7.36|
;;;97     		#if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;98     			g_pFingerHop1ESDBaseImage = HAL_GET_HOPP1_ESD_BASELINE_IMAGE_PTR();
00000c  6281              STR      r1,[r0,#0x28]  ; g_pFingerHop1BaseImage
00000e  f5a16152          SUB      r1,r1,#0xd20
000012  62c1              STR      r1,[r0,#0x2c]  ; g_pFingerHop1ESDBaseImage
;;;99     		#endif
;;;100    	#endif /* USED_NOISE_HOPPING_FREQ */
;;;101    
;;;102    #elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN || PEN_PROTOCOL_WGP_UHD_PEN)
;;;103    	g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;104    #else	
;;;105    	if(hal_Info_GetControlActivePenRawDataType() == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;106    	{
;;;107    		g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
;;;108    	}
;;;109    	else
;;;110    	{
;;;111    		g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;112    	}
;;;113    #endif
;;;114    }
000014  4770              BX       lr
;;;115    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      FullSharedBuff+0x5940
                  |L7.28|
                          DCD      ||.data||
                  |L7.32|
                          DCD      FullSharedBuff+0x2610
                  |L7.36|
                          DCD      FullSharedBuff+0x39c0

                          AREA ||i.algorithm_baseline_init_param||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_param PROC
;;;81     
;;;82     void algorithm_baseline_init_param(void)
000000  b510              PUSH     {r4,lr}
;;;83     {
;;;84     	thisModeConf  = algorithm_GetModeConfig();
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c03              LDR      r4,|L8.20|
;;;85     	ptModuleModeConf = module_GetModeConfig();
000008  60a0              STR      r0,[r4,#8]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
00000e  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
;;;86     }
000010  bd10              POP      {r4,pc}
;;;87     
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_tracking_continuous||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous PROC
;;;697    extern int16_t sLFOffsetCol[COL_MAX];
;;;698    void algorithm_baseline_tracking_continuous(uint8_t mode)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;699    {
000004  4606              MOV      r6,r0
;;;700    	uint32_t ulIdx;
;;;701    	uint32_t ulFullIdxNum;
;;;702    	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;703    	static bool_t traking_en = 0;
;;;704    	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
000006  f7fffffe          BL       hal_Info_GetControlLocalFingerOPType
;;;705    	uint16_t * pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;706    #if USED_NOISE_HOPPING_FREQ
;;;707    	uint16_t * pBaseImage;
;;;708    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
00000a  493b              LDR      r1,|L9.248|
00000c  9000              STR      r0,[sp,#0]
00000e  4d39              LDR      r5,|L9.244|
000010  6908              LDR      r0,[r1,#0x10]  ; ptAppInfo
000012  7cc0              LDRB     r0,[r0,#0x13]
000014  2801              CMP      r0,#1
;;;709    	{
;;;710    		pBaseImage = g_pFingerBaseImage;
000016  bf0c              ITE      EQ
000018  6a0c              LDREQ    r4,[r1,#0x20]  ; g_pFingerBaseImage
;;;711    	}
;;;712    	else
;;;713    	{
;;;714    		pBaseImage = g_pFingerHop1BaseImage;
00001a  6a8c              LDRNE    r4,[r1,#0x28]  ; g_pFingerHop1BaseImage
;;;715    	}
;;;716    //	uint16_t * pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;717    #else /* USED_NOISE_HOPPING_FREQ */
;;;718    	uint16_t * pBaseImage = g_pFingerBaseImage;
;;;719    #endif /* USED_NOISE_HOPPING_FREQ */
;;;720    	
;;;721        if(thisInfo->bIsPalm == 0 && thisInfo->bBlockTracking == NO)
00001c  4836              LDR      r0,|L9.248|
00001e  68c1              LDR      r1,[r0,#0xc]  ; thisInfo
000020  f5015080          ADD      r0,r1,#0x1000
000024  f89020da          LDRB     r2,[r0,#0xda]
000028  2a00              CMP      r2,#0
00002a  d157              BNE      |L9.220|
00002c  7809              LDRB     r1,[r1,#0]
00002e  4f32              LDR      r7,|L9.248|
000030  2900              CMP      r1,#0
000032  d153              BNE      |L9.220|
;;;722    	{
;;;723    		if( (mode == FULL_MODE && thisInfo->bLocal_sensing == NO) || 
000034  b116              CBZ      r6,|L9.60|
000036  2e02              CMP      r6,#2
000038  d005              BEQ      |L9.70|
00003a  e04f              B        |L9.220|
                  |L9.60|
00003c  f89000e0          LDRB     r0,[r0,#0xe0]
000040  2800              CMP      r0,#0
000042  d14b              BNE      |L9.220|
000044  e00d              B        |L9.98|
                  |L9.70|
000046  f7fffffe          BL       hal_Info_GetPenDectionEnable
00004a  2800              CMP      r0,#0
00004c  d146              BNE      |L9.220|
00004e  68f8              LDR      r0,[r7,#0xc]  ; thisInfo
000050  7840              LDRB     r0,[r0,#1]
000052  2800              CMP      r0,#0
000054  d142              BNE      |L9.220|
000056  9800              LDR      r0,[sp,#0]
000058  2800              CMP      r0,#0
00005a  bf04              ITT      EQ
00005c  78b8              LDRBEQ   r0,[r7,#2]  ; traking_en
00005e  2800              CMPEQ    r0,#0
000060  d03c              BEQ      |L9.220|
                  |L9.98|
;;;724    		(mode == LOCAL_FINGER_MODE && hal_Info_GetPenDectionEnable() == NO && thisInfo->bBlockTrackingByLocalDelta == NO && 
;;;725    		(eLocalFingerOPType != ACTIVEPEN_TYPE_LOCAL_MS || (eLocalFingerOPType == ACTIVEPEN_TYPE_LOCAL_MS && traking_en))) )
;;;726    		{
;;;727    			alpha = thisModeConf->BaseLine.usIIRCoef;
000062  68b8              LDR      r0,[r7,#8]  ; thisModeConf
;;;728    
;;;729    			//pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;730    			//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;731    			ulFullIdxNum = ROW_MAX * COL_MAX;
;;;732    			for(ulIdx = 0; ulIdx < ulFullIdxNum; ulIdx++)
;;;733    			{
;;;734    				curr_rawdata = (*(pRawImage++));
;;;735    #if USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS
;;;736    				if(curr_rawdata > 0)
;;;737    #endif /* USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS */
;;;738    				{
;;;739    #if !FAST_LF_EN	
;;;740    					curr_rawdata += (sLFOffsetRow[ulIdx / COL_MAX] + sLFOffsetCol[ulIdx % COL_MAX]);
000064  4a25              LDR      r2,|L9.252|
000066  f8df9098          LDR      r9,|L9.256|
00006a  f8b03003          LDRH     r3,[r0,#3]            ;727
00006e  f8dfb094          LDR      r11,|L9.260|
;;;741    #endif
;;;742    					prev_baseline = *(pBaseImage);
;;;743    					curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;744    					*(pBaseImage++) = (uint16_t)curr_baseline;
000072  f8dfa094          LDR      r10,|L9.264|
000076  f04f0000          MOV      r0,#0                 ;732
00007a  f44f617c          MOV      r1,#0xfc0             ;732
00007e  f1c30c64          RSB      r12,r3,#0x64
                  |L9.130|
000082  4f1e              LDR      r7,|L9.252|
000084  f04f0600          MOV      r6,#0
000088  fbe07602          UMLAL    r7,r6,r0,r2           ;740
00008c  ea4f1696          LSR      r6,r6,#6              ;740
000090  4f1a              LDR      r7,|L9.252|
000092  f9398016          LDRSH    r8,[r9,r6,LSL #1]     ;740
000096  f04f0600          MOV      r6,#0                 ;740
00009a  fbe07602          UMLAL    r7,r6,r0,r2           ;740
00009e  ea4f1696          LSR      r6,r6,#6              ;740
0000a2  eba606c6          SUB      r6,r6,r6,LSL #3       ;740
0000a6  eb060646          ADD      r6,r6,r6,LSL #1       ;740
0000aa  eb000686          ADD      r6,r0,r6,LSL #2       ;740
0000ae  f8357b02          LDRH     r7,[r5],#2            ;740
0000b2  f93b6016          LDRSH    r6,[r11,r6,LSL #1]    ;740
0000b6  f1000001          ADD      r0,r0,#1
0000ba  4446              ADD      r6,r6,r8              ;740
0000bc  443e              ADD      r6,r6,r7              ;740
0000be  8827              LDRH     r7,[r4,#0]
0000c0  1e49              SUBS     r1,r1,#1
0000c2  fb07f703          MUL      r7,r7,r3
0000c6  fb0c7606          MLA      r6,r12,r6,r7
0000ca  fb8a7606          SMULL    r7,r6,r10,r6
0000ce  ea4f1766          ASR      r7,r6,#5
0000d2  eba776e6          SUB      r6,r7,r6,ASR #31
0000d6  f8246b02          STRH     r6,[r4],#2
;;;745    				}
;;;746    			}
0000da  d1d2              BNE      |L9.130|
                  |L9.220|
;;;747    		}
;;;748    	}
;;;749    	
;;;750    	if(traking_en==0 && eLocalFingerOPType == ACTIVEPEN_TYPE_LOCAL_MS)traking_en=1;
0000dc  4806              LDR      r0,|L9.248|
0000de  9900              LDR      r1,[sp,#0]
0000e0  7882              LDRB     r2,[r0,#2]  ; traking_en
0000e2  4311              ORRS     r1,r1,r2
0000e4  bf04              ITT      EQ
0000e6  2101              MOVEQ    r1,#1
0000e8  7081              STRBEQ   r1,[r0,#2]
;;;751    	
;;;752    	thisInfo->bBlockTrackingByLocalDelta = NO;  
0000ea  2100              MOVS     r1,#0
0000ec  68c0              LDR      r0,[r0,#0xc]  ; thisInfo
0000ee  7041              STRB     r1,[r0,#1]
;;;753    }
0000f0  e8bd8ff8          POP      {r3-r11,pc}
;;;754    
                          ENDP

                  |L9.244|
                          DCD      FullSharedBuff
                  |L9.248|
                          DCD      ||.data||
                  |L9.252|
                          DCD      0xc30c30c3
                  |L9.256|
                          DCD      sLFOffsetRow
                  |L9.260|
                          DCD      sLFOffsetCol
                  |L9.264|
                          DCD      0x51eb851f

                          AREA ||i.algorithm_baseline_tracking_continuous_idle||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous_idle PROC
;;;1761   
;;;1762   void algorithm_baseline_tracking_continuous_idle(void)
000000  481b              LDR      r0,|L10.112|
;;;1763   {
;;;1764   	uint32_t ulIdx;
;;;1765   	uint32_t ulIdleIdxNum;
;;;1766   	uint16_t * pIdleRawImage;
;;;1767   	uint16_t * pIdleBaseImage;
;;;1768   	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;1769   
;;;1770       if(thisInfo->bBlockTracking == NO)
000002  68c1              LDR      r1,[r0,#0xc]  ; thisInfo
000004  7809              LDRB     r1,[r1,#0]
000006  2900              CMP      r1,#0
;;;1771       {
;;;1772       	ulIdleIdxNum = COL_MAX * NI_ROW_MAX;
;;;1773   		alpha = thisModeConf->BaseLine.usIIRCoef;
;;;1774   
;;;1775   		pIdleRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
;;;1776   		pIdleBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
;;;1777   		for(ulIdx = 0; ulIdx < ulIdleIdxNum; ulIdx++)
;;;1778   		{
;;;1779   			curr_rawdata = (*(pIdleRawImage++)) + sLFOffsetRow[ulIdx / COL_MAX];
;;;1780   			prev_baseline = (*pIdleBaseImage);
;;;1781   			curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;1782   			*(pIdleBaseImage++) = (uint16_t)curr_baseline;
;;;1783   		}
;;;1784       }
;;;1785   }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  e92d47f0          PUSH     {r4-r10,lr}           ;1763
000010  6880              LDR      r0,[r0,#8]            ;1773  ; thisModeConf
000012  4c18              LDR      r4,|L10.116|
000014  f8b05003          LDRH     r5,[r0,#3]            ;1773
000018  f7fffffe          BL       HAL_GetSensingMode
00001c  2101              MOVS     r1,#1                 ;1776
00001e  f7fffffe          BL       HAL_GetBaseImagePointer
000022  4e15              LDR      r6,|L10.120|
000024  4f15              LDR      r7,|L10.124|
000026  f8df8058          LDR      r8,|L10.128|
00002a  2100              MOVS     r1,#0                 ;1777
00002c  f44f7252          MOV      r2,#0x348             ;1777
000030  f1c50c64          RSB      r12,r5,#0x64          ;1782
                  |L10.52|
000034  f8df9040          LDR      r9,|L10.120|
000038  2300              MOVS     r3,#0                 ;1782
00003a  fbe19306          UMLAL    r9,r3,r1,r6           ;1779
00003e  099b              LSRS     r3,r3,#6              ;1779
000040  f8349b02          LDRH     r9,[r4],#2            ;1779
000044  f9373013          LDRSH    r3,[r7,r3,LSL #1]     ;1779
000048  1c49              ADDS     r1,r1,#1              ;1782
00004a  444b              ADD      r3,r3,r9              ;1779
00004c  f8b09000          LDRH     r9,[r0,#0]            ;1782
000050  1e52              SUBS     r2,r2,#1              ;1782
000052  fb09f905          MUL      r9,r9,r5              ;1782
000056  fb0c9303          MLA      r3,r12,r3,r9          ;1782
00005a  fb889303          SMULL    r9,r3,r8,r3           ;1782
00005e  ea4f1963          ASR      r9,r3,#5              ;1782
000062  eba973e3          SUB      r3,r9,r3,ASR #31      ;1782
000066  f8203b02          STRH     r3,[r0],#2            ;1782
00006a  d1e3              BNE      |L10.52|
00006c  e8bd87f0          POP      {r4-r10,pc}
;;;1786   
                          ENDP

                  |L10.112|
                          DCD      ||.data||
                  |L10.116|
                          DCD      FullSharedBuff
                  |L10.120|
                          DCD      0xc30c30c3
                  |L10.124|
                          DCD      sLFOffsetRow
                  |L10.128|
                          DCD      0x51eb851f

                          AREA ||i.algorithm_baseline_tracking_initial||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial PROC
;;;119    #endif
;;;120    void algorithm_baseline_tracking_initial(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;121    {
;;;122    	uint32_t ulFrameNum, ulIdx;
;;;123    	uint32_t ulFullIdxNum;
;;;124    #ifdef SHORT_COMPENSATION
;;;125        int diff;
;;;126        uint16_t raw_diff_thd = 500;
;;;127    #endif
;;;128        uint16_t temp_data, raw_val = 500;
;;;129    #ifdef SHORT_COMPENSATION
;;;130    	uint32_t raw_avg = 0;
;;;131    	short_cnt = 0;
;;;132    	memset(short_pos, 0, sizeof(short_pos));
;;;133    #endif
;;;134    	uint16_t * pRawImage;
;;;135    	uint16_t * pInitRawImage;
;;;136    	uint16_t * pBaseImage;
;;;137    	uint16_t * pInitBaseImage;
;;;138    #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;139    	uint16_t * pESDRawImage;
;;;140    	uint16_t * pInitESDRawImage;
;;;141    	uint16_t * pESDBaseImage;
;;;142    	uint16_t * pInitESDBaseImage;
;;;143    	uint32_t ulESDFullIdxNum;
;;;144    #endif
;;;145    	
;;;146        for (ulFrameNum = 0; ulFrameNum < thisModeConf->BaseLine.ucDiscardFrameNum; ulFrameNum++)
000004  f8df9114          LDR      r9,|L11.284|
000008  2400              MOVS     r4,#0
00000a  f8d90008          LDR      r0,[r9,#8]  ; thisModeConf
00000e  7840              LDRB     r0,[r0,#1]
000010  2800              CMP      r0,#0
000012  d907              BLS      |L11.36|
                  |L11.20|
;;;147    	{
;;;148    		module_wait_full_sample_done();
000014  f7fffffe          BL       module_wait_full_sample_done
000018  f8d90008          LDR      r0,[r9,#8]  ; thisModeConf
00001c  1c64              ADDS     r4,r4,#1
00001e  7840              LDRB     r0,[r0,#1]
000020  42a0              CMP      r0,r4
000022  d8f7              BHI      |L11.20|
                  |L11.36|
;;;149    	}
;;;150    
;;;151    #ifdef MODE_WDT				
;;;152    	KICK_DOG();
000024  f7fffffe          BL       Hal_Kick_DOG
;;;153    #endif
;;;154    
;;;155    #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;156    	{
;;;157    		pInitRawImage = pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;158    		pInitESDRawImage = pESDRawImage = HAL_GET_ESD_RAW_IMAGE_PTR();
;;;159    	#if USED_NOISE_HOPPING_FREQ
;;;160    		if(ptAppInfo->eSelectFreq == FREQ_MAIN)
000028  f8d90010          LDR      r0,[r9,#0x10]  ; ptAppInfo
00002c  4f3c              LDR      r7,|L11.288|
00002e  7cc0              LDRB     r0,[r0,#0x13]
000030  f50756fc          ADD      r6,r7,#0x1f80         ;158
000034  2801              CMP      r0,#1
;;;161    		{
;;;162    			pInitBaseImage = pBaseImage = g_pFingerBaseImage;
000036  bf0c              ITE      EQ
000038  f8d90020          LDREQ    r0,[r9,#0x20]  ; g_pFingerBaseImage
;;;163    			pInitESDBaseImage = pESDBaseImage = g_pFingerESDBaseImage;
;;;164    		}
;;;165    		else
;;;166    		{
;;;167    			pInitBaseImage = pBaseImage = g_pFingerHop1BaseImage ;
00003c  f8d90028          LDRNE    r0,[r9,#0x28]  ; g_pFingerHop1BaseImage
000040  4605              MOV      r5,r0
000042  bf0c              ITE      EQ                    ;163
000044  f8d94024          LDREQ    r4,[r9,#0x24]         ;163  ; g_pFingerESDBaseImage
;;;168    			pInitESDBaseImage = pESDBaseImage = g_pFingerHop1ESDBaseImage ;
000048  f8d9402c          LDRNE    r4,[r9,#0x2c]  ; g_pFingerHop1ESDBaseImage
;;;169    		}
;;;170    	//	pInitBaseImage = pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;171    	#else /* USED_NOISE_HOPPING_FREQ */
;;;172    		pInitBaseImage = pBaseImage = g_pFingerBaseImage;//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;173    		pInitESDBaseImage = pESDBaseImage = g_pFingerESDBaseImage;//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;174    	#endif /* USED_NOISE_HOPPING_FREQ */
;;;175    		memset((void*)pBaseImage, 0x00, sizeof(uint16_t)*(ROW_MAX * COL_MAX));
00004c  f44f51fc          MOV      r1,#0x1f80
000050  f7fffffe          BL       __aeabi_memclr
;;;176    		memset((void*)pESDBaseImage, 0x00, sizeof(uint16_t)*(FINGER_ESD_SCAN_ROW_MAX_NUM * COL_MAX));
000054  f44f61d2          MOV      r1,#0x690
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       __aeabi_memclr
;;;177    		ulFullIdxNum = ROW_MAX * COL_MAX;
;;;178    		ulESDFullIdxNum = FINGER_ESD_SCAN_ROW_MAX_NUM * COL_MAX;
;;;179    		for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
00005e  f8d90008          LDR      r0,[r9,#8]  ; thisModeConf
000062  7880              LDRB     r0,[r0,#2]
000064  f1b00801          SUBS     r8,r0,#1
000068  d32c              BCC      |L11.196|
;;;180    		{
;;;181    			module_wait_full_sample_done();
00006a  bf00              NOP      
                  |L11.108|
00006c  f7fffffe          BL       module_wait_full_sample_done
;;;182    			pRawImage = pInitRawImage;
;;;183    			pBaseImage = pInitBaseImage;
;;;184    			for(ulIdx = ulFullIdxNum; ulIdx--; )
000070  1ea9              SUBS     r1,r5,#2
000072  1eb8              SUBS     r0,r7,#2
000074  f44f62fc          MOV      r2,#0x7e0
                  |L11.120|
;;;185    			{
;;;186    				raw_val = *(pRawImage++);
;;;187    				temp_data = *(pBaseImage) + raw_val;
;;;188    				*(pBaseImage++) = temp_data;
000078  f8313f02          LDRH     r3,[r1,#2]!
00007c  f8b0c002          LDRH     r12,[r0,#2]
000080  1e52              SUBS     r2,r2,#1
000082  4463              ADD      r3,r3,r12
000084  f8213b02          STRH     r3,[r1],#2
000088  f830cf04          LDRH     r12,[r0,#4]!
00008c  880b              LDRH     r3,[r1,#0]
00008e  4463              ADD      r3,r3,r12
000090  800b              STRH     r3,[r1,#0]
000092  d1f1              BNE      |L11.120|
;;;189    	#ifdef SHORT_COMPENSATION
;;;190    				raw_avg += raw_val;
;;;191    	#endif
;;;192    			}
;;;193    
;;;194    			pESDRawImage = pInitESDRawImage;
;;;195    			pESDBaseImage = pInitESDBaseImage;
;;;196    			for(ulIdx = ulESDFullIdxNum; ulIdx--; )
000094  1ea1              SUBS     r1,r4,#2
000096  1eb0              SUBS     r0,r6,#2
000098  f44f72d2          MOV      r2,#0x1a4
                  |L11.156|
;;;197    			{
;;;198    				raw_val = *(pESDRawImage++);
;;;199    				temp_data = *(pESDBaseImage) + raw_val;
;;;200    				*(pESDBaseImage++) = temp_data;
00009c  f8313f02          LDRH     r3,[r1,#2]!
0000a0  f8b0c002          LDRH     r12,[r0,#2]
0000a4  1e52              SUBS     r2,r2,#1
0000a6  4463              ADD      r3,r3,r12
0000a8  f8213b02          STRH     r3,[r1],#2
0000ac  f8303f04          LDRH     r3,[r0,#4]!
0000b0  f8b1c000          LDRH     r12,[r1,#0]
0000b4  4463              ADD      r3,r3,r12
0000b6  800b              STRH     r3,[r1,#0]
0000b8  d1f0              BNE      |L11.156|
;;;201    			}
;;;202    
;;;203    	#ifdef MODE_WDT
;;;204    			KICK_DOG();
0000ba  f7fffffe          BL       Hal_Kick_DOG
0000be  f1b80801          SUBS     r8,r8,#1
0000c2  d2d3              BCS      |L11.108|
                  |L11.196|
;;;205    	#endif
;;;206    		}
;;;207    	}
;;;208    #else
;;;209    	{
;;;210    		pInitRawImage = pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;211    	#if USED_NOISE_HOPPING_FREQ
;;;212    		if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;213    		{
;;;214    			pInitBaseImage = pBaseImage = g_pFingerBaseImage;
;;;215    		}
;;;216    		else
;;;217    		{
;;;218    			pInitBaseImage = pBaseImage = g_pFingerHop1BaseImage ;
;;;219    		}
;;;220    	//	pInitBaseImage = pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;221    	#else /* USED_NOISE_HOPPING_FREQ */
;;;222    		pInitBaseImage = pBaseImage = g_pFingerBaseImage;//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;223    	#endif /* USED_NOISE_HOPPING_FREQ */
;;;224    		memset((void*)pBaseImage, 0x00, sizeof(uint16_t)*(ROW_MAX * COL_MAX));
;;;225    		ulFullIdxNum = ROW_MAX * COL_MAX;
;;;226    
;;;227    		for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
;;;228    		{
;;;229    			module_wait_full_sample_done();
;;;230    			pRawImage = pInitRawImage;
;;;231    			pBaseImage = pInitBaseImage;
;;;232    			for(ulIdx = ulFullIdxNum; ulIdx--; )
;;;233    			{
;;;234    				raw_val = *(pRawImage++);
;;;235    				temp_data = *(pBaseImage) + raw_val;
;;;236    				*(pBaseImage++) = temp_data;
;;;237    	#ifdef SHORT_COMPENSATION
;;;238    				raw_avg += raw_val;
;;;239    	#endif
;;;240    			}
;;;241    
;;;242    	#ifdef MODE_WDT
;;;243    			KICK_DOG();
;;;244    	#endif
;;;245    		}
;;;246    	}
;;;247    #endif
;;;248    
;;;249    #ifdef SHORT_COMPENSATION
;;;250    	raw_avg /= (ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;251    #endif
;;;252    
;;;253    	pBaseImage = pInitBaseImage;
;;;254    	for(ulIdx = ulFullIdxNum; ulIdx--; )
;;;255    	{
;;;256    		temp_data = (*pBaseImage);
;;;257    		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
0000c4  f8d91008          LDR      r1,[r9,#8]  ; thisModeConf
0000c8  1ea8              SUBS     r0,r5,#2              ;254
0000ca  f44f62fc          MOV      r2,#0x7e0             ;254
0000ce  bf00              NOP      
                  |L11.208|
0000d0  f830cf02          LDRH     r12,[r0,#2]!
0000d4  788b              LDRB     r3,[r1,#2]
;;;258    		(*pBaseImage++) = temp_data;
0000d6  1e52              SUBS     r2,r2,#1
0000d8  fbbcf3f3          UDIV     r3,r12,r3             ;257
0000dc  f8203b02          STRH     r3,[r0],#2
0000e0  788b              LDRB     r3,[r1,#2]            ;257
0000e2  f8b0c000          LDRH     r12,[r0,#0]           ;257
0000e6  fbbcf3f3          UDIV     r3,r12,r3             ;257
0000ea  8003              STRH     r3,[r0,#0]
0000ec  d1f0              BNE      |L11.208|
;;;259    #ifdef SHORT_COMPENSATION
;;;260    		diff = raw_avg - temp_data;
;;;261    		if( diff > raw_diff_thd && short_cnt < SHORT_NUM )
;;;262    		{
;;;263    			short_pos[short_cnt].c = c;
;;;264    			short_pos[short_cnt].r = r;
;;;265    			short_cnt++;
;;;266    		}
;;;267    #endif
;;;268    	}
;;;269    
;;;270    #if USED_ESD_RECOVERY_SENSING_WITHOUT_MODULATION
;;;271    	pESDBaseImage = pInitESDBaseImage;
;;;272    	for(ulIdx = ulESDFullIdxNum; ulIdx--; )
0000ee  1ea0              SUBS     r0,r4,#2
0000f0  f44f72d2          MOV      r2,#0x1a4
                  |L11.244|
;;;273    	{
;;;274    		temp_data = (*pESDBaseImage);
;;;275    		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
0000f4  f8303f02          LDRH     r3,[r0,#2]!
0000f8  f891c002          LDRB     r12,[r1,#2]
;;;276    		(*pESDBaseImage++) = temp_data;
0000fc  1e52              SUBS     r2,r2,#1
0000fe  fbb3f3fc          UDIV     r3,r3,r12             ;275
000102  f8203b02          STRH     r3,[r0],#2
000106  f891c002          LDRB     r12,[r1,#2]           ;275
00010a  8803              LDRH     r3,[r0,#0]            ;275
00010c  fbb3f3fc          UDIV     r3,r3,r12             ;275
000110  8003              STRH     r3,[r0,#0]
000112  d1ef              BNE      |L11.244|
;;;277    	}
;;;278    #endif
;;;279    
;;;280    #ifdef MODE_WDT				
;;;281    	KICK_DOG();
000114  e8bd47f0          POP      {r4-r10,lr}
000118  f7ffbffe          B.W      Hal_Kick_DOG
;;;282    #endif
;;;283    }
;;;284    
                          ENDP

                  |L11.284|
                          DCD      ||.data||
                  |L11.288|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_tracking_initial_idle||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial_idle PROC
;;;1668   #if USED_IDLE_MODE_CONTROL
;;;1669   void algorithm_baseline_tracking_initial_idle(bool_t bIsSkip)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1670   {
;;;1671   	uint32_t ulFrameNum, ulIdx;
;;;1672   	uint32_t ulNiIdxNum;
;;;1673   	uint32_t ulSkipFrameNum;
;;;1674   #ifdef SHORT_COMPENSATION
;;;1675       int diff;
;;;1676       uint16_t raw_diff_thd = 500;
;;;1677   #endif
;;;1678       uint16_t temp_data, raw_val = 500;
;;;1679   #ifdef SHORT_COMPENSATION
;;;1680   	uint32_t raw_avg = 0;
;;;1681   	uint32_t raw_avg_Ni_1 = 0,  raw_avg_Ni_2 = 0;
;;;1682   	short_cnt = 0;
;;;1683   	memset(short_pos, 0, sizeof(short_pos));
;;;1684   #endif
;;;1685   	uint16_t * pNiRawImage;
;;;1686   	uint16_t * pNiInitRawImage;
;;;1687   	uint16_t * pNiBaseImage;
;;;1688   	uint16_t * pNiInitBaseImage;
;;;1689   
;;;1690   	if(bIsSkip)
;;;1691   	{
;;;1692   		ulSkipFrameNum = thisModeConf->BaseLine.ucDiscardFrameNum;
000004  4e28              LDR      r6,|L12.168|
000006  2800              CMP      r0,#0                 ;1690
;;;1693   	}
;;;1694   	else
;;;1695   	{
;;;1696   		ulSkipFrameNum = 1;
000008  bf04              ITT      EQ
00000a  2501              MOVEQ    r5,#1
;;;1697   	}
;;;1698   
;;;1699       for(ulFrameNum=0; ulFrameNum<ulSkipFrameNum; ulFrameNum++)
00000c  2400              MOVEQ    r4,#0
00000e  d004              BEQ      |L12.26|
000010  68b0              LDR      r0,[r6,#8]            ;1692  ; thisModeConf
000012  2400              MOVS     r4,#0
000014  7845              LDRB     r5,[r0,#1]            ;1692
000016  2d00              CMP      r5,#0
000018  d904              BLS      |L12.36|
                  |L12.26|
;;;1700       {
;;;1701       	module_wait_NI_sample_done();
00001a  f7fffffe          BL       module_wait_NI_sample_done
00001e  1c64              ADDS     r4,r4,#1
000020  42a5              CMP      r5,r4
000022  d8fa              BHI      |L12.26|
                  |L12.36|
;;;1702       }
;;;1703   
;;;1704   #ifdef MODE_WDT
;;;1705   	KICK_DOG();
000024  f7fffffe          BL       Hal_Kick_DOG
;;;1706   #endif
;;;1707   
;;;1708   	pNiInitRawImage = pNiRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
000028  4d20              LDR      r5,|L12.172|
;;;1709   	pNiInitBaseImage = pNiBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
00002a  f7fffffe          BL       HAL_GetSensingMode
00002e  2101              MOVS     r1,#1
000030  f7fffffe          BL       HAL_GetBaseImagePointer
000034  4604              MOV      r4,r0
;;;1710       memset((void*)pNiBaseImage, 0x00, sizeof(uint16_t)*(NI_ROW_MAX * COL_MAX));
000036  f44f61d2          MOV      r1,#0x690
00003a  f7fffffe          BL       __aeabi_memclr
;;;1711       ulNiIdxNum = NI_ROW_MAX * COL_MAX;
;;;1712   
;;;1713       for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
00003e  68b0              LDR      r0,[r6,#8]  ; thisModeConf
000040  7880              LDRB     r0,[r0,#2]
000042  1e47              SUBS     r7,r0,#1
000044  d318              BCC      |L12.120|
;;;1714       {
;;;1715       	module_wait_NI_sample_done();
000046  bf00              NOP      
                  |L12.72|
000048  f7fffffe          BL       module_wait_NI_sample_done
;;;1716   
;;;1717   		pNiRawImage = pNiInitRawImage;
;;;1718   		pNiBaseImage = pNiInitBaseImage;
;;;1719   		for(ulIdx = ulNiIdxNum; ulIdx--; )
00004c  1ea1              SUBS     r1,r4,#2
00004e  1eaa              SUBS     r2,r5,#2
000050  f44f73d2          MOV      r3,#0x1a4
                  |L12.84|
;;;1720   		{
;;;1721   			raw_val = *(pNiRawImage++);
;;;1722   			temp_data = *(pNiBaseImage) + raw_val;
;;;1723   			*(pNiBaseImage++) = temp_data;
000054  f8310f02          LDRH     r0,[r1,#2]!
000058  f8b2c002          LDRH     r12,[r2,#2]
00005c  1e5b              SUBS     r3,r3,#1
00005e  4460              ADD      r0,r0,r12
000060  f8210b02          STRH     r0,[r1],#2
000064  f832cf04          LDRH     r12,[r2,#4]!
000068  8808              LDRH     r0,[r1,#0]
00006a  4460              ADD      r0,r0,r12
00006c  8008              STRH     r0,[r1,#0]
00006e  d1f1              BNE      |L12.84|
;;;1724   #ifdef SHORT_COMPENSATION
;;;1725   			raw_avg_Ni_1 += raw_val;
;;;1726   #endif
;;;1727   		}
;;;1728   
;;;1729   #ifdef MODE_WDT
;;;1730   		KICK_DOG();
000070  f7fffffe          BL       Hal_Kick_DOG
000074  1e7f              SUBS     r7,r7,#1
000076  d2e7              BCS      |L12.72|
                  |L12.120|
;;;1731   #endif
;;;1732       }
;;;1733   
;;;1734   #ifdef SHORT_COMPENSATION
;;;1735   	raw_avg /= (ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1736   	raw_avg_Ni_1 /= (NI_ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1737   	raw_avg_Ni_2 /= (NI_ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1738   #endif
;;;1739   
;;;1740   	pNiBaseImage = pNiInitBaseImage;
;;;1741   	for(ulIdx = ulNiIdxNum; ulIdx--; )
;;;1742   	{
;;;1743   		temp_data = (*pNiBaseImage);
;;;1744   		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
000078  68b2              LDR      r2,[r6,#8]  ; thisModeConf
00007a  1ea0              SUBS     r0,r4,#2              ;1741
00007c  f44f71d2          MOV      r1,#0x1a4             ;1741
                  |L12.128|
000080  f8303f02          LDRH     r3,[r0,#2]!
000084  f892c002          LDRB     r12,[r2,#2]
;;;1745   		(*pNiBaseImage++) = temp_data;
000088  1e49              SUBS     r1,r1,#1
00008a  fbb3f3fc          UDIV     r3,r3,r12             ;1744
00008e  f8203b02          STRH     r3,[r0],#2
000092  f892c002          LDRB     r12,[r2,#2]           ;1744
000096  8803              LDRH     r3,[r0,#0]            ;1744
000098  fbb3f3fc          UDIV     r3,r3,r12             ;1744
00009c  8003              STRH     r3,[r0,#0]
00009e  d1ef              BNE      |L12.128|
;;;1746   #ifdef SHORT_COMPENSATION
;;;1747   		diff = raw_avg_Ni_1 - temp_data;
;;;1748   		if( diff > raw_diff_thd && short_cnt < SHORT_NUM )
;;;1749   		{
;;;1750   			short_pos[short_cnt].c = c;
;;;1751   			short_pos[short_cnt].r = r;
;;;1752   			short_cnt++;
;;;1753   		}
;;;1754   #endif
;;;1755   	}
;;;1756   
;;;1757   #ifdef MODE_WDT
;;;1758   	KICK_DOG();
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  f7ffbffe          B.W      Hal_Kick_DOG
;;;1759   #endif
;;;1760   }
;;;1761   
                          ENDP

                  |L12.168|
                          DCD      ||.data||
                  |L12.172|
                          DCD      FullSharedBuff

                          AREA ||.data||, DATA, ALIGN=2

                  g_ucFrameCnt
000000  00                DCB      0x00
                  g_ucAbnormalDeltaCnt
000001  00                DCB      0x00
                  traking_en
000002  0000              DCB      0x00,0x00
                  ptModuleModeConf
                          DCD      0x00000000
                  thisModeConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  ptAppInfo
                          DCD      0x00000000
                  gulESD_DletaSum
                          DCD      0x00000000
                  dataCnt
                          DCD      0x00000000
                  AbnormalCnt
                          DCD      0x00000000
                  g_pFingerBaseImage
                          DCD      0x00000000
                  g_pFingerESDBaseImage
                          DCD      0x00000000
                  g_pFingerHop1BaseImage
                          DCD      0x00000000
                  g_pFingerHop1ESDBaseImage
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\App\\Algorithm\\Baseline\\algorithm_baseline.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_5dea3b78____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___20_algorithm_baseline_c_5dea3b78____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_5dea3b78____REVSH|
#line 402
|__asm___20_algorithm_baseline_c_5dea3b78____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_5dea3b78____RRX|
#line 587
|__asm___20_algorithm_baseline_c_5dea3b78____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
