; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\protocol_swip.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\protocol_swip.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\protocol_swip.crf ..\..\Protocol\protocol_swip.c]
                          THUMB

                          AREA ||i.Hal_ClearIntr||, CODE, READONLY, ALIGN=2

                  Hal_ClearIntr PROC
;;;417    
;;;418    void Hal_ClearIntr(void) 
000000  b510              PUSH     {r4,lr}
;;;419    {
;;;420      if(CheckI2CReady() || !protocol_swip_GetEventIntrType()) return;
000002  f7fffffe          BL       CheckI2CReady
000006  2800              CMP      r0,#0
;;;421    	
;;;422    	GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;423    }
000008  bf18              IT       NE
00000a  bd10              POPNE    {r4,pc}
00000c  4805              LDR      r0,|L1.36|
00000e  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000010  7840              LDRB     r0,[r0,#1]
000012  2801              CMP      r0,#1
000014  bf18              IT       NE
000016  bd10              POPNE    {r4,pc}
000018  2101              MOVS     r1,#1                 ;422
00001a  e8bd4010          POP      {r4,lr}               ;422
00001e  2004              MOVS     r0,#4                 ;422
000020  f7ffbffe          B.W      GPIO_Set_DATA
;;;424    
                          ENDP

                  |L1.36|
                          DCD      tProtocolCtrl

                          AREA ||i.Hal_GetIntr||, CODE, READONLY, ALIGN=2

                  Hal_GetIntr PROC
;;;424    
;;;425    bool_t Hal_GetIntr(void)
000000  b510              PUSH     {r4,lr}
;;;426    {
;;;427     
;;;428     if(CheckI2CReady()||!protocol_swip_GetEventIntrType()) return 0;
000002  f7fffffe          BL       CheckI2CReady
000006  b960              CBNZ     r0,|L2.34|
000008  4807              LDR      r0,|L2.40|
00000a  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
00000c  7840              LDRB     r0,[r0,#1]
00000e  2801              CMP      r0,#1
000010  d107              BNE      |L2.34|
;;;429    	
;;;430    	if(IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_LOW)
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       GPIO_Get_IN
000018  b918              CBNZ     r0,|L2.34|
;;;431    	{
;;;432    		GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
00001a  2101              MOVS     r1,#1
00001c  2004              MOVS     r0,#4
00001e  f7fffffe          BL       GPIO_Set_DATA
                  |L2.34|
;;;433    	}
;;;434    
;;;435    	return 0;
000022  2000              MOVS     r0,#0
;;;436    }
000024  bd10              POP      {r4,pc}
;;;437    void Hal_PendIntr(void)
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      tProtocolCtrl

                          AREA ||i.Hal_PendIntr||, CODE, READONLY, ALIGN=2

                  Hal_PendIntr PROC
;;;436    }
;;;437    void Hal_PendIntr(void)
000000  b510              PUSH     {r4,lr}
;;;438    {
;;;439      
;;;440      if(CheckI2CReady() || !protocol_swip_GetEventIntrType()) return;
000002  f7fffffe          BL       CheckI2CReady
000006  2800              CMP      r0,#0
;;;441    	GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;442    }
000008  bf18              IT       NE
00000a  bd10              POPNE    {r4,pc}
00000c  4805              LDR      r0,|L3.36|
00000e  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000010  7840              LDRB     r0,[r0,#1]
000012  2801              CMP      r0,#1
000014  bf18              IT       NE
000016  bd10              POPNE    {r4,pc}
000018  2100              MOVS     r1,#0                 ;441
00001a  e8bd4010          POP      {r4,lr}               ;441
00001e  2004              MOVS     r0,#4                 ;441
000020  f7ffbffe          B.W      GPIO_Set_DATA
;;;443    
                          ENDP

                  |L3.36|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_CheckEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_CheckEventInterrupt PROC
;;;470    
;;;471    bool_t protocol_swip_CheckEventInterrupt(void)
000000  480d              LDR      r0,|L4.56|
;;;472    {
000002  b510              PUSH     {r4,lr}
;;;473        thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
000004  6841              LDR      r1,[r0,#4]  ; tProtocolCtrl
000006  784a              LDRB     r2,[r1,#1]
000008  490c              LDR      r1,|L4.60|
00000a  6849              LDR      r1,[r1,#4]  ; thisInfo
00000c  700a              STRB     r2,[r1,#0]
;;;474        switch( thisInfo->eEventTriggerType )
00000e  b2d1              UXTB     r1,r2
000010  2901              CMP      r1,#1
000012  d002              BEQ      |L4.26|
000014  2902              CMP      r1,#2
000016  d006              BEQ      |L4.38|
000018  e00b              B        |L4.50|
                  |L4.26|
;;;475        {
;;;476        case ETT_INTERRUPT:
;;;477            if(IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_HIGH )	return YES;
00001a  2004              MOVS     r0,#4
00001c  f7fffffe          BL       GPIO_Get_IN
000020  2801              CMP      r0,#1
000022  d106              BNE      |L4.50|
;;;478    		else									return NO;
;;;479    //        break; // NOTE : warning제거
;;;480        case ETT_REGISTER:
;;;481            if(tProtocolCtrl.getter->bEventReady == NO) 	return YES;
;;;482    		else											return NO;
;;;483    //        break; // NOTE : warning제거
;;;484        default:
;;;485        	break;
;;;486        }
;;;487    
;;;488        return NO; // NOTE : warning제거
;;;489    }
000024  bd10              POP      {r4,pc}
                  |L4.38|
000026  6800              LDR      r0,[r0,#0]            ;481  ; tProtocolCtrl
000028  7840              LDRB     r0,[r0,#1]            ;481
00002a  2800              CMP      r0,#0                 ;481
00002c  bf04              ITT      EQ                    ;481
00002e  2001              MOVEQ    r0,#1                 ;481
000030  bd10              POPEQ    {r4,pc}
                  |L4.50|
000032  2000              MOVS     r0,#0                 ;488
000034  bd10              POP      {r4,pc}
;;;490    
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      tProtocolCtrl
                  |L4.60|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_ClearEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_ClearEventInterrupt PROC
;;;457    
;;;458    void protocol_swip_ClearEventInterrupt(void)
000000  480e              LDR      r0,|L5.60|
;;;459    {
000002  b510              PUSH     {r4,lr}
;;;460        switch( thisInfo->eEventTriggerType )
000004  6840              LDR      r0,[r0,#4]  ; thisInfo
000006  4c0e              LDR      r4,|L5.64|
000008  7801              LDRB     r1,[r0,#0]
00000a  2000              MOVS     r0,#0
00000c  2901              CMP      r1,#1
00000e  d004              BEQ      |L5.26|
000010  2902              CMP      r1,#2
;;;461        {
;;;462        case ETT_INTERRUPT:
;;;463            Hal_ClearIntr();
;;;464            break;
;;;465        case ETT_REGISTER:
;;;466            tProtocolCtrl.getter->bEventReady = NO;
000012  bf04              ITT      EQ
000014  6821              LDREQ    r1,[r4,#0]  ; tProtocolCtrl
000016  7048              STRBEQ   r0,[r1,#1]
;;;467            break;
;;;468        }
;;;469    }
000018  bd10              POP      {r4,pc}
                  |L5.26|
00001a  f7fffffe          BL       CheckI2CReady
00001e  2800              CMP      r0,#0
000020  bf18              IT       NE
000022  bd10              POPNE    {r4,pc}
000024  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
000026  7840              LDRB     r0,[r0,#1]
000028  2801              CMP      r0,#1
00002a  bf18              IT       NE
00002c  bd10              POPNE    {r4,pc}
00002e  2101              MOVS     r1,#1
000030  e8bd4010          POP      {r4,lr}
000034  2004              MOVS     r0,#4
000036  f7ffbffe          B.W      GPIO_Set_DATA
;;;470    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      ||.data||
                  |L5.64|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_ClearInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_ClearInterrupt PROC
;;;617    
;;;618    void protocol_swip_ClearInterrupt(uint16_t _addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;619    {
;;;620    	uint16_t SWIP_REG_ADDR;
;;;621    	
;;;622    	if(thisInfo->eEventTriggerType == ETT_REGISTER){
000004  4a26              LDR      r2,|L6.160|
000006  f8d2c004          LDR      r12,[r2,#4]  ; thisInfo
00000a  f89c1000          LDRB     r1,[r12,#0]
00000e  2902              CMP      r1,#2
;;;623    		SWIP_REG_ADDR = SWIP_REG_ADDR_EVENT_PACKET_INFO;
000010  bf0c              ITE      EQ
000012  f44f7304          MOVEQ    r3,#0x210
;;;624    	}
;;;625    	else{
;;;626    		SWIP_REG_ADDR = SWIP_REG_ADDR_EVENT_PACKET_CONTENT;
000016  f2402311          MOVNE    r3,#0x211
;;;627    	}
;;;628    
;;;629        if( _addr == SWIP_REG_ADDR_CTRL_GETTER + offsetof(tProtocolGetter_t, eReadyStatus) )
;;;630        {
;;;631            if( tProtocolCtrl.getter->eReadyStatus != RS_NONE )
00001a  4c22              LDR      r4,|L6.164|
00001c  f5b06fc0          CMP      r0,#0x600             ;629
000020  6821              LDR      r1,[r4,#0]
000022  d024              BEQ      |L6.110|
000024  332f              ADDS     r3,r3,#0x2f           ;619
;;;632                tProtocolCtrl.getter->eReadyStatus = RS_NONE;
;;;633        }
;;;634        //Touch packet의 마지막 data를 읽어갈 때,
;;;635        else if( _addr == SWIP_REG_ADDR + TEST_DEVICE_READ_PACKED - 1 )
000026  4298              CMP      r0,r3
;;;636        {
;;;637    #if (SWIP_QUEUE_MODE)
;;;638    		if(sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear) // Not Queue Empty
;;;639    		{
;;;640    			sptAlgorithmInfo->QueueFront++;
;;;641    			sptAlgorithmInfo->QueueFront = (sptAlgorithmInfo->QueueFront) % SWIP_QUEUE_SIZE;
;;;642    		}
;;;643    #endif
;;;644            protocol_swip_ClearEventInterrupt();
;;;645        }
;;;646    }
000028  bf18              IT       NE
00002a  e8bd81f0          POPNE    {r4-r8,pc}
00002e  6890              LDR      r0,[r2,#8]            ;638  ; sptAlgorithmInfo
000030  2500              MOVS     r5,#0                 ;638
000032  f5005280          ADD      r2,r0,#0x1000         ;638
000036  f892002f          LDRB     r0,[r2,#0x2f]         ;638
00003a  f892302e          LDRB     r3,[r2,#0x2e]         ;638
00003e  4298              CMP      r0,r3                 ;638
000040  d00c              BEQ      |L6.92|
000042  1c40              ADDS     r0,r0,#1              ;638
000044  4f18              LDR      r7,|L6.168|
000046  b2c3              UXTB     r3,r0                 ;640
000048  463e              MOV      r6,r7                 ;641
00004a  2000              MOVS     r0,#0                 ;641
00004c  fbe36007          UMLAL    r6,r0,r3,r7           ;641
000050  0840              LSRS     r0,r0,#1              ;641
000052  eba000c0          SUB      r0,r0,r0,LSL #3       ;641
000056  4418              ADD      r0,r0,r3              ;641
000058  f882002f          STRB     r0,[r2,#0x2f]         ;641
                  |L6.92|
00005c  f89c0000          LDRB     r0,[r12,#0]           ;641
000060  2801              CMP      r0,#1                 ;641
000062  d00b              BEQ      |L6.124|
000064  2802              CMP      r0,#2                 ;641
000066  bf08              IT       EQ                    ;641
000068  704d              STRBEQ   r5,[r1,#1]            ;641
00006a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.110|
00006e  7808              LDRB     r0,[r1,#0]            ;631
000070  2805              CMP      r0,#5                 ;631
000072  bf1c              ITT      NE                    ;632
000074  2005              MOVNE    r0,#5                 ;632
000076  7008              STRBNE   r0,[r1,#0]            ;632
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L6.124|
00007c  f7fffffe          BL       CheckI2CReady
000080  2800              CMP      r0,#0
000082  bf18              IT       NE
000084  e8bd81f0          POPNE    {r4-r8,pc}
000088  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
00008a  7840              LDRB     r0,[r0,#1]
00008c  2801              CMP      r0,#1
00008e  bf18              IT       NE
000090  e8bd81f0          POPNE    {r4-r8,pc}
000094  2101              MOVS     r1,#1
000096  e8bd41f0          POP      {r4-r8,lr}
00009a  2004              MOVS     r0,#4
00009c  f7ffbffe          B.W      GPIO_Set_DATA
;;;647    
                          ENDP

                  |L6.160|
                          DCD      ||.data||
                  |L6.164|
                          DCD      tProtocolCtrl
                  |L6.168|
                          DCD      0x49249249

                          AREA ||i.protocol_swip_GetABSAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetABSAvrCount PROC
;;;370    // Protocol for Test Mode
;;;371    uint8_t protocol_swip_GetABSAvrCount(void)
000000  4801              LDR      r0,|L7.8|
;;;372    {
;;;373    	return tSWIPTest.tTest.ptCtrl->ucABSAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7840              LDRB     r0,[r0,#1]
;;;374    }
000006  4770              BX       lr
;;;375    
                          ENDP

                  |L7.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetDCABSAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetDCABSAvrCount PROC
;;;375    
;;;376    uint8_t protocol_swip_GetDCABSAvrCount(void)
000000  4801              LDR      r0,|L8.8|
;;;377    {
;;;378    	return tSWIPTest.tTest.ptCtrl->ucDCABSAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7880              LDRB     r0,[r0,#2]
;;;379    }
000006  4770              BX       lr
;;;380    
                          ENDP

                  |L8.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetDFUP_Ready||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetDFUP_Ready PROC
;;;353    
;;;354    bool_t protocol_swip_GetDFUP_Ready(void)
000000  4801              LDR      r0,|L9.8|
;;;355    {
;;;356    	return tProtocolCtrl.setter->bDFUP_Ready;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7cc0              LDRB     r0,[r0,#0x13]
;;;357    }
000006  4770              BX       lr
;;;358    
                          ENDP

                  |L9.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetEnableBulkLog||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetEnableBulkLog PROC
;;;343    
;;;344    bool_t protocol_swip_GetEnableBulkLog(void)
000000  4801              LDR      r0,|L10.8|
;;;345    {
;;;346    	return tProtocolCtrl.setter->bEnableBulkLog;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7c80              LDRB     r0,[r0,#0x12]
;;;347    }
000006  4770              BX       lr
;;;348    
                          ENDP

                  |L10.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetEventIntrType||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetEventIntrType PROC
;;;338    
;;;339    bool_t protocol_swip_GetEventIntrType(void)
000000  4803              LDR      r0,|L11.16|
;;;340    {
;;;341       return (tProtocolCtrl.setter->eEventTriggerType == ETT_INTERRUPT) ? YES : NO;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7840              LDRB     r0,[r0,#1]
000006  2801              CMP      r0,#1
000008  bf18              IT       NE
00000a  2000              MOVNE    r0,#0
;;;342    }
00000c  4770              BX       lr
;;;343    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetJitterAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetJitterAvrCount PROC
;;;390    
;;;391    uint8_t protocol_swip_GetJitterAvrCount(void)
000000  4801              LDR      r0,|L12.8|
;;;392    {
;;;393    	return tSWIPTest.tTest.ptCtrl->ucJitterAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7940              LDRB     r0,[r0,#5]
;;;394    }
000006  4770              BX       lr
;;;395    
                          ENDP

                  |L12.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetJitterCheckCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetJitterCheckCount PROC
;;;395    
;;;396    uint8_t protocol_swip_GetJitterCheckCount(void)
000000  4801              LDR      r0,|L13.8|
;;;397    {
;;;398    	return tSWIPTest.tTest.ptCtrl->ucJitterCheckCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7980              LDRB     r0,[r0,#6]
;;;399    }
000006  4770              BX       lr
;;;400    
                          ENDP

                  |L13.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetMappedPointer||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetMappedPointer PROC
;;;572    
;;;573    uint8_t* protocol_swip_GetMappedPointer(uint16_t _addr)
000000  0a01              LSRS     r1,r0,#8
;;;574    {
;;;575        int i;
;;;576        uint8_t maddr = MSB(_addr), laddr = LSB(_addr);
000002  b2c2              UXTB     r2,r0
;;;577        //TODO: remove it! 임시로 기존 프로토콜 사용하기 위해서 작업해 두었습니다.
;;;578        if( _addr >= SWIP_REG_ADDR_RESERVED )
000004  f5b04f70          CMP      r0,#0xf000
000008  d22f              BCS      |L14.106|
;;;579        {
;;;580            return (uint8_t*)0;
;;;581        }
;;;582    
;;;583        if( maddr < GET_ARRAY_(vtMRmiMap) )
00000a  2915              CMP      r1,#0x15
00000c  d217              BCS      |L14.62|
;;;584        {
;;;585    		const tSWIPSubsetInfo_t* info = vtMRmiMap[maddr];
00000e  4818              LDR      r0,|L14.112|
000010  f8501021          LDR      r1,[r0,r1,LSL #2]
;;;586    		if(info != NULL)
000014  b349              CBZ      r1,|L14.106|
;;;587    		{
;;;588    			for( i=info->iSize; i--; )
000016  688b              LDR      r3,[r1,#8]
000018  1e58              SUBS     r0,r3,#1
;;;589    			{
;;;590    				int start_addr = info->vucStartLAddr[i];
00001a  bf28              IT       CS
00001c  f8d1c004          LDRCS    r12,[r1,#4]
000020  d323              BCC      |L14.106|
000022  bf00              NOP      
                  |L14.36|
000024  f81c3000          LDRB     r3,[r12,r0]
;;;591    				if( laddr >= start_addr )
000028  429a              CMP      r2,r3
00002a  db05              BLT      |L14.56|
;;;592    				{
;;;593    					return info->ppucData[i] + laddr - start_addr;
00002c  6809              LDR      r1,[r1,#0]
00002e  f8510020          LDR      r0,[r1,r0,LSL #2]
000032  4410              ADD      r0,r0,r2
000034  1ac0              SUBS     r0,r0,r3
;;;594    				}
;;;595    			}
;;;596    		}
;;;597    		else
;;;598    		{
;;;599    			info = NULL;
;;;600    		}
;;;601        }
;;;602        else //16K buffers.
;;;603        {
;;;604            for( i=tSWIPBufferInfo.iSize; i--; )
;;;605            {
;;;606                int start_addr = tSWIPBufferInfo.vusStartAddr[i];
;;;607    
;;;608                if( _addr >= start_addr)
;;;609                {
;;;610                    return tSWIPBufferInfo.ppucBuffer[i] + _addr - start_addr;
;;;611                }
;;;612            }
;;;613        }
;;;614    
;;;615        return (uint8_t*)NULL;
;;;616    }
000036  4770              BX       lr
                  |L14.56|
000038  1e40              SUBS     r0,r0,#1
00003a  d2f3              BCS      |L14.36|
00003c  e015              B        |L14.106|
                  |L14.62|
00003e  f8dfc034          LDR      r12,|L14.116|
000042  f8dc2008          LDR      r2,[r12,#8]           ;604  ; tSWIPBufferInfo
000046  1e51              SUBS     r1,r2,#1              ;604
000048  bf28              IT       CS                    ;606
00004a  f8dc3004          LDRCS    r3,[r12,#4]           ;606
00004e  d30c              BCC      |L14.106|
                  |L14.80|
000050  f8332011          LDRH     r2,[r3,r1,LSL #1]     ;606
000054  4290              CMP      r0,r2                 ;608
000056  db06              BLT      |L14.102|
000058  f8dc3000          LDR      r3,[r12,#0]           ;610  ; tSWIPBufferInfo
00005c  f8531021          LDR      r1,[r3,r1,LSL #2]     ;610
000060  4408              ADD      r0,r0,r1              ;610
000062  1a80              SUBS     r0,r0,r2              ;610
000064  4770              BX       lr
                  |L14.102|
000066  1e49              SUBS     r1,r1,#1
000068  d2f2              BCS      |L14.80|
                  |L14.106|
00006a  2000              MOVS     r0,#0                 ;615
00006c  4770              BX       lr
;;;617    
                          ENDP

00006e  0000              DCW      0x0000
                  |L14.112|
                          DCD      ||.data||+0x48
                  |L14.116|
                          DCD      ||.data||+0x3c

                          AREA ||i.protocol_swip_GetMode||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetMode PROC
;;;328    
;;;329    eProtocolMode_t protocol_swip_GetMode(void)
000000  4801              LDR      r0,|L15.8|
;;;330    {
;;;331        return tProtocolCtrl.setter->eMode;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7800              LDRB     r0,[r0,#0]
;;;332    }
000006  4770              BX       lr
;;;333    
                          ENDP

                  |L15.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetOpenAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetOpenAvrCount PROC
;;;380    
;;;381    uint8_t protocol_swip_GetOpenAvrCount(void)
000000  4801              LDR      r0,|L16.8|
;;;382    {
;;;383    	return tSWIPTest.tTest.ptCtrl->ucOpenAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  78c0              LDRB     r0,[r0,#3]
;;;384    }
000006  4770              BX       lr
;;;385    
                          ENDP

                  |L16.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetPacketFormatId||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetPacketFormatId PROC
;;;558    
;;;559    eSWIPPacketFormatId_t protocol_swip_GetPacketFormatId(void)
000000  4801              LDR      r0,|L17.8|
;;;560    {
;;;561        return thisCommonConf->ePacketFormatId;
000002  6800              LDR      r0,[r0,#0]  ; thisCommonConf
000004  8800              LDRH     r0,[r0,#0]
;;;562    }
000006  4770              BX       lr
;;;563    
                          ENDP

                  |L17.8|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_GetShortAvrCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetShortAvrCount PROC
;;;385    
;;;386    uint8_t protocol_swip_GetShortAvrCount(void)
000000  4801              LDR      r0,|L18.8|
;;;387    {
;;;388    	return tSWIPTest.tTest.ptCtrl->ucShortAvrCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7900              LDRB     r0,[r0,#4]
;;;389    }
000006  4770              BX       lr
;;;390    
                          ENDP

                  |L18.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_GetTestType||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetTestType PROC
;;;400    
;;;401    eSWIPTestType_t protocol_swip_GetTestType(void)
000000  4801              LDR      r0,|L19.8|
;;;402    {
;;;403        return tSWIPTest.tTest.ptCtrl->eTestType;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7800              LDRB     r0,[r0,#0]
;;;404    }
000006  4770              BX       lr
;;;405    
                          ENDP

                  |L19.8|
                          DCD      ||.data||+0x30

                          AREA ||i.protocol_swip_Init||, CODE, READONLY, ALIGN=2

                  protocol_swip_Init PROC
;;;784    
;;;785    void protocol_swip_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;786    {
;;;787    	volatile unsigned long  BOOT_ADDR = 0x00001FFAUL;
000002  f64170fa          MOV      r0,#0x1ffa
;;;788    
;;;789    	thisCommonConf = protocol_GetCommonConfig();
000006  9000              STR      r0,[sp,#0]
000008  f7fffffe          BL       protocol_GetCommonConfig
00000c  4c1f              LDR      r4,|L20.140|
;;;790    	thisInfo = protocol_GetInfo();
00000e  6020              STR      r0,[r4,#0]  ; thisCommonConf
000010  f7fffffe          BL       protocol_GetInfo
;;;791    	sptAlgorithmInfo = algorithm_GetInfo();
000014  6060              STR      r0,[r4,#4]  ; thisInfo
000016  f7fffffe          BL       algorithm_GetInfo
;;;792    
;;;793    	tSWIPInfo.ptPanel->usXResolution = I2C_X_RESOLUTION;//32768;
00001a  60a0              STR      r0,[r4,#8]  ; sptAlgorithmInfo
00001c  f1040014          ADD      r0,r4,#0x14
000020  f44f4100          MOV      r1,#0x8000
000024  6802              LDR      r2,[r0,#0]  ; tSWIPInfo
;;;794    	tSWIPInfo.ptPanel->usYResolution = I2C_Y_RESOLUTION;//32768;
;;;795    
;;;796    	tSWIPInfo.ptPanel->ucXNode_ = COL_MAX;
;;;797    	tSWIPInfo.ptPanel->ucYNode_ = ROW_MAX;
;;;798    #ifdef _USE_WITH_BOOT_
;;;799        tSWIPInfo.ptVersion->bcdBootVer = (*(uint16_t *)(0x2FF4));
;;;800    #else
;;;801        tSWIPInfo.ptVersion->bcdBootVer = BOOT_VERSION;
;;;802    #endif
;;;803        tSWIPInfo.ptVersion->bcdAppVer = APP_VERSION;
;;;804        tSWIPInfo.ptVersion->bcdParamVer = CONFIG_VERSION;
;;;805    
;;;806    #ifdef _USE_WITH_BOOT_
;;;807    	tSWIPInfo.ptIntegrity->ulBootCRC = (*(volatile unsigned short *)(0x2FFC));
;;;808    	tSWIPInfo.ptIntegrity->ulAppCRC = (*(volatile unsigned short *)(0x1FFFC));
;;;809    #else
;;;810    	tSWIPInfo.ptIntegrity->ulBootCRC = 0xFFFF;//SYSCFG_SPI_BOOT_crc_code_read();
;;;811    	tSWIPInfo.ptIntegrity->ulAppCRC = 0xFFFF;//SYSCFG_SPI_APP_crc_code_read();
;;;812    #endif /* _USE_WITH_BOOT_ */
;;;813    
;;;814    #if (USED_MODULE_DEF == MODULE_DEF_S_1)
;;;815    	protocol_swip_UpdatePTInspectionGetInfo();
;;;816    #endif /* (USED_MODULE_DEF == MODULE_DEF_S_1) */
;;;817    
;;;818    	tSWIPInfo.ptIntegrity->ulParamCRC = 0x00000000;
;;;819    	tSWIPInfo.ptExtra->usPWMTxFrequecy = PWMDRV_USED_FREQUENCY;
;;;820    
;;;821    	tSWIPEvent.ptEventFormat->ePacketFormatId = thisCommonConf->ePacketFormatId;
;;;822    
;;;823    	int iItemSize = 0x06;
;;;824    	int iTouchEventPacketSize  = 0x0042;
000026  2542              MOVS     r5,#0x42
000028  8211              STRH     r1,[r2,#0x10]         ;793
00002a  6802              LDR      r2,[r0,#0]            ;794  ; tSWIPInfo
00002c  8251              STRH     r1,[r2,#0x12]         ;794
00002e  6802              LDR      r2,[r0,#0]            ;796  ; tSWIPInfo
000030  2150              MOVS     r1,#0x50              ;796
000032  7511              STRB     r1,[r2,#0x14]         ;796
000034  6803              LDR      r3,[r0,#0]            ;797  ; tSWIPInfo
000036  222d              MOVS     r2,#0x2d              ;797
000038  755a              STRB     r2,[r3,#0x15]         ;797
00003a  6843              LDR      r3,[r0,#4]            ;801  ; tSWIPInfo
00003c  f2401201          MOV      r2,#0x101             ;801
000040  801a              STRH     r2,[r3,#0]            ;801
000042  6843              LDR      r3,[r0,#4]            ;803  ; tSWIPInfo
000044  2201              MOVS     r2,#1                 ;803
000046  805a              STRH     r2,[r3,#2]            ;803
000048  6843              LDR      r3,[r0,#4]            ;804  ; tSWIPInfo
00004a  809a              STRH     r2,[r3,#4]            ;804
00004c  68c3              LDR      r3,[r0,#0xc]          ;810  ; tSWIPInfo
00004e  f64f72ff          MOV      r2,#0xffff            ;810
000052  601a              STR      r2,[r3,#0]            ;810
000054  68c3              LDR      r3,[r0,#0xc]          ;811  ; tSWIPInfo
000056  605a              STR      r2,[r3,#4]            ;811
000058  68c3              LDR      r3,[r0,#0xc]          ;818  ; tSWIPInfo
00005a  2200              MOVS     r2,#0                 ;818
00005c  609a              STR      r2,[r3,#8]            ;818
00005e  6940              LDR      r0,[r0,#0x14]         ;819  ; tSWIPInfo
000060  8001              STRH     r1,[r0,#0]            ;819
000062  6820              LDR      r0,[r4,#0]            ;821  ; thisCommonConf
000064  340c              ADDS     r4,r4,#0xc            ;821
000066  6821              LDR      r1,[r4,#0]            ;821  ; tSWIPEvent
000068  8800              LDRH     r0,[r0,#0]            ;821
00006a  8088              STRH     r0,[r1,#4]            ;821
;;;825    
;;;826    	tSWIPEvent.ptEventFormat->ucTouchPacketItemSize = iItemSize;
00006c  6821              LDR      r1,[r4,#0]  ; tSWIPEvent
00006e  2006              MOVS     r0,#6
000070  7188              STRB     r0,[r1,#6]
;;;827    	tSWIPEvent.ptPacketInfo = malloc(iTouchEventPacketSize);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       malloc
;;;828    	memset(tSWIPEvent.ptPacketInfo, 0, iTouchEventPacketSize);
000078  4629              MOV      r1,r5
00007a  6060              STR      r0,[r4,#4]  ; tSWIPEvent
00007c  f7fffffe          BL       __aeabi_memclr
;;;829    
;;;830    	vtProtocolBufferPointers.pParameterBuffer = (void *)PARAM_GetPreMainSet();
000080  f7fffffe          BL       PARAM_GetPreMainSet
000084  4902              LDR      r1,|L20.144|
000086  6048              STR      r0,[r1,#4]  ; vtProtocolBufferPointers
;;;831    }
000088  bd38              POP      {r3-r5,pc}
;;;832    
                          ENDP

00008a  0000              DCW      0x0000
                  |L20.140|
                          DCD      ||.data||
                  |L20.144|
                          DCD      vtProtocolBufferPointers

                          AREA ||i.protocol_swip_InitTouchEventBuffer||, CODE, READONLY, ALIGN=2

                  protocol_swip_InitTouchEventBuffer PROC
;;;563    
;;;564    void protocol_swip_InitTouchEventBuffer(void)
000000  4902              LDR      r1,|L21.12|
;;;565    {
;;;566    	thisInfo->iEventPacket_ = 0;
000002  2000              MOVS     r0,#0
000004  6849              LDR      r1,[r1,#4]  ; thisInfo
000006  f8c10001          STR      r0,[r1,#1]
;;;567    #ifdef MODE_I2C
;;;568    	protocol_swip_WaitEventInterruptCleared();	
;;;569    #endif
;;;570    }
00000a  4770              BX       lr
;;;571    
                          ENDP

                  |L21.12|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_PendEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendEventInterrupt PROC
;;;443    
;;;444    void protocol_swip_PendEventInterrupt(void)
000000  b510              PUSH     {r4,lr}
;;;445    {
;;;446        thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
000002  4c0f              LDR      r4,|L22.64|
000004  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
000006  7841              LDRB     r1,[r0,#1]
000008  480e              LDR      r0,|L22.68|
00000a  6840              LDR      r0,[r0,#4]  ; thisInfo
00000c  7001              STRB     r1,[r0,#0]
00000e  2001              MOVS     r0,#1
;;;447        switch( thisInfo->eEventTriggerType )
000010  2901              CMP      r1,#1
000012  d004              BEQ      |L22.30|
000014  2902              CMP      r1,#2
;;;448        {
;;;449        case ETT_INTERRUPT:
;;;450            Hal_PendIntr();
;;;451            break;
;;;452        case ETT_REGISTER:
;;;453            tProtocolCtrl.getter->bEventReady = YES;
000016  bf04              ITT      EQ
000018  6821              LDREQ    r1,[r4,#0]  ; tProtocolCtrl
00001a  7048              STRBEQ   r0,[r1,#1]
;;;454            break;
;;;455        }
;;;456    }
00001c  bd10              POP      {r4,pc}
                  |L22.30|
00001e  f7fffffe          BL       CheckI2CReady
000022  2800              CMP      r0,#0
000024  bf18              IT       NE
000026  bd10              POPNE    {r4,pc}
000028  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
00002a  7840              LDRB     r0,[r0,#1]
00002c  2801              CMP      r0,#1
00002e  bf18              IT       NE
000030  bd10              POPNE    {r4,pc}
000032  2100              MOVS     r1,#0
000034  e8bd4010          POP      {r4,lr}
000038  2004              MOVS     r0,#4
00003a  f7ffbffe          B.W      GPIO_Set_DATA
;;;457    
                          ENDP

00003e  0000              DCW      0x0000
                  |L22.64|
                          DCD      tProtocolCtrl
                  |L22.68|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_PendReadyStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendReadyStatus PROC
;;;363    
;;;364    void protocol_swip_PendReadyStatus(void)
000000  4804              LDR      r0,|L23.20|
;;;365    {
;;;366        tProtocolCtrl.getter->eReadyStatus = RS_READY;
000002  21a0              MOVS     r1,#0xa0
000004  6802              LDR      r2,[r0,#0]  ; tProtocolCtrl
000006  7011              STRB     r1,[r2,#0]
000008  6800              LDR      r0,[r0,#0]
                  |L23.10|
;;;367        while( tProtocolCtrl.getter->eReadyStatus == RS_READY );
00000a  7801              LDRB     r1,[r0,#0]
00000c  29a0              CMP      r1,#0xa0
00000e  d0fc              BEQ      |L23.10|
;;;368    }
000010  4770              BX       lr
;;;369    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PendTestResult||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendTestResult PROC
;;;542    
;;;543    void protocol_swip_PendTestResult(const tSWIPTestDataFmt_t* _ptDataFormat, const void* _pBuf)
000000  4a0a              LDR      r2,|L24.44|
;;;544    {
;;;545        tSWIPTest.tTest.ptCtrl->eTestType = CTT_NONE;
000002  23ff              MOVS     r3,#0xff
000004  f8d2c004          LDR      r12,[r2,#4]  ; tSWIPTest
000008  f88c3000          STRB     r3,[r12,#0]
;;;546        //Set data format.
;;;547        tSWIPTest.tTest.ptFormat = _ptDataFormat;
;;;548    
;;;549        //Set buffer address.
;;;550        vtProtocolBufferPointers.pGeneralBuffer = (void*)_pBuf;
00000c  6090              STR      r0,[r2,#8]  ; tSWIPTest
00000e  4808              LDR      r0,|L24.48|
000010  6001              STR      r1,[r0,#0]  ; vtProtocolBufferPointers
;;;551    
;;;552        //Pend wait flag and wait for image type setting.
;;;553        tProtocolCtrl.getter->eReadyStatus = RS_READY;
000012  4808              LDR      r0,|L24.52|
000014  21a0              MOVS     r1,#0xa0
000016  6803              LDR      r3,[r0,#0]  ; tProtocolCtrl
000018  7019              STRB     r1,[r3,#0]
;;;554        while( tSWIPTest.tTest.ptCtrl->eTestType == CTT_NONE
;;;555                && tProtocolCtrl.setter->eMode == M_TOUCH_DIAG )
00001a  6851              LDR      r1,[r2,#4]
00001c  6840              LDR      r0,[r0,#4]
                  |L24.30|
00001e  780a              LDRB     r2,[r1,#0]            ;554
000020  2aff              CMP      r2,#0xff              ;554
000022  bf04              ITT      EQ
000024  7802              LDRBEQ   r2,[r0,#0]
000026  2a01              CMPEQ    r2,#1
000028  d0f9              BEQ      |L24.30|
;;;556            ;
;;;557    }
00002a  4770              BX       lr
;;;558    
                          ENDP

                  |L24.44|
                          DCD      ||.data||+0x30
                  |L24.48|
                          DCD      vtProtocolBufferPointers
                  |L24.52|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PushTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_PushTouchEvent PROC
;;;652    #endif
;;;653    void protocol_swip_PushTouchEvent(const uSWIPTouchItem_t* _kptItem)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;654    {
;;;655    	int index = 0;
;;;656    
;;;657    #if (SWIP_QUEUE_MODE)
;;;658    	if(sptAlgorithmInfo->bQueueStart == 0)
000004  4d7c              LDR      r5,|L25.504|
000006  4607              MOV      r7,r0                 ;654
000008  2400              MOVS     r4,#0                 ;655
00000a  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
;;;659    	{
;;;660    		sptAlgorithmInfo->bQueueStart = 1;
;;;661    		if((sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE == sptAlgorithmInfo->QueueFront ) // Queue Full Check
;;;662    		{	
;;;663    			uint8_t CurrFrontIdx, NextFrontIdx;
;;;664    
;;;665    			if( protocol_swip_CheckEventInterrupt() == YES )
;;;666    			{
;;;667    				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE;
;;;668    			}
;;;669    			else
;;;670    			{
;;;671    				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 2) % SWIP_QUEUE_SIZE;
;;;672    			}
;;;673    			NextFrontIdx = (CurrFrontIdx + 1) % SWIP_QUEUE_SIZE;
;;;674    
;;;675    			for(index=0; index<MAX_TOUCH_; index++)				
;;;676    			{
;;;677    				if( ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status == 0 && ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID > 0)
00000c  4e7b              LDR      r6,|L25.508|
00000e  f5005080          ADD      r0,r0,#0x1000         ;658
000012  f8901030          LDRB     r1,[r0,#0x30]         ;658
000016  2900              CMP      r1,#0                 ;658
000018  d17e              BNE      |L25.280|
00001a  2101              MOVS     r1,#1                 ;660
00001c  f8801030          STRB     r1,[r0,#0x30]         ;660
000020  f890102e          LDRB     r1,[r0,#0x2e]         ;661
000024  f8df81d8          LDR      r8,|L25.512|
000028  2200              MOVS     r2,#0                 ;661
00002a  4643              MOV      r3,r8                 ;661
00002c  1c49              ADDS     r1,r1,#1              ;661
00002e  fbe13208          UMLAL    r3,r2,r1,r8           ;661
000032  0852              LSRS     r2,r2,#1              ;661
000034  eba202c2          SUB      r2,r2,r2,LSL #3       ;661
000038  f890002f          LDRB     r0,[r0,#0x2f]         ;661
00003c  4411              ADD      r1,r1,r2              ;661
00003e  4281              CMP      r1,r0                 ;661
000040  d17c              BNE      |L25.316|
000042  4870              LDR      r0,|L25.516|
000044  6841              LDR      r1,[r0,#4]            ;661  ; tProtocolCtrl
000046  784a              LDRB     r2,[r1,#1]            ;661
000048  6869              LDR      r1,[r5,#4]            ;661  ; thisInfo
00004a  700a              STRB     r2,[r1,#0]            ;661
00004c  b2d1              UXTB     r1,r2                 ;661
00004e  2901              CMP      r1,#1                 ;661
000050  d002              BEQ      |L25.88|
000052  2902              CMP      r1,#2                 ;661
000054  d006              BEQ      |L25.100|
000056  e008              B        |L25.106|
                  |L25.88|
000058  2004              MOVS     r0,#4                 ;661
00005a  f7fffffe          BL       GPIO_Get_IN
00005e  2801              CMP      r0,#1                 ;661
000060  d103              BNE      |L25.106|
000062  e02d              B        |L25.192|
                  |L25.100|
000064  6800              LDR      r0,[r0,#0]            ;661  ; tProtocolCtrl
000066  7840              LDRB     r0,[r0,#1]            ;661
000068  b350              CBZ      r0,|L25.192|
                  |L25.106|
00006a  68a8              LDR      r0,[r5,#8]            ;671  ; sptAlgorithmInfo
00006c  4a64              LDR      r2,|L25.512|
00006e  f5005080          ADD      r0,r0,#0x1000         ;671
000072  2100              MOVS     r1,#0                 ;671
000074  f890002e          LDRB     r0,[r0,#0x2e]         ;671
000078  1c80              ADDS     r0,r0,#2              ;671
00007a  fbe02108          UMLAL    r2,r1,r0,r8           ;671
00007e  0849              LSRS     r1,r1,#1              ;671
000080  eba101c1          SUB      r1,r1,r1,LSL #3       ;671
000084  4408              ADD      r0,r0,r1              ;671
000086  b2c0              UXTB     r0,r0                 ;671
                  |L25.136|
000088  1c41              ADDS     r1,r0,#1              ;673
00008a  4b5d              LDR      r3,|L25.512|
00008c  2200              MOVS     r2,#0                 ;673
00008e  fbe13208          UMLAL    r3,r2,r1,r8           ;673
000092  0852              LSRS     r2,r2,#1              ;673
000094  eba202c2          SUB      r2,r2,r2,LSL #3       ;673
000098  4411              ADD      r1,r1,r2              ;673
00009a  b2c9              UXTB     r1,r1                 ;673
;;;678    				{
;;;679    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].Status = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status; 
00009c  eb011141          ADD      r1,r1,r1,LSL #5
0000a0  eb001040          ADD      r0,r0,r0,LSL #5       ;677
0000a4  eb060241          ADD      r2,r6,r1,LSL #1
0000a8  eb060340          ADD      r3,r6,r0,LSL #1       ;677
                  |L25.172|
0000ac  eb040044          ADD      r0,r4,r4,LSL #1       ;677
0000b0  eb030140          ADD      r1,r3,r0,LSL #1       ;677
0000b4  f891c003          LDRB     r12,[r1,#3]           ;677
0000b8  f1bc0f00          CMP      r12,#0                ;677
0000bc  d127              BNE      |L25.270|
0000be  e00f              B        |L25.224|
                  |L25.192|
0000c0  68a8              LDR      r0,[r5,#8]            ;667  ; sptAlgorithmInfo
0000c2  4a4f              LDR      r2,|L25.512|
0000c4  f5005080          ADD      r0,r0,#0x1000         ;667
0000c8  2100              MOVS     r1,#0                 ;667
0000ca  f890002e          LDRB     r0,[r0,#0x2e]         ;667
0000ce  1c40              ADDS     r0,r0,#1              ;667
0000d0  fbe02108          UMLAL    r2,r1,r0,r8           ;667
0000d4  0849              LSRS     r1,r1,#1              ;667
0000d6  eba101c1          SUB      r1,r1,r1,LSL #3       ;667
0000da  4408              ADD      r0,r0,r1              ;667
0000dc  b2c0              UXTB     r0,r0                 ;667
0000de  e7d3              B        |L25.136|
                  |L25.224|
0000e0  f891c004          LDRB     r12,[r1,#4]           ;677
0000e4  f1bc0f00          CMP      r12,#0                ;677
0000e8  d011              BEQ      |L25.270|
0000ea  f891c003          LDRB     r12,[r1,#3]
0000ee  eb020040          ADD      r0,r2,r0,LSL #1
0000f2  f880c003          STRB     r12,[r0,#3]
;;;680    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ID 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID; 	 
0000f6  f891c004          LDRB     r12,[r1,#4]
0000fa  f880c004          STRB     r12,[r0,#4]
;;;681    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucX 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucX; 	 
0000fe  f8b1c005          LDRH     r12,[r1,#5]
000102  f8a0c005          STRH     r12,[r0,#5]
;;;682    					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucY 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucY;	 
000106  f8b11007          LDRH     r1,[r1,#7]
00010a  f8a01007          STRH     r1,[r0,#7]
                  |L25.270|
00010e  1c64              ADDS     r4,r4,#1
000110  2c0a              CMP      r4,#0xa               ;675
000112  dbcb              BLT      |L25.172|
;;;683    				}
;;;684    			}
;;;685    
;;;686    			sptAlgorithmInfo->QueueFront++;
000114  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
000116  e001              B        |L25.284|
                  |L25.280|
000118  e01c              B        |L25.340|
00011a  e00f              B        |L25.316|
                  |L25.284|
00011c  f5005180          ADD      r1,r0,#0x1000
000120  4b37              LDR      r3,|L25.512|
000122  f891002f          LDRB     r0,[r1,#0x2f]
000126  2200              MOVS     r2,#0
000128  1c40              ADDS     r0,r0,#1
00012a  b2c0              UXTB     r0,r0
;;;687    			sptAlgorithmInfo->QueueFront = (sptAlgorithmInfo->QueueFront) % SWIP_QUEUE_SIZE;
00012c  fbe03208          UMLAL    r3,r2,r0,r8
000130  0852              LSRS     r2,r2,#1
000132  eba202c2          SUB      r2,r2,r2,LSL #3
000136  4410              ADD      r0,r0,r2
000138  f881002f          STRB     r0,[r1,#0x2f]
                  |L25.316|
;;;688    		}
;;;689    		memset((void *)&ptPacketInfoQueue[sptAlgorithmInfo->QueueRear], 0x00, sizeof(tSWIPPacketInfo_t));
00013c  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
00013e  2142              MOVS     r1,#0x42
000140  f5005080          ADD      r0,r0,#0x1000
000144  f890002e          LDRB     r0,[r0,#0x2e]
000148  eb001040          ADD      r0,r0,r0,LSL #5
00014c  eb060040          ADD      r0,r6,r0,LSL #1
000150  f7fffffe          BL       __aeabi_memclr
                  |L25.340|
;;;690    	}
;;;691    #endif
;;;692    
;;;693    	index = (_kptItem->tItem00.tInfo.b4FingerID-1);
000154  7838              LDRB     r0,[r7,#0]
000156  f000010f          AND      r1,r0,#0xf
;;;694    
;;;695    #if (SWIP_QUEUE_MODE)
;;;696    #if USED_SHARP_SPECIFIC_PROTOCOL
;;;697    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].Status = ((_kptItem->tItem00.tInfo.b6Type << 1) | (_kptItem->tItem00.tInfo.b1Status & 0x01)) & 0xff;
;;;698    #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;699    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].Status = _kptItem->tItem00.tInfo.bTouch;
00015a  09c3              LSRS     r3,r0,#7
00015c  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
00015e  1e49              SUBS     r1,r1,#1
000160  f5005080          ADD      r0,r0,#0x1000
000164  f890202e          LDRB     r2,[r0,#0x2e]
000168  eb021242          ADD      r2,r2,r2,LSL #5
00016c  eb060c42          ADD      r12,r6,r2,LSL #1
000170  eb010241          ADD      r2,r1,r1,LSL #1
000174  eb0c0c42          ADD      r12,r12,r2,LSL #1
000178  f88c3003          STRB     r3,[r12,#3]
;;;700    #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;701    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ID 	= _kptItem->tItem00.tInfo.b4FingerID;
00017c  f890c02e          LDRB     r12,[r0,#0x2e]
000180  783b              LDRB     r3,[r7,#0]
000182  eb0c1c4c          ADD      r12,r12,r12,LSL #5
000186  eb060c4c          ADD      r12,r6,r12,LSL #1
00018a  eb0c0c42          ADD      r12,r12,r2,LSL #1
00018e  f003030f          AND      r3,r3,#0xf
000192  f88c3004          STRB     r3,[r12,#4]
;;;702    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucX 	= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
000196  78fb              LDRB     r3,[r7,#3]
000198  f897c001          LDRB     r12,[r7,#1]
00019c  ea43230c          ORR      r3,r3,r12,LSL #8
0001a0  f890c02e          LDRB     r12,[r0,#0x2e]
0001a4  eb0c1c4c          ADD      r12,r12,r12,LSL #5
0001a8  eb060c4c          ADD      r12,r6,r12,LSL #1
0001ac  eb0c0c42          ADD      r12,r12,r2,LSL #1
0001b0  f8ac3005          STRH     r3,[r12,#5]
;;;703    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucY 	= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
0001b4  793b              LDRB     r3,[r7,#4]
0001b6  f897c002          LDRB     r12,[r7,#2]
0001ba  ea43230c          ORR      r3,r3,r12,LSL #8
0001be  f890c02e          LDRB     r12,[r0,#0x2e]
0001c2  eb0c1c4c          ADD      r12,r12,r12,LSL #5
0001c6  eb060c4c          ADD      r12,r6,r12,LSL #1
0001ca  eb0c0242          ADD      r2,r12,r2,LSL #1
0001ce  f8a23007          STRH     r3,[r2,#7]
;;;704    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].RowStart 				= _kptItem->tItem00.ucRowStart;
0001d2  f890302e          LDRB     r3,[r0,#0x2e]
0001d6  7a3a              LDRB     r2,[r7,#8]
0001d8  eb031343          ADD      r3,r3,r3,LSL #5
0001dc  eb060343          ADD      r3,r6,r3,LSL #1
0001e0  f8a32040          STRH     r2,[r3,#0x40]
;;;705    	ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].ucContactCnt 			= index;
0001e4  f890002e          LDRB     r0,[r0,#0x2e]
0001e8  eb001040          ADD      r0,r0,r0,LSL #5
0001ec  eb060040          ADD      r0,r6,r0,LSL #1
0001f0  f880103f          STRB     r1,[r0,#0x3f]
;;;706    #else
;;;707    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= _kptItem->tItem00.tInfo.bTouch;
;;;708    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= _kptItem->tItem00.tInfo.b4FingerID;
;;;709    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
;;;710    	tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
;;;711    	tSWIPEvent.ptPacketInfo->RowStart 					= _kptItem->tItem00.ucRowStart;
;;;712    	tSWIPEvent.ptPacketInfo->ucContactCnt 				= index;
;;;713    	thisInfo->iEventPacket_ += ((int)tSWIPEvent.ptEventFormat->ucTouchPacketItemSize);
;;;714    #endif
;;;715    }
0001f4  e8bd81f0          POP      {r4-r8,pc}
;;;716    
                          ENDP

                  |L25.504|
                          DCD      ||.data||
                  |L25.508|
                          DCD      ||area_number.36||
                  |L25.512|
                          DCD      0x49249249
                  |L25.516|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SendPenEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_SendPenEvent PROC
;;;750    
;;;751    void protocol_swip_SendPenEvent(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;752    {
;;;753    	int index;
;;;754    
;;;755    #if (SWIP_QUEUE_MODE)
;;;756    	if( sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
000004  4c5e              LDR      r4,|L26.384|
000006  68a0              LDR      r0,[r4,#8]  ; sptAlgorithmInfo
000008  f5005080          ADD      r0,r0,#0x1000
00000c  f890102f          LDRB     r1,[r0,#0x2f]
000010  f890002e          LDRB     r0,[r0,#0x2e]
000014  4281              CMP      r1,r0
;;;757    	{
;;;758    		for(index=0; index<MAX_TOUCH_; index++)
;;;759    		{
;;;760    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;761    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;762    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;763    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;764    			tSWIPEvent.ptPacketInfo->RowStart 					= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;765    			tSWIPEvent.ptPacketInfo->ucContactCnt 				= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;766    		}
;;;767    		tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;768    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;769    		protocol_swip_PendEventInterrupt();
;;;770    	}
;;;771    #else			
;;;772    	if( thisInfo->iEventPacket_ )
;;;773    		{
;;;774    		tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;775    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;776    		protocol_swip_PendEventInterrupt();
;;;777    	}
;;;778    	else
;;;779    	{
;;;780    		tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;781    	}
;;;782    #endif
;;;783    }
000016  bf08              IT       EQ
000018  e8bd9ff0          POPEQ    {r4-r12,pc}
00001c  f8dfb164          LDR      r11,|L26.388|
000020  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
000024  7841              LDRB     r1,[r0,#1]
000026  6860              LDR      r0,[r4,#4]  ; thisInfo
000028  7001              STRB     r1,[r0,#0]
00002a  b2c8              UXTB     r0,r1
00002c  2801              CMP      r0,#1
00002e  d07d              BEQ      |L26.300|
000030  2802              CMP      r0,#2
000032  bf18              IT       NE
000034  e8bd9ff0          POPNE    {r4-r12,pc}
000038  f8db0000          LDR      r0,[r11,#0]  ; tProtocolCtrl
00003c  7840              LDRB     r0,[r0,#1]
00003e  2800              CMP      r0,#0
000040  bf18              IT       NE
000042  e8bd9ff0          POPNE    {r4-r12,pc}
000046  bf00              NOP                            ;758
                  |L26.72|
000048  68a1              LDR      r1,[r4,#8]            ;760  ; sptAlgorithmInfo
00004a  2504              MOVS     r5,#4                 ;760
00004c  4a4e              LDR      r2,|L26.392|
00004e  484f              LDR      r0,|L26.396|
000050  2603              MOVS     r6,#3                 ;760
000052  f04f0c00          MOV      r12,#0                ;758
000056  46a6              MOV      lr,r4                 ;760
000058  2705              MOVS     r7,#5                 ;762
00005a  f04f0807          MOV      r8,#7                 ;763
00005e  f5015380          ADD      r3,r1,#0x1000         ;760
000062  bf00              NOP                            ;760
                  |L26.100|
000064  f893102f          LDRB     r1,[r3,#0x2f]         ;760
000068  eb011141          ADD      r1,r1,r1,LSL #5       ;760
00006c  eb020441          ADD      r4,r2,r1,LSL #1       ;760
000070  eb0c014c          ADD      r1,r12,r12,LSL #1     ;760
000074  eb040441          ADD      r4,r4,r1,LSL #1       ;760
000078  78e4              LDRB     r4,[r4,#3]            ;760
00007a  f8d09004          LDR      r9,[r0,#4]            ;760  ; tSWIPEvent
00007e  eb060a41          ADD      r10,r6,r1,LSL #1      ;760
000082  f809400a          STRB     r4,[r9,r10]           ;760
000086  f893402f          LDRB     r4,[r3,#0x2f]         ;761
00008a  eb041444          ADD      r4,r4,r4,LSL #5       ;761
00008e  eb020444          ADD      r4,r2,r4,LSL #1       ;761
000092  eb040441          ADD      r4,r4,r1,LSL #1       ;761
000096  7924              LDRB     r4,[r4,#4]            ;761
000098  f8d09004          LDR      r9,[r0,#4]            ;761  ; tSWIPEvent
00009c  eb050a41          ADD      r10,r5,r1,LSL #1      ;761
0000a0  f809400a          STRB     r4,[r9,r10]           ;761
0000a4  f893402f          LDRB     r4,[r3,#0x2f]         ;762
0000a8  eb041444          ADD      r4,r4,r4,LSL #5       ;762
0000ac  eb020444          ADD      r4,r2,r4,LSL #1       ;762
0000b0  eb040441          ADD      r4,r4,r1,LSL #1       ;762
0000b4  f8b44005          LDRH     r4,[r4,#5]            ;762
0000b8  f8d09004          LDR      r9,[r0,#4]            ;762  ; tSWIPEvent
0000bc  eb070a41          ADD      r10,r7,r1,LSL #1      ;762
0000c0  44d1              ADD      r9,r9,r10             ;762
0000c2  f8a94000          STRH     r4,[r9,#0]            ;762
0000c6  f893402f          LDRB     r4,[r3,#0x2f]         ;763
0000ca  eb041444          ADD      r4,r4,r4,LSL #5       ;763
0000ce  eb020444          ADD      r4,r2,r4,LSL #1       ;763
0000d2  eb040441          ADD      r4,r4,r1,LSL #1       ;763
0000d6  f8b44007          LDRH     r4,[r4,#7]            ;763
0000da  f8d09004          LDR      r9,[r0,#4]            ;763  ; tSWIPEvent
0000de  eb080141          ADD      r1,r8,r1,LSL #1       ;763
0000e2  4449              ADD      r1,r1,r9              ;763
0000e4  800c              STRH     r4,[r1,#0]            ;763
0000e6  f893102f          LDRB     r1,[r3,#0x2f]         ;764
0000ea  eb011141          ADD      r1,r1,r1,LSL #5       ;764
0000ee  eb020141          ADD      r1,r2,r1,LSL #1       ;764
0000f2  f8b14040          LDRH     r4,[r1,#0x40]         ;764
0000f6  6841              LDR      r1,[r0,#4]            ;764  ; tSWIPEvent
0000f8  f8a14040          STRH     r4,[r1,#0x40]         ;764
0000fc  f893402f          LDRB     r4,[r3,#0x2f]         ;765
000100  eb041444          ADD      r4,r4,r4,LSL #5       ;765
000104  eb020444          ADD      r4,r2,r4,LSL #1       ;765
000108  f894403f          LDRB     r4,[r4,#0x3f]         ;765
00010c  f10c0c01          ADD      r12,r12,#1            ;765
000110  f881403f          STRB     r4,[r1,#0x3f]         ;765
000114  f1bc0f0a          CMP      r12,#0xa              ;758
000118  dba4              BLT      |L26.100|
00011a  6842              LDR      r2,[r0,#4]            ;767  ; tSWIPEvent
00011c  2101              MOVS     r1,#1                 ;767
00011e  7091              STRB     r1,[r2,#2]            ;767
000120  6840              LDR      r0,[r0,#4]            ;768  ; tSWIPEvent
000122  2230              MOVS     r2,#0x30              ;768
000124  8002              STRH     r2,[r0,#0]            ;768
000126  f8db0004          LDR      r0,[r11,#4]           ;768  ; tProtocolCtrl
00012a  e000              B        |L26.302|
                  |L26.300|
00012c  e00d              B        |L26.330|
                  |L26.302|
00012e  7842              LDRB     r2,[r0,#1]            ;768
000130  f8de0004          LDR      r0,[lr,#4]            ;768  ; thisInfo
000134  7002              STRB     r2,[r0,#0]            ;768
000136  b2d0              UXTB     r0,r2                 ;768
000138  2801              CMP      r0,#1                 ;768
00013a  d00e              BEQ      |L26.346|
00013c  2802              CMP      r0,#2                 ;768
00013e  bf04              ITT      EQ                    ;768
000140  f8db0000          LDREQ    r0,[r11,#0]           ;768  ; tProtocolCtrl
000144  7041              STRBEQ   r1,[r0,#1]            ;768
000146  e8bd9ff0          POP      {r4-r12,pc}
                  |L26.330|
00014a  2004              MOVS     r0,#4
00014c  f7fffffe          BL       GPIO_Get_IN
000150  2801              CMP      r0,#1
000152  bf18              IT       NE
000154  e8bd9ff0          POPNE    {r4-r12,pc}
000158  e776              B        |L26.72|
                  |L26.346|
00015a  f7fffffe          BL       CheckI2CReady
00015e  2800              CMP      r0,#0
000160  bf18              IT       NE
000162  e8bd9ff0          POPNE    {r4-r12,pc}
000166  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
00016a  7840              LDRB     r0,[r0,#1]
00016c  2801              CMP      r0,#1
00016e  bf18              IT       NE
000170  e8bd9ff0          POPNE    {r4-r12,pc}
000174  2100              MOVS     r1,#0
000176  e8bd5ff0          POP      {r4-r12,lr}
00017a  2004              MOVS     r0,#4
00017c  f7ffbffe          B.W      GPIO_Set_DATA
;;;784    
                          ENDP

                  |L26.384|
                          DCD      ||.data||
                  |L26.388|
                          DCD      tProtocolCtrl
                  |L26.392|
                          DCD      ||area_number.36||
                  |L26.396|
                          DCD      ||.data||+0xc

                          AREA ||i.protocol_swip_SendTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_SendTouchEvent PROC
;;;716    
;;;717    void protocol_swip_SendTouchEvent(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;718    {
;;;719    	int index = 0;	
;;;720    
;;;721    #if (SWIP_QUEUE_MODE)
;;;722    	if(sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
000004  4d5e              LDR      r5,|L27.384|
000006  2400              MOVS     r4,#0                 ;719
000008  68a8              LDR      r0,[r5,#8]  ; sptAlgorithmInfo
00000a  f5005080          ADD      r0,r0,#0x1000
00000e  f890102f          LDRB     r1,[r0,#0x2f]
000012  f890002e          LDRB     r0,[r0,#0x2e]
000016  4281              CMP      r1,r0
;;;723    	{
;;;724    		for(index=0; index<MAX_TOUCH_; index++)
;;;725    		{
;;;726    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;727    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;728    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;729    			tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;730    			tSWIPEvent.ptPacketInfo->RowStart 					= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;731    			tSWIPEvent.ptPacketInfo->ucContactCnt 				= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;732    		}
;;;733    		tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;734    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;735    		protocol_swip_PendEventInterrupt();
;;;736    	}
;;;737    #else
;;;738    	if( thisInfo->iEventPacket_ )
;;;739    	{
;;;740    		tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;741    		tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;742    		protocol_swip_PendEventInterrupt();
;;;743    	}
;;;744    	else
;;;745    	{
;;;746    		tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;747    	}
;;;748    #endif
;;;749    }
000018  bf08              IT       EQ
00001a  e8bd9ff0          POPEQ    {r4-r12,pc}
00001e  f8dfb164          LDR      r11,|L27.388|
000022  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
000026  7841              LDRB     r1,[r0,#1]
000028  6868              LDR      r0,[r5,#4]  ; thisInfo
00002a  7001              STRB     r1,[r0,#0]
00002c  b2c8              UXTB     r0,r1
00002e  2801              CMP      r0,#1
000030  d07e              BEQ      |L27.304|
000032  2802              CMP      r0,#2
000034  bf18              IT       NE
000036  e8bd9ff0          POPNE    {r4-r12,pc}
00003a  f8db0000          LDR      r0,[r11,#0]  ; tProtocolCtrl
00003e  7840              LDRB     r0,[r0,#1]
000040  2800              CMP      r0,#0
000042  bf18              IT       NE
000044  e8bd9ff0          POPNE    {r4-r12,pc}
                  |L27.72|
000048  46ae              MOV      lr,r5                 ;726
00004a  68a9              LDR      r1,[r5,#8]            ;726  ; sptAlgorithmInfo
00004c  2504              MOVS     r5,#4                 ;726
00004e  4a4e              LDR      r2,|L27.392|
000050  484e              LDR      r0,|L27.396|
000052  2603              MOVS     r6,#3                 ;726
000054  2705              MOVS     r7,#5                 ;728
000056  f04f0807          MOV      r8,#7                 ;729
00005a  f5015380          ADD      r3,r1,#0x1000         ;726
00005e  bf00              NOP                            ;726
                  |L27.96|
000060  f893102f          LDRB     r1,[r3,#0x2f]         ;726
000064  eb011141          ADD      r1,r1,r1,LSL #5       ;726
000068  eb020c41          ADD      r12,r2,r1,LSL #1      ;726
00006c  eb040144          ADD      r1,r4,r4,LSL #1       ;726
000070  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;726
000074  f89cc003          LDRB     r12,[r12,#3]          ;726
000078  f8d09004          LDR      r9,[r0,#4]            ;726  ; tSWIPEvent
00007c  eb060a41          ADD      r10,r6,r1,LSL #1      ;726
000080  f809c00a          STRB     r12,[r9,r10]          ;726
000084  f893c02f          LDRB     r12,[r3,#0x2f]        ;727
000088  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;727
00008c  eb020c4c          ADD      r12,r2,r12,LSL #1     ;727
000090  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;727
000094  f89cc004          LDRB     r12,[r12,#4]          ;727
000098  f8d09004          LDR      r9,[r0,#4]            ;727  ; tSWIPEvent
00009c  eb050a41          ADD      r10,r5,r1,LSL #1      ;727
0000a0  f809c00a          STRB     r12,[r9,r10]          ;727
0000a4  f893c02f          LDRB     r12,[r3,#0x2f]        ;728
0000a8  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;728
0000ac  eb020c4c          ADD      r12,r2,r12,LSL #1     ;728
0000b0  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;728
0000b4  f8bcc005          LDRH     r12,[r12,#5]          ;728
0000b8  f8d09004          LDR      r9,[r0,#4]            ;728  ; tSWIPEvent
0000bc  eb070a41          ADD      r10,r7,r1,LSL #1      ;728
0000c0  44d1              ADD      r9,r9,r10             ;728
0000c2  f8a9c000          STRH     r12,[r9,#0]           ;728
0000c6  f893c02f          LDRB     r12,[r3,#0x2f]        ;729
0000ca  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;729
0000ce  eb020c4c          ADD      r12,r2,r12,LSL #1     ;729
0000d2  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;729
0000d6  f8bcc007          LDRH     r12,[r12,#7]          ;729
0000da  f8d09004          LDR      r9,[r0,#4]            ;729  ; tSWIPEvent
0000de  eb080141          ADD      r1,r8,r1,LSL #1       ;729
0000e2  4449              ADD      r1,r1,r9              ;729
0000e4  f8a1c000          STRH     r12,[r1,#0]           ;729
0000e8  f893102f          LDRB     r1,[r3,#0x2f]         ;730
0000ec  eb011141          ADD      r1,r1,r1,LSL #5       ;730
0000f0  eb020141          ADD      r1,r2,r1,LSL #1       ;730
0000f4  f8b1c040          LDRH     r12,[r1,#0x40]        ;730
0000f8  6841              LDR      r1,[r0,#4]            ;730  ; tSWIPEvent
0000fa  f8a1c040          STRH     r12,[r1,#0x40]        ;730
0000fe  f893c02f          LDRB     r12,[r3,#0x2f]        ;731
000102  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;731
000106  eb020c4c          ADD      r12,r2,r12,LSL #1     ;731
00010a  f89cc03f          LDRB     r12,[r12,#0x3f]       ;731
00010e  1c64              ADDS     r4,r4,#1              ;731
000110  f881c03f          STRB     r12,[r1,#0x3f]        ;731
000114  2c0a              CMP      r4,#0xa               ;724
000116  dba3              BLT      |L27.96|
000118  6842              LDR      r2,[r0,#4]            ;733  ; tSWIPEvent
00011a  2101              MOVS     r1,#1                 ;733
00011c  7091              STRB     r1,[r2,#2]            ;733
00011e  6840              LDR      r0,[r0,#4]            ;734  ; tSWIPEvent
000120  2230              MOVS     r2,#0x30              ;734
000122  8002              STRH     r2,[r0,#0]            ;734
000124  f8db0004          LDR      r0,[r11,#4]           ;734  ; tProtocolCtrl
000128  7842              LDRB     r2,[r0,#1]            ;734
00012a  f8de0004          LDR      r0,[lr,#4]            ;734  ; thisInfo
00012e  e000              B        |L27.306|
                  |L27.304|
000130  e00a              B        |L27.328|
                  |L27.306|
000132  7002              STRB     r2,[r0,#0]            ;734
000134  b2d0              UXTB     r0,r2                 ;734
000136  2801              CMP      r0,#1                 ;734
000138  d00e              BEQ      |L27.344|
00013a  2802              CMP      r0,#2                 ;734
00013c  bf04              ITT      EQ                    ;734
00013e  f8db0000          LDREQ    r0,[r11,#0]           ;734  ; tProtocolCtrl
000142  7041              STRBEQ   r1,[r0,#1]            ;734
000144  e8bd9ff0          POP      {r4-r12,pc}
                  |L27.328|
000148  2004              MOVS     r0,#4
00014a  f7fffffe          BL       GPIO_Get_IN
00014e  2801              CMP      r0,#1
000150  bf18              IT       NE
000152  e8bd9ff0          POPNE    {r4-r12,pc}
000156  e777              B        |L27.72|
                  |L27.344|
000158  f7fffffe          BL       CheckI2CReady
00015c  2800              CMP      r0,#0
00015e  bf18              IT       NE
000160  e8bd9ff0          POPNE    {r4-r12,pc}
000164  f8db0004          LDR      r0,[r11,#4]  ; tProtocolCtrl
000168  7840              LDRB     r0,[r0,#1]
00016a  2801              CMP      r0,#1
00016c  bf18              IT       NE
00016e  e8bd9ff0          POPNE    {r4-r12,pc}
000172  2100              MOVS     r1,#0
000174  e8bd5ff0          POP      {r4-r12,lr}
000178  2004              MOVS     r0,#4
00017a  f7ffbffe          B.W      GPIO_Set_DATA
;;;750    
                          ENDP

00017e  0000              DCW      0x0000
                  |L27.384|
                          DCD      ||.data||
                  |L27.388|
                          DCD      tProtocolCtrl
                  |L27.392|
                          DCD      ||area_number.36||
                  |L27.396|
                          DCD      ||.data||+0xc

                          AREA ||i.protocol_swip_SetDFUP_Ready||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetDFUP_Ready PROC
;;;358    
;;;359    void protocol_swip_SetDFUP_Ready(bool_t _bVal)
000000  4901              LDR      r1,|L28.8|
;;;360    {
;;;361    	tProtocolCtrl.setter->bDFUP_Ready = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  74c8              STRB     r0,[r1,#0x13]
;;;362    }
000006  4770              BX       lr
;;;363    
                          ENDP

                  |L28.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetEnableBulkLog||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetEnableBulkLog PROC
;;;348    
;;;349    void protocol_swip_SetEnableBulkLog(bool_t _bVal)
000000  4901              LDR      r1,|L29.8|
;;;350    {
;;;351    	tProtocolCtrl.setter->bEnableBulkLog = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7488              STRB     r0,[r1,#0x12]
;;;352    }
000006  4770              BX       lr
;;;353    
                          ENDP

                  |L29.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetMode||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetMode PROC
;;;333    
;;;334    void protocol_swip_SetMode(eProtocolMode_t _eMode)
000000  4901              LDR      r1,|L30.8|
;;;335    {
;;;336    	tProtocolCtrl.setter->eMode = _eMode;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7008              STRB     r0,[r1,#0]
;;;337    }
000006  4770              BX       lr
;;;338    
                          ENDP

                  |L30.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_WaitEventInterruptCleared||, CODE, READONLY, ALIGN=2

                  protocol_swip_WaitEventInterruptCleared PROC
;;;490    
;;;491    void protocol_swip_WaitEventInterruptCleared(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;492    {
;;;493    #define INTR_HIGH_              300
;;;494    #define WAIT_FOR_INTERRUPT_     0xFFFF
;;;495    	int intr = NO;
000004  2500              MOVS     r5,#0
;;;496    	int cnt = WAIT_FOR_INTERRUPT_;
;;;497    	
;;;498    	do
;;;499    	{
;;;500    		switch( thisInfo->eEventTriggerType )
000006  4e38              LDR      r6,|L31.232|
000008  4c38              LDR      r4,|L31.236|
00000a  f64f78ff          MOV      r8,#0xffff            ;496
00000e  462f              MOV      r7,r5                 ;496
                  |L31.16|
000010  6870              LDR      r0,[r6,#4]  ; thisInfo
000012  7800              LDRB     r0,[r0,#0]
000014  2800              CMP      r0,#0
;;;501    		{
;;;502    			case ETT_INTERRUPT:
;;;503    			{
;;;504    				intr = Hal_GetIntr();
;;;505    				if( cnt-- == 0 )
;;;506    				{
;;;507    					Hal_ClearIntr();
;;;508    					int i;
;;;509    					for (i = INTR_HIGH_; i--;)
;;;510    					__NOP();
;;;511    					Hal_PendIntr();
;;;512    					cnt = WAIT_FOR_INTERRUPT_;
;;;513    				}
;;;514    			}
;;;515    			break;
;;;516    
;;;517    			case ETT_REGISTER:
;;;518    			{
;;;519    				intr = tProtocolCtrl.getter->bEventReady;
;;;520    				if( intr )
;;;521    				{
;;;522    					protocol_swip_ClearEventInterrupt();
;;;523    				}
;;;524    			}
;;;525    			break;
;;;526    
;;;527    			case ETT_NONE:
;;;528    				intr = NO;
000016  bf08              IT       EQ
000018  2500              MOVEQ    r5,#0
00001a  d03c              BEQ      |L31.150|
00001c  2801              CMP      r0,#1                 ;500
00001e  d002              BEQ      |L31.38|
000020  2802              CMP      r0,#2                 ;500
000022  d033              BEQ      |L31.140|
000024  e037              B        |L31.150|
                  |L31.38|
000026  f7fffffe          BL       CheckI2CReady
00002a  b958              CBNZ     r0,|L31.68|
00002c  6860              LDR      r0,[r4,#4]            ;500  ; tProtocolCtrl
00002e  7840              LDRB     r0,[r0,#1]            ;500
000030  2801              CMP      r0,#1                 ;500
000032  d107              BNE      |L31.68|
000034  2004              MOVS     r0,#4                 ;500
000036  f7fffffe          BL       GPIO_Get_IN
00003a  b918              CBNZ     r0,|L31.68|
00003c  2101              MOVS     r1,#1                 ;500
00003e  2004              MOVS     r0,#4                 ;500
000040  f7fffffe          BL       GPIO_Set_DATA
                  |L31.68|
000044  2500              MOVS     r5,#0                 ;500
000046  f1b80801          SUBS     r8,r8,#1              ;500
00004a  d224              BCS      |L31.150|
00004c  f7fffffe          BL       CheckI2CReady
000050  b938              CBNZ     r0,|L31.98|
000052  6860              LDR      r0,[r4,#4]            ;507  ; tProtocolCtrl
000054  7840              LDRB     r0,[r0,#1]            ;507
000056  2801              CMP      r0,#1                 ;507
000058  d103              BNE      |L31.98|
00005a  2101              MOVS     r1,#1                 ;507
00005c  2004              MOVS     r0,#4                 ;507
00005e  f7fffffe          BL       GPIO_Set_DATA
                  |L31.98|
000062  bf00              NOP                            ;510
000064  bf00              NOP                            ;510
000066  f2401029          MOV      r0,#0x129             ;509
                  |L31.106|
00006a  bf00              NOP                            ;510
00006c  1e40              SUBS     r0,r0,#1              ;510
00006e  d2fc              BCS      |L31.106|
000070  f7fffffe          BL       CheckI2CReady
000074  b938              CBNZ     r0,|L31.134|
000076  6860              LDR      r0,[r4,#4]            ;509  ; tProtocolCtrl
000078  7840              LDRB     r0,[r0,#1]            ;509
00007a  2801              CMP      r0,#1                 ;509
00007c  d103              BNE      |L31.134|
00007e  2100              MOVS     r1,#0                 ;509
000080  2004              MOVS     r0,#4                 ;509
000082  f7fffffe          BL       GPIO_Set_DATA
                  |L31.134|
000086  f64f78ff          MOV      r8,#0xffff            ;512
00008a  e004              B        |L31.150|
                  |L31.140|
00008c  6820              LDR      r0,[r4,#0]            ;519  ; tProtocolCtrl
00008e  7845              LDRB     r5,[r0,#1]            ;519
000090  2d00              CMP      r5,#0                 ;520
000092  bf18              IT       NE                    ;520
000094  7047              STRBNE   r7,[r0,#1]            ;520
                  |L31.150|
;;;529    			break;
;;;530    		}
;;;531    
;;;532    		if( thisInfo->eEventTriggerType != tProtocolCtrl.setter->eEventTriggerType )
000096  6870              LDR      r0,[r6,#4]  ; thisInfo
000098  7801              LDRB     r1,[r0,#0]
00009a  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
00009c  7840              LDRB     r0,[r0,#1]
00009e  4281              CMP      r1,r0
0000a0  d01e              BEQ      |L31.224|
;;;533    		{
;;;534    			thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
0000a2  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
0000a4  7841              LDRB     r1,[r0,#1]
0000a6  6870              LDR      r0,[r6,#4]  ; thisInfo
0000a8  7001              STRB     r1,[r0,#0]
0000aa  b2c8              UXTB     r0,r1
0000ac  2801              CMP      r0,#1
0000ae  d005              BEQ      |L31.188|
0000b0  2802              CMP      r0,#2
0000b2  bf04              ITT      EQ
0000b4  6820              LDREQ    r0,[r4,#0]  ; tProtocolCtrl
0000b6  7047              STRBEQ   r7,[r0,#1]
;;;535    			protocol_swip_ClearEventInterrupt();
;;;536    			break;
;;;537    		}
;;;538    	}
;;;539    	while (intr);
;;;540    }
0000b8  e8bd81f0          POP      {r4-r8,pc}
                  |L31.188|
0000bc  f7fffffe          BL       CheckI2CReady
0000c0  2800              CMP      r0,#0
0000c2  bf18              IT       NE
0000c4  e8bd81f0          POPNE    {r4-r8,pc}
0000c8  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
0000ca  7840              LDRB     r0,[r0,#1]
0000cc  2801              CMP      r0,#1
0000ce  bf18              IT       NE
0000d0  e8bd81f0          POPNE    {r4-r8,pc}
0000d4  2101              MOVS     r1,#1
0000d6  e8bd41f0          POP      {r4-r8,lr}
0000da  2004              MOVS     r0,#4
0000dc  f7ffbffe          B.W      GPIO_Set_DATA
                  |L31.224|
0000e0  2d00              CMP      r5,#0                 ;539
0000e2  d195              BNE      |L31.16|
0000e4  e8bd81f0          POP      {r4-r8,pc}
;;;541    
                          ENDP

                  |L31.232|
                          DCD      ||.data||
                  |L31.236|
                          DCD      tProtocolCtrl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ktSWIPInfoPanel
                          %        22

                          AREA ||area_number.34||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.34||, ||.bss||
                  ktSWIPInfoFirmwareIntegrity
                          %        12

                          AREA ||area_number.35||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.35||, ||.bss||
                  ktSWIPInfoTrimCode
                          %        64

                          AREA ||area_number.36||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.36||, ||.bss||
                  ptPacketInfoQueue
                          %        462

                          AREA ||.data||, DATA, ALIGN=2

                  thisCommonConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  sptAlgorithmInfo
                          DCD      0x00000000
                  tSWIPEvent
                          DCD      tSWIPEventFormat
                          DCD      0x00000000
                  tSWIPInfo
                          DCD      ktSWIPInfoPanel
                          DCD      ktSWIPInfoFirmwareSectionVersion
                          DCD      ktSWIPInfoFirmwareSectionAddress
                          DCD      ktSWIPInfoFirmwareIntegrity
                          DCD      ktSWIPInfoInterface
                          DCD      ktSWIPInfoExtra
                          DCD      ktSWIPInfoTrimCode
                  tSWIPTest
                          DCD      ktSWIPTestInfo
                          DCD      ktSWIPTestControl
                          DCD      0x00000000
                  tSWIPBufferInfo
                          DCD      vtProtocolBufferPointers
                          DCD      ktProtocolBufferStartAddr
                          DCD      0x00000002
                  vtMRmiMap
                          DCD      0x00000000
                          DCD      ktSubsetInfo
                          DCD      ktSubsetEvent
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ktSubsetCtrl
                          DCD      0x00000000
                          DCD      ktSubsetParam
                          DCD      0x00000000
                          DCD      ktSubsetTest
                          DCD      0x00000000
                          DCD      ktSubsetImage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ktSubsetLog
                          DCD      0x00000000
                          DCD      ktSubsetSpecialAction
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||area_number.39||, DATA, ALIGN=0

                          EXPORTAS ||area_number.39||, ||.data||
                  ktSWIPInfoInterface
000000  53574950          DCB      0x53,0x57,0x49,0x50
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  011029bd          DCWU     0x0110,0x29bd
00000c  9302              DCWU     0x9302

                          AREA ||area_number.40||, DATA, ALIGN=0

                          EXPORTAS ||area_number.40||, ||.data||
                  ptDummyPacketInfo
000000  0000              DCWU     0x0000
000002  0100              DCB      0x01,0x00
                          %        56
00003c  00000000          DCB      0x00,0x00,0x00,0x00
000040  0000              DCWU     0x0000

                          AREA ||area_number.41||, DATA, ALIGN=0

                          EXPORTAS ||area_number.41||, ||.data||
                  ktSWIPTestInfo
000000  20000001          DCWU     0x2000,0x0001

                          AREA ||area_number.42||, DATA, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.data||
                  ktSWIPTestControl
000000  ff000000          DCB      0xff,0x00,0x00,0x00
000004  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  ktSWIPControlForTuning
000000  0000ff00          DCB      0x00,0x00,0xff,0x00

                          AREA ||area_number.44||, DATA, ALIGN=0

                          EXPORTAS ||area_number.44||, ||.data||
                  tSWIPSpecialAction
                          DCDU     ktSWIPControlForTuning
                          DCDU     0x00000000
                          DCDU     0x00000000

                          AREA ||area_number.45||, DATA, ALIGN=0

                          EXPORTAS ||area_number.45||, ||.data||
                  ktSWIPParameterInfo
000000  60000001          DCWU     0x6000,0x0001

                          AREA ||area_number.46||, DATA, ALIGN=0

                          EXPORTAS ||area_number.46||, ||.data||
                  tSWIPParameter
                          DCDU     ktSWIPParameterInfo

                          AREA ||area_number.47||, DATA, ALIGN=1

                          EXPORTAS ||area_number.47||, ||.data||
                  ktProtocolBufferStartAddr
000000  20006000          DCW      0x2000,0x6000

                          AREA ||area_number.48||, DATA, ALIGN=0

                          EXPORTAS ||area_number.48||, ||.data||
                  SWIP_REG_ADDR_INFO_LOWER_ADDR
000000  00203040          DCB      0x00,0x20,0x30,0x40
000004  5070a0c0          DCB      0x50,0x70,0xa0,0xc0

                          AREA ||area_number.49||, DATA, ALIGN=0

                          EXPORTAS ||area_number.49||, ||.data||
                  SWIP_REG_ADDR_EVENT_LOWER_ADDR
000000  001011            DCB      0x00,0x10,0x11

                          AREA ||area_number.50||, DATA, ALIGN=0

                          EXPORTAS ||area_number.50||, ||.data||
                  SWIP_REG_ADDR_CTRL_LOWER_ADDR
000000  0010              DCB      0x00,0x10

                          AREA ||area_number.51||, DATA, ALIGN=0

                          EXPORTAS ||area_number.51||, ||.data||
                  SWIP_REG_ADDR_PARAMETER_LOWER_ADDR
000000  00                DCB      0x00

                          AREA ||area_number.52||, DATA, ALIGN=0

                          EXPORTAS ||area_number.52||, ||.data||
                  SWIP_REG_ADDR_TEST_LOWER_ADDR
000000  001020            DCB      0x00,0x10,0x20

                          AREA ||area_number.53||, DATA, ALIGN=0

                          EXPORTAS ||area_number.53||, ||.data||
                  SWIP_REG_ADDR_IMAGE_LOWER_ADDR
000000  00102030          DCB      0x00,0x10,0x20,0x30
000004  31                DCB      0x31

                          AREA ||area_number.54||, DATA, ALIGN=0

                          EXPORTAS ||area_number.54||, ||.data||
                  SWIP_REG_ADDR_LOG_LOWER_ADDR
000000  001020            DCB      0x00,0x10,0x20

                          AREA ||area_number.55||, DATA, ALIGN=0

                          EXPORTAS ||area_number.55||, ||.data||
                  SWIP_REG_ADDR_SPECIAL_ACTION_LOWER_ADDR
000000  001030            DCB      0x00,0x10,0x30

                          AREA ||area_number.56||, DATA, ALIGN=0

                          EXPORTAS ||area_number.56||, ||.data||
                  ktSubsetInfo
                          DCDU     tSWIPInfo
                          DCDU     SWIP_REG_ADDR_INFO_LOWER_ADDR
                          DCDU     0x00000007

                          AREA ||area_number.57||, DATA, ALIGN=0

                          EXPORTAS ||area_number.57||, ||.data||
                  ktSubsetEvent
                          DCDU     tSWIPEvent
                          DCDU     SWIP_REG_ADDR_EVENT_LOWER_ADDR
                          DCDU     0x00000002

                          AREA ||area_number.58||, DATA, ALIGN=0

                          EXPORTAS ||area_number.58||, ||.data||
                  ktSubsetCtrl
                          DCDU     tProtocolCtrl
                          DCDU     SWIP_REG_ADDR_CTRL_LOWER_ADDR
                          DCDU     0x00000002

                          AREA ||area_number.59||, DATA, ALIGN=0

                          EXPORTAS ||area_number.59||, ||.data||
                  ktSubsetParam
                          DCDU     tSWIPParameter
                          DCDU     SWIP_REG_ADDR_PARAMETER_LOWER_ADDR
                          DCDU     0x00000001

                          AREA ||area_number.60||, DATA, ALIGN=0

                          EXPORTAS ||area_number.60||, ||.data||
                  ktSubsetTest
                          DCDU     tSWIPTest
                          DCDU     SWIP_REG_ADDR_TEST_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.61||, DATA, ALIGN=0

                          EXPORTAS ||area_number.61||, ||.data||
                  ktSubsetImage
                          DCDU     tProtocolImage
                          DCDU     SWIP_REG_ADDR_IMAGE_LOWER_ADDR
                          DCDU     0x00000005

                          AREA ||area_number.62||, DATA, ALIGN=0

                          EXPORTAS ||area_number.62||, ||.data||
                  ktSubsetLog
                          DCDU     tProtocolLog
                          DCDU     SWIP_REG_ADDR_LOG_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.63||, DATA, ALIGN=0

                          EXPORTAS ||area_number.63||, ||.data||
                  ktSubsetSpecialAction
                          DCDU     tSWIPSpecialAction
                          DCDU     SWIP_REG_ADDR_SPECIAL_ACTION_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.64||, DATA, ALIGN=0

                          EXPORTAS ||area_number.64||, ||.data||
                  ktSWIPInfoFirmwareSectionVersion
                          DCDU     0x00000000
000004  0000              DCB      0x00,0x00

                          AREA ||area_number.65||, DATA, ALIGN=0

                          EXPORTAS ||area_number.65||, ||.data||
                  ktSWIPInfoFirmwareSectionAddress
                          DCDU     0x00000000
000004  0000              DCB      0x00,0x00

                          AREA ||area_number.66||, DATA, ALIGN=0

                          EXPORTAS ||area_number.66||, ||.data||
                  ktSWIPInfoExtra
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.67||, DATA, ALIGN=0

                          EXPORTAS ||area_number.67||, ||.data||
                  tSWIPEventFormat
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Protocol\\protocol_swip.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___15_protocol_swip_c_c9478dad____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____REVSH|
#line 402
|__asm___15_protocol_swip_c_c9478dad____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____RRX|
#line 587
|__asm___15_protocol_swip_c_c9478dad____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
