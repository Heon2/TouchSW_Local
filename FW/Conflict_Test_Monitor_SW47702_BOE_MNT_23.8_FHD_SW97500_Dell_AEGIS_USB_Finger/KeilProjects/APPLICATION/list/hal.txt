; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\hal.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\hal.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\hal.crf ..\..\Hal\hal.c]
                          THUMB

                          AREA ||i.HAL_Change_S3_VDD_OddEven_Stauts||, CODE, READONLY, ALIGN=2

                  HAL_Change_S3_VDD_OddEven_Stauts PROC
;;;296    
;;;297    void HAL_Change_S3_VDD_OddEven_Stauts(void)
000000  b510              PUSH     {r4,lr}
000002  4c15              LDR      r4,|L1.88|
000004  6820              LDR      r0,[r4,#0]  ; ptHalInfo
000006  6a01              LDR      r1,[r0,#0x20]
000008  2904              CMP      r1,#4
;;;298    {
00000a  d202              BCS      |L1.18|
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  1c49              ADDS     r1,r1,#1
000010  6201              STR      r1,[r0,#0x20]
                  |L1.18|
000012  6a01              LDR      r1,[r0,#0x20]
000014  2904              CMP      r1,#4
;;;299    	if(HAL_Get_S3_VDD_OddEven_Ctrl())
;;;300    	{
;;;301    		if(ptHalInfo->bIsS3VddOddEvenControlFrameCheckCnt < TPIC_S3_VDD_OE_INPUT_OUTPUT_CTRL_FRAME_CNT_THD)
;;;302    		{
;;;303    			ptHalInfo->bIsS3VddOddEvenControlFrameCheckCnt++;
;;;304    		}
;;;305    
;;;306    		if(ptHalInfo->bIsS3VddOddEvenControlFrameCheckCnt >= TPIC_S3_VDD_OE_INPUT_OUTPUT_CTRL_FRAME_CNT_THD)
;;;307    		{
;;;308    #if USED_S3_VDD_OE_INPUT_OUTPUT_ALWAYS_LOW_CTRL
;;;309    			GPIO_Set_DATA(_GPIO_VDDO_EVEN_CTRL, GPIO_DATA_LOW);
;;;310    #else /* USED_S3_VDD_OE_INPUT_OUTPUT_ALWAYS_LOW_CTRL */
;;;311    			GPIO_Set_DATA(_GPIO_VDDO_EVEN_CTRL, (GPIODATA_TypeDef)ptHalInfo->ucS3VddOddEvenStatus);
;;;312    #endif /* USED_S3_VDD_OE_INPUT_OUTPUT_ALWAYS_LOW_CTRL */
;;;313    			ptHalInfo->ucS3VddOddEvenStatus = (!ptHalInfo->ucS3VddOddEvenStatus);
;;;314    			ptHalInfo->bIsS3VddOddEvenControlFrameCheckCnt = 0;
;;;315    		}
;;;316    	}
;;;317    }
000016  bf38              IT       CC
000018  bd10              POPCC    {r4,pc}
00001a  7f01              LDRB     r1,[r0,#0x1c]
00001c  2900              CMP      r1,#0
00001e  bf08              IT       EQ
000020  bd10              POPEQ    {r4,pc}
000022  6a81              LDR      r1,[r0,#0x28]         ;301
000024  2928              CMP      r1,#0x28              ;301
000026  d202              BCS      |L1.46|
000028  6a81              LDR      r1,[r0,#0x28]         ;303
00002a  1c49              ADDS     r1,r1,#1              ;303
00002c  6281              STR      r1,[r0,#0x28]         ;303
                  |L1.46|
00002e  6a81              LDR      r1,[r0,#0x28]         ;306
000030  2928              CMP      r1,#0x28              ;306
000032  bf38              IT       CC
000034  bd10              POPCC    {r4,pc}
000036  f8901024          LDRB     r1,[r0,#0x24]         ;311
00003a  2005              MOVS     r0,#5                 ;311
00003c  f7fffffe          BL       GPIO_Set_DATA
000040  6820              LDR      r0,[r4,#0]            ;313  ; ptHalInfo
000042  f8901024          LDRB     r1,[r0,#0x24]         ;313
000046  2900              CMP      r1,#0                 ;313
000048  bf14              ITE      NE                    ;313
00004a  2100              MOVNE    r1,#0                 ;313
00004c  2101              MOVEQ    r1,#1                 ;313
00004e  f8801024          STRB     r1,[r0,#0x24]         ;313
000052  2100              MOVS     r1,#0                 ;314
000054  6281              STR      r1,[r0,#0x28]         ;314
000056  bd10              POP      {r4,pc}
;;;318    #endif /* USED_S3_VDD_OE_INPUT_OUTPUT_CTRL */
                          ENDP

                  |L1.88|
                          DCD      ||.data||

                          AREA ||i.HAL_CheckActivePenChangeType||, CODE, READONLY, ALIGN=2

                  HAL_CheckActivePenChangeType PROC
;;;1010   
;;;1011   bool_t HAL_CheckActivePenChangeType(void)
000000  b510              PUSH     {r4,lr}
;;;1012   {
;;;1013   	bool_t bReg = FALSE;
;;;1014   
;;;1015   	switch(ptHalInfo->ulActivePenChangeType)
000002  4c20              LDR      r4,|L2.132|
000004  2000              MOVS     r0,#0                 ;1013
000006  6821              LDR      r1,[r4,#0]  ; ptHalInfo
000008  f8911030          LDRB     r1,[r1,#0x30]
00000c  b1b1              CBZ      r1,|L2.60|
00000e  2901              CMP      r1,#1
000010  d026              BEQ      |L2.96|
000012  2902              CMP      r1,#2
;;;1016   	{
;;;1017   		case ACTIVEPEN_CHANGE_LOCAL_MS:
;;;1018   		{
;;;1019   			hal_Info_SetControlActivePenSettingType(ACTIVEPEN_TYPE_LOCAL_MS);
;;;1020   			PWMDRV_RegisterInit(HAL_GetSensingMode());
;;;1021   			PWMDRV_Cmd(ENABLE);
;;;1022   //			PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;1023   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHAGNE_MSPen_Local_Setting);
;;;1024   			hal_Info_SetControlActivePenOPType(ACTIVEPEN_TYPE_LOCAL_MS);
;;;1025   			bReg = TRUE;
;;;1026   			break;
;;;1027   		}
;;;1028   		case ACTIVEPEN_CHANGE_LOCAL_WACOM:
;;;1029   		{
;;;1030   			hal_Info_SetControlActivePenSettingType(ACTIVEPEN_TYPE_LOCAL_WACOM);
;;;1031   			PWMDRV_RegisterInit(HAL_GetSensingMode());
;;;1032   			PWMDRV_Cmd(ENABLE);
;;;1033   //			PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;1034   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHAGNE_WacomPen_Local_Setting);
;;;1035   			hal_Info_SetControlActivePenOPType(ACTIVEPEN_TYPE_LOCAL_WACOM);
;;;1036   			bReg = TRUE;
;;;1037   			break;
;;;1038   		}
;;;1039   		case ACTIVEPEN_CHANGE_LOCAL_WGP:
;;;1040   		{
;;;1041   			hal_Info_SetControlActivePenSettingType(ACTIVEPEN_TYPE_LOCAL_WGP);
;;;1042   			PWMDRV_RegisterInit(HAL_GetSensingMode());
;;;1043   			PWMDRV_Cmd(ENABLE);
;;;1044   //			PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;1045   			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHAGNE_WGPPen_Local_Setting);
;;;1046   			hal_Info_SetControlActivePenOPType(ACTIVEPEN_TYPE_LOCAL_WGP);
;;;1047   			bReg = TRUE;
;;;1048   			break;
;;;1049   		}
;;;1050   	}
;;;1051   
;;;1052   	return bReg;
;;;1053   }
000014  bf18              IT       NE
000016  bd10              POPNE    {r4,pc}
000018  2002              MOVS     r0,#2                 ;1041
00001a  f7fffffe          BL       hal_Info_SetControlActivePenSettingType
00001e  6820              LDR      r0,[r4,#0]            ;1041  ; ptHalInfo
000020  8840              LDRH     r0,[r0,#2]            ;1041
000022  f7fffffe          BL       PWMDRV_RegisterInit
000026  2001              MOVS     r0,#1                 ;1043
000028  f7fffffe          BL       PWMDRV_Cmd
00002c  2005              MOVS     r0,#5                 ;1045
00002e  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
000032  2002              MOVS     r0,#2                 ;1046
000034  f7fffffe          BL       hal_Info_SetControlActivePenOPType
000038  2001              MOVS     r0,#1                 ;1047
00003a  bd10              POP      {r4,pc}
                  |L2.60|
00003c  2000              MOVS     r0,#0                 ;1019
00003e  f7fffffe          BL       hal_Info_SetControlActivePenSettingType
000042  6820              LDR      r0,[r4,#0]            ;1019  ; ptHalInfo
000044  8840              LDRH     r0,[r0,#2]            ;1019
000046  f7fffffe          BL       PWMDRV_RegisterInit
00004a  2001              MOVS     r0,#1                 ;1021
00004c  f7fffffe          BL       PWMDRV_Cmd
000050  2007              MOVS     r0,#7                 ;1023
000052  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
000056  2000              MOVS     r0,#0                 ;1024
000058  f7fffffe          BL       hal_Info_SetControlActivePenOPType
00005c  2001              MOVS     r0,#1                 ;1025
00005e  bd10              POP      {r4,pc}
                  |L2.96|
000060  2001              MOVS     r0,#1                 ;1030
000062  f7fffffe          BL       hal_Info_SetControlActivePenSettingType
000066  6820              LDR      r0,[r4,#0]            ;1030  ; ptHalInfo
000068  8840              LDRH     r0,[r0,#2]            ;1030
00006a  f7fffffe          BL       PWMDRV_RegisterInit
00006e  2001              MOVS     r0,#1                 ;1032
000070  f7fffffe          BL       PWMDRV_Cmd
000074  2003              MOVS     r0,#3                 ;1034
000076  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
00007a  2001              MOVS     r0,#1                 ;1035
00007c  f7fffffe          BL       hal_Info_SetControlActivePenOPType
000080  2001              MOVS     r0,#1                 ;1036
000082  bd10              POP      {r4,pc}
;;;1054   
                          ENDP

                  |L2.132|
                          DCD      ||.data||

                          AREA ||i.HAL_CheckActivePenTypeSwap||, CODE, READONLY, ALIGN=2

                  HAL_CheckActivePenTypeSwap PROC
;;;1054   
;;;1055   bool_t HAL_CheckActivePenTypeSwap(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1056   {
;;;1057   	bool_t bReg = FALSE;
;;;1058   	if(ptHalInfo->bIsPenDection)
000002  4e18              LDR      r6,|L3.100|
000004  2400              MOVS     r4,#0                 ;1057
000006  6830              LDR      r0,[r6,#0]  ; ptHalInfo
000008  f8901031          LDRB     r1,[r0,#0x31]
00000c  4625              MOV      r5,r4
00000e  2900              CMP      r1,#0
;;;1059   	{
;;;1060   		ptHalInfo->ulPenTypeSwapCheckFrameCnt = 0;
000010  bf18              IT       NE
000012  6345              STRNE    r5,[r0,#0x34]
000014  d123              BNE      |L3.94|
;;;1061   	}
;;;1062   	else
;;;1063   	{
;;;1064   		if(ptHalInfo->bIsPenTypeSwapCheckStart)
000016  f8901032          LDRB     r1,[r0,#0x32]
00001a  b1e1              CBZ      r1,|L3.86|
;;;1065   		{
;;;1066   			eActivePenType_t ePenOPType = hal_Info_GetControlActivePenOPType();
00001c  f7fffffe          BL       hal_Info_GetControlActivePenOPType
;;;1067   			ptHalInfo->ulPenTypeSwapCheckFrameCnt++;
000020  6831              LDR      r1,[r6,#0]  ; ptHalInfo
000022  6b4a              LDR      r2,[r1,#0x34]
000024  1c52              ADDS     r2,r2,#1
000026  634a              STR      r2,[r1,#0x34]
;;;1068   			switch(ePenOPType)
000028  b120              CBZ      r0,|L3.52|
00002a  2801              CMP      r0,#1
00002c  bf18              IT       NE
00002e  2802              CMPNE    r0,#2
000030  d007              BEQ      |L3.66|
000032  e014              B        |L3.94|
                  |L3.52|
;;;1069   			{
;;;1070   				case ACTIVEPEN_TYPE_LOCAL_MS:
;;;1071   				{
;;;1072   					if(ptHalInfo->ulPenTypeSwapCheckFrameCnt >= ptHalInfo->ulMSPenIdleOpFrameNumTHD)
000034  6b48              LDR      r0,[r1,#0x34]
000036  6b8a              LDR      r2,[r1,#0x38]
000038  4290              CMP      r0,r2
;;;1073   					{
;;;1074   						ptHalInfo->ulPenTypeSwapCheckFrameCnt = 0;
00003a  bf28              IT       CS
00003c  634d              STRCS    r5,[r1,#0x34]
00003e  d30e              BCC      |L3.94|
000040  e007              B        |L3.82|
                  |L3.66|
;;;1075   #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN)
;;;1076   						HAL_SetActivePenChagneType(ACTIVEPEN_CHANGE_LOCAL_WACOM);
;;;1077   #elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;1078   						HAL_SetActivePenChagneType(ACTIVEPEN_CHANGE_LOCAL_WGP);
;;;1079   #endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) */
;;;1080   						bReg = TRUE;
;;;1081   					}
;;;1082   					break;
;;;1083   				}
;;;1084   				case ACTIVEPEN_TYPE_LOCAL_WACOM:
;;;1085   				case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;1086   				{
;;;1087   					if(ptHalInfo->ulPenTypeSwapCheckFrameCnt >= ptHalInfo->ulWacomPenIdleOpFrameNumTHD)
000042  6b48              LDR      r0,[r1,#0x34]
000044  6bca              LDR      r2,[r1,#0x3c]
000046  4290              CMP      r0,r2
;;;1088   					{
;;;1089   						ptHalInfo->ulPenTypeSwapCheckFrameCnt = 0;
000048  bf24              ITT      CS
00004a  634d              STRCS    r5,[r1,#0x34]
00004c  f8815030          STRBCS   r5,[r1,#0x30]
000050  d305              BCC      |L3.94|
                  |L3.82|
000052  2401              MOVS     r4,#1                 ;1080
000054  e003              B        |L3.94|
                  |L3.86|
;;;1090   						HAL_SetActivePenChagneType(ACTIVEPEN_CHANGE_LOCAL_MS);
;;;1091   						bReg = TRUE;
;;;1092   					}
;;;1093   					break;
;;;1094   				}
;;;1095   			}
;;;1096   		}
;;;1097   		else if(ptHalInfo->ulActivePenChangeType != ACTIVEPEN_CHANGE_DONE)
000056  f8900030          LDRB     r0,[r0,#0x30]
00005a  2803              CMP      r0,#3
00005c  d1f9              BNE      |L3.82|
                  |L3.94|
;;;1098   		{
;;;1099   			bReg = TRUE;
;;;1100   		}
;;;1101   	}
;;;1102   
;;;1103   	return bReg;
00005e  4620              MOV      r0,r4
;;;1104   }
000060  bd70              POP      {r4-r6,pc}
;;;1105   
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
                          DCD      ||.data||

                          AREA ||i.HAL_CheckBootInterfaceInfoOnSecurityRegion||, CODE, READONLY, ALIGN=2

                  HAL_CheckBootInterfaceInfoOnSecurityRegion PROC
;;;1190    */
;;;1191   void HAL_CheckBootInterfaceInfoOnSecurityRegion(void)
000000  b510              PUSH     {r4,lr}
;;;1192   {
;;;1193   	if(FLITF_EnsureBootInterfaceCodeFlashIntegrity() == NO)
000002  f7fffffe          BL       FLITF_EnsureBootInterfaceCodeFlashIntegrity
000006  2800              CMP      r0,#0
;;;1194   	{
;;;1195   		tSimpleBootFlashCtrlInfo_t * pSimpleBootFlashCtrlInfo = (tSimpleBootFlashCtrlInfo_t *)SRAM_SIMPLE_BOOT_CTRL_INFO_ADDR;
;;;1196   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceId.BOOT_VID = UNIQUE_VID;
;;;1197   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceId.BOOT_PID = UNIQUE_BOOT_PID;
;;;1198   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceInfo.BOOT_I2C_SLV_ADDR = I2C_ADDRESS;
;;;1199   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.tDeviceInfo.APP_KBYTE_SIZE = FLASH_APPLICATION_KBYTE_SIZE;
;;;1200   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.BOOT_INFO_WRITE_EN_CODE = EFLASH_BOOT_INFO_WRITE_EN_CODE;
;;;1201   		pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo.CheckSum = FLITF_Calc32bitCheckSum((uint32_t *)&pSimpleBootFlashCtrlInfo->tFlashBootInterfaceInfo, (EFLASH_VID_PID_I2CSLV_WORD_SIZE - 1));
;;;1202   
;;;1203   		pSimpleBootFlashCtrlInfo->ulFlashUpdateType = SIMPLE_BOOT_FLASH_UPDATE_HOST_INTERFACE;
;;;1204   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_VTRIM = SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_VTRIM;
;;;1205   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_ITRIM = SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_ITRIM;
;;;1206   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim2.R_LDO_TRIM = SCRB->SYS_ANA_TRIM.tBit.R_LDO_TRIM;
;;;1207   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VBGR_CTL = SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VBGR_CTL;
;;;1208   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_IREF_TRIM = SCRB->SYS_ANA_TRIM.tBit.R_MAIN_IREF_TRIM;
;;;1209   		pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VREF_TRIM = SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VREF_TRIM;
;;;1210   
;;;1211   		FLITF_FlashInformationRegionWriteOperation();
;;;1212   	}
;;;1213   }
000008  bf18              IT       NE
00000a  bd10              POPNE    {r4,pc}
00000c  4c1f              LDR      r4,|L4.140|
00000e  f64210bd          MOV      r0,#0x29bd            ;1196
000012  2103              MOVS     r1,#3                 ;1201
000014  80a0              STRH     r0,[r4,#4]            ;1196
000016  f2477002          MOV      r0,#0x7702            ;1197
00001a  80e0              STRH     r0,[r4,#6]            ;1197
00001c  2009              MOVS     r0,#9                 ;1198
00001e  7220              STRB     r0,[r4,#8]            ;1198
000020  2074              MOVS     r0,#0x74              ;1199
000022  7260              STRB     r0,[r4,#9]            ;1199
000024  481a              LDR      r0,|L4.144|
000026  60e0              STR      r0,[r4,#0xc]          ;1200
000028  1d20              ADDS     r0,r4,#4              ;1201
00002a  342e              ADDS     r4,r4,#0x2e           ;1201
00002c  f7fffffe          BL       FLITF_Calc32bitCheckSum
000030  f8440c1e          STR      r0,[r4,#-0x1e]        ;1201
000034  f44f6070          MOV      r0,#0xf00             ;1203
000038  f8440c2e          STR      r0,[r4,#-0x2e]        ;1203
00003c  f04f4080          MOV      r0,#0x40000000        ;1204
000040  6ac1              LDR      r1,[r0,#0x2c]         ;1204
000042  7da2              LDRB     r2,[r4,#0x16]         ;1204
000044  f3610205          BFI      r2,r1,#0,#6           ;1204
000048  75a2              STRB     r2,[r4,#0x16]         ;1204
00004a  6ac1              LDR      r1,[r0,#0x2c]         ;1205
00004c  098a              LSRS     r2,r1,#6              ;1205
00004e  8ae1              LDRH     r1,[r4,#0x16]         ;1205
000050  f3621188          BFI      r1,r2,#6,#3           ;1205
000054  82e1              STRH     r1,[r4,#0x16]         ;1205
000056  6ac1              LDR      r1,[r0,#0x2c]         ;1206
000058  0a4a              LSRS     r2,r1,#9              ;1206
00005a  7ea1              LDRB     r1,[r4,#0x1a]         ;1206
00005c  f3620104          BFI      r1,r2,#0,#5           ;1206
000060  76a1              STRB     r1,[r4,#0x1a]         ;1206
000062  6ac1              LDR      r1,[r0,#0x2c]         ;1207
000064  0c0a              LSRS     r2,r1,#16             ;1207
000066  7fa1              LDRB     r1,[r4,#0x1e]         ;1207
000068  f3620102          BFI      r1,r2,#0,#3           ;1207
00006c  6ac2              LDR      r2,[r0,#0x2c]         ;1208
00006e  0cd2              LSRS     r2,r2,#19             ;1208
000070  f36201c7          BFI      r1,r2,#3,#5           ;1208
000074  77a1              STRB     r1,[r4,#0x1e]         ;1208
000076  6ac0              LDR      r0,[r0,#0x2c]         ;1209
000078  0e01              LSRS     r1,r0,#24             ;1209
00007a  7fe0              LDRB     r0,[r4,#0x1f]         ;1209
00007c  f3610003          BFI      r0,r1,#0,#4           ;1209
000080  77e0              STRB     r0,[r4,#0x1f]         ;1209
000082  e8bd4010          POP      {r4,lr}               ;1211
000086  f7ffbffe          B.W      FLITF_FlashInformationRegionWriteOperation
;;;1214   #if USED_LPWG_MCU_SLEEP
                          ENDP

00008a  0000              DCW      0x0000
                  |L4.140|
                          DCD      0x20010000
                  |L4.144|
                          DCD      0x4a4d4801

                          AREA ||i.HAL_CheckSensningModeChange||, CODE, READONLY, ALIGN=2

                  HAL_CheckSensningModeChange PROC
;;;779    
;;;780    bool_t HAL_CheckSensningModeChange(eSENSING_CHANGE_MODE_t mode)
000000  4602              MOV      r2,r0
000002  483b              LDR      r0,|L5.240|
;;;781    {
000004  b510              PUSH     {r4,lr}
000006  6800              LDR      r0,[r0,#0]  ; ptHalInfo
;;;782    	bool_t bIsModeChange = YES;
000008  2401              MOVS     r4,#1
00000a  8841              LDRH     r1,[r0,#2]
;;;783    #if USED_S3_ALL_MUX_SHORT
;;;784    	const tModuleSRICCommonConf_t * pktmoduleSRICCommonConf;
;;;785    	pktmoduleSRICCommonConf = module_SRIC_GetCommonConfig();
;;;786    #endif /* USED_S3_ALL_MUX_SHORT */
;;;787    	eSENSING_MODE_t ePastSensingMode = HAL_GetSensingMode();
;;;788    
;;;789    	switch(mode)
00000c  2a0b              CMP      r2,#0xb
00000e  d26c              BCS      |L5.234|
000010  e8dff002          TBB      [pc,r2]
000014  6b6c061b          DCB      0x6b,0x6c,0x06,0x1b
000018  2f6c6c42          DCB      0x2f,0x6c,0x6c,0x42
00001c  52636700          DCB      0x52,0x63,0x67,0x00
;;;790    	{
;;;791    		case SM_CHANGE_IDLE_MODE:
;;;792    		{
;;;793    //			if(IS_S3_MODE(ePastSensingMode))
;;;794    //			{
;;;795    //				tTimerOpHandleInfo_t tTimerHandle;
;;;796    //				TIMER_StopTimer(TIMER_1UNIT);
;;;797    //#if USED_S3_ALL_MUX_SHORT
;;;798    //				{
;;;799    //					/*
;;;800    //					 * S3 Idle All Mux Short적용!!
;;;801    //					 */
;;;802    //					tSRIC_CFGR_CHIP0_LEN_t tParam_CHIP0_LEN;
;;;803    //					tParam_CHIP0_LEN.ulBulk = pktmoduleSRICCommonConf->tParam_CHIP0_LEN.ulBulk;
;;;804    //					tParam_CHIP0_LEN.tBit.tie1_cmux = 1;
;;;805    //					SW92501_Set_Register(CHIP0_LEN, pktmoduleSRICCommonConf->tParam_CHIP0_LEN.ulBulk, ROIC_0);
;;;806    //					PWMDRV_Set_Pulse_Config(SM_S3_IDLE_MODE);
;;;807    //				}
;;;808    //#endif /* USED_S3_ALL_MUX_SHORT */
;;;809    //				tTimerHandle.ulTimerUnit = TIMER_1UNIT;
;;;810    //#if USED_ECLK_ON_OFF_CONTROL
;;;811    //	#if USED_S3_ALL_MUX_SHORT
;;;812    //				tTimerHandle.ulLoadCount = 78260,//94660;//44650; // 60Hz //44650;//(3 * (1000000/20));//16.6msec //50012;
;;;813    //	#else /* USED_S3_ALL_MUX_SHORT */
;;;814    //				tTimerHandle.ulLoadCount = 89360,//94660;//44650; // 60Hz //44650;//(3 * (1000000/20));//16.6msec //50012;
;;;815    //	#endif/* USED_S3_ALL_MUX_SHORT */
;;;816    //#else /* USED_ECLK_ON_OFF_CONTROL */
;;;817    //				tTimerHandle.ulLoadCount = 150000,//94660;//44650; // 60Hz //44650;//(3 * (1000000/20));//16.6msec //50012;
;;;818    //#endif /* USED_ECLK_ON_OFF_CONTROL */
;;;819    //				TIMER_SetPeriodicMode(&tTimerHandle);
;;;820    //				TIMER_StartTimer(TIMER_1UNIT);
;;;821    //				HAL_SetSensingMode(SM_S3_IDLE_MODE);
;;;822    //			}
;;;823    #if USED_IDLE_MODE_CONTROL
;;;824    			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
;;;825    			{
;;;826    				PWMDRV_RegisterInit(SM_FINGER_ONLY_IDLE_MODE);
;;;827    				PWMDRV_Cmd(ENABLE);
;;;828    				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FINGER_PEN_FULL_IDLE);
;;;829    				HAL_SetSensingMode(SM_FINGER_ONLY_IDLE_MODE);
;;;830    			}
;;;831    #endif /* USED_IDLE_MODE_CONTROL */
;;;832    #if USED_LOCAL_IDLE_MODE_CONTROL
;;;833    			if(IS_FINGER_PEN_MODE(ePastSensingMode))
;;;834    			{
;;;835    				PWMDRV_RegisterInit(SM_FINGER_PEN_IDLE_MODE);
;;;836    				PWMDRV_Cmd(ENABLE);
;;;837    				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FINGER_PEN_LOCAL_IDLE);
;;;838    				HAL_SetSensingMode(SM_FINGER_PEN_IDLE_MODE);
;;;839    			}
;;;840    #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;841    			break;
;;;842    		}
;;;843    		case SM_CHANGE_ACTIVE_MODE:
;;;844    		{
;;;845    			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
000020  f4115f80          TST      r1,#0x1000
000024  d062              BEQ      |L5.236|
;;;846    			{
;;;847    				PWMDRV_RegisterInit(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
000026  f2410003          MOV      r0,#0x1003
00002a  f7fffffe          BL       PWMDRV_RegisterInit
;;;848    				PWMDRV_Cmd(ENABLE);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       PWMDRV_Cmd
;;;849    				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FINGER_PEN_FULL);
000034  200b              MOVS     r0,#0xb
000036  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
00003a  492d              LDR      r1,|L5.240|
;;;850    				HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
00003c  f2410003          MOV      r0,#0x1003
000040  6809              LDR      r1,[r1,#0]  ; ptHalInfo
000042  2900              CMP      r1,#0
000044  bf18              IT       NE
000046  8048              STRHNE   r0,[r1,#2]
000048  e050              B        |L5.236|
;;;851    			}
;;;852    			break;
;;;853    		}
;;;854    		case SM_CHANGE_ACTIVE_FRQ_MAIN_MODE:
;;;855    		{
;;;856    #if USED_NOISE_HOPPING_FREQ
;;;857    			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
00004a  f4115f80          TST      r1,#0x1000
00004e  d04d              BEQ      |L5.236|
;;;858    			{
;;;859    				PWMDRV_RegisterInit(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
000050  f2410003          MOV      r0,#0x1003
000054  f7fffffe          BL       PWMDRV_RegisterInit
;;;860    				PWMDRV_Cmd(ENABLE);
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       PWMDRV_Cmd
;;;861    				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FREQ_MAIN_FINGER_PEN_FULL);
00005e  200d              MOVS     r0,#0xd
000060  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
000064  4822              LDR      r0,|L5.240|
;;;862    				HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
000066  f2410103          MOV      r1,#0x1003
00006a  6800              LDR      r0,[r0,#0]  ; ptHalInfo
00006c  2800              CMP      r0,#0
00006e  d03d              BEQ      |L5.236|
000070  e031              B        |L5.214|
;;;863    			}
;;;864    #endif
;;;865    			break;
;;;866    		}
;;;867    		case SM_CHANGE_ACTIVE_FRQ_HOP1_MODE:
;;;868    		{
;;;869    #if USED_NOISE_HOPPING_FREQ
;;;870    			if(IS_FINGER_ONLY_MODE(ePastSensingMode))
000072  f4115f80          TST      r1,#0x1000
000076  d039              BEQ      |L5.236|
;;;871    			{
;;;872    				PWMDRV_RegisterInit(SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE);
000078  f2410005          MOV      r0,#0x1005
00007c  f7fffffe          BL       PWMDRV_RegisterInit
;;;873    				PWMDRV_Cmd(ENABLE);
000080  2001              MOVS     r0,#1
000082  f7fffffe          BL       PWMDRV_Cmd
;;;874    				SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FREQ_HOPP1_FINGER_PEN_FULL);
000086  200e              MOVS     r0,#0xe
000088  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
00008c  4818              LDR      r0,|L5.240|
;;;875    				HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE);
00008e  f2410105          MOV      r1,#0x1005
000092  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000094  b300              CBZ      r0,|L5.216|
000096  e01e              B        |L5.214|
;;;876    			}
;;;877    #endif
;;;878    			break;
;;;879    		}
;;;880    		case SM_CHANGE_ACTIVE_FRQ_HOP2_MODE:
;;;881    		{
;;;882    			break;
;;;883    		}
;;;884    //		case SM_CHANGE_S3_MODE:
;;;885    //		{
;;;886    //			break;
;;;887    //		}
;;;888    		case SM_CHANGE_FINGER_ONLY_MODE:
;;;889    		{
;;;890    			break;
;;;891    		}
;;;892    		case SM_CHANGE_FINGER_PEN_SEARCH_MODE:
;;;893    		{
;;;894    			PWMDRV_RegisterInit(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE);
000098  f2420003          MOV      r0,#0x2003
00009c  f7fffffe          BL       PWMDRV_RegisterInit
;;;895    			PWMDRV_Cmd(ENABLE);
0000a0  2001              MOVS     r0,#1
0000a2  f7fffffe          BL       PWMDRV_Cmd
;;;896    //			PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;897    			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FINGER_PEN_FULL);
0000a6  200b              MOVS     r0,#0xb
0000a8  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
0000ac  4810              LDR      r0,|L5.240|
;;;898    //			SRIC_SetFingerPenFullModeChange(YES);
;;;899    			HAL_SetSensingMode(SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE);
0000ae  f2420103          MOV      r1,#0x2003
0000b2  6800              LDR      r0,[r0,#0]  ; ptHalInfo
0000b4  b180              CBZ      r0,|L5.216|
0000b6  e00e              B        |L5.214|
;;;900    			break;
;;;901    		}
;;;902    		case SM_CHANGE_FINGER_PEN_MODE:
;;;903    		{
;;;904    			PWMDRV_RegisterInit(SM_FINGER_PEN_ACTIVE_MODE);
0000b8  f2440001          MOV      r0,#0x4001
0000bc  f7fffffe          BL       PWMDRV_RegisterInit
;;;905    			PWMDRV_Cmd(ENABLE);
0000c0  2001              MOVS     r0,#1
0000c2  f7fffffe          BL       PWMDRV_Cmd
;;;906    //			PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;907    			SRIC_SetRuntimeChangeRegister(ROIC_REG_SET_CHANGE_FINGER_PEN_LOCAL_ACTIVE);
0000c6  2009              MOVS     r0,#9
0000c8  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
0000cc  4808              LDR      r0,|L5.240|
;;;908    //			SRIC_SetFingerPenFullModeChange(NO);
;;;909    			HAL_SetSensingMode(SM_FINGER_PEN_ACTIVE_MODE);
0000ce  f2440101          MOV      r1,#0x4001
0000d2  6800              LDR      r0,[r0,#0]  ; ptHalInfo
0000d4  b100              CBZ      r0,|L5.216|
                  |L5.214|
0000d6  8041              STRH     r1,[r0,#2]
                  |L5.216|
0000d8  e008              B        |L5.236|
0000da  7900              LDRB     r0,[r0,#4]
;;;910    			break;
;;;911    		}
;;;912    		case SM_CHANGE_DIAG_TEST:
;;;913    		{
;;;914    			SRIC_SetDiagTestOperationMode(HAL_GetDiagTestSensingChangeMode());
0000dc  f7fffffe          BL       SRIC_SetDiagTestOperationMode
;;;915    			break;
0000e0  e004              B        |L5.236|
0000e2  7940              LDRB     r0,[r0,#5]
;;;916    		}
;;;917    		case SM_CHANGE_ROIC_REG_VAL:
;;;918    		{
;;;919    			SRIC_SetRuntimeChangeRegister(HAL_GetROICRegSetChangeMode());
0000e4  f7fffffe          BL       SRIC_SetRuntimeChangeRegister
;;;920    			break;
0000e8  e000              B        |L5.236|
                  |L5.234|
;;;921    		}
;;;922    		case SM_CHANGE_COMPLETE:
;;;923    		default:
;;;924    		{
;;;925    			bIsModeChange = NO;
0000ea  2400              MOVS     r4,#0
                  |L5.236|
;;;926    			break;
;;;927    		}
;;;928    	}
;;;929    
;;;930    	return bIsModeChange;
0000ec  4620              MOV      r0,r4
;;;931    }
0000ee  bd10              POP      {r4,pc}
;;;932    
                          ENDP

                  |L5.240|
                          DCD      ||.data||

                          AREA ||i.HAL_ConfigInit||, CODE, READONLY, ALIGN=2

                  HAL_ConfigInit PROC
;;;690    
;;;691    void HAL_ConfigInit(bool_t bIsS3)
000000  4904              LDR      r1,|L6.20|
;;;692    {
;;;693    #if USED_PEN_MODE_OPERATION
;;;694    #if USED_INIT_PEN_MODE
;;;695    	ptHalInfo->eSensingMode = SM_FINGER_PEN_ACTIVE_MODE;
;;;696    #else /* USED_INIT_PEN_MODE */
;;;697    	ptHalInfo->eSensingMode = SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE;
;;;698    #endif /* USED_INIT_PEN_MODE */
;;;699    #else /* USED_PEN_MODE_OPERATION */
;;;700    	if(bIsS3)
000002  2800              CMP      r0,#0
;;;701    	{
;;;702    		ptHalInfo->eSensingMode = SM_S3_ACTIVE_MODE;
000004  6809              LDR      r1,[r1,#0]
000006  bf14              ITE      NE
000008  f6400001          MOVNE    r0,#0x801
;;;703    	}
;;;704    	else
;;;705    	{
;;;706    		ptHalInfo->eSensingMode = SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE;
00000c  f2410003          MOVEQ    r0,#0x1003
000010  8048              STRH     r0,[r1,#2]            ;702
;;;707    	}
;;;708    #endif /* USED_PEN_MODE_OPERATION */
;;;709    }
000012  4770              BX       lr
;;;710    
                          ENDP

                  |L6.20|
                          DCD      ||.data||

                          AREA ||i.HAL_ECLK_Off||, CODE, READONLY, ALIGN=2

                  HAL_ECLK_Off PROC
;;;190    
;;;191    void HAL_ECLK_Off(void)
000000  4803              LDR      r0,|L7.16|
;;;192    {
;;;193    #if USED_ECLK_FRQ_ADJUST_CONTROL
;;;194    	/*
;;;195    	 * Not Implementation
;;;196    	 */
;;;197    	PWMDRV->ECLK_CR.tBit.div_num = 3;
000002  f8501f8c          LDR      r1,[r0,#0x8c]!
000006  f42171f8          BIC      r1,r1,#0x1f0
00000a  3130              ADDS     r1,r1,#0x30
00000c  6001              STR      r1,[r0,#0]
;;;198    #else /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;199    	tCP_ECLK_CR_t tCP_ECLK_CR_TMP;
;;;200    	tCP_ECLK_CR_TMP.ulBulk = PWMDRV->ECLK_CR.ulBulk;
;;;201    	tCP_ECLK_CR_TMP.tBit.eclk_en = DISABLE;
;;;202    	tCP_ECLK_CR_TMP.tBit.eclk_force_on = DISABLE;
;;;203    	PWMDRV->ECLK_CR.ulBulk = tCP_ECLK_CR_TMP.ulBulk;
;;;204    #endif /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;205    }
00000e  4770              BX       lr
;;;206    #endif /* USED_ECLK_ON_OFF_CONTROL */
                          ENDP

                  |L7.16|
                          DCD      0x40002000

                          AREA ||i.HAL_ECLK_On||, CODE, READONLY, ALIGN=2

                  HAL_ECLK_On PROC
;;;174    
;;;175    void HAL_ECLK_On(void)
000000  4803              LDR      r0,|L8.16|
;;;176    {
;;;177    #if USED_ECLK_FRQ_ADJUST_CONTROL
;;;178    	/*
;;;179    	 * Not Implementation
;;;180    	 */
;;;181    	PWMDRV->ECLK_CR.tBit.div_num = 0;
000002  f8501f8c          LDR      r1,[r0,#0x8c]!
000006  f42171f8          BIC      r1,r1,#0x1f0
00000a  6001              STR      r1,[r0,#0]
;;;182    #else /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;183    	tCP_ECLK_CR_t tCP_ECLK_CR_TMP;
;;;184    	tCP_ECLK_CR_TMP.ulBulk = PWMDRV->ECLK_CR.ulBulk;
;;;185    	tCP_ECLK_CR_TMP.tBit.eclk_en = DISABLE;
;;;186    	tCP_ECLK_CR_TMP.tBit.eclk_force_on = ENABLE;
;;;187    	PWMDRV->ECLK_CR.ulBulk = tCP_ECLK_CR_TMP.ulBulk;
;;;188    #endif /* USED_ECLK_FRQ_ADJUST_CONTROL */
;;;189    }
00000c  4770              BX       lr
;;;190    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40002000

                          AREA ||i.HAL_GetBaseImagePointer||, CODE, READONLY, ALIGN=2

                  HAL_GetBaseImagePointer PROC
;;;932    
;;;933    uint16_t * HAL_GetBaseImagePointer(eSENSING_MODE_t mode, eBaseImageType_t type)
000000  b570              PUSH     {r4-r6,lr}
;;;934    {
000002  460e              MOV      r6,r1
000004  4605              MOV      r5,r0
;;;935    	uint16_t * pImage = NULL;
000006  2400              MOVS     r4,#0
;;;936    	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
000008  f7fffffe          BL       hal_Info_GetControlLocalFingerOPType
00000c  4602              MOV      r2,r0
;;;937    
;;;938    #if USED_MNT_S3_MODE_FUNCTION
;;;939    	if(IS_S3_MODE(mode))
;;;940    	{
;;;941    		pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
00000e  480e              LDR      r0,|L9.72|
000010  f4156f00          TST      r5,#0x800             ;939
000014  d115              BNE      |L9.66|
;;;942    	}
;;;943    	else
;;;944    #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;945    	{
;;;946    		if(IS_ACTIVE_MODE(mode))
000016  f0150f01          TST      r5,#1
00001a  d012              BEQ      |L9.66|
;;;947    		{
;;;948    			if(IS_ACTIVE_MODE_FRQ_HOP1(mode))
00001c  f0150f04          TST      r5,#4
;;;949    			{
;;;950    				if(type == BASELINE_TYPE_FULL)
;;;951    				{
;;;952    					//pImage = HAL_GET_HOPP1_BASELINE_IMAGE_PTR();	// leegc
;;;953    				}
;;;954    				else
;;;955    				{
;;;956    	//				pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;957    				}
;;;958    			}
;;;959    			else if(IS_ACTIVE_MODE_FRQ_HOP2(mode))
000020  bf04              ITT      EQ
000022  f0150f08          TSTEQ    r5,#8
;;;960    			{
;;;961    				if(type == BASELINE_TYPE_FULL)
;;;962    				{
;;;963    					//pImage = HAL_GET_HOPP2_BASELINE_IMAGE_PTR();	// leegc
;;;964    				}
;;;965    				else
;;;966    				{
;;;967    	//				pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;968    				}
;;;969    			}
;;;970    			else
;;;971    			{
;;;972    				if(type == BASELINE_TYPE_FULL)
000026  2e00              CMPEQ    r6,#0
000028  d10c              BNE      |L9.68|
00002a  4808              LDR      r0,|L9.76|
;;;973    				{
;;;974    					switch(eLocalFingerOPType)
00002c  2a00              CMP      r2,#0
;;;975    					{
;;;976    						case ACTIVEPEN_TYPE_LOCAL_MS:
;;;977    						{
;;;978    							pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
00002e  bf08              IT       EQ
000030  f50054e1          ADDEQ    r4,r0,#0x1c20
000034  d006              BEQ      |L9.68|
000036  2a01              CMP      r2,#1                 ;974
000038  bf14              ITE      NE                    ;974
00003a  2a02              CMPNE    r2,#2                 ;974
;;;979    							break;
;;;980    						}
;;;981    						case ACTIVEPEN_TYPE_LOCAL_WACOM:
;;;982    						case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;983    						{
;;;984    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;985    							pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;986    	#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;987    							pImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
00003c  f5005461          ADDEQ    r4,r0,#0x3840
000040  e000              B        |L9.68|
                  |L9.66|
;;;988    	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;989    							break;
;;;990    						}
;;;991    					}
;;;992    				}
;;;993    			}
;;;994    		}
;;;995    		else
;;;996    		{
;;;997    			pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
000042  4604              MOV      r4,r0
                  |L9.68|
;;;998    		}
;;;999    	}
;;;1000   
;;;1001   	return pImage;
000044  4620              MOV      r0,r4
;;;1002   }
000046  bd70              POP      {r4-r6,pc}
;;;1003   
                          ENDP

                  |L9.72|
                          DCD      FullSharedBuff+0xfc42
                  |L9.76|
                          DCD      FullSharedBuff

                          AREA ||i.HAL_GetDiagTestSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_GetDiagTestSensingChangeMode PROC
;;;738    
;;;739    eDIAG_TEST_CHANGE_MODE_t HAL_GetDiagTestSensingChangeMode(void)
000000  4801              LDR      r0,|L10.8|
;;;740    {
;;;741    	return ptHalInfo->eDiagTestChangeMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7900              LDRB     r0,[r0,#4]
;;;742    }
000006  4770              BX       lr
;;;743    
                          ENDP

                  |L10.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetECLKOnOffControl||, CODE, READONLY, ALIGN=2

                  HAL_GetECLKOnOffControl PROC
;;;157    
;;;158    bool_t HAL_GetECLKOnOffControl(void)
000000  4806              LDR      r0,|L11.28|
;;;159    {
;;;160    	if(ptHalInfo->bIsECLKOnOffStartCheckCnt < ECLK_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6881              LDR      r1,[r0,#8]
000006  2914              CMP      r1,#0x14
000008  d202              BCS      |L11.16|
;;;161    	{
;;;162    		ptHalInfo->bIsECLKOnOffStartCheckCnt++;
00000a  6881              LDR      r1,[r0,#8]
00000c  1c49              ADDS     r1,r1,#1
00000e  6081              STR      r1,[r0,#8]
                  |L11.16|
;;;163    	}
;;;164    
;;;165    	if(ptHalInfo->bIsECLKOnOffStartCheckCnt >= ECLK_ON_OFF_CONTROL_START_CNT_THD)
000010  6881              LDR      r1,[r0,#8]
000012  2914              CMP      r1,#0x14
;;;166    	{
;;;167    		return ptHalInfo->bIsECLKOnOffStart;
000014  bf2c              ITE      CS
000016  7980              LDRBCS   r0,[r0,#6]
;;;168    	}
;;;169    	else
;;;170    	{
;;;171    		return NO;
000018  2000              MOVCC    r0,#0
;;;172    	}
;;;173    }
00001a  4770              BX       lr
;;;174    
                          ENDP

                  |L11.28|
                          DCD      ||.data||

                          AREA ||i.HAL_GetROICRegSetChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_GetROICRegSetChangeMode PROC
;;;757    
;;;758    eROIC_REG_SET_CHANGE_MODE_t HAL_GetROICRegSetChangeMode(void)
000000  4801              LDR      r0,|L12.8|
;;;759    {
;;;760    	return ptHalInfo->eROICRegSetChangeMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7940              LDRB     r0,[r0,#5]
;;;761    }
000006  4770              BX       lr
;;;762    
                          ENDP

                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_GetSensingChangeMode PROC
;;;710    
;;;711    eSENSING_CHANGE_MODE_t HAL_GetSensingChangeMode(void)
000000  4801              LDR      r0,|L13.8|
;;;712    {
;;;713    	return ptHalInfo->eSensingChangeMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7800              LDRB     r0,[r0,#0]
;;;714    }
000006  4770              BX       lr
;;;715    
                          ENDP

                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetSensingMode||, CODE, READONLY, ALIGN=2

                  HAL_GetSensingMode PROC
;;;727    
;;;728    eSENSING_MODE_t HAL_GetSensingMode(void)
000000  4801              LDR      r0,|L14.8|
;;;729    {
;;;730    	return ptHalInfo->eSensingMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  8840              LDRH     r0,[r0,#2]
;;;731    }
000006  4770              BX       lr
;;;732    
                          ENDP

                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTPICMuxEnControl||, CODE, READONLY, ALIGN=2

                  HAL_GetTPICMuxEnControl PROC
;;;235    
;;;236    bool_t HAL_GetTPICMuxEnControl(void)
000000  4806              LDR      r0,|L15.28|
;;;237    {
;;;238    	if(ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt < TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6901              LDR      r1,[r0,#0x10]
000006  2914              CMP      r1,#0x14
000008  d202              BCS      |L15.16|
;;;239    	{
;;;240    		ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt++;
00000a  6901              LDR      r1,[r0,#0x10]
00000c  1c49              ADDS     r1,r1,#1
00000e  6101              STR      r1,[r0,#0x10]
                  |L15.16|
;;;241    	}
;;;242    
;;;243    	if(ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt >= TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD)
000010  6901              LDR      r1,[r0,#0x10]
000012  2914              CMP      r1,#0x14
;;;244    	{
;;;245    		return ptHalInfo->bIsTPICMuxEnOnOffStart;
000014  bf2c              ITE      CS
000016  7b00              LDRBCS   r0,[r0,#0xc]
;;;246    	}
;;;247    	else
;;;248    	{
;;;249    		return NO;
000018  2000              MOVCC    r0,#0
;;;250    	}
;;;251    }
00001a  4770              BX       lr
;;;252    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
                          ENDP

                  |L15.28|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTouchReportEnControl||, CODE, READONLY, ALIGN=2

                  HAL_GetTouchReportEnControl PROC
;;;333    
;;;334    bool_t HAL_GetTouchReportEnControl(void)
000000  4806              LDR      r0,|L16.28|
;;;335    {
;;;336    	if(ptHalInfo->bIsTouchReportOnOffStartCheckCnt < TOUCH_REPORT_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6981              LDR      r1,[r0,#0x18]
000006  2914              CMP      r1,#0x14
000008  d202              BCS      |L16.16|
;;;337    	{
;;;338    		ptHalInfo->bIsTouchReportOnOffStartCheckCnt++;
00000a  6981              LDR      r1,[r0,#0x18]
00000c  1c49              ADDS     r1,r1,#1
00000e  6181              STR      r1,[r0,#0x18]
                  |L16.16|
;;;339    	}
;;;340    
;;;341    	if(ptHalInfo->bIsTouchReportOnOffStartCheckCnt >= TOUCH_REPORT_ON_OFF_CONTROL_START_CNT_THD)
000010  6981              LDR      r1,[r0,#0x18]
000012  2914              CMP      r1,#0x14
;;;342    	{
;;;343    		return ptHalInfo->bIsTouchReportOnOffStart;
000014  bf2c              ITE      CS
000016  7d00              LDRBCS   r0,[r0,#0x14]
;;;344    	}
;;;345    	else
;;;346    	{
;;;347    		return NO;
000018  2000              MOVCC    r0,#0
;;;348    	}
;;;349    }
00001a  4770              BX       lr
;;;350    #endif /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
                          ENDP

                  |L16.28|
                          DCD      ||.data||

                          AREA ||i.HAL_Get_S3_VDD_OddEven_Ctrl||, CODE, READONLY, ALIGN=2

                  HAL_Get_S3_VDD_OddEven_Ctrl PROC
;;;279    
;;;280    bool_t HAL_Get_S3_VDD_OddEven_Ctrl(void)
000000  4806              LDR      r0,|L17.28|
;;;281    {
;;;282    	if(ptHalInfo->bIsS3VddOddEvenControlStartCheckCnt < TPIC_S3_VDD_OE_INPUT_OUTPUT_CTRL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  6a01              LDR      r1,[r0,#0x20]
000006  2904              CMP      r1,#4
000008  d202              BCS      |L17.16|
;;;283    	{
;;;284    		ptHalInfo->bIsS3VddOddEvenControlStartCheckCnt++;
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  1c49              ADDS     r1,r1,#1
00000e  6201              STR      r1,[r0,#0x20]
                  |L17.16|
;;;285    	}
;;;286    
;;;287    	if(ptHalInfo->bIsS3VddOddEvenControlStartCheckCnt >= TPIC_S3_VDD_OE_INPUT_OUTPUT_CTRL_START_CNT_THD)
000010  6a01              LDR      r1,[r0,#0x20]
000012  2904              CMP      r1,#4
;;;288    	{
;;;289    		return ptHalInfo->bIsS3VddOddEvenControlStart;
000014  bf2c              ITE      CS
000016  7f00              LDRBCS   r0,[r0,#0x1c]
;;;290    	}
;;;291    	else
;;;292    	{
;;;293    		return NO;
000018  2000              MOVCC    r0,#0
;;;294    	}
;;;295    }
00001a  4770              BX       lr
;;;296    
                          ENDP

                  |L17.28|
                          DCD      ||.data||

                          AREA ||i.HAL_Initialize||, CODE, READONLY, ALIGN=2

                  HAL_Initialize PROC
;;;685     */
;;;686    void HAL_Initialize(void)
000000  b510              PUSH     {r4,lr}
;;;687    {
;;;688    	ptHalInfo = hal_GetInfo();
000002  f7fffffe          BL       hal_GetInfo
000006  4901              LDR      r1,|L18.12|
000008  6008              STR      r0,[r1,#0]  ; ptHalInfo
;;;689    }
00000a  bd10              POP      {r4,pc}
;;;690    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.HAL_SetActivePenChagneType||, CODE, READONLY, ALIGN=2

                  HAL_SetActivePenChagneType PROC
;;;1003   
;;;1004   void HAL_SetActivePenChagneType(eActivePenChangeType_t eType)
000000  4902              LDR      r1,|L19.12|
;;;1005   {
;;;1006   	ptHalInfo->ulActivePenChangeType = eType;
000002  6809              LDR      r1,[r1,#0]  ; ptHalInfo
000004  f8810030          STRB     r0,[r1,#0x30]
;;;1007   }
000008  4770              BX       lr
;;;1008   
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      ||.data||

                          AREA ||i.HAL_SetDiagTestSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_SetDiagTestSensingChangeMode PROC
;;;743    
;;;744    void HAL_SetDiagTestSensingChangeMode(eDIAG_TEST_CHANGE_MODE_t mode)
000000  4909              LDR      r1,|L20.40|
000002  6809              LDR      r1,[r1,#0]
;;;745    {
000004  b158              CBZ      r0,|L20.30|
000006  798b              LDRB     r3,[r1,#6]
;;;746    #if USED_ECLK_ON_OFF_CONTROL
;;;747    	// Mode ????? EClk On/Off Control?? Disable????? ???.
;;;748    	if(mode != SM_CHANGE_COMPLETE)
;;;749    	{
;;;750    		HAL_SetECLKOnOffControl(NO);
000008  2200              MOVS     r2,#0
00000a  2b01              CMP      r3,#1
00000c  d106              BNE      |L20.28|
00000e  4b07              LDR      r3,|L20.44|
000010  f8d3c08c          LDR      r12,[r3,#0x8c]
000014  f42c7cf8          BIC      r12,r12,#0x1f0
000018  f8c3c08c          STR      r12,[r3,#0x8c]
                  |L20.28|
00001c  718a              STRB     r2,[r1,#6]
                  |L20.30|
;;;751    	}
;;;752    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;753    	ptHalInfo->eDiagTestChangeMode = mode;
00001e  7108              STRB     r0,[r1,#4]
;;;754    	ptHalInfo->eSensingChangeMode = SM_CHANGE_DIAG_TEST;
000020  2009              MOVS     r0,#9
000022  7008              STRB     r0,[r1,#0]
;;;755    }
000024  4770              BX       lr
;;;756    
                          ENDP

000026  0000              DCW      0x0000
                  |L20.40|
                          DCD      ||.data||
                  |L20.44|
                          DCD      0x40002000

                          AREA ||i.HAL_SetECLKOnOffControl||, CODE, READONLY, ALIGN=2

                  HAL_SetECLKOnOffControl PROC
;;;137    #if USED_ECLK_ON_OFF_CONTROL
;;;138    void HAL_SetECLKOnOffControl(bool_t bIsEn)
000000  4909              LDR      r1,|L21.40|
;;;139    {
;;;140    	if(bIsEn == NO)
;;;141    	{
;;;142    		if(ptHalInfo->bIsECLKOnOffStart == YES)
000002  6809              LDR      r1,[r1,#0]
;;;143    		{
;;;144    			HAL_ECLK_On();
;;;145    		}
;;;146    	}
;;;147    	else
;;;148    	{
;;;149    		if(ptHalInfo->bIsECLKOnOffStart == NO)
000004  798a              LDRB     r2,[r1,#6]
000006  b120              CBZ      r0,|L21.18|
000008  2a00              CMP      r2,#0
;;;150    		{
;;;151    			ptHalInfo->bIsECLKOnOffStartCheckCnt = 0;
00000a  bf04              ITT      EQ
00000c  2200              MOVEQ    r2,#0
00000e  608a              STREQ    r2,[r1,#8]
000010  e007              B        |L21.34|
                  |L21.18|
000012  2a01              CMP      r2,#1                 ;142
000014  d105              BNE      |L21.34|
000016  4a05              LDR      r2,|L21.44|
000018  f8523f8c          LDR      r3,[r2,#0x8c]!        ;142
00001c  f42373f8          BIC      r3,r3,#0x1f0          ;142
000020  6013              STR      r3,[r2,#0]            ;142
                  |L21.34|
;;;152    		}
;;;153    	}
;;;154    
;;;155    	ptHalInfo->bIsECLKOnOffStart = bIsEn;
000022  7188              STRB     r0,[r1,#6]
;;;156    }
000024  4770              BX       lr
;;;157    
                          ENDP

000026  0000              DCW      0x0000
                  |L21.40|
                          DCD      ||.data||
                  |L21.44|
                          DCD      0x40002000

                          AREA ||i.HAL_SetROICRegSetChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_SetROICRegSetChangeMode PROC
;;;762    
;;;763    void HAL_SetROICRegSetChangeMode(eROIC_REG_SET_CHANGE_MODE_t mode)
000000  4909              LDR      r1,|L22.40|
000002  6809              LDR      r1,[r1,#0]
;;;764    {
000004  b158              CBZ      r0,|L22.30|
000006  798b              LDRB     r3,[r1,#6]
;;;765    #if USED_ECLK_ON_OFF_CONTROL
;;;766    	// Mode 변경시 EClk On/Off Control을 Disable시켜야 한다.
;;;767    	if(mode != SM_CHANGE_COMPLETE)
;;;768    	{
;;;769    		HAL_SetECLKOnOffControl(NO);
000008  2200              MOVS     r2,#0
00000a  2b01              CMP      r3,#1
00000c  d106              BNE      |L22.28|
00000e  4b07              LDR      r3,|L22.44|
000010  f8d3c08c          LDR      r12,[r3,#0x8c]
000014  f42c7cf8          BIC      r12,r12,#0x1f0
000018  f8c3c08c          STR      r12,[r3,#0x8c]
                  |L22.28|
00001c  718a              STRB     r2,[r1,#6]
                  |L22.30|
;;;770    	}
;;;771    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;772    	ptHalInfo->eROICRegSetChangeMode = mode;
00001e  7148              STRB     r0,[r1,#5]
;;;773    	ptHalInfo->eSensingChangeMode = SM_CHANGE_ROIC_REG_VAL;
000020  200a              MOVS     r0,#0xa
000022  7008              STRB     r0,[r1,#0]
;;;774    }
000024  4770              BX       lr
;;;775    
                          ENDP

000026  0000              DCW      0x0000
                  |L22.40|
                          DCD      ||.data||
                  |L22.44|
                          DCD      0x40002000

                          AREA ||i.HAL_SetSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_SetSensingChangeMode PROC
;;;715    
;;;716    void HAL_SetSensingChangeMode(eSENSING_CHANGE_MODE_t mode)
000000  4908              LDR      r1,|L23.36|
000002  6809              LDR      r1,[r1,#0]
;;;717    {
000004  b158              CBZ      r0,|L23.30|
000006  798b              LDRB     r3,[r1,#6]
;;;718    #if USED_ECLK_ON_OFF_CONTROL
;;;719    	// Mode 변경시 EClk On/Off Control을 Disable시켜야 한다.
;;;720    	if(mode != SM_CHANGE_COMPLETE)
;;;721    	{
;;;722    		HAL_SetECLKOnOffControl(NO);
000008  2200              MOVS     r2,#0
00000a  2b01              CMP      r3,#1
00000c  d106              BNE      |L23.28|
00000e  4b06              LDR      r3,|L23.40|
000010  f8d3c08c          LDR      r12,[r3,#0x8c]
000014  f42c7cf8          BIC      r12,r12,#0x1f0
000018  f8c3c08c          STR      r12,[r3,#0x8c]
                  |L23.28|
00001c  718a              STRB     r2,[r1,#6]
                  |L23.30|
;;;723    	}
;;;724    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;725    	ptHalInfo->eSensingChangeMode = mode;
00001e  7008              STRB     r0,[r1,#0]
;;;726    }
000020  4770              BX       lr
;;;727    
                          ENDP

000022  0000              DCW      0x0000
                  |L23.36|
                          DCD      ||.data||
                  |L23.40|
                          DCD      0x40002000

                          AREA ||i.HAL_SetSensingMode||, CODE, READONLY, ALIGN=2

                  HAL_SetSensingMode PROC
;;;732    
;;;733    void HAL_SetSensingMode(eSENSING_MODE_t mode)
000000  4902              LDR      r1,|L24.12|
;;;734    {
;;;735    	if(ptHalInfo != NULL)
000002  6809              LDR      r1,[r1,#0]  ; ptHalInfo
000004  2900              CMP      r1,#0
;;;736    		ptHalInfo->eSensingMode = mode;
000006  bf18              IT       NE
000008  8048              STRHNE   r0,[r1,#2]
;;;737    }
00000a  4770              BX       lr
;;;738    
                          ENDP

                  |L24.12|
                          DCD      ||.data||

                          AREA ||i.HAL_SetTPICMuxEnControl||, CODE, READONLY, ALIGN=2

                  HAL_SetTPICMuxEnControl PROC
;;;208    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;209    void HAL_SetTPICMuxEnControl(bool_t bIsEn, bool_t bIsVCCOff)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
;;;211    	if(bIsEn == NO)
;;;212    	{
;;;213    		if(ptHalInfo->bIsTPICMuxEnOnOffStart == YES)
000002  4d0c              LDR      r5,|L25.52|
000004  0004              MOVS     r4,r0                 ;210
;;;214    		{
;;;215    			if(bIsVCCOff)
;;;216    			{
;;;217    				GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_LOW);
;;;218    			}
;;;219    			else
;;;220    			{
;;;221    				GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_HIGH);
;;;222    			}
;;;223    		}
;;;224    	}
;;;225    	else
;;;226    	{
;;;227    		if(ptHalInfo->bIsTPICMuxEnOnOffStart == NO)
000006  682a              LDR      r2,[r5,#0]
000008  7b10              LDRB     r0,[r2,#0xc]
00000a  d004              BEQ      |L25.22|
00000c  2800              CMP      r0,#0
;;;228    		{
;;;229    			ptHalInfo->bIsTPICMuxEnOnOffStartCheckCnt = 0;
00000e  bf04              ITT      EQ
000010  2000              MOVEQ    r0,#0
000012  6110              STREQ    r0,[r2,#0x10]
000014  e00b              B        |L25.46|
                  |L25.22|
000016  2801              CMP      r0,#1                 ;213
000018  d109              BNE      |L25.46|
00001a  b121              CBZ      r1,|L25.38|
00001c  2100              MOVS     r1,#0                 ;217
00001e  2025              MOVS     r0,#0x25              ;217
000020  f7fffffe          BL       GPIO_Set_DATA
000024  e003              B        |L25.46|
                  |L25.38|
000026  2101              MOVS     r1,#1                 ;221
000028  2025              MOVS     r0,#0x25              ;221
00002a  f7fffffe          BL       GPIO_Set_DATA
                  |L25.46|
;;;230    		}
;;;231    	}
;;;232    
;;;233    	ptHalInfo->bIsTPICMuxEnOnOffStart = bIsEn;
00002e  6828              LDR      r0,[r5,#0]  ; ptHalInfo
000030  7304              STRB     r4,[r0,#0xc]
;;;234    }
000032  bd70              POP      {r4-r6,pc}
;;;235    
                          ENDP

                  |L25.52|
                          DCD      ||.data||

                          AREA ||i.HAL_SetTouchReportEnControl||, CODE, READONLY, ALIGN=2

                  HAL_SetTouchReportEnControl PROC
;;;320    #if USED_TOUCH_REPORT_ON_OFF_CONTROL
;;;321    void HAL_SetTouchReportEnControl(bool_t bIsEn)
000000  4904              LDR      r1,|L26.20|
;;;322    {
;;;323    	if(bIsEn == YES)
000002  2801              CMP      r0,#1
;;;324    	{
;;;325    		if(ptHalInfo->bIsTouchReportOnOffStart == NO)
000004  6809              LDR      r1,[r1,#0]
000006  bf01              ITTTT    EQ
000008  7d0a              LDRBEQ   r2,[r1,#0x14]
00000a  2a00              CMPEQ    r2,#0
;;;326    		{
;;;327    			ptHalInfo->bIsTouchReportOnOffStartCheckCnt = 0;
00000c  2200              MOVEQ    r2,#0
00000e  618a              STREQ    r2,[r1,#0x18]
;;;328    		}
;;;329    	}
;;;330    
;;;331    	ptHalInfo->bIsTouchReportOnOffStart = bIsEn;
000010  7508              STRB     r0,[r1,#0x14]
;;;332    }
000012  4770              BX       lr
;;;333    
                          ENDP

                  |L26.20|
                          DCD      ||.data||

                          AREA ||i.HAL_Set_S3_VDD_OddEven_Ctrl||, CODE, READONLY, ALIGN=2

                  HAL_Set_S3_VDD_OddEven_Ctrl PROC
;;;254    #if USED_S3_VDD_OE_INPUT_OUTPUT_CTRL
;;;255    void HAL_Set_S3_VDD_OddEven_Ctrl(bool_t bIsEn)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
;;;257    	if(bIsEn == NO)
;;;258    	{
;;;259    		if(ptHalInfo->bIsS3VddOddEvenControlStart == YES)
000002  4c12              LDR      r4,|L27.76|
000004  0006              MOVS     r6,r0                 ;256
000006  f04f0500          MOV      r5,#0                 ;256
;;;260    		{
;;;261    			GPIO_Set_DATA(_GPIO_VDDO_EVEN_CTRL, GPIO_DATA_LOW);
;;;262    			GPIO_Init(_GPIO_VDDO_EVEN_CTRL, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;263    			ptHalInfo->ucS3VddOddEvenStatus = GPIO_DATA_LOW;
;;;264    		}
;;;265    	}
;;;266    	else
;;;267    	{
;;;268    		if(ptHalInfo->bIsS3VddOddEvenControlStart == NO)
00000a  6820              LDR      r0,[r4,#0]
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  d001              BEQ      |L27.20|
000010  b170              CBZ      r0,|L27.48|
000012  e018              B        |L27.70|
                  |L27.20|
000014  2801              CMP      r0,#1                 ;259
000016  d116              BNE      |L27.70|
000018  2100              MOVS     r1,#0                 ;261
00001a  2005              MOVS     r0,#5                 ;261
00001c  f7fffffe          BL       GPIO_Set_DATA
000020  2302              MOVS     r3,#2                 ;262
000022  2201              MOVS     r2,#1                 ;262
000024  2103              MOVS     r1,#3                 ;262
000026  2005              MOVS     r0,#5                 ;262
000028  f7fffffe          BL       GPIO_Init
00002c  6820              LDR      r0,[r4,#0]            ;263  ; ptHalInfo
00002e  e008              B        |L27.66|
                  |L27.48|
;;;269    		{
;;;270    			GPIO_Init(_GPIO_VDDO_EVEN_CTRL, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000030  2300              MOVS     r3,#0
000032  461a              MOV      r2,r3
000034  2103              MOVS     r1,#3
000036  2005              MOVS     r0,#5
000038  f7fffffe          BL       GPIO_Init
;;;271    			ptHalInfo->bIsS3VddOddEvenControlStartCheckCnt = 0;
00003c  6820              LDR      r0,[r4,#0]  ; ptHalInfo
00003e  6205              STR      r5,[r0,#0x20]
;;;272    			ptHalInfo->bIsS3VddOddEvenControlFrameCheckCnt = 0;
000040  6285              STR      r5,[r0,#0x28]
                  |L27.66|
;;;273    			ptHalInfo->ucS3VddOddEvenStatus = GPIO_DATA_LOW;
000042  f8805024          STRB     r5,[r0,#0x24]
                  |L27.70|
;;;274    		}
;;;275    	}
;;;276    
;;;277    	ptHalInfo->bIsS3VddOddEvenControlStart = bIsEn;
000046  6820              LDR      r0,[r4,#0]  ; ptHalInfo
000048  7706              STRB     r6,[r0,#0x1c]
;;;278    }
00004a  bd70              POP      {r4-r6,pc}
;;;279    
                          ENDP

                  |L27.76|
                          DCD      ||.data||

                          AREA ||i.Hal_VccOff_State||, CODE, READONLY, ALIGN=2

                  Hal_VccOff_State PROC
;;;508    
;;;509    void Hal_VccOff_State(void)
000000  4885              LDR      r0,|L28.536|
;;;510    {
000002  b510              PUSH     {r4,lr}
;;;511    	// ECLK OFF
;;;512    //	PWMDRV->ECLK_CR.tBit.eclk_en = DISABLE;
;;;513    	PWMDRV->ECLK_CR.tBit.eclk_force_on = DISABLE;
000004  f8501f8c          LDR      r1,[r0,#0x8c]!
000008  f4217100          BIC      r1,r1,#0x200
00000c  6001              STR      r1,[r0,#0]
;;;514    
;;;515    #if (!USED_DO_NOT_TOUCH_ONLY_DISPLAY)
;;;516    	GPIO_Init(_GPIO_TSYNC_OUT, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00000e  2300              MOVS     r3,#0
000010  461a              MOV      r2,r3
000012  2103              MOVS     r1,#3
000014  2032              MOVS     r0,#0x32
000016  f7fffffe          BL       GPIO_Init
;;;517    	GPIO_Init(_GPIO_TSYNC_IN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00001a  2300              MOVS     r3,#0
00001c  461a              MOV      r2,r3
00001e  2103              MOVS     r1,#3
000020  202e              MOVS     r0,#0x2e
000022  f7fffffe          BL       GPIO_Init
;;;518    #if USED_TSYNC2_INPUT_FROM_TCON
;;;519    	GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;520    #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;521    #endif /* (!USED_DO_NOT_TOUCH_ONLY_DISPLAY) */
;;;522    #if !(USED_MODULE_DEF == MODULE_DEF_S_1 && (CUSTOMER == MODEL_DEF_FHD_92503S))
;;;523    	GPIO_Init(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  2103              MOVS     r1,#3
00002c  2033              MOVS     r0,#0x33
00002e  f7fffffe          BL       GPIO_Init
;;;524    #endif
;;;525    	GPIO_Init(_GPIO_MUX_EN_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000032  2300              MOVS     r3,#0
000034  461a              MOV      r2,r3
000036  2103              MOVS     r1,#3
000038  2025              MOVS     r0,#0x25
00003a  f7fffffe          BL       GPIO_Init
;;;526    
;;;527    	//Vsync Pull-Down
;;;528    	GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00003e  2300              MOVS     r3,#0
000040  461a              MOV      r2,r3
000042  2103              MOVS     r1,#3
000044  202d              MOVS     r0,#0x2d
000046  f7fffffe          BL       GPIO_Init
;;;529    
;;;530    	//MSPI Pull-Down
;;;531    	GPIO_Init(_GPIO_MSPI_0_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00004a  2300              MOVS     r3,#0
00004c  461a              MOV      r2,r3
00004e  2103              MOVS     r1,#3
000050  200b              MOVS     r0,#0xb
000052  f7fffffe          BL       GPIO_Init
;;;532    	GPIO_Init(_GPIO_MSPI_0_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000056  2300              MOVS     r3,#0
000058  461a              MOV      r2,r3
00005a  2103              MOVS     r1,#3
00005c  200c              MOVS     r0,#0xc
00005e  f7fffffe          BL       GPIO_Init
;;;533    	GPIO_Init(_GPIO_MSPI_0_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000062  2300              MOVS     r3,#0
000064  461a              MOV      r2,r3
000066  2103              MOVS     r1,#3
000068  200d              MOVS     r0,#0xd
00006a  f7fffffe          BL       GPIO_Init
;;;534    	GPIO_Init(_GPIO_MSPI_0_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00006e  2300              MOVS     r3,#0
000070  461a              MOV      r2,r3
000072  2103              MOVS     r1,#3
000074  200e              MOVS     r0,#0xe
000076  f7fffffe          BL       GPIO_Init
;;;535    
;;;536    	GPIO_Init(_GPIO_MSPI_1_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00007a  2300              MOVS     r3,#0
00007c  461a              MOV      r2,r3
00007e  2103              MOVS     r1,#3
000080  200f              MOVS     r0,#0xf
000082  f7fffffe          BL       GPIO_Init
;;;537    	GPIO_Init(_GPIO_MSPI_1_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000086  2300              MOVS     r3,#0
000088  461a              MOV      r2,r3
00008a  2103              MOVS     r1,#3
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       GPIO_Init
;;;538    	GPIO_Init(_GPIO_MSPI_1_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000092  2300              MOVS     r3,#0
000094  461a              MOV      r2,r3
000096  2103              MOVS     r1,#3
000098  2011              MOVS     r0,#0x11
00009a  f7fffffe          BL       GPIO_Init
;;;539    	GPIO_Init(_GPIO_MSPI_1_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00009e  2300              MOVS     r3,#0
0000a0  461a              MOV      r2,r3
0000a2  2103              MOVS     r1,#3
0000a4  2012              MOVS     r0,#0x12
0000a6  f7fffffe          BL       GPIO_Init
;;;540    
;;;541    	GPIO_Init(_GPIO_MSPI_2_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000aa  2300              MOVS     r3,#0
0000ac  461a              MOV      r2,r3
0000ae  2103              MOVS     r1,#3
0000b0  2013              MOVS     r0,#0x13
0000b2  f7fffffe          BL       GPIO_Init
;;;542    	GPIO_Init(_GPIO_MSPI_2_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000b6  2300              MOVS     r3,#0
0000b8  461a              MOV      r2,r3
0000ba  2103              MOVS     r1,#3
0000bc  2014              MOVS     r0,#0x14
0000be  f7fffffe          BL       GPIO_Init
;;;543    	GPIO_Init(_GPIO_MSPI_2_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000c2  2300              MOVS     r3,#0
0000c4  461a              MOV      r2,r3
0000c6  2103              MOVS     r1,#3
0000c8  2015              MOVS     r0,#0x15
0000ca  f7fffffe          BL       GPIO_Init
;;;544    	GPIO_Init(_GPIO_MSPI_2_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000ce  2300              MOVS     r3,#0
0000d0  461a              MOV      r2,r3
0000d2  2103              MOVS     r1,#3
0000d4  2016              MOVS     r0,#0x16
0000d6  f7fffffe          BL       GPIO_Init
;;;545    
;;;546    	GPIO_Init(_GPIO_MSPI_3_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000da  2300              MOVS     r3,#0
0000dc  461a              MOV      r2,r3
0000de  2103              MOVS     r1,#3
0000e0  2017              MOVS     r0,#0x17
0000e2  f7fffffe          BL       GPIO_Init
;;;547    	GPIO_Init(_GPIO_MSPI_3_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000e6  2300              MOVS     r3,#0
0000e8  461a              MOV      r2,r3
0000ea  2103              MOVS     r1,#3
0000ec  2018              MOVS     r0,#0x18
0000ee  f7fffffe          BL       GPIO_Init
;;;548    	GPIO_Init(_GPIO_MSPI_3_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000f2  2300              MOVS     r3,#0
0000f4  461a              MOV      r2,r3
0000f6  2103              MOVS     r1,#3
0000f8  2019              MOVS     r0,#0x19
0000fa  f7fffffe          BL       GPIO_Init
;;;549    	GPIO_Init(_GPIO_MSPI_3_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0000fe  2300              MOVS     r3,#0
000100  461a              MOV      r2,r3
000102  2103              MOVS     r1,#3
000104  201a              MOVS     r0,#0x1a
000106  f7fffffe          BL       GPIO_Init
;;;550    
;;;551    	GPIO_Init(_GPIO_MSPI_4_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00010a  2300              MOVS     r3,#0
00010c  461a              MOV      r2,r3
00010e  2103              MOVS     r1,#3
000110  201b              MOVS     r0,#0x1b
000112  f7fffffe          BL       GPIO_Init
;;;552    	GPIO_Init(_GPIO_MSPI_4_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000116  2300              MOVS     r3,#0
000118  461a              MOV      r2,r3
00011a  2103              MOVS     r1,#3
00011c  201c              MOVS     r0,#0x1c
00011e  f7fffffe          BL       GPIO_Init
;;;553    	GPIO_Init(_GPIO_MSPI_4_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000122  2300              MOVS     r3,#0
000124  461a              MOV      r2,r3
000126  2103              MOVS     r1,#3
000128  201d              MOVS     r0,#0x1d
00012a  f7fffffe          BL       GPIO_Init
;;;554    	GPIO_Init(_GPIO_MSPI_4_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00012e  2300              MOVS     r3,#0
000130  461a              MOV      r2,r3
000132  2103              MOVS     r1,#3
000134  201e              MOVS     r0,#0x1e
000136  f7fffffe          BL       GPIO_Init
;;;555    
;;;556    	GPIO_Init(_GPIO_MSPI_5_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00013a  2300              MOVS     r3,#0
00013c  461a              MOV      r2,r3
00013e  2103              MOVS     r1,#3
000140  201f              MOVS     r0,#0x1f
000142  f7fffffe          BL       GPIO_Init
;;;557    	GPIO_Init(_GPIO_MSPI_5_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000146  2300              MOVS     r3,#0
000148  461a              MOV      r2,r3
00014a  2103              MOVS     r1,#3
00014c  2020              MOVS     r0,#0x20
00014e  f7fffffe          BL       GPIO_Init
;;;558    
;;;559    #if (USED_MODULE_DEF == MODULE_DEF_S_1)
;;;560    	#if (USED_PCB_PINMAP != SHARP_NBPC_PIN_TYPE_S01)
;;;561    		GPIO_Init(_GPIO_MSPI_5_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;562    	#endif /* (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01) */
;;;563    #else /* (USED_MODULE_DEF == MODULE_DEF_S_1) */
;;;564    	GPIO_Init(_GPIO_MSPI_5_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000152  2300              MOVS     r3,#0
000154  461a              MOV      r2,r3
000156  2103              MOVS     r1,#3
000158  2021              MOVS     r0,#0x21
00015a  f7fffffe          BL       GPIO_Init
;;;565    #endif /* (USED_MODULE_DEF == MODULE_DEF_S_1) */
;;;566    	GPIO_Init(_GPIO_MSPI_5_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00015e  2300              MOVS     r3,#0
000160  461a              MOV      r2,r3
000162  2103              MOVS     r1,#3
000164  2022              MOVS     r0,#0x22
000166  f7fffffe          BL       GPIO_Init
;;;567    
;;;568    	GPIO_Init(_GPIO_MSPI_6_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00016a  2300              MOVS     r3,#0
00016c  461a              MOV      r2,r3
00016e  2103              MOVS     r1,#3
000170  2023              MOVS     r0,#0x23
000172  f7fffffe          BL       GPIO_Init
;;;569    	GPIO_Init(_GPIO_MSPI_6_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000176  2300              MOVS     r3,#0
000178  461a              MOV      r2,r3
00017a  2103              MOVS     r1,#3
00017c  2024              MOVS     r0,#0x24
00017e  f7fffffe          BL       GPIO_Init
;;;570    	#if ((!((USED_MODULE_DEF == MODULE_DEF_B_1) && (CUSTOMER == MODEL_DEF_FHD_97500_MNT_S3))) && (!USED_GPIO_MSPI_6_IS_MUX_EN))
;;;571    		GPIO_Init(_GPIO_MSPI_6_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;572    	#endif /* (!((USED_MODULE_DEF == MODULE_DEF_B_1) && (CUSTOMER == MODEL_DEF_FHD_97500_MNT_S3))) */
;;;573    	GPIO_Init(_GPIO_MSPI_6_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000182  2300              MOVS     r3,#0
000184  461a              MOV      r2,r3
000186  2103              MOVS     r1,#3
000188  2026              MOVS     r0,#0x26
00018a  f7fffffe          BL       GPIO_Init
;;;574    
;;;575    #if (USED_VCF_SYNC_CONTROL == NO)
;;;576    	GPIO_Init(_GPIO_MSPI_7_CSN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00018e  2300              MOVS     r3,#0
000190  461a              MOV      r2,r3
000192  2103              MOVS     r1,#3
000194  2027              MOVS     r0,#0x27
000196  f7fffffe          BL       GPIO_Init
;;;577    	GPIO_Init(_GPIO_MSPI_7_CLK, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00019a  2300              MOVS     r3,#0
00019c  461a              MOV      r2,r3
00019e  2103              MOVS     r1,#3
0001a0  2028              MOVS     r0,#0x28
0001a2  f7fffffe          BL       GPIO_Init
;;;578    	#if !USED_PWM_GATE_CONTROL
;;;579    		GPIO_Init(_GPIO_MSPI_7_MOSI, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;580    	#endif
;;;581    	GPIO_Init(_GPIO_MSPI_7_MISO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001a6  2300              MOVS     r3,#0
0001a8  461a              MOV      r2,r3
0001aa  2103              MOVS     r1,#3
0001ac  202a              MOVS     r0,#0x2a
0001ae  f7fffffe          BL       GPIO_Init
;;;582    #endif /* USED_VCF_SYNC_CONTROL */
;;;583    
;;;584    #if USED_VCF_SYNC_CONTROL
;;;585    	//TP EN -> GPIO -> Low
;;;586    	GPIO_Init(_GPIO_PRIVACY_EN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;587    #else /* USED_VCF_SYNC_CONTROL */
;;;588    	//TP EN -> GPIO -> Low
;;;589    #if (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3)
;;;590    	GPIO_Init(_GPIO_TP_EN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;591    #endif /* (CUSTOMER != MODEL_DEF_FHD_97500_MNT_S3) */
;;;592    #endif /* USED_VCF_SYNC_CONTROL */
;;;593    
;;;594    	//PWM Pull-Down
;;;595    	GPIO_Init(_GPIO_PWM_SRIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001b2  2300              MOVS     r3,#0
0001b4  461a              MOV      r2,r3
0001b6  2103              MOVS     r1,#3
0001b8  202f              MOVS     r0,#0x2f
0001ba  f7fffffe          BL       GPIO_Init
;;;596    	GPIO_Init(_GPIO_PWM_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001be  2300              MOVS     r3,#0
0001c0  461a              MOV      r2,r3
0001c2  2103              MOVS     r1,#3
0001c4  2030              MOVS     r0,#0x30
0001c6  f7fffffe          BL       GPIO_Init
;;;597    #if USED_PWM_GATE_CONTROL
;;;598    	GPIO_Init(_GPIO_PWM_GATE, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001ca  2300              MOVS     r3,#0
0001cc  461a              MOV      r2,r3
0001ce  2103              MOVS     r1,#3
0001d0  2029              MOVS     r0,#0x29
0001d2  f7fffffe          BL       GPIO_Init
;;;599    #endif /* USED_PWM_GATE_CONTROL */
;;;600    
;;;601    	//ECLK Pull-Down
;;;602    	GPIO_Init(_GPIO_ECLK_0, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001d6  2300              MOVS     r3,#0
0001d8  461a              MOV      r2,r3
0001da  2103              MOVS     r1,#3
0001dc  202b              MOVS     r0,#0x2b
0001de  f7fffffe          BL       GPIO_Init
;;;603    	GPIO_Init(_GPIO_ECLK_1, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001e2  2300              MOVS     r3,#0
0001e4  461a              MOV      r2,r3
0001e6  2103              MOVS     r1,#3
0001e8  202c              MOVS     r0,#0x2c
0001ea  f7fffffe          BL       GPIO_Init
;;;604    	GPIO_Init(_GPIO_TP_INTR, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
0001ee  2301              MOVS     r3,#1
0001f0  2200              MOVS     r2,#0
0001f2  2103              MOVS     r1,#3
0001f4  2004              MOVS     r0,#4
0001f6  f7fffffe          BL       GPIO_Init
;;;605    
;;;606    	//Reset SRIC
;;;607    	GPIO_Init(_GPIO_RSTN_SRIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
0001fa  2300              MOVS     r3,#0
0001fc  461a              MOV      r2,r3
0001fe  2103              MOVS     r1,#3
000200  2034              MOVS     r0,#0x34
000202  f7fffffe          BL       GPIO_Init
;;;608    
;;;609    	//Reset Uplink
;;;610    	GPIO_Init(_GPIO_Uplink_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
000206  2300              MOVS     r3,#0
000208  2103              MOVS     r1,#3
00020a  e8bd4010          POP      {r4,lr}
00020e  461a              MOV      r2,r3
000210  2036              MOVS     r0,#0x36
000212  f7ffbffe          B.W      GPIO_Init
;;;611    }
;;;612    
                          ENDP

000216  0000              DCW      0x0000
                  |L28.536|
                          DCD      0x40002000

                          AREA ||i.Hal_sric_start||, CODE, READONLY, ALIGN=2

                  Hal_sric_start PROC
;;;366    uint32_t ulRetryCount;
;;;367    bool_t Hal_sric_start(bool_t cmuxoff)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;368    {
000004  4c48              LDR      r4,|L29.296|
000006  6820              LDR      r0,[r4,#0]  ; ptHalInfo
000008  8847              LDRH     r7,[r0,#2]
;;;369    	eSENSING_MODE_t eSensingMode;
;;;370    	eSensingMode = HAL_GetSensingMode();
;;;371    
;;;372    #if !USED_OPERATION_STAND_ALONE
;;;373    	if(!IS_S3_MODE(eSensingMode))
00000a  f4176f00          TST      r7,#0x800
00000e  d109              BNE      |L29.36|
                  |L29.16|
;;;374    	{
;;;375    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 0);
000010  202d              MOVS     r0,#0x2d
000012  f7fffffe          BL       GPIO_Get_IN
000016  2800              CMP      r0,#0
000018  d0fa              BEQ      |L29.16|
                  |L29.26|
;;;376    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 1);
00001a  202d              MOVS     r0,#0x2d
00001c  f7fffffe          BL       GPIO_Get_IN
000020  2801              CMP      r0,#1
000022  d0fa              BEQ      |L29.26|
                  |L29.36|
;;;377    	}
;;;378    #endif /* !USED_OPERATION_STAND_ALONE */
;;;379    
;;;380    	tHalIntrHandle.ulInitFirstFrame = 1;
000024  f8df8104          LDR      r8,|L29.300|
000028  2001              MOVS     r0,#1
00002a  f8c80028          STR      r0,[r8,#0x28]  ; tHalIntrHandle
;;;381    
;;;382    //	while(1)
;;;383    //	{
;;;384    //		ulTPICSendData[0] = TPIC_VCOM_H_ADDR;
;;;385    //		ulTPICSendData[1] = (uint8_t)eTPIC_VCOM_H_Level;
;;;386    //		I2CM_SendByte(TPIC_CTRL_I2C_SLAVE_ADDR, &ulTPICSendData[0], 2);
;;;387    //		delay_usec(500);
;;;388    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VCOM_H_ADDR, &ulTPICRecvData[0], 1);
;;;389    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VCOM_L_ADDR, &ulTPICRecvData[1], 1);
;;;390    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VGL1_H_ADDR, &ulTPICRecvData[2], 1);
;;;391    //		I2CM_RcvByte(TPIC_CTRL_I2C_SLAVE_ADDR, TPIC_VGL2_H_ADDR, &ulTPICRecvData[3], 1);
;;;392    //
;;;393    //		delay_msec(10);
;;;394    //	}
;;;395    
;;;396    #if ((USED_PEN_PROTOCOL == PEN_PROTOCOL_WACOM_PEN) && USED_TPIC_VCOM_LEVEL_I2CM_CONTROL)
;;;397    	HAL_TPIC_UplinkModulation_LevelCtrl_Enable();
;;;398    #endif /* ((USED_PEN_PROTOCOL == PEN_PROTOCOL_WACOM_PEN) && USED_TPIC_VCOM_LEVEL_I2CM_CONTROL) */
;;;399    
;;;400    	PWMDRV_Init(eSensingMode);
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       PWMDRV_Init
;;;401    
;;;402    	SRIC_Reset(eSensingMode);
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       SRIC_Reset
;;;403    	delay_msec(10);
00003a  f2427010          MOV      r0,#0x2710
00003e  f7fffffe          BL       delay_us
;;;404    	MSPI_Initialize();
000042  f7fffffe          BL       MSPI_Initialize
;;;405    
;;;406    	MSPI_Set_TLPMODE();
000046  f7fffffe          BL       MSPI_Set_TLPMODE
;;;407    
;;;408    	ulRetryCount = 0;
00004a  2600              MOVS     r6,#0
;;;409    #if USED_SRIC_REG_INIT_RETRY
;;;410    	{
;;;411    #define DEF_SRIC_RETRY_COUNT_THD			(5)
;;;412    		uint32_t ulReTryCount = 0;
00004c  4635              MOV      r5,r6
;;;413    		do
00004e  6066              STR      r6,[r4,#4]  ; ulRetryCount
000050  e002              B        |L29.88|
                  |L29.82|
;;;414    		{
;;;415    			if(ulReTryCount > DEF_SRIC_RETRY_COUNT_THD)
;;;416    			{
;;;417    				return NO;
000052  2000              MOVS     r0,#0
;;;418    			}
;;;419    
;;;420    			if(SRIC_RegisterInit(eSensingMode) == YES)
;;;421    			{
;;;422    				break;
;;;423    			}
;;;424    
;;;425    			SRIC_Reset(eSensingMode);
;;;426    			delay_msec(10);
;;;427    
;;;428    			ulReTryCount++;
;;;429    			ulRetryCount++;
;;;430    		} while(1);
;;;431    	}
;;;432    #else /* USED_SRIC_REG_INIT_RETRY */
;;;433    	SRIC_RegisterInit(eSensingMode);
;;;434    #endif /* USED_SRIC_REG_INIT_RETRY */
;;;435    
;;;436    #if USED_OPERATION_STAND_ALONE
;;;437    	delay_usec(500);
;;;438    #else /* USED_OPERATION_STAND_ALONE */
;;;439    
;;;440    	if(IS_S3_MODE(eSensingMode))
;;;441    	{
;;;442    #if USED_S3_VDD_OE_INPUT_OUTPUT_CTRL
;;;443    		HAL_Set_S3_VDD_OddEven_Ctrl(YES);
;;;444    #endif /* USED_S3_VDD_OE_INPUT_OUTPUT_CTRL */
;;;445    
;;;446    		delay_usec(500);
;;;447    #if USED_S3_PGAMMA_SW_I2C_CTRL
;;;448    		module_S3_PGAMMA_I2C_SW_Disable();
;;;449    #endif /* USED_S3_PGAMMA_SW_I2C_CTRL */
;;;450    	}
;;;451    	else
;;;452    	{
;;;453    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 1);
;;;454    //#if USED_S3_PGAMMA_SW_I2C_CTRL
;;;455    //		_gT(_GPIO_TP_INTR);
;;;456    //		module_S3_PGAMMA_I2C_SW_Enable();
;;;457    //		_gT(_GPIO_TP_INTR);
;;;458    //#endif /* USED_S3_PGAMMA_SW_I2C_CTRL */
;;;459    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 0);
;;;460    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 1);
;;;461    		while(IS_GPIO_PIN(_GPIO_VSYNC) == 0);
;;;462    	}
;;;463    #endif /* USED_OPERATION_STAND_ALONE */
;;;464    
;;;465    //	{
;;;466    //		PWMDRV_Cmd(ENABLE);
;;;467    //		PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;468    //		tHalIntrHandle.ulInitFirstFrame = 0;
;;;469    //		while(1) ;
;;;470    //	}
;;;471    
;;;472    #if USED_DO_NOT_TOUCH_ONLY_DISPLAY
;;;473    	/*
;;;474    	 * ECLK OFF시키자!! Default가 Enable이라 PLL On되면 ECLK바로 구동 되어 버림!!
;;;475    	 */
;;;476    	PWMDRV->ECLK_CR.tBit.eclk_force_on = 0;
;;;477    	PWMDRV->ECLK_CR.tBit.eclk_en = 0;
;;;478    	GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_LOW);
;;;479    	Hal_VccOff_State();
;;;480    	while(1)
;;;481    	{
;;;482    		__WFI();
;;;483    	}
;;;484    #endif /* USED_DO_NOT_TOUCH_ONLY_DISPLAY */
;;;485    	SRIC_Run(ENABLE);
;;;486    
;;;487    	MSPI_ITConfig(ENABLE);
;;;488    	MSPI_Set_AITMODE(eSensingMode);
;;;489    
;;;490    	MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;491    
;;;492    	PWMDRV_Cmd(ENABLE);
;;;493    	MSPI->SPIAITSTART = MSPI_START_VAL;
;;;494    
;;;495    //	PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;496    	tHalIntrHandle.ulInitFirstFrame = 0;
;;;497    
;;;498    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;499    	HAL_SetTPICMuxEnControl(YES, NO);
;;;500    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;501    
;;;502    #if USED_TOUCH_REPORT_ON_OFF_CONTROL
;;;503    	HAL_SetTouchReportEnControl(YES);
;;;504    #endif /* USED_TOUCH_REPORT_ON_OFF_CONTROL */
;;;505    
;;;506    	return YES;
;;;507    }
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L29.88|
000058  4638              MOV      r0,r7                 ;420
00005a  f7fffffe          BL       SRIC_RegisterInit
00005e  2801              CMP      r0,#1                 ;420
000060  d00d              BEQ      |L29.126|
000062  4638              MOV      r0,r7                 ;425
000064  f7fffffe          BL       SRIC_Reset
000068  f2427010          MOV      r0,#0x2710            ;426
00006c  f7fffffe          BL       delay_us
000070  6860              LDR      r0,[r4,#4]            ;429  ; ulRetryCount
000072  1c6d              ADDS     r5,r5,#1              ;429
000074  1c40              ADDS     r0,r0,#1              ;429
000076  6060              STR      r0,[r4,#4]            ;415  ; ulRetryCount
000078  2d05              CMP      r5,#5                 ;415
00007a  d9ed              BLS      |L29.88|
00007c  e7e9              B        |L29.82|
                  |L29.126|
00007e  f4176f00          TST      r7,#0x800             ;440
000082  d017              BEQ      |L29.180|
000084  6820              LDR      r0,[r4,#0]            ;440  ; ptHalInfo
000086  2501              MOVS     r5,#1                 ;443
000088  7f00              LDRB     r0,[r0,#0x1c]         ;443
00008a  b950              CBNZ     r0,|L29.162|
00008c  2300              MOVS     r3,#0                 ;443
00008e  461a              MOV      r2,r3                 ;443
000090  2103              MOVS     r1,#3                 ;443
000092  2005              MOVS     r0,#5                 ;443
000094  f7fffffe          BL       GPIO_Init
000098  6820              LDR      r0,[r4,#0]            ;443  ; ptHalInfo
00009a  6206              STR      r6,[r0,#0x20]         ;443
00009c  6286              STR      r6,[r0,#0x28]         ;443
00009e  f8806024          STRB     r6,[r0,#0x24]         ;443
                  |L29.162|
0000a2  6820              LDR      r0,[r4,#0]            ;443  ; ptHalInfo
0000a4  7705              STRB     r5,[r0,#0x1c]         ;443
0000a6  f44f70fa          MOV      r0,#0x1f4             ;446
0000aa  f7fffffe          BL       delay_us
0000ae  f7fffffe          BL       module_S3_PGAMMA_I2C_SW_Disable
0000b2  e013              B        |L29.220|
                  |L29.180|
0000b4  202d              MOVS     r0,#0x2d              ;453
0000b6  f7fffffe          BL       GPIO_Get_IN
0000ba  2801              CMP      r0,#1                 ;453
0000bc  d0fa              BEQ      |L29.180|
                  |L29.190|
0000be  202d              MOVS     r0,#0x2d              ;459
0000c0  f7fffffe          BL       GPIO_Get_IN
0000c4  2800              CMP      r0,#0                 ;459
0000c6  d0fa              BEQ      |L29.190|
                  |L29.200|
0000c8  202d              MOVS     r0,#0x2d              ;460
0000ca  f7fffffe          BL       GPIO_Get_IN
0000ce  2801              CMP      r0,#1                 ;460
0000d0  d0fa              BEQ      |L29.200|
                  |L29.210|
0000d2  202d              MOVS     r0,#0x2d              ;461
0000d4  f7fffffe          BL       GPIO_Get_IN
0000d8  2800              CMP      r0,#0                 ;461
0000da  d0fa              BEQ      |L29.210|
                  |L29.220|
0000dc  2001              MOVS     r0,#1                 ;485
0000de  f7fffffe          BL       SRIC_Run
0000e2  2001              MOVS     r0,#1                 ;487
0000e4  f7fffffe          BL       MSPI_ITConfig
0000e8  4638              MOV      r0,r7                 ;488
0000ea  f7fffffe          BL       MSPI_Set_AITMODE
0000ee  2000              MOVS     r0,#0                 ;490
0000f0  f7fffffe          BL       MSPI_Set_BUFSIZE_FingerPenMode
0000f4  2001              MOVS     r0,#1                 ;492
0000f6  f7fffffe          BL       PWMDRV_Cmd
0000fa  f04f2140          MOV      r1,#0x40004000        ;493
0000fe  200f              MOVS     r0,#0xf               ;493
000100  6288              STR      r0,[r1,#0x28]         ;493
000102  f8c86028          STR      r6,[r8,#0x28]         ;496  ; tHalIntrHandle
000106  6820              LDR      r0,[r4,#0]            ;496  ; ptHalInfo
000108  2101              MOVS     r1,#1                 ;499
00010a  7b02              LDRB     r2,[r0,#0xc]          ;499
00010c  2a00              CMP      r2,#0                 ;499
00010e  bf08              IT       EQ                    ;499
000110  6106              STREQ    r6,[r0,#0x10]         ;499
000112  7301              STRB     r1,[r0,#0xc]          ;499
000114  7d02              LDRB     r2,[r0,#0x14]         ;499
000116  2101              MOVS     r1,#1                 ;503
000118  2a00              CMP      r2,#0                 ;503
00011a  bf08              IT       EQ                    ;503
00011c  6186              STREQ    r6,[r0,#0x18]         ;503
00011e  7501              STRB     r1,[r0,#0x14]         ;503
000120  2001              MOVS     r0,#1                 ;506
000122  e8bd81f0          POP      {r4-r8,pc}
;;;508    
                          ENDP

000126  0000              DCW      0x0000
                  |L29.296|
                          DCD      ||.data||
                  |L29.300|
                          DCD      ||.bss||

                          AREA ||i.callPendSV||, CODE, READONLY, ALIGN=2

                  callPendSV PROC
;;;351    
;;;352    void callPendSV(void)
000000  4904              LDR      r1,|L30.20|
;;;353    {
;;;354    	// Set a PendSV to request processing
;;;355    	NVIC_INT_CTRL_REG = NVIC_PENDSVSET_BIT;
000002  f04f5080          MOV      r0,#0x10000000
000006  6008              STR      r0,[r1,#0]
;;;356    	/* Barriers are normally not required but do ensure the code is completely	within the specified behaviour for the architecture. */
;;;357    	__asm volatile( "dsb" );
000008  f3bf8f4f          DSB      
;;;358    	__asm volatile( "isb" );
00000c  f3bf8f6f          ISB      
;;;359    }
000010  4770              BX       lr
;;;360    
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0xe000ed04

                          AREA ||i.initBoardGPIO||, CODE, READONLY, ALIGN=1

                  initBoardGPIO PROC
;;;41     
;;;42     void initBoardGPIO(void)
000000  b510              PUSH     {r4,lr}
;;;43     {
;;;44     	// TSYNCN_OUT
;;;45     	GPIO_Init(_GPIO_TSYNC_OUT, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
000002  2301              MOVS     r3,#1
000004  2200              MOVS     r2,#0
000006  2103              MOVS     r1,#3
000008  2032              MOVS     r0,#0x32
00000a  f7fffffe          BL       GPIO_Init
;;;46     	
;;;47     	// All DC
;;;48     #ifdef _ALL_PWM_DC_
;;;49     	GPIO_Init(_GPIO_PWM_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;50     #endif
;;;51     
;;;52     
;;;53     #if USED_GPIO_UPLINK_LEVEL_CONTROL
;;;54     #if (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_HW_CONTROL)
;;;55     	GPIO_Set_Mode(_GPIO_Uplink_GPIO, GPIO_MODE_FUNC_2);
;;;56     #elif (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)
;;;57     	GPIO_Init(_GPIO_Uplink_GPIO, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
;;;58     #endif /* (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_HW_CONTROL) */
;;;59     #endif /* USED_GPIO_UPLINK_LEVEL_CONTROL */
;;;60     
;;;61     //#if (USED_MODULE_DEF == MODULE_DEF_B_1)
;;;62     //	GPIO_Init(_GPIO_MUX_EN_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;63     //#else /* (USED_MODULE_DEF == MODULE_DEF_B_1) */
;;;64     	GPIO_Init(_GPIO_MUX_EN_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
00000e  2301              MOVS     r3,#1
000010  2200              MOVS     r2,#0
000012  2103              MOVS     r1,#3
000014  e8bd4010          POP      {r4,lr}
000018  2025              MOVS     r0,#0x25
00001a  f7ffbffe          B.W      GPIO_Init
;;;65     //#endif /* (USED_MODULE_DEF == MODULE_DEF_B_1) */
;;;66     
;;;67     #if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;68     	GPIO_Init(_GPIO_MUX_EN2_TPIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;69     #endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;70     }
;;;71     
                          ENDP


                          AREA ||i.initECLK||, CODE, READONLY, ALIGN=2

                  initECLK PROC
;;;105    
;;;106    void initECLK(void)
000000  b510              PUSH     {r4,lr}
;;;107    {
;;;108    	const tHalPwmdrvCommonConf_t * pktHalPwmdrvCommonConf;
;;;109    	pktHalPwmdrvCommonConf = hal_pwmdrv_GetCommonConfig();
000002  f7fffffe          BL       hal_pwmdrv_GetCommonConfig
000006  4604              MOV      r4,r0
;;;110    	// 8. ECLK Configuration  
;;;111    	GPIO_Set_Mode(_GPIO_ECLK_0, GPIO_MODE_FUNC_0);	// ECLK0
000008  2100              MOVS     r1,#0
00000a  202b              MOVS     r0,#0x2b
00000c  f7fffffe          BL       GPIO_Set_Mode
;;;112    	GPIO_Set_DS(_GPIO_ECLK_0, USED_ECLK_DRIVING_STRENGTH);
000010  2102              MOVS     r1,#2
000012  202b              MOVS     r0,#0x2b
000014  f7fffffe          BL       GPIO_Set_DS
;;;113    #if USED_ECLK_1WAY_CONNECTION
;;;114    	GPIO_Init(_GPIO_ECLK_1, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;115    #else
;;;116    	GPIO_Set_Mode(_GPIO_ECLK_1, GPIO_MODE_FUNC_0);	// ECLK1
000018  2100              MOVS     r1,#0
00001a  202c              MOVS     r0,#0x2c
00001c  f7fffffe          BL       GPIO_Set_Mode
;;;117    	GPIO_Set_DS(_GPIO_ECLK_1, USED_ECLK_DRIVING_STRENGTH);
000020  2102              MOVS     r1,#2
000022  202c              MOVS     r0,#0x2c
000024  f7fffffe          BL       GPIO_Set_DS
;;;118    #endif
;;;119    
;;;120    //	SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 0;	// PWMDRV_CLK off
;;;121    	PWMDRV->ECLK_CR.ulBulk = pktHalPwmdrvCommonConf->tCP_ECLK_CR.ulBulk;
000028  f8d41558          LDR      r1,[r4,#0x558]
00002c  4803              LDR      r0,|L32.60|
00002e  f8401f8c          STR      r1,[r0,#0x8c]!
;;;122    	PWMDRV->ECLK_CR.tBit.eclk_force_on = PWM_ECLK_ALWAYS_ON;			// ECLK always on. 0-TSYNC on/off
000032  6801              LDR      r1,[r0,#0]
000034  f4417100          ORR      r1,r1,#0x200
000038  6001              STR      r1,[r0,#0]
;;;123    }
00003a  bd10              POP      {r4,pc}
;;;124    
                          ENDP

                  |L32.60|
                          DCD      0x40002000

                          AREA ||i.initMNT_S3_MODE_GPIO||, CODE, READONLY, ALIGN=1

                  initMNT_S3_MODE_GPIO PROC
;;;93     #if USED_MNT_S3_MODE_FUNCTION
;;;94     void initMNT_S3_MODE_GPIO(void)
000000  b510              PUSH     {r4,lr}
;;;95     {
;;;96     #if USED_S3_POWER_INPUT_CHECK
;;;97     	GPIO_Init(_GPIO_S3_POWER_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
000002  2302              MOVS     r3,#2
000004  2201              MOVS     r2,#1
000006  2103              MOVS     r1,#3
000008  2008              MOVS     r0,#8
00000a  f7fffffe          BL       GPIO_Init
;;;98     #endif /* USED_S3_POWER_INPUT_CHECK */
;;;99     
;;;100    #if USED_S3_SIGNAL_OUTPUT_CTRL
;;;101    	GPIO_Init(_GPIO_S3_SIGNAL_OUT, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_LOW);
00000e  2300              MOVS     r3,#0
000010  2103              MOVS     r1,#3
000012  e8bd4010          POP      {r4,lr}
000016  461a              MOV      r2,r3
000018  2007              MOVS     r0,#7
00001a  f7ffbffe          B.W      GPIO_Init
;;;102    #endif /* USED_S3_SIGNAL_OUTPUT_CTRL */
;;;103    }
;;;104    #endif /* USED_MNT_S3_MODE_FUNCTION */
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tHalIntrHandle
                          %        48

                          AREA ||.data||, DATA, ALIGN=2

                  ptHalInfo
                          DCD      0x00000000
                  ulRetryCount
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_9cc174c9____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___5_hal_c_9cc174c9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_9cc174c9____REVSH|
#line 402
|__asm___5_hal_c_9cc174c9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_9cc174c9____RRX|
#line 587
|__asm___5_hal_c_9cc174c9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
