; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\algorithm_baseline.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\algorithm_baseline.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\algorithm_baseline.crf ..\..\App\Algorithm\Baseline\algorithm_baseline.c]
                          THUMB

                          AREA ||i.abnormal_rawdata_detection_for_hopping||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_detection_for_hopping PROC
;;;713    
;;;714    bool_t abnormal_rawdata_detection_for_hopping(bool_t SET)
000000  4907              LDR      r1,|L1.32|
;;;715    {
;;;716    	static uint32_t AbnormalCnt  = 0;
;;;717    	uint32_t lAbnormalCnt = 0;
;;;718    
;;;719    	if( SET )
000002  2800              CMP      r0,#0
000004  698a              LDR      r2,[r1,#0x18]
;;;720    	{
;;;721    		AbnormalCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  6188              STRNE    r0,[r1,#0x18]  ; AbnormalCnt
00000c  d105              BNE      |L1.26|
;;;722    	}
;;;723    	else
;;;724    	{
;;;725    		lAbnormalCnt = AbnormalCnt;
;;;726    		AbnormalCnt = 0;
00000e  2000              MOVS     r0,#0
;;;727    
;;;728    		if(lAbnormalCnt > 0)
000010  6188              STR      r0,[r1,#0x18]  ; AbnormalCnt
000012  2a00              CMP      r2,#0
;;;729    		{
;;;730    			return TRUE;
000014  bf1c              ITT      NE
000016  2001              MOVNE    r0,#1
;;;731    		}
;;;732    	}
;;;733    	return FALSE;
;;;734    }
000018  4770              BXNE     lr
                  |L1.26|
00001a  2000              MOVS     r0,#0                 ;733
00001c  4770              BX       lr
;;;735    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||

                          AREA ||i.abnormal_rawdata_temp||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_temp PROC
;;;690    
;;;691    bool_t abnormal_rawdata_temp(bool_t SET)
000000  4907              LDR      r1,|L2.32|
;;;692    {
;;;693    	static uint32_t dataCnt = 0;
;;;694    	uint32_t ldataCnt = 0;
;;;695    
;;;696    	if(SET)
000002  2800              CMP      r0,#0
000004  694a              LDR      r2,[r1,#0x14]
;;;697    	{
;;;698    		dataCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  6148              STRNE    r0,[r1,#0x14]  ; dataCnt
00000c  d105              BNE      |L2.26|
;;;699    	}
;;;700    	else
;;;701    	{
;;;702    		ldataCnt = dataCnt;
;;;703    		dataCnt = 0;
00000e  2000              MOVS     r0,#0
;;;704    
;;;705    		if(ldataCnt > 10)
000010  6148              STR      r0,[r1,#0x14]  ; dataCnt
000012  2a0a              CMP      r2,#0xa
;;;706    		{
;;;707    			return TRUE;
000014  bf84              ITT      HI
000016  2001              MOVHI    r0,#1
;;;708    		}
;;;709    	}
;;;710    
;;;711    	return FALSE;
;;;712    }
000018  4770              BXHI     lr
                  |L2.26|
00001a  2000              MOVS     r0,#0                 ;711
00001c  4770              BX       lr
;;;713    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_2_tracking_initial_local||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_2_tracking_initial_local PROC
;;;457    #else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;458    bool_t algorithm_baseline_2_tracking_initial_local(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;459    {
;;;460    	int r, c;
;;;461    	uint32_t ulRowEnd = PEN_COORD_ROW_MAX;
000004  2605              MOVS     r6,#5
;;;462    	uint16_t temp_data = 0;
;;;463    	ePartialSensing_t lDataIndex = PARTIAL_PEN_BEACON;
;;;464    	bool_t local_base_return_flag = NO;
;;;465        int finger_div = ((ROW_MAX + (PEN_COORD_ROW_MAX - 1)) / PEN_COORD_ROW_MAX);
;;;466    
;;;467    	sensingRowStart = 0;
000006  4c61              LDR      r4,|L3.396|
000008  2000              MOVS     r0,#0                 ;464
00000a  9000              STR      r0,[sp,#0]
00000c  f04f0809          MOV      r8,#9                 ;465
000010  8020              STRH     r0,[r4,#0]
;;;468    
;;;469    	module_wait_Vsync_signal(LOCAL_MODE, thisModeConf->BaseLine.ucDiscardFrameNum);
000012  4f5f              LDR      r7,|L3.400|
000014  68b8              LDR      r0,[r7,#8]  ; thisModeConf
000016  7841              LDRB     r1,[r0,#1]
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       module_wait_Vsync_signal
;;;470    
;;;471        while(YES)
;;;472        {
;;;473    		lDataIndex = module_wait_local_sample_done();
00001e  bf00              NOP      
                  |L3.32|
000020  f7fffffe          BL       module_wait_local_sample_done
;;;474    
;;;475    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;476    		if(lDataIndex == LOCAL_OP_2_LAST_LHB)
;;;477    #else
;;;478    		if(lDataIndex == LOCAL_OP_LAST_LHB || lDataIndex == PARTIAL_MAX)
000024  2808              CMP      r0,#8
000026  bf18              IT       NE
000028  2816              CMPNE    r0,#0x16
00002a  d1f9              BNE      |L3.32|
;;;479    #endif
;;;480    		{
;;;481    			break;
;;;482    		}
;;;483    	}
;;;484    
;;;485        tHalIntrHandle.ulLocalIndexChangeStart = 1;
00002c  4959              LDR      r1,|L3.404|
00002e  f04f0001          MOV      r0,#1
000032  6088              STR      r0,[r1,#8]  ; tHalIntrHandle
;;;486    
;;;487    	uint8_t BaseOffset = thisModeConf->BaseLine.ucPP_MUX_Select * PEN_COORD_ROW_MAX;
000034  68b8              LDR      r0,[r7,#8]  ; thisModeConf
;;;488    	
;;;489    	while(YES)
;;;490    	{
;;;491    		lDataIndex = module_wait_local_sample_done();
;;;492    
;;;493    		switch(lDataIndex)
;;;494    		{
;;;495    			case PARTIAL_PEN_COORD1:
;;;496    			case PARTIAL_PEN_COORD2:
;;;497    			case PARTIAL_PEN_COORD3:
;;;498    			case PARTIAL_PEN_COORD4:
;;;499    			{
;;;500    				int prev_raw_data = HAL_READ_LOCAL_RAW_IMAGE(0, 0);
000036  4d58              LDR      r5,|L3.408|
000038  f8900042          LDRB     r0,[r0,#0x42]         ;487
00003c  eb000080          ADD      r0,r0,r0,LSL #2       ;487
000040  b2c7              UXTB     r7,r0                 ;487
000042  bf00              NOP                            ;491
                  |L3.68|
000044  f7fffffe          BL       module_wait_local_sample_done
000048  2806              CMP      r0,#6                 ;493
00004a  d0fb              BEQ      |L3.68|
00004c  dc08              BGT      |L3.96|
00004e  2801              CMP      r0,#1                 ;493
000050  bf18              IT       NE                    ;493
000052  2802              CMPNE    r0,#2                 ;493
000054  d00f              BEQ      |L3.118|
000056  2803              CMP      r0,#3                 ;493
000058  bf18              IT       NE                    ;493
00005a  2804              CMPNE    r0,#4                 ;493
00005c  d00b              BEQ      |L3.118|
00005e  e052              B        |L3.262|
                  |L3.96|
000060  2807              CMP      r0,#7                 ;493
000062  bf18              IT       NE                    ;493
000064  2808              CMPNE    r0,#8                 ;493
000066  d04e              BEQ      |L3.262|
000068  280c              CMP      r0,#0xc               ;493
;;;501    				int temp_raw_data;
;;;502    				int sub_data;
;;;503    				int g_temp_sum = 0;
;;;504    
;;;505    				for(r = 0; r < ulRowEnd; r++)
;;;506    				{
;;;507    					for(c = 0; c < COL_MAX; c++)
;;;508    					{
;;;509    						temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r+BaseOffset, c);
;;;510    						temp_data = HAL_READ_LOCAL_BASELINE_IMAGE_2(r + sensingRowStart, c) + temp_raw_data;
;;;511    						HAL_WRITE_LOCAL_BASELINE_IMAGE_2(r + sensingRowStart, c, temp_data);
;;;512    						sub_data = (prev_raw_data - temp_raw_data);
;;;513    
;;;514    						/*
;;;515    						 * TODD_1st : 아래 상수값 parameter로 빼자!!
;;;516    						 */
;;;517    						if(sub_data < 0)
;;;518    						{
;;;519    							sub_data = -sub_data;
;;;520    						}
;;;521    						if(sub_data > 200)
;;;522    						{
;;;523    							g_temp_sum += sub_data;
;;;524    						}
;;;525    
;;;526    						prev_raw_data = temp_raw_data;
;;;527    					}
;;;528    				}
;;;529    
;;;530    //				if(g_temp_sum > 1000)
;;;531    //				{
;;;532    //					local_base_return_flag = YES;
;;;533    //				}
;;;534    				break;
;;;535    			}
;;;536    			case LOCAL_FINGER_LAST_LHB:
;;;537    			{
;;;538    				for (r = 0; r < ROW_MAX; r++)
00006a  bf04              ITT      EQ
00006c  2100              MOVEQ    r1,#0
;;;539    				{
;;;540    					for (c = 0; c < COL_MAX; c++)
;;;541    					{
;;;542    						temp_data = HAL_READ_LOCAL_FINGER_BASELINE_IMAGE_2(r, c) + HAL_READ_LOCAL_FINGER_RAW_IMAGE(r, c);
;;;543    						HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE_2(r, c, temp_data);
00006e  f8df912c          LDREQ    r9,|L3.412|
000072  d032              BEQ      |L3.218|
000074  e047              B        |L3.262|
                  |L3.118|
000076  2e00              CMP      r6,#0                 ;505
000078  bf18              IT       NE                    ;505
00007a  2300              MOVNE    r3,#0                 ;505
00007c  d943              BLS      |L3.262|
00007e  bf00              NOP                            ;507
                  |L3.128|
000080  eb030207          ADD      r2,r3,r7              ;509
000084  eb020282          ADD      r2,r2,r2,LSL #2       ;509
000088  f04f0100          MOV      r1,#0                 ;507
00008c  eb051a42          ADD      r10,r5,r2,LSL #5      ;509
                  |L3.144|
000090  f8b49000          LDRH     r9,[r4,#0]            ;510  ; sensingRowStart
000094  f83a2011          LDRH     r2,[r10,r1,LSL #1]    ;509
000098  4499              ADD      r9,r9,r3              ;510
00009a  eb090989          ADD      r9,r9,r9,LSL #2       ;510
00009e  eb051949          ADD      r9,r5,r9,LSL #5       ;510
0000a2  eb090941          ADD      r9,r9,r1,LSL #1       ;510
0000a6  f5095900          ADD      r9,r9,#0x2000         ;510
0000aa  f8b4b000          LDRH     r11,[r4,#0]           ;511  ; sensingRowStart
0000ae  f8b998a0          LDRH     r9,[r9,#0x8a0]        ;510
0000b2  4491              ADD      r9,r9,r2              ;510
0000b4  449b              ADD      r11,r11,r3            ;511
0000b6  eb0b0b8b          ADD      r11,r11,r11,LSL #2    ;511
0000ba  eb051b4b          ADD      r11,r5,r11,LSL #5     ;511
0000be  eb0b0b41          ADD      r11,r11,r1,LSL #1     ;511
0000c2  f50b5b00          ADD      r11,r11,#0x2000       ;511
0000c6  f1010101          ADD      r1,r1,#1              ;511
0000ca  f8ab98a0          STRH     r9,[r11,#0x8a0]       ;511
0000ce  2950              CMP      r1,#0x50              ;526
0000d0  dbde              BLT      |L3.144|
0000d2  1c5b              ADDS     r3,r3,#1              ;517
0000d4  42b3              CMP      r3,r6                 ;526
0000d6  d3d3              BCC      |L3.128|
0000d8  e015              B        |L3.262|
                  |L3.218|
0000da  eb090c41          ADD      r12,r9,r1,LSL #1
0000de  f50c5240          ADD      r2,r12,#0x3000
0000e2  f839a011          LDRH     r10,[r9,r1,LSL #1]
0000e6  f8b23840          LDRH     r3,[r2,#0x840]
0000ea  f8bcc002          LDRH     r12,[r12,#2]
0000ee  4453              ADD      r3,r3,r10
0000f0  f8b2a842          LDRH     r10,[r2,#0x842]
0000f4  f8a23840          STRH     r3,[r2,#0x840]
0000f8  44d4              ADD      r12,r12,r10
0000fa  1c89              ADDS     r1,r1,#2
0000fc  f8a2c842          STRH     r12,[r2,#0x842]
000100  f5b16f61          CMP      r1,#0xe10
000104  dbe9              BLT      |L3.218|
                  |L3.262|
;;;544    					}
;;;545    				}
;;;546    				break;
;;;547    			}
;;;548    			case PARTIAL_PEN_DATA1:
;;;549    			case PARTIAL_PEN_DATA2:
;;;550    			case PARTIAL_PEN_DATA3:
;;;551    			case PARTIAL_PEN_DATA4:
;;;552    			case PARTIAL_MAX:
;;;553    			default:
;;;554    				break;
;;;555    		}
;;;556    
;;;557    		if(lDataIndex == PARTIAL_PEN_COORD4)
000106  2804              CMP      r0,#4
000108  d028              BEQ      |L3.348|
;;;558    		{
;;;559    			sensingRowStart += PEN_COORD_ROW_MAX;
;;;560    			if(sensingRowStart >= ROW_MAX)
;;;561    			{
;;;562    				sensingRowStart = 0;
;;;563    			}
;;;564    			else if((ROW_MAX - sensingRowStart) < PEN_COORD_ROW_MAX)
;;;565    			{
;;;566    				ulRowEnd = (ROW_MAX - sensingRowStart);
;;;567    			}
;;;568    		}
;;;569    
;;;570    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;571    		if(lDataIndex == LOCAL_OP_2_LAST_LHB && sensingRowStart == 0)
;;;572    		{
;;;573    			break;
;;;574    		}
;;;575    #else
;;;576    		if((lDataIndex == LOCAL_OP_LAST_LHB && sensingRowStart == 0) || lDataIndex == PARTIAL_MAX)
00010a  2808              CMP      r0,#8
00010c  d039              BEQ      |L3.386|
00010e  2816              CMP      r0,#0x16
000110  d198              BNE      |L3.68|
;;;577    		{
;;;578    			break;
;;;579    		}
;;;580    #endif
;;;581    	}
;;;582    
;;;583    	for(r = ROW_MAX; r--; )
;;;584    	{
;;;585    		for(c=COL_MAX; c--; )
;;;586    		{
;;;587    			temp_data = HAL_READ_LOCAL_BASELINE_IMAGE_2(r, c);
;;;588    			temp_data /= 4;
;;;589    			HAL_WRITE_LOCAL_BASELINE_IMAGE_2(r, c, temp_data);
;;;590    
;;;591    			temp_data = HAL_READ_LOCAL_FINGER_BASELINE_IMAGE_2(r, c);
;;;592    			temp_data /= finger_div;
;;;593    			HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE_2(r, c, temp_data);
;;;594    		}
;;;595    	}
;;;596    
;;;597    	return local_base_return_flag;
;;;598    }
000112  bf00              NOP      
                  |L3.276|
000114  4c21              LDR      r4,|L3.412|
000116  f04f0c2c          MOV      r12,#0x2c
00011a  f642163e          MOV      r6,#0x293e            ;585
00011e  f64307de          MOV      r7,#0x38de            ;585
000122  bf00              NOP                            ;585
                  |L3.292|
000124  eb0c008c          ADD      r0,r12,r12,LSL #2     ;585
000128  eb051140          ADD      r1,r5,r0,LSL #5       ;585
00012c  eb041040          ADD      r0,r4,r0,LSL #5       ;585
000130  4431              ADD      r1,r1,r6              ;585
000132  4438              ADD      r0,r0,r7              ;585
000134  2250              MOVS     r2,#0x50              ;585
                  |L3.310|
000136  8803              LDRH     r3,[r0,#0]            ;585
000138  f8b19000          LDRH     r9,[r1,#0]            ;588
00013c  fb93f3f8          SDIV     r3,r3,r8              ;592
000140  ea4f0999          LSR      r9,r9,#2              ;588
000144  f8219902          STRH     r9,[r1],#-2           ;589
000148  f8203902          STRH     r3,[r0],#-2           ;593
00014c  1e52              SUBS     r2,r2,#1              ;593
00014e  d1f2              BNE      |L3.310|
000150  f1bc0c01          SUBS     r12,r12,#1            ;593
000154  d2e6              BCS      |L3.292|
000156  9800              LDR      r0,[sp,#0]            ;597
000158  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.348|
00015c  8820              LDRH     r0,[r4,#0]            ;559  ; sensingRowStart
00015e  1d40              ADDS     r0,r0,#5              ;559
000160  8020              STRH     r0,[r4,#0]            ;559
000162  8820              LDRH     r0,[r4,#0]            ;560  ; sensingRowStart
000164  282d              CMP      r0,#0x2d              ;560
000166  bf24              ITT      CS                    ;562
000168  2000              MOVCS    r0,#0                 ;562
00016a  8020              STRHCS   r0,[r4,#0]            ;562
00016c  f4bfaf6a          BCS      |L3.68|
000170  8820              LDRH     r0,[r4,#0]            ;564  ; sensingRowStart
000172  f1c0002d          RSB      r0,r0,#0x2d           ;564
000176  2805              CMP      r0,#5                 ;564
000178  bfbc              ITT      LT                    ;566
00017a  8820              LDRHLT   r0,[r4,#0]            ;566  ; sensingRowStart
00017c  f1c0062d          RSBLT    r6,r0,#0x2d           ;566
000180  e760              B        |L3.68|
                  |L3.386|
000182  8820              LDRH     r0,[r4,#0]            ;576  ; sensingRowStart
000184  2800              CMP      r0,#0                 ;576
000186  f47faf5d          BNE      |L3.68|
00018a  e7c3              B        |L3.276|
;;;599    #endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
                          ENDP

                  |L3.396|
                          DCD      sensingRowStart
                  |L3.400|
                          DCD      ||.data||
                  |L3.404|
                          DCD      tHalIntrHandle
                  |L3.408|
                          DCD      LocalSharedBuff
                  |L3.412|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_calculate_delta||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta PROC
;;;810    
;;;811    bool_t algorithm_baseline_calculate_delta(int mode)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;812    {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
;;;813    	int r, c;
;;;814    	int delta;	
;;;815    //	int local_rs;
;;;816    //	int pen_touch_data = 0;
;;;817    	uint16_t read_raw_data;
;;;818    //	tCell_t pen_pos;
;;;819    //	int pen_touch_data2 = 0;
;;;820    	tOrigDeltaInfo_t * temp_delta;
;;;821    	uint16_t * pBaseImage;
;;;822    	tAppInfo_t * ptAppInfo = app_GetInfo();
000008  f7fffffe          BL       app_GetInfo
;;;823    	
;;;824    	//Adaptive SeedBase LYB_200819
;;;825    	uint16_t AdaptiveSeedBase = 0;
;;;826    	
;;;827    #if CPI_TEST_EN
;;;828    	uint16_t AbnormalRawCnt = 0;	
;;;829    	uint32_t RawPartSum[COL_MAX/5+1] = {0};
;;;830    	uint16_t RawPartSumCnt[COL_MAX/5+1] = {0};
;;;831    	uint16_t AbnormalDeltaCntInMux[COL_MAX/5+1] = {0};
;;;832    	int DeltaEdgeCntInMux = 0;
;;;833    	uint8_t PhoneNoiseConditionCnt = 0;
;;;834    #endif
;;;835    #if LGD_ERROR_FRAME_PROCESS_EN
;;;836    	int EvenDelta = 0, OddDelta = 0;
;;;837    #endif
;;;838    	thisInfo->bBlockTracking = NO;
00000c  f8df81f0          LDR      r8,|L4.512|
000010  2700              MOVS     r7,#0
000012  4606              MOV      r6,r0                 ;822
000014  f8d8400c          LDR      r4,[r8,#0xc]  ; thisInfo
;;;839    //	local_rs = 0;
;;;840    	temp_delta = &thisInfo->tDelta;
;;;841    
;;;842    	memset((void *)temp_delta, 0x00, sizeof(tOrigDeltaInfo_t));
000018  212c              MOVS     r1,#0x2c
00001a  f8047b0d          STRB     r7,[r4],#0xd          ;838
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __aeabi_memclr
;;;843    	temp_delta->tValidRect.cs = COL_MAX - 1; temp_delta->tValidRect.ce = 0;
000024  204f              MOVS     r0,#0x4f
000026  70a0              STRB     r0,[r4,#2]
000028  70e7              STRB     r7,[r4,#3]
;;;844    	temp_delta->tValidRect.rs = ROW_MAX - 1; temp_delta->tValidRect.re = 0;
00002a  202c              MOVS     r0,#0x2c
00002c  7020              STRB     r0,[r4,#0]
00002e  7067              STRB     r7,[r4,#1]
;;;845    #if USED_NOISE_HOPPING_FREQ
;;;846    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
000030  7cb0              LDRB     r0,[r6,#0x12]
000032  2801              CMP      r0,#1
;;;847    	{
;;;848    		pBaseImage = g_pFingerBaseImage;
000034  bf08              IT       EQ
000036  f8d8c01c          LDREQ    r12,[r8,#0x1c]  ; g_pFingerBaseImage
00003a  d001              BEQ      |L4.64|
;;;849    	}
;;;850    	else
;;;851    	{
;;;852    		pBaseImage = (uint16_t *)HAL_GET_HOPP1_BASELINE_IMAGE_PTR() ;
00003c  f8dfc1c4          LDR      r12,|L4.516|
                  |L4.64|
;;;853    	}
;;;854    //	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;855    #else /* USED_NOISE_HOPPING_FREQ */
;;;856    	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;857    #endif /* USED_NOISE_HOPPING_FREQ */
;;;858    	
;;;859    	temp_delta->iPosCnt = 0;
000040  6167              STR      r7,[r4,#0x14]
;;;860    	temp_delta->iNegCnt = 0;
000042  61e7              STR      r7,[r4,#0x1c]
;;;861    
;;;862    
;;;863    //#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)	
;;;864    //	tRect_t FingerNonSumOnPenArea;
;;;865    //	bool_t bNonSumFlag = 0;
;;;866    //	FingerNonSumOnPenArea.cs = COL_MAX-1; FingerNonSumOnPenArea.ce = 0;
;;;867    //	FingerNonSumOnPenArea.rs = ROW_MAX-1; FingerNonSumOnPenArea.re = 0;
;;;868    //	if(thisInfo->tDelta_local.iMaxStrength > FingerNonSumThOnPenAreaForReBase
;;;869    //	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;870    //	&& hal_Info_GetControlLocalFingerOPType() == ACTIVEPEN_TYPE_LOCAL_MS
;;;871    //	#endif
;;;872    //	)
;;;873    //	{
;;;874    //		FingerNonSumOnPenArea.cs = MAX(0,thisInfo->tDelta_local.tMaxCellPos.c-3);
;;;875    //		FingerNonSumOnPenArea.ce = MIN(COL_MAX-1,thisInfo->tDelta_local.tMaxCellPos.c+3);
;;;876    //		FingerNonSumOnPenArea.rs = MAX(0,thisInfo->tDelta_local.tMaxCellPos.r+currentRowStart-3);
;;;877    //		FingerNonSumOnPenArea.re = MIN(ROW_MAX-1,thisInfo->tDelta_local.tMaxCellPos.r+currentRowStart+3);
;;;878    //		bNonSumFlag = 1;
;;;879    //	}
;;;880    //#endif
;;;881    	
;;;882    #if (USED_DSPA_FUNC_FOR_FINGER && USED_DSPA_FUNC_FOR_FINGER_CAL_DELTA)
;;;883    	if(!thisModeConf->BaseLine.bDspA_Finger_CalculateDelta)
;;;884    #endif
;;;885    	{
;;;886    		
;;;887    #if ADAPTIVE_SEEDBASE
;;;888    		//Adaptive SeedBase LYB_200819
;;;889    		if(thisInfo->bIsPalm)	AdaptiveSeedBase = (thisModeConf->Label.usSeedBase>>1);
000044  f8d8000c          LDR      r0,[r8,#0xc]  ; thisInfo
000048  9000              STR      r0,[sp,#0]
00004a  f8900fb2          LDRB     r0,[r0,#0xfb2]
00004e  2800              CMP      r0,#0
;;;890    		else					AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
000050  f8d80008          LDR      r0,[r8,#8]  ; thisModeConf
000054  bf1a              ITTE     NE                    ;889
000056  f8b0005f          LDRHNE   r0,[r0,#0x5f]         ;889
00005a  0846              LSRNE    r6,r0,#1              ;889
00005c  f8b0605f          LDRHEQ   r6,[r0,#0x5f]
;;;891    #else
;;;892    		AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
;;;893    #endif
;;;894    		
;;;895    		for( r=0; r<ROW_MAX; r++ )
000060  2200              MOVS     r2,#0
000062  4867              LDR      r0,|L4.512|
000064  6981              LDR      r1,[r0,#0x18]  ; AbnormalCnt
000066  9101              STR      r1,[sp,#4]
;;;896    		{
;;;897    #if LGD_ERROR_FRAME_PROCESS_EN
;;;898    			if(thisModeConf->Noise.ucErrorFrameProcess == 2){
;;;899    				EvenDelta = 0, OddDelta = 0;
;;;900    			}
;;;901    #endif
;;;902    			for( c=0; c<COL_MAX; c++ )
;;;903    			{
;;;904    				read_raw_data = HAL_READ_RAW_IMAGE(r, c);
;;;905    				
;;;906    #if CPI_TEST_EN
;;;907    				if(thisModeConf->Noise.ucCPITestOn){
;;;908    					RawPartSum[c/5] += read_raw_data;
;;;909    					RawPartSumCnt[c/5]++;
;;;910    					if(read_raw_data <= 0)	AbnormalRawCnt++;
;;;911    				}
;;;912    #endif
;;;913    				
;;;914    				delta = (signed)read_raw_data - (signed)(*(pBaseImage++));
;;;915    
;;;916    				if(mode == FULL_MODE)
;;;917    				{							
;;;918    					if(read_raw_data < MINRAWDATA_MARGIN)
;;;919    					{
;;;920    						abnormal_rawdata_temp(TRUE);
;;;921    					}
;;;922    #if USED_NOISE_HOPPING_FREQ
;;;923    					if( read_raw_data < thisModeConf->Noise.usRawDataThd )
;;;924    					{
;;;925    						if( HAL_READ_DELTA_IMAGE(r,c) < thisModeConf->Noise.sDeltaDataThd )
;;;926    						{
;;;927    							abnormal_rawdata_detection_for_hopping(TRUE);
;;;928    						}
;;;929    					}
;;;930    
;;;931    #endif /* USED_NOISE_HOPPING_FREQ */
;;;932    				}
;;;933    				
;;;934    #if NORMALIZE_DELTA_EN
;;;935    				//Normalize Active 190612 limyb
;;;936    				if(thisModeConf->BaseLine.cNormalizeDelta != 0 && delta > (AdaptiveSeedBase>>1))
;;;937    				{
;;;938    	//				int left_top = 1;
;;;939    	//				int right_bottom = 128;
;;;940    					int nDelta = delta;
;;;941    					
;;;942    	//				nDelta = nDelta * (2*ROW_MAX + r) * (2*COL_MAX + c) / (ROW_MAX * COL_MAX);
;;;943    //					delta = nDelta * ( ((ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta)<<1) - r) / (ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta);
;;;944    					delta = nDelta * (ROW_MAX + ((ROW_MAX - r)>>2)) / ROW_MAX;
;;;945    				}
;;;946    #endif
;;;947    				
;;;948    				delta >>= ptModuleModeConf->ucOvrShift;
;;;949    				
;;;950    				#if ConflictTest
;;;951    //				if(c < COL_MAX >> 1){
;;;952    //					HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;953    //					HAL_WRITE_DELTA_IMAGE(r, c+(COL_MAX >> 1),delta);
;;;954    //				}
;;;955    				HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;956    				#else
;;;957    				HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;958    				#endif
;;;959    				
;;;960    #if LGD_ERROR_FRAME_PROCESS_EN
;;;961    				//LGD Kiosk error data rejection
;;;962    				if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;963    				{
;;;964    					if(c%2 == 0)	EvenDelta += delta;
;;;965    					else			OddDelta += delta;
;;;966    				}
;;;967    #endif
;;;968    				
;;;969    				//Mux baundary
;;;970    #if CPI_TEST_EN
;;;971    				if(thisModeConf->Noise.ucCPITestOn){
;;;972    					if(c != 0 && c < COL_MAX-1)
;;;973    					{
;;;974    						if(c%5 == 0){
;;;975    							if( abs(delta) > 10 && abs(delta - HAL_READ_DELTA_IMAGE(r,c-1)) > (abs(delta - HAL_READ_DELTA_IMAGE(r,c+1))<<1) )
;;;976    								DeltaEdgeCntInMux++;
;;;977    						}
;;;978    					}
;;;979    				
;;;980    					if(c%5 == 0)	PhoneNoiseConditionCnt = 0;
;;;981    					if(delta < -100)	PhoneNoiseConditionCnt++;
;;;982    					if(PhoneNoiseConditionCnt == 5)	AbnormalDeltaCntInMux[c/5] += 200;
;;;983    				}
;;;984    #endif
;;;985    				
;;;986    				if( delta > 0 )
;;;987    				{	
;;;988    					if( delta > thisModeConf->BaseLine.sAccumPosSumThd )
;;;989    					{
;;;990    #if CPI_TEST_EN
;;;991    						if(thisModeConf->Noise.ucCPITestOn){
;;;992    							if(delta > 511)	AbnormalDeltaCntInMux[c/5] += 200;
;;;993    						}
;;;994    #endif
;;;995    //#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)							
;;;996    //						if((FingerNonSumOnPenArea.cs > c || FingerNonSumOnPenArea.ce < c || FingerNonSumOnPenArea.rs > r || FingerNonSumOnPenArea.re < r) && bNonSumFlag)
;;;997    //#endif
;;;998    						{
;;;999    							temp_delta->iPosCnt++;
;;;1000   							temp_delta->iPosSum += delta - thisModeConf->BaseLine.sAccumPosSumThd;
;;;1001   						}
;;;1002   					}
;;;1003   
;;;1004   //					if( delta > thisModeConf->Label.usSeedBase )
;;;1005   					if( delta > AdaptiveSeedBase )
;;;1006   					{
;;;1007   						if( temp_delta->tValidRect.cs > c )
;;;1008   							temp_delta->tValidRect.cs = c;
;;;1009   						if( temp_delta->tValidRect.ce < c )
;;;1010   							temp_delta->tValidRect.ce = c;
;;;1011   						if( temp_delta->tValidRect.rs > r )
;;;1012   							temp_delta->tValidRect.rs = r;
;;;1013   						if( temp_delta->tValidRect.re < r )
;;;1014   							temp_delta->tValidRect.re = r;
;;;1015   
;;;1016   						temp_delta->iGroupedCellCnt++;
;;;1017   					}
;;;1018   
;;;1019   					if( temp_delta->iMaxStrength < delta )
;;;1020   					{
;;;1021   						temp_delta->iMaxStrength = delta;
;;;1022   					}
;;;1023   				}
;;;1024   				else
;;;1025   				{
;;;1026   					if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;1027   					{
;;;1028   #if CPI_TEST_EN
;;;1029   						if(thisModeConf->Noise.ucCPITestOn){
;;;1030   							AbnormalDeltaCntInMux[c/5]+=5;
;;;1031   							if(delta < -300)	AbnormalDeltaCntInMux[c/5] += 200;
;;;1032   						}
;;;1033   #endif
;;;1034   //#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)				
;;;1035   //						if((FingerNonSumOnPenArea.cs > c || FingerNonSumOnPenArea.ce < c || FingerNonSumOnPenArea.rs > r || FingerNonSumOnPenArea.re < r) && bNonSumFlag)
;;;1036   //#endif
;;;1037   						{						
;;;1038   							temp_delta->iNegCnt++;
;;;1039   							temp_delta->iNegSum += delta - thisModeConf->BaseLine.sAccumNegSumThd;
000068  f8d08014          LDR      r8,[r0,#0x14]  ; dataCnt
00006c  6883              LDR      r3,[r0,#8]  ; thisModeConf
00006e  9302              STR      r3,[sp,#8]            ;948
000070  f8d0a004          LDR      r10,[r0,#4]           ;948  ; ptModuleModeConf
                  |L4.116|
000074  4f64              LDR      r7,|L4.520|
000076  eb020082          ADD      r0,r2,r2,LSL #2       ;904
00007a  2100              MOVS     r1,#0                 ;902
00007c  eb071b40          ADD      r11,r7,r0,LSL #5      ;904
000080  f1c2092d          RSB      r9,r2,#0x2d           ;944
000084  202d              MOVS     r0,#0x2d              ;944
000086  eb0000a9          ADD      r0,r0,r9,ASR #2       ;944
00008a  9004              STR      r0,[sp,#0x10]         ;925
00008c  eb0200c2          ADD      r0,r2,r2,LSL #3       ;925
000090  eb001042          ADD      r0,r0,r2,LSL #5       ;925
000094  eb070980          ADD      r9,r7,r0,LSL #2       ;925
;;;1040   						}
;;;1041   					}
;;;1042   
;;;1043   
;;;1044   					if( temp_delta->iMinStrength > delta )
;;;1045   					{
;;;1046   						temp_delta->iMinStrength = delta;
;;;1047   						temp_delta->tMinCellPos.r = r;
000098  b250              SXTB     r0,r2
00009a  9003              STR      r0,[sp,#0xc]
                  |L4.156|
00009c  f83b7011          LDRH     r7,[r11,r1,LSL #1]    ;904
0000a0  f83c0b02          LDRH     r0,[r12],#2           ;914
0000a4  1a38              SUBS     r0,r7,r0              ;914
0000a6  b9a5              CBNZ     r5,|L4.210|
0000a8  2f0a              CMP      r7,#0xa               ;918
0000aa  bf38              IT       CC                    ;918
0000ac  f1080801          ADDCC    r8,r8,#1              ;918
0000b0  f8b3e1e7          LDRH     lr,[r3,#0x1e7]        ;923
0000b4  45be              CMP      lr,r7                 ;923
0000b6  d90c              BLS      |L4.210|
0000b8  eb090741          ADD      r7,r9,r1,LSL #1       ;925
0000bc  f5074740          ADD      r7,r7,#0xc000         ;925
0000c0  f9b3e1e9          LDRSH    lr,[r3,#0x1e9]        ;925
0000c4  f9b7797e          LDRSH    r7,[r7,#0x97e]        ;925
0000c8  4577              CMP      r7,lr                 ;925
0000ca  da02              BGE      |L4.210|
0000cc  9f01              LDR      r7,[sp,#4]            ;925
0000ce  1c7f              ADDS     r7,r7,#1              ;925
0000d0  9701              STR      r7,[sp,#4]            ;925
                  |L4.210|
0000d2  781f              LDRB     r7,[r3,#0]            ;936
0000d4  2f00              CMP      r7,#0                 ;936
0000d6  bf18              IT       NE                    ;936
0000d8  ebb00f56          CMPNE    r0,r6,LSR #1          ;936
0000dc  dd09              BLE      |L4.242|
0000de  9f04              LDR      r7,[sp,#0x10]         ;944
0000e0  f8dfe128          LDR      lr,|L4.524|
0000e4  4378              MULS     r0,r7,r0              ;944
0000e6  2700              MOVS     r7,#0                 ;944
0000e8  fbce7000          SMLAL    r7,r0,lr,r0           ;944
0000ec  1147              ASRS     r7,r0,#5              ;944
0000ee  eba770e0          SUB      r0,r7,r0,ASR #31      ;944
                  |L4.242|
0000f2  f89a7000          LDRB     r7,[r10,#0]           ;948
0000f6  4138              ASRS     r0,r0,r7              ;948
0000f8  eb090741          ADD      r7,r9,r1,LSL #1       ;955
0000fc  f5074740          ADD      r7,r7,#0xc000         ;955
000100  2800              CMP      r0,#0                 ;986
000102  f8a7097e          STRH     r0,[r7,#0x97e]        ;955
000106  dd30              BLE      |L4.362|
000108  f9b37009          LDRSH    r7,[r3,#9]            ;988
00010c  42b8              CMP      r0,r7                 ;988
00010e  dd09              BLE      |L4.292|
000110  6967              LDR      r7,[r4,#0x14]         ;999
000112  1c7f              ADDS     r7,r7,#1              ;999
000114  6167              STR      r7,[r4,#0x14]         ;999
000116  f9b3e009          LDRSH    lr,[r3,#9]            ;1000
00011a  69a7              LDR      r7,[r4,#0x18]         ;1000
00011c  eba00e0e          SUB      lr,r0,lr              ;1000
000120  4477              ADD      r7,r7,lr              ;1000
000122  61a7              STR      r7,[r4,#0x18]         ;1000
                  |L4.292|
000124  42b0              CMP      r0,r6                 ;1005
000126  dd1a              BLE      |L4.350|
000128  f9947002          LDRSB    r7,[r4,#2]            ;1008
00012c  428f              CMP      r7,r1                 ;1008
00012e  bfc8              IT       GT                    ;1008
000130  460f              MOVGT    r7,r1                 ;1008
000132  70a7              STRB     r7,[r4,#2]            ;1008
000134  f9947003          LDRSB    r7,[r4,#3]            ;1010
000138  428f              CMP      r7,r1                 ;1010
00013a  bfd8              IT       LE                    ;1010
00013c  460f              MOVLE    r7,r1                 ;1010
00013e  70e7              STRB     r7,[r4,#3]            ;1010
000140  f9947000          LDRSB    r7,[r4,#0]            ;1012
000144  4297              CMP      r7,r2                 ;1012
000146  bfc8              IT       GT                    ;1012
000148  4617              MOVGT    r7,r2                 ;1012
00014a  7027              STRB     r7,[r4,#0]            ;1012
00014c  f9947001          LDRSB    r7,[r4,#1]            ;1014
000150  4297              CMP      r7,r2                 ;1014
000152  bfd8              IT       LE                    ;1014
000154  4617              MOVLE    r7,r2                 ;1014
000156  7067              STRB     r7,[r4,#1]            ;1014
000158  6867              LDR      r7,[r4,#4]            ;1016
00015a  1c7f              ADDS     r7,r7,#1              ;1016
00015c  6067              STR      r7,[r4,#4]            ;1016
                  |L4.350|
00015e  68a7              LDR      r7,[r4,#8]            ;1021
000160  4287              CMP      r7,r0                 ;1021
000162  bfc8              IT       GT                    ;1021
000164  4638              MOVGT    r0,r7                 ;1021
000166  60a0              STR      r0,[r4,#8]            ;1021
000168  e016              B        |L4.408|
                  |L4.362|
00016a  f9b3700b          LDRSH    r7,[r3,#0xb]          ;1026
00016e  42b8              CMP      r0,r7                 ;1026
000170  da09              BGE      |L4.390|
000172  69e7              LDR      r7,[r4,#0x1c]         ;1038
000174  1c7f              ADDS     r7,r7,#1              ;1038
000176  61e7              STR      r7,[r4,#0x1c]         ;1038
000178  f9b3e00b          LDRSH    lr,[r3,#0xb]          ;1039
00017c  6a27              LDR      r7,[r4,#0x20]         ;1039
00017e  eba00e0e          SUB      lr,r0,lr              ;1039
000182  4477              ADD      r7,r7,lr              ;1039
000184  6227              STR      r7,[r4,#0x20]         ;1039
                  |L4.390|
000186  6a67              LDR      r7,[r4,#0x24]         ;1044
000188  4287              CMP      r7,r0                 ;1044
00018a  dd05              BLE      |L4.408|
00018c  6260              STR      r0,[r4,#0x24]         ;1046
00018e  9803              LDR      r0,[sp,#0xc]
000190  f884002b          STRB     r0,[r4,#0x2b]
;;;1048   						temp_delta->tMinCellPos.c = c;
000194  f884102a          STRB     r1,[r4,#0x2a]
                  |L4.408|
000198  1c49              ADDS     r1,r1,#1
00019a  2950              CMP      r1,#0x50
00019c  f6ffaf7e          BLT      |L4.156|
0001a0  1c52              ADDS     r2,r2,#1
0001a2  2a2d              CMP      r2,#0x2d
0001a4  f6ffaf66          BLT      |L4.116|
0001a8  4815              LDR      r0,|L4.512|
0001aa  9901              LDR      r1,[sp,#4]
0001ac  e9c08105          STRD     r8,r1,[r0,#0x14]
;;;1049   	//					pen_touch_data = -delta;
;;;1050   //						pen_pos.r = r;
;;;1051   //						pen_pos.c = c;
;;;1052   					}
;;;1053   				}
;;;1054   			}
;;;1055   #if LGD_ERROR_FRAME_PROCESS_EN
;;;1056   			//LGD Kiosk error data rejection
;;;1057   			if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;1058   			{
;;;1059   				if(COL_MAX>1)
;;;1060   				{
;;;1061   					EvenDelta /= ( (COL_MAX+1)>>1);
;;;1062   					OddDelta /= (COL_MAX>>1);
;;;1063   					if(abs(EvenDelta - OddDelta) > 5)
;;;1064   					{
;;;1065   						for( c=0; c<COL_MAX; c++ ){
;;;1066   							delta = HAL_READ_DELTA_IMAGE(r,c);
;;;1067   							if(c%2 == 0)
;;;1068   								delta = (delta - EvenDelta < 0) ? 0 : delta - EvenDelta;
;;;1069   							else
;;;1070   								delta = (delta - OddDelta < 0) ? 0 : delta - OddDelta;
;;;1071   							HAL_WRITE_DELTA_IMAGE(r,c,delta);
;;;1072   						}
;;;1073   						
;;;1074   					}
;;;1075   				}
;;;1076   			}
;;;1077   #endif
;;;1078   			
;;;1079   		}
;;;1080   		
;;;1081   		thisInfo->bTouchExpect = (temp_delta->iGroupedCellCnt > 0);
0001b0  6860              LDR      r0,[r4,#4]
0001b2  2800              CMP      r0,#0
0001b4  bf18              IT       NE
0001b6  2001              MOVNE    r0,#1
0001b8  9900              LDR      r1,[sp,#0]
0001ba  f8810fb5          STRB     r0,[r1,#0xfb5]
0001be  2101              MOVS     r1,#1                 ;846
0001c0  b140              CBZ      r0,|L4.468|
0001c2  9800              LDR      r0,[sp,#0]            ;1048
0001c4  f5005080          ADD      r0,r0,#0x1000         ;1048
;;;1082   	}
;;;1083   #if (USED_DSPA_FUNC_FOR_FINGER && USED_DSPA_FUNC_FOR_FINGER_CAL_DELTA)
;;;1084   	else
;;;1085   	{
;;;1086   		algorithm_baseline_calculate_delta_dspA(mode);
;;;1087   	#if LOCAL_REBASE_ALGO_EN
;;;1088   		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;1089   		if(bNonSumFlag)
;;;1090   		{
;;;1091   			for(r = FingerNonSumOnPenArea.rs; r <= FingerNonSumOnPenArea.re; r++)for(c = FingerNonSumOnPenArea.cs; c <= FingerNonSumOnPenArea.ce; c++)
;;;1092   			{
;;;1093   				delta = HAL_READ_DELTA_IMAGE(r,c);
;;;1094   				if(delta > thisModeConf->BaseLine.sAccumPosSumThd)
;;;1095   				{
;;;1096   					temp_delta->iPosCnt--;
;;;1097   					temp_delta->iPosSum -= (delta - thisModeConf->BaseLine.sAccumPosSumThd);				
;;;1098   				}
;;;1099   				else if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;1100   				{						
;;;1101   					temp_delta->iNegCnt--;
;;;1102   					temp_delta->iNegSum -= (delta - thisModeConf->BaseLine.sAccumNegSumThd);
;;;1103   				}
;;;1104   			}
;;;1105   		}
;;;1106   		#endif
;;;1107   	#endif
;;;1108   	}
;;;1109   #endif	
;;;1110   
;;;1111   	if(thisInfo->bTouchExpect && !thisInfo->bLineFilterRepeatCheck)thisInfo->bLineFilterRepeatCheck = 1;
0001c8  f8902179          LDRB     r2,[r0,#0x179]
0001cc  2a00              CMP      r2,#0
0001ce  bf08              IT       EQ
0001d0  f8801179          STRBEQ   r1,[r0,#0x179]
                  |L4.468|
;;;1112   
;;;1113   #if CPI_TEST_EN
;;;1114   	//LGD Phone noise
;;;1115   	if(thisModeConf->Noise.ucCPITestOn)
;;;1116   	{
;;;1117   		if(!thisInfo->WinCertMode && thisInfo->tCoord.cScreenDebCnt[0]<COORD_HISTORY_NUM){
;;;1118   			for(idx=0;idx<COL_MAX/5;idx++){
;;;1119   				if(RawPartSumCnt[idx] != 0)
;;;1120   					RawPartSum[idx] /= RawPartSumCnt[idx];
;;;1121   				if(idx>0){
;;;1122   					if(abs(RawPartSum[idx] - RawPartSum[idx-1])>1000)
;;;1123   						AbnormalRawCnt = RawPartSumCnt[idx];
;;;1124   				}
;;;1125   				
;;;1126   				if(AbnormalDeltaCntInMux[idx] > 50 || DeltaEdgeCntInMux > (ROW_MAX>>1) )
;;;1127   					thisInfo->UnstableStateFrm = 400;
;;;1128   		//		if(AbnormalDeltaCntInMux[idx] >= 200)
;;;1129   		//			thisInfo->UnstableStateFrm = 400;
;;;1130   			}
;;;1131   			
;;;1132   			if(thisInfo->UnstableStateFrm && wdt_init)
;;;1133   			{
;;;1134   				KICK_DOG();
;;;1135   				Hal_WDT_DeInit();
;;;1136   			}
;;;1137   			
;;;1138   			if(AbnormalRawCnt >= 5){
;;;1139   				memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;1140   				GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;1141   				thisInfo->UnstableStateFrm = 0;
;;;1142   			}
;;;1143   			
;;;1144   			{
;;;1145   				static uint16_t AbnormalFrmCnt = 0;
;;;1146   				static uint8_t ResetDelayCount = 0;
;;;1147   
;;;1148   				if(thisInfo->UnstableStateFrm){
;;;1149   					memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;1150   					if(ResetDelayCount++ > 10){
;;;1151   						GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;1152   					}	
;;;1153   				}
;;;1154   				if(GoToThisState == TOUCH_NORMAL_OPER_RESET_HAL)
;;;1155   				{
;;;1156   					thisInfo->UnstableStateFrm = 0;
;;;1157   					AbnormalFrmCnt = 0;
;;;1158   					ResetDelayCount = 0;
;;;1159   				}
;;;1160   			}
;;;1161   		}
;;;1162   	}
;;;1163   #endif
;;;1164   	
;;;1165   	if(  temp_delta->iMaxStrength > thisModeConf->BaseLine.sBlockPosThd )
0001d4  68a2              LDR      r2,[r4,#8]
0001d6  9802              LDR      r0,[sp,#8]
0001d8  f9b00005          LDRSH    r0,[r0,#5]
0001dc  4282              CMP      r2,r0
;;;1166   	{
;;;1167   		thisInfo->bBlockTracking = YES;
0001de  bfc4              ITT      GT
0001e0  9800              LDRGT    r0,[sp,#0]
0001e2  7001              STRBGT   r1,[r0,#0]
;;;1168   	}
;;;1169   	
;;;1170   	if( temp_delta->iMinStrength < thisModeConf->BaseLine.sBlockNegThd )
0001e4  6a62              LDR      r2,[r4,#0x24]
0001e6  9802              LDR      r0,[sp,#8]
0001e8  f9b00007          LDRSH    r0,[r0,#7]
0001ec  4282              CMP      r2,r0
;;;1171   	{
;;;1172   		thisInfo->bBlockTracking = YES;
0001ee  bfbc              ITT      LT
0001f0  9800              LDRLT    r0,[sp,#0]
0001f2  7001              STRBLT   r1,[r0,#0]
;;;1173   	}
;;;1174   	
;;;1175   #if USED_PEN_MODE_OPERATION
;;;1176   	if(mode == FULL_MODE)
;;;1177   	{
;;;1178   		if(thisInfo->sLFingerMinVal < -30 && 
;;;1179   			((thisInfo->tLFingerMinCell.r-1 <= temp_delta->tMinCellPos.r && temp_delta->tMinCellPos.r <= thisInfo->tLFingerMinCell.r+1) && 
;;;1180   			(thisInfo->tLFingerMinCell.c-1 <= temp_delta->tMinCellPos.c && temp_delta->tMinCellPos.c <= thisInfo->tLFingerMinCell.c+1)))
;;;1181   			temp_delta->iMinStrength = /*pen_touch_data =*/ 0;
;;;1182   		
;;;1183   	//	if(pen_touch_data > 30 || pen_touch_data2 < -70)
;;;1184   	//	{
;;;1185   	//		thisInfo->bLocal_sensing = YES;
;;;1186   	////		hal_Info_SetPenDectionEnable(YES);
;;;1187   	//		algorithm_baseline_calculate_mux_range(pen_pos.r+local_rs, pen_pos.c);
;;;1188   	//	}
;;;1189   	}
;;;1190   	else
;;;1191   	{
;;;1192   		thisInfo->sLFingerMinVal = temp_delta->iMinStrength;
;;;1193   		thisInfo->tLFingerMinCell = temp_delta->tMinCellPos;		
;;;1194   	}
;;;1195   #endif /* USED_PEN_MODE_OPERATION */
;;;1196   
;;;1197   	return thisInfo->bBlockTracking;
0001f4  9800              LDR      r0,[sp,#0]
0001f6  7800              LDRB     r0,[r0,#0]
;;;1198   }
0001f8  b005              ADD      sp,sp,#0x14
0001fa  e8bd8ff0          POP      {r4-r11,pc}
;;;1199   
                          ENDP

0001fe  0000              DCW      0x0000
                  |L4.512|
                          DCD      ||.data||
                  |L4.516|
                          DCD      FullSharedBuff+0x5460
                  |L4.520|
                          DCD      FullSharedBuff
                  |L4.524|
                          DCD      0xb60b60b7

                          AREA ||i.algorithm_baseline_calculate_delta_S3||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta_S3 PROC
;;;1957   
;;;1958   void algorithm_baseline_calculate_delta_S3(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1959   {
;;;1960   	uint32_t r, c;
;;;1961   	int16_t delta;
;;;1962   	uint16_t read_raw_data;
;;;1963   	uint16_t * pS3BaseImage;
;;;1964   	tS3DeltaInfo_t * ptTempS3DeltaInfo;
;;;1965   
;;;1966   	thisInfo->bBlockTracking = NO;
000004  4f4b              LDR      r7,|L5.308|
000006  2000              MOVS     r0,#0
000008  68f9              LDR      r1,[r7,#0xc]  ; thisInfo
;;;1967   	thisInfo->bTouchExpect = NO;
;;;1968   
;;;1969   	ptTempS3DeltaInfo = &thisInfo->tS3DeltaInfo;
00000a  f5016472          ADD      r4,r1,#0xf20
00000e  7008              STRB     r0,[r1,#0]            ;1966
000010  f8810fb5          STRB     r0,[r1,#0xfb5]        ;1967
;;;1970   
;;;1971   	ptTempS3DeltaInfo->sMaxStrength = -4096;
000014  f44f4070          MOV      r0,#0xf000
000018  f8a10f28          STRH     r0,[r1,#0xf28]
;;;1972   	ptTempS3DeltaInfo->sMinStrength = 4096;
00001c  f44f5080          MOV      r0,#0x1000
000020  f8a10f2a          STRH     r0,[r1,#0xf2a]
;;;1973   
;;;1974   	pS3BaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
000024  f7fffffe          BL       HAL_GetSensingMode
000028  2101              MOVS     r1,#1
00002a  f7fffffe          BL       HAL_GetBaseImagePointer
;;;1975   	for(r=0; r<NI_ROW_MAX; r++)
;;;1976   	{
;;;1977   		for(c=0; c<COL_MAX; c++)
00002e  f8dfb108          LDR      r11,|L5.312|
000032  f8d7a004          LDR      r10,[r7,#4]  ; ptModuleModeConf
000036  f04f0900          MOV      r9,#0                 ;1975
00003a  f24f6e02          MOV      lr,#0xf602
                  |L5.62|
00003e  eb090289          ADD      r2,r9,r9,LSL #2
000042  eb0b1342          ADD      r3,r11,r2,LSL #5
000046  4601              MOV      r1,r0
000048  eb03050e          ADD      r5,r3,lr
00004c  f04f0c00          MOV      r12,#0
000050  f05f0650          MOVS.W   r6,#0x50
                  |L5.84|
;;;1978   		{
;;;1979   			read_raw_data = HAL_NI_READ_RAW_IMAGE(r, c);
;;;1980   			delta = (int16_t)read_raw_data - (int16_t)(*(pS3BaseImage++));
000054  f8332b02          LDRH     r2,[r3],#2
000058  f8318b02          LDRH     r8,[r1],#2
00005c  eba20208          SUB      r2,r2,r8
;;;1981   			delta >>= ptModuleModeConf->ucIdleOvrShift;
000060  f89a8001          LDRB     r8,[r10,#1]
000064  b212              SXTH     r2,r2                 ;1980
000066  fa42f208          ASR      r2,r2,r8
;;;1982   
;;;1983   			HAL_NI_WRITE_DELTA_IMAGE(r, c, delta);
00006a  f8252b02          STRH     r2,[r5],#2
;;;1984   
;;;1985   			if(ptTempS3DeltaInfo->sMaxStrength < delta)
00006e  f9b48008          LDRSH    r8,[r4,#8]
000072  4590              CMP      r8,r2
;;;1986   			{
;;;1987   				ptTempS3DeltaInfo->sMaxStrength = delta;
000074  bfbc              ITT      LT
000076  8122              STRHLT   r2,[r4,#8]
;;;1988   				ptTempS3DeltaInfo->ulMaxNodeColIndex = c;
000078  f8c4c000          STRLT    r12,[r4,#0]
;;;1989   			}
;;;1990   
;;;1991   			if(ptTempS3DeltaInfo->sMinStrength > delta)
00007c  f9b4800a          LDRSH    r8,[r4,#0xa]
000080  4590              CMP      r8,r2
;;;1992   			{
;;;1993   				ptTempS3DeltaInfo->sMinStrength = delta;
000082  bfc4              ITT      GT
000084  8162              STRHGT   r2,[r4,#0xa]
;;;1994   				ptTempS3DeltaInfo->ulMinNodeColIndex = c;
000086  f8c4c004          STRGT    r12,[r4,#4]
00008a  1e76              SUBS     r6,r6,#1
00008c  f10c0c01          ADD      r12,r12,#1
000090  d1e0              BNE      |L5.84|
000092  30a0              ADDS     r0,r0,#0xa0           ;1985
000094  f1090901          ADD      r9,r9,#1              ;1985
;;;1995   			}
;;;1996   		}
000098  f1b90f0a          CMP      r9,#0xa
00009c  d3cf              BCC      |L5.62|
;;;1997   	}
;;;1998   
;;;1999   	if(ptTempS3DeltaInfo->sMaxStrength > thisModeConf->BaseLine.sS3_BlockPosThd ||
00009e  68be              LDR      r6,[r7,#8]  ; thisModeConf
0000a0  f9b43008          LDRSH    r3,[r4,#8]
0000a4  f9b6001d          LDRSH    r0,[r6,#0x1d]
0000a8  4283              CMP      r3,r0
0000aa  dc07              BGT      |L5.188|
0000ac  f9b4000a          LDRSH    r0,[r4,#0xa]
0000b0  f9b6101f          LDRSH    r1,[r6,#0x1f]
0000b4  4281              CMP      r1,r0
;;;2000   		ptTempS3DeltaInfo->sMinStrength < thisModeConf->BaseLine.sS3_BlockNegThd)
;;;2001   	{
;;;2002   		uint32_t ulCheckNodeColIdx;
;;;2003   		if(ABS(ptTempS3DeltaInfo->sMaxStrength) > ABS(ptTempS3DeltaInfo->sMinStrength))
;;;2004   		{
;;;2005   			ulCheckNodeColIdx = ptTempS3DeltaInfo->ulMaxNodeColIndex;
;;;2006   		}
;;;2007   		else
;;;2008   		{
;;;2009   			ulCheckNodeColIdx = ptTempS3DeltaInfo->ulMinNodeColIndex;
;;;2010   		}
;;;2011   		ptTempS3DeltaInfo->sColumStrengthTotalSum = 0;
;;;2012   		for(r=0; r<NI_ROW_MAX; r++)
;;;2013   		{
;;;2014   			ptTempS3DeltaInfo->sColumStrengthTotalSum += HAL_NI_READ_DELTA_IMAGE(r, ulCheckNodeColIdx);
;;;2015   		}
;;;2016   
;;;2017   		if(ptTempS3DeltaInfo->sColumStrengthTotalSum > thisModeConf->BaseLine.sS3_PosTotalSumThd ||
;;;2018   			ptTempS3DeltaInfo->sColumStrengthTotalSum < thisModeConf->BaseLine.sS3_NegTotalSumThd)
;;;2019   		{
;;;2020   			ptTempS3DeltaInfo->sPrevMaxStrength = ptTempS3DeltaInfo->sMaxStrength;
;;;2021   			ptTempS3DeltaInfo->sPrevMinStrength = ptTempS3DeltaInfo->sMinStrength;
;;;2022   
;;;2023   //			if((ptTempS3DeltaInfo->sPrevMaxStrength > 500 || ptTempS3DeltaInfo->sColumStrengthTotalSum < -500) &&
;;;2024   //				(ptTempS3DeltaInfo->sColumStrengthTotalSum > 2500 || ptTempS3DeltaInfo->sColumStrengthTotalSum < -2500))
;;;2025   //			{
;;;2026   //
;;;2027   //			}
;;;2028   //			else
;;;2029   			{
;;;2030   #if (!USED_ONLY_S3_MODE)
;;;2031   				thisInfo->bTouchExpect = YES;
;;;2032   #endif /* (!USED_ONLY_S3_MODE) */
;;;2033   			}
;;;2034   		}
;;;2035   
;;;2036   		thisInfo->bBlockTracking = YES;
;;;2037   	}
;;;2038   
;;;2039   #if USED_ONLY_IDLE_MODE
;;;2040   	thisInfo->bTouchExpect = NO;
;;;2041   	thisInfo->bBlockTracking = NO;
;;;2042   #endif /* USED_ONLY_IDLE_MODE */
;;;2043   }
0000b6  bfd8              IT       LE
0000b8  e8bd9ff0          POPLE    {r4-r12,pc}
                  |L5.188|
0000bc  2b00              CMP      r3,#0                 ;2003
0000be  bfac              ITE      GE                    ;2003
0000c0  4618              MOVGE    r0,r3                 ;2003
0000c2  4258              RSBLT    r0,r3,#0              ;2003
0000c4  f9b4c00a          LDRSH    r12,[r4,#0xa]         ;2003
0000c8  f1bc0f00          CMP      r12,#0                ;2003
0000cc  bfac              ITE      GE                    ;2003
0000ce  4661              MOVGE    r1,r12                ;2003
0000d0  f1cc0100          RSBLT    r1,r12,#0             ;2003
0000d4  4288              CMP      r0,r1                 ;2003
0000d6  bfcc              ITE      GT                    ;2005
0000d8  6820              LDRGT    r0,[r4,#0]            ;2005
0000da  6860              LDRLE    r0,[r4,#4]            ;2009
0000dc  2100              MOVS     r1,#0                 ;2011
0000de  8221              STRH     r1,[r4,#0x10]         ;2011
0000e0  eb0b0040          ADD      r0,r11,r0,LSL #1      ;2012
0000e4  f24f5162          MOV      r1,#0xf562            ;2012
0000e8  4408              ADD      r0,r0,r1              ;2012
0000ea  2100              MOVS     r1,#0
0000ec  2205              MOVS     r2,#5                 ;2012
                  |L5.238|
0000ee  8a25              LDRH     r5,[r4,#0x10]         ;2014
0000f0  f8308fa0          LDRH     r8,[r0,#0xa0]!        ;2014
0000f4  1e52              SUBS     r2,r2,#1              ;2014
0000f6  4445              ADD      r5,r5,r8              ;2014
0000f8  8225              STRH     r5,[r4,#0x10]         ;2014
0000fa  f8305fa0          LDRH     r5,[r0,#0xa0]!        ;2014
0000fe  4429              ADD      r1,r1,r5              ;2014
000100  b209              SXTH     r1,r1                 ;2014
000102  d1f4              BNE      |L5.238|
000104  8a20              LDRH     r0,[r4,#0x10]
000106  4408              ADD      r0,r0,r1
000108  b200              SXTH     r0,r0
00010a  8220              STRH     r0,[r4,#0x10]
00010c  f9b62021          LDRSH    r2,[r6,#0x21]         ;2017
000110  2101              MOVS     r1,#1                 ;1974
000112  4290              CMP      r0,r2                 ;2017
000114  dc03              BGT      |L5.286|
000116  f9b62023          LDRSH    r2,[r6,#0x23]         ;2017
00011a  4290              CMP      r0,r2                 ;2017
00011c  da05              BGE      |L5.298|
                  |L5.286|
00011e  81a3              STRH     r3,[r4,#0xc]          ;2020
000120  f8a4c00e          STRH     r12,[r4,#0xe]         ;2021
000124  68f8              LDR      r0,[r7,#0xc]          ;2031  ; thisInfo
000126  f8801fb5          STRB     r1,[r0,#0xfb5]        ;2031
                  |L5.298|
00012a  68f8              LDR      r0,[r7,#0xc]          ;2036  ; thisInfo
00012c  7001              STRB     r1,[r0,#0]            ;2036
00012e  e8bd9ff0          POP      {r4-r12,pc}
;;;2044   #endif /* USED_MNT_S3_MODE_FUNCTION */
                          ENDP

000132  0000              DCW      0x0000
                  |L5.308|
                          DCD      ||.data||
                  |L5.312|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_calculate_mux_range||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_mux_range PROC
;;;740    
;;;741    void algorithm_baseline_calculate_mux_range(int r, int c)
000000  4a11              LDR      r2,|L6.72|
;;;742    {
;;;743    #if 1
;;;744    #define COL_CAL_SIZE						(8)
;;;745    #define COL_CAL_HALF						(COL_CAL_SIZE>>1)
;;;746    #define PEN_LOCAL_ROW_HALF_IDX				(PEN_COORD_ROW_MAX>>1)
;;;747    //	int sub_r = r;
;;;748    
;;;749    	if(r <= PEN_LOCAL_ROW_HALF_IDX)
;;;750    	{
;;;751    		sensingRowStart = 0;
000002  2300              MOVS     r3,#0
000004  2802              CMP      r0,#2                 ;749
000006  bfd8              IT       LE
000008  8013              STRHLE   r3,[r2,#0]
00000a  dd04              BLE      |L6.22|
;;;752    	}
;;;753    	else if(r >= (ROW_MAX-1) - PEN_LOCAL_ROW_HALF_IDX)
00000c  282a              CMP      r0,#0x2a
;;;754    	{
;;;755    		sensingRowStart = ROW_MAX - PEN_COORD_ROW_MAX;
00000e  bfac              ITE      GE
000010  2028              MOVGE    r0,#0x28
000012  1e80              SUBLT    r0,r0,#2
000014  8010              STRH     r0,[r2,#0]
                  |L6.22|
;;;756    	}
;;;757    	else
;;;758    	{
;;;759    		sensingRowStart = r - PEN_LOCAL_ROW_HALF_IDX;
;;;760    	}
;;;761    
;;;762    //	currentRowStart = sensingRowStart;
;;;763    	if(c<COL_CAL_HALF)
;;;764    	{
;;;765    		thisInfo->tPenInfo.ucCurrentColumnStart = 0;
000016  480d              LDR      r0,|L6.76|
000018  2904              CMP      r1,#4                 ;763
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  bfbc              ITT      LT
00001e  f8803fbb          STRBLT   r3,[r0,#0xfbb]
;;;766    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_CAL_SIZE;
000022  2108              MOVLT    r1,#8
000024  db06              BLT      |L6.52|
;;;767    	}
;;;768    	else if(c+COL_CAL_HALF >= COL_MAX)
000026  1d0a              ADDS     r2,r1,#4
000028  2a50              CMP      r2,#0x50
00002a  db06              BLT      |L6.58|
;;;769    	{
;;;770    		thisInfo->tPenInfo.ucCurrentColumnStart = COL_MAX - COL_CAL_SIZE - 1;
00002c  2147              MOVS     r1,#0x47
00002e  f8801fbb          STRB     r1,[r0,#0xfbb]
;;;771    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_MAX - 1;
000032  214f              MOVS     r1,#0x4f
                  |L6.52|
000034  f8801fbc          STRB     r1,[r0,#0xfbc]        ;766
;;;772    	}
;;;773    	else
;;;774    	{
;;;775    		thisInfo->tPenInfo.ucCurrentColumnStart = c-COL_CAL_HALF;
;;;776    		thisInfo->tPenInfo.ucCurrentColumnEnd = c+COL_CAL_HALF;
;;;777    	}
;;;778    #else
;;;779    	int sub_r = r;
;;;780    	
;;;781    	if(currentRowStart == sensingRowStart)
;;;782    	{
;;;783    		sub_r = sub_r-MAX_MUX_HALF;
;;;784    		
;;;785    		if(sub_r < 0)
;;;786    			sensingRowStart = 0;
;;;787    		else if(sub_r >= MUX_MAX_ROW)
;;;788    			sensingRowStart = MUX_MAX_ROW;
;;;789    		else
;;;790    			sensingRowStart = sub_r;
;;;791    	}
;;;792    
;;;793    	if(c<MAX_MUX_HALF)
;;;794    	{
;;;795    		thisInfo->tPenInfo.ucCurrentColumnStart = 0;
;;;796    		thisInfo->tPenInfo.ucCurrentColumnEnd = MAX_MUX_SIZE;
;;;797    	}
;;;798    	else if(c+MAX_MUX_HALF > COL_MAX)
;;;799    	{
;;;800    		thisInfo->tPenInfo.ucCurrentColumnStart = COL_MAX - MAX_MUX_SIZE;
;;;801    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_MAX;
;;;802    	}
;;;803    	else
;;;804    	{
;;;805    		thisInfo->tPenInfo.ucCurrentColumnStart = c-MAX_MUX_HALF;
;;;806    		thisInfo->tPenInfo.ucCurrentColumnEnd = c+MAX_MUX_HALF;
;;;807    	}
;;;808    #endif
;;;809    }
000038  4770              BX       lr
                  |L6.58|
00003a  1f09              SUBS     r1,r1,#4
00003c  f8801fbb          STRB     r1,[r0,#0xfbb]        ;775
000040  f8802fbc          STRB     r2,[r0,#0xfbc]        ;776
000044  4770              BX       lr
;;;810    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      sensingRowStart
                  |L6.76|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_init||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init PROC
;;;54     
;;;55     void algorithm_baseline_init(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c0a              LDR      r4,|L7.48|
000008  60a0              STR      r0,[r4,#8]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
;;;56     {
;;;57     	algorithm_baseline_init_param();
;;;58     	thisInfo = algorithm_GetInfo();
00000e  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
000010  f7fffffe          BL       algorithm_GetInfo
;;;59     #if USED_NOISE_HOPPING_FREQ
;;;60     	ptAppInfo = app_GetInfo();
000014  60e0              STR      r0,[r4,#0xc]  ; thisInfo
000016  f7fffffe          BL       app_GetInfo
00001a  6120              STR      r0,[r4,#0x10]  ; ptAppInfo
00001c  4805              LDR      r0,|L7.52|
;;;61     #endif
;;;62     	algorithm_baseline_init_FingerPoint();	
;;;63     	memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
00001e  61e0              STR      r0,[r4,#0x1c]  ; g_pFingerBaseImage
000020  e8bd4010          POP      {r4,lr}
000024  f641611c          MOV      r1,#0x1e1c
000028  4803              LDR      r0,|L7.56|
00002a  f7ffbffe          B.W      __aeabi_memclr4
;;;64     }
;;;65     
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      ||.data||
                  |L7.52|
                          DCD      FullSharedBuff+0x3840
                  |L7.56|
                          DCD      FullSharedBuff+0xc8d8

                          AREA ||i.algorithm_baseline_init_FingerPoint||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_FingerPoint PROC
;;;71     
;;;72     void algorithm_baseline_init_FingerPoint(void)
000000  4902              LDR      r1,|L8.12|
;;;73     {
;;;74     #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN)
;;;75     	g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
000002  4801              LDR      r0,|L8.8|
000004  61c8              STR      r0,[r1,#0x1c]  ; g_pFingerBaseImage
;;;76     #elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN || PEN_PROTOCOL_WGP_UHD_PEN)
;;;77     	g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;78     #else	
;;;79     	if(hal_Info_GetControlActivePenRawDataType() == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;80     	{
;;;81     		g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
;;;82     	}
;;;83     	else
;;;84     	{
;;;85     		g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;86     	}
;;;87     #endif
;;;88     }
000006  4770              BX       lr
;;;89     
                          ENDP

                  |L8.8|
                          DCD      FullSharedBuff+0x3840
                  |L8.12|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_init_param||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_param PROC
;;;65     
;;;66     void algorithm_baseline_init_param(void)
000000  b510              PUSH     {r4,lr}
;;;67     {
;;;68     	thisModeConf  = algorithm_GetModeConfig();
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c03              LDR      r4,|L9.20|
;;;69     	ptModuleModeConf = module_GetModeConfig();
000008  60a0              STR      r0,[r4,#8]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
00000e  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
;;;70     }
000010  bd10              POP      {r4,pc}
;;;71     
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_tracking_continuous||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous PROC
;;;602    extern int16_t sLFOffsetCol[COL_MAX];
;;;603    void algorithm_baseline_tracking_continuous(uint8_t mode)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;604    {
000004  4680              MOV      r8,r0
;;;605    	uint32_t ulIdx;
;;;606    	uint32_t ulFullIdxNum;
;;;607    	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;608    	static bool_t traking_en = 0;
;;;609    	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
000006  f7fffffe          BL       hal_Info_GetControlLocalFingerOPType
00000a  4606              MOV      r6,r0
;;;610    	uint16_t * pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;611    #if USED_NOISE_HOPPING_FREQ
;;;612    	uint16_t * pBaseImage;
;;;613    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
00000c  4835              LDR      r0,|L10.228|
00000e  4d34              LDR      r5,|L10.224|
000010  6901              LDR      r1,[r0,#0x10]  ; ptAppInfo
000012  7c89              LDRB     r1,[r1,#0x12]
000014  2901              CMP      r1,#1
;;;614    	{
;;;615    		pBaseImage = g_pFingerBaseImage;
000016  bf08              IT       EQ
000018  69c4              LDREQ    r4,[r0,#0x1c]  ; g_pFingerBaseImage
00001a  d000              BEQ      |L10.30|
;;;616    	}
;;;617    	else
;;;618    	{
;;;619    		pBaseImage = (uint16_t *)HAL_GET_HOPP1_BASELINE_IMAGE_PTR() ;
00001c  4c32              LDR      r4,|L10.232|
                  |L10.30|
;;;620    	}
;;;621    //	uint16_t * pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;622    #else /* USED_NOISE_HOPPING_FREQ */
;;;623    	uint16_t * pBaseImage = g_pFingerBaseImage;
;;;624    #endif /* USED_NOISE_HOPPING_FREQ */
;;;625    	
;;;626        if(thisInfo->bIsPalm == 0 && thisInfo->bBlockTracking == NO)
00001e  4831              LDR      r0,|L10.228|
000020  68c0              LDR      r0,[r0,#0xc]  ; thisInfo
000022  f8901fb2          LDRB     r1,[r0,#0xfb2]
000026  2900              CMP      r1,#0
000028  d14f              BNE      |L10.202|
00002a  7801              LDRB     r1,[r0,#0]
00002c  4f2d              LDR      r7,|L10.228|
00002e  2900              CMP      r1,#0
000030  d14b              BNE      |L10.202|
;;;627    	{
;;;628    		if( (mode == FULL_MODE && thisInfo->bLocal_sensing == NO) || 
000032  f1b80f00          CMP      r8,#0
000036  d003              BEQ      |L10.64|
000038  f1b80f02          CMP      r8,#2
00003c  d005              BEQ      |L10.74|
00003e  e044              B        |L10.202|
                  |L10.64|
000040  f8900fb8          LDRB     r0,[r0,#0xfb8]
000044  2800              CMP      r0,#0
000046  d140              BNE      |L10.202|
000048  e00a              B        |L10.96|
                  |L10.74|
00004a  f7fffffe          BL       hal_Info_GetPenDectionEnable
00004e  bbe0              CBNZ     r0,|L10.202|
000050  68f8              LDR      r0,[r7,#0xc]  ; thisInfo
000052  7840              LDRB     r0,[r0,#1]
000054  bbc8              CBNZ     r0,|L10.202|
000056  2e00              CMP      r6,#0
000058  bf04              ITT      EQ
00005a  7838              LDRBEQ   r0,[r7,#0]  ; traking_en
00005c  2800              CMPEQ    r0,#0
00005e  d034              BEQ      |L10.202|
                  |L10.96|
;;;629    		(mode == LOCAL_FINGER_MODE && hal_Info_GetPenDectionEnable() == NO && thisInfo->bBlockTrackingByLocalDelta == NO && 
;;;630    		(eLocalFingerOPType != ACTIVEPEN_TYPE_LOCAL_MS || (eLocalFingerOPType == ACTIVEPEN_TYPE_LOCAL_MS && traking_en))) )
;;;631    		{
;;;632    			alpha = thisModeConf->BaseLine.usIIRCoef;
000060  68b8              LDR      r0,[r7,#8]  ; thisModeConf
;;;633    
;;;634    			//pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;635    			//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;636    			ulFullIdxNum = ROW_MAX * COL_MAX;
;;;637    			for(ulIdx = 0; ulIdx < ulFullIdxNum; ulIdx++)
;;;638    			{
;;;639    				curr_rawdata = (*(pRawImage++));
;;;640    	#if USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS
;;;641    				if(curr_rawdata > 0)
;;;642    	#endif /* USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS */
;;;643    				{
;;;644    					curr_rawdata += (sLFOffsetRow[ulIdx / COL_MAX] + sLFOffsetCol[ulIdx % COL_MAX]);
000062  f8df8088          LDR      r8,|L10.236|
000066  f8df9088          LDR      r9,|L10.240|
00006a  f8b03003          LDRH     r3,[r0,#3]            ;632
00006e  f8dfa084          LDR      r10,|L10.244|
;;;645    					prev_baseline = *(pBaseImage);
;;;646    					curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;647    					*(pBaseImage++) = (uint16_t)curr_baseline;
000072  f8dfb084          LDR      r11,|L10.248|
000076  f04f0100          MOV      r1,#0                 ;637
00007a  f44f6261          MOV      r2,#0xe10             ;637
00007e  f1c30064          RSB      r0,r3,#0x64
000082  bf00              NOP                            ;644
                  |L10.132|
000084  fba87c01          UMULL    r7,r12,r8,r1          ;644
000088  ea4f1c9c          LSR      r12,r12,#6            ;644
00008c  1e52              SUBS     r2,r2,#1
00008e  f939701c          LDRSH    r7,[r9,r12,LSL #1]    ;644
000092  f1cc0c00          RSB      r12,r12,#0            ;644
000096  eb0c0c8c          ADD      r12,r12,r12,LSL #2    ;644
00009a  eb011c0c          ADD      r12,r1,r12,LSL #4     ;644
00009e  f1010101          ADD      r1,r1,#1
0000a2  f93ac01c          LDRSH    r12,[r10,r12,LSL #1]  ;644
0000a6  44bc              ADD      r12,r12,r7            ;644
0000a8  f8357b02          LDRH     r7,[r5],#2            ;644
0000ac  44bc              ADD      r12,r12,r7            ;644
0000ae  8827              LDRH     r7,[r4,#0]
0000b0  fb07f703          MUL      r7,r7,r3
0000b4  fb007c0c          MLA      r12,r0,r12,r7
0000b8  fb8b7c0c          SMULL    r7,r12,r11,r12
0000bc  ea4f176c          ASR      r7,r12,#5
0000c0  eba77cec          SUB      r12,r7,r12,ASR #31
0000c4  f824cb02          STRH     r12,[r4],#2
;;;648    				}
;;;649    			}
0000c8  d1dc              BNE      |L10.132|
                  |L10.202|
;;;650    		}
;;;651    	}
;;;652    	
;;;653    	if(traking_en==0 && eLocalFingerOPType == ACTIVEPEN_TYPE_LOCAL_MS)traking_en=1;
0000ca  4806              LDR      r0,|L10.228|
0000cc  7801              LDRB     r1,[r0,#0]  ; traking_en
0000ce  4331              ORRS     r1,r1,r6
0000d0  bf04              ITT      EQ
0000d2  2101              MOVEQ    r1,#1
0000d4  7001              STRBEQ   r1,[r0,#0]
;;;654    	
;;;655    	thisInfo->bBlockTrackingByLocalDelta = NO;  
0000d6  2100              MOVS     r1,#0
0000d8  68c0              LDR      r0,[r0,#0xc]  ; thisInfo
0000da  7041              STRB     r1,[r0,#1]
;;;656    }
0000dc  e8bd9ff0          POP      {r4-r12,pc}
;;;657    
                          ENDP

                  |L10.224|
                          DCD      FullSharedBuff
                  |L10.228|
                          DCD      ||.data||
                  |L10.232|
                          DCD      FullSharedBuff+0x5460
                  |L10.236|
                          DCD      0xcccccccd
                  |L10.240|
                          DCD      sLFOffsetRow
                  |L10.244|
                          DCD      sLFOffsetCol
                  |L10.248|
                          DCD      0x51eb851f

                          AREA ||i.algorithm_baseline_tracking_continuous_S3||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous_S3 PROC
;;;1932   
;;;1933   void algorithm_baseline_tracking_continuous_S3(void)
000000  481a              LDR      r0,|L11.108|
;;;1934   {
;;;1935   	uint32_t ulIdx;
;;;1936   	uint32_t ulS3IdxNum;
;;;1937   	uint16_t * pS3RawImage;
;;;1938   	uint16_t * pS3BaseImage;
;;;1939   	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;1940   
;;;1941       if(thisInfo->bBlockTracking == NO)
000002  68c1              LDR      r1,[r0,#0xc]  ; thisInfo
000004  7809              LDRB     r1,[r1,#0]
000006  2900              CMP      r1,#0
;;;1942       {
;;;1943       	ulS3IdxNum = COL_MAX * NI_ROW_MAX;
;;;1944   		alpha = thisModeConf->BaseLine.usIIRCoef;
;;;1945   
;;;1946   		pS3RawImage = HAL_NI_GET_RAW_IMAGE_PTR();
;;;1947   		pS3BaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
;;;1948   		for(ulIdx = 0; ulIdx < ulS3IdxNum; ulIdx++)
;;;1949   		{
;;;1950   			curr_rawdata = (*(pS3RawImage++)) + sLFOffsetRow[ulIdx / COL_MAX];
;;;1951   			prev_baseline = (*pS3BaseImage);
;;;1952   			curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;1953   			*(pS3BaseImage++) = (uint16_t)curr_baseline;
;;;1954   		}
;;;1955       }
;;;1956   }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  e92d47f0          PUSH     {r4-r10,lr}           ;1934
000010  6880              LDR      r0,[r0,#8]            ;1944  ; thisModeConf
000012  4c17              LDR      r4,|L11.112|
000014  f8b05003          LDRH     r5,[r0,#3]            ;1944
000018  f7fffffe          BL       HAL_GetSensingMode
00001c  2101              MOVS     r1,#1                 ;1947
00001e  f7fffffe          BL       HAL_GetBaseImagePointer
000022  4e14              LDR      r6,|L11.116|
000024  4f14              LDR      r7,|L11.120|
000026  f8df8054          LDR      r8,|L11.124|
00002a  2100              MOVS     r1,#0                 ;1948
00002c  f44f7248          MOV      r2,#0x320             ;1948
000030  f1c50c64          RSB      r12,r5,#0x64          ;1953
                  |L11.52|
000034  fba69301          UMULL    r9,r3,r6,r1           ;1950
000038  099b              LSRS     r3,r3,#6              ;1950
00003a  f8349b02          LDRH     r9,[r4],#2            ;1950
00003e  f9373013          LDRSH    r3,[r7,r3,LSL #1]     ;1950
000042  1c49              ADDS     r1,r1,#1              ;1953
000044  444b              ADD      r3,r3,r9              ;1950
000046  f8b09000          LDRH     r9,[r0,#0]            ;1953
00004a  1e52              SUBS     r2,r2,#1              ;1953
00004c  fb09f905          MUL      r9,r9,r5              ;1953
000050  fb0c9303          MLA      r3,r12,r3,r9          ;1953
000054  fb889303          SMULL    r9,r3,r8,r3           ;1953
000058  ea4f1963          ASR      r9,r3,#5              ;1953
00005c  eba973e3          SUB      r3,r9,r3,ASR #31      ;1953
000060  f8203b02          STRH     r3,[r0],#2            ;1953
000064  d1e6              BNE      |L11.52|
000066  e8bd87f0          POP      {r4-r10,pc}
;;;1957   
                          ENDP

00006a  0000              DCW      0x0000
                  |L11.108|
                          DCD      ||.data||
                  |L11.112|
                          DCD      FullSharedBuff
                  |L11.116|
                          DCD      0xcccccccd
                  |L11.120|
                          DCD      sLFOffsetRow
                  |L11.124|
                          DCD      0x51eb851f

                          AREA ||i.algorithm_baseline_tracking_continuous_local_ring||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous_local_ring PROC
;;;658    extern uint16_t sensingRowStart_Tilt;
;;;659    void algorithm_baseline_tracking_continuous_local_ring(void)
000000  4816              LDR      r0,|L12.92|
;;;660    {
;;;661    	int r,c,read_raw_data;
;;;662    	if(thisModeConf->PenTilt.bRingBaseTracking)
000002  6880              LDR      r0,[r0,#8]  ; thisModeConf
000004  f8900162          LDRB     r0,[r0,#0x162]
000008  2800              CMP      r0,#0
;;;663    	{		
;;;664    		for( r=0; r<PEN_COORD_ROW_MAX; r++ )
;;;665    		{
;;;666    			for( c=0; c<COL_MAX; c++ )
;;;667    			{
;;;668    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)	
;;;669    				read_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r,c);
;;;670    #else
;;;671    				read_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r+PEN_COORD_ROW_MAX,c);
;;;672    #endif
;;;673    				HAL_WRITE_RING_BASELINE_IMAGE(r+sensingRowStart_Tilt,c,(HAL_READ_RING_BASELINE_IMAGE(r+sensingRowStart_Tilt,c) + read_raw_data)>>1);
;;;674    			}
;;;675    		}
;;;676    	}
;;;677    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)		
;;;678    	if(sensingRowStart_Tilt >= MUX_MAX_ROW)
;;;679    	{
;;;680    		sensingRowStart_Tilt = 0;
;;;681    	}
;;;682    	else
;;;683    	{
;;;684    		sensingRowStart_Tilt += PEN_COORD_ROW_MAX;
;;;685    		if(sensingRowStart_Tilt > MUX_MAX_ROW)
;;;686    			sensingRowStart_Tilt = MUX_MAX_ROW;
;;;687    	}
;;;688    #endif
;;;689    }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  b430              PUSH     {r4,r5}               ;660
000010  2000              MOVS     r0,#0                 ;664
000012  4913              LDR      r1,|L12.96|
000014  4c13              LDR      r4,|L12.100|
000016  8809              LDRH     r1,[r1,#0]            ;673
000018  eb010181          ADD      r1,r1,r1,LSL #2       ;673
00001c  eb041241          ADD      r2,r4,r1,LSL #5       ;673
                  |L12.32|
000020  eb020140          ADD      r1,r2,r0,LSL #1       ;673
000024  f5014110          ADD      r1,r1,#0x9000         ;673
000028  eb040340          ADD      r3,r4,r0,LSL #1       ;673
00002c  f8b1cbd8          LDRH     r12,[r1,#0xbd8]       ;673
000030  f8b35960          LDRH     r5,[r3,#0x960]        ;673
000034  f8b33962          LDRH     r3,[r3,#0x962]        ;673
000038  44ac              ADD      r12,r12,r5            ;673
00003a  f8b15bda          LDRH     r5,[r1,#0xbda]        ;673
00003e  ea4f0c5c          LSR      r12,r12,#1            ;673
000042  442b              ADD      r3,r3,r5              ;673
000044  085b              LSRS     r3,r3,#1              ;673
000046  f8a1cbd8          STRH     r12,[r1,#0xbd8]       ;673
00004a  1c80              ADDS     r0,r0,#2              ;673
00004c  f8a13bda          STRH     r3,[r1,#0xbda]        ;673
000050  f5b07fc8          CMP      r0,#0x190             ;673
000054  dbe4              BLT      |L12.32|
000056  bc30              POP      {r4,r5}
000058  4770              BX       lr
;;;690    
                          ENDP

00005a  0000              DCW      0x0000
                  |L12.92|
                          DCD      ||.data||
                  |L12.96|
                          DCD      sensingRowStart_Tilt
                  |L12.100|
                          DCD      LocalSharedBuff

                          AREA ||i.algorithm_baseline_tracking_initial||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial PROC
;;;93     #endif
;;;94     void algorithm_baseline_tracking_initial(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;95     {
;;;96     	uint32_t ulFrameNum, ulIdx;
;;;97     	uint32_t ulFullIdxNum;
;;;98     #ifdef SHORT_COMPENSATION
;;;99         int diff;
;;;100        uint16_t raw_diff_thd = 500;
;;;101    #endif
;;;102        uint16_t temp_data, raw_val = 500;
;;;103    #ifdef SHORT_COMPENSATION
;;;104    	uint32_t raw_avg = 0;
;;;105    	short_cnt = 0;
;;;106    	memset(short_pos, 0, sizeof(short_pos));
;;;107    #endif
;;;108    	uint16_t * pRawImage;
;;;109    	uint16_t * pInitRawImage;
;;;110    	uint16_t * pBaseImage;
;;;111    	uint16_t * pInitBaseImage;
;;;112    	
;;;113        for (ulFrameNum = 0; ulFrameNum < thisModeConf->BaseLine.ucDiscardFrameNum; ulFrameNum++)
000004  4f28              LDR      r7,|L13.168|
000006  2400              MOVS     r4,#0
000008  68b8              LDR      r0,[r7,#8]  ; thisModeConf
00000a  7840              LDRB     r0,[r0,#1]
00000c  2800              CMP      r0,#0
00000e  d906              BLS      |L13.30|
                  |L13.16|
;;;114    	{
;;;115    		module_wait_full_sample_done();
000010  f7fffffe          BL       module_wait_full_sample_done
000014  68b8              LDR      r0,[r7,#8]  ; thisModeConf
000016  1c64              ADDS     r4,r4,#1
000018  7840              LDRB     r0,[r0,#1]
00001a  42a0              CMP      r0,r4
00001c  d8f8              BHI      |L13.16|
                  |L13.30|
;;;116    	}
;;;117    
;;;118    #ifdef MODE_WDT				
;;;119    	KICK_DOG();
00001e  f7fffffe          BL       Hal_Kick_DOG
;;;120    #endif
;;;121    
;;;122    	pInitRawImage = pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;123    #if USED_NOISE_HOPPING_FREQ
;;;124    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
000022  6938              LDR      r0,[r7,#0x10]  ; ptAppInfo
000024  4d21              LDR      r5,|L13.172|
000026  7c80              LDRB     r0,[r0,#0x12]
000028  2801              CMP      r0,#1
;;;125    	{
;;;126    		pInitBaseImage = pBaseImage = g_pFingerBaseImage;
00002a  bf0f              ITEEE    EQ
00002c  69f8              LDREQ    r0,[r7,#0x1c]  ; g_pFingerBaseImage
;;;127    	}
;;;128    	else
;;;129    	{
;;;130    		pInitBaseImage = pBaseImage = (uint16_t *)HAL_GET_HOPP1_BASELINE_IMAGE_PTR() ;
00002e  481f              LDRNE    r0,|L13.172|
000030  f2454160          MOVNE    r1,#0x5460
000034  4408              ADDNE    r0,r1
000036  4604              MOV      r4,r0
;;;131    	}
;;;132    //	pInitBaseImage = pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;133    #else /* USED_NOISE_HOPPING_FREQ */
;;;134    	pInitBaseImage = pBaseImage = g_pFingerBaseImage;//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;135    #endif /* USED_NOISE_HOPPING_FREQ */
;;;136    	memset((void*)pBaseImage, 0x00, sizeof(uint16_t)*(ROW_MAX * COL_MAX));
000038  f44f51e1          MOV      r1,#0x1c20
00003c  f7fffffe          BL       __aeabi_memclr
;;;137    	ulFullIdxNum = ROW_MAX * COL_MAX;
;;;138    
;;;139        for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
000040  68b8              LDR      r0,[r7,#8]  ; thisModeConf
000042  7880              LDRB     r0,[r0,#2]
000044  1e46              SUBS     r6,r0,#1
000046  d317              BCC      |L13.120|
                  |L13.72|
;;;140        {
;;;141    		module_wait_full_sample_done();
000048  f7fffffe          BL       module_wait_full_sample_done
;;;142    		pRawImage = pInitRawImage;
;;;143    		pBaseImage = pInitBaseImage;
;;;144    		for(ulIdx = ulFullIdxNum; ulIdx--; )
00004c  1ea1              SUBS     r1,r4,#2
00004e  1eaa              SUBS     r2,r5,#2
000050  f44f63e1          MOV      r3,#0x708
                  |L13.84|
;;;145    		{
;;;146    			raw_val = *(pRawImage++);
;;;147    			temp_data = *(pBaseImage) + raw_val;
;;;148    			*(pBaseImage++) = temp_data;
000054  f8310f02          LDRH     r0,[r1,#2]!
000058  f8b2c002          LDRH     r12,[r2,#2]
00005c  1e5b              SUBS     r3,r3,#1
00005e  4460              ADD      r0,r0,r12
000060  f8210b02          STRH     r0,[r1],#2
000064  f832cf04          LDRH     r12,[r2,#4]!
000068  8808              LDRH     r0,[r1,#0]
00006a  4460              ADD      r0,r0,r12
00006c  8008              STRH     r0,[r1,#0]
00006e  d1f1              BNE      |L13.84|
;;;149    #ifdef SHORT_COMPENSATION
;;;150    			raw_avg += raw_val;
;;;151    #endif
;;;152    		}
;;;153    
;;;154    #ifdef MODE_WDT				
;;;155    		KICK_DOG();
000070  f7fffffe          BL       Hal_Kick_DOG
000074  1e76              SUBS     r6,r6,#1
000076  d2e7              BCS      |L13.72|
                  |L13.120|
;;;156    #endif
;;;157        }
;;;158    
;;;159    #ifdef SHORT_COMPENSATION
;;;160    	raw_avg /= (ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;161    #endif
;;;162    
;;;163    	pBaseImage = pInitBaseImage;
;;;164    	for(ulIdx = ulFullIdxNum; ulIdx--; )
;;;165    	{
;;;166    		temp_data = (*pBaseImage);
;;;167    		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
000078  68ba              LDR      r2,[r7,#8]  ; thisModeConf
00007a  1ea0              SUBS     r0,r4,#2              ;164
00007c  f44f61e1          MOV      r1,#0x708             ;164
                  |L13.128|
000080  f8303f02          LDRH     r3,[r0,#2]!
000084  f892c002          LDRB     r12,[r2,#2]
;;;168    		(*pBaseImage++) = temp_data;
000088  1e49              SUBS     r1,r1,#1
00008a  fbb3f3fc          UDIV     r3,r3,r12             ;167
00008e  f8203b02          STRH     r3,[r0],#2
000092  f892c002          LDRB     r12,[r2,#2]           ;167
000096  8803              LDRH     r3,[r0,#0]            ;167
000098  fbb3f3fc          UDIV     r3,r3,r12             ;167
00009c  8003              STRH     r3,[r0,#0]
00009e  d1ef              BNE      |L13.128|
;;;169    #ifdef SHORT_COMPENSATION
;;;170    		diff = raw_avg - temp_data;
;;;171    		if( diff > raw_diff_thd && short_cnt < SHORT_NUM )
;;;172    		{
;;;173    			short_pos[short_cnt].c = c;
;;;174    			short_pos[short_cnt].r = r;
;;;175    			short_cnt++;
;;;176    		}
;;;177    #endif
;;;178    	}
;;;179    
;;;180    #ifdef MODE_WDT				
;;;181    	KICK_DOG();
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  f7ffbffe          B.W      Hal_Kick_DOG
;;;182    #endif
;;;183    }
;;;184    
                          ENDP

                  |L13.168|
                          DCD      ||.data||
                  |L13.172|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_tracking_initial_S3||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial_S3 PROC
;;;1839   #if USED_MNT_S3_MODE_FUNCTION
;;;1840   void algorithm_baseline_tracking_initial_S3(bool_t bIsSkip)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1841   {
;;;1842   	uint32_t ulFrameNum, ulIdx;
;;;1843   	uint32_t ulNiIdxNum;
;;;1844   	uint32_t ulSkipFrameNum;
;;;1845   #ifdef SHORT_COMPENSATION
;;;1846       int diff;
;;;1847       uint16_t raw_diff_thd = 500;
;;;1848   #endif
;;;1849       uint16_t temp_data, raw_val = 500;
;;;1850   #ifdef SHORT_COMPENSATION
;;;1851   	uint32_t raw_avg = 0;
;;;1852   	uint32_t raw_avg_Ni_1 = 0,  raw_avg_Ni_2 = 0;
;;;1853   	short_cnt = 0;
;;;1854   	memset(short_pos, 0, sizeof(short_pos));
;;;1855   #endif
;;;1856   	uint16_t * pNiRawImage;
;;;1857   	uint16_t * pNiInitRawImage;
;;;1858   	uint16_t * pNiBaseImage;
;;;1859   	uint16_t * pNiInitBaseImage;
;;;1860   
;;;1861   	if(bIsSkip)
;;;1862   	{
;;;1863   		ulSkipFrameNum = thisModeConf->BaseLine.ucDiscardFrameNum;
000004  4e28              LDR      r6,|L14.168|
000006  2800              CMP      r0,#0                 ;1861
;;;1864   	}
;;;1865   	else
;;;1866   	{
;;;1867   		ulSkipFrameNum = 3;
000008  bf04              ITT      EQ
00000a  2503              MOVEQ    r5,#3
;;;1868   	}
;;;1869   
;;;1870       for(ulFrameNum=0; ulFrameNum<ulSkipFrameNum; ulFrameNum++)
00000c  2400              MOVEQ    r4,#0
00000e  d004              BEQ      |L14.26|
000010  68b0              LDR      r0,[r6,#8]            ;1863  ; thisModeConf
000012  2400              MOVS     r4,#0
000014  7845              LDRB     r5,[r0,#1]            ;1863
000016  2d00              CMP      r5,#0
000018  d904              BLS      |L14.36|
                  |L14.26|
;;;1871       {
;;;1872       	module_wait_S3_sample_done();
00001a  f7fffffe          BL       module_wait_S3_sample_done
00001e  1c64              ADDS     r4,r4,#1
000020  42a5              CMP      r5,r4
000022  d8fa              BHI      |L14.26|
                  |L14.36|
;;;1873       }
;;;1874   
;;;1875   #ifdef MODE_WDT
;;;1876   	KICK_DOG();
000024  f7fffffe          BL       Hal_Kick_DOG
;;;1877   #endif
;;;1878   
;;;1879   	pNiInitRawImage = pNiRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
000028  4d20              LDR      r5,|L14.172|
;;;1880   	pNiInitBaseImage = pNiBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
00002a  f7fffffe          BL       HAL_GetSensingMode
00002e  2101              MOVS     r1,#1
000030  f7fffffe          BL       HAL_GetBaseImagePointer
000034  4604              MOV      r4,r0
;;;1881       memset((void*)pNiBaseImage, 0x00, sizeof(uint16_t)*(NI_ROW_MAX * COL_MAX));
000036  f44f61c8          MOV      r1,#0x640
00003a  f7fffffe          BL       __aeabi_memclr
;;;1882       ulNiIdxNum = NI_ROW_MAX * COL_MAX;
;;;1883   
;;;1884       for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
00003e  68b0              LDR      r0,[r6,#8]  ; thisModeConf
000040  7880              LDRB     r0,[r0,#2]
000042  1e47              SUBS     r7,r0,#1
000044  d318              BCC      |L14.120|
;;;1885       {
;;;1886       	module_wait_S3_sample_done();
000046  bf00              NOP      
                  |L14.72|
000048  f7fffffe          BL       module_wait_S3_sample_done
;;;1887   
;;;1888   		pNiRawImage = pNiInitRawImage;
;;;1889   		pNiBaseImage = pNiInitBaseImage;
;;;1890   		for(ulIdx = ulNiIdxNum; ulIdx--; )
00004c  1ea1              SUBS     r1,r4,#2
00004e  1eaa              SUBS     r2,r5,#2
000050  f44f73c8          MOV      r3,#0x190
                  |L14.84|
;;;1891   		{
;;;1892   			raw_val = *(pNiRawImage++);
;;;1893   			temp_data = *(pNiBaseImage) + raw_val;
;;;1894   			*(pNiBaseImage++) = temp_data;
000054  f8310f02          LDRH     r0,[r1,#2]!
000058  f8b2c002          LDRH     r12,[r2,#2]
00005c  1e5b              SUBS     r3,r3,#1
00005e  4460              ADD      r0,r0,r12
000060  f8210b02          STRH     r0,[r1],#2
000064  f832cf04          LDRH     r12,[r2,#4]!
000068  8808              LDRH     r0,[r1,#0]
00006a  4460              ADD      r0,r0,r12
00006c  8008              STRH     r0,[r1,#0]
00006e  d1f1              BNE      |L14.84|
;;;1895   #ifdef SHORT_COMPENSATION
;;;1896   			raw_avg_Ni_1 += raw_val;
;;;1897   #endif
;;;1898   		}
;;;1899   
;;;1900   #ifdef MODE_WDT
;;;1901   		KICK_DOG();
000070  f7fffffe          BL       Hal_Kick_DOG
000074  1e7f              SUBS     r7,r7,#1
000076  d2e7              BCS      |L14.72|
                  |L14.120|
;;;1902   #endif
;;;1903       }
;;;1904   
;;;1905   #ifdef SHORT_COMPENSATION
;;;1906   	raw_avg /= (ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1907   	raw_avg_Ni_1 /= (NI_ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1908   	raw_avg_Ni_2 /= (NI_ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1909   #endif
;;;1910   
;;;1911   	pNiBaseImage = pNiInitBaseImage;
;;;1912   	for(ulIdx = ulNiIdxNum; ulIdx--; )
;;;1913   	{
;;;1914   		temp_data = (*pNiBaseImage);
;;;1915   		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
000078  68b2              LDR      r2,[r6,#8]  ; thisModeConf
00007a  1ea0              SUBS     r0,r4,#2              ;1912
00007c  f44f71c8          MOV      r1,#0x190             ;1912
                  |L14.128|
000080  f8303f02          LDRH     r3,[r0,#2]!
000084  f892c002          LDRB     r12,[r2,#2]
;;;1916   		(*pNiBaseImage++) = temp_data;
000088  1e49              SUBS     r1,r1,#1
00008a  fbb3f3fc          UDIV     r3,r3,r12             ;1915
00008e  f8203b02          STRH     r3,[r0],#2
000092  f892c002          LDRB     r12,[r2,#2]           ;1915
000096  8803              LDRH     r3,[r0,#0]            ;1915
000098  fbb3f3fc          UDIV     r3,r3,r12             ;1915
00009c  8003              STRH     r3,[r0,#0]
00009e  d1ef              BNE      |L14.128|
;;;1917   #ifdef SHORT_COMPENSATION
;;;1918   		diff = raw_avg_Ni_1 - temp_data;
;;;1919   		if( diff > raw_diff_thd && short_cnt < SHORT_NUM )
;;;1920   		{
;;;1921   			short_pos[short_cnt].c = c;
;;;1922   			short_pos[short_cnt].r = r;
;;;1923   			short_cnt++;
;;;1924   		}
;;;1925   #endif
;;;1926   	}
;;;1927   
;;;1928   #ifdef MODE_WDT
;;;1929   	KICK_DOG();
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  f7ffbffe          B.W      Hal_Kick_DOG
;;;1930   #endif
;;;1931   }
;;;1932   
                          ENDP

                  |L14.168|
                          DCD      ||.data||
                  |L14.172|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_tracking_initial_local||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial_local PROC
;;;186    
;;;187    bool_t algorithm_baseline_tracking_initial_local(uint8_t OP_TYPE)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;188    {
000004  b083              SUB      sp,sp,#0xc
;;;189    	int r, c , r_pos;
;;;190    //	uint32_t ulRowEnd = PEN_COORD_ROW_MAX;
;;;191    	int ulRowEnd = PEN_COORD_ROW_MAX;
000006  2505              MOVS     r5,#5
;;;192    	uint16_t temp_data = 0;
;;;193    	ePartialSensing_t lDataIndex = PARTIAL_PEN_BEACON;
;;;194    	bool_t local_base_return_flag = NO;
;;;195        int finger_div = ((ROW_MAX + (PEN_COORD_ROW_MAX - 1)) / PEN_COORD_ROW_MAX);
;;;196    //	uint16_t * pPenBaseImage;
;;;197    //	uint16_t * pFingerBaseImage;
;;;198    
;;;199    //	if(OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS)
;;;200    //	{
;;;201    //		pPenBaseImage = HAL_GET_LOCAL_BASELINE_IMAGE_PTR();
;;;202    //		pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;203    //	}
;;;204    //	else
;;;205    //	{
;;;206    //#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;207    //		pPenBaseImage = HAL_GET_LOCAL_BASELINE_IMAGE_PTR();
;;;208    //		pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;209    //#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;210    //		pPenBaseImage = HAL_GET_LOCAL_BASELINE_IMAGE_2_PTR();
;;;211    //		pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
;;;212    //#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;213    //	}
;;;214    	
;;;215    	sensingRowStart = 0;
000008  f8dfb200          LDR      r11,|L15.524|
00000c  2000              MOVS     r0,#0                 ;194
00000e  9001              STR      r0,[sp,#4]
000010  f04f0809          MOV      r8,#9                 ;195
000014  f8ab0000          STRH     r0,[r11,#0]
;;;216    
;;;217    	module_wait_Vsync_signal(LOCAL_MODE, thisModeConf->BaseLine.ucDiscardFrameNum);
000018  f8df91f4          LDR      r9,|L15.528|
00001c  f8d90008          LDR      r0,[r9,#8]  ; thisModeConf
000020  7841              LDRB     r1,[r0,#1]
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       module_wait_Vsync_signal
;;;218    
;;;219    	uint16_t * pPenBaseImage = g_pLocalBaseImage;
000028  487a              LDR      r0,|L15.532|
;;;220    	uint16_t * pFingerBaseImage = g_pFingerBaseImage;
00002a  f8d9601c          LDR      r6,[r9,#0x1c]  ; g_pFingerBaseImage
00002e  6804              LDR      r4,[r0,#0]  ; g_pLocalBaseImage
                  |L15.48|
;;;221    	
;;;222        while(YES)
;;;223        {
;;;224    		lDataIndex = module_wait_local_sample_done();
000030  f7fffffe          BL       module_wait_local_sample_done
;;;225    
;;;226    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;227    		if((lDataIndex == LOCAL_OP_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS) || (lDataIndex == LOCAL_OP_2_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_WGP))
;;;228    #else
;;;229    		if(lDataIndex == LOCAL_OP_LAST_LHB || lDataIndex == PARTIAL_MAX)
000034  2808              CMP      r0,#8
000036  bf18              IT       NE
000038  2816              CMPNE    r0,#0x16
00003a  d1f9              BNE      |L15.48|
;;;230    #endif
;;;231    		{
;;;232    			break;
;;;233    		}
;;;234    	}
;;;235    
;;;236        tHalIntrHandle.ulLocalIndexChangeStart = 1;
00003c  4976              LDR      r1,|L15.536|
00003e  f04f0001          MOV      r0,#1
000042  6088              STR      r0,[r1,#8]  ; tHalIntrHandle
;;;237    
;;;238    	uint8_t BaseOffset = thisModeConf->BaseLine.ucPP_MUX_Select * PEN_COORD_ROW_MAX;
000044  f8d91008          LDR      r1,[r9,#8]  ; thisModeConf
000048  f8910042          LDRB     r0,[r1,#0x42]
;;;239    	if(thisModeConf->BaseLine.bPen_2BASE == 1 && thisModeConf->BaseLine.ucPP_MUX_Select > 0)
00004c  f891103e          LDRB     r1,[r1,#0x3e]
000050  eb000280          ADD      r2,r0,r0,LSL #2       ;238
000054  b2d7              UXTB     r7,r2                 ;238
000056  2901              CMP      r1,#1
000058  d103              BNE      |L15.98|
00005a  2800              CMP      r0,#0
;;;240    		BaseOffset -= PEN_COORD_ROW_MAX;
00005c  bf1c              ITT      NE
00005e  1f78              SUBNE    r0,r7,#5
000060  b2c7              UXTBNE   r7,r0
                  |L15.98|
;;;241    	
;;;242    	while(YES)
;;;243    	{
;;;244    		lDataIndex = module_wait_local_sample_done();
000062  f7fffffe          BL       module_wait_local_sample_done
;;;245    
;;;246    		switch(lDataIndex)
000066  9000              STR      r0,[sp,#0]
000068  2806              CMP      r0,#6
00006a  d0fa              BEQ      |L15.98|
00006c  dc08              BGT      |L15.128|
00006e  2801              CMP      r0,#1
000070  bf18              IT       NE
000072  2802              CMPNE    r0,#2
000074  d00b              BEQ      |L15.142|
000076  2803              CMP      r0,#3
000078  bf18              IT       NE
00007a  2804              CMPNE    r0,#4
00007c  d007              BEQ      |L15.142|
00007e  e06f              B        |L15.352|
                  |L15.128|
000080  2807              CMP      r0,#7
000082  bf18              IT       NE
000084  2808              CMPNE    r0,#8
000086  d06b              BEQ      |L15.352|
000088  280c              CMP      r0,#0xc
00008a  d045              BEQ      |L15.280|
00008c  e068              B        |L15.352|
                  |L15.142|
;;;247    		{
;;;248    			case PARTIAL_PEN_COORD1:
;;;249    			case PARTIAL_PEN_COORD2:
;;;250    			case PARTIAL_PEN_COORD3:
;;;251    			case PARTIAL_PEN_COORD4:
;;;252    			{
;;;253    				int temp_raw_data;
;;;254    
;;;255    #if USED_PANEL_HV60x34_SIZE
;;;256    				if(sensingRowStart == 30)
;;;257    				{
;;;258    					ulRowEnd = PEN_COORD_ROW_MAX-1;
;;;259    				}
;;;260    #endif /* USED_PANEL_HV60x34_SIZE */
;;;261    				for(r = 0; r < ulRowEnd; r++)
00008e  2100              MOVS     r1,#0
000090  2d00              CMP      r5,#0
000092  dd65              BLE      |L15.352|
;;;262    				{
;;;263    					r_pos = (r+sensingRowStart)*COL_MAX;
;;;264    					for(c = 0; c < COL_MAX; c++)
;;;265    					{
;;;266    						temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r+BaseOffset, c);
;;;267    						temp_data = pPenBaseImage[r_pos+c] + temp_raw_data; //HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;268    						pPenBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;269    						
;;;270    						if(thisModeConf->BaseLine.bPen_2BASE == 1)
000094  485e              LDR      r0,|L15.528|
000096  4a5d              LDR      r2,|L15.524|
000098  f8d0a008          LDR      r10,[r0,#8]           ;215  ; thisModeConf
                  |L15.156|
00009c  8810              LDRH     r0,[r2,#0]            ;263  ; sensingRowStart
00009e  f8dfc17c          LDR      r12,|L15.540|
0000a2  4408              ADD      r0,r0,r1              ;263
0000a4  eb000080          ADD      r0,r0,r0,LSL #2       ;263
0000a8  ea4f1900          LSL      r9,r0,#4              ;263
0000ac  2000              MOVS     r0,#0                 ;264
0000ae  19cb              ADDS     r3,r1,r7              ;266
0000b0  eb030383          ADD      r3,r3,r3,LSL #2       ;266
0000b4  eb0c1343          ADD      r3,r12,r3,LSL #5      ;266
                  |L15.184|
0000b8  eb090c00          ADD      r12,r9,r0             ;267
0000bc  f833b010          LDRH     r11,[r3,r0,LSL #1]    ;266
0000c0  f834e01c          LDRH     lr,[r4,r12,LSL #1]    ;267
0000c4  44f3              ADD      r11,r11,lr            ;267
0000c6  f824b01c          STRH     r11,[r4,r12,LSL #1]   ;268
0000ca  f89ac03e          LDRB     r12,[r10,#0x3e]
0000ce  f1bc0f01          CMP      r12,#1
0000d2  d11a              BNE      |L15.266|
;;;271    						{
;;;272    							temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r+BaseOffset+PEN_COORD_ROW_MAX, c);
0000d4  eb030c40          ADD      r12,r3,r0,LSL #1
;;;273    							temp_data = pPenBaseImage[(r+sensingRowStart+ROW_MAX)*COL_MAX+c] + temp_raw_data; //HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c) + temp_raw_data;
0000d8  f8b2b000          LDRH     r11,[r2,#0]  ; sensingRowStart
0000dc  f8bcc320          LDRH     r12,[r12,#0x320]      ;272
0000e0  448b              ADD      r11,r11,r1
0000e2  f10b0b2d          ADD      r11,r11,#0x2d
0000e6  eb0b0b8b          ADD      r11,r11,r11,LSL #2
0000ea  eb001b0b          ADD      r11,r0,r11,LSL #4
0000ee  f834b01b          LDRH     r11,[r4,r11,LSL #1]
0000f2  44dc              ADD      r12,r12,r11
;;;274    							pPenBaseImage[(r+sensingRowStart+ROW_MAX)*COL_MAX+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c, temp_data);		
0000f4  f8b2b000          LDRH     r11,[r2,#0]  ; sensingRowStart
0000f8  448b              ADD      r11,r11,r1
0000fa  f10b0b2d          ADD      r11,r11,#0x2d
0000fe  eb0b0b8b          ADD      r11,r11,r11,LSL #2
000102  eb001b0b          ADD      r11,r0,r11,LSL #4
000106  f824c01b          STRH     r12,[r4,r11,LSL #1]
                  |L15.266|
00010a  1c40              ADDS     r0,r0,#1
00010c  2850              CMP      r0,#0x50
00010e  dbd3              BLT      |L15.184|
000110  1c49              ADDS     r1,r1,#1
000112  42a9              CMP      r1,r5
000114  dbc2              BLT      |L15.156|
000116  e023              B        |L15.352|
                  |L15.280|
;;;275    						}
;;;276    
;;;277    #if ((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)) && defined(TILT_ON)
;;;278    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;279    						if(OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS)
;;;280    	#endif
;;;281    						{
;;;282    	//						if(lDataIndex == PARTIAL_PEN_COORD1)// || lDataIndex == PARTIAL_PEN_COORD3)
;;;283    	//						{
;;;284    	//							temp_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r+PEN_COORD_ROW_MAX, c);
;;;285    	//							temp_data = HAL_READ_RING_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c) + temp_raw_data;
;;;286    	//							HAL_WRITE_RING_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c, temp_data);
;;;287    	//						}
;;;288    						
;;;289    							if(/*lDataIndex == PARTIAL_PEN_COORD1 ||*/ lDataIndex == PARTIAL_PEN_COORD3)
;;;290    							{
;;;291    								temp_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r+PEN_COORD_ROW_MAX, c);
;;;292    								temp_data = HAL_READ_RING_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;293    								HAL_WRITE_RING_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;294    							}
;;;295    							
;;;296    	#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
;;;297    							if(lDataIndex == PARTIAL_PEN_COORD1)
;;;298    							{							
;;;299    								temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r,c);
;;;300    								temp_data = HAL_READ_RECAL_BASELINE_IMAGE(r+ sensingRowStart,c) + temp_raw_data;
;;;301    								HAL_WRITE_RECAL_BASELINE_IMAGE(r+ sensingRowStart, c, temp_data);								
;;;302    							}
;;;303    	#endif
;;;304    						}
;;;305    #endif
;;;306    						/*
;;;307    						 * TODD_1st : 아래 상수값 parameter로 빼자!!
;;;308    						 */
;;;309    //						if(sub_data < 0)
;;;310    //						{
;;;311    //							sub_data = -sub_data;
;;;312    //						}
;;;313    //						if(sub_data > 200)
;;;314    //						{
;;;315    //							g_temp_sum += sub_data;
;;;316    //						}
;;;317    //
;;;318    //						prev_raw_data = temp_raw_data;
;;;319    					}
;;;320    				}
;;;321    
;;;322    //				if(g_temp_sum > 1000)
;;;323    //				{
;;;324    //					local_base_return_flag = YES;
;;;325    //				}
;;;326    				break;
;;;327    			}
;;;328    			
;;;329    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)			
;;;330    			case PARTIAL_PEN_COORD_DATA1:
;;;331    			case PARTIAL_PEN_COORD_DATA2:
;;;332    			case PARTIAL_PEN_COORD_DATA3:
;;;333    			case PARTIAL_PEN_COORD_DATA4:
;;;334    			{
;;;335    				int temp_raw_data;
;;;336    				for(r = 0; r < ulRowEnd; r++)
;;;337    				{
;;;338    					for(c = 0; c < COL_MAX; c++)
;;;339    					{
;;;340    						temp_raw_data = HAL_READ_LOCAL_DATA_RAW_IMAGE_3(r+BaseOffset, c);
;;;341    						temp_data = HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;342    						HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;343    						if(thisModeConf->BaseLine.bPen_2BASE == 1)
;;;344    						{
;;;345    							temp_raw_data = HAL_READ_LOCAL_DATA_RAW_IMAGE_3(r+BaseOffset+PEN_COORD_ROW_MAX, c);
;;;346    							temp_data = HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c) + temp_raw_data;
;;;347    							HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c, temp_data);		
;;;348    						}							
;;;349    					}
;;;350    				}
;;;351    				break;
;;;352    			}
;;;353    //			case PARTIAL_TILT1:
;;;354    //			{
;;;355    //				int temp_raw_data;
;;;356    //				for(r = 0; r < ulRowEnd; r++)
;;;357    //				{
;;;358    //					for(c = 0; c < COL_MAX; c++)
;;;359    //					{
;;;360    //						temp_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r, c);
;;;361    //						temp_data = HAL_READ_RING_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;362    //						HAL_WRITE_RING_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;363    //					}
;;;364    //				}
;;;365    //				break;
;;;366    //			}
;;;367    #endif /* USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN */			
;;;368    			case LOCAL_FINGER_LAST_LHB:
;;;369    			{
;;;370    				int temp_raw_data;
;;;371    				for (r = 0; r < ROW_MAX; r++)
000118  f04f0c00          MOV      r12,#0
;;;372    				{
;;;373    					r_pos = r*COL_MAX;
;;;374    					for (c = 0; c < COL_MAX; c++)
00011c  f8dfa100          LDR      r10,|L15.544|
000120  4662              MOV      r2,r12                ;371
000122  bf00              NOP      
                  |L15.292|
000124  eb06004c          ADD      r0,r6,r12,LSL #1
000128  eb020182          ADD      r1,r2,r2,LSL #2
00012c  eb0a1141          ADD      r1,r10,r1,LSL #5
000130  1e80              SUBS     r0,r0,#2
000132  f04f0928          MOV      r9,#0x28
000136  1e89              SUBS     r1,r1,#2
                  |L15.312|
;;;375    					{
;;;376    						temp_raw_data = HAL_READ_LOCAL_FINGER_RAW_IMAGE(r, c);
;;;377    #if USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS
;;;378    						if(temp_raw_data == 0)
;;;379    						{
;;;380    							ulZeroFingerRawMaskInfo[r][c/ZERO_FINGER_RAWDATA_MASK_NUM] |= (0x1<<(c%ZERO_FINGER_RAWDATA_MASK_NUM));
;;;381    						}
;;;382    #endif /* USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS */
;;;383    						temp_data = pFingerBaseImage[r_pos+c] + temp_raw_data; //HAL_READ_LOCAL_FINGER_BASELINE_IMAGE(r, c) + temp_raw_data;
;;;384    						pFingerBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE(r, c, temp_data);
000138  f8303f02          LDRH     r3,[r0,#2]!
00013c  f8b1b002          LDRH     r11,[r1,#2]
000140  f1b90901          SUBS     r9,r9,#1
000144  445b              ADD      r3,r3,r11
000146  f8203b02          STRH     r3,[r0],#2
00014a  f831bf04          LDRH     r11,[r1,#4]!
00014e  8803              LDRH     r3,[r0,#0]
000150  445b              ADD      r3,r3,r11
000152  8003              STRH     r3,[r0,#0]
000154  d1f0              BNE      |L15.312|
000156  1c52              ADDS     r2,r2,#1
000158  f10c0c50          ADD      r12,r12,#0x50
;;;385    					}
00015c  2a2d              CMP      r2,#0x2d
00015e  dbe1              BLT      |L15.292|
                  |L15.352|
;;;386    				}
;;;387    				break;
;;;388    			}
;;;389    			case PARTIAL_PEN_DATA1:
;;;390    			case PARTIAL_PEN_DATA2:
;;;391    			case PARTIAL_PEN_DATA3:
;;;392    			case PARTIAL_PEN_DATA4:
;;;393    			case PARTIAL_MAX:
;;;394    			default:
;;;395    				break;
;;;396    		}
;;;397    
;;;398    		if(lDataIndex == PARTIAL_PEN_COORD4 || lDataIndex == PARTIAL_PEN_COORD_DATA4)
000160  9800              LDR      r0,[sp,#0]
000162  2804              CMP      r0,#4
000164  bf18              IT       NE
000166  2815              CMPNE    r0,#0x15
000168  d113              BNE      |L15.402|
;;;399    		{
;;;400    			sensingRowStart += PEN_COORD_ROW_MAX;
00016a  4828              LDR      r0,|L15.524|
00016c  8801              LDRH     r1,[r0,#0]  ; sensingRowStart
00016e  f1010105          ADD      r1,r1,#5
000172  8001              STRH     r1,[r0,#0]
;;;401    			if(sensingRowStart >= ROW_MAX)
000174  8801              LDRH     r1,[r0,#0]  ; sensingRowStart
000176  292d              CMP      r1,#0x2d
000178  d303              BCC      |L15.386|
;;;402    			{
;;;403    				ulRowEnd = PEN_COORD_ROW_MAX;
00017a  2505              MOVS     r5,#5
;;;404    				sensingRowStart = 0;
00017c  2100              MOVS     r1,#0
00017e  8001              STRH     r1,[r0,#0]
000180  e007              B        |L15.402|
                  |L15.386|
;;;405    			}
;;;406    			else if((ROW_MAX - sensingRowStart) < PEN_COORD_ROW_MAX)
000182  8801              LDRH     r1,[r0,#0]  ; sensingRowStart
000184  f1c1012d          RSB      r1,r1,#0x2d
000188  2905              CMP      r1,#5
;;;407    			{
;;;408    				ulRowEnd = (ROW_MAX - sensingRowStart);
00018a  bfbc              ITT      LT
00018c  8800              LDRHLT   r0,[r0,#0]  ; sensingRowStart
00018e  f1c0052d          RSBLT    r5,r0,#0x2d
                  |L15.402|
;;;409    			}
;;;410    		}
;;;411    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;412    		if(((lDataIndex == LOCAL_OP_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS) || (lDataIndex == LOCAL_OP_2_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_WGP)) && sensingRowStart == 0)
;;;413    #else
;;;414    		if((lDataIndex == LOCAL_OP_LAST_LHB && sensingRowStart == 0) || lDataIndex == PARTIAL_MAX)
000192  9800              LDR      r0,[sp,#0]
000194  2808              CMP      r0,#8
000196  d01d              BEQ      |L15.468|
000198  2816              CMP      r0,#0x16
00019a  f47faf62          BNE      |L15.98|
                  |L15.414|
;;;415    #endif
;;;416    		{
;;;417    			break;
;;;418    		}
;;;419    	}
;;;420    
;;;421    	for(r = ROW_MAX; r--; )
;;;422    	{
;;;423    		r_pos = r*COL_MAX;
;;;424    		for(c=COL_MAX; c--; )
;;;425    		{
;;;426    			temp_data = pPenBaseImage[r_pos+c]; //HAL_READ_LOCAL_BASELINE_IMAGE(r, c);
;;;427    			temp_data /= 4;
;;;428    			pPenBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r, c, temp_data);
;;;429    
;;;430    			if(thisModeConf->BaseLine.bPen_2BASE == 1)
00019e  481c              LDR      r0,|L15.528|
;;;431    			{
;;;432    				temp_data = pPenBaseImage[(r+ROW_MAX)*COL_MAX+c]; //HAL_READ_LOCAL_BASELINE_IMAGE(r+ROW_MAX, c);
;;;433    				temp_data /= 4;
;;;434    				pPenBaseImage[(r+ROW_MAX)*COL_MAX+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r+ROW_MAX, c, temp_data);
;;;435    			}
;;;436    
;;;437    #if 0//((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)) && defined(TILT_ON)
;;;438    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;439    			if(OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS)
;;;440    	#endif
;;;441    			{
;;;442    				temp_data = HAL_READ_RING_BASELINE_IMAGE(r, c);
;;;443    //				temp_data /= 2;
;;;444    				HAL_WRITE_RING_BASELINE_IMAGE(r, c, temp_data);
;;;445    			}
;;;446    #endif			
;;;447    			temp_data = pFingerBaseImage[r_pos+c]; //HAL_READ_LOCAL_FINGER_BASELINE_IMAGE(r, c);			
;;;448    			temp_data /= finger_div;
;;;449    			pFingerBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE(r, c, temp_data);
;;;450    		}
;;;451    	}
;;;452    
;;;453    	return local_base_return_flag;
;;;454    }
0001a0  232c              MOVS     r3,#0x2c
0001a2  f04f094f          MOV      r9,#0x4f
0001a6  6885              LDR      r5,[r0,#8]  ; thisModeConf
                  |L15.424|
0001a8  eb030083          ADD      r0,r3,r3,LSL #2       ;423
0001ac  ea4f1c00          LSL      r12,r0,#4             ;423
0001b0  f103002d          ADD      r0,r3,#0x2d           ;432
0001b4  4649              MOV      r1,r9
0001b6  eb000780          ADD      r7,r0,r0,LSL #2       ;432
0001ba  bf00              NOP                            ;426
                  |L15.444|
0001bc  eb0c0001          ADD      r0,r12,r1             ;426
0001c0  f8342010          LDRH     r2,[r4,r0,LSL #1]     ;426
0001c4  0892              LSRS     r2,r2,#2              ;427
0001c6  f8242010          STRH     r2,[r4,r0,LSL #1]     ;428
0001ca  f895203e          LDRB     r2,[r5,#0x3e]         ;430
0001ce  2a01              CMP      r2,#1                 ;430
0001d0  d10d              BNE      |L15.494|
0001d2  e005              B        |L15.480|
                  |L15.468|
0001d4  480d              LDR      r0,|L15.524|
0001d6  8800              LDRH     r0,[r0,#0]            ;414  ; sensingRowStart
0001d8  2800              CMP      r0,#0                 ;414
0001da  f47faf42          BNE      |L15.98|
0001de  e7de              B        |L15.414|
                  |L15.480|
0001e0  eb011a07          ADD      r10,r1,r7,LSL #4      ;432
0001e4  f834201a          LDRH     r2,[r4,r10,LSL #1]    ;432
0001e8  0892              LSRS     r2,r2,#2              ;433
0001ea  f824201a          STRH     r2,[r4,r10,LSL #1]    ;434
                  |L15.494|
0001ee  f8362010          LDRH     r2,[r6,r0,LSL #1]     ;447
0001f2  1e49              SUBS     r1,r1,#1              ;449
0001f4  fb92f2f8          SDIV     r2,r2,r8              ;448
0001f8  f8262010          STRH     r2,[r6,r0,LSL #1]     ;449
0001fc  d2de              BCS      |L15.444|
0001fe  1e5b              SUBS     r3,r3,#1              ;449
000200  d2d2              BCS      |L15.424|
000202  9801              LDR      r0,[sp,#4]            ;453
000204  b003              ADD      sp,sp,#0xc
000206  e8bd8ff0          POP      {r4-r11,pc}
;;;455    
                          ENDP

00020a  0000              DCW      0x0000
                  |L15.524|
                          DCD      sensingRowStart
                  |L15.528|
                          DCD      ||.data||
                  |L15.532|
                          DCD      g_pLocalBaseImage
                  |L15.536|
                          DCD      tHalIntrHandle
                  |L15.540|
                          DCD      LocalSharedBuff
                  |L15.544|
                          DCD      FullSharedBuff

                          AREA ||.data||, DATA, ALIGN=2

                  traking_en
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  ptModuleModeConf
                          DCD      0x00000000
                  thisModeConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  ptAppInfo
                          DCD      0x00000000
                  dataCnt
                          DCD      0x00000000
                  AbnormalCnt
                          DCD      0x00000000
                  g_pFingerBaseImage
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\App\\Algorithm\\Baseline\\algorithm_baseline.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_b70fc24c____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___20_algorithm_baseline_c_b70fc24c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_b70fc24c____REVSH|
#line 402
|__asm___20_algorithm_baseline_c_b70fc24c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_b70fc24c____RRX|
#line 587
|__asm___20_algorithm_baseline_c_b70fc24c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
