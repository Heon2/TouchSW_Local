; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\interrupt.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\interrupt.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\interrupt.crf ..\..\Hal\interrupt.c]
                          THUMB

                          AREA ||i.HAL_PendSVHandlerInitialize||, CODE, READONLY, ALIGN=2

                  HAL_PendSVHandlerInitialize PROC
;;;460    
;;;461    void HAL_PendSVHandlerInitialize(void)
000000  4904              LDR      r1,|L1.20|
;;;462    {
;;;463    	/*
;;;464    	* NOTE : PendSV_IRQn를 Enable시키지 않고.. 왜 priority만 설정하고 있지?
;;;465    	*/
;;;466    	Fncp_PendSV_IRQHandler = &PendSV_InterruptHandler;
000002  4803              LDR      r0,|L1.16|
000004  6008              STR      r0,[r1,#0]  ; Fncp_PendSV_IRQHandler
000006  4904              LDR      r1,|L1.24|
000008  20e0              MOVS     r0,#0xe0
00000a  f8810d14          STRB     r0,[r1,#0xd14]
;;;467    	NVIC_SetPriority(PendSV_IRQn, PendSV_IRQn_Priority);
;;;468    }
00000e  4770              BX       lr
;;;469    
                          ENDP

                  |L1.16|
                          DCD      PendSV_InterruptHandler
                  |L1.20|
                          DCD      Fncp_PendSV_IRQHandler
                  |L1.24|
                          DCD      0xe000e00e

                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L2.0|
;;;57     #if 1
;;;58     void HardFault_Handler(void)
000000  e7fe              B        |L2.0|
;;;59     {
;;;60     	while (1);
;;;61     }
;;;62     #else
                          ENDP


                          AREA ||i.PendSV_InterruptHandler||, CODE, READONLY, ALIGN=1

                  PendSV_InterruptHandler PROC
;;;103    extern int8_t sensingRowStart_Tilt_Offset;
;;;104    void PendSV_InterruptHandler(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106    	eActivePenType_t eActivePenOpType = hal_Info_GetControlActivePenOPType();
000002  f7fffffe          BL       hal_Info_GetControlActivePenOPType
;;;107    	eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      HAL_GetSensingMode
;;;108    
;;;109    	// _gT(_GPIO_TP_INTR);
;;;110    
;;;111    	switch (eSensingMode)
;;;112    	{
;;;113    #if USED_PEN_MODE_OPERATION
;;;114    		case SM_FINGER_PEN_ACTIVE_MODE:
;;;115    		{
;;;116    			tAlgorithmInfo_t * ptAlgorithmInfo = algorithm_GetInfo();  // NOTE : Global Variable占쏙옙 占쏙옙占쏙옙占싹울옙 Hal占십울옙占쏙옙 Initialize占싹몌옙 占쏙옙占� 占쏙옙 占쏙옙 占쌍듸옙占쏙옙 占쏙옙占쏙옙占쏙옙占쏙옙!! IRQ占쏙옙 Hal占쏙옙占쏙옙占쏙옙 占쏙옙치 占싱듸옙!!
;;;117    			volatile ePartialSensing_t RetVal = PARTIAL_PEN_BEACON;
;;;118    			RetVal = tHalIntrHandle.eLocalSensingType;
;;;119    
;;;120    			hal_set_LocalType_flag(RetVal);
;;;121    
;;;122    			if(TEST_LOCAL_STATE == 1)
;;;123    			{
;;;124    				switch (RetVal)
;;;125    				{
;;;126    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;127    					case PARTIAL_PEN_COORD_DATA1:
;;;128    					case PARTIAL_PEN_COORD_DATA2:
;;;129    					case PARTIAL_PEN_COORD_DATA3:
;;;130    					case PARTIAL_PEN_COORD_DATA4:
;;;131    					{
;;;132    						module_read_local_penposition_pendata_sample_data(RetVal);
;;;133    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;134    						
;;;135    						if(sptAlgorithmInfo->tPenInfo.bSearch_Mode_Flag == 0)
;;;136    						{
;;;137    							algorithm_data_local_process(RetVal);
;;;138    
;;;139    							if(sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt==0)
;;;140    							{
;;;141    								if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;142    								{
;;;143    									hal_Info_SetMPPPen1stBeaconType(PWM_MPP_PEN_1st_PEN_BEACON);
;;;144    								}
;;;145    								else if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;146    								{
;;;147    									hal_Info_SetWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;148    								}
;;;149    								#ifdef OUT_IN_DRAWING
;;;150    								sptAlgorithmInfo->tPenInfo.PrePos.x = 0;
;;;151    								sptAlgorithmInfo->tPenInfo.PrePos.y = 0;
;;;152    								#endif
;;;153    								algorithm_coord_init_local_DSP();
;;;154    								sptAlgorithmInfo->tCoord_local_dsp.PenContactCnt = 0;
;;;155    								sensingRowStart_Tilt = sensingRowStart;
;;;156    								sptAlgorithmInfo->tTiltInfo.sTilt_cnt = 1;
;;;157    								sptAlgorithmInfo->tTiltInfo.HID_TILT_X = sptAlgorithmInfo->tTiltInfo.Smooth_PastTilt.x = 9000;
;;;158    								sptAlgorithmInfo->tTiltInfo.HID_TILT_Y = sptAlgorithmInfo->tTiltInfo.Smooth_PastTilt.y = 9000;
;;;159    							}
;;;160    
;;;161    							if(sptAlgorithmInfo->tPenInfo.bPenContact == YES || sptAlgorithmInfo->tPenInfo.bPrevPenContact == YES)
;;;162    							{
;;;163    								algorithm_local_dsp_process(1, RetVal, LOCAL_MODE);
;;;164    							}
;;;165    							else
;;;166    							{
;;;167    								algorithm_local_dsp_process(1, RetVal, LOCAL_HOVER_MODE);
;;;168    							}
;;;169    								
;;;170    							if(sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt++>32760)
;;;171    								sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt = 10;
;;;172    						}
;;;173    						else
;;;174    						{
;;;175    							algorithm_hover_full_search(RetVal);
;;;176    
;;;177    							sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt = 0;
;;;178    							sptAlgorithmInfo->tPenInfo.bPenContact = NO;
;;;179    							sptAlgorithmInfo->tPenInfo.bReportEraser = 0;
;;;180    						}
;;;181    						break;
;;;182    					}
;;;183    	#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;184    					case PARTIAL_PEN_COORD1:
;;;185    					case PARTIAL_PEN_COORD2:
;;;186    					case PARTIAL_PEN_COORD3:
;;;187    					case PARTIAL_PEN_COORD4:
;;;188    					{
;;;189    						// _gOut(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;190    						module_read_local_penposition_sample_data(RetVal);
;;;191    						// _gOut(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;192    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;193    		#if 1
;;;194    						if (sptAlgorithmInfo->tPenInfo.bSearch_Mode_Flag == 0)
;;;195    						{
;;;196    							if(sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt==0)
;;;197    							{
;;;198    								sptAlgorithmInfo->tPenInfo.usSearch_Mode_Cnt = 0;
;;;199    								if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;200    								{
;;;201    									hal_Info_SetMPPPen1stBeaconType(PWM_MPP_PEN_1st_PEN_BEACON);
;;;202    								}
;;;203    								else if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;204    								{
;;;205    									hal_Info_SetWGPPenBeaconType(PWM_WGP_PEN_GETABS_BEACON);
;;;206    								}
;;;207    								
;;;208    								#ifdef OUT_IN_DRAWING
;;;209    								sptAlgorithmInfo->tPenInfo.PrePos.x = 0;
;;;210    								sptAlgorithmInfo->tPenInfo.PrePos.y = 0;
;;;211    								#endif
;;;212    								algorithm_coord_init_local_DSP();
;;;213    								sptAlgorithmInfo->tCoord_local_dsp.PenContactCnt = 0;
;;;214    								sensingRowStart_Tilt = sensingRowStart;
;;;215    								for(uint8_t i = 1; i < 6 ; i++){sptAlgorithmInfo->tTiltInfo.Median_PastTilt[i].x = 9000;sptAlgorithmInfo->tTiltInfo.Median_PastTilt[i].y = 9000;}
;;;216    							}
;;;217    
;;;218    							if(sptAlgorithmInfo->tPenInfo.bPenContact == YES || sptAlgorithmInfo->tPenInfo.bPrevPenContact == YES)
;;;219    							{
;;;220    								algorithm_local_dsp_process(1, RetVal, LOCAL_MODE);
;;;221    							}
;;;222    							else
;;;223    							{
;;;224    								algorithm_local_dsp_process(1, RetVal, LOCAL_HOVER_MODE);
;;;225    							}
;;;226    							if(sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt++>32760)
;;;227    								sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt = 10;
;;;228    						}
;;;229    						else
;;;230    						{
;;;231    							algorithm_hover_full_search(RetVal);
;;;232    
;;;233    							sensingRowStart_Tilt = sensingRowStart;
;;;234    							sptAlgorithmInfo->tPenInfo.usPen_Coord_Cnt = 0;
;;;235    							sptAlgorithmInfo->tPenInfo.bPenContact = NO;
;;;236    							sptAlgorithmInfo->tPenInfo.bReportEraser = 0;
;;;237    							sensingRowStart_Tilt_Offset = 0;
;;;238    						}
;;;239    		#endif
;;;240    						break;
;;;241    					}
;;;242    					case PARTIAL_PEN_DATA1:
;;;243    					case PARTIAL_PEN_DATA2:
;;;244    					case PARTIAL_PEN_DATA3:
;;;245    					case PARTIAL_PEN_DATA4:
;;;246    					case PARTIAL_PEN_DATA5:
;;;247    					{
;;;248    						module_read_local_pendata_sample_data(RetVal);
;;;249    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;250    
;;;251    						algorithm_data_local_process(RetVal);
;;;252    
;;;253    						/*
;;;254    						 * For Tilt at WACOM AIT Protocol!!
;;;255    						 */
;;;256    		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN)
;;;257    						if(RetVal == PARTIAL_PEN_DATA3 && sptAlgorithmInfo->tPenInfo.bDSP_SendDataEn == 1
;;;258    								&& eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WACOM)
;;;259    						{
;;;260    							SendPenData();
;;;261    							sptAlgorithmInfo->tPenInfo.bDSP_SendDataEn = 0;
;;;262    						}
;;;263    		#endif
;;;264    						if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;265    						{
;;;266    							if(RetVal == PARTIAL_PEN_DATA3 ||
;;;267    								RetVal == PARTIAL_PEN_DATA4)
;;;268    							{
;;;269    								p_currentRowStart = currentRowStart;
;;;270    								currentRowStart = sensingRowStart;
;;;271    								currentColStart = sptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;272    							}
;;;273    						}
;;;274    
;;;275    						if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;276    						{
;;;277    							if(RetVal == PARTIAL_PEN_DATA4)
;;;278    							{
;;;279    								p_currentRowStart = currentRowStart;
;;;280    								currentRowStart = sensingRowStart;
;;;281    								currentColStart = sptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;282    							}
;;;283    						}
;;;284    						break;
;;;285    					}
;;;286    	#endif /* (USED_PEN_PROTOCOL != PEN_PROTOCOL_WGP_UHD_PEN) */
;;;287    					case PARTIAL_FINGER1:
;;;288    					case PARTIAL_FINGER2:
;;;289    					case PARTIAL_FINGER3:
;;;290    					case PARTIAL_FINGER4:
;;;291    					case PARTIAL_FINGER5:
;;;292    					{
;;;293    						module_read_local_finger_sample_data(RetVal);
;;;294    						if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;295    						{	
;;;296    #if (USED_MODULE_DEF == MODULE_DEF_L_1)
;;;297    	#if (CUSTOMER == MODEL_DEF_QHD_92407 || CUSTOMER == MODEL_DEF_QHD_92407_FLIP)
;;;298    							if(RetVal == PARTIAL_FINGER3 ||
;;;299    								RetVal == PARTIAL_FINGER5)
;;;300    	#else /* (CUSTOMER == MODEL_DEF_QHD_92407) */
;;;301    							if(RetVal == PARTIAL_FINGER3 ||
;;;302    								RetVal == PARTIAL_FINGER4)
;;;303    	#endif /* (CUSTOMER == MODEL_DEF_QHD_92407) */
;;;304    #else /* (USED_MODULE_DEF == MODULE_DEF_L_1) */
;;;305    							if(RetVal == PARTIAL_FINGER1 ||
;;;306    								RetVal == PARTIAL_FINGER3)
;;;307    #endif /* (USED_MODULE_DEF == MODULE_DEF_L_1) */
;;;308    							{
;;;309    								p_currentRowStart = currentRowStart;
;;;310    								currentRowStart = sensingRowStart;
;;;311    								currentColStart = sptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;312    							}
;;;313    						}
;;;314    						else if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WACOM)
;;;315    						{
;;;316    #if	(CUSTOMER == MODEL_DEF_QHD_92407 || CUSTOMER == MODEL_DEF_QHD_92407_FLIP) // TODO!! Check!!
;;;317    							if(PARTIAL_FINGER3 != RetVal)
;;;318    #endif
;;;319    							{
;;;320    								p_currentRowStart = currentRowStart;
;;;321    								currentRowStart = sensingRowStart;
;;;322    								currentColStart = sptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;323    							}
;;;324    						}
;;;325    						else if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;326    						{
;;;327    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;328    							if(RetVal == PARTIAL_FINGER1 ||
;;;329    								RetVal == PARTIAL_FINGER2)
;;;330    #else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;331    							if(RetVal == PARTIAL_FINGER1)
;;;332    #endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;333    							{
;;;334    								p_currentRowStart = currentRowStart;
;;;335    								currentRowStart = sensingRowStart;
;;;336    								currentColStart = sptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;337    							}
;;;338    						}
;;;339    
;;;340    						if (RetVal == LOCAL_FINGER_LAST_LHB)
;;;341    						{
;;;342    							// _gT(_GPIO_TP_INTR);
;;;343    //							if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;344    //							{
;;;345    							// _gT(_GPIO_TP_INTR);
;;;346    //							}
;;;347    							hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;348    						}
;;;349    						break;
;;;350    					}
;;;351    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;352    					case PARTIAL_TILT1:
;;;353    					case PARTIAL_TILT2:
;;;354    					{
;;;355    						module_read_local_pentilt_sample_data(RetVal);
;;;356    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;357    		#ifdef TILT_ON
;;;358    			#if (USED_PEN_PROTOCOL != PEN_PROTOCOL_WGP_UHD_PEN)
;;;359    						if (sptAlgorithmInfo->tPenInfo.bSearch_Mode_Flag == 0)
;;;360    							algorithm_local_dsp_process(1, RetVal, LOCAL_TILT_MODE);
;;;361    			#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;362    						if (sptAlgorithmInfo->tPenInfo.bSearch_Mode_Flag == 1)
;;;363    							algorithm_baseline_tracking_continuous_local_ring();
;;;364    			#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;365    		#else
;;;366    						sensingRowStart_Tilt = sensingRowStart;
;;;367    		#endif
;;;368    						if(eActivePenOpType == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;369    						{
;;;370    							p_currentRowStart = currentRowStart;
;;;371    							currentRowStart = sensingRowStart;
;;;372    							currentColStart = sptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;373    						}
;;;374    						break;
;;;375    					}
;;;376    	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;377    					case PARTIAL_MAX:
;;;378    					{
;;;379    						while(1);
;;;380    					}
;;;381    
;;;382    					default:
;;;383    					break;
;;;384    				}
;;;385    			}
;;;386    			else
;;;387    			{
;;;388    				switch (RetVal)
;;;389    				{
;;;390    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;391    					case PARTIAL_TILT1:
;;;392    					case PARTIAL_TILT2:
;;;393    					{
;;;394    						module_read_local_pentilt_sample_data(RetVal);
;;;395    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;396    						break;
;;;397    					}
;;;398    	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;399    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;400    					case PARTIAL_PEN_COORD_DATA1:
;;;401    					case PARTIAL_PEN_COORD_DATA2:
;;;402    					case PARTIAL_PEN_COORD_DATA3:
;;;403    					case PARTIAL_PEN_COORD_DATA4:
;;;404    					{
;;;405    						module_read_local_penposition_pendata_sample_data(RetVal);
;;;406    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;407    						break;
;;;408    					}
;;;409    	#else /* USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;410    					case PARTIAL_PEN_COORD1:
;;;411    					case PARTIAL_PEN_COORD2:
;;;412    					case PARTIAL_PEN_COORD3:
;;;413    					case PARTIAL_PEN_COORD4:
;;;414    					{
;;;415    						module_read_local_penposition_sample_data(RetVal);
;;;416    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;417    						break;
;;;418    					}
;;;419    					case PARTIAL_PEN_DATA1:
;;;420    					case PARTIAL_PEN_DATA2:
;;;421    					case PARTIAL_PEN_DATA3:
;;;422    					case PARTIAL_PEN_DATA4:
;;;423    					case PARTIAL_PEN_DATA5:
;;;424    					{
;;;425    						module_read_local_pendata_sample_data(RetVal);
;;;426    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;427    						break;
;;;428    					}
;;;429    	#endif /* USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;430    					case PARTIAL_FINGER1:
;;;431    					case PARTIAL_FINGER2:
;;;432    					case PARTIAL_FINGER3:
;;;433    					case PARTIAL_FINGER4:
;;;434    					case PARTIAL_FINGER5:
;;;435    					{
;;;436    						module_read_local_finger_sample_data(RetVal);
;;;437    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;438    						break;
;;;439    					}
;;;440    					default:
;;;441    						break;
;;;442    				}
;;;443    			}
;;;444    			break;
;;;445    		}
;;;446    #endif /* USED_PEN_MODE_OPERATION */
;;;447    		case SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE:
;;;448    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE:
;;;449    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP2_MODE:
;;;450    		case SM_FINGER_ONLY_IDLE_MODE:
;;;451    		case SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE:
;;;452    		case SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP1_MODE:
;;;453    		case SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP2_MODE:
;;;454    //		case SM_FINGER_PEN_SEARCH_IDLE_MODE:
;;;455    		{
;;;456    			break;
;;;457    		}
;;;458    	}
;;;459    }
;;;460    
                          ENDP


                          AREA ||i.SensingBufferInit||, CODE, READONLY, ALIGN=2

                  SensingBufferInit PROC
;;;469    
;;;470    void SensingBufferInit(void)
000000  b510              PUSH     {r4,lr}
;;;471    {
;;;472    	p_currentRowStart =			0;
000002  480a              LDR      r0,|L4.44|
000004  2400              MOVS     r4,#0
000006  8004              STRH     r4,[r0,#0]
;;;473    	sensingRowStart =			0;
000008  8044              STRH     r4,[r0,#2]
;;;474    	currentRowStart =			0;
00000a  8084              STRH     r4,[r0,#4]
;;;475    	sensingRowStart_Tilt = 		0;
00000c  80c4              STRH     r4,[r0,#6]
;;;476    
;;;477    	pFreqHoppingAndModeTest =	0;
00000e  6084              STR      r4,[r0,#8]  ; pFreqHoppingAndModeTest
;;;478    #if USED_ECLK_ON_OFF_CONTROL
;;;479    	HAL_SetECLKOnOffControl(NO);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_SetECLKOnOffControl
;;;480    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;481    	tHalIntrHandle.ulMSPIPenModeIntrCnt = 0;
000016  4806              LDR      r0,|L4.48|
000018  6004              STR      r4,[r0,#0]  ; tHalIntrHandle
;;;482    	tHalIntrHandle.ulInitFirstFrame = 1;
00001a  2101              MOVS     r1,#1
00001c  6281              STR      r1,[r0,#0x28]  ; tHalIntrHandle
;;;483    	tHalIntrHandle.ulVSyncFlag = 0;
00001e  6184              STR      r4,[r0,#0x18]  ; tHalIntrHandle
;;;484    	tHalIntrHandle.ulTSyncInFallingCnt = 0;
000020  61c4              STR      r4,[r0,#0x1c]  ; tHalIntrHandle
;;;485    	tHalIntrHandle.ulTSyncInRisingCnt = 0;
000022  6204              STR      r4,[r0,#0x20]  ; tHalIntrHandle
;;;486    	tHalIntrHandle.ulLocalIndexChangeStart = 0;
000024  6084              STR      r4,[r0,#8]  ; tHalIntrHandle
;;;487    #if USED_PWM_PULSE_END_FLAG_CHECK
;;;488    	tHalIntrHandle.ulPWM_Pulse_End_Flag = NO;
000026  6244              STR      r4,[r0,#0x24]  ; tHalIntrHandle
;;;489    #endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;490    }
000028  bd10              POP      {r4,pc}
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      ||.data||
                  |L4.48|
                          DCD      tHalIntrHandle

                          AREA ||.data||, DATA, ALIGN=2

                  p_currentRowStart
000000  0000              DCW      0x0000
                  sensingRowStart
000002  0000              DCW      0x0000
                  currentRowStart
000004  0000              DCW      0x0000
                  sensingRowStart_Tilt
000006  0000              DCB      0x00,0x00
                  pFreqHoppingAndModeTest
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\interrupt.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_631c50be____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___11_interrupt_c_631c50be____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_631c50be____REVSH|
#line 402
|__asm___11_interrupt_c_631c50be____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_631c50be____RRX|
#line 587
|__asm___11_interrupt_c_631c50be____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
