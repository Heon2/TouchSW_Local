; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\scrb.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\scrb.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ --wchar32 --omf_browse=.\bin\scrb.crf ..\..\Hal\scrb\scrb.c]
                          THUMB

                          AREA ||i.SCRB_Initialize||, CODE, READONLY, ALIGN=2

                  SCRB_Initialize PROC
;;;35     
;;;36     void SCRB_Initialize(void)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  b08c              SUB      sp,sp,#0x30
;;;38     	/*
;;;39     	 * Trim Code Read and Write
;;;40     	 */
;;;41     	{
;;;42     #if 0 /* Old Trim Code */
;;;43     		unsigned * saddr;
;;;44     		unsigned int Trimdata = 0;
;;;45     
;;;46     		FLASH->FACR.tBit.LATENCY = 0x6;
;;;47     		FLASH->FUSRCTRL.tBit.ECC_EN = 0x1;
;;;48     
;;;49     		saddr = (unsigned *)0x00020088;
;;;50     		Trimdata = *saddr;
;;;51     		SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VREF_TRIM = (Trimdata>>5) & 0xF;
;;;52     		SCRB->SYS_ANA_TRIM.tBit.R_MAIN_IREF_TRIM = Trimdata & 0x1F;
;;;53     
;;;54     		saddr = (unsigned *)0x00020084;
;;;55     		Trimdata = *saddr;
;;;56     		SCRB->SYS_ANA_TRIM.tBit.R_LDO_TRIM = Trimdata & 0x1F;
;;;57     
;;;58     		saddr = (unsigned *)0x00020080;
;;;59     		Trimdata = *saddr;
;;;60     		SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_ITRIM = (Trimdata>>6) & 0x7;
;;;61     		SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_VTRIM = Trimdata & 0x3F;
;;;62     
;;;63     		FLASH->FUSRCTRL.tBit.ECC_EN = 0x3;
;;;64     		FLASH->FACR.tBit.LATENCY = 0x6;
;;;65     #else
;;;66     		tFlashPTTrimCodeInfo_t PTTrimCodeInfo = {0,};
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;67     
;;;68     		// Flash access latency - Must do
;;;69     		FLASH->FACR.tBit.LATENCY = 0x6;			// flash access latency, must be over 6
000008  4eb3              LDR      r6,|L1.728|
00000a  9501              STR      r5,[sp,#4]            ;66
00000c  9502              STR      r5,[sp,#8]            ;66
00000e  9503              STR      r5,[sp,#0xc]          ;66
000010  9504              STR      r5,[sp,#0x10]         ;66
000012  9505              STR      r5,[sp,#0x14]         ;66
000014  9506              STR      r5,[sp,#0x18]         ;66
000016  9507              STR      r5,[sp,#0x1c]         ;66
000018  9508              STR      r5,[sp,#0x20]         ;66
00001a  9509              STR      r5,[sp,#0x24]         ;66
00001c  950a              STR      r5,[sp,#0x28]
00001e  6830              LDR      r0,[r6,#0]
000020  f020000f          BIC      r0,r0,#0xf
000024  1d80              ADDS     r0,r0,#6
000026  6030              STR      r0,[r6,#0]
;;;70     
;;;71     		SCRB->SYS_OSC_PD_CTL.ulBulk = 0x7;		// for BOD Control
000028  2007              MOVS     r0,#7
00002a  03f4              LSLS     r4,r6,#15
00002c  62a0              STR      r0,[r4,#0x28]
;;;72     
;;;73     		// Analog Trim setting - Must do
;;;74     		FLASH->FUSRCTRL.tBit.ECC_EN = 0x1;		//	ECC OFF
00002e  f8d601d0          LDR      r0,[r6,#0x1d0]
000032  f0400002          ORR      r0,r0,#2
000036  f8c601d0          STR      r0,[r6,#0x1d0]
;;;75     
;;;76     		if(FLITF_CheckTrimInfoSectionIntegrity(&PTTrimCodeInfo))
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       FLITF_CheckTrimInfoSectionIntegrity
000040  b318              CBZ      r0,|L1.138|
;;;77     		{
;;;78     			SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_VTRIM = PTTrimCodeInfo.tTrim1.R_OSC12M_VTRIM;
000042  f89d0014          LDRB     r0,[sp,#0x14]
000046  6ae1              LDR      r1,[r4,#0x2c]
000048  f3600105          BFI      r1,r0,#0,#6
00004c  62e1              STR      r1,[r4,#0x2c]
;;;79     			SCRB->SYS_ANA_TRIM.tBit.R_OSC12M_ITRIM = PTTrimCodeInfo.tTrim1.R_OSC12M_ITRIM;
00004e  f8bd0014          LDRH     r0,[sp,#0x14]
000052  0981              LSRS     r1,r0,#6
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  f3611088          BFI      r0,r1,#6,#3
00005a  62e0              STR      r0,[r4,#0x2c]
;;;80     			SCRB->SYS_ANA_TRIM.tBit.R_LDO_TRIM = PTTrimCodeInfo.tTrim2.R_LDO_TRIM;
00005c  f89d0018          LDRB     r0,[sp,#0x18]
000060  6ae1              LDR      r1,[r4,#0x2c]
000062  f360214d          BFI      r1,r0,#9,#5
000066  62e1              STR      r1,[r4,#0x2c]
;;;81     			SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VBGR_CTL = PTTrimCodeInfo.tTrim3.R_MAIN_VBGR_CTL;		//	New Added.
000068  f89d001c          LDRB     r0,[sp,#0x1c]
00006c  6ae1              LDR      r1,[r4,#0x2c]
00006e  f3604112          BFI      r1,r0,#16,#3
000072  62e1              STR      r1,[r4,#0x2c]
;;;82     			SCRB->SYS_ANA_TRIM.tBit.R_MAIN_IREF_TRIM = PTTrimCodeInfo.tTrim3.R_MAIN_IREF_TRIM;
000074  08c1              LSRS     r1,r0,#3
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  f36140d7          BFI      r0,r1,#19,#5
00007c  62e0              STR      r0,[r4,#0x2c]
;;;83     			SCRB->SYS_ANA_TRIM.tBit.R_MAIN_VREF_TRIM = PTTrimCodeInfo.tTrim3.R_MAIN_VREF_TRIM;
00007e  f89d101d          LDRB     r1,[sp,#0x1d]
000082  6ae0              LDR      r0,[r4,#0x2c]
000084  f361601b          BFI      r0,r1,#24,#4
000088  62e0              STR      r0,[r4,#0x2c]
                  |L1.138|
;;;84     		}
;;;85     #ifdef _USE_WITH_BOOT_
;;;86     	#if USED_TRIMCODE_UPDATE_SECURITY_FUNC
;;;87     		else
;;;88     		{
;;;89     			tSimpleBootFlashCtrlInfo_t * pSimpleBootFlashCtrlInfo = (tSimpleBootFlashCtrlInfo_t *)SRAM_SIMPLE_BOOT_CTRL_INFO_ADDR;
;;;90     			pSimpleBootFlashCtrlInfo->ulFlashUpdateType = SIMPLE_BOOT_FLASH_UPDATE_TRIM_CODE_WRITE;
;;;91     			{
;;;92     				/*
;;;93     				 * PT Trim Code Update
;;;94     				 */
;;;95     				memset((void *)&pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo, 0x0, sizeof(tFlashPTTrimCodeInfo_t));
;;;96     				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.ulMagicCode = EFLASH_PT_MAGIC_CODE;
;;;97     
;;;98     				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_VTRIM = 0xA;
;;;99     				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim1.R_OSC12M_ITRIM = 0x7;
;;;100    
;;;101    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim2.R_LDO_TRIM = 0x11;
;;;102    
;;;103    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VBGR_CTL = 0x4;
;;;104    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_IREF_TRIM = 0xF;
;;;105    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.tTrim3.R_MAIN_VREF_TRIM = 0xC;
;;;106    
;;;107    				pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo.CheckSum = FLITF_Calc32bitCheckSum((uint32_t *)&pSimpleBootFlashCtrlInfo->tFlashPTTrimCodeInfo, EFLASH_ANALOG_TRIM_PT_INFO_WORD_SIZE-1);
;;;108    			}
;;;109    
;;;110    			{
;;;111    				/*
;;;112    				 * FT Trim Code Update
;;;113    				 */
;;;114    				memset((void *)&pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo, 0x0, sizeof(tFlashFTTrimCodeInfo_t));
;;;115    
;;;116    				pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo.CHIP_ID_ECC = EFLASH_FT_CHIP_ID_CODE;
;;;117    
;;;118    				pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo.CheckSum = FLITF_Calc32bitCheckSum((uint32_t *)&pSimpleBootFlashCtrlInfo->tFlashFTTrimCodeInfo, EFLASH_ANALOG_TRIM_FT_INFO_WORD_SIZE-1);
;;;119    			}
;;;120    
;;;121    			FLITF_FlashInformationRegionWriteOperation();
;;;122    		}
;;;123    	#endif /* USED_TRIMCODE_UPDATE_SECURITY_FUNC */
;;;124    #endif /* _USE_WITH_BOOT_ */
;;;125    
;;;126    		// Analog Trim setting - Must do
;;;127    		FLASH->FUSRCTRL.tBit.ECC_EN = 0x3;		//	ECC ON
00008a  f8d601d0          LDR      r0,[r6,#0x1d0]
00008e  f0400002          ORR      r0,r0,#2
000092  f8c601d0          STR      r0,[r6,#0x1d0]
;;;128    		// Flash access latency - Must do
;;;129    		FLASH->FACR.tBit.LATENCY = 0x6;			// flash access latency, must be over 6
000096  6830              LDR      r0,[r6,#0]
000098  f020000f          BIC      r0,r0,#0xf
00009c  1d80              ADDS     r0,r0,#6
00009e  6030              STR      r0,[r6,#0]
;;;130    #endif
;;;131    	}
;;;132    
;;;133    	/*
;;;134    	 * ECLK OFF시키자!! Default가 Enable이라 PLL On되면 ECLK바로 구동 되어 버림!!
;;;135    	 */
;;;136    	PWMDRV->ECLK_CR.tBit.eclk_force_on = 0;
0000a0  488e              LDR      r0,|L1.732|
0000a2  f8501f8c          LDR      r1,[r0,#0x8c]!
0000a6  f4217100          BIC      r1,r1,#0x200
0000aa  6001              STR      r1,[r0,#0]
;;;137    	PWMDRV->ECLK_CR.tBit.eclk_en = 0;
0000ac  6801              LDR      r1,[r0,#0]
0000ae  f0210101          BIC      r1,r1,#1
0000b2  6001              STR      r1,[r0,#0]
;;;138    
;;;139    	{
;;;140    		tSYS_CLK_CTL _SYS_CLK_CTL;
;;;141    		_SYS_CLK_CTL.tBit.wdtclk_en = YES;
;;;142    		_SYS_CLK_CTL.tBit.timclk0_en = YES;
;;;143    		_SYS_CLK_CTL.tBit.timclk1_en = YES;
;;;144    		_SYS_CLK_CTL.tBit.timclk2_en = YES;
;;;145    		_SYS_CLK_CTL.tBit.timclk3_en = YES;
;;;146    		_SYS_CLK_CTL.tBit.i2cclk_en = YES;//YES;
;;;147    		_SYS_CLK_CTL.tBit.dspaclk_en = YES;
;;;148    		_SYS_CLK_CTL.tBit.tdspclk_en = YES;
;;;149    #ifdef MODE_I2C
;;;150    		_SYS_CLK_CTL.tBit.usbcclk_en = NO;
;;;151    		_SYS_CLK_CTL.tBit.usbhclk_en = NO;
;;;152    #else /* MODE_I2C */
;;;153    		_SYS_CLK_CTL.tBit.usbcclk_en = YES;
;;;154    		_SYS_CLK_CTL.tBit.usbhclk_en = YES;
;;;155    #endif /* MODE_I2C */
;;;156    		_SYS_CLK_CTL.tBit.pwmclk_en = YES;
;;;157    		_SYS_CLK_CTL.tBit.mspiclk_en = YES;
;;;158    		_SYS_CLK_CTL.tBit.sscgclk_en = YES;
;;;159    		_SYS_CLK_CTL.tBit.mpiclk_en = NO;
0000b4  9800              LDR      r0,[sp,#0]
0000b6  f4202006          BIC      r0,r0,#0x86000
;;;160    		_SYS_CLK_CTL.tBit.tlvclk_en = NO;
;;;161    		_SYS_CLK_CTL.tBit.i2cm0clk_en = YES;
;;;162    		_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = YES;
;;;163    		_SYS_CLK_CTL.tBit.i2cm1clk_en = YES;
;;;164    		_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = YES;
0000ba  f04000ff          ORR      r0,r0,#0xff
;;;165    		_SYS_CLK_CTL.tBit.osc_deglitch_en = NO;
0000be  f440401f          ORR      r0,r0,#0x9f00
0000c2  f44020e0          ORR      r0,r0,#0x70000
;;;166    		SCRB->SYS_CLK_CTL.ulBulk = _SYS_CLK_CTL.ulBulk;
0000c6  9000              STR      r0,[sp,#0]
0000c8  9800              LDR      r0,[sp,#0]
0000ca  60a0              STR      r0,[r4,#8]
;;;167    
;;;168    	    SCRB->SYS_RST_CTL.ulBulk = 0x00; /* all release */
0000cc  60e5              STR      r5,[r4,#0xc]
;;;169    	    WDT->WDOG_RSTCLR = 1; // watchdog interrupt status clear
0000ce  2001              MOVS     r0,#1
0000d0  f8c4018c          STR      r0,[r4,#0x18c]
;;;170    
;;;171    	    SCB->SHCSR |= (7 << 16);
0000d4  4882              LDR      r0,|L1.736|
0000d6  6801              LDR      r1,[r0,#0]
0000d8  f44121e0          ORR      r1,r1,#0x70000
0000dc  6001              STR      r1,[r0,#0]
;;;172    	    SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
0000de  4981              LDR      r1,|L1.740|
0000e0  2004              MOVS     r0,#4
0000e2  6008              STR      r0,[r1,#0]
;;;173    	}
;;;174    
;;;175    	{
;;;176    		/*
;;;177    		 * USB POR set
;;;178    		 */
;;;179    		tUSB_PHY_FC USB_PHY;
;;;180    		USB_PHY.ulBulk = SCRB->USB_PHY_FC.ulBulk;
0000e4  f8d400a8          LDR      r0,[r4,#0xa8]
0000e8  9000              STR      r0,[sp,#0]
;;;181    #if (USED_ROIC_DEF == ROIC_SW98500)
;;;182    		USB_PHY.tBit.pllaliv = 1;
;;;183    #else /* (USED_ROIC_DEF == ROIC_SW98500) */
;;;184    		USB_PHY.tBit.pllaliv = 0;
0000ea  f0200008          BIC      r0,r0,#8
;;;185    #endif /* (USED_ROIC_DEF == ROIC_SW98500) */
;;;186    
;;;187    #ifdef MODE_I2C
;;;188    		USB_PHY.tBit.ponrst = 0;
;;;189    #else /* MODE_I2C */
;;;190    		USB_PHY.tBit.ponrst = 1;
0000ee  f0400010          ORR      r0,r0,#0x10
;;;191    #endif /* MODE_I2C */
;;;192    		SCRB->USB_PHY_FC.ulBulk = USB_PHY.ulBulk;
0000f2  9000              STR      r0,[sp,#0]
0000f4  9800              LDR      r0,[sp,#0]
0000f6  f8c400a8          STR      r0,[r4,#0xa8]
;;;193    //		SCRB->USB_PHY_FC.ulBulk = 0x31B;		// USB POR ON, USB should be worked after 3msec with this setting.
;;;194    
;;;195    		medium_delay(3000);
0000fa  f64030b8          MOV      r0,#0xbb8
0000fe  f7fffffe          BL       medium_delay
;;;196    		/*
;;;197    		 * Internal OSC use (12MHz) - Default.
;;;198    		 */
;;;199    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	//	main system clk: 12MHz, default: 0
000102  6e20              LDR      r0,[r4,#0x60]
000104  f0200001          BIC      r0,r0,#1
000108  6620              STR      r0,[r4,#0x60]
;;;200    		/*
;;;201    		 * MCLK freq. setting
;;;202    		 */
;;;203    		SCRB->SYS_MAINCLK_CFG.tBit.mclksel = 0;	// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)		//	0: internal OSC, 1: External Crystal
00010a  6e20              LDR      r0,[r4,#0x60]
00010c  f4203080          BIC      r0,r0,#0x10000
000110  6620              STR      r0,[r4,#0x60]
;;;204    		SCRB->SYS_MAINCLK_CFG.tBit.mclkdiv = 15;	// WATCHDOG_BASE_ADDR & timer clock. OSC freq./(mclkdiv+1)    ( default: 12)
000112  6e20              LDR      r0,[r4,#0x60]
000114  f420407c          BIC      r0,r0,#0xfc00
000118  f5005070          ADD      r0,r0,#0x3c00
00011c  6620              STR      r0,[r4,#0x60]
;;;205    
;;;206    		/*
;;;207    		 * Cache Control
;;;208    		 */
;;;209    		SCRB->CACHE_CTRL.tBit.CACHE_EN = 0;	// 1: ENABLE. 0 : disable
00011e  f8d40090          LDR      r0,[r4,#0x90]
000122  f0200001          BIC      r0,r0,#1
000126  f8c40090          STR      r0,[r4,#0x90]
;;;210    		while(SCRB->CACHE_ST != 1)
00012a  bf00              NOP      
                  |L1.300|
00012c  f8d40094          LDR      r0,[r4,#0x94]
000130  2801              CMP      r0,#1
000132  d1fb              BNE      |L1.300|
;;;211    		{
;;;212    			;
;;;213    		}
;;;214    		SCRB->CACHE_CTRL.tBit.CACHE_FLUSH = 0;
000134  f8d40090          LDR      r0,[r4,#0x90]
000138  f0200002          BIC      r0,r0,#2
00013c  f8c40090          STR      r0,[r4,#0x90]
;;;215    		SCRB->CACHE_CTRL.tBit.CACHE_FLUSH = 1;
000140  f8d40090          LDR      r0,[r4,#0x90]
000144  f0400002          ORR      r0,r0,#2
000148  f8c40090          STR      r0,[r4,#0x90]
;;;216    		SCRB->CACHE_CTRL.tBit.CACHE_FLUSH = 0;
00014c  f8d40090          LDR      r0,[r4,#0x90]
000150  f0200002          BIC      r0,r0,#2
000154  f8c40090          STR      r0,[r4,#0x90]
;;;217    
;;;218    		SCRB->CACHE_CTRL.tBit.CACHE_BST = 3;	// burst 8
000158  f8d40090          LDR      r0,[r4,#0x90]
00015c  f040000c          ORR      r0,r0,#0xc
000160  f8c40090          STR      r0,[r4,#0x90]
;;;219    		SCRB->CACHE_CTRL.tBit.CACHE_DEN = 0;//1;	// data enable
000164  f8d40090          LDR      r0,[r4,#0x90]
000168  f0200010          BIC      r0,r0,#0x10
00016c  f8c40090          STR      r0,[r4,#0x90]
;;;220    		SCRB->CACHE_CTRL.tBit.CACHE_EN = 1;	// 1: ENABLE. 0 : disable
000170  f8d40090          LDR      r0,[r4,#0x90]
000174  f0400001          ORR      r0,r0,#1
000178  f8c40090          STR      r0,[r4,#0x90]
;;;221    	}
;;;222    
;;;223    	{
;;;224    //#if DEF_USB480MHz_NOT_USED
;;;225    
;;;226    	#if USED_SPI_NBIT_TRANSMODE
;;;227    		/*
;;;228    		 * PLL Power On
;;;229    		 * 	- VCO range : 150 < (Fin*N)/M < 300 ==> MUST BE !!     // Fin: input clk
;;;230    		 * 	- PLL clock = (Fin*N)/(M*O)
;;;231    		 */
;;;232    #define PLL_RSEL_MAX			(5)
;;;233    #define PLL_RECOVERY_CNT		(870)	//	870: about 1ms  @12MHz
;;;234    		uint8_t ucRselIdx = 0;
;;;235    		uint8_t vucRselValue[PLL_RSEL_MAX] = {3, 2, 1, 0, 4};
;;;236    		uint32_t ulPllLockCnt = 0;
;;;237    
;;;238    		SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
;;;239    
;;;240    		SCRB->PLL_CFG.tBit.rsel = 4;
;;;241    
;;;242    		SCRB->PLL_CFG.tBit.pllin_sel = 1;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
;;;243    		SCRB->PLL_CFG.tBit.refdiv = 1;//1;		// M = refdiv+1
;;;244    		SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;245    
;;;246    		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;247    	//		SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  96MHz		//	feedback divider
;;;248    			SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;249    	//		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;250    		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;251    			SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  288MHz		//	feedback divider
;;;252    		#endif
;;;253    
;;;254    		SCRB->PLL_CFG.tBit.pll_stby_i = 0;	// PLL power on
;;;255    		while (!SCRB->PLL_LOCK)				// Wait Lock
;;;256    		{
;;;257    			ulPllLockCnt++;
;;;258    
;;;259    			if (ulPllLockCnt > PLL_RECOVERY_CNT)
;;;260    			{
;;;261    				SCRB->PLL_CFG.tBit.rsel = vucRselValue[ucRselIdx++];		//	rsel update
;;;262    				ulPllLockCnt = 0;
;;;263    
;;;264    				if (ucRselIdx >= PLL_RSEL_MAX)
;;;265    					ucRselIdx = 0;
;;;266    			}
;;;267    		}
;;;268    
;;;269    		/*
;;;270    		 * Change PLL clock
;;;271    		 */
;;;272    		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 1;//0;//1;//0;		// PLL clock divider. PLLCLK/(pllclkdiv+1)
;;;273    		SCRB->SYS_MAINCLK_CFG.tBit.usbclkdiv = 4;		// USB480 clock divider. 480MHz/(usbclkdiv+1)
;;;274    		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;275    			SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 1;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;276    		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;277    			SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;278    		#endif
;;;279    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	// 0: INT OSC 1: PLL/USB clock
;;;280    	#else /* USED_SPI_NBIT_TRANSMODE */
;;;281    		/*
;;;282    		 * PLL Power On
;;;283    		 * 	- VCO range : 150 < (Fin*N)/M < 300 ==> MUST BE !!     // Fin: input clk
;;;284    		 * 	- PLL clock = (Fin*N)/(M*O)
;;;285    		 */
;;;286    #define PLL_RSEL_MAX			(5)
;;;287    #define PLL_RECOVERY_CNT		(870)	//	870: about 1ms  @12MHz
;;;288    		uint8_t ucRselIdx = 0;
;;;289    		uint8_t vucRselValue[PLL_RSEL_MAX] = {3, 2, 1, 0, 4};
00017c  a25a              ADR      r2,|L1.744|
00017e  2000              MOVS     r0,#0                 ;288
000180  e9d21200          LDRD     r1,r2,[r2,#0]
000184  e9cd1200          STRD     r1,r2,[sp,#0]
;;;290    		uint32_t ulPllLockCnt = 0;
;;;291    
;;;292    		SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
000188  6fa1              LDR      r1,[r4,#0x78]
00018a  f4415100          ORR      r1,r1,#0x2000
00018e  67a1              STR      r1,[r4,#0x78]
;;;293    
;;;294    		SCRB->PLL_CFG.tBit.rsel = 4;
000190  6fa1              LDR      r1,[r4,#0x78]
000192  f42131e0          BIC      r1,r1,#0x1c000
000196  f5013180          ADD      r1,r1,#0x10000
00019a  67a1              STR      r1,[r4,#0x78]
;;;295    
;;;296    		SCRB->PLL_CFG.tBit.pllin_sel = 1;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
00019c  6fa1              LDR      r1,[r4,#0x78]
00019e  f4412180          ORR      r1,r1,#0x40000
0001a2  67a1              STR      r1,[r4,#0x78]
;;;297    		SCRB->PLL_CFG.tBit.refdiv = 0;//1;		// M = refdiv+1
0001a4  6fa1              LDR      r1,[r4,#0x78]
0001a6  f0210107          BIC      r1,r1,#7
0001aa  67a1              STR      r1,[r4,#0x78]
;;;298    		SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
0001ac  6fa1              LDR      r1,[r4,#0x78]
0001ae  f42161c0          BIC      r1,r1,#0x600
0001b2  67a1              STR      r1,[r4,#0x78]
;;;299    
;;;300    		SCRB->PLL_CFG.tBit.fbdiv = 16;		// N = fbdiv (>5).  96MHz		//	feedback divider
0001b4  6fa1              LDR      r1,[r4,#0x78]
0001b6  f42171fc          BIC      r1,r1,#0x1f8
0001ba  3180              ADDS     r1,r1,#0x80
0001bc  67a1              STR      r1,[r4,#0x78]
;;;301    //		SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;302    //		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;303    
;;;304    		SCRB->PLL_CFG.tBit.pll_stby_i = 0;	// PLL power on
0001be  6fa1              LDR      r1,[r4,#0x78]
0001c0  f4215100          BIC      r1,r1,#0x2000
0001c4  67a1              STR      r1,[r4,#0x78]
;;;305    		while (!SCRB->PLL_LOCK)				// Wait Lock
0001c6  6fe1              LDR      r1,[r4,#0x7c]
0001c8  b9a1              CBNZ     r1,|L1.500|
0001ca  e080              B        |L1.718|
                  |L1.460|
0001cc  1c49              ADDS     r1,r1,#1
;;;306    		{
;;;307    			ulPllLockCnt++;
;;;308    
;;;309    			if (ulPllLockCnt > PLL_RECOVERY_CNT)
0001ce  428a              CMP      r2,r1
0001d0  d20b              BCS      |L1.490|
;;;310    			{
;;;311    				SCRB->PLL_CFG.tBit.rsel = vucRselValue[ucRselIdx++];		//	rsel update
0001d2  f813c000          LDRB     r12,[r3,r0]
0001d6  1c40              ADDS     r0,r0,#1
0001d8  6fa1              LDR      r1,[r4,#0x78]
0001da  b2c0              UXTB     r0,r0
0001dc  f36c3190          BFI      r1,r12,#14,#3
0001e0  67a1              STR      r1,[r4,#0x78]
;;;312    				ulPllLockCnt = 0;
0001e2  2100              MOVS     r1,#0
;;;313    
;;;314    				if (ucRselIdx >= PLL_RSEL_MAX)
0001e4  2805              CMP      r0,#5
;;;315    					ucRselIdx = 0;
0001e6  bf28              IT       CS
0001e8  2000              MOVCS    r0,#0
                  |L1.490|
0001ea  f8d4c07c          LDR      r12,[r4,#0x7c]        ;305
0001ee  f1bc0f00          CMP      r12,#0                ;305
0001f2  d0eb              BEQ      |L1.460|
                  |L1.500|
;;;316    			}
;;;317    		}
;;;318    
;;;319    		/*
;;;320    		 * Change PLL clock
;;;321    		 */
;;;322    		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 1;//1;//0;		// PLL clock divider. PLLCLK/(pllclkdiv+1)
0001f4  6e20              LDR      r0,[r4,#0x60]
0001f6  f020003c          BIC      r0,r0,#0x3c
0001fa  1d00              ADDS     r0,r0,#4
0001fc  6620              STR      r0,[r4,#0x60]
;;;323    		SCRB->SYS_MAINCLK_CFG.tBit.usbclkdiv = 4;		// USB480 clock divider. 480MHz/(usbclkdiv+1)
0001fe  6e20              LDR      r0,[r4,#0x60]
000200  f4207070          BIC      r0,r0,#0x3c0
000204  f5007080          ADD      r0,r0,#0x100
000208  6620              STR      r0,[r4,#0x60]
;;;324    		SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
00020a  6e20              LDR      r0,[r4,#0x60]
00020c  f0200002          BIC      r0,r0,#2
000210  6620              STR      r0,[r4,#0x60]
;;;325    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	// 0: INT OSC 1: PLL/USB clock
000212  6e20              LDR      r0,[r4,#0x60]
000214  f0200001          BIC      r0,r0,#1
000218  6620              STR      r0,[r4,#0x60]
;;;326    	#endif /* USED_SPI_NBIT_TRANSMODE */
;;;327    //#else /* DEF_USB480MHz_NOT_USED */
;;;328    //		/*
;;;329    //		 * PLL Power On
;;;330    //		 * 	- VCO range : 150 < (Fin*N)/M < 300 ==> MUST BE !!     // Fin: input clk
;;;331    //		 * 	- PLL clock = (Fin*N)/(M*O)
;;;332    //		 */
;;;333    //		SCRB->PLL_CFG.tBit.pllin_sel = 1;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
;;;334    //		SCRB->PLL_CFG.tBit.refdiv = 1;		// M = refdiv+1
;;;335    //		SCRB->PLL_CFG.tBit.outdiv = 1;		// O = 0:1, 1:2, 2:4, 3:8
;;;336    //
;;;337    //	#if USED_SPI_NBIT_TRANSMODE
;;;338    //		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;339    //	//		SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  96MHz		//	feedback divider
;;;340    //			SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;341    //	//		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;342    //		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;343    //			SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  96MHz		//	feedback divider
;;;344    //	//		SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;345    //	//		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;346    //		#endif
;;;347    //
;;;348    //		SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
;;;349    //		SCRB->PLL_CFG.tBit.pll_stby_i = 0;	// PLL power on
;;;350    //		while (!SCRB->PLL_LOCK);				// Wait Lock
;;;351    //
;;;352    //		/*
;;;353    //		 * Change PLL clock
;;;354    //		 */
;;;355    //		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 0;//1;//0;		// PLL clock divider. PLLCLK/(pllclkdiv+1)
;;;356    //		SCRB->SYS_MAINCLK_CFG.tBit.usbclkdiv = 4;		// USB480 clock divider. 480MHz/(usbclkdiv+1)
;;;357    //		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;358    //			SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 1;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;359    //		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;360    //			SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;361    //		#endif
;;;362    //		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	// 0: INT OSC 1: PLL/USB clock
;;;363    //	#else /* USED_SPI_NBIT_TRANSMODE */
;;;364    //		SCRB->PLL_CFG.tBit.fbdiv = 32;		// N = fbdiv (>5).  96MHz		//	feedback divider
;;;365    ////		SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;366    ////		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;367    //
;;;368    //
;;;369    //		SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
;;;370    //		SCRB->PLL_CFG.tBit.pll_stby_i = 0;	// PLL power on
;;;371    //		while (!SCRB->PLL_LOCK);				// Wait Lock
;;;372    //
;;;373    //		/*
;;;374    //		 * Change PLL clock
;;;375    //		 */
;;;376    //		SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 0;//1;//0;		// PLL clock divider. PLLCLK/(pllclkdiv+1)
;;;377    //		SCRB->SYS_MAINCLK_CFG.tBit.usbclkdiv = 4;		// USB480 clock divider. 480MHz/(usbclkdiv+1)
;;;378    //		SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;379    //		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	// 0: INT OSC 1: PLL/USB clock
;;;380    //	#endif /* USED_SPI_NBIT_TRANSMODE */
;;;381    //#endif /* DEF_USB480MHz_NOT_USED */
;;;382    	}
;;;383    
;;;384    	{
;;;385    //#if DEF_USB480MHz_NOT_USED
;;;386    		/*
;;;387    		 * SSCG control : SSCG input range - 40MHz~50MHz
;;;388    		 */
;;;389    	#if (USED_ROIC_DEF == ROIC_SW98500)
;;;390    		#if USED_SPI_NBIT_TRANSMODE
;;;391    			SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 2;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;392    			#if (SPI_TRANSFER_BIT_NUM == 10) // SPI 18MHz
;;;393    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 5;//7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;394    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;395    			#elif (SPI_TRANSFER_BIT_NUM == 11) // SPI 20MHz
;;;396    				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;397    				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;//1;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;398    			#endif
;;;399    			SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
;;;400    
;;;401    			SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 0;	// SSCG power on
;;;402    			medium_delay(300);						// You need stable time
;;;403    
;;;404    			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
;;;405    			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
;;;406    			SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 0;	// SSCG operation start
;;;407    
;;;408    			SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;409    			SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
;;;410    		#else /* USED_SPI_NBIT_TRANSMODE */
;;;411    			SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;412    			SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 9;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;413    			SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;414    			SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
;;;415    
;;;416    			SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
;;;417    			medium_delay(300);							// You need stable time
;;;418    
;;;419    			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
;;;420    			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
;;;421    			SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 1;		// SSCG operation start
;;;422    
;;;423    			SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;424    			SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
;;;425    		#endif /* USED_SPI_NBIT_TRANSMODE */
;;;426    	#else /* (USED_ROIC_DEF == ROIC_SW98500) */
;;;427    		SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 3;//1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
00021a  6ea0              LDR      r0,[r4,#0x68]
00021c  f020001c          BIC      r0,r0,#0x1c
000220  300c              ADDS     r0,r0,#0xc
000222  66a0              STR      r0,[r4,#0x68]
;;;428    		SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 9;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
000224  6ea0              LDR      r0,[r4,#0x68]
000226  f42070f0          BIC      r0,r0,#0x1e0
00022a  f5007090          ADD      r0,r0,#0x120
00022e  66a0              STR      r0,[r4,#0x68]
;;;429    		SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
000230  6ea0              LDR      r0,[r4,#0x68]
000232  f0200001          BIC      r0,r0,#1
000236  66a0              STR      r0,[r4,#0x68]
;;;430    		SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
000238  6ea0              LDR      r0,[r4,#0x68]
00023a  f0200002          BIC      r0,r0,#2
00023e  66a0              STR      r0,[r4,#0x68]
;;;431    
;;;432    #if (USED_ROIC_DEF == ROIC_SW97500)
;;;433    	#if USED_SSCG_ON_OFF_CONTORL_AITnTLP_MODE
;;;434    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
;;;435    	#else
;;;436    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 0;	// SSCG power on
000240  6ce0              LDR      r0,[r4,#0x4c]
000242  f0200002          BIC      r0,r0,#2
000246  64e0              STR      r0,[r4,#0x4c]
;;;437    	#endif
;;;438    #else
;;;439    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
;;;440    #endif
;;;441    		medium_delay(300);							// You need stable time
000248  f44f7096          MOV      r0,#0x12c
00024c  f7fffffe          BL       medium_delay
;;;442    
;;;443    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
000250  6d20              LDR      r0,[r4,#0x50]
000252  f4406040          ORR      r0,r0,#0xc00
000256  6520              STR      r0,[r4,#0x50]
;;;444    		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
000258  6d20              LDR      r0,[r4,#0x50]
00025a  f44040e0          ORR      r0,r0,#0x7000
00025e  6520              STR      r0,[r4,#0x50]
;;;445    		SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 1;		// SSCG operation start
000260  6ce0              LDR      r0,[r4,#0x4c]
000262  f0400001          ORR      r0,r0,#1
000266  64e0              STR      r0,[r4,#0x4c]
;;;446    
;;;447    #if (USED_ROIC_DEF == ROIC_SW97500)
;;;448    		SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
000268  6ea0              LDR      r0,[r4,#0x68]
00026a  f4207000          BIC      r0,r0,#0x200
00026e  66a0              STR      r0,[r4,#0x68]
;;;449    #else
;;;450    		SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 1;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;451    #endif
;;;452    		SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
000270  6d20              LDR      r0,[r4,#0x50]
000272  f4403080          ORR      r0,r0,#0x10000
000276  6520              STR      r0,[r4,#0x50]
;;;453    	#endif /* (USED_ROIC_DEF == ROIC_SW98500) */
;;;454    //#else /* DEF_USB480MHz_NOT_USED */
;;;455    //		/*
;;;456    //		 * SSCG control : SSCG input range - 40MHz~50MHz
;;;457    //		 */
;;;458    //	#if (USED_ROIC_DEF == ROIC_SW98500)
;;;459    //		#if USED_SPI_NBIT_TRANSMODE
;;;460    //			SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;461    //			#if (SPI_TRANSFER_BIT_NUM == 10) // SPI 18MHz
;;;462    //				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 5;//7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;463    //				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;464    //			#elif (SPI_TRANSFER_BIT_NUM == 11) // SPI 20MHz
;;;465    //				SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 7;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;466    //				SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 1;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;467    //			#endif
;;;468    //			SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
;;;469    //
;;;470    //			SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 0;	// SSCG power on
;;;471    //			medium_delay(300);						// You need stable time
;;;472    //
;;;473    //			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
;;;474    //			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
;;;475    //			SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 0;	// SSCG operation start
;;;476    //
;;;477    //			SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;478    //			SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
;;;479    //		#else /* USED_SPI_NBIT_TRANSMODE */
;;;480    //			SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;481    //			SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 9;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;482    //			SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;483    //			SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
;;;484    //
;;;485    //			SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
;;;486    //			medium_delay(300);							// You need stable time
;;;487    //
;;;488    //			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
;;;489    //			SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
;;;490    //			SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 1;		// SSCG operation start
;;;491    //
;;;492    //			SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 0;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;493    //			SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
;;;494    //		#endif /* USED_SPI_NBIT_TRANSMODE */
;;;495    //	#else /* (USED_ROIC_DEF == ROIC_SW98500) */
;;;496    //#if (USED_ROIC_DEF == ROIC_SW97500)
;;;497    //		SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 2;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;498    //#else /* (USED_ROIC_DEF == ROIC_SW97500) */
;;;499    //		SCRB->SSCG_IN_CFG.tBit.sscgplldiv = 1; //1;	// PLLCLK_div. PLLCLK/(sscgplldiv+1)
;;;500    //#endif /* (USED_ROIC_DEF == ROIC_SW97500) */
;;;501    //		SCRB->SSCG_IN_CFG.tBit.sscgusbdiv = 9;	// USBCLK480_div. 480MHz/(sscgusbdiv+1) -> 48MHz input
;;;502    //		SCRB->SSCG_IN_CFG.tBit.sscgin_sel = 0;	// 0: PLLCLK_div, 1:USBCLK480_div
;;;503    //		SCRB->SSCG_IN_CFG.tBit.sscgin_inv = 0;
;;;504    //
;;;505    //		SCRB->SSCG_PD_CTL.tBit.R_DSSC_PDB = 1;	// SSCG power on
;;;506    //		medium_delay(300);							// You need stable time
;;;507    //
;;;508    //		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MF = 3;	// Modulation frequency (0~3)
;;;509    //		SCRB->SSCG_OP_CTRL.tBit.R_DSSC_MR = 7;	// Modulation ratio (0~7). 7:2%
;;;510    //		SCRB->SSCG_PD_CTL.tBit.R_DSSC_EN = 1;		// SSCG operation start
;;;511    //
;;;512    //		SCRB->SSCG_IN_CFG.tBit.sscgclk_sel = 1;	// SSCGCLK select. 0: no sscg, 1:sscg out
;;;513    //		SCRB->SSCG_OP_CTRL.tBit.modu_cnt_en = 1;	// SSCG modulation monitoring enable. monitor SSCG_MODU_CNT
;;;514    //	#endif /* (USED_ROIC_DEF == ROIC_SW98500) */
;;;515    //#endif /* DEF_USB480MHz_NOT_USED */
;;;516    	}
;;;517    
;;;518    	{
;;;519    //#if DEF_USB480MHz_NOT_USED
;;;520    		/*
;;;521    		 * PWM clock control
;;;522    		 */
;;;523    	#if USED_SPI_NBIT_TRANSMODE
;;;524    		SCRB->SYS_PWMCLK_CFG.tBit.pllclkdiv = 1;//0;	// PLLCLK_div. PLLCLK/(pllclkdiv+1)
;;;525    		SCRB->SYS_PWMCLK_CFG.tBit.usbclkdiv = 4;	// USBCLK480_div. 480MHz/(usbclkdiv+1) -> 96MHz input
;;;526    		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;527    			SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 1;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;528    		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;529    			SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 0;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;530    		#endif
;;;531    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv = 0;//1;	// PWM source clock divider - TSYNC sync. pre-PWMCLK/(pwmclkdiv+1) -> 96MHz
;;;532    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_num = 3;//1;	// PWMDRV_CLK - PWM/ECLK generation clock divide. pre-PWMLCK/(pwmclkdiv_num+1), 3: 12Mhz
;;;533    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclk_phase_en = 0;// ECLK to TSYNC sync enable
;;;534    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 1;	// PWMDRV_CLK - PWM/ECLK generation clock enable. -> 48MHz
;;;535    		SCRB->SYS_CLK_CTL.tBit.pwmclk_en = 1;	// PWMCLK on
;;;536    	#else /* USED_SPI_NBIT_TRANSMODE */
;;;537    		SCRB->SYS_PWMCLK_CFG.tBit.pllclkdiv = 1;//0;	// PLLCLK_div. PLLCLK/(pllclkdiv+1)
000278  6e60              LDR      r0,[r4,#0x64]
00027a  f02000f0          BIC      r0,r0,#0xf0
00027e  3010              ADDS     r0,r0,#0x10
000280  6660              STR      r0,[r4,#0x64]
;;;538    		SCRB->SYS_PWMCLK_CFG.tBit.usbclkdiv = 4;	// USBCLK480_div. 480MHz/(usbclkdiv+1) -> 96MHz input
000282  6e60              LDR      r0,[r4,#0x64]
000284  f4206070          BIC      r0,r0,#0xf00
000288  f5006080          ADD      r0,r0,#0x400
00028c  6660              STR      r0,[r4,#0x64]
;;;539    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 0;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
00028e  6e60              LDR      r0,[r4,#0x64]
000290  f0200001          BIC      r0,r0,#1
000294  6660              STR      r0,[r4,#0x64]
;;;540    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv = 0;//1;	// PWM source clock divider - TSYNC sync. pre-PWMCLK/(pwmclkdiv+1) -> 96MHz
000296  6e60              LDR      r0,[r4,#0x64]
000298  f020000e          BIC      r0,r0,#0xe
00029c  6660              STR      r0,[r4,#0x64]
;;;541    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_num = 3;//1;	// PWMDRV_CLK - PWM/ECLK generation clock divide. pre-PWMLCK/(pwmclkdiv_num+1), 3: 12Mhz
00029e  6e60              LDR      r0,[r4,#0x64]
0002a0  f4204060          BIC      r0,r0,#0xe000
0002a4  f50040c0          ADD      r0,r0,#0x6000
0002a8  6660              STR      r0,[r4,#0x64]
;;;542    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclk_phase_en = 0;// ECLK to TSYNC sync enable
0002aa  6e60              LDR      r0,[r4,#0x64]
0002ac  f4203080          BIC      r0,r0,#0x10000
0002b0  6660              STR      r0,[r4,#0x64]
;;;543    		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 1;	// PWMDRV_CLK - PWM/ECLK generation clock enable. -> 48MHz
0002b2  6e60              LDR      r0,[r4,#0x64]
0002b4  f4405080          ORR      r0,r0,#0x1000
0002b8  6660              STR      r0,[r4,#0x64]
;;;544    		SCRB->SYS_CLK_CTL.tBit.pwmclk_en = 1;	// PWMCLK on
0002ba  68a0              LDR      r0,[r4,#8]
0002bc  f4406080          ORR      r0,r0,#0x400
0002c0  60a0              STR      r0,[r4,#8]
;;;545    	#endif /* USED_SPI_NBIT_TRANSMODE */
;;;546    //#else /* DEF_USB480MHz_NOT_USED */
;;;547    //		/*
;;;548    //		 * PWM clock control
;;;549    //		 */
;;;550    //	#if USED_SPI_NBIT_TRANSMODE
;;;551    //		SCRB->SYS_PWMCLK_CFG.tBit.pllclkdiv = 0;	// PLLCLK_div. PLLCLK/(pllclkdiv+1)
;;;552    //		SCRB->SYS_PWMCLK_CFG.tBit.usbclkdiv = 4;	// USBCLK480_div. 480MHz/(usbclkdiv+1) -> 96MHz input
;;;553    //		#if (SPI_TRANSFER_BIT_NUM == 10)
;;;554    //			SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 1;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;555    //		#elif (SPI_TRANSFER_BIT_NUM == 11)
;;;556    //			SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 0;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;557    //		#endif
;;;558    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv = 0;//1;	// PWM source clock divider - TSYNC sync. pre-PWMCLK/(pwmclkdiv+1) -> 96MHz
;;;559    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_num = 3;//1;	// PWMDRV_CLK - PWM/ECLK generation clock divide. pre-PWMLCK/(pwmclkdiv_num+1), 3: 12Mhz
;;;560    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclk_phase_en = 0;// ECLK to TSYNC sync enable
;;;561    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 1;	// PWMDRV_CLK - PWM/ECLK generation clock enable. -> 48MHz
;;;562    //		SCRB->SYS_CLK_CTL.tBit.pwmclk_en = 1;	// PWMCLK on
;;;563    //	#else /* USED_SPI_NBIT_TRANSMODE */
;;;564    //		SCRB->SYS_PWMCLK_CFG.tBit.pllclkdiv = 0;	// PLLCLK_div. PLLCLK/(pllclkdiv+1)
;;;565    //		SCRB->SYS_PWMCLK_CFG.tBit.usbclkdiv = 4;	// USBCLK480_div. 480MHz/(usbclkdiv+1) -> 96MHz input
;;;566    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclksel = 0;	// pre-PWMCLK select. 0:PLLCLK_div, 1:USBCLK480_div
;;;567    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv = 0;//1;	// PWM source clock divider - TSYNC sync. pre-PWMCLK/(pwmclkdiv+1) -> 96MHz
;;;568    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_num = 3;//1;	// PWMDRV_CLK - PWM/ECLK generation clock divide. pre-PWMLCK/(pwmclkdiv_num+1), 3: 12Mhz
;;;569    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclk_phase_en = 0;// ECLK to TSYNC sync enable
;;;570    //		SCRB->SYS_PWMCLK_CFG.tBit.pwmclkdiv_en = 1;	// PWMDRV_CLK - PWM/ECLK generation clock enable. -> 48MHz
;;;571    //		SCRB->SYS_CLK_CTL.tBit.pwmclk_en = 1;	// PWMCLK on
;;;572    //	#endif /* USED_SPI_NBIT_TRANSMODE */
;;;573    //#endif /* DEF_USB480MHz_NOT_USED */
;;;574    	}
;;;575    
;;;576    	{
;;;577    		/*
;;;578    		 * Clock Enable
;;;579    		 */
;;;580    		SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		// 1: PLL clk enable
0002c2  6e20              LDR      r0,[r4,#0x60]
0002c4  f0400001          ORR      r0,r0,#1
0002c8  6620              STR      r0,[r4,#0x60]
;;;581    	}
;;;582    }
0002ca  b00c              ADD      sp,sp,#0x30
0002cc  bd70              POP      {r4-r6,pc}
                  |L1.718|
0002ce  2101              MOVS     r1,#1                 ;307
0002d0  f2403266          MOV      r2,#0x366             ;309
0002d4  466b              MOV      r3,sp                 ;289
0002d6  e788              B        |L1.490|
;;;583    
                          ENDP

                  |L1.728|
                          DCD      0x40008000
                  |L1.732|
                          DCD      0x40002000
                  |L1.736|
                          DCD      0xe000ed24
                  |L1.740|
                          DCD      0xe000ed10
                  |L1.744|
0002e8  03020100          DCB      3,2,1,0
0002ec  0400              DCB      4,0
0002ee  00                DCB      0
0002ef  00                DCB      0

                          AREA ||i.SCRB_PLL_Clock_Off||, CODE, READONLY, ALIGN=1

                  SCRB_PLL_Clock_Off PROC
;;;583    
;;;584    void SCRB_PLL_Clock_Off(void)
000000  b538              PUSH     {r3-r5,lr}
;;;585    {
;;;586    #if 0
;;;587    	/*
;;;588    	 * Clock Enable
;;;589    	 */
;;;590    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;		//	main system clk: 12MHz, default: 0
;;;591    
;;;592    //	/*
;;;593    //	 * MCLK freq. setting
;;;594    //	 */
;;;595    //	SCRB->SYS_MAINCLK_CFG.tBit.mclksel = 0;	// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)		//	0: internal OSC, 1: External Crystal
;;;596    //	SCRB->SYS_MAINCLK_CFG.tBit.mclkdiv = 15;	// WATCHDOG_BASE_ADDR & timer clock. OSC freq./(mclkdiv+1)    ( default: 12)
;;;597    
;;;598    	SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
;;;599    #else
;;;600    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;		//	main system clk: 12MHz, default: 0
000002  f04f4480          MOV      r4,#0x40000000
000006  6e20              LDR      r0,[r4,#0x60]
000008  f0200001          BIC      r0,r0,#1
00000c  6620              STR      r0,[r4,#0x60]
;;;601    	delay_usec(1);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       delay_us
;;;602    	/*
;;;603    	 * USB는 30M이상에서만 동작 하는 것을 확인
;;;604    	 * (5+1)6분주 적용 하여 192/6=32M로 구동시켜 야만 USB동작함. 그 이하는 동작 하지 않음
;;;605    	 */
;;;606    	SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 5;
000014  6e20              LDR      r0,[r4,#0x60]
000016  f020003c          BIC      r0,r0,#0x3c
00001a  3014              ADDS     r0,r0,#0x14
00001c  6620              STR      r0,[r4,#0x60]
;;;607    //	SCRB->SYS_MAINCLK_CFG.tBit.mclkdiv = 3;	// WATCHDOG_BASE_ADDR & timer clock. OSC freq./(mclkdiv+1)    ( default: 12)
;;;608    	delay_usec(1);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       delay_us
;;;609    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		//	main system clk: 12MHz, default: 0
000024  6e20              LDR      r0,[r4,#0x60]
000026  f0400001          ORR      r0,r0,#1
00002a  6620              STR      r0,[r4,#0x60]
;;;610    
;;;611    	tSYS_CLK_CTL _SYS_CLK_CTL;
;;;612    	_SYS_CLK_CTL.tBit.wdtclk_en = YES;
;;;613    	_SYS_CLK_CTL.tBit.timclk0_en = YES;
;;;614    	_SYS_CLK_CTL.tBit.timclk1_en = NO;
;;;615    	_SYS_CLK_CTL.tBit.timclk2_en = NO;
;;;616    	_SYS_CLK_CTL.tBit.timclk3_en = NO;
;;;617    	_SYS_CLK_CTL.tBit.i2cclk_en = YES;//YES;
;;;618    	_SYS_CLK_CTL.tBit.dspaclk_en = NO;
;;;619    	_SYS_CLK_CTL.tBit.tdspclk_en = NO;
;;;620    #ifdef MODE_I2C
;;;621    	_SYS_CLK_CTL.tBit.usbcclk_en = NO;
;;;622    	_SYS_CLK_CTL.tBit.usbhclk_en = NO;
;;;623    #else /* MODE_I2C */
;;;624    	_SYS_CLK_CTL.tBit.usbcclk_en = YES;
;;;625    	_SYS_CLK_CTL.tBit.usbhclk_en = YES;
;;;626    #endif /* MODE_I2C */
;;;627    	_SYS_CLK_CTL.tBit.pwmclk_en = NO;
;;;628    	_SYS_CLK_CTL.tBit.mspiclk_en = NO;
;;;629    	_SYS_CLK_CTL.tBit.sscgclk_en = NO;
00002c  9800              LDR      r0,[sp,#0]
00002e  f02000dc          BIC      r0,r0,#0xdc
000032  f42040f8          BIC      r0,r0,#0x7c00
;;;630    	_SYS_CLK_CTL.tBit.mpiclk_en = NO;
000036  f4202000          BIC      r0,r0,#0x80000
;;;631    	_SYS_CLK_CTL.tBit.tlvclk_en = NO;
;;;632    	_SYS_CLK_CTL.tBit.i2cm0clk_en = YES;
;;;633    	_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = YES;
;;;634    	_SYS_CLK_CTL.tBit.i2cm1clk_en = YES;
;;;635    	_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = YES;
00003a  f0400023          ORR      r0,r0,#0x23
;;;636    	_SYS_CLK_CTL.tBit.osc_deglitch_en = NO;
00003e  f4404003          ORR      r0,r0,#0x8300
000042  f44020e0          ORR      r0,r0,#0x70000
;;;637    	SCRB->SYS_CLK_CTL.ulBulk = _SYS_CLK_CTL.ulBulk;
000046  9000              STR      r0,[sp,#0]
000048  9800              LDR      r0,[sp,#0]
00004a  60a0              STR      r0,[r4,#8]
;;;638    
;;;639    #endif
;;;640    }
00004c  bd38              POP      {r3-r5,pc}
;;;641    
                          ENDP


                          AREA ||i.SCRB_PLL_Clock_On||, CODE, READONLY, ALIGN=1

                  SCRB_PLL_Clock_On PROC
;;;641    
;;;642    void SCRB_PLL_Clock_On(void)
000000  b538              PUSH     {r3-r5,lr}
;;;643    {
;;;644    #if 0
;;;645    	/*
;;;646    	 * Internal OSC use (12MHz) - Default.
;;;647    	 */
;;;648    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	//	main system clk: 12MHz, default: 0
;;;649    	/*
;;;650    	 * MCLK freq. setting
;;;651    	 */
;;;652    	SCRB->SYS_MAINCLK_CFG.tBit.mclksel = 0;	// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)		//	0: internal OSC, 1: External Crystal
;;;653    	SCRB->SYS_MAINCLK_CFG.tBit.mclkdiv = 15;	// WATCHDOG_BASE_ADDR & timer clock. OSC freq./(mclkdiv+1)    ( default: 12)
;;;654    
;;;655    	/*
;;;656    	 * PLL Power On
;;;657    	 * 	- VCO range : 150 < (Fin*N)/M < 300 ==> MUST BE !!     // Fin: input clk
;;;658    	 * 	- PLL clock = (Fin*N)/(M*O)
;;;659    	 */
;;;660    	uint8_t ucRselIdx = 0;
;;;661    	uint8_t vucRselValue[PLL_RSEL_MAX] = {3, 2, 1, 0, 4};
;;;662    	uint32_t ulPllLockCnt = 0;
;;;663    
;;;664    //	SCRB->PLL_CFG.tBit.pll_stby_i = 1;	// PLL power off & control register set
;;;665    
;;;666    	SCRB->PLL_CFG.tBit.rsel = 4;
;;;667    
;;;668    	SCRB->PLL_CFG.tBit.pllin_sel = 1;		// 0: int OSC, 1:XTAL (if XTAL, you need stable time 2msec after power on)  // input clk
;;;669    	SCRB->PLL_CFG.tBit.refdiv = 0;//1;		// M = refdiv+1
;;;670    	SCRB->PLL_CFG.tBit.outdiv = 0;//1;		// O = 0:1, 1:2, 2:4, 3:8
;;;671    
;;;672    	SCRB->PLL_CFG.tBit.fbdiv = 16;		// N = fbdiv (>5).  96MHz		//	feedback divider
;;;673    //		SCRB->PLL_CFG.tBit.fbdiv = 36;		// N = fbdiv (>5). 108MHz
;;;674    //		SCRB->PLL_CFG.tBit.fbdiv = 28;		// N = fbdiv (>5).	84MHz
;;;675    
;;;676    	SCRB->PLL_CFG.tBit.pll_stby_i = 0;	// PLL power on
;;;677    	while (!SCRB->PLL_LOCK)				// Wait Lock
;;;678    	{
;;;679    		ulPllLockCnt++;
;;;680    
;;;681    		if (ulPllLockCnt > PLL_RECOVERY_CNT)
;;;682    		{
;;;683    			SCRB->PLL_CFG.tBit.rsel = vucRselValue[ucRselIdx++];		//	rsel update
;;;684    			ulPllLockCnt = 0;
;;;685    
;;;686    			if (ucRselIdx >= PLL_RSEL_MAX)
;;;687    				ucRselIdx = 0;
;;;688    		}
;;;689    	}
;;;690    
;;;691    	/*
;;;692    	 * Change PLL clock
;;;693    	 */
;;;694    	SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 1;//1;//0;		// PLL clock divider. PLLCLK/(pllclkdiv+1)
;;;695    	SCRB->SYS_MAINCLK_CFG.tBit.usbclkdiv = 4;		// USB480 clock divider. 480MHz/(usbclkdiv+1)
;;;696    	SCRB->SYS_MAINCLK_CFG.tBit.hsclksel = 0;		// HIGH speed clock select. 0:PLLCLK_div, 1:USBCLK480_div
;;;697    //	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;	// 0: INT OSC 1: PLL/USB clock
;;;698    
;;;699    	/*
;;;700    	 * Clock Enable
;;;701    	 */
;;;702    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		//	main system clk: 12MHz, default: 0
;;;703    #else
;;;704    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 0;		//	main system clk: 12MHz, default: 0
000002  f04f4480          MOV      r4,#0x40000000
000006  6e20              LDR      r0,[r4,#0x60]
000008  f0200001          BIC      r0,r0,#1
00000c  6620              STR      r0,[r4,#0x60]
;;;705    	delay_usec(1);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       delay_us
;;;706    	SCRB->SYS_MAINCLK_CFG.tBit.pllclkdiv = 1;
000014  6e20              LDR      r0,[r4,#0x60]
000016  f020003c          BIC      r0,r0,#0x3c
00001a  1d00              ADDS     r0,r0,#4
00001c  6620              STR      r0,[r4,#0x60]
;;;707    //	SCRB->SYS_MAINCLK_CFG.tBit.mclkdiv = 15;	// WATCHDOG_BASE_ADDR & timer clock. OSC freq./(mclkdiv+1)    ( default: 12)
;;;708    	delay_usec(1);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       delay_us
;;;709    	SCRB->SYS_MAINCLK_CFG.tBit.mainclksel = 1;		//	main system clk: 12MHz, default: 0
000024  6e20              LDR      r0,[r4,#0x60]
000026  f0400001          ORR      r0,r0,#1
00002a  6620              STR      r0,[r4,#0x60]
;;;710    
;;;711    
;;;712    	tSYS_CLK_CTL _SYS_CLK_CTL;
;;;713    	_SYS_CLK_CTL.tBit.wdtclk_en = YES;
;;;714    	_SYS_CLK_CTL.tBit.timclk0_en = YES;
;;;715    	_SYS_CLK_CTL.tBit.timclk1_en = YES;
;;;716    	_SYS_CLK_CTL.tBit.timclk2_en = YES;
;;;717    	_SYS_CLK_CTL.tBit.timclk3_en = YES;
;;;718    	_SYS_CLK_CTL.tBit.i2cclk_en = YES;//YES;
;;;719    	_SYS_CLK_CTL.tBit.dspaclk_en = YES;
;;;720    	_SYS_CLK_CTL.tBit.tdspclk_en = YES;
;;;721    #ifdef MODE_I2C
;;;722    	_SYS_CLK_CTL.tBit.usbcclk_en = NO;
;;;723    	_SYS_CLK_CTL.tBit.usbhclk_en = NO;
;;;724    #else /* MODE_I2C */
;;;725    	_SYS_CLK_CTL.tBit.usbcclk_en = YES;
;;;726    	_SYS_CLK_CTL.tBit.usbhclk_en = YES;
;;;727    #endif /* MODE_I2C */
;;;728    	_SYS_CLK_CTL.tBit.pwmclk_en = YES;
;;;729    	_SYS_CLK_CTL.tBit.mspiclk_en = YES;
;;;730    	_SYS_CLK_CTL.tBit.sscgclk_en = YES;
;;;731    	_SYS_CLK_CTL.tBit.mpiclk_en = NO;
00002c  9800              LDR      r0,[sp,#0]
00002e  f4202006          BIC      r0,r0,#0x86000
;;;732    	_SYS_CLK_CTL.tBit.tlvclk_en = NO;
;;;733    	_SYS_CLK_CTL.tBit.i2cm0clk_en = YES;
;;;734    	_SYS_CLK_CTL.tBit.i2cm0clk_slp_en = YES;
;;;735    	_SYS_CLK_CTL.tBit.i2cm1clk_en = YES;
;;;736    	_SYS_CLK_CTL.tBit.i2cm1clk_slp_en = YES;
000032  f04000ff          ORR      r0,r0,#0xff
;;;737    	_SYS_CLK_CTL.tBit.osc_deglitch_en = NO;
000036  f440401f          ORR      r0,r0,#0x9f00
00003a  f44020e0          ORR      r0,r0,#0x70000
;;;738    	SCRB->SYS_CLK_CTL.ulBulk = _SYS_CLK_CTL.ulBulk;
00003e  9000              STR      r0,[sp,#0]
000040  9800              LDR      r0,[sp,#0]
000042  60a0              STR      r0,[r4,#8]
;;;739    
;;;740    #endif
;;;741    }
000044  bd38              POP      {r3-r5,pc}
;;;742    
                          ENDP


                          AREA ||i.SCRB_Remap_And_Reset||, CODE, READONLY, ALIGN=1

                  SCRB_Remap_And_Reset PROC
;;;753    
;;;754    void SCRB_Remap_And_Reset(uint8_t _num)
000000  f04f4180          MOV      r1,#0x40000000
;;;755    {
;;;756    	SCRB->SYS_BUS_REMAP = _num;
000004  f8410fb4          STR      r0,[r1,#0xb4]!
;;;757    	SCRB->CM3_REMAP_RESET = 1;
000008  2001              MOVS     r0,#1
00000a  6088              STR      r0,[r1,#8]
;;;758    }
00000c  4770              BX       lr
                          ENDP


                          AREA ||i.SCRB_USB_Reset||, CODE, READONLY, ALIGN=1

                  SCRB_USB_Reset PROC
;;;742    
;;;743    void SCRB_USB_Reset(void)
000000  f04f4180          MOV      r1,#0x40000000
;;;744    {
;;;745    	SCRB->SYS_RST_CTL.tBit.usb_rst = 1;
000004  68c8              LDR      r0,[r1,#0xc]
000006  f0400020          ORR      r0,r0,#0x20
00000a  60c8              STR      r0,[r1,#0xc]
;;;746    	SCRB->USB_PHY_FC.tBit.ponrst = 0;
00000c  f8d100a8          LDR      r0,[r1,#0xa8]
000010  f0200010          BIC      r0,r0,#0x10
000014  f8c100a8          STR      r0,[r1,#0xa8]
;;;747    
;;;748    	for (int i=0; i<100; i++);
000018  2000              MOVS     r0,#0
                  |L5.26|
00001a  1c40              ADDS     r0,r0,#1
00001c  2864              CMP      r0,#0x64
00001e  dbfc              BLT      |L5.26|
;;;749    
;;;750    	SCRB->USB_PHY_FC.tBit.ponrst = 1;
000020  f8d100a8          LDR      r0,[r1,#0xa8]
000024  f0400010          ORR      r0,r0,#0x10
000028  f8c100a8          STR      r0,[r1,#0xa8]
;;;751    	SCRB->SYS_RST_CTL.tBit.usb_rst = 0;
00002c  68c8              LDR      r0,[r1,#0xc]
00002e  f0200020          BIC      r0,r0,#0x20
000032  60c8              STR      r0,[r1,#0xc]
;;;752    }
000034  4770              BX       lr
;;;753    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\scrb\\scrb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_scrb_c_5ffd5815____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___6_scrb_c_5ffd5815____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_scrb_c_5ffd5815____REVSH|
#line 402
|__asm___6_scrb_c_5ffd5815____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_scrb_c_5ffd5815____RRX|
#line 587
|__asm___6_scrb_c_5ffd5815____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
