; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\algorithm_baseline.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\algorithm_baseline.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\algorithm_baseline.crf ..\..\App\Algorithm\Baseline\algorithm_baseline.c]
                          THUMB

                          AREA ||i.abnormal_rawdata_detection_for_hopping||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_detection_for_hopping PROC
;;;713    
;;;714    bool_t abnormal_rawdata_detection_for_hopping(bool_t SET)
000000  4907              LDR      r1,|L1.32|
;;;715    {
;;;716    	static uint32_t AbnormalCnt  = 0;
;;;717    	uint32_t lAbnormalCnt = 0;
;;;718    
;;;719    	if( SET )
000002  2800              CMP      r0,#0
000004  698a              LDR      r2,[r1,#0x18]
;;;720    	{
;;;721    		AbnormalCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  6188              STRNE    r0,[r1,#0x18]  ; AbnormalCnt
00000c  d105              BNE      |L1.26|
;;;722    	}
;;;723    	else
;;;724    	{
;;;725    		lAbnormalCnt = AbnormalCnt;
;;;726    		AbnormalCnt = 0;
00000e  2000              MOVS     r0,#0
;;;727    
;;;728    		if(lAbnormalCnt > 0)
000010  6188              STR      r0,[r1,#0x18]  ; AbnormalCnt
000012  2a00              CMP      r2,#0
;;;729    		{
;;;730    			return TRUE;
000014  bf1c              ITT      NE
000016  2001              MOVNE    r0,#1
;;;731    		}
;;;732    	}
;;;733    	return FALSE;
;;;734    }
000018  4770              BXNE     lr
                  |L1.26|
00001a  2000              MOVS     r0,#0                 ;733
00001c  4770              BX       lr
;;;735    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||

                          AREA ||i.abnormal_rawdata_temp||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_temp PROC
;;;690    
;;;691    bool_t abnormal_rawdata_temp(bool_t SET)
000000  4907              LDR      r1,|L2.32|
;;;692    {
;;;693    	static uint32_t dataCnt = 0;
;;;694    	uint32_t ldataCnt = 0;
;;;695    
;;;696    	if(SET)
000002  2800              CMP      r0,#0
000004  694a              LDR      r2,[r1,#0x14]
;;;697    	{
;;;698    		dataCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  6148              STRNE    r0,[r1,#0x14]  ; dataCnt
00000c  d105              BNE      |L2.26|
;;;699    	}
;;;700    	else
;;;701    	{
;;;702    		ldataCnt = dataCnt;
;;;703    		dataCnt = 0;
00000e  2000              MOVS     r0,#0
;;;704    
;;;705    		if(ldataCnt > 10)
000010  6148              STR      r0,[r1,#0x14]  ; dataCnt
000012  2a0a              CMP      r2,#0xa
;;;706    		{
;;;707    			return TRUE;
000014  bf84              ITT      HI
000016  2001              MOVHI    r0,#1
;;;708    		}
;;;709    	}
;;;710    
;;;711    	return FALSE;
;;;712    }
000018  4770              BXHI     lr
                  |L2.26|
00001a  2000              MOVS     r0,#0                 ;711
00001c  4770              BX       lr
;;;713    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_2_tracking_initial_local||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_2_tracking_initial_local PROC
;;;457    #else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;458    bool_t algorithm_baseline_2_tracking_initial_local(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;459    {
;;;460    	int r, c;
;;;461    	uint32_t ulRowEnd = PEN_COORD_ROW_MAX;
000004  2605              MOVS     r6,#5
;;;462    	uint16_t temp_data = 0;
;;;463    	ePartialSensing_t lDataIndex = PARTIAL_PEN_BEACON;
;;;464    	bool_t local_base_return_flag = NO;
;;;465        int finger_div = ((ROW_MAX + (PEN_COORD_ROW_MAX - 1)) / PEN_COORD_ROW_MAX);
;;;466    
;;;467    	sensingRowStart = 0;
000006  4c61              LDR      r4,|L3.396|
000008  2000              MOVS     r0,#0                 ;464
00000a  9000              STR      r0,[sp,#0]
00000c  f04f0809          MOV      r8,#9                 ;465
000010  8020              STRH     r0,[r4,#0]
;;;468    
;;;469    	module_wait_Vsync_signal(LOCAL_MODE, thisModeConf->BaseLine.ucDiscardFrameNum);
000012  4f5f              LDR      r7,|L3.400|
000014  68b8              LDR      r0,[r7,#8]  ; thisModeConf
000016  7841              LDRB     r1,[r0,#1]
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       module_wait_Vsync_signal
;;;470    
;;;471        while(YES)
;;;472        {
;;;473    		lDataIndex = module_wait_local_sample_done();
00001e  bf00              NOP      
                  |L3.32|
000020  f7fffffe          BL       module_wait_local_sample_done
;;;474    
;;;475    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;476    		if(lDataIndex == LOCAL_OP_2_LAST_LHB)
;;;477    #else
;;;478    		if(lDataIndex == LOCAL_OP_LAST_LHB || lDataIndex == PARTIAL_MAX)
000024  2808              CMP      r0,#8
000026  bf18              IT       NE
000028  2816              CMPNE    r0,#0x16
00002a  d1f9              BNE      |L3.32|
;;;479    #endif
;;;480    		{
;;;481    			break;
;;;482    		}
;;;483    	}
;;;484    
;;;485        tHalIntrHandle.ulLocalIndexChangeStart = 1;
00002c  4959              LDR      r1,|L3.404|
00002e  f04f0001          MOV      r0,#1
000032  6088              STR      r0,[r1,#8]  ; tHalIntrHandle
;;;486    
;;;487    	uint8_t BaseOffset = thisModeConf->BaseLine.ucPP_MUX_Select * PEN_COORD_ROW_MAX;
000034  68b8              LDR      r0,[r7,#8]  ; thisModeConf
;;;488    	
;;;489    	while(YES)
;;;490    	{
;;;491    		lDataIndex = module_wait_local_sample_done();
;;;492    
;;;493    		switch(lDataIndex)
;;;494    		{
;;;495    			case PARTIAL_PEN_COORD1:
;;;496    			case PARTIAL_PEN_COORD2:
;;;497    			case PARTIAL_PEN_COORD3:
;;;498    			case PARTIAL_PEN_COORD4:
;;;499    			{
;;;500    				int prev_raw_data = HAL_READ_LOCAL_RAW_IMAGE(0, 0);
000036  4d58              LDR      r5,|L3.408|
000038  f8900042          LDRB     r0,[r0,#0x42]         ;487
00003c  eb000080          ADD      r0,r0,r0,LSL #2       ;487
000040  b2c7              UXTB     r7,r0                 ;487
000042  bf00              NOP                            ;491
                  |L3.68|
000044  f7fffffe          BL       module_wait_local_sample_done
000048  2806              CMP      r0,#6                 ;493
00004a  d0fb              BEQ      |L3.68|
00004c  dc08              BGT      |L3.96|
00004e  2801              CMP      r0,#1                 ;493
000050  bf18              IT       NE                    ;493
000052  2802              CMPNE    r0,#2                 ;493
000054  d00f              BEQ      |L3.118|
000056  2803              CMP      r0,#3                 ;493
000058  bf18              IT       NE                    ;493
00005a  2804              CMPNE    r0,#4                 ;493
00005c  d00b              BEQ      |L3.118|
00005e  e052              B        |L3.262|
                  |L3.96|
000060  2807              CMP      r0,#7                 ;493
000062  bf18              IT       NE                    ;493
000064  2808              CMPNE    r0,#8                 ;493
000066  d04e              BEQ      |L3.262|
000068  280c              CMP      r0,#0xc               ;493
;;;501    				int temp_raw_data;
;;;502    				int sub_data;
;;;503    				int g_temp_sum = 0;
;;;504    
;;;505    				for(r = 0; r < ulRowEnd; r++)
;;;506    				{
;;;507    					for(c = 0; c < COL_MAX; c++)
;;;508    					{
;;;509    						temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r+BaseOffset, c);
;;;510    						temp_data = HAL_READ_LOCAL_BASELINE_IMAGE_2(r + sensingRowStart, c) + temp_raw_data;
;;;511    						HAL_WRITE_LOCAL_BASELINE_IMAGE_2(r + sensingRowStart, c, temp_data);
;;;512    						sub_data = (prev_raw_data - temp_raw_data);
;;;513    
;;;514    						/*
;;;515    						 * TODD_1st : 아래 상수값 parameter로 빼자!!
;;;516    						 */
;;;517    						if(sub_data < 0)
;;;518    						{
;;;519    							sub_data = -sub_data;
;;;520    						}
;;;521    						if(sub_data > 200)
;;;522    						{
;;;523    							g_temp_sum += sub_data;
;;;524    						}
;;;525    
;;;526    						prev_raw_data = temp_raw_data;
;;;527    					}
;;;528    				}
;;;529    
;;;530    //				if(g_temp_sum > 1000)
;;;531    //				{
;;;532    //					local_base_return_flag = YES;
;;;533    //				}
;;;534    				break;
;;;535    			}
;;;536    			case LOCAL_FINGER_LAST_LHB:
;;;537    			{
;;;538    				for (r = 0; r < ROW_MAX; r++)
00006a  bf04              ITT      EQ
00006c  2100              MOVEQ    r1,#0
;;;539    				{
;;;540    					for (c = 0; c < COL_MAX; c++)
;;;541    					{
;;;542    						temp_data = HAL_READ_LOCAL_FINGER_BASELINE_IMAGE_2(r, c) + HAL_READ_LOCAL_FINGER_RAW_IMAGE(r, c);
;;;543    						HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE_2(r, c, temp_data);
00006e  f8df912c          LDREQ    r9,|L3.412|
000072  d032              BEQ      |L3.218|
000074  e047              B        |L3.262|
                  |L3.118|
000076  2e00              CMP      r6,#0                 ;505
000078  bf18              IT       NE                    ;505
00007a  2300              MOVNE    r3,#0                 ;505
00007c  d943              BLS      |L3.262|
00007e  bf00              NOP                            ;507
                  |L3.128|
000080  eb030207          ADD      r2,r3,r7              ;509
000084  eb020282          ADD      r2,r2,r2,LSL #2       ;509
000088  f04f0100          MOV      r1,#0                 ;507
00008c  eb051a42          ADD      r10,r5,r2,LSL #5      ;509
                  |L3.144|
000090  f8b49000          LDRH     r9,[r4,#0]            ;510  ; sensingRowStart
000094  f83a2011          LDRH     r2,[r10,r1,LSL #1]    ;509
000098  4499              ADD      r9,r9,r3              ;510
00009a  eb090989          ADD      r9,r9,r9,LSL #2       ;510
00009e  eb051949          ADD      r9,r5,r9,LSL #5       ;510
0000a2  eb090941          ADD      r9,r9,r1,LSL #1       ;510
0000a6  f5095900          ADD      r9,r9,#0x2000         ;510
0000aa  f8b4b000          LDRH     r11,[r4,#0]           ;511  ; sensingRowStart
0000ae  f8b998a0          LDRH     r9,[r9,#0x8a0]        ;510
0000b2  4491              ADD      r9,r9,r2              ;510
0000b4  449b              ADD      r11,r11,r3            ;511
0000b6  eb0b0b8b          ADD      r11,r11,r11,LSL #2    ;511
0000ba  eb051b4b          ADD      r11,r5,r11,LSL #5     ;511
0000be  eb0b0b41          ADD      r11,r11,r1,LSL #1     ;511
0000c2  f50b5b00          ADD      r11,r11,#0x2000       ;511
0000c6  f1010101          ADD      r1,r1,#1              ;511
0000ca  f8ab98a0          STRH     r9,[r11,#0x8a0]       ;511
0000ce  2950              CMP      r1,#0x50              ;526
0000d0  dbde              BLT      |L3.144|
0000d2  1c5b              ADDS     r3,r3,#1              ;517
0000d4  42b3              CMP      r3,r6                 ;526
0000d6  d3d3              BCC      |L3.128|
0000d8  e015              B        |L3.262|
                  |L3.218|
0000da  eb090c41          ADD      r12,r9,r1,LSL #1
0000de  f50c5240          ADD      r2,r12,#0x3000
0000e2  f839a011          LDRH     r10,[r9,r1,LSL #1]
0000e6  f8b23840          LDRH     r3,[r2,#0x840]
0000ea  f8bcc002          LDRH     r12,[r12,#2]
0000ee  4453              ADD      r3,r3,r10
0000f0  f8b2a842          LDRH     r10,[r2,#0x842]
0000f4  f8a23840          STRH     r3,[r2,#0x840]
0000f8  44d4              ADD      r12,r12,r10
0000fa  1c89              ADDS     r1,r1,#2
0000fc  f8a2c842          STRH     r12,[r2,#0x842]
000100  f5b16f61          CMP      r1,#0xe10
000104  dbe9              BLT      |L3.218|
                  |L3.262|
;;;544    					}
;;;545    				}
;;;546    				break;
;;;547    			}
;;;548    			case PARTIAL_PEN_DATA1:
;;;549    			case PARTIAL_PEN_DATA2:
;;;550    			case PARTIAL_PEN_DATA3:
;;;551    			case PARTIAL_PEN_DATA4:
;;;552    			case PARTIAL_MAX:
;;;553    			default:
;;;554    				break;
;;;555    		}
;;;556    
;;;557    		if(lDataIndex == PARTIAL_PEN_COORD4)
000106  2804              CMP      r0,#4
000108  d028              BEQ      |L3.348|
;;;558    		{
;;;559    			sensingRowStart += PEN_COORD_ROW_MAX;
;;;560    			if(sensingRowStart >= ROW_MAX)
;;;561    			{
;;;562    				sensingRowStart = 0;
;;;563    			}
;;;564    			else if((ROW_MAX - sensingRowStart) < PEN_COORD_ROW_MAX)
;;;565    			{
;;;566    				ulRowEnd = (ROW_MAX - sensingRowStart);
;;;567    			}
;;;568    		}
;;;569    
;;;570    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;571    		if(lDataIndex == LOCAL_OP_2_LAST_LHB && sensingRowStart == 0)
;;;572    		{
;;;573    			break;
;;;574    		}
;;;575    #else
;;;576    		if((lDataIndex == LOCAL_OP_LAST_LHB && sensingRowStart == 0) || lDataIndex == PARTIAL_MAX)
00010a  2808              CMP      r0,#8
00010c  d039              BEQ      |L3.386|
00010e  2816              CMP      r0,#0x16
000110  d198              BNE      |L3.68|
;;;577    		{
;;;578    			break;
;;;579    		}
;;;580    #endif
;;;581    	}
;;;582    
;;;583    	for(r = ROW_MAX; r--; )
;;;584    	{
;;;585    		for(c=COL_MAX; c--; )
;;;586    		{
;;;587    			temp_data = HAL_READ_LOCAL_BASELINE_IMAGE_2(r, c);
;;;588    			temp_data /= 4;
;;;589    			HAL_WRITE_LOCAL_BASELINE_IMAGE_2(r, c, temp_data);
;;;590    
;;;591    			temp_data = HAL_READ_LOCAL_FINGER_BASELINE_IMAGE_2(r, c);
;;;592    			temp_data /= finger_div;
;;;593    			HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE_2(r, c, temp_data);
;;;594    		}
;;;595    	}
;;;596    
;;;597    	return local_base_return_flag;
;;;598    }
000112  bf00              NOP      
                  |L3.276|
000114  4c21              LDR      r4,|L3.412|
000116  f04f0c2c          MOV      r12,#0x2c
00011a  f642163e          MOV      r6,#0x293e            ;585
00011e  f64307de          MOV      r7,#0x38de            ;585
000122  bf00              NOP                            ;585
                  |L3.292|
000124  eb0c008c          ADD      r0,r12,r12,LSL #2     ;585
000128  eb051140          ADD      r1,r5,r0,LSL #5       ;585
00012c  eb041040          ADD      r0,r4,r0,LSL #5       ;585
000130  4431              ADD      r1,r1,r6              ;585
000132  4438              ADD      r0,r0,r7              ;585
000134  2250              MOVS     r2,#0x50              ;585
                  |L3.310|
000136  8803              LDRH     r3,[r0,#0]            ;585
000138  f8b19000          LDRH     r9,[r1,#0]            ;588
00013c  fb93f3f8          SDIV     r3,r3,r8              ;592
000140  ea4f0999          LSR      r9,r9,#2              ;588
000144  f8219902          STRH     r9,[r1],#-2           ;589
000148  f8203902          STRH     r3,[r0],#-2           ;593
00014c  1e52              SUBS     r2,r2,#1              ;593
00014e  d1f2              BNE      |L3.310|
000150  f1bc0c01          SUBS     r12,r12,#1            ;593
000154  d2e6              BCS      |L3.292|
000156  9800              LDR      r0,[sp,#0]            ;597
000158  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.348|
00015c  8820              LDRH     r0,[r4,#0]            ;559  ; sensingRowStart
00015e  1d40              ADDS     r0,r0,#5              ;559
000160  8020              STRH     r0,[r4,#0]            ;559
000162  8820              LDRH     r0,[r4,#0]            ;560  ; sensingRowStart
000164  282d              CMP      r0,#0x2d              ;560
000166  bf24              ITT      CS                    ;562
000168  2000              MOVCS    r0,#0                 ;562
00016a  8020              STRHCS   r0,[r4,#0]            ;562
00016c  f4bfaf6a          BCS      |L3.68|
000170  8820              LDRH     r0,[r4,#0]            ;564  ; sensingRowStart
000172  f1c0002d          RSB      r0,r0,#0x2d           ;564
000176  2805              CMP      r0,#5                 ;564
000178  bfbc              ITT      LT                    ;566
00017a  8820              LDRHLT   r0,[r4,#0]            ;566  ; sensingRowStart
00017c  f1c0062d          RSBLT    r6,r0,#0x2d           ;566
000180  e760              B        |L3.68|
                  |L3.386|
000182  8820              LDRH     r0,[r4,#0]            ;576  ; sensingRowStart
000184  2800              CMP      r0,#0                 ;576
000186  f47faf5d          BNE      |L3.68|
00018a  e7c3              B        |L3.276|
;;;599    #endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
                          ENDP

                  |L3.396|
                          DCD      sensingRowStart
                  |L3.400|
                          DCD      ||.data||
                  |L3.404|
                          DCD      tHalIntrHandle
                  |L3.408|
                          DCD      LocalSharedBuff
                  |L3.412|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_calculate_delta||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta PROC
;;;810    
;;;811    bool_t algorithm_baseline_calculate_delta(int mode)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;812    {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
;;;813    	int r, c;
;;;814    	int delta;	
;;;815    //	int local_rs;
;;;816    //	int pen_touch_data = 0;
;;;817    	uint16_t read_raw_data;
;;;818    //	tCell_t pen_pos;
;;;819    //	int pen_touch_data2 = 0;
;;;820    	tOrigDeltaInfo_t * temp_delta;
;;;821    	uint16_t * pBaseImage;
;;;822    	tAppInfo_t * ptAppInfo = app_GetInfo();
000008  f7fffffe          BL       app_GetInfo
;;;823    	
;;;824    	//Adaptive SeedBase LYB_200819
;;;825    	uint16_t AdaptiveSeedBase = 0;
;;;826    	
;;;827    #if CPI_TEST_EN
;;;828    	uint16_t AbnormalRawCnt = 0;	
;;;829    	uint32_t RawPartSum[COL_MAX/5+1] = {0};
;;;830    	uint16_t RawPartSumCnt[COL_MAX/5+1] = {0};
;;;831    	uint16_t AbnormalDeltaCntInMux[COL_MAX/5+1] = {0};
;;;832    	int DeltaEdgeCntInMux = 0;
;;;833    	uint8_t PhoneNoiseConditionCnt = 0;
;;;834    #endif
;;;835    #if LGD_ERROR_FRAME_PROCESS_EN
;;;836    	int EvenDelta = 0, OddDelta = 0;
;;;837    #endif
;;;838    	thisInfo->bBlockTracking = NO;
00000c  4e8d              LDR      r6,|L4.580|
00000e  2700              MOVS     r7,#0
000010  4680              MOV      r8,r0                 ;822
000012  68f4              LDR      r4,[r6,#0xc]  ; thisInfo
;;;839    //	local_rs = 0;
;;;840    	temp_delta = &thisInfo->tDelta;
;;;841    
;;;842    	memset((void *)temp_delta, 0x00, sizeof(tOrigDeltaInfo_t));
000014  212c              MOVS     r1,#0x2c
000016  f8047b0d          STRB     r7,[r4],#0xd          ;838
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       __aeabi_memclr
;;;843    	temp_delta->tValidRect.cs = COL_MAX - 1; temp_delta->tValidRect.ce = 0;
000020  204f              MOVS     r0,#0x4f
000022  70a0              STRB     r0,[r4,#2]
000024  70e7              STRB     r7,[r4,#3]
;;;844    	temp_delta->tValidRect.rs = ROW_MAX - 1; temp_delta->tValidRect.re = 0;
000026  202c              MOVS     r0,#0x2c
000028  7020              STRB     r0,[r4,#0]
00002a  7067              STRB     r7,[r4,#1]
;;;845    #if USED_NOISE_HOPPING_FREQ
;;;846    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
00002c  f8980012          LDRB     r0,[r8,#0x12]
000030  2801              CMP      r0,#1
;;;847    	{
;;;848    		pBaseImage = g_pFingerBaseImage;
000032  bf08              IT       EQ
000034  f8d6c01c          LDREQ    r12,[r6,#0x1c]  ; g_pFingerBaseImage
000038  d001              BEQ      |L4.62|
;;;849    	}
;;;850    	else
;;;851    	{
;;;852    		pBaseImage = (uint16_t *)HAL_GET_HOPP1_BASELINE_IMAGE_PTR() ;
00003a  f8dfc20c          LDR      r12,|L4.584|
                  |L4.62|
;;;853    	}
;;;854    //	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;855    #else /* USED_NOISE_HOPPING_FREQ */
;;;856    	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;857    #endif /* USED_NOISE_HOPPING_FREQ */
;;;858    	
;;;859    	temp_delta->iPosCnt = 0;
00003e  6167              STR      r7,[r4,#0x14]
;;;860    	temp_delta->iNegCnt = 0;
000040  61e7              STR      r7,[r4,#0x1c]
;;;861    
;;;862    
;;;863    //#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)	
;;;864    //	tRect_t FingerNonSumOnPenArea;
;;;865    //	bool_t bNonSumFlag = 0;
;;;866    //	FingerNonSumOnPenArea.cs = COL_MAX-1; FingerNonSumOnPenArea.ce = 0;
;;;867    //	FingerNonSumOnPenArea.rs = ROW_MAX-1; FingerNonSumOnPenArea.re = 0;
;;;868    //	if(thisInfo->tDelta_local.iMaxStrength > FingerNonSumThOnPenAreaForReBase
;;;869    //	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;870    //	&& hal_Info_GetControlLocalFingerOPType() == ACTIVEPEN_TYPE_LOCAL_MS
;;;871    //	#endif
;;;872    //	)
;;;873    //	{
;;;874    //		FingerNonSumOnPenArea.cs = MAX(0,thisInfo->tDelta_local.tMaxCellPos.c-3);
;;;875    //		FingerNonSumOnPenArea.ce = MIN(COL_MAX-1,thisInfo->tDelta_local.tMaxCellPos.c+3);
;;;876    //		FingerNonSumOnPenArea.rs = MAX(0,thisInfo->tDelta_local.tMaxCellPos.r+currentRowStart-3);
;;;877    //		FingerNonSumOnPenArea.re = MIN(ROW_MAX-1,thisInfo->tDelta_local.tMaxCellPos.r+currentRowStart+3);
;;;878    //		bNonSumFlag = 1;
;;;879    //	}
;;;880    //#endif
;;;881    	
;;;882    #if (USED_DSPA_FUNC_FOR_FINGER && USED_DSPA_FUNC_FOR_FINGER_CAL_DELTA)
;;;883    	if(!thisModeConf->BaseLine.bDspA_Finger_CalculateDelta)
;;;884    #endif
;;;885    	{
;;;886    		
;;;887    #if ADAPTIVE_SEEDBASE
;;;888    		//Adaptive SeedBase LYB_200819
;;;889    		if(thisInfo->bIsPalm)	AdaptiveSeedBase = (thisModeConf->Label.usSeedBase>>1);
000042  68f0              LDR      r0,[r6,#0xc]  ; thisInfo
000044  9000              STR      r0,[sp,#0]
000046  f8900fb2          LDRB     r0,[r0,#0xfb2]
00004a  2800              CMP      r0,#0
;;;890    		else					AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
00004c  68b0              LDR      r0,[r6,#8]  ; thisModeConf
00004e  bf1a              ITTE     NE                    ;889
000050  f8b0005f          LDRHNE   r0,[r0,#0x5f]         ;889
000054  ea4f0850          LSRNE    r8,r0,#1              ;889
000058  f8b0805f          LDRHEQ   r8,[r0,#0x5f]
;;;891    #else
;;;892    		AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
;;;893    #endif
;;;894    		
;;;895    		for( r=0; r<ROW_MAX; r++ )
00005c  2200              MOVS     r2,#0
00005e  4879              LDR      r0,|L4.580|
000060  6981              LDR      r1,[r0,#0x18]  ; AbnormalCnt
000062  9101              STR      r1,[sp,#4]
;;;896    		{
;;;897    #if LGD_ERROR_FRAME_PROCESS_EN
;;;898    			if(thisModeConf->Noise.ucErrorFrameProcess == 2){
;;;899    				EvenDelta = 0, OddDelta = 0;
;;;900    			}
;;;901    #endif
;;;902    			for( c=0; c<COL_MAX; c++ )
;;;903    			{
;;;904    				read_raw_data = HAL_READ_RAW_IMAGE(r, c);
;;;905    				
;;;906    #if CPI_TEST_EN
;;;907    				if(thisModeConf->Noise.ucCPITestOn){
;;;908    					RawPartSum[c/5] += read_raw_data;
;;;909    					RawPartSumCnt[c/5]++;
;;;910    					if(read_raw_data <= 0)	AbnormalRawCnt++;
;;;911    				}
;;;912    #endif
;;;913    				
;;;914    				delta = (signed)read_raw_data - (signed)(*(pBaseImage++));
;;;915    
;;;916    				if(mode == FULL_MODE)
;;;917    				{							
;;;918    					if(read_raw_data < MINRAWDATA_MARGIN)
;;;919    					{
;;;920    						abnormal_rawdata_temp(TRUE);
;;;921    					}
;;;922    #if USED_NOISE_HOPPING_FREQ
;;;923    					if( read_raw_data < thisModeConf->Noise.usRawDataThd )
;;;924    					{
;;;925    						if( HAL_READ_DELTA_IMAGE(r,c) < thisModeConf->Noise.sDeltaDataThd )
;;;926    						{
;;;927    							abnormal_rawdata_detection_for_hopping(TRUE);
;;;928    						}
;;;929    					}
;;;930    
;;;931    #endif /* USED_NOISE_HOPPING_FREQ */
;;;932    				}
;;;933    				
;;;934    #if NORMALIZE_DELTA_EN
;;;935    				//Normalize Active 190612 limyb
;;;936    				if(thisModeConf->BaseLine.cNormalizeDelta != 0 && delta > (AdaptiveSeedBase>>1))
;;;937    				{
;;;938    	//				int left_top = 1;
;;;939    	//				int right_bottom = 128;
;;;940    					int nDelta = delta;
;;;941    					
;;;942    	//				nDelta = nDelta * (2*ROW_MAX + r) * (2*COL_MAX + c) / (ROW_MAX * COL_MAX);
;;;943    //					delta = nDelta * ( ((ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta)<<1) - r) / (ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta);
;;;944    					delta = nDelta * (ROW_MAX + ((ROW_MAX - r)>>2)) / ROW_MAX;
;;;945    				}
;;;946    #endif
;;;947    				
;;;948    				delta >>= ptModuleModeConf->ucOvrShift;
;;;949    				
;;;950    				#if ConflictCopyTest
;;;951    					if(c > (COL_MAX)>>1){
;;;952    						delta = HAL_READ_DELTA_IMAGE(r,c-((COL_MAX)>>1));
;;;953    					}
;;;954    				#endif
;;;955    				
;;;956    				HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;957    					
;;;958    //				HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;959    				
;;;960    //				#if ConflictCopyTest
;;;961    //					if(c < (COL_MAX>>1)){
;;;962    //						HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;963    //						HAL_WRITE_DELTA_IMAGE(r,c+(COL_MAX>>1),delta);
;;;964    //					}
;;;965    //				#else
;;;966    //					HAL_WRITE_DELTA_IMAGE(r, c, delta);
;;;967    //				#endif
;;;968    				
;;;969    					
;;;970    #if LGD_ERROR_FRAME_PROCESS_EN
;;;971    				//LGD Kiosk error data rejection
;;;972    				if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;973    				{
;;;974    					if(c%2 == 0)	EvenDelta += delta;
;;;975    					else			OddDelta += delta;
;;;976    				}
;;;977    #endif
;;;978    				
;;;979    				//Mux baundary
;;;980    #if CPI_TEST_EN
;;;981    				if(thisModeConf->Noise.ucCPITestOn){
;;;982    					if(c != 0 && c < COL_MAX-1)
;;;983    					{
;;;984    						if(c%5 == 0){
;;;985    							if( abs(delta) > 10 && abs(delta - HAL_READ_DELTA_IMAGE(r,c-1)) > (abs(delta - HAL_READ_DELTA_IMAGE(r,c+1))<<1) )
;;;986    								DeltaEdgeCntInMux++;
;;;987    						}
;;;988    					}
;;;989    				
;;;990    					if(c%5 == 0)	PhoneNoiseConditionCnt = 0;
;;;991    					if(delta < -100)	PhoneNoiseConditionCnt++;
;;;992    					if(PhoneNoiseConditionCnt == 5)	AbnormalDeltaCntInMux[c/5] += 200;
;;;993    				}
;;;994    #endif
;;;995    				
;;;996    				if( delta > 0 )
;;;997    				{	
;;;998    					if( delta > thisModeConf->BaseLine.sAccumPosSumThd )
;;;999    					{
;;;1000   #if CPI_TEST_EN
;;;1001   						if(thisModeConf->Noise.ucCPITestOn){
;;;1002   							if(delta > 511)	AbnormalDeltaCntInMux[c/5] += 200;
;;;1003   						}
;;;1004   #endif
;;;1005   //#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)							
;;;1006   //						if((FingerNonSumOnPenArea.cs > c || FingerNonSumOnPenArea.ce < c || FingerNonSumOnPenArea.rs > r || FingerNonSumOnPenArea.re < r) && bNonSumFlag)
;;;1007   //#endif
;;;1008   						{
;;;1009   							temp_delta->iPosCnt++;
;;;1010   							temp_delta->iPosSum += delta - thisModeConf->BaseLine.sAccumPosSumThd;
;;;1011   						}
;;;1012   					}
;;;1013   
;;;1014   //					if( delta > thisModeConf->Label.usSeedBase )
;;;1015   					if( delta > AdaptiveSeedBase )
;;;1016   					{
;;;1017   						if( temp_delta->tValidRect.cs > c )
;;;1018   							temp_delta->tValidRect.cs = c;
;;;1019   						if( temp_delta->tValidRect.ce < c )
;;;1020   							temp_delta->tValidRect.ce = c;
;;;1021   						if( temp_delta->tValidRect.rs > r )
;;;1022   							temp_delta->tValidRect.rs = r;
;;;1023   						if( temp_delta->tValidRect.re < r )
;;;1024   							temp_delta->tValidRect.re = r;
;;;1025   
;;;1026   						temp_delta->iGroupedCellCnt++;
;;;1027   					}
;;;1028   
;;;1029   					if( temp_delta->iMaxStrength < delta )
;;;1030   					{
;;;1031   						temp_delta->iMaxStrength = delta;
;;;1032   					}
;;;1033   				}
;;;1034   				else
;;;1035   				{
;;;1036   					if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;1037   					{
;;;1038   #if CPI_TEST_EN
;;;1039   						if(thisModeConf->Noise.ucCPITestOn){
;;;1040   							AbnormalDeltaCntInMux[c/5]+=5;
;;;1041   							if(delta < -300)	AbnormalDeltaCntInMux[c/5] += 200;
;;;1042   						}
;;;1043   #endif
;;;1044   //#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)				
;;;1045   //						if((FingerNonSumOnPenArea.cs > c || FingerNonSumOnPenArea.ce < c || FingerNonSumOnPenArea.rs > r || FingerNonSumOnPenArea.re < r) && bNonSumFlag)
;;;1046   //#endif
;;;1047   						{						
;;;1048   							temp_delta->iNegCnt++;
;;;1049   							temp_delta->iNegSum += delta - thisModeConf->BaseLine.sAccumNegSumThd;
000064  6946              LDR      r6,[r0,#0x14]  ; dataCnt
000066  6883              LDR      r3,[r0,#8]  ; thisModeConf
000068  9302              STR      r3,[sp,#8]            ;948
00006a  f8d0a004          LDR      r10,[r0,#4]           ;948  ; ptModuleModeConf
                  |L4.110|
00006e  4f77              LDR      r7,|L4.588|
000070  eb020082          ADD      r0,r2,r2,LSL #2       ;904
000074  eb071b40          ADD      r11,r7,r0,LSL #5      ;904
000078  f1c2002d          RSB      r0,r2,#0x2d           ;944
00007c  f04f092d          MOV      r9,#0x2d              ;944
000080  eb0900a0          ADD      r0,r9,r0,ASR #2       ;944
000084  9004              STR      r0,[sp,#0x10]         ;925
000086  eb0200c2          ADD      r0,r2,r2,LSL #3       ;925
00008a  eb001042          ADD      r0,r0,r2,LSL #5       ;925
00008e  eb070780          ADD      r7,r7,r0,LSL #2       ;925
;;;1050   						}
;;;1051   					}
;;;1052   
;;;1053   
;;;1054   					if( temp_delta->iMinStrength > delta )
;;;1055   					{
;;;1056   						temp_delta->iMinStrength = delta;
;;;1057   						temp_delta->tMinCellPos.r = r;
000092  b250              SXTB     r0,r2
000094  2100              MOVS     r1,#0                 ;902
000096  9003              STR      r0,[sp,#0xc]
                  |L4.152|
000098  f83b9011          LDRH     r9,[r11,r1,LSL #1]    ;904
00009c  f83c0b02          LDRH     r0,[r12],#2           ;914
0000a0  eba90000          SUB      r0,r9,r0              ;914
0000a4  b9bd              CBNZ     r5,|L4.214|
0000a6  f1b90f0a          CMP      r9,#0xa               ;918
0000aa  bf38              IT       CC                    ;918
0000ac  1c76              ADDCC    r6,r6,#1              ;918
0000ae  f8b3e1e7          LDRH     lr,[r3,#0x1e7]        ;923
0000b2  45ce              CMP      lr,r9                 ;923
0000b4  d90f              BLS      |L4.214|
0000b6  eb070941          ADD      r9,r7,r1,LSL #1       ;925
0000ba  f5094940          ADD      r9,r9,#0xc000         ;925
0000be  f9b3e1e9          LDRSH    lr,[r3,#0x1e9]        ;925
0000c2  f9b9997e          LDRSH    r9,[r9,#0x97e]        ;925
0000c6  45f1              CMP      r9,lr                 ;925
0000c8  da05              BGE      |L4.214|
0000ca  f8dd9004          LDR      r9,[sp,#4]            ;925
0000ce  f1090901          ADD      r9,r9,#1              ;925
0000d2  f8cd9004          STR      r9,[sp,#4]            ;925
                  |L4.214|
0000d6  f8939000          LDRB     r9,[r3,#0]            ;936
0000da  f1b90f00          CMP      r9,#0                 ;936
0000de  bf18              IT       NE                    ;936
0000e0  ebb00f58          CMPNE    r0,r8,LSR #1          ;936
0000e4  dd0c              BLE      |L4.256|
0000e6  f8dd9010          LDR      r9,[sp,#0x10]         ;944
0000ea  f8dfe164          LDR      lr,|L4.592|
0000ee  fb09f900          MUL      r9,r9,r0              ;944
0000f2  2000              MOVS     r0,#0                 ;944
0000f4  fbce0909          SMLAL    r0,r9,lr,r9           ;944
0000f8  ea4f1069          ASR      r0,r9,#5              ;944
0000fc  eba070e9          SUB      r0,r0,r9,ASR #31      ;944
                  |L4.256|
000100  f89a9000          LDRB     r9,[r10,#0]           ;948
000104  fa40f009          ASR      r0,r0,r9              ;948
000108  2928              CMP      r1,#0x28              ;951
00010a  dd05              BLE      |L4.280|
00010c  eb070041          ADD      r0,r7,r1,LSL #1       ;952
000110  f5004040          ADD      r0,r0,#0xc000         ;952
000114  f9b0092e          LDRSH    r0,[r0,#0x92e]        ;952
                  |L4.280|
000118  eb070941          ADD      r9,r7,r1,LSL #1       ;956
00011c  f5094940          ADD      r9,r9,#0xc000         ;956
000120  2800              CMP      r0,#0                 ;996
000122  f8a9097e          STRH     r0,[r9,#0x97e]        ;956
000126  dd3d              BLE      |L4.420|
000128  f9b39009          LDRSH    r9,[r3,#9]            ;998
00012c  4548              CMP      r0,r9                 ;998
00012e  dd0e              BLE      |L4.334|
000130  f8d49014          LDR      r9,[r4,#0x14]         ;1009
000134  f1090901          ADD      r9,r9,#1              ;1009
000138  f8c49014          STR      r9,[r4,#0x14]         ;1009
00013c  f9b3e009          LDRSH    lr,[r3,#9]            ;1010
000140  f8d49018          LDR      r9,[r4,#0x18]         ;1010
000144  eba00e0e          SUB      lr,r0,lr              ;1010
000148  44f1              ADD      r9,r9,lr              ;1010
00014a  f8c49018          STR      r9,[r4,#0x18]         ;1010
                  |L4.334|
00014e  4540              CMP      r0,r8                 ;1015
000150  dd21              BLE      |L4.406|
000152  f9949002          LDRSB    r9,[r4,#2]            ;1018
000156  4589              CMP      r9,r1                 ;1018
000158  bfc8              IT       GT                    ;1018
00015a  4689              MOVGT    r9,r1                 ;1018
00015c  f8849002          STRB     r9,[r4,#2]            ;1018
000160  f9949003          LDRSB    r9,[r4,#3]            ;1020
000164  4589              CMP      r9,r1                 ;1020
000166  bfd8              IT       LE                    ;1020
000168  4689              MOVLE    r9,r1                 ;1020
00016a  f8849003          STRB     r9,[r4,#3]            ;1020
00016e  f9949000          LDRSB    r9,[r4,#0]            ;1022
000172  4591              CMP      r9,r2                 ;1022
000174  bfc8              IT       GT                    ;1022
000176  4691              MOVGT    r9,r2                 ;1022
000178  f8849000          STRB     r9,[r4,#0]            ;1022
00017c  f9949001          LDRSB    r9,[r4,#1]            ;1024
000180  4591              CMP      r9,r2                 ;1024
000182  bfd8              IT       LE                    ;1024
000184  4691              MOVLE    r9,r2                 ;1024
000186  f8849001          STRB     r9,[r4,#1]            ;1024
00018a  f8d49004          LDR      r9,[r4,#4]            ;1026
00018e  f1090901          ADD      r9,r9,#1              ;1026
000192  f8c49004          STR      r9,[r4,#4]            ;1026
                  |L4.406|
000196  f8d49008          LDR      r9,[r4,#8]            ;1031
00019a  4581              CMP      r9,r0                 ;1031
00019c  bfc8              IT       GT                    ;1031
00019e  4648              MOVGT    r0,r9                 ;1031
0001a0  60a0              STR      r0,[r4,#8]            ;1031
0001a2  e01c              B        |L4.478|
                  |L4.420|
0001a4  f9b3900b          LDRSH    r9,[r3,#0xb]          ;1036
0001a8  4548              CMP      r0,r9                 ;1036
0001aa  da0e              BGE      |L4.458|
0001ac  f8d4901c          LDR      r9,[r4,#0x1c]         ;1048
0001b0  f1090901          ADD      r9,r9,#1              ;1048
0001b4  f8c4901c          STR      r9,[r4,#0x1c]         ;1048
0001b8  f9b3e00b          LDRSH    lr,[r3,#0xb]          ;1049
0001bc  f8d49020          LDR      r9,[r4,#0x20]         ;1049
0001c0  eba00e0e          SUB      lr,r0,lr              ;1049
0001c4  44f1              ADD      r9,r9,lr              ;1049
0001c6  f8c49020          STR      r9,[r4,#0x20]         ;1049
                  |L4.458|
0001ca  f8d49024          LDR      r9,[r4,#0x24]         ;1054
0001ce  4581              CMP      r9,r0                 ;1054
0001d0  dd05              BLE      |L4.478|
0001d2  6260              STR      r0,[r4,#0x24]         ;1056
0001d4  9803              LDR      r0,[sp,#0xc]
0001d6  f884002b          STRB     r0,[r4,#0x2b]
;;;1058   						temp_delta->tMinCellPos.c = c;
0001da  f884102a          STRB     r1,[r4,#0x2a]
                  |L4.478|
0001de  1c49              ADDS     r1,r1,#1
0001e0  2950              CMP      r1,#0x50
0001e2  f6ffaf59          BLT      |L4.152|
0001e6  1c52              ADDS     r2,r2,#1
0001e8  2a2d              CMP      r2,#0x2d
0001ea  f6ffaf40          BLT      |L4.110|
0001ee  4815              LDR      r0,|L4.580|
0001f0  9901              LDR      r1,[sp,#4]
0001f2  e9c06105          STRD     r6,r1,[r0,#0x14]
;;;1059   	//					pen_touch_data = -delta;
;;;1060   //						pen_pos.r = r;
;;;1061   //						pen_pos.c = c;
;;;1062   					}
;;;1063   				}
;;;1064   			}
;;;1065   #if LGD_ERROR_FRAME_PROCESS_EN
;;;1066   			//LGD Kiosk error data rejection
;;;1067   			if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;1068   			{
;;;1069   				if(COL_MAX>1)
;;;1070   				{
;;;1071   					EvenDelta /= ( (COL_MAX+1)>>1);
;;;1072   					OddDelta /= (COL_MAX>>1);
;;;1073   					if(abs(EvenDelta - OddDelta) > 5)
;;;1074   					{
;;;1075   						for( c=0; c<COL_MAX; c++ ){
;;;1076   							delta = HAL_READ_DELTA_IMAGE(r,c);
;;;1077   							if(c%2 == 0)
;;;1078   								delta = (delta - EvenDelta < 0) ? 0 : delta - EvenDelta;
;;;1079   							else
;;;1080   								delta = (delta - OddDelta < 0) ? 0 : delta - OddDelta;
;;;1081   							HAL_WRITE_DELTA_IMAGE(r,c,delta);
;;;1082   						}
;;;1083   						
;;;1084   					}
;;;1085   				}
;;;1086   			}
;;;1087   #endif
;;;1088   			
;;;1089   		}
;;;1090   		
;;;1091   		thisInfo->bTouchExpect = (temp_delta->iGroupedCellCnt > 0);
0001f6  6860              LDR      r0,[r4,#4]
0001f8  2800              CMP      r0,#0
0001fa  bf18              IT       NE
0001fc  2001              MOVNE    r0,#1
0001fe  9900              LDR      r1,[sp,#0]
000200  f8810fb5          STRB     r0,[r1,#0xfb5]
000204  2101              MOVS     r1,#1                 ;846
000206  b140              CBZ      r0,|L4.538|
000208  9800              LDR      r0,[sp,#0]            ;1058
00020a  f5005080          ADD      r0,r0,#0x1000         ;1058
;;;1092   	}
;;;1093   #if (USED_DSPA_FUNC_FOR_FINGER && USED_DSPA_FUNC_FOR_FINGER_CAL_DELTA)
;;;1094   	else
;;;1095   	{
;;;1096   		algorithm_baseline_calculate_delta_dspA(mode);
;;;1097   	#if LOCAL_REBASE_ALGO_EN
;;;1098   		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)// || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN || USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;1099   		if(bNonSumFlag)
;;;1100   		{
;;;1101   			for(r = FingerNonSumOnPenArea.rs; r <= FingerNonSumOnPenArea.re; r++)for(c = FingerNonSumOnPenArea.cs; c <= FingerNonSumOnPenArea.ce; c++)
;;;1102   			{
;;;1103   				delta = HAL_READ_DELTA_IMAGE(r,c);
;;;1104   				if(delta > thisModeConf->BaseLine.sAccumPosSumThd)
;;;1105   				{
;;;1106   					temp_delta->iPosCnt--;
;;;1107   					temp_delta->iPosSum -= (delta - thisModeConf->BaseLine.sAccumPosSumThd);				
;;;1108   				}
;;;1109   				else if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;1110   				{						
;;;1111   					temp_delta->iNegCnt--;
;;;1112   					temp_delta->iNegSum -= (delta - thisModeConf->BaseLine.sAccumNegSumThd);
;;;1113   				}
;;;1114   			}
;;;1115   		}
;;;1116   		#endif
;;;1117   	#endif
;;;1118   	}
;;;1119   #endif	
;;;1120   
;;;1121   	if(thisInfo->bTouchExpect && !thisInfo->bLineFilterRepeatCheck)thisInfo->bLineFilterRepeatCheck = 1;
00020e  f8902179          LDRB     r2,[r0,#0x179]
000212  2a00              CMP      r2,#0
000214  bf08              IT       EQ
000216  f8801179          STRBEQ   r1,[r0,#0x179]
                  |L4.538|
;;;1122   
;;;1123   #if CPI_TEST_EN
;;;1124   	//LGD Phone noise
;;;1125   	if(thisModeConf->Noise.ucCPITestOn)
;;;1126   	{
;;;1127   		if(!thisInfo->WinCertMode && thisInfo->tCoord.cScreenDebCnt[0]<COORD_HISTORY_NUM){
;;;1128   			for(idx=0;idx<COL_MAX/5;idx++){
;;;1129   				if(RawPartSumCnt[idx] != 0)
;;;1130   					RawPartSum[idx] /= RawPartSumCnt[idx];
;;;1131   				if(idx>0){
;;;1132   					if(abs(RawPartSum[idx] - RawPartSum[idx-1])>1000)
;;;1133   						AbnormalRawCnt = RawPartSumCnt[idx];
;;;1134   				}
;;;1135   				
;;;1136   				if(AbnormalDeltaCntInMux[idx] > 50 || DeltaEdgeCntInMux > (ROW_MAX>>1) )
;;;1137   					thisInfo->UnstableStateFrm = 400;
;;;1138   		//		if(AbnormalDeltaCntInMux[idx] >= 200)
;;;1139   		//			thisInfo->UnstableStateFrm = 400;
;;;1140   			}
;;;1141   			
;;;1142   			if(thisInfo->UnstableStateFrm && wdt_init)
;;;1143   			{
;;;1144   				KICK_DOG();
;;;1145   				Hal_WDT_DeInit();
;;;1146   			}
;;;1147   			
;;;1148   			if(AbnormalRawCnt >= 5){
;;;1149   				memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;1150   				GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;1151   				thisInfo->UnstableStateFrm = 0;
;;;1152   			}
;;;1153   			
;;;1154   			{
;;;1155   				static uint16_t AbnormalFrmCnt = 0;
;;;1156   				static uint8_t ResetDelayCount = 0;
;;;1157   
;;;1158   				if(thisInfo->UnstableStateFrm){
;;;1159   					memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;1160   					if(ResetDelayCount++ > 10){
;;;1161   						GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;1162   					}	
;;;1163   				}
;;;1164   				if(GoToThisState == TOUCH_NORMAL_OPER_RESET_HAL)
;;;1165   				{
;;;1166   					thisInfo->UnstableStateFrm = 0;
;;;1167   					AbnormalFrmCnt = 0;
;;;1168   					ResetDelayCount = 0;
;;;1169   				}
;;;1170   			}
;;;1171   		}
;;;1172   	}
;;;1173   #endif
;;;1174   	
;;;1175   	if(  temp_delta->iMaxStrength > thisModeConf->BaseLine.sBlockPosThd )
00021a  68a2              LDR      r2,[r4,#8]
00021c  9802              LDR      r0,[sp,#8]
00021e  f9b00005          LDRSH    r0,[r0,#5]
000222  4282              CMP      r2,r0
;;;1176   	{
;;;1177   		thisInfo->bBlockTracking = YES;
000224  bfc4              ITT      GT
000226  9800              LDRGT    r0,[sp,#0]
000228  7001              STRBGT   r1,[r0,#0]
;;;1178   	}
;;;1179   	
;;;1180   	if( temp_delta->iMinStrength < thisModeConf->BaseLine.sBlockNegThd )
00022a  6a62              LDR      r2,[r4,#0x24]
00022c  9802              LDR      r0,[sp,#8]
00022e  f9b00007          LDRSH    r0,[r0,#7]
000232  4282              CMP      r2,r0
;;;1181   	{
;;;1182   		thisInfo->bBlockTracking = YES;
000234  bfbc              ITT      LT
000236  9800              LDRLT    r0,[sp,#0]
000238  7001              STRBLT   r1,[r0,#0]
;;;1183   	}
;;;1184   	
;;;1185   #if USED_PEN_MODE_OPERATION
;;;1186   	if(mode == FULL_MODE)
;;;1187   	{
;;;1188   		if(thisInfo->sLFingerMinVal < -30 && 
;;;1189   			((thisInfo->tLFingerMinCell.r-1 <= temp_delta->tMinCellPos.r && temp_delta->tMinCellPos.r <= thisInfo->tLFingerMinCell.r+1) && 
;;;1190   			(thisInfo->tLFingerMinCell.c-1 <= temp_delta->tMinCellPos.c && temp_delta->tMinCellPos.c <= thisInfo->tLFingerMinCell.c+1)))
;;;1191   			temp_delta->iMinStrength = /*pen_touch_data =*/ 0;
;;;1192   		
;;;1193   	//	if(pen_touch_data > 30 || pen_touch_data2 < -70)
;;;1194   	//	{
;;;1195   	//		thisInfo->bLocal_sensing = YES;
;;;1196   	////		hal_Info_SetPenDectionEnable(YES);
;;;1197   	//		algorithm_baseline_calculate_mux_range(pen_pos.r+local_rs, pen_pos.c);
;;;1198   	//	}
;;;1199   	}
;;;1200   	else
;;;1201   	{
;;;1202   		thisInfo->sLFingerMinVal = temp_delta->iMinStrength;
;;;1203   		thisInfo->tLFingerMinCell = temp_delta->tMinCellPos;		
;;;1204   	}
;;;1205   #endif /* USED_PEN_MODE_OPERATION */
;;;1206   
;;;1207   	return thisInfo->bBlockTracking;
00023a  9800              LDR      r0,[sp,#0]
00023c  7800              LDRB     r0,[r0,#0]
;;;1208   }
00023e  b005              ADD      sp,sp,#0x14
000240  e8bd8ff0          POP      {r4-r11,pc}
;;;1209   
                          ENDP

                  |L4.580|
                          DCD      ||.data||
                  |L4.584|
                          DCD      FullSharedBuff+0x5460
                  |L4.588|
                          DCD      FullSharedBuff
                  |L4.592|
                          DCD      0xb60b60b7

                          AREA ||i.algorithm_baseline_calculate_delta_S3||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta_S3 PROC
;;;1967   
;;;1968   void algorithm_baseline_calculate_delta_S3(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1969   {
;;;1970   	uint32_t r, c;
;;;1971   	int16_t delta;
;;;1972   	uint16_t read_raw_data;
;;;1973   	uint16_t * pS3BaseImage;
;;;1974   	tS3DeltaInfo_t * ptTempS3DeltaInfo;
;;;1975   
;;;1976   	thisInfo->bBlockTracking = NO;
000004  4f4b              LDR      r7,|L5.308|
000006  2000              MOVS     r0,#0
000008  68f9              LDR      r1,[r7,#0xc]  ; thisInfo
;;;1977   	thisInfo->bTouchExpect = NO;
;;;1978   
;;;1979   	ptTempS3DeltaInfo = &thisInfo->tS3DeltaInfo;
00000a  f5016472          ADD      r4,r1,#0xf20
00000e  7008              STRB     r0,[r1,#0]            ;1976
000010  f8810fb5          STRB     r0,[r1,#0xfb5]        ;1977
;;;1980   
;;;1981   	ptTempS3DeltaInfo->sMaxStrength = -4096;
000014  f44f4070          MOV      r0,#0xf000
000018  f8a10f28          STRH     r0,[r1,#0xf28]
;;;1982   	ptTempS3DeltaInfo->sMinStrength = 4096;
00001c  f44f5080          MOV      r0,#0x1000
000020  f8a10f2a          STRH     r0,[r1,#0xf2a]
;;;1983   
;;;1984   	pS3BaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
000024  f7fffffe          BL       HAL_GetSensingMode
000028  2101              MOVS     r1,#1
00002a  f7fffffe          BL       HAL_GetBaseImagePointer
;;;1985   	for(r=0; r<NI_ROW_MAX; r++)
;;;1986   	{
;;;1987   		for(c=0; c<COL_MAX; c++)
00002e  f8dfb108          LDR      r11,|L5.312|
000032  f8d7a004          LDR      r10,[r7,#4]  ; ptModuleModeConf
000036  f04f0900          MOV      r9,#0                 ;1985
00003a  f24f6e02          MOV      lr,#0xf602
                  |L5.62|
00003e  eb090289          ADD      r2,r9,r9,LSL #2
000042  eb0b1342          ADD      r3,r11,r2,LSL #5
000046  4601              MOV      r1,r0
000048  eb03050e          ADD      r5,r3,lr
00004c  f04f0c00          MOV      r12,#0
000050  f05f0650          MOVS.W   r6,#0x50
                  |L5.84|
;;;1988   		{
;;;1989   			read_raw_data = HAL_NI_READ_RAW_IMAGE(r, c);
;;;1990   			delta = (int16_t)read_raw_data - (int16_t)(*(pS3BaseImage++));
000054  f8332b02          LDRH     r2,[r3],#2
000058  f8318b02          LDRH     r8,[r1],#2
00005c  eba20208          SUB      r2,r2,r8
;;;1991   			delta >>= ptModuleModeConf->ucIdleOvrShift;
000060  f89a8001          LDRB     r8,[r10,#1]
000064  b212              SXTH     r2,r2                 ;1990
000066  fa42f208          ASR      r2,r2,r8
;;;1992   
;;;1993   			HAL_NI_WRITE_DELTA_IMAGE(r, c, delta);
00006a  f8252b02          STRH     r2,[r5],#2
;;;1994   
;;;1995   			if(ptTempS3DeltaInfo->sMaxStrength < delta)
00006e  f9b48008          LDRSH    r8,[r4,#8]
000072  4590              CMP      r8,r2
;;;1996   			{
;;;1997   				ptTempS3DeltaInfo->sMaxStrength = delta;
000074  bfbc              ITT      LT
000076  8122              STRHLT   r2,[r4,#8]
;;;1998   				ptTempS3DeltaInfo->ulMaxNodeColIndex = c;
000078  f8c4c000          STRLT    r12,[r4,#0]
;;;1999   			}
;;;2000   
;;;2001   			if(ptTempS3DeltaInfo->sMinStrength > delta)
00007c  f9b4800a          LDRSH    r8,[r4,#0xa]
000080  4590              CMP      r8,r2
;;;2002   			{
;;;2003   				ptTempS3DeltaInfo->sMinStrength = delta;
000082  bfc4              ITT      GT
000084  8162              STRHGT   r2,[r4,#0xa]
;;;2004   				ptTempS3DeltaInfo->ulMinNodeColIndex = c;
000086  f8c4c004          STRGT    r12,[r4,#4]
00008a  1e76              SUBS     r6,r6,#1
00008c  f10c0c01          ADD      r12,r12,#1
000090  d1e0              BNE      |L5.84|
000092  30a0              ADDS     r0,r0,#0xa0           ;1995
000094  f1090901          ADD      r9,r9,#1              ;1995
;;;2005   			}
;;;2006   		}
000098  f1b90f0a          CMP      r9,#0xa
00009c  d3cf              BCC      |L5.62|
;;;2007   	}
;;;2008   
;;;2009   	if(ptTempS3DeltaInfo->sMaxStrength > thisModeConf->BaseLine.sS3_BlockPosThd ||
00009e  68be              LDR      r6,[r7,#8]  ; thisModeConf
0000a0  f9b43008          LDRSH    r3,[r4,#8]
0000a4  f9b6001d          LDRSH    r0,[r6,#0x1d]
0000a8  4283              CMP      r3,r0
0000aa  dc07              BGT      |L5.188|
0000ac  f9b4000a          LDRSH    r0,[r4,#0xa]
0000b0  f9b6101f          LDRSH    r1,[r6,#0x1f]
0000b4  4281              CMP      r1,r0
;;;2010   		ptTempS3DeltaInfo->sMinStrength < thisModeConf->BaseLine.sS3_BlockNegThd)
;;;2011   	{
;;;2012   		uint32_t ulCheckNodeColIdx;
;;;2013   		if(ABS(ptTempS3DeltaInfo->sMaxStrength) > ABS(ptTempS3DeltaInfo->sMinStrength))
;;;2014   		{
;;;2015   			ulCheckNodeColIdx = ptTempS3DeltaInfo->ulMaxNodeColIndex;
;;;2016   		}
;;;2017   		else
;;;2018   		{
;;;2019   			ulCheckNodeColIdx = ptTempS3DeltaInfo->ulMinNodeColIndex;
;;;2020   		}
;;;2021   		ptTempS3DeltaInfo->sColumStrengthTotalSum = 0;
;;;2022   		for(r=0; r<NI_ROW_MAX; r++)
;;;2023   		{
;;;2024   			ptTempS3DeltaInfo->sColumStrengthTotalSum += HAL_NI_READ_DELTA_IMAGE(r, ulCheckNodeColIdx);
;;;2025   		}
;;;2026   
;;;2027   		if(ptTempS3DeltaInfo->sColumStrengthTotalSum > thisModeConf->BaseLine.sS3_PosTotalSumThd ||
;;;2028   			ptTempS3DeltaInfo->sColumStrengthTotalSum < thisModeConf->BaseLine.sS3_NegTotalSumThd)
;;;2029   		{
;;;2030   			ptTempS3DeltaInfo->sPrevMaxStrength = ptTempS3DeltaInfo->sMaxStrength;
;;;2031   			ptTempS3DeltaInfo->sPrevMinStrength = ptTempS3DeltaInfo->sMinStrength;
;;;2032   
;;;2033   //			if((ptTempS3DeltaInfo->sPrevMaxStrength > 500 || ptTempS3DeltaInfo->sColumStrengthTotalSum < -500) &&
;;;2034   //				(ptTempS3DeltaInfo->sColumStrengthTotalSum > 2500 || ptTempS3DeltaInfo->sColumStrengthTotalSum < -2500))
;;;2035   //			{
;;;2036   //
;;;2037   //			}
;;;2038   //			else
;;;2039   			{
;;;2040   #if (!USED_ONLY_S3_MODE)
;;;2041   				thisInfo->bTouchExpect = YES;
;;;2042   #endif /* (!USED_ONLY_S3_MODE) */
;;;2043   			}
;;;2044   		}
;;;2045   
;;;2046   		thisInfo->bBlockTracking = YES;
;;;2047   	}
;;;2048   
;;;2049   #if USED_ONLY_IDLE_MODE
;;;2050   	thisInfo->bTouchExpect = NO;
;;;2051   	thisInfo->bBlockTracking = NO;
;;;2052   #endif /* USED_ONLY_IDLE_MODE */
;;;2053   }
0000b6  bfd8              IT       LE
0000b8  e8bd9ff0          POPLE    {r4-r12,pc}
                  |L5.188|
0000bc  2b00              CMP      r3,#0                 ;2013
0000be  bfac              ITE      GE                    ;2013
0000c0  4618              MOVGE    r0,r3                 ;2013
0000c2  4258              RSBLT    r0,r3,#0              ;2013
0000c4  f9b4c00a          LDRSH    r12,[r4,#0xa]         ;2013
0000c8  f1bc0f00          CMP      r12,#0                ;2013
0000cc  bfac              ITE      GE                    ;2013
0000ce  4661              MOVGE    r1,r12                ;2013
0000d0  f1cc0100          RSBLT    r1,r12,#0             ;2013
0000d4  4288              CMP      r0,r1                 ;2013
0000d6  bfcc              ITE      GT                    ;2015
0000d8  6820              LDRGT    r0,[r4,#0]            ;2015
0000da  6860              LDRLE    r0,[r4,#4]            ;2019
0000dc  2100              MOVS     r1,#0                 ;2021
0000de  8221              STRH     r1,[r4,#0x10]         ;2021
0000e0  eb0b0040          ADD      r0,r11,r0,LSL #1      ;2022
0000e4  f24f5162          MOV      r1,#0xf562            ;2022
0000e8  4408              ADD      r0,r0,r1              ;2022
0000ea  2100              MOVS     r1,#0
0000ec  2205              MOVS     r2,#5                 ;2022
                  |L5.238|
0000ee  8a25              LDRH     r5,[r4,#0x10]         ;2024
0000f0  f8308fa0          LDRH     r8,[r0,#0xa0]!        ;2024
0000f4  1e52              SUBS     r2,r2,#1              ;2024
0000f6  4445              ADD      r5,r5,r8              ;2024
0000f8  8225              STRH     r5,[r4,#0x10]         ;2024
0000fa  f8305fa0          LDRH     r5,[r0,#0xa0]!        ;2024
0000fe  4429              ADD      r1,r1,r5              ;2024
000100  b209              SXTH     r1,r1                 ;2024
000102  d1f4              BNE      |L5.238|
000104  8a20              LDRH     r0,[r4,#0x10]
000106  4408              ADD      r0,r0,r1
000108  b200              SXTH     r0,r0
00010a  8220              STRH     r0,[r4,#0x10]
00010c  f9b62021          LDRSH    r2,[r6,#0x21]         ;2027
000110  2101              MOVS     r1,#1                 ;1984
000112  4290              CMP      r0,r2                 ;2027
000114  dc03              BGT      |L5.286|
000116  f9b62023          LDRSH    r2,[r6,#0x23]         ;2027
00011a  4290              CMP      r0,r2                 ;2027
00011c  da05              BGE      |L5.298|
                  |L5.286|
00011e  81a3              STRH     r3,[r4,#0xc]          ;2030
000120  f8a4c00e          STRH     r12,[r4,#0xe]         ;2031
000124  68f8              LDR      r0,[r7,#0xc]          ;2041  ; thisInfo
000126  f8801fb5          STRB     r1,[r0,#0xfb5]        ;2041
                  |L5.298|
00012a  68f8              LDR      r0,[r7,#0xc]          ;2046  ; thisInfo
00012c  7001              STRB     r1,[r0,#0]            ;2046
00012e  e8bd9ff0          POP      {r4-r12,pc}
;;;2054   #endif /* USED_MNT_S3_MODE_FUNCTION */
                          ENDP

000132  0000              DCW      0x0000
                  |L5.308|
                          DCD      ||.data||
                  |L5.312|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_calculate_mux_range||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_mux_range PROC
;;;740    
;;;741    void algorithm_baseline_calculate_mux_range(int r, int c)
000000  4a11              LDR      r2,|L6.72|
;;;742    {
;;;743    #if 1
;;;744    #define COL_CAL_SIZE						(8)
;;;745    #define COL_CAL_HALF						(COL_CAL_SIZE>>1)
;;;746    #define PEN_LOCAL_ROW_HALF_IDX				(PEN_COORD_ROW_MAX>>1)
;;;747    //	int sub_r = r;
;;;748    
;;;749    	if(r <= PEN_LOCAL_ROW_HALF_IDX)
;;;750    	{
;;;751    		sensingRowStart = 0;
000002  2300              MOVS     r3,#0
000004  2802              CMP      r0,#2                 ;749
000006  bfd8              IT       LE
000008  8013              STRHLE   r3,[r2,#0]
00000a  dd04              BLE      |L6.22|
;;;752    	}
;;;753    	else if(r >= (ROW_MAX-1) - PEN_LOCAL_ROW_HALF_IDX)
00000c  282a              CMP      r0,#0x2a
;;;754    	{
;;;755    		sensingRowStart = ROW_MAX - PEN_COORD_ROW_MAX;
00000e  bfac              ITE      GE
000010  2028              MOVGE    r0,#0x28
000012  1e80              SUBLT    r0,r0,#2
000014  8010              STRH     r0,[r2,#0]
                  |L6.22|
;;;756    	}
;;;757    	else
;;;758    	{
;;;759    		sensingRowStart = r - PEN_LOCAL_ROW_HALF_IDX;
;;;760    	}
;;;761    
;;;762    //	currentRowStart = sensingRowStart;
;;;763    	if(c<COL_CAL_HALF)
;;;764    	{
;;;765    		thisInfo->tPenInfo.ucCurrentColumnStart = 0;
000016  480d              LDR      r0,|L6.76|
000018  2904              CMP      r1,#4                 ;763
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  bfbc              ITT      LT
00001e  f8803fbb          STRBLT   r3,[r0,#0xfbb]
;;;766    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_CAL_SIZE;
000022  2108              MOVLT    r1,#8
000024  db06              BLT      |L6.52|
;;;767    	}
;;;768    	else if(c+COL_CAL_HALF >= COL_MAX)
000026  1d0a              ADDS     r2,r1,#4
000028  2a50              CMP      r2,#0x50
00002a  db06              BLT      |L6.58|
;;;769    	{
;;;770    		thisInfo->tPenInfo.ucCurrentColumnStart = COL_MAX - COL_CAL_SIZE - 1;
00002c  2147              MOVS     r1,#0x47
00002e  f8801fbb          STRB     r1,[r0,#0xfbb]
;;;771    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_MAX - 1;
000032  214f              MOVS     r1,#0x4f
                  |L6.52|
000034  f8801fbc          STRB     r1,[r0,#0xfbc]        ;766
;;;772    	}
;;;773    	else
;;;774    	{
;;;775    		thisInfo->tPenInfo.ucCurrentColumnStart = c-COL_CAL_HALF;
;;;776    		thisInfo->tPenInfo.ucCurrentColumnEnd = c+COL_CAL_HALF;
;;;777    	}
;;;778    #else
;;;779    	int sub_r = r;
;;;780    	
;;;781    	if(currentRowStart == sensingRowStart)
;;;782    	{
;;;783    		sub_r = sub_r-MAX_MUX_HALF;
;;;784    		
;;;785    		if(sub_r < 0)
;;;786    			sensingRowStart = 0;
;;;787    		else if(sub_r >= MUX_MAX_ROW)
;;;788    			sensingRowStart = MUX_MAX_ROW;
;;;789    		else
;;;790    			sensingRowStart = sub_r;
;;;791    	}
;;;792    
;;;793    	if(c<MAX_MUX_HALF)
;;;794    	{
;;;795    		thisInfo->tPenInfo.ucCurrentColumnStart = 0;
;;;796    		thisInfo->tPenInfo.ucCurrentColumnEnd = MAX_MUX_SIZE;
;;;797    	}
;;;798    	else if(c+MAX_MUX_HALF > COL_MAX)
;;;799    	{
;;;800    		thisInfo->tPenInfo.ucCurrentColumnStart = COL_MAX - MAX_MUX_SIZE;
;;;801    		thisInfo->tPenInfo.ucCurrentColumnEnd = COL_MAX;
;;;802    	}
;;;803    	else
;;;804    	{
;;;805    		thisInfo->tPenInfo.ucCurrentColumnStart = c-MAX_MUX_HALF;
;;;806    		thisInfo->tPenInfo.ucCurrentColumnEnd = c+MAX_MUX_HALF;
;;;807    	}
;;;808    #endif
;;;809    }
000038  4770              BX       lr
                  |L6.58|
00003a  1f09              SUBS     r1,r1,#4
00003c  f8801fbb          STRB     r1,[r0,#0xfbb]        ;775
000040  f8802fbc          STRB     r2,[r0,#0xfbc]        ;776
000044  4770              BX       lr
;;;810    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      sensingRowStart
                  |L6.76|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_init||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init PROC
;;;54     
;;;55     void algorithm_baseline_init(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c0a              LDR      r4,|L7.48|
000008  60a0              STR      r0,[r4,#8]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
;;;56     {
;;;57     	algorithm_baseline_init_param();
;;;58     	thisInfo = algorithm_GetInfo();
00000e  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
000010  f7fffffe          BL       algorithm_GetInfo
;;;59     #if USED_NOISE_HOPPING_FREQ
;;;60     	ptAppInfo = app_GetInfo();
000014  60e0              STR      r0,[r4,#0xc]  ; thisInfo
000016  f7fffffe          BL       app_GetInfo
00001a  6120              STR      r0,[r4,#0x10]  ; ptAppInfo
00001c  4805              LDR      r0,|L7.52|
;;;61     #endif
;;;62     	algorithm_baseline_init_FingerPoint();	
;;;63     	memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
00001e  61e0              STR      r0,[r4,#0x1c]  ; g_pFingerBaseImage
000020  e8bd4010          POP      {r4,lr}
000024  f641611c          MOV      r1,#0x1e1c
000028  4803              LDR      r0,|L7.56|
00002a  f7ffbffe          B.W      __aeabi_memclr4
;;;64     }
;;;65     
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      ||.data||
                  |L7.52|
                          DCD      FullSharedBuff+0x3840
                  |L7.56|
                          DCD      FullSharedBuff+0xc8d8

                          AREA ||i.algorithm_baseline_init_FingerPoint||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_FingerPoint PROC
;;;71     
;;;72     void algorithm_baseline_init_FingerPoint(void)
000000  4902              LDR      r1,|L8.12|
;;;73     {
;;;74     #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_PEN)
;;;75     	g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
000002  4801              LDR      r0,|L8.8|
000004  61c8              STR      r0,[r1,#0x1c]  ; g_pFingerBaseImage
;;;76     #elif (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN || PEN_PROTOCOL_WGP_UHD_PEN)
;;;77     	g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;78     #else	
;;;79     	if(hal_Info_GetControlActivePenRawDataType() == ACTIVEPEN_TYPE_LOCAL_WGP)
;;;80     	{
;;;81     		g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
;;;82     	}
;;;83     	else
;;;84     	{
;;;85     		g_pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;86     	}
;;;87     #endif
;;;88     }
000006  4770              BX       lr
;;;89     
                          ENDP

                  |L8.8|
                          DCD      FullSharedBuff+0x3840
                  |L8.12|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_init_param||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_param PROC
;;;65     
;;;66     void algorithm_baseline_init_param(void)
000000  b510              PUSH     {r4,lr}
;;;67     {
;;;68     	thisModeConf  = algorithm_GetModeConfig();
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c03              LDR      r4,|L9.20|
;;;69     	ptModuleModeConf = module_GetModeConfig();
000008  60a0              STR      r0,[r4,#8]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
00000e  6060              STR      r0,[r4,#4]  ; ptModuleModeConf
;;;70     }
000010  bd10              POP      {r4,pc}
;;;71     
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_tracking_continuous||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous PROC
;;;602    extern int16_t sLFOffsetCol[COL_MAX];
;;;603    void algorithm_baseline_tracking_continuous(uint8_t mode)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;604    {
000004  4680              MOV      r8,r0
;;;605    	uint32_t ulIdx;
;;;606    	uint32_t ulFullIdxNum;
;;;607    	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;608    	static bool_t traking_en = 0;
;;;609    	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
000006  f7fffffe          BL       hal_Info_GetControlLocalFingerOPType
00000a  4606              MOV      r6,r0
;;;610    	uint16_t * pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;611    #if USED_NOISE_HOPPING_FREQ
;;;612    	uint16_t * pBaseImage;
;;;613    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
00000c  4835              LDR      r0,|L10.228|
00000e  4d34              LDR      r5,|L10.224|
000010  6901              LDR      r1,[r0,#0x10]  ; ptAppInfo
000012  7c89              LDRB     r1,[r1,#0x12]
000014  2901              CMP      r1,#1
;;;614    	{
;;;615    		pBaseImage = g_pFingerBaseImage;
000016  bf08              IT       EQ
000018  69c4              LDREQ    r4,[r0,#0x1c]  ; g_pFingerBaseImage
00001a  d000              BEQ      |L10.30|
;;;616    	}
;;;617    	else
;;;618    	{
;;;619    		pBaseImage = (uint16_t *)HAL_GET_HOPP1_BASELINE_IMAGE_PTR() ;
00001c  4c32              LDR      r4,|L10.232|
                  |L10.30|
;;;620    	}
;;;621    //	uint16_t * pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;622    #else /* USED_NOISE_HOPPING_FREQ */
;;;623    	uint16_t * pBaseImage = g_pFingerBaseImage;
;;;624    #endif /* USED_NOISE_HOPPING_FREQ */
;;;625    	
;;;626        if(thisInfo->bIsPalm == 0 && thisInfo->bBlockTracking == NO)
00001e  4831              LDR      r0,|L10.228|
000020  68c0              LDR      r0,[r0,#0xc]  ; thisInfo
000022  f8901fb2          LDRB     r1,[r0,#0xfb2]
000026  2900              CMP      r1,#0
000028  d14f              BNE      |L10.202|
00002a  7801              LDRB     r1,[r0,#0]
00002c  4f2d              LDR      r7,|L10.228|
00002e  2900              CMP      r1,#0
000030  d14b              BNE      |L10.202|
;;;627    	{
;;;628    		if( (mode == FULL_MODE && thisInfo->bLocal_sensing == NO) || 
000032  f1b80f00          CMP      r8,#0
000036  d003              BEQ      |L10.64|
000038  f1b80f02          CMP      r8,#2
00003c  d005              BEQ      |L10.74|
00003e  e044              B        |L10.202|
                  |L10.64|
000040  f8900fb8          LDRB     r0,[r0,#0xfb8]
000044  2800              CMP      r0,#0
000046  d140              BNE      |L10.202|
000048  e00a              B        |L10.96|
                  |L10.74|
00004a  f7fffffe          BL       hal_Info_GetPenDectionEnable
00004e  bbe0              CBNZ     r0,|L10.202|
000050  68f8              LDR      r0,[r7,#0xc]  ; thisInfo
000052  7840              LDRB     r0,[r0,#1]
000054  bbc8              CBNZ     r0,|L10.202|
000056  2e00              CMP      r6,#0
000058  bf04              ITT      EQ
00005a  7838              LDRBEQ   r0,[r7,#0]  ; traking_en
00005c  2800              CMPEQ    r0,#0
00005e  d034              BEQ      |L10.202|
                  |L10.96|
;;;629    		(mode == LOCAL_FINGER_MODE && hal_Info_GetPenDectionEnable() == NO && thisInfo->bBlockTrackingByLocalDelta == NO && 
;;;630    		(eLocalFingerOPType != ACTIVEPEN_TYPE_LOCAL_MS || (eLocalFingerOPType == ACTIVEPEN_TYPE_LOCAL_MS && traking_en))) )
;;;631    		{
;;;632    			alpha = thisModeConf->BaseLine.usIIRCoef;
000060  68b8              LDR      r0,[r7,#8]  ; thisModeConf
;;;633    
;;;634    			//pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;635    			//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;636    			ulFullIdxNum = ROW_MAX * COL_MAX;
;;;637    			for(ulIdx = 0; ulIdx < ulFullIdxNum; ulIdx++)
;;;638    			{
;;;639    				curr_rawdata = (*(pRawImage++));
;;;640    	#if USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS
;;;641    				if(curr_rawdata > 0)
;;;642    	#endif /* USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS */
;;;643    				{
;;;644    					curr_rawdata += (sLFOffsetRow[ulIdx / COL_MAX] + sLFOffsetCol[ulIdx % COL_MAX]);
000062  f8df8088          LDR      r8,|L10.236|
000066  f8df9088          LDR      r9,|L10.240|
00006a  f8b03003          LDRH     r3,[r0,#3]            ;632
00006e  f8dfa084          LDR      r10,|L10.244|
;;;645    					prev_baseline = *(pBaseImage);
;;;646    					curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;647    					*(pBaseImage++) = (uint16_t)curr_baseline;
000072  f8dfb084          LDR      r11,|L10.248|
000076  f04f0100          MOV      r1,#0                 ;637
00007a  f44f6261          MOV      r2,#0xe10             ;637
00007e  f1c30064          RSB      r0,r3,#0x64
000082  bf00              NOP                            ;644
                  |L10.132|
000084  fba87c01          UMULL    r7,r12,r8,r1          ;644
000088  ea4f1c9c          LSR      r12,r12,#6            ;644
00008c  1e52              SUBS     r2,r2,#1
00008e  f939701c          LDRSH    r7,[r9,r12,LSL #1]    ;644
000092  f1cc0c00          RSB      r12,r12,#0            ;644
000096  eb0c0c8c          ADD      r12,r12,r12,LSL #2    ;644
00009a  eb011c0c          ADD      r12,r1,r12,LSL #4     ;644
00009e  f1010101          ADD      r1,r1,#1
0000a2  f93ac01c          LDRSH    r12,[r10,r12,LSL #1]  ;644
0000a6  44bc              ADD      r12,r12,r7            ;644
0000a8  f8357b02          LDRH     r7,[r5],#2            ;644
0000ac  44bc              ADD      r12,r12,r7            ;644
0000ae  8827              LDRH     r7,[r4,#0]
0000b0  fb07f703          MUL      r7,r7,r3
0000b4  fb007c0c          MLA      r12,r0,r12,r7
0000b8  fb8b7c0c          SMULL    r7,r12,r11,r12
0000bc  ea4f176c          ASR      r7,r12,#5
0000c0  eba77cec          SUB      r12,r7,r12,ASR #31
0000c4  f824cb02          STRH     r12,[r4],#2
;;;648    				}
;;;649    			}
0000c8  d1dc              BNE      |L10.132|
                  |L10.202|
;;;650    		}
;;;651    	}
;;;652    	
;;;653    	if(traking_en==0 && eLocalFingerOPType == ACTIVEPEN_TYPE_LOCAL_MS)traking_en=1;
0000ca  4806              LDR      r0,|L10.228|
0000cc  7801              LDRB     r1,[r0,#0]  ; traking_en
0000ce  4331              ORRS     r1,r1,r6
0000d0  bf04              ITT      EQ
0000d2  2101              MOVEQ    r1,#1
0000d4  7001              STRBEQ   r1,[r0,#0]
;;;654    	
;;;655    	thisInfo->bBlockTrackingByLocalDelta = NO;  
0000d6  2100              MOVS     r1,#0
0000d8  68c0              LDR      r0,[r0,#0xc]  ; thisInfo
0000da  7041              STRB     r1,[r0,#1]
;;;656    }
0000dc  e8bd9ff0          POP      {r4-r12,pc}
;;;657    
                          ENDP

                  |L10.224|
                          DCD      FullSharedBuff
                  |L10.228|
                          DCD      ||.data||
                  |L10.232|
                          DCD      FullSharedBuff+0x5460
                  |L10.236|
                          DCD      0xcccccccd
                  |L10.240|
                          DCD      sLFOffsetRow
                  |L10.244|
                          DCD      sLFOffsetCol
                  |L10.248|
                          DCD      0x51eb851f

                          AREA ||i.algorithm_baseline_tracking_continuous_S3||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous_S3 PROC
;;;1942   
;;;1943   void algorithm_baseline_tracking_continuous_S3(void)
000000  481a              LDR      r0,|L11.108|
;;;1944   {
;;;1945   	uint32_t ulIdx;
;;;1946   	uint32_t ulS3IdxNum;
;;;1947   	uint16_t * pS3RawImage;
;;;1948   	uint16_t * pS3BaseImage;
;;;1949   	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;1950   
;;;1951       if(thisInfo->bBlockTracking == NO)
000002  68c1              LDR      r1,[r0,#0xc]  ; thisInfo
000004  7809              LDRB     r1,[r1,#0]
000006  2900              CMP      r1,#0
;;;1952       {
;;;1953       	ulS3IdxNum = COL_MAX * NI_ROW_MAX;
;;;1954   		alpha = thisModeConf->BaseLine.usIIRCoef;
;;;1955   
;;;1956   		pS3RawImage = HAL_NI_GET_RAW_IMAGE_PTR();
;;;1957   		pS3BaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
;;;1958   		for(ulIdx = 0; ulIdx < ulS3IdxNum; ulIdx++)
;;;1959   		{
;;;1960   			curr_rawdata = (*(pS3RawImage++)) + sLFOffsetRow[ulIdx / COL_MAX];
;;;1961   			prev_baseline = (*pS3BaseImage);
;;;1962   			curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;1963   			*(pS3BaseImage++) = (uint16_t)curr_baseline;
;;;1964   		}
;;;1965       }
;;;1966   }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  e92d47f0          PUSH     {r4-r10,lr}           ;1944
000010  6880              LDR      r0,[r0,#8]            ;1954  ; thisModeConf
000012  4c17              LDR      r4,|L11.112|
000014  f8b05003          LDRH     r5,[r0,#3]            ;1954
000018  f7fffffe          BL       HAL_GetSensingMode
00001c  2101              MOVS     r1,#1                 ;1957
00001e  f7fffffe          BL       HAL_GetBaseImagePointer
000022  4e14              LDR      r6,|L11.116|
000024  4f14              LDR      r7,|L11.120|
000026  f8df8054          LDR      r8,|L11.124|
00002a  2100              MOVS     r1,#0                 ;1958
00002c  f44f7248          MOV      r2,#0x320             ;1958
000030  f1c50c64          RSB      r12,r5,#0x64          ;1963
                  |L11.52|
000034  fba69301          UMULL    r9,r3,r6,r1           ;1960
000038  099b              LSRS     r3,r3,#6              ;1960
00003a  f8349b02          LDRH     r9,[r4],#2            ;1960
00003e  f9373013          LDRSH    r3,[r7,r3,LSL #1]     ;1960
000042  1c49              ADDS     r1,r1,#1              ;1963
000044  444b              ADD      r3,r3,r9              ;1960
000046  f8b09000          LDRH     r9,[r0,#0]            ;1963
00004a  1e52              SUBS     r2,r2,#1              ;1963
00004c  fb09f905          MUL      r9,r9,r5              ;1963
000050  fb0c9303          MLA      r3,r12,r3,r9          ;1963
000054  fb889303          SMULL    r9,r3,r8,r3           ;1963
000058  ea4f1963          ASR      r9,r3,#5              ;1963
00005c  eba973e3          SUB      r3,r9,r3,ASR #31      ;1963
000060  f8203b02          STRH     r3,[r0],#2            ;1963
000064  d1e6              BNE      |L11.52|
000066  e8bd87f0          POP      {r4-r10,pc}
;;;1967   
                          ENDP

00006a  0000              DCW      0x0000
                  |L11.108|
                          DCD      ||.data||
                  |L11.112|
                          DCD      FullSharedBuff
                  |L11.116|
                          DCD      0xcccccccd
                  |L11.120|
                          DCD      sLFOffsetRow
                  |L11.124|
                          DCD      0x51eb851f

                          AREA ||i.algorithm_baseline_tracking_continuous_local_ring||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous_local_ring PROC
;;;658    extern uint16_t sensingRowStart_Tilt;
;;;659    void algorithm_baseline_tracking_continuous_local_ring(void)
000000  4816              LDR      r0,|L12.92|
;;;660    {
;;;661    	int r,c,read_raw_data;
;;;662    	if(thisModeConf->PenTilt.bRingBaseTracking)
000002  6880              LDR      r0,[r0,#8]  ; thisModeConf
000004  f8900162          LDRB     r0,[r0,#0x162]
000008  2800              CMP      r0,#0
;;;663    	{		
;;;664    		for( r=0; r<PEN_COORD_ROW_MAX; r++ )
;;;665    		{
;;;666    			for( c=0; c<COL_MAX; c++ )
;;;667    			{
;;;668    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)	
;;;669    				read_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r,c);
;;;670    #else
;;;671    				read_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r+PEN_COORD_ROW_MAX,c);
;;;672    #endif
;;;673    				HAL_WRITE_RING_BASELINE_IMAGE(r+sensingRowStart_Tilt,c,(HAL_READ_RING_BASELINE_IMAGE(r+sensingRowStart_Tilt,c) + read_raw_data)>>1);
;;;674    			}
;;;675    		}
;;;676    	}
;;;677    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)		
;;;678    	if(sensingRowStart_Tilt >= MUX_MAX_ROW)
;;;679    	{
;;;680    		sensingRowStart_Tilt = 0;
;;;681    	}
;;;682    	else
;;;683    	{
;;;684    		sensingRowStart_Tilt += PEN_COORD_ROW_MAX;
;;;685    		if(sensingRowStart_Tilt > MUX_MAX_ROW)
;;;686    			sensingRowStart_Tilt = MUX_MAX_ROW;
;;;687    	}
;;;688    #endif
;;;689    }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  b430              PUSH     {r4,r5}               ;660
000010  2000              MOVS     r0,#0                 ;664
000012  4913              LDR      r1,|L12.96|
000014  4c13              LDR      r4,|L12.100|
000016  8809              LDRH     r1,[r1,#0]            ;673
000018  eb010181          ADD      r1,r1,r1,LSL #2       ;673
00001c  eb041241          ADD      r2,r4,r1,LSL #5       ;673
                  |L12.32|
000020  eb020140          ADD      r1,r2,r0,LSL #1       ;673
000024  f5014110          ADD      r1,r1,#0x9000         ;673
000028  eb040340          ADD      r3,r4,r0,LSL #1       ;673
00002c  f8b1cbd8          LDRH     r12,[r1,#0xbd8]       ;673
000030  f8b35960          LDRH     r5,[r3,#0x960]        ;673
000034  f8b33962          LDRH     r3,[r3,#0x962]        ;673
000038  44ac              ADD      r12,r12,r5            ;673
00003a  f8b15bda          LDRH     r5,[r1,#0xbda]        ;673
00003e  ea4f0c5c          LSR      r12,r12,#1            ;673
000042  442b              ADD      r3,r3,r5              ;673
000044  085b              LSRS     r3,r3,#1              ;673
000046  f8a1cbd8          STRH     r12,[r1,#0xbd8]       ;673
00004a  1c80              ADDS     r0,r0,#2              ;673
00004c  f8a13bda          STRH     r3,[r1,#0xbda]        ;673
000050  f5b07fc8          CMP      r0,#0x190             ;673
000054  dbe4              BLT      |L12.32|
000056  bc30              POP      {r4,r5}
000058  4770              BX       lr
;;;690    
                          ENDP

00005a  0000              DCW      0x0000
                  |L12.92|
                          DCD      ||.data||
                  |L12.96|
                          DCD      sensingRowStart_Tilt
                  |L12.100|
                          DCD      LocalSharedBuff

                          AREA ||i.algorithm_baseline_tracking_initial||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial PROC
;;;93     #endif
;;;94     void algorithm_baseline_tracking_initial(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;95     {
;;;96     	uint32_t ulFrameNum, ulIdx;
;;;97     	uint32_t ulFullIdxNum;
;;;98     #ifdef SHORT_COMPENSATION
;;;99         int diff;
;;;100        uint16_t raw_diff_thd = 500;
;;;101    #endif
;;;102        uint16_t temp_data, raw_val = 500;
;;;103    #ifdef SHORT_COMPENSATION
;;;104    	uint32_t raw_avg = 0;
;;;105    	short_cnt = 0;
;;;106    	memset(short_pos, 0, sizeof(short_pos));
;;;107    #endif
;;;108    	uint16_t * pRawImage;
;;;109    	uint16_t * pInitRawImage;
;;;110    	uint16_t * pBaseImage;
;;;111    	uint16_t * pInitBaseImage;
;;;112    	
;;;113        for (ulFrameNum = 0; ulFrameNum < thisModeConf->BaseLine.ucDiscardFrameNum; ulFrameNum++)
000004  4f28              LDR      r7,|L13.168|
000006  2400              MOVS     r4,#0
000008  68b8              LDR      r0,[r7,#8]  ; thisModeConf
00000a  7840              LDRB     r0,[r0,#1]
00000c  2800              CMP      r0,#0
00000e  d906              BLS      |L13.30|
                  |L13.16|
;;;114    	{
;;;115    		module_wait_full_sample_done();
000010  f7fffffe          BL       module_wait_full_sample_done
000014  68b8              LDR      r0,[r7,#8]  ; thisModeConf
000016  1c64              ADDS     r4,r4,#1
000018  7840              LDRB     r0,[r0,#1]
00001a  42a0              CMP      r0,r4
00001c  d8f8              BHI      |L13.16|
                  |L13.30|
;;;116    	}
;;;117    
;;;118    #ifdef MODE_WDT				
;;;119    	KICK_DOG();
00001e  f7fffffe          BL       Hal_Kick_DOG
;;;120    #endif
;;;121    
;;;122    	pInitRawImage = pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;123    #if USED_NOISE_HOPPING_FREQ
;;;124    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
000022  6938              LDR      r0,[r7,#0x10]  ; ptAppInfo
000024  4d21              LDR      r5,|L13.172|
000026  7c80              LDRB     r0,[r0,#0x12]
000028  2801              CMP      r0,#1
;;;125    	{
;;;126    		pInitBaseImage = pBaseImage = g_pFingerBaseImage;
00002a  bf0f              ITEEE    EQ
00002c  69f8              LDREQ    r0,[r7,#0x1c]  ; g_pFingerBaseImage
;;;127    	}
;;;128    	else
;;;129    	{
;;;130    		pInitBaseImage = pBaseImage = (uint16_t *)HAL_GET_HOPP1_BASELINE_IMAGE_PTR() ;
00002e  481f              LDRNE    r0,|L13.172|
000030  f2454160          MOVNE    r1,#0x5460
000034  4408              ADDNE    r0,r1
000036  4604              MOV      r4,r0
;;;131    	}
;;;132    //	pInitBaseImage = pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;133    #else /* USED_NOISE_HOPPING_FREQ */
;;;134    	pInitBaseImage = pBaseImage = g_pFingerBaseImage;//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;135    #endif /* USED_NOISE_HOPPING_FREQ */
;;;136    	memset((void*)pBaseImage, 0x00, sizeof(uint16_t)*(ROW_MAX * COL_MAX));
000038  f44f51e1          MOV      r1,#0x1c20
00003c  f7fffffe          BL       __aeabi_memclr
;;;137    	ulFullIdxNum = ROW_MAX * COL_MAX;
;;;138    
;;;139        for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
000040  68b8              LDR      r0,[r7,#8]  ; thisModeConf
000042  7880              LDRB     r0,[r0,#2]
000044  1e46              SUBS     r6,r0,#1
000046  d317              BCC      |L13.120|
                  |L13.72|
;;;140        {
;;;141    		module_wait_full_sample_done();
000048  f7fffffe          BL       module_wait_full_sample_done
;;;142    		pRawImage = pInitRawImage;
;;;143    		pBaseImage = pInitBaseImage;
;;;144    		for(ulIdx = ulFullIdxNum; ulIdx--; )
00004c  1ea1              SUBS     r1,r4,#2
00004e  1eaa              SUBS     r2,r5,#2
000050  f44f63e1          MOV      r3,#0x708
                  |L13.84|
;;;145    		{
;;;146    			raw_val = *(pRawImage++);
;;;147    			temp_data = *(pBaseImage) + raw_val;
;;;148    			*(pBaseImage++) = temp_data;
000054  f8310f02          LDRH     r0,[r1,#2]!
000058  f8b2c002          LDRH     r12,[r2,#2]
00005c  1e5b              SUBS     r3,r3,#1
00005e  4460              ADD      r0,r0,r12
000060  f8210b02          STRH     r0,[r1],#2
000064  f832cf04          LDRH     r12,[r2,#4]!
000068  8808              LDRH     r0,[r1,#0]
00006a  4460              ADD      r0,r0,r12
00006c  8008              STRH     r0,[r1,#0]
00006e  d1f1              BNE      |L13.84|
;;;149    #ifdef SHORT_COMPENSATION
;;;150    			raw_avg += raw_val;
;;;151    #endif
;;;152    		}
;;;153    
;;;154    #ifdef MODE_WDT				
;;;155    		KICK_DOG();
000070  f7fffffe          BL       Hal_Kick_DOG
000074  1e76              SUBS     r6,r6,#1
000076  d2e7              BCS      |L13.72|
                  |L13.120|
;;;156    #endif
;;;157        }
;;;158    
;;;159    #ifdef SHORT_COMPENSATION
;;;160    	raw_avg /= (ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;161    #endif
;;;162    
;;;163    	pBaseImage = pInitBaseImage;
;;;164    	for(ulIdx = ulFullIdxNum; ulIdx--; )
;;;165    	{
;;;166    		temp_data = (*pBaseImage);
;;;167    		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
000078  68ba              LDR      r2,[r7,#8]  ; thisModeConf
00007a  1ea0              SUBS     r0,r4,#2              ;164
00007c  f44f61e1          MOV      r1,#0x708             ;164
                  |L13.128|
000080  f8303f02          LDRH     r3,[r0,#2]!
000084  f892c002          LDRB     r12,[r2,#2]
;;;168    		(*pBaseImage++) = temp_data;
000088  1e49              SUBS     r1,r1,#1
00008a  fbb3f3fc          UDIV     r3,r3,r12             ;167
00008e  f8203b02          STRH     r3,[r0],#2
000092  f892c002          LDRB     r12,[r2,#2]           ;167
000096  8803              LDRH     r3,[r0,#0]            ;167
000098  fbb3f3fc          UDIV     r3,r3,r12             ;167
00009c  8003              STRH     r3,[r0,#0]
00009e  d1ef              BNE      |L13.128|
;;;169    #ifdef SHORT_COMPENSATION
;;;170    		diff = raw_avg - temp_data;
;;;171    		if( diff > raw_diff_thd && short_cnt < SHORT_NUM )
;;;172    		{
;;;173    			short_pos[short_cnt].c = c;
;;;174    			short_pos[short_cnt].r = r;
;;;175    			short_cnt++;
;;;176    		}
;;;177    #endif
;;;178    	}
;;;179    
;;;180    #ifdef MODE_WDT				
;;;181    	KICK_DOG();
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  f7ffbffe          B.W      Hal_Kick_DOG
;;;182    #endif
;;;183    }
;;;184    
                          ENDP

                  |L13.168|
                          DCD      ||.data||
                  |L13.172|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_tracking_initial_S3||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial_S3 PROC
;;;1849   #if USED_MNT_S3_MODE_FUNCTION
;;;1850   void algorithm_baseline_tracking_initial_S3(bool_t bIsSkip)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1851   {
;;;1852   	uint32_t ulFrameNum, ulIdx;
;;;1853   	uint32_t ulNiIdxNum;
;;;1854   	uint32_t ulSkipFrameNum;
;;;1855   #ifdef SHORT_COMPENSATION
;;;1856       int diff;
;;;1857       uint16_t raw_diff_thd = 500;
;;;1858   #endif
;;;1859       uint16_t temp_data, raw_val = 500;
;;;1860   #ifdef SHORT_COMPENSATION
;;;1861   	uint32_t raw_avg = 0;
;;;1862   	uint32_t raw_avg_Ni_1 = 0,  raw_avg_Ni_2 = 0;
;;;1863   	short_cnt = 0;
;;;1864   	memset(short_pos, 0, sizeof(short_pos));
;;;1865   #endif
;;;1866   	uint16_t * pNiRawImage;
;;;1867   	uint16_t * pNiInitRawImage;
;;;1868   	uint16_t * pNiBaseImage;
;;;1869   	uint16_t * pNiInitBaseImage;
;;;1870   
;;;1871   	if(bIsSkip)
;;;1872   	{
;;;1873   		ulSkipFrameNum = thisModeConf->BaseLine.ucDiscardFrameNum;
000004  4e28              LDR      r6,|L14.168|
000006  2800              CMP      r0,#0                 ;1871
;;;1874   	}
;;;1875   	else
;;;1876   	{
;;;1877   		ulSkipFrameNum = 3;
000008  bf04              ITT      EQ
00000a  2503              MOVEQ    r5,#3
;;;1878   	}
;;;1879   
;;;1880       for(ulFrameNum=0; ulFrameNum<ulSkipFrameNum; ulFrameNum++)
00000c  2400              MOVEQ    r4,#0
00000e  d004              BEQ      |L14.26|
000010  68b0              LDR      r0,[r6,#8]            ;1873  ; thisModeConf
000012  2400              MOVS     r4,#0
000014  7845              LDRB     r5,[r0,#1]            ;1873
000016  2d00              CMP      r5,#0
000018  d904              BLS      |L14.36|
                  |L14.26|
;;;1881       {
;;;1882       	module_wait_S3_sample_done();
00001a  f7fffffe          BL       module_wait_S3_sample_done
00001e  1c64              ADDS     r4,r4,#1
000020  42a5              CMP      r5,r4
000022  d8fa              BHI      |L14.26|
                  |L14.36|
;;;1883       }
;;;1884   
;;;1885   #ifdef MODE_WDT
;;;1886   	KICK_DOG();
000024  f7fffffe          BL       Hal_Kick_DOG
;;;1887   #endif
;;;1888   
;;;1889   	pNiInitRawImage = pNiRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
000028  4d20              LDR      r5,|L14.172|
;;;1890   	pNiInitBaseImage = pNiBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
00002a  f7fffffe          BL       HAL_GetSensingMode
00002e  2101              MOVS     r1,#1
000030  f7fffffe          BL       HAL_GetBaseImagePointer
000034  4604              MOV      r4,r0
;;;1891       memset((void*)pNiBaseImage, 0x00, sizeof(uint16_t)*(NI_ROW_MAX * COL_MAX));
000036  f44f61c8          MOV      r1,#0x640
00003a  f7fffffe          BL       __aeabi_memclr
;;;1892       ulNiIdxNum = NI_ROW_MAX * COL_MAX;
;;;1893   
;;;1894       for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
00003e  68b0              LDR      r0,[r6,#8]  ; thisModeConf
000040  7880              LDRB     r0,[r0,#2]
000042  1e47              SUBS     r7,r0,#1
000044  d318              BCC      |L14.120|
;;;1895       {
;;;1896       	module_wait_S3_sample_done();
000046  bf00              NOP      
                  |L14.72|
000048  f7fffffe          BL       module_wait_S3_sample_done
;;;1897   
;;;1898   		pNiRawImage = pNiInitRawImage;
;;;1899   		pNiBaseImage = pNiInitBaseImage;
;;;1900   		for(ulIdx = ulNiIdxNum; ulIdx--; )
00004c  1ea1              SUBS     r1,r4,#2
00004e  1eaa              SUBS     r2,r5,#2
000050  f44f73c8          MOV      r3,#0x190
                  |L14.84|
;;;1901   		{
;;;1902   			raw_val = *(pNiRawImage++);
;;;1903   			temp_data = *(pNiBaseImage) + raw_val;
;;;1904   			*(pNiBaseImage++) = temp_data;
000054  f8310f02          LDRH     r0,[r1,#2]!
000058  f8b2c002          LDRH     r12,[r2,#2]
00005c  1e5b              SUBS     r3,r3,#1
00005e  4460              ADD      r0,r0,r12
000060  f8210b02          STRH     r0,[r1],#2
000064  f832cf04          LDRH     r12,[r2,#4]!
000068  8808              LDRH     r0,[r1,#0]
00006a  4460              ADD      r0,r0,r12
00006c  8008              STRH     r0,[r1,#0]
00006e  d1f1              BNE      |L14.84|
;;;1905   #ifdef SHORT_COMPENSATION
;;;1906   			raw_avg_Ni_1 += raw_val;
;;;1907   #endif
;;;1908   		}
;;;1909   
;;;1910   #ifdef MODE_WDT
;;;1911   		KICK_DOG();
000070  f7fffffe          BL       Hal_Kick_DOG
000074  1e7f              SUBS     r7,r7,#1
000076  d2e7              BCS      |L14.72|
                  |L14.120|
;;;1912   #endif
;;;1913       }
;;;1914   
;;;1915   #ifdef SHORT_COMPENSATION
;;;1916   	raw_avg /= (ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1917   	raw_avg_Ni_1 /= (NI_ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1918   	raw_avg_Ni_2 /= (NI_ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;1919   #endif
;;;1920   
;;;1921   	pNiBaseImage = pNiInitBaseImage;
;;;1922   	for(ulIdx = ulNiIdxNum; ulIdx--; )
;;;1923   	{
;;;1924   		temp_data = (*pNiBaseImage);
;;;1925   		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
000078  68b2              LDR      r2,[r6,#8]  ; thisModeConf
00007a  1ea0              SUBS     r0,r4,#2              ;1922
00007c  f44f71c8          MOV      r1,#0x190             ;1922
                  |L14.128|
000080  f8303f02          LDRH     r3,[r0,#2]!
000084  f892c002          LDRB     r12,[r2,#2]
;;;1926   		(*pNiBaseImage++) = temp_data;
000088  1e49              SUBS     r1,r1,#1
00008a  fbb3f3fc          UDIV     r3,r3,r12             ;1925
00008e  f8203b02          STRH     r3,[r0],#2
000092  f892c002          LDRB     r12,[r2,#2]           ;1925
000096  8803              LDRH     r3,[r0,#0]            ;1925
000098  fbb3f3fc          UDIV     r3,r3,r12             ;1925
00009c  8003              STRH     r3,[r0,#0]
00009e  d1ef              BNE      |L14.128|
;;;1927   #ifdef SHORT_COMPENSATION
;;;1928   		diff = raw_avg_Ni_1 - temp_data;
;;;1929   		if( diff > raw_diff_thd && short_cnt < SHORT_NUM )
;;;1930   		{
;;;1931   			short_pos[short_cnt].c = c;
;;;1932   			short_pos[short_cnt].r = r;
;;;1933   			short_cnt++;
;;;1934   		}
;;;1935   #endif
;;;1936   	}
;;;1937   
;;;1938   #ifdef MODE_WDT
;;;1939   	KICK_DOG();
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  f7ffbffe          B.W      Hal_Kick_DOG
;;;1940   #endif
;;;1941   }
;;;1942   
                          ENDP

                  |L14.168|
                          DCD      ||.data||
                  |L14.172|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_tracking_initial_local||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial_local PROC
;;;186    
;;;187    bool_t algorithm_baseline_tracking_initial_local(uint8_t OP_TYPE)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;188    {
000004  b083              SUB      sp,sp,#0xc
;;;189    	int r, c , r_pos;
;;;190    //	uint32_t ulRowEnd = PEN_COORD_ROW_MAX;
;;;191    	int ulRowEnd = PEN_COORD_ROW_MAX;
000006  2505              MOVS     r5,#5
;;;192    	uint16_t temp_data = 0;
;;;193    	ePartialSensing_t lDataIndex = PARTIAL_PEN_BEACON;
;;;194    	bool_t local_base_return_flag = NO;
;;;195        int finger_div = ((ROW_MAX + (PEN_COORD_ROW_MAX - 1)) / PEN_COORD_ROW_MAX);
;;;196    //	uint16_t * pPenBaseImage;
;;;197    //	uint16_t * pFingerBaseImage;
;;;198    
;;;199    //	if(OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS)
;;;200    //	{
;;;201    //		pPenBaseImage = HAL_GET_LOCAL_BASELINE_IMAGE_PTR();
;;;202    //		pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;203    //	}
;;;204    //	else
;;;205    //	{
;;;206    //#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;207    //		pPenBaseImage = HAL_GET_LOCAL_BASELINE_IMAGE_PTR();
;;;208    //		pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR();
;;;209    //#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;210    //		pPenBaseImage = HAL_GET_LOCAL_BASELINE_IMAGE_2_PTR();
;;;211    //		pFingerBaseImage = HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_2_PTR();
;;;212    //#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;213    //	}
;;;214    	
;;;215    	sensingRowStart = 0;
000008  f8dfb200          LDR      r11,|L15.524|
00000c  2000              MOVS     r0,#0                 ;194
00000e  9001              STR      r0,[sp,#4]
000010  f04f0809          MOV      r8,#9                 ;195
000014  f8ab0000          STRH     r0,[r11,#0]
;;;216    
;;;217    	module_wait_Vsync_signal(LOCAL_MODE, thisModeConf->BaseLine.ucDiscardFrameNum);
000018  f8df91f4          LDR      r9,|L15.528|
00001c  f8d90008          LDR      r0,[r9,#8]  ; thisModeConf
000020  7841              LDRB     r1,[r0,#1]
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       module_wait_Vsync_signal
;;;218    
;;;219    	uint16_t * pPenBaseImage = g_pLocalBaseImage;
000028  487a              LDR      r0,|L15.532|
;;;220    	uint16_t * pFingerBaseImage = g_pFingerBaseImage;
00002a  f8d9601c          LDR      r6,[r9,#0x1c]  ; g_pFingerBaseImage
00002e  6804              LDR      r4,[r0,#0]  ; g_pLocalBaseImage
                  |L15.48|
;;;221    	
;;;222        while(YES)
;;;223        {
;;;224    		lDataIndex = module_wait_local_sample_done();
000030  f7fffffe          BL       module_wait_local_sample_done
;;;225    
;;;226    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;227    		if((lDataIndex == LOCAL_OP_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS) || (lDataIndex == LOCAL_OP_2_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_WGP))
;;;228    #else
;;;229    		if(lDataIndex == LOCAL_OP_LAST_LHB || lDataIndex == PARTIAL_MAX)
000034  2808              CMP      r0,#8
000036  bf18              IT       NE
000038  2816              CMPNE    r0,#0x16
00003a  d1f9              BNE      |L15.48|
;;;230    #endif
;;;231    		{
;;;232    			break;
;;;233    		}
;;;234    	}
;;;235    
;;;236        tHalIntrHandle.ulLocalIndexChangeStart = 1;
00003c  4976              LDR      r1,|L15.536|
00003e  f04f0001          MOV      r0,#1
000042  6088              STR      r0,[r1,#8]  ; tHalIntrHandle
;;;237    
;;;238    	uint8_t BaseOffset = thisModeConf->BaseLine.ucPP_MUX_Select * PEN_COORD_ROW_MAX;
000044  f8d91008          LDR      r1,[r9,#8]  ; thisModeConf
000048  f8910042          LDRB     r0,[r1,#0x42]
;;;239    	if(thisModeConf->BaseLine.bPen_2BASE == 1 && thisModeConf->BaseLine.ucPP_MUX_Select > 0)
00004c  f891103e          LDRB     r1,[r1,#0x3e]
000050  eb000280          ADD      r2,r0,r0,LSL #2       ;238
000054  b2d7              UXTB     r7,r2                 ;238
000056  2901              CMP      r1,#1
000058  d103              BNE      |L15.98|
00005a  2800              CMP      r0,#0
;;;240    		BaseOffset -= PEN_COORD_ROW_MAX;
00005c  bf1c              ITT      NE
00005e  1f78              SUBNE    r0,r7,#5
000060  b2c7              UXTBNE   r7,r0
                  |L15.98|
;;;241    	
;;;242    	while(YES)
;;;243    	{
;;;244    		lDataIndex = module_wait_local_sample_done();
000062  f7fffffe          BL       module_wait_local_sample_done
;;;245    
;;;246    		switch(lDataIndex)
000066  9000              STR      r0,[sp,#0]
000068  2806              CMP      r0,#6
00006a  d0fa              BEQ      |L15.98|
00006c  dc08              BGT      |L15.128|
00006e  2801              CMP      r0,#1
000070  bf18              IT       NE
000072  2802              CMPNE    r0,#2
000074  d00b              BEQ      |L15.142|
000076  2803              CMP      r0,#3
000078  bf18              IT       NE
00007a  2804              CMPNE    r0,#4
00007c  d007              BEQ      |L15.142|
00007e  e06f              B        |L15.352|
                  |L15.128|
000080  2807              CMP      r0,#7
000082  bf18              IT       NE
000084  2808              CMPNE    r0,#8
000086  d06b              BEQ      |L15.352|
000088  280c              CMP      r0,#0xc
00008a  d045              BEQ      |L15.280|
00008c  e068              B        |L15.352|
                  |L15.142|
;;;247    		{
;;;248    			case PARTIAL_PEN_COORD1:
;;;249    			case PARTIAL_PEN_COORD2:
;;;250    			case PARTIAL_PEN_COORD3:
;;;251    			case PARTIAL_PEN_COORD4:
;;;252    			{
;;;253    				int temp_raw_data;
;;;254    
;;;255    #if USED_PANEL_HV60x34_SIZE
;;;256    				if(sensingRowStart == 30)
;;;257    				{
;;;258    					ulRowEnd = PEN_COORD_ROW_MAX-1;
;;;259    				}
;;;260    #endif /* USED_PANEL_HV60x34_SIZE */
;;;261    				for(r = 0; r < ulRowEnd; r++)
00008e  2100              MOVS     r1,#0
000090  2d00              CMP      r5,#0
000092  dd65              BLE      |L15.352|
;;;262    				{
;;;263    					r_pos = (r+sensingRowStart)*COL_MAX;
;;;264    					for(c = 0; c < COL_MAX; c++)
;;;265    					{
;;;266    						temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r+BaseOffset, c);
;;;267    						temp_data = pPenBaseImage[r_pos+c] + temp_raw_data; //HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;268    						pPenBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;269    						
;;;270    						if(thisModeConf->BaseLine.bPen_2BASE == 1)
000094  485e              LDR      r0,|L15.528|
000096  4a5d              LDR      r2,|L15.524|
000098  f8d0a008          LDR      r10,[r0,#8]           ;215  ; thisModeConf
                  |L15.156|
00009c  8810              LDRH     r0,[r2,#0]            ;263  ; sensingRowStart
00009e  f8dfc17c          LDR      r12,|L15.540|
0000a2  4408              ADD      r0,r0,r1              ;263
0000a4  eb000080          ADD      r0,r0,r0,LSL #2       ;263
0000a8  ea4f1900          LSL      r9,r0,#4              ;263
0000ac  2000              MOVS     r0,#0                 ;264
0000ae  19cb              ADDS     r3,r1,r7              ;266
0000b0  eb030383          ADD      r3,r3,r3,LSL #2       ;266
0000b4  eb0c1343          ADD      r3,r12,r3,LSL #5      ;266
                  |L15.184|
0000b8  eb090c00          ADD      r12,r9,r0             ;267
0000bc  f833b010          LDRH     r11,[r3,r0,LSL #1]    ;266
0000c0  f834e01c          LDRH     lr,[r4,r12,LSL #1]    ;267
0000c4  44f3              ADD      r11,r11,lr            ;267
0000c6  f824b01c          STRH     r11,[r4,r12,LSL #1]   ;268
0000ca  f89ac03e          LDRB     r12,[r10,#0x3e]
0000ce  f1bc0f01          CMP      r12,#1
0000d2  d11a              BNE      |L15.266|
;;;271    						{
;;;272    							temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r+BaseOffset+PEN_COORD_ROW_MAX, c);
0000d4  eb030c40          ADD      r12,r3,r0,LSL #1
;;;273    							temp_data = pPenBaseImage[(r+sensingRowStart+ROW_MAX)*COL_MAX+c] + temp_raw_data; //HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c) + temp_raw_data;
0000d8  f8b2b000          LDRH     r11,[r2,#0]  ; sensingRowStart
0000dc  f8bcc320          LDRH     r12,[r12,#0x320]      ;272
0000e0  448b              ADD      r11,r11,r1
0000e2  f10b0b2d          ADD      r11,r11,#0x2d
0000e6  eb0b0b8b          ADD      r11,r11,r11,LSL #2
0000ea  eb001b0b          ADD      r11,r0,r11,LSL #4
0000ee  f834b01b          LDRH     r11,[r4,r11,LSL #1]
0000f2  44dc              ADD      r12,r12,r11
;;;274    							pPenBaseImage[(r+sensingRowStart+ROW_MAX)*COL_MAX+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c, temp_data);		
0000f4  f8b2b000          LDRH     r11,[r2,#0]  ; sensingRowStart
0000f8  448b              ADD      r11,r11,r1
0000fa  f10b0b2d          ADD      r11,r11,#0x2d
0000fe  eb0b0b8b          ADD      r11,r11,r11,LSL #2
000102  eb001b0b          ADD      r11,r0,r11,LSL #4
000106  f824c01b          STRH     r12,[r4,r11,LSL #1]
                  |L15.266|
00010a  1c40              ADDS     r0,r0,#1
00010c  2850              CMP      r0,#0x50
00010e  dbd3              BLT      |L15.184|
000110  1c49              ADDS     r1,r1,#1
000112  42a9              CMP      r1,r5
000114  dbc2              BLT      |L15.156|
000116  e023              B        |L15.352|
                  |L15.280|
;;;275    						}
;;;276    
;;;277    #if ((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)) && defined(TILT_ON)
;;;278    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;279    						if(OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS)
;;;280    	#endif
;;;281    						{
;;;282    	//						if(lDataIndex == PARTIAL_PEN_COORD1)// || lDataIndex == PARTIAL_PEN_COORD3)
;;;283    	//						{
;;;284    	//							temp_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r+PEN_COORD_ROW_MAX, c);
;;;285    	//							temp_data = HAL_READ_RING_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c) + temp_raw_data;
;;;286    	//							HAL_WRITE_RING_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c, temp_data);
;;;287    	//						}
;;;288    						
;;;289    							if(/*lDataIndex == PARTIAL_PEN_COORD1 ||*/ lDataIndex == PARTIAL_PEN_COORD3)
;;;290    							{
;;;291    								temp_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r+PEN_COORD_ROW_MAX, c);
;;;292    								temp_data = HAL_READ_RING_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;293    								HAL_WRITE_RING_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;294    							}
;;;295    							
;;;296    	#if LOCAL_REBASE_ALGO_EN && (USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN)
;;;297    							if(lDataIndex == PARTIAL_PEN_COORD1)
;;;298    							{							
;;;299    								temp_raw_data = HAL_READ_LOCAL_RAW_IMAGE(r,c);
;;;300    								temp_data = HAL_READ_RECAL_BASELINE_IMAGE(r+ sensingRowStart,c) + temp_raw_data;
;;;301    								HAL_WRITE_RECAL_BASELINE_IMAGE(r+ sensingRowStart, c, temp_data);								
;;;302    							}
;;;303    	#endif
;;;304    						}
;;;305    #endif
;;;306    						/*
;;;307    						 * TODD_1st : 아래 상수값 parameter로 빼자!!
;;;308    						 */
;;;309    //						if(sub_data < 0)
;;;310    //						{
;;;311    //							sub_data = -sub_data;
;;;312    //						}
;;;313    //						if(sub_data > 200)
;;;314    //						{
;;;315    //							g_temp_sum += sub_data;
;;;316    //						}
;;;317    //
;;;318    //						prev_raw_data = temp_raw_data;
;;;319    					}
;;;320    				}
;;;321    
;;;322    //				if(g_temp_sum > 1000)
;;;323    //				{
;;;324    //					local_base_return_flag = YES;
;;;325    //				}
;;;326    				break;
;;;327    			}
;;;328    			
;;;329    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)			
;;;330    			case PARTIAL_PEN_COORD_DATA1:
;;;331    			case PARTIAL_PEN_COORD_DATA2:
;;;332    			case PARTIAL_PEN_COORD_DATA3:
;;;333    			case PARTIAL_PEN_COORD_DATA4:
;;;334    			{
;;;335    				int temp_raw_data;
;;;336    				for(r = 0; r < ulRowEnd; r++)
;;;337    				{
;;;338    					for(c = 0; c < COL_MAX; c++)
;;;339    					{
;;;340    						temp_raw_data = HAL_READ_LOCAL_DATA_RAW_IMAGE_3(r+BaseOffset, c);
;;;341    						temp_data = HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;342    						HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;343    						if(thisModeConf->BaseLine.bPen_2BASE == 1)
;;;344    						{
;;;345    							temp_raw_data = HAL_READ_LOCAL_DATA_RAW_IMAGE_3(r+BaseOffset+PEN_COORD_ROW_MAX, c);
;;;346    							temp_data = HAL_READ_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c) + temp_raw_data;
;;;347    							HAL_WRITE_LOCAL_BASELINE_IMAGE(r + sensingRowStart + ROW_MAX, c, temp_data);		
;;;348    						}							
;;;349    					}
;;;350    				}
;;;351    				break;
;;;352    			}
;;;353    //			case PARTIAL_TILT1:
;;;354    //			{
;;;355    //				int temp_raw_data;
;;;356    //				for(r = 0; r < ulRowEnd; r++)
;;;357    //				{
;;;358    //					for(c = 0; c < COL_MAX; c++)
;;;359    //					{
;;;360    //						temp_raw_data = HAL_READ_LOCAL_RING_RAW_IMAGE(r, c);
;;;361    //						temp_data = HAL_READ_RING_BASELINE_IMAGE(r + sensingRowStart, c) + temp_raw_data;
;;;362    //						HAL_WRITE_RING_BASELINE_IMAGE(r + sensingRowStart, c, temp_data);
;;;363    //					}
;;;364    //				}
;;;365    //				break;
;;;366    //			}
;;;367    #endif /* USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN */			
;;;368    			case LOCAL_FINGER_LAST_LHB:
;;;369    			{
;;;370    				int temp_raw_data;
;;;371    				for (r = 0; r < ROW_MAX; r++)
000118  f04f0c00          MOV      r12,#0
;;;372    				{
;;;373    					r_pos = r*COL_MAX;
;;;374    					for (c = 0; c < COL_MAX; c++)
00011c  f8dfa100          LDR      r10,|L15.544|
000120  4662              MOV      r2,r12                ;371
000122  bf00              NOP      
                  |L15.292|
000124  eb06004c          ADD      r0,r6,r12,LSL #1
000128  eb020182          ADD      r1,r2,r2,LSL #2
00012c  eb0a1141          ADD      r1,r10,r1,LSL #5
000130  1e80              SUBS     r0,r0,#2
000132  f04f0928          MOV      r9,#0x28
000136  1e89              SUBS     r1,r1,#2
                  |L15.312|
;;;375    					{
;;;376    						temp_raw_data = HAL_READ_LOCAL_FINGER_RAW_IMAGE(r, c);
;;;377    #if USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS
;;;378    						if(temp_raw_data == 0)
;;;379    						{
;;;380    							ulZeroFingerRawMaskInfo[r][c/ZERO_FINGER_RAWDATA_MASK_NUM] |= (0x1<<(c%ZERO_FINGER_RAWDATA_MASK_NUM));
;;;381    						}
;;;382    #endif /* USED_ZERO_FINGER_RAWDATA_DONOT_PEN_PROCESS */
;;;383    						temp_data = pFingerBaseImage[r_pos+c] + temp_raw_data; //HAL_READ_LOCAL_FINGER_BASELINE_IMAGE(r, c) + temp_raw_data;
;;;384    						pFingerBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE(r, c, temp_data);
000138  f8303f02          LDRH     r3,[r0,#2]!
00013c  f8b1b002          LDRH     r11,[r1,#2]
000140  f1b90901          SUBS     r9,r9,#1
000144  445b              ADD      r3,r3,r11
000146  f8203b02          STRH     r3,[r0],#2
00014a  f831bf04          LDRH     r11,[r1,#4]!
00014e  8803              LDRH     r3,[r0,#0]
000150  445b              ADD      r3,r3,r11
000152  8003              STRH     r3,[r0,#0]
000154  d1f0              BNE      |L15.312|
000156  1c52              ADDS     r2,r2,#1
000158  f10c0c50          ADD      r12,r12,#0x50
;;;385    					}
00015c  2a2d              CMP      r2,#0x2d
00015e  dbe1              BLT      |L15.292|
                  |L15.352|
;;;386    				}
;;;387    				break;
;;;388    			}
;;;389    			case PARTIAL_PEN_DATA1:
;;;390    			case PARTIAL_PEN_DATA2:
;;;391    			case PARTIAL_PEN_DATA3:
;;;392    			case PARTIAL_PEN_DATA4:
;;;393    			case PARTIAL_MAX:
;;;394    			default:
;;;395    				break;
;;;396    		}
;;;397    
;;;398    		if(lDataIndex == PARTIAL_PEN_COORD4 || lDataIndex == PARTIAL_PEN_COORD_DATA4)
000160  9800              LDR      r0,[sp,#0]
000162  2804              CMP      r0,#4
000164  bf18              IT       NE
000166  2815              CMPNE    r0,#0x15
000168  d113              BNE      |L15.402|
;;;399    		{
;;;400    			sensingRowStart += PEN_COORD_ROW_MAX;
00016a  4828              LDR      r0,|L15.524|
00016c  8801              LDRH     r1,[r0,#0]  ; sensingRowStart
00016e  f1010105          ADD      r1,r1,#5
000172  8001              STRH     r1,[r0,#0]
;;;401    			if(sensingRowStart >= ROW_MAX)
000174  8801              LDRH     r1,[r0,#0]  ; sensingRowStart
000176  292d              CMP      r1,#0x2d
000178  d303              BCC      |L15.386|
;;;402    			{
;;;403    				ulRowEnd = PEN_COORD_ROW_MAX;
00017a  2505              MOVS     r5,#5
;;;404    				sensingRowStart = 0;
00017c  2100              MOVS     r1,#0
00017e  8001              STRH     r1,[r0,#0]
000180  e007              B        |L15.402|
                  |L15.386|
;;;405    			}
;;;406    			else if((ROW_MAX - sensingRowStart) < PEN_COORD_ROW_MAX)
000182  8801              LDRH     r1,[r0,#0]  ; sensingRowStart
000184  f1c1012d          RSB      r1,r1,#0x2d
000188  2905              CMP      r1,#5
;;;407    			{
;;;408    				ulRowEnd = (ROW_MAX - sensingRowStart);
00018a  bfbc              ITT      LT
00018c  8800              LDRHLT   r0,[r0,#0]  ; sensingRowStart
00018e  f1c0052d          RSBLT    r5,r0,#0x2d
                  |L15.402|
;;;409    			}
;;;410    		}
;;;411    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;412    		if(((lDataIndex == LOCAL_OP_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS) || (lDataIndex == LOCAL_OP_2_LAST_LHB && OP_TYPE == ACTIVEPEN_TYPE_LOCAL_WGP)) && sensingRowStart == 0)
;;;413    #else
;;;414    		if((lDataIndex == LOCAL_OP_LAST_LHB && sensingRowStart == 0) || lDataIndex == PARTIAL_MAX)
000192  9800              LDR      r0,[sp,#0]
000194  2808              CMP      r0,#8
000196  d01d              BEQ      |L15.468|
000198  2816              CMP      r0,#0x16
00019a  f47faf62          BNE      |L15.98|
                  |L15.414|
;;;415    #endif
;;;416    		{
;;;417    			break;
;;;418    		}
;;;419    	}
;;;420    
;;;421    	for(r = ROW_MAX; r--; )
;;;422    	{
;;;423    		r_pos = r*COL_MAX;
;;;424    		for(c=COL_MAX; c--; )
;;;425    		{
;;;426    			temp_data = pPenBaseImage[r_pos+c]; //HAL_READ_LOCAL_BASELINE_IMAGE(r, c);
;;;427    			temp_data /= 4;
;;;428    			pPenBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r, c, temp_data);
;;;429    
;;;430    			if(thisModeConf->BaseLine.bPen_2BASE == 1)
00019e  481c              LDR      r0,|L15.528|
;;;431    			{
;;;432    				temp_data = pPenBaseImage[(r+ROW_MAX)*COL_MAX+c]; //HAL_READ_LOCAL_BASELINE_IMAGE(r+ROW_MAX, c);
;;;433    				temp_data /= 4;
;;;434    				pPenBaseImage[(r+ROW_MAX)*COL_MAX+c] = temp_data; //HAL_WRITE_LOCAL_BASELINE_IMAGE(r+ROW_MAX, c, temp_data);
;;;435    			}
;;;436    
;;;437    #if 0//((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)) && defined(TILT_ON)
;;;438    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWACOM_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)
;;;439    			if(OP_TYPE == ACTIVEPEN_TYPE_LOCAL_MS)
;;;440    	#endif
;;;441    			{
;;;442    				temp_data = HAL_READ_RING_BASELINE_IMAGE(r, c);
;;;443    //				temp_data /= 2;
;;;444    				HAL_WRITE_RING_BASELINE_IMAGE(r, c, temp_data);
;;;445    			}
;;;446    #endif			
;;;447    			temp_data = pFingerBaseImage[r_pos+c]; //HAL_READ_LOCAL_FINGER_BASELINE_IMAGE(r, c);			
;;;448    			temp_data /= finger_div;
;;;449    			pFingerBaseImage[r_pos+c] = temp_data; //HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE(r, c, temp_data);
;;;450    		}
;;;451    	}
;;;452    
;;;453    	return local_base_return_flag;
;;;454    }
0001a0  232c              MOVS     r3,#0x2c
0001a2  f04f094f          MOV      r9,#0x4f
0001a6  6885              LDR      r5,[r0,#8]  ; thisModeConf
                  |L15.424|
0001a8  eb030083          ADD      r0,r3,r3,LSL #2       ;423
0001ac  ea4f1c00          LSL      r12,r0,#4             ;423
0001b0  f103002d          ADD      r0,r3,#0x2d           ;432
0001b4  4649              MOV      r1,r9
0001b6  eb000780          ADD      r7,r0,r0,LSL #2       ;432
0001ba  bf00              NOP                            ;426
                  |L15.444|
0001bc  eb0c0001          ADD      r0,r12,r1             ;426
0001c0  f8342010          LDRH     r2,[r4,r0,LSL #1]     ;426
0001c4  0892              LSRS     r2,r2,#2              ;427
0001c6  f8242010          STRH     r2,[r4,r0,LSL #1]     ;428
0001ca  f895203e          LDRB     r2,[r5,#0x3e]         ;430
0001ce  2a01              CMP      r2,#1                 ;430
0001d0  d10d              BNE      |L15.494|
0001d2  e005              B        |L15.480|
                  |L15.468|
0001d4  480d              LDR      r0,|L15.524|
0001d6  8800              LDRH     r0,[r0,#0]            ;414  ; sensingRowStart
0001d8  2800              CMP      r0,#0                 ;414
0001da  f47faf42          BNE      |L15.98|
0001de  e7de              B        |L15.414|
                  |L15.480|
0001e0  eb011a07          ADD      r10,r1,r7,LSL #4      ;432
0001e4  f834201a          LDRH     r2,[r4,r10,LSL #1]    ;432
0001e8  0892              LSRS     r2,r2,#2              ;433
0001ea  f824201a          STRH     r2,[r4,r10,LSL #1]    ;434
                  |L15.494|
0001ee  f8362010          LDRH     r2,[r6,r0,LSL #1]     ;447
0001f2  1e49              SUBS     r1,r1,#1              ;449
0001f4  fb92f2f8          SDIV     r2,r2,r8              ;448
0001f8  f8262010          STRH     r2,[r6,r0,LSL #1]     ;449
0001fc  d2de              BCS      |L15.444|
0001fe  1e5b              SUBS     r3,r3,#1              ;449
000200  d2d2              BCS      |L15.424|
000202  9801              LDR      r0,[sp,#4]            ;453
000204  b003              ADD      sp,sp,#0xc
000206  e8bd8ff0          POP      {r4-r11,pc}
;;;455    
                          ENDP

00020a  0000              DCW      0x0000
                  |L15.524|
                          DCD      sensingRowStart
                  |L15.528|
                          DCD      ||.data||
                  |L15.532|
                          DCD      g_pLocalBaseImage
                  |L15.536|
                          DCD      tHalIntrHandle
                  |L15.540|
                          DCD      LocalSharedBuff
                  |L15.544|
                          DCD      FullSharedBuff

                          AREA ||.data||, DATA, ALIGN=2

                  traking_en
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  ptModuleModeConf
                          DCD      0x00000000
                  thisModeConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  ptAppInfo
                          DCD      0x00000000
                  dataCnt
                          DCD      0x00000000
                  AbnormalCnt
                          DCD      0x00000000
                  g_pFingerBaseImage
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\App\\Algorithm\\Baseline\\algorithm_baseline.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_b70fc24c____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___20_algorithm_baseline_c_b70fc24c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_b70fc24c____REVSH|
#line 402
|__asm___20_algorithm_baseline_c_b70fc24c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_b70fc24c____RRX|
#line 587
|__asm___20_algorithm_baseline_c_b70fc24c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
