; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\pe_usb.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\pe_usb.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\pe_usb.crf ..\..\Hal\usb\FWOTG210_F000\Pe_usb.c]
                          THUMB

                          AREA ||i.CheckHIDReady||, CODE, READONLY, ALIGN=2

                  CheckHIDReady PROC
;;;261    // Touch 의 Contact Count 를 Host 에서 읽어 갔는지 확인 (Touch 를 사용할 준비가 되었다고 판단)
;;;262    uint8_t CheckHIDReady(void)
000000  4801              LDR      r0,|L1.8|
;;;263    {
;;;264    	return g_HIDReady;
000002  7840              LDRB     r0,[r0,#1]  ; g_HIDReady
;;;265    }
000004  4770              BX       lr
;;;266    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.CheckUsbConfig||, CODE, READONLY, ALIGN=2

                  CheckUsbConfig PROC
;;;255    // USB 장치를 사용할 준비가 되어 있는지 확인
;;;256    uint8_t CheckUsbConfig(void)
000000  4801              LDR      r0,|L2.8|
;;;257    {
;;;258    	return g_Configuration;
000002  7800              LDRB     r0,[r0,#0]  ; g_Configuration
;;;259    }
000004  4770              BX       lr
;;;260    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.DMABulkData_USB||, CODE, READONLY, ALIGN=2

                  DMABulkData_USB PROC
;;;1517   // Device to Host
;;;1518   void DMABulkData_USB(void)
000000  480d              LDR      r0,|L3.56|
;;;1519   {
;;;1520   #ifndef MODE_I2C
;;;1521   	// Virtual DMA Mask - Bulk Custom IN
;;;1522   	mUsbEXIntDmaErrEn(BULK_CUSTOM_FIFO_IN);
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4213100          BIC      r1,r1,#0x20000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
;;;1523   	mUsbEXIntDmaFinishEn(BULK_CUSTOM_FIFO_IN);
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210102          BIC      r1,r1,#2
000016  f8c0132c          STR      r1,[r0,#0x32c]
;;;1524   
;;;1525   	// Virtual DMA Start !!!!
;;;1526   	mUsbEXDmaConfig(BULK_CUSTOM_FIFO_IN, MX_PA_SZ_64, DIRECTION_IN);
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01308          STR      r1,[r0,#0x308]
;;;1527   	mUsbEXDmaAddr(BULK_CUSTOM_FIFO_IN, (uint32_t)g_BulkCustomBuffer);
000022  4906              LDR      r1,|L3.60|
000024  f8c0130c          STR      r1,[r0,#0x30c]
;;;1528   	mUsbEXDmaStart(BULK_CUSTOM_FIFO_IN);
000028  f8d01308          LDR      r1,[r0,#0x308]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01308          STR      r1,[r0,#0x308]
;;;1529   #endif
;;;1530   	return;
;;;1531   }
000034  4770              BX       lr
;;;1532   
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      0x20100000
                  |L3.60|
                          DCD      ||.bss||+0xcdc

                          AREA ||i.DMACustomData_USB||, CODE, READONLY, ALIGN=2

                  DMACustomData_USB PROC
;;;790    // Device to Host
;;;791    void DMACustomData_USB()
000000  480d              LDR      r0,|L4.56|
;;;792    {
;;;793    #ifndef MODE_I2C
;;;794    	// Virtual DMA Mask - Custom IN
;;;795    	mUsbEXIntDmaErrEn(CUSTOM_FIFO_IN);
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4213100          BIC      r1,r1,#0x20000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
;;;796    	mUsbEXIntDmaFinishEn(CUSTOM_FIFO_IN);
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210102          BIC      r1,r1,#2
000016  f8c0132c          STR      r1,[r0,#0x32c]
;;;797    
;;;798    	// Virtual DMA Start !!!!
;;;799    	mUsbEXDmaConfig(CUSTOM_FIFO_IN, MX_PA_SZ_64, DIRECTION_IN);
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01308          STR      r1,[r0,#0x308]
;;;800    	mUsbEXDmaAddr(CUSTOM_FIFO_IN, (uint32_t)g_CustomBuffer);
000022  4906              LDR      r1,|L4.60|
000024  f8c0130c          STR      r1,[r0,#0x30c]
;;;801    	mUsbEXDmaStart(CUSTOM_FIFO_IN);
000028  f8d01308          LDR      r1,[r0,#0x308]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01308          STR      r1,[r0,#0x308]
;;;802    #endif
;;;803    	return;
;;;804    }
000034  4770              BX       lr
;;;805    
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      0x20100000
                  |L4.60|
                          DCD      ||.bss||+0xc9c

                          AREA ||i.DMATouchData_USB||, CODE, READONLY, ALIGN=2

                  DMATouchData_USB PROC
;;;554    
;;;555    void DMATouchData_USB(void)
000000  480d              LDR      r0,|L5.56|
;;;556    {
;;;557    #ifndef MODE_I2C
;;;558    	// Virtual DMA Mask - MultiTouch
;;;559    	mUsbEXIntDmaErrEn(TOUCH_FIFO_IN);
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4212180          BIC      r1,r1,#0x40000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
;;;560    	mUsbEXIntDmaFinishEn(TOUCH_FIFO_IN);
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210104          BIC      r1,r1,#4
000016  f8c0132c          STR      r1,[r0,#0x32c]
;;;561    
;;;562    	// Virtual DMA Start !!!!
;;;563    	mUsbEXDmaConfig(TOUCH_FIFO_IN, sizeof(HID_MULTITOUCH), DIRECTION_IN);
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01310          STR      r1,[r0,#0x310]
;;;564    	mUsbEXDmaAddr(TOUCH_FIFO_IN, (uint32_t)&g_Touch);
000022  4906              LDR      r1,|L5.60|
000024  f8c01314          STR      r1,[r0,#0x314]
;;;565    	mUsbEXDmaStart(TOUCH_FIFO_IN);
000028  f8d01310          LDR      r1,[r0,#0x310]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01310          STR      r1,[r0,#0x310]
;;;566    #endif
;;;567    	return;
;;;568    }
000034  4770              BX       lr
;;;569    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x20100000
                  |L5.60|
                          DCD      ||.bss||+0x11a

                          AREA ||i.EP0_SetupPacket||, CODE, READONLY, ALIGN=2

                  EP0_SetupPacket PROC
;;;1976   
;;;1977   void EP0_SetupPacket(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1978   {
;;;1979   	uint8_t	bStall = TRUE;
;;;1980   
;;;1981   	if (mUsbOTGHighSpeedST())
000004  4cff              LDR      r4,|L6.1028|
000006  f04f0901          MOV      r9,#1                 ;1979
00000a  f8d40100          LDR      r0,[r4,#0x100]
00000e  f0100f40          TST      r0,#0x40
;;;1982   	{
;;;1983   		return;
;;;1984   	}
;;;1985   
;;;1986   	// Device to Host
;;;1987   	switch (g_pSetupPacket->bmRequestType_Type)
;;;1988   	{
;;;1989   		case SETUPPACKET_REQUEST_TYPE__STANDARD:
;;;1990   		{
;;;1991   			// Standard
;;;1992   			switch (g_pSetupPacket->bRequest)
;;;1993   			{
;;;1994   				case SETUPPACKET_STANDARD_REQUEST__GET_STATUS:
;;;1995   				{					
;;;1996   					g_EP0_BufferAddr = (uint8_t*)&g_Status[g_pSetupPacket->wIndex];
;;;1997   					g_EP0_BufferLength = sizeof(SETUP_GET_STATUS);
;;;1998   
;;;1999   					// Tx
;;;2000   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2001   					bStall = FALSE;
;;;2002   					break;
;;;2003   				}
;;;2004   
;;;2005   				case SETUPPACKET_STANDARD_REQUEST__CLEAR_FEATURE:
;;;2006   				{
;;;2007   					switch (g_pSetupPacket->wValue & 0x00FF)
;;;2008   					{
;;;2009   						case SETUPPACKET_FEATURE__ENDPOINT_HALT:
;;;2010   						{
;;;2011   							g_Status[g_pSetupPacket->wIndex].Status.EP.EndPointHalt = 0;
;;;2012   							break;
;;;2013   						}
;;;2014   
;;;2015   						case SETUPPACKET_FEATURE__DEVICE_REMOTE_WAKEUP:
;;;2016   						{
;;;2017   							// Clear Suspend
;;;2018   							mUsbClearSuspend();
;;;2019   							
;;;2020   							g_Status[g_pSetupPacket->wIndex].Status.Global.RemoteWakeup = 0;
;;;2021   							g_StartTime_Recovery_ClearSus = g_ScanTime_Recovery_ClearSus = 0; 
;;;2022   							ResumeCnt=0;
;;;2023   							Recovery_ClearSus_Flag = 0;
;;;2024   							break;
;;;2025   						}
;;;2026   					}
;;;2027   
;;;2028   					mUsbEP0DoneSet();
;;;2029   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2030   					bStall = FALSE;
;;;2031   					break;
;;;2032   				}
;;;2033   
;;;2034   				case SETUPPACKET_STANDARD_REQUEST__SET_FEATURE:
;;;2035   				{
;;;2036   					
;;;2037   					switch (g_pSetupPacket->wValue & 0x00FF)
;;;2038   					{
;;;2039   						case SETUPPACKET_FEATURE__ENDPOINT_HALT:
;;;2040   						{
;;;2041   							g_Status[g_pSetupPacket->wIndex].Status.EP.EndPointHalt = 1;
;;;2042   
;;;2043   							if (g_pSetupPacket->wIndex & 0x0080)
;;;2044   							{
;;;2045   								mUsbEPinRsTgClr(g_pSetupPacket->wIndex & 0x000F);
;;;2046   							}
;;;2047   							else
;;;2048   							{
;;;2049   								mUsbEPoutRsTgClr(g_pSetupPacket->wIndex & 0x000F);
;;;2050   							}
;;;2051   
;;;2052   							mUsbEP0DoneSet();
;;;2053   							g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2054   							bStall = FALSE;
;;;2055   							break;
;;;2056   						}
;;;2057   
;;;2058   						case SETUPPACKET_FEATURE__DEVICE_REMOTE_WAKEUP:
;;;2059   						{
;;;2060   							mUsbEP0DoneSet();
;;;2061   							
;;;2062   							// Suspend
;;;2063   							mUsbGoSuspend();
;;;2064   							
;;;2065   							g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2066   							g_RemoteWakeup = 1;
;;;2067   							g_SuspendOn = 1;
;;;2068   							g_Status[g_pSetupPacket->wIndex].Status.Global.RemoteWakeup = 1;
;;;2069   							bStall = FALSE;
;;;2070   							break;
;;;2071   						}
;;;2072   					}
;;;2073   					
;;;2074   					
;;;2075   					break;
;;;2076   				}
;;;2077   
;;;2078   				case SETUPPACKET_STANDARD_REQUEST__SET_ADDRESS:
;;;2079   				{
;;;2080   					mUsbDevAddrSet(g_pSetupPacket->wValue);
;;;2081   					mUsbEP0DoneSet();
;;;2082   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2083   					bStall = FALSE;
;;;2084   					break;
;;;2085   				}
;;;2086   
;;;2087   				case SETUPPACKET_STANDARD_REQUEST__GET_DESCRIPTOR:
;;;2088   				{
;;;2089   					EP0_SetupPacket_GetDescriptor();
;;;2090   					bStall = FALSE;
;;;2091   					break;
;;;2092   				}
;;;2093   
;;;2094   				case SETUPPACKET_STANDARD_REQUEST__SET_DESCRIPTOR:
;;;2095   				{
;;;2096   					break;
;;;2097   				}
;;;2098   
;;;2099   				case SETUPPACKET_STANDARD_REQUEST__GET_CONFIGURATION:
;;;2100   				{
;;;2101   					g_EP0_BufferAddr = &g_Configuration;
;;;2102   					g_EP0_BufferLength = 1;
;;;2103   
;;;2104   					// Tx
;;;2105   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2106   					bStall = FALSE;
;;;2107   					break;
;;;2108   				}
;;;2109   
;;;2110   				case SETUPPACKET_STANDARD_REQUEST__SET_CONFIGURATION:
;;;2111   				{
;;;2112   					// EP 와 FIFO 연결
;;;2113   					mUsbEPMap(EP2, TOUCH_FIFO_IN);				// MultiTouch IN
;;;2114   					mUsbEPMap(EP3, CUSTOM_FIFO_OUT << 4);		// Custom OUT 
;;;2115   					mUsbEPMap(EP4, CUSTOM_FIFO_IN);				// Custom IN
;;;2116   					mUsbEPMap(EP6, PEN_FIFO_IN);				// Pen IN
;;;2117   					//mUsbEPMap(EP7, BULK_CUSTOM_FIFO_OUT << 4);	// Bulk Custom OUT 
;;;2118   					//mUsbEPMap(EP8, BULK_CUSTOM_FIFO_IN);		// Bulk Custom IN
;;;2119   
;;;2120   					// FIFO 설정
;;;2121   					mUsbFIFOMap(TOUCH_FIFO_IN, EP2 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2122   					mUsbFIFOMap(CUSTOM_FIFO_OUT, EP3 | (FIFO_CONFIG_DIRECTION__OUT << 4));
;;;2123   					mUsbFIFOMap(CUSTOM_FIFO_IN, EP4 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2124   					mUsbFIFOMap(PEN_FIFO_IN, EP6 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2125   					//mUsbFIFOMap(BULK_CUSTOM_FIFO_OUT, EP7 | (FIFO_CONFIG_DIRECTION__OUT << 4));
;;;2126   					//mUsbFIFOMap(BULK_CUSTOM_FIFO_IN, EP8 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2127   
;;;2128   					// Max Packet Size
;;;2129   					mUsbEPMxPtSz(EP2, DIRECTION_IN, MX_PA_SZ_64);
;;;2130   					mUsbEPMxPtSz(EP3, DIRECTION_OUT, MX_PA_SZ_64);
;;;2131   					mUsbEPMxPtSz(EP4, DIRECTION_IN, MX_PA_SZ_64);
;;;2132   					mUsbEPMxPtSz(EP6, DIRECTION_IN, MX_PA_SZ_64);
;;;2133   					//mUsbEPMxPtSz(EP7, DIRECTION_OUT, MX_PA_SZ_64);
;;;2134   					//mUsbEPMxPtSz(EP8, DIRECTION_IN, MX_PA_SZ_64);
;;;2135   
;;;2136   					// FIFO Config
;;;2137   					mUsbFIFOConfig(TOUCH_FIFO_IN, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2138   					mUsbFIFOConfig(CUSTOM_FIFO_OUT, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2139   					mUsbFIFOConfig(CUSTOM_FIFO_IN, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2140   					mUsbFIFOConfig(PEN_FIFO_IN, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2141   					//mUsbFIFOConfig(BULK_CUSTOM_FIFO_OUT, FIFO_CONFIG_TYPE__BULK | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2142   					//mUsbFIFOConfig(BULK_CUSTOM_FIFO_IN, FIFO_CONFIG_TYPE__BULK | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2143   
;;;2144   					// Custom OUT
;;;2145   					RecieveCustomData_DMA();
;;;2146   
;;;2147   					// Bulk Custom OUT
;;;2148   					RecieveBulkCustomData_DMA();
;;;2149   
;;;2150   					// Toggle
;;;2151   					mUsbEPinRsTgClr(EP2);
;;;2152   					mUsbEPoutRsTgClr(EP3);
;;;2153   					mUsbEPinRsTgClr(EP4);
;;;2154   					mUsbEPinRsTgClr(EP6);
;;;2155   					//mUsbEPoutRsTgClr(EP7);
;;;2156   					//mUsbEPinRsTgClr(EP8);
;;;2157   
;;;2158   					// SOF
;;;2159   					mUsbSOFMaskFS();
;;;2160   
;;;2161   					// Done !!
;;;2162   					mUsbEP0DoneSet();
;;;2163   
;;;2164   					// After Set Configuration
;;;2165   					mUsbCfgSet();
;;;2166   
;;;2167   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2168   					g_Configuration = (uint8_t)(g_pSetupPacket->wValue & 0x00FF);
;;;2169   					g_HIDReady = 1;
;;;2170   					bStall = FALSE;
;;;2171   					break;
;;;2172   				}
;;;2173   
;;;2174   				case SETUPPACKET_STANDARD_REQUEST__GET_INTERFACE:
;;;2175   				{
;;;2176   					uint8_t AlterInterface = 0;
;;;2177   
;;;2178   					g_EP0_BufferAddr = &AlterInterface;
;;;2179   					g_EP0_BufferLength = 1;
;;;2180   
;;;2181   					// Tx
;;;2182   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2183   					bStall = FALSE;
;;;2184   					break;
;;;2185   				}
;;;2186   
;;;2187   				case SETUPPACKET_STANDARD_REQUEST__SET_INFERFACE:
;;;2188   				{
;;;2189   					switch (g_pSetupPacket->wIndex)
;;;2190   					{
;;;2191   						// MultiTouch
;;;2192   						case TOUCH_INTERFACE_NUM:
;;;2193   						{
;;;2194   							mUsbEPinRsTgClr(EP2);
;;;2195   							break;
;;;2196   						}
;;;2197   
;;;2198   						// Custom
;;;2199   						case CUSTOM_INTERFACE_NUM:
;;;2200   						{
;;;2201   							mUsbEPoutRsTgClr(EP3);
;;;2202   							mUsbEPinRsTgClr(EP4);
;;;2203   							break;
;;;2204   						}
;;;2205   
;;;2206   						// Pen
;;;2207   						case PEN_INTERFACE_NUM:
;;;2208   						{
;;;2209   							mUsbEPinRsTgClr(EP6);
;;;2210   							break;
;;;2211   						}
;;;2212   					}
;;;2213   
;;;2214   					mUsbEP0DoneSet();
;;;2215   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2216   					bStall = FALSE;
;;;2217   					break;
;;;2218   				}
;;;2219   
;;;2220   				case SETUPPACKET_STANDARD_REQUEST__SYNCH_FRAME:
;;;2221   				{
;;;2222   					break;
;;;2223   				}
;;;2224   
;;;2225   				default:
;;;2226   				{
;;;2227   					break;
;;;2228   				}
;;;2229   			}
;;;2230   
;;;2231   			break;
;;;2232   		}
;;;2233   
;;;2234   		case SETUPPACKET_REQUEST_TYPE__CLASS:
;;;2235   		{
;;;2236   			switch (g_pSetupPacket->bRequest)
;;;2237   			{
;;;2238   				// Get Report
;;;2239   				case SETUPPACKET_CLASS_REQUEST__GET_REPORT:
;;;2240   				{
;;;2241   					// Feature
;;;2242   					if ((g_pSetupPacket->wValue & 0xFF00) == 0x0300)
;;;2243   					{
;;;2244   						switch (g_pSetupPacket->wValue & 0x00FF)
;;;2245   						{
;;;2246   #ifdef ADD_TOUCH
;;;2247   							// Contact count Mamimum
;;;2248   							case HID_REPORT_ID__CONTACT_COUNT:
;;;2249   							{
;;;2250   								g_MaxTouchCount.ReportID = HID_REPORT_ID__CONTACT_COUNT;
;;;2251   								g_MaxTouchCount.Count = HID_MAX_TOUCH;
;;;2252   								//g_MaxTouchCount.Reserved = 0;
;;;2253   
;;;2254   								g_EP0_BufferAddr = (uint8_t*)&g_MaxTouchCount;
;;;2255   								g_EP0_BufferLength = sizeof(TOUCH_MAX_COUNT);
;;;2256   
;;;2257   								// Tx
;;;2258   								EP0_TxRx_Proc(DIRECTION_IN);
;;;2259   								bStall = FALSE;
;;;2260   								break;
;;;2261   							}
;;;2262   
;;;2263   							case HID_REPORT_ID__BLOB_CODE:
;;;2264   							{
;;;2265   								g_EP0_BufferAddr = &u8_HID_Touch_Blob[g_EP0_Offset];
;;;2266   								g_EP0_BufferLength = HID_TOUCH_BLOB_LENGTH;
;;;2267   
;;;2268   								// Tx
;;;2269   								EP0_TxRx_Proc(DIRECTION_IN);
;;;2270   								bStall = FALSE;
;;;2271   								break;
;;;2272   							}
;;;2273   #endif
;;;2274   						}
;;;2275   					}
;;;2276   					break;
;;;2277   				}
;;;2278   
;;;2279   				// Set Report
;;;2280   				case SETUPPACKET_CLASS_REQUEST__SET_REPORT:
;;;2281   				{
;;;2282   					// Feature
;;;2283   					if ((g_pSetupPacket->wValue & 0xFF00) == 0x0300)
;;;2284   					{
;;;2285   #ifdef ADD_TOUCH
;;;2286   						// Device Mode
;;;2287   						if ((g_pSetupPacket->wValue & 0x00FF) == HID_REPORT_ID__DEVICE_MODE)
;;;2288   						{
;;;2289   							g_EP0_BufferAddr = (uint8_t*)&g_DeviceMode;
;;;2290   							g_EP0_BufferLength = g_pSetupPacket->wLength;
;;;2291   
;;;2292   							// Rx
;;;2293   							EP0_TxRx_Proc(DIRECTION_OUT);
;;;2294   							bStall = FALSE;
;;;2295   						}
;;;2296   #endif
;;;2297   
;;;2298   						// Latency Mode
;;;2299   						if ((g_pSetupPacket->wValue & 0x00FF) == HID_REPORT_ID__LATENCY_MODE)
;;;2300   						{
;;;2301   							g_EP0_BufferAddr = (uint8_t*)&g_LatencyMode;
;;;2302   							g_EP0_BufferLength = g_pSetupPacket->wLength;
;;;2303   
;;;2304   							// Rx
;;;2305   							EP0_TxRx_Proc(DIRECTION_OUT);
;;;2306   							bStall = FALSE;
;;;2307   						}
;;;2308   					}
;;;2309   
;;;2310   					break;
;;;2311   				}
;;;2312   
;;;2313   				// Set Idle
;;;2314   				case SETUPPACKET_CLASS_REQUEST__SET_IDLE:
;;;2315   				{
;;;2316   					uint8_t	ReportID = 0;
;;;2317   					uint8_t	Duration = 0;
;;;2318   
;;;2319   					ReportID = (uint8_t)(g_pSetupPacket->wValue & 0x00FF);
;;;2320   					Duration = (uint8_t)((g_pSetupPacket->wValue & 0xFF00) >> 8);
;;;2321   
;;;2322   					// All
;;;2323   					if (ReportID == 0)
;;;2324   					{
;;;2325   						mUsbEP0StallSet();
;;;2326   						mUsbEP0DoneSet();
;;;2327   						g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2328   						bStall = FALSE;
;;;2329   					}
;;;2330   					// Other Report
;;;2331   					else
;;;2332   					{
;;;2333   						g_IdleDuration[ReportID] = Duration;
;;;2334   						mUsbEP0DoneSet();
;;;2335   						g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2336   						bStall = FALSE;
;;;2337   					}
;;;2338   
;;;2339   					break;
;;;2340   				}
;;;2341   
;;;2342   				// Get Idle
;;;2343   				case SETUPPACKET_CLASS_REQUEST__GET_IDLE:
;;;2344   				{
;;;2345   					uint8_t	ReportID = 0;
;;;2346   
;;;2347   					ReportID = (uint8_t)(g_pSetupPacket->wValue & 0x00FF);
;;;2348   
;;;2349   					g_EP0_BufferAddr = (uint8_t*)&g_IdleDuration[ReportID];
;;;2350   					g_EP0_BufferLength = 1;
;;;2351   
;;;2352   					// Rx
;;;2353   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2354   					bStall = FALSE;
;;;2355   					break;
;;;2356   				}
;;;2357   			}
;;;2358   
;;;2359   			break;
;;;2360   		}
;;;2361   
;;;2362   		case SETUPPACKET_REQUEST_TYPE__VENDOR:
;;;2363   		{
;;;2364   			switch (g_pSetupPacket->bRequest)
;;;2365   			{
;;;2366   				// MS OS Descriptor
;;;2367   				case SETUPPACKET_DESCRIPTOR__MS_OS_VENDOR_CODE:
;;;2368   				{
;;;2369   					switch (g_pSetupPacket->wIndex)
;;;2370   					{
;;;2371   
;;;2372   						case MS_OS_DESCRIPTOR_TYPE__COMPATIBLE_ID:
;;;2373   						{
;;;2374   #ifdef ADD_BULK_CUSTOM
;;;2375   							MS_OS_CompatibleID.Length = sizeof(COMPATIBLE_ID_FEATURE_DESCRIPTOR);
;;;2376   							MS_OS_CompatibleID.bcdVersion = 0x0100;
;;;2377   							MS_OS_CompatibleID.Index = MS_OS_DESCRIPTOR_TYPE__COMPATIBLE_ID;
;;;2378   							MS_OS_CompatibleID.Count = 0x01;
;;;2379   							MS_OS_CompatibleID.FirstInterfaceNumber = BULK_CUSTOM_INTERFACE_NUM;
;;;2380   
;;;2381   							// WINUSB
;;;2382   							MS_OS_CompatibleID.CompatibleID[0] = 'W';
;;;2383   							MS_OS_CompatibleID.CompatibleID[1] = 'I';
;;;2384   							MS_OS_CompatibleID.CompatibleID[2] = 'N';
;;;2385   							MS_OS_CompatibleID.CompatibleID[3] = 'U';
;;;2386   							MS_OS_CompatibleID.CompatibleID[4] = 'S';
;;;2387   							MS_OS_CompatibleID.CompatibleID[5] = 'B';
;;;2388   							MS_OS_CompatibleID.CompatibleID[6] = 0;
;;;2389   							MS_OS_CompatibleID.CompatibleID[7] = 0;
;;;2390   
;;;2391   							g_EP0_BufferAddr = (uint8_t*)&MS_OS_CompatibleID;
;;;2392   							g_EP0_BufferLength = sizeof(COMPATIBLE_ID_FEATURE_DESCRIPTOR);
;;;2393   
;;;2394   							// Rx
;;;2395   							EP0_TxRx_Proc(DIRECTION_IN);
;;;2396   							bStall = FALSE;
;;;2397   #endif
;;;2398   							break;
;;;2399   						}
;;;2400   
;;;2401   						case MS_OS_DESCRIPTOR_TYPE__PROPERTIES:
;;;2402   						{
;;;2403   #ifdef USB_SELECTIVE_SUSPEND
;;;2404   							uint32_t	i = 0;
;;;2405   							uint8_t*	pString = 0;
;;;2406   							uint8_t*	pBuffer = (uint8_t*)&MS_OS_Property;
;;;2407   
;;;2408   							MS_OS_Property.Header.Length = sizeof(PROPERTIES_DESCRIPTOR_HEADER);
;;;2409   							MS_OS_Property.Header.bcdVersion = 0x0100;
;;;2410   							MS_OS_Property.Header.Index = MS_OS_DESCRIPTOR_TYPE__PROPERTIES;
;;;2411   							MS_OS_Property.Header.Count = 0;
;;;2412   							
;;;2413   							// SelectiveSuspend
;;;2414   							pString = SELECTIVE_SUSPEND_STRING;
;;;2415   							MS_OS_Property.SelectiveSuspend.Size = sizeof(PROPERTY_SECTION__SELECTIVE_SUSPEND);
;;;2416   							MS_OS_Property.SelectiveSuspend.PropertyDataType = REG_DWORD;
;;;2417   							MS_OS_Property.SelectiveSuspend.PropertyNameLength = 48;
;;;2418   							for (i = 0; i < (MS_OS_Property.SelectiveSuspend.PropertyNameLength/2); i++)
;;;2419   							{
;;;2420   								MS_OS_Property.SelectiveSuspend.PropertyName[i*2] = pString[i];
;;;2421   							}
;;;2422   							MS_OS_Property.SelectiveSuspend.PropertyDataLength = 0x04;
;;;2423   							MS_OS_Property.SelectiveSuspend.PropertyData = 0x01;
;;;2424   							MS_OS_Property.Header.Count += 1;
;;;2425   							MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__SELECTIVE_SUSPEND);
;;;2426   
;;;2427   #ifdef ADD_BULK_CUSTOM
;;;2428   #ifdef MS_OS_EXT_PROP__WINUSB
;;;2429   							if (InterfaceNumber == BULK_CUSTOM_INTERFACE_NUM)
;;;2430   							{
;;;2431   								// DeviceInterfaceGUID
;;;2432   								MS_OS_Property.DeviceInterfaceGUID.Size = sizeof(PROPERTY_SECTION__DEVICEINTERFACEGUID);
;;;2433   								MS_OS_Property.DeviceInterfaceGUID.PropertyDataType = REG_SZ;
;;;2434   								pString = DEVICEINTERFACEGUID_NAME;
;;;2435   								MS_OS_Property.DeviceInterfaceGUID.PropertyNameLength = 40;
;;;2436   								for (i = 0; i < (MS_OS_Property.DeviceInterfaceGUID.PropertyNameLength / 2); i++)
;;;2437   								{
;;;2438   									MS_OS_Property.DeviceInterfaceGUID.PropertyName[i * 2] = pString[i];
;;;2439   								}
;;;2440   								pString = DEVICEINTERFACEGUID_STRING;
;;;2441   								MS_OS_Property.DeviceInterfaceGUID.PropertyDataLength = 78;
;;;2442   								for (i = 0; i < (MS_OS_Property.DeviceInterfaceGUID.PropertyDataLength / 2); i++)
;;;2443   								{
;;;2444   									MS_OS_Property.DeviceInterfaceGUID.PropertyData[i * 2] = pString[i];
;;;2445   								}
;;;2446   								MS_OS_Property.Header.Count += 1;
;;;2447   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICEINTERFACEGUID);
;;;2448   
;;;2449   
;;;2450   								// DeviceIdleEnabled
;;;2451   								pString = DEVICEIDLEENABLED_NAME;
;;;2452   								MS_OS_Property.DeviceIdleEnabled.Size = sizeof(PROPERTY_SECTION__DEVICEIDLEENABLED);
;;;2453   								MS_OS_Property.DeviceIdleEnabled.PropertyDataType = REG_DWORD;
;;;2454   								MS_OS_Property.DeviceIdleEnabled.PropertyNameLength = 36;
;;;2455   								for (i = 0; i < (MS_OS_Property.DeviceIdleEnabled.PropertyNameLength / 2); i++)
;;;2456   								{
;;;2457   									MS_OS_Property.DeviceIdleEnabled.PropertyName[i * 2] = pString[i];
;;;2458   								}
;;;2459   								MS_OS_Property.DeviceIdleEnabled.PropertyDataLength = 0x04;
;;;2460   								MS_OS_Property.DeviceIdleEnabled.PropertyData = 0x01;
;;;2461   								MS_OS_Property.Header.Count += 1;
;;;2462   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICEIDLEENABLED);
;;;2463   
;;;2464   
;;;2465   								// DefaultIdleState
;;;2466   								pString = DEFAULTIDLESTATE_NAME;
;;;2467   								MS_OS_Property.DefaultIdleState.Size = sizeof(PROPERTY_SECTION__DEFAULTIDLESTATE);
;;;2468   								MS_OS_Property.DefaultIdleState.PropertyDataType = REG_DWORD;
;;;2469   								MS_OS_Property.DefaultIdleState.PropertyNameLength = 34;
;;;2470   								for (i = 0; i < (MS_OS_Property.DefaultIdleState.PropertyNameLength / 2); i++)
;;;2471   								{
;;;2472   									MS_OS_Property.DefaultIdleState.PropertyName[i * 2] = pString[i];
;;;2473   								}
;;;2474   								MS_OS_Property.DefaultIdleState.PropertyDataLength = 0x04;
;;;2475   								MS_OS_Property.DefaultIdleState.PropertyData = 0x01;
;;;2476   								MS_OS_Property.Header.Count += 1;
;;;2477   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEFAULTIDLESTATE);
;;;2478   
;;;2479   
;;;2480   								// DefaultIdleTimeout
;;;2481   								pString = DEFAULTIDLETIMEOUT_NAME;
;;;2482   								MS_OS_Property.DefaultIdleTimeout.Size = sizeof(PROPERTY_SECTION__DEFAULTIDLETIMEOUT);
;;;2483   								MS_OS_Property.DefaultIdleTimeout.PropertyDataType = REG_DWORD;
;;;2484   								MS_OS_Property.DefaultIdleTimeout.PropertyNameLength = 38;
;;;2485   								for (i = 0; i < (MS_OS_Property.DefaultIdleTimeout.PropertyNameLength / 2); i++)
;;;2486   								{
;;;2487   									MS_OS_Property.DefaultIdleTimeout.PropertyName[i * 2] = pString[i];
;;;2488   								}
;;;2489   								MS_OS_Property.DefaultIdleTimeout.PropertyDataLength = 0x04;
;;;2490   								MS_OS_Property.DefaultIdleTimeout.PropertyData = 0x00001388; // 5000 ms
;;;2491   								MS_OS_Property.Header.Count += 1;
;;;2492   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEFAULTIDLETIMEOUT);
;;;2493   
;;;2494   
;;;2495   								// UserSetDeviceIdleEnabled
;;;2496   								pString = USERSETDEVICEIDLEENABLED_NAME;
;;;2497   								MS_OS_Property.UserSetDeviceIdleEnabled.Size = sizeof(PROPERTY_SECTION__USERSETDEVICEIDLEENABLED);
;;;2498   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyDataType = REG_DWORD;
;;;2499   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyNameLength = 50;
;;;2500   								for (i = 0; i < (MS_OS_Property.UserSetDeviceIdleEnabled.PropertyNameLength / 2); i++)
;;;2501   								{
;;;2502   									MS_OS_Property.UserSetDeviceIdleEnabled.PropertyName[i * 2] = pString[i];
;;;2503   								}
;;;2504   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyDataLength = 0x04;
;;;2505   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyData = 0x01;
;;;2506   								MS_OS_Property.Header.Count += 1;
;;;2507   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__USERSETDEVICEIDLEENABLED);
;;;2508   
;;;2509   
;;;2510   								// SystemWakeEnabled
;;;2511   								pString = SYSTEMWAKEENABLED_NAME;
;;;2512   								MS_OS_Property.SystemWakeEnabled.Size = sizeof(PROPERTY_SECTION__SYSTEMWAKEENABLED);
;;;2513   								MS_OS_Property.SystemWakeEnabled.PropertyDataType = REG_DWORD;
;;;2514   								MS_OS_Property.SystemWakeEnabled.PropertyNameLength = 36;
;;;2515   								for (i = 0; i < (MS_OS_Property.SystemWakeEnabled.PropertyNameLength / 2); i++)
;;;2516   								{
;;;2517   									MS_OS_Property.SystemWakeEnabled.PropertyName[i * 2] = pString[i];
;;;2518   								}
;;;2519   								MS_OS_Property.SystemWakeEnabled.PropertyDataLength = 0x04;
;;;2520   								MS_OS_Property.SystemWakeEnabled.PropertyData = 0x01;
;;;2521   								MS_OS_Property.Header.Count += 1;
;;;2522   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__SYSTEMWAKEENABLED);
;;;2523   							}
;;;2524   #endif
;;;2525   #endif
;;;2526   							
;;;2527   #ifdef MS_OS_EXT_PROP__ICON
;;;2528   							// DeviceIcon
;;;2529   							pString = DEVICE_ICON_STRING;
;;;2530   							MS_OS_Property.DeviceIcon.Size = sizeof(PROPERTY_SECTION__DEVICE_ICON);
;;;2531   							MS_OS_Property.DeviceIcon.PropertyDataType = REG_MULTI_SZ;
;;;2532   							MS_OS_Property.DeviceIcon.PropertyNameLength = 12;
;;;2533   							MS_OS_Property.DeviceIcon.PropertyName[0] = 'I';
;;;2534   							MS_OS_Property.DeviceIcon.PropertyName[2] = 'c';
;;;2535   							MS_OS_Property.DeviceIcon.PropertyName[4] = 'o';
;;;2536   							MS_OS_Property.DeviceIcon.PropertyName[6] = 'n';
;;;2537   							MS_OS_Property.DeviceIcon.PropertyName[8] = 's';
;;;2538   							MS_OS_Property.DeviceIcon.PropertyDataLength = 78;
;;;2539   							for (i = 0; i < (MS_OS_Property.DeviceIcon.PropertyDataLength/2); i++)
;;;2540   							{
;;;2541   								MS_OS_Property.DeviceIcon.PropertyData[i*2] = pString[i];
;;;2542   							}
;;;2543   							MS_OS_Property.Header.Count += 1;
;;;2544   							MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICE_ICON);
;;;2545   #endif
;;;2546   							
;;;2547   #ifdef MS_OS_EXT_PROP__LABEL
;;;2548   							// DeviceLabel
;;;2549   							pString = DEVICE_LABEL_STRING;
;;;2550   							MS_OS_Property.DeviceLabel.Size = sizeof(PROPERTY_SECTION__DEVICE_LABEL);
;;;2551   							MS_OS_Property.DeviceLabel.PropertyDataType = REG_SZ;
;;;2552   							MS_OS_Property.DeviceLabel.PropertyNameLength = 12;
;;;2553   							MS_OS_Property.DeviceLabel.PropertyName[0] = 'L';
;;;2554   							MS_OS_Property.DeviceLabel.PropertyName[2] = 'a';
;;;2555   							MS_OS_Property.DeviceLabel.PropertyName[4] = 'b';
;;;2556   							MS_OS_Property.DeviceLabel.PropertyName[6] = 'e';
;;;2557   							MS_OS_Property.DeviceLabel.PropertyName[8] = 'l';
;;;2558   							MS_OS_Property.DeviceLabel.PropertyDataLength = 26;
;;;2559   							for (i = 0; i < (MS_OS_Property.DeviceLabel.PropertyDataLength/2); i++)
;;;2560   							{
;;;2561   								MS_OS_Property.DeviceLabel.PropertyData[i*2] = pString[i];
;;;2562   							}
;;;2563   							MS_OS_Property.Header.Count += 1;
;;;2564   							MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICE_LABEL);
;;;2565   #endif
;;;2566   							
;;;2567   							
;;;2568   							
;;;2569   							g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;2570   							g_EP0_BufferLength = MS_OS_Property.Header.Length;
;;;2571   
;;;2572   							// Rx
;;;2573   							EP0_TxRx_Proc(DIRECTION_IN);
;;;2574   							bStall = FALSE;
;;;2575   #endif
;;;2576   							break;
;;;2577   						}
;;;2578   
;;;2579   					}
;;;2580   
;;;2581   					break;
;;;2582   				}
;;;2583   			}
;;;2584   			break;
;;;2585   		}
;;;2586   	}
;;;2587   
;;;2588   
;;;2589   	if (bStall == TRUE)
;;;2590   	{
;;;2591   		mUsbEP0StallSet();
;;;2592   		mUsbEP0DoneSet();
;;;2593   		g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2594   	}
;;;2595   
;;;2596   	return;
;;;2597   }
000012  bf18              IT       NE
000014  e8bd83f8          POPNE    {r3-r9,pc}
000018  4dfb              LDR      r5,|L6.1032|
00001a  2301              MOVS     r3,#1                 ;1979
00001c  2603              MOVS     r6,#3                 ;1992
00001e  69e8              LDR      r0,[r5,#0x1c]         ;1987  ; g_pSetupPacket
000020  2202              MOVS     r2,#2                 ;1997
000022  f04f0808          MOV      r8,#8                 ;1992
000026  7801              LDRB     r1,[r0,#0]            ;1987
000028  f3c11c41          UBFX     r12,r1,#5,#2          ;1987
00002c  2100              MOVS     r1,#0                 ;1997
00002e  f1bc0f00          CMP      r12,#0                ;1987
000032  d00d              BEQ      |L6.80|
000034  270a              MOVS     r7,#0xa               ;1992
000036  f1bc0f01          CMP      r12,#1                ;1987
00003a  f0008151          BEQ.W    |L6.736|
00003e  f1bc0f02          CMP      r12,#2                ;1987
000042  bf04              ITT      EQ                    ;2364
000044  7842              LDRBEQ   r2,[r0,#1]            ;2364
000046  2a98              CMPEQ    r2,#0x98              ;2364
000048  f00081b5          BEQ.W    |L6.950|
00004c  f000b9a3          B.W      |L6.918|
                  |L6.80|
000050  f890c001          LDRB     r12,[r0,#1]           ;1992
000054  f1bc0f0c          CMP      r12,#0xc              ;1992
000058  f080819d          BCS.W    |L6.918|
00005c  e8dff00c          TBB      [pc,r12]              ;1992
000060  0611fd3e          DCB      0x06,0x11,0xfd,0x3e
000064  fd878bfd          DCB      0xfd,0x87,0x8b,0xfd
000068  8f96fcfb          DCB      0x8f,0x96,0xfc,0xfb
00006c  8880              LDRH     r0,[r0,#4]            ;1996
00006e  49e7              LDR      r1,|L6.1036|
000070  eb010040          ADD      r0,r1,r0,LSL #1       ;1996
000074  6228              STR      r0,[r5,#0x20]         ;1997  ; g_EP0_BufferAddr
000076  81aa              STRH     r2,[r5,#0xc]          ;1997
000078  e8bd43f8          POP      {r3-r9,lr}            ;2000
00007c  2000              MOVS     r0,#0                 ;2000
00007e  f7ffbffe          B.W      EP0_TxRx_Proc
000082  7882              LDRB     r2,[r0,#2]            ;2007
000084  f01202ff          ANDS     r2,r2,#0xff           ;2007
000088  d002              BEQ      |L6.144|
00008a  2a01              CMP      r2,#1                 ;2007
00008c  d009              BEQ      |L6.162|
00008e  e01c              B        |L6.202|
                  |L6.144|
000090  8881              LDRH     r1,[r0,#4]            ;2011
000092  48de              LDR      r0,|L6.1036|
000094  f8102011          LDRB     r2,[r0,r1,LSL #1]     ;2011
000098  f0220201          BIC      r2,r2,#1              ;2011
00009c  f8002011          STRB     r2,[r0,r1,LSL #1]     ;2011
0000a0  e013              B        |L6.202|
                  |L6.162|
0000a2  f8d42100          LDR      r2,[r4,#0x100]        ;2018
0000a6  f0220208          BIC      r2,r2,#8              ;2018
0000aa  f8c42100          STR      r2,[r4,#0x100]        ;2018
0000ae  8882              LDRH     r2,[r0,#4]            ;2020
0000b0  48d6              LDR      r0,|L6.1036|
0000b2  f8103012          LDRB     r3,[r0,r2,LSL #1]     ;2020
0000b6  f0230302          BIC      r3,r3,#2              ;2020
0000ba  f8003012          STRB     r3,[r0,r2,LSL #1]     ;2020
0000be  2200              MOVS     r2,#0                 ;2021
0000c0  64a9              STR      r1,[r5,#0x48]         ;2021  ; g_ScanTime_Recovery_ClearSus
0000c2  e9c52222          STRD     r2,r2,[r5,#0x88]      ;2021
0000c6  71e9              STRB     r1,[r5,#7]            ;2022
0000c8  7229              STRB     r1,[r5,#8]            ;2023
                  |L6.202|
0000ca  f8d40120          LDR      r0,[r4,#0x120]        ;2028
0000ce  f0400001          ORR      r0,r0,#1              ;2028
0000d2  f8c40120          STR      r0,[r4,#0x120]        ;2028
0000d6  70ae              STRB     r6,[r5,#2]            ;2029
0000d8  e8bd83f8          POP      {r3-r9,pc}
0000dc  7881              LDRB     r1,[r0,#2]            ;2037
0000de  f01101ff          ANDS     r1,r1,#0xff           ;2037
0000e2  d003              BEQ      |L6.236|
0000e4  2901              CMP      r1,#1                 ;2037
0000e6  d029              BEQ      |L6.316|
0000e8  f000b955          B.W      |L6.918|
                  |L6.236|
0000ec  8882              LDRH     r2,[r0,#4]            ;2041
0000ee  49c7              LDR      r1,|L6.1036|
0000f0  f8113012          LDRB     r3,[r1,r2,LSL #1]     ;2041
0000f4  f0430301          ORR      r3,r3,#1              ;2041
0000f8  f8013012          STRB     r3,[r1,r2,LSL #1]     ;2041
0000fc  8880              LDRH     r0,[r0,#4]            ;2043
0000fe  f0100f80          TST      r0,#0x80              ;2043
000102  f000010e          AND      r1,r0,#0xe            ;2049
000106  d00c              BEQ      |L6.290|
000108  f44f70b0          MOV      r0,#0x160             ;2045
00010c  eb000081          ADD      r0,r0,r1,LSL #2       ;2045
000110  f4401080          ORR      r0,r0,#0x100000       ;2045
000114  f0405000          ORR      r0,r0,#0x20000000     ;2045
000118  6801              LDR      r1,[r0,#0]            ;2045
00011a  f4215180          BIC      r1,r1,#0x1000         ;2045
00011e  6001              STR      r1,[r0,#0]            ;2045
000120  e7d3              B        |L6.202|
                  |L6.290|
000122  f44f70c0          MOV      r0,#0x180             ;2049
000126  eb000081          ADD      r0,r0,r1,LSL #2       ;2049
00012a  f4401080          ORR      r0,r0,#0x100000       ;2049
00012e  f0405000          ORR      r0,r0,#0x20000000     ;2049
000132  6801              LDR      r1,[r0,#0]            ;2049
000134  f4215180          BIC      r1,r1,#0x1000         ;2049
000138  6001              STR      r1,[r0,#0]            ;2049
00013a  e7c6              B        |L6.202|
                  |L6.316|
00013c  f8d41120          LDR      r1,[r4,#0x120]        ;2060
000140  f0410101          ORR      r1,r1,#1              ;2060
000144  f8c41120          STR      r1,[r4,#0x120]        ;2060
000148  f8d41100          LDR      r1,[r4,#0x100]        ;2063
00014c  f0410108          ORR      r1,r1,#8              ;2063
000150  f8c41100          STR      r1,[r4,#0x100]        ;2063
000154  70ae              STRB     r6,[r5,#2]            ;2065
000156  70eb              STRB     r3,[r5,#3]            ;2066
000158  712b              STRB     r3,[r5,#4]            ;2067
00015a  8881              LDRH     r1,[r0,#4]            ;2068
00015c  48ab              LDR      r0,|L6.1036|
00015e  f8102011          LDRB     r2,[r0,r1,LSL #1]     ;2068
000162  f0420202          ORR      r2,r2,#2              ;2068
000166  f8002011          STRB     r2,[r0,r1,LSL #1]     ;2068
00016a  e8bd83f8          POP      {r3-r9,pc}
00016e  8840              LDRH     r0,[r0,#2]            ;2080
000170  f8c40104          STR      r0,[r4,#0x104]        ;2080
000174  e7a9              B        |L6.202|
000176  e8bd43f8          POP      {r3-r9,lr}            ;2089
00017a  f7ffbffe          B.W      EP0_SetupPacket_GetDescriptor
00017e  622d              STR      r5,[r5,#0x20]         ;2101  ; g_EP0_BufferAddr
000180  81ab              STRH     r3,[r5,#0xc]          ;2102
000182  e8bd43f8          POP      {r3-r9,lr}            ;2105
000186  2000              MOVS     r0,#0                 ;2105
000188  f7ffbffe          B.W      EP0_TxRx_Proc
00018c  f88431a1          STRB     r3,[r4,#0x1a1]        ;2113
000190  2220              MOVS     r2,#0x20              ;2114
000192  f88421a2          STRB     r2,[r4,#0x1a2]        ;2114
000196  f88411a3          STRB     r1,[r4,#0x1a3]        ;2115
00019a  f88461a5          STRB     r6,[r4,#0x1a5]        ;2116
00019e  2112              MOVS     r1,#0x12              ;2121
0001a0  f88411a9          STRB     r1,[r4,#0x1a9]        ;2121
0001a4  f88461aa          STRB     r6,[r4,#0x1aa]        ;2122
0001a8  2114              MOVS     r1,#0x14              ;2123
0001aa  f88411a8          STRB     r1,[r4,#0x1a8]        ;2123
0001ae  2116              MOVS     r1,#0x16              ;2124
0001b0  f88411ab          STRB     r1,[r4,#0x1ab]        ;2124
0001b4  2140              MOVS     r1,#0x40              ;2129
0001b6  f8c41164          STR      r1,[r4,#0x164]        ;2129
0001ba  f8c41188          STR      r1,[r4,#0x188]        ;2130
0001be  f8c4116c          STR      r1,[r4,#0x16c]        ;2131
0001c2  f8c41174          STR      r1,[r4,#0x174]        ;2132
0001c6  2123              MOVS     r1,#0x23              ;2137
0001c8  f88411ad          STRB     r1,[r4,#0x1ad]        ;2137
0001cc  f88411ae          STRB     r1,[r4,#0x1ae]        ;2138
0001d0  f88411ac          STRB     r1,[r4,#0x1ac]        ;2139
0001d4  f88411af          STRB     r1,[r4,#0x1af]        ;2140
0001d8  f8c48328          STR      r8,[r4,#0x328]        ;2140
0001dc  f8d4132c          LDR      r1,[r4,#0x32c]        ;2140
0001e0  f4412100          ORR      r1,r1,#0x80000        ;2140
0001e4  f8c4132c          STR      r1,[r4,#0x32c]        ;2140
0001e8  f8d4132c          LDR      r1,[r4,#0x32c]        ;2140
0001ec  f0410108          ORR      r1,r1,#8              ;2140
0001f0  f8c4132c          STR      r1,[r4,#0x32c]        ;2140
0001f4  f8d4132c          LDR      r1,[r4,#0x32c]        ;2140
0001f8  f4212100          BIC      r1,r1,#0x80000        ;2140
0001fc  f8c4132c          STR      r1,[r4,#0x32c]        ;2140
000200  f8d4132c          LDR      r1,[r4,#0x32c]        ;2140
000204  f0210108          BIC      r1,r1,#8              ;2140
000208  f8c4132c          STR      r1,[r4,#0x32c]        ;2140
00020c  0251              LSLS     r1,r2,#9              ;2140
00020e  f8c41318          STR      r1,[r4,#0x318]        ;2140
000212  497f              LDR      r1,|L6.1040|
000214  f8c4131c          STR      r1,[r4,#0x31c]        ;2140
000218  f8d41318          LDR      r1,[r4,#0x318]        ;2140
00021c  f0410101          ORR      r1,r1,#1              ;2140
000220  f8c41318          STR      r1,[r4,#0x318]        ;2140
000224  f8d41164          LDR      r1,[r4,#0x164]        ;2151
000228  f4215180          BIC      r1,r1,#0x1000         ;2151
00022c  f8c41164          STR      r1,[r4,#0x164]        ;2151
000230  f8d41188          LDR      r1,[r4,#0x188]        ;2152
000234  f4215180          BIC      r1,r1,#0x1000         ;2152
000238  f8c41188          STR      r1,[r4,#0x188]        ;2152
00023c  f8d4116c          LDR      r1,[r4,#0x16c]        ;2153
000240  f4215180          BIC      r1,r1,#0x1000         ;2153
000244  f8c4116c          STR      r1,[r4,#0x16c]        ;2153
000248  f8d41174          LDR      r1,[r4,#0x174]        ;2154
00024c  f4215180          BIC      r1,r1,#0x1000         ;2154
000250  f8c41174          STR      r1,[r4,#0x174]        ;2154
000254  e002              B        |L6.604|
000256  e021              B        |L6.668|
000258  e016              B        |L6.648|
00025a  e09c              B        |L6.918|
                  |L6.604|
00025c  f2427110          MOV      r1,#0x2710            ;2159
000260  f8c41110          STR      r1,[r4,#0x110]        ;2159
000264  f8d41120          LDR      r1,[r4,#0x120]        ;2162
000268  f0410101          ORR      r1,r1,#1              ;2162
00026c  f8c41120          STR      r1,[r4,#0x120]        ;2162
000270  f8d41104          LDR      r1,[r4,#0x104]        ;2165
000274  f0410180          ORR      r1,r1,#0x80           ;2165
000278  f8c41104          STR      r1,[r4,#0x104]        ;2165
00027c  70ae              STRB     r6,[r5,#2]            ;2167
00027e  7880              LDRB     r0,[r0,#2]            ;2168
000280  7028              STRB     r0,[r5,#0]            ;2168
000282  706b              STRB     r3,[r5,#1]            ;2169
000284  e8bd83f8          POP      {r3-r9,pc}
                  |L6.648|
000288  f88d1000          STRB     r1,[sp,#0]            ;2176
00028c  f8c5d020          STR      sp,[r5,#0x20]         ;2178  ; g_EP0_BufferAddr
000290  81ab              STRH     r3,[r5,#0xc]          ;2179
000292  2000              MOVS     r0,#0                 ;2182
000294  f7fffffe          BL       EP0_TxRx_Proc
000298  e8bd83f8          POP      {r3-r9,pc}
                  |L6.668|
00029c  8880              LDRH     r0,[r0,#4]            ;2189
00029e  b158              CBZ      r0,|L6.696|
0002a0  2801              CMP      r0,#1                 ;2189
0002a2  d010              BEQ      |L6.710|
0002a4  2802              CMP      r0,#2                 ;2189
0002a6  f47faf10          BNE      |L6.202|
0002aa  f8d40174          LDR      r0,[r4,#0x174]        ;2209
0002ae  f4205080          BIC      r0,r0,#0x1000         ;2209
0002b2  f8c40174          STR      r0,[r4,#0x174]        ;2209
0002b6  e708              B        |L6.202|
                  |L6.696|
0002b8  f8d40164          LDR      r0,[r4,#0x164]        ;2194
0002bc  f4205080          BIC      r0,r0,#0x1000         ;2194
0002c0  f8c40164          STR      r0,[r4,#0x164]        ;2194
0002c4  e701              B        |L6.202|
                  |L6.710|
0002c6  f8d40188          LDR      r0,[r4,#0x188]        ;2201
0002ca  f4205080          BIC      r0,r0,#0x1000         ;2201
0002ce  f8c40188          STR      r0,[r4,#0x188]        ;2201
0002d2  f8d4016c          LDR      r0,[r4,#0x16c]        ;2202
0002d6  f4205080          BIC      r0,r0,#0x1000         ;2202
0002da  f8c4016c          STR      r0,[r4,#0x16c]        ;2202
0002de  e6f4              B        |L6.202|
                  |L6.736|
0002e0  7841              LDRB     r1,[r0,#1]            ;2236
0002e2  2901              CMP      r1,#1                 ;2236
0002e4  d007              BEQ      |L6.758|
0002e6  4a4b              LDR      r2,|L6.1044|
0002e8  2902              CMP      r1,#2                 ;2236
0002ea  d05b              BEQ      |L6.932|
0002ec  2909              CMP      r1,#9                 ;2236
0002ee  d024              BEQ      |L6.826|
0002f0  290a              CMP      r1,#0xa               ;2236
0002f2  d047              BEQ      |L6.900|
0002f4  e04f              B        |L6.918|
                  |L6.758|
0002f6  8840              LDRH     r0,[r0,#2]            ;2242
0002f8  f400417f          AND      r1,r0,#0xff00         ;2242
0002fc  f5b17f40          CMP      r1,#0x300             ;2242
000300  d149              BNE      |L6.918|
000302  b2c0              UXTB     r0,r0                 ;2244
000304  2806              CMP      r0,#6                 ;2244
000306  d00c              BEQ      |L6.802|
000308  2808              CMP      r0,#8                 ;2244
00030a  d144              BNE      |L6.918|
00030c  4842              LDR      r0,|L6.1048|
00030e  f8808000          STRB     r8,[r0,#0]            ;2250
000312  7047              STRB     r7,[r0,#1]            ;2251
000314  6228              STR      r0,[r5,#0x20]         ;2255  ; g_EP0_BufferAddr
000316  81aa              STRH     r2,[r5,#0xc]          ;2255
000318  e8bd43f8          POP      {r3-r9,lr}            ;2258
00031c  2000              MOVS     r0,#0                 ;2258
00031e  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L6.802|
000322  483e              LDR      r0,|L6.1052|
000324  6a69              LDR      r1,[r5,#0x24]         ;2265  ; g_EP0_Offset
000326  4408              ADD      r0,r0,r1              ;2265
000328  6228              STR      r0,[r5,#0x20]         ;2266  ; g_EP0_BufferAddr
00032a  f2401001          MOV      r0,#0x101             ;2266
00032e  81a8              STRH     r0,[r5,#0xc]          ;2266
000330  e8bd43f8          POP      {r3-r9,lr}            ;2269
000334  2000              MOVS     r0,#0                 ;2269
000336  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L6.826|
00033a  8841              LDRH     r1,[r0,#2]            ;2283
00033c  f401427f          AND      r2,r1,#0xff00         ;2283
000340  f5b27f40          CMP      r2,#0x300             ;2283
000344  d127              BNE      |L6.918|
000346  b2c9              UXTB     r1,r1                 ;2287
000348  2907              CMP      r1,#7                 ;2287
00034a  d108              BNE      |L6.862|
00034c  4934              LDR      r1,|L6.1056|
00034e  6229              STR      r1,[r5,#0x20]         ;2290  ; g_EP0_BufferAddr
000350  88c0              LDRH     r0,[r0,#6]            ;2290
000352  81a8              STRH     r0,[r5,#0xc]          ;2290
000354  2001              MOVS     r0,#1                 ;2293
000356  f7fffffe          BL       EP0_TxRx_Proc
00035a  f04f0900          MOV      r9,#0                 ;2294
                  |L6.862|
00035e  69e8              LDR      r0,[r5,#0x1c]         ;2299  ; g_pSetupPacket
000360  7881              LDRB     r1,[r0,#2]            ;2299
000362  2905              CMP      r1,#5                 ;2299
000364  d005              BEQ      |L6.882|
000366  f1b90f00          CMP      r9,#0                 ;2589
00036a  bf08              IT       EQ
00036c  e8bd83f8          POPEQ    {r3-r9,pc}
000370  e011              B        |L6.918|
                  |L6.882|
000372  492c              LDR      r1,|L6.1060|
000374  6229              STR      r1,[r5,#0x20]         ;2302  ; g_EP0_BufferAddr
000376  88c0              LDRH     r0,[r0,#6]            ;2302
000378  81a8              STRH     r0,[r5,#0xc]          ;2302
00037a  e8bd43f8          POP      {r3-r9,lr}            ;2305
00037e  2001              MOVS     r0,#1                 ;2305
000380  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L6.900|
000384  8841              LDRH     r1,[r0,#2]            ;2319
000386  f01100ff          ANDS     r0,r1,#0xff           ;2319
00038a  ea4f2111          LSR      r1,r1,#8              ;2320
00038e  bf18              IT       NE                    ;2333
000390  5411              STRBNE   r1,[r2,r0]            ;2333
000392  f47fae9a          BNE      |L6.202|
                  |L6.918|
000396  f8d40120          LDR      r0,[r4,#0x120]        ;2325
00039a  f0400004          ORR      r0,r0,#4              ;2325
00039e  f8c40120          STR      r0,[r4,#0x120]        ;2325
0003a2  e692              B        |L6.202|
                  |L6.932|
0003a4  7880              LDRB     r0,[r0,#2]            ;2347
0003a6  4410              ADD      r0,r0,r2              ;2349
0003a8  6228              STR      r0,[r5,#0x20]         ;2350  ; g_EP0_BufferAddr
0003aa  81ab              STRH     r3,[r5,#0xc]          ;2350
0003ac  e8bd43f8          POP      {r3-r9,lr}            ;2353
0003b0  2000              MOVS     r0,#0                 ;2353
0003b2  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L6.950|
0003b6  8880              LDRH     r0,[r0,#4]            ;2369
0003b8  2804              CMP      r0,#4                 ;2369
0003ba  d0ec              BEQ      |L6.918|
0003bc  2805              CMP      r0,#5                 ;2369
0003be  d1ea              BNE      |L6.918|
0003c0  4c19              LDR      r4,|L6.1064|
0003c2  f44f7080          MOV      r0,#0x100             ;2409
0003c6  46a4              MOV      r12,r4                ;2408
0003c8  2604              MOVS     r6,#4                 ;2416
0003ca  f8cc7000          STR      r7,[r12,#0]           ;2408  ; MS_OS_Property
0003ce  f8ac0004          STRH     r0,[r12,#4]           ;2409
0003d2  2005              MOVS     r0,#5                 ;2410
0003d4  f8ac0006          STRH     r0,[r12,#6]           ;2410
0003d8  f8ac1008          STRH     r1,[r12,#8]           ;2411
0003dc  2142              MOVS     r1,#0x42              ;2415
0003de  f8cc100a          STR      r1,[r12,#0xa]         ;2415  ; MS_OS_Property
0003e2  2130              MOVS     r1,#0x30              ;2417
0003e4  a011              ADR      r0,|L6.1068|
0003e6  f8cc600e          STR      r6,[r12,#0xe]         ;2416  ; MS_OS_Property
0003ea  f8ac1012          STRH     r1,[r12,#0x12]        ;2417
0003ee  1e42              SUBS     r2,r0,#1              ;2418
0003f0  f10c0112          ADD      r1,r12,#0x12          ;2418
0003f4  200c              MOVS     r0,#0xc               ;2418
                  |L6.1014|
0003f6  7857              LDRB     r7,[r2,#1]            ;2420
0003f8  708f              STRB     r7,[r1,#2]            ;2420
0003fa  f8127f02          LDRB     r7,[r2,#2]!           ;2420
0003fe  f8017f04          STRB     r7,[r1,#4]!           ;2420
000402  e01f              B        |L6.1092|
                  |L6.1028|
                          DCD      0x20100000
                  |L6.1032|
                          DCD      ||.data||
                  |L6.1036|
                          DCD      ||.bss||
                  |L6.1040|
                          DCD      ||.bss||+0xc9c
                  |L6.1044|
                          DCD      ||.bss||+0x12
                  |L6.1048|
                          DCD      ||.data||+0x10
                  |L6.1052|
                          DCD      u8_HID_Touch_Blob
                  |L6.1056|
                          DCD      ||.data||+0x18
                  |L6.1060|
                          DCD      ||.data||+0xe
                  |L6.1064|
                          DCD      MS_OS_Property
                  |L6.1068|
00042c  53656c65          DCB      "SelectiveSuspendEnabled",0
000430  63746976
000434  65537573
000438  70656e64
00043c  456e6162
000440  6c656400
                  |L6.1092|
000444  1e40              SUBS     r0,r0,#1              ;2420
000446  d1d6              BNE      |L6.1014|
000448  f8cc6044          STR      r6,[r12,#0x44]        ;2422  ; MS_OS_Property
00044c  f8cc3048          STR      r3,[r12,#0x48]        ;2423  ; MS_OS_Property
000450  f8bc0008          LDRH     r0,[r12,#8]           ;2424  ; MS_OS_Property
000454  1c40              ADDS     r0,r0,#1              ;2424
000456  f8ac0008          STRH     r0,[r12,#8]           ;2424
00045a  f8dc0000          LDR      r0,[r12,#0]           ;2425  ; MS_OS_Property
00045e  3042              ADDS     r0,r0,#0x42           ;2425
000460  f8cc0000          STR      r0,[r12,#0]           ;2425  ; MS_OS_Property
000464  6a69              LDR      r1,[r5,#0x24]         ;2569  ; g_EP0_Offset
000466  4421              ADD      r1,r1,r4              ;2569
000468  6229              STR      r1,[r5,#0x20]         ;2570  ; g_EP0_BufferAddr
00046a  81a8              STRH     r0,[r5,#0xc]          ;2570
00046c  e8bd43f8          POP      {r3-r9,lr}            ;2573
000470  2000              MOVS     r0,#0                 ;2573
000472  f7ffbffe          B.W      EP0_TxRx_Proc
;;;2598   
                          ENDP


                          AREA ||i.EP0_SetupPacket_GetDescriptor||, CODE, READONLY, ALIGN=2

                  EP0_SetupPacket_GetDescriptor PROC
;;;1715   
;;;1716   void EP0_SetupPacket_GetDescriptor(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1717   {
;;;1718   	uint8_t	bStall = TRUE;
;;;1719   
;;;1720   	switch ((g_pSetupPacket->wValue & 0xFF00) >> 8)
000004  4f8a              LDR      r7,|L7.560|
000006  2200              MOVS     r2,#0
000008  2401              MOVS     r4,#1                 ;1718
00000a  69f9              LDR      r1,[r7,#0x1c]  ; g_pSetupPacket
;;;1721   	{
;;;1722   		case SETUPPACKET_DESCRIPTOR__DEVICE:
;;;1723   		{
;;;1724   			g_EP0_BufferAddr = &u8_FS_DeviceDesc[0];
;;;1725   			g_EP0_BufferLength = DEVICE_DESC_LENGTH;
;;;1726   
;;;1727   			// Tx
;;;1728   			EP0_TxRx_Proc(DIRECTION_IN);
;;;1729   			bStall = FALSE;
;;;1730   			break;
;;;1731   		}
;;;1732   
;;;1733   		case SETUPPACKET_DESCRIPTOR__CONFIGURATION:
;;;1734   		{
;;;1735   			g_EP0_BufferAddr = &u8_FS_ConfigDesc[g_EP0_Offset];
;;;1736   			g_EP0_BufferLength = CONFIG_DESC_LENGTH;
;;;1737   
;;;1738   			// Tx
;;;1739   			EP0_TxRx_Proc(DIRECTION_IN);
;;;1740   			bStall = FALSE;
;;;1741   			break;
;;;1742   		}
;;;1743   
;;;1744   		case SETUPPACKET_DESCRIPTOR__STRING:
;;;1745   		{
;;;1746   			switch (g_pSetupPacket->wValue & 0x00FF)
;;;1747   			{
;;;1748   				// Lang IDs
;;;1749   				case 0:
;;;1750   				{
;;;1751   					g_EP0_BufferAddr = &u8O_StrDesc_LangIDs[g_EP0_Offset];
;;;1752   					g_EP0_BufferLength = STRING_LANG_IDS_LENGTH;
;;;1753   
;;;1754   					// Tx
;;;1755   					EP0_TxRx_Proc(DIRECTION_IN);
;;;1756   					bStall = FALSE;
;;;1757   					break;
;;;1758   				}
;;;1759   
;;;1760   				// Product String
;;;1761   				case DEVICE_PRODUCT:
;;;1762   				{
;;;1763   					g_EP0_BufferAddr = &u8O_StrDesc_Product[g_EP0_Offset];
;;;1764   					g_EP0_BufferLength = STRING_PRODUCT_LENGTH;
;;;1765   
;;;1766   					// Tx
;;;1767   					EP0_TxRx_Proc(DIRECTION_IN);
;;;1768   					bStall = FALSE;
;;;1769   					break;
;;;1770   				}
;;;1771   				
;;;1772   				// Manufacturer
;;;1773   				case DEVICE_MANUFACTURER:
;;;1774   				{
;;;1775   					g_EP0_BufferAddr = &u8O_StrDesc_Manufacturer[g_EP0_Offset];
;;;1776   					g_EP0_BufferLength = STRING_MANUFACTURER_LENGTH;
;;;1777   
;;;1778   					// Tx
;;;1779   					EP0_TxRx_Proc(DIRECTION_IN);
;;;1780   					bStall = FALSE;
;;;1781   					break;
;;;1782   				}
;;;1783   
;;;1784   				// String Microsoft OS
;;;1785   				case SETUPPACKET_DESCRIPTOR__MS_OS:
;;;1786   				{
;;;1787   					if (g_pSetupPacket->wValue == SETUPPACKET_DESCRIPTOR__MS_OS_2)
;;;1788   					{
;;;1789   #ifdef USB_SELECTIVE_SUSPEND
;;;1790   						uint8_t* pBuffer = (uint8_t*)&MS_OS_Descriptor;
;;;1791   
;;;1792   						MS_OS_Descriptor.Length = sizeof(MS_OS_STRING_DESCRIPTOR);
;;;1793   						MS_OS_Descriptor.Type = SETUPPACKET_DESCRIPTOR__STRING;
00000c  f04f0c03          MOV      r12,#3
000010  8848              LDRH     r0,[r1,#2]            ;1720
000012  0a05              LSRS     r5,r0,#8              ;1720
000014  2d0f              CMP      r5,#0xf               ;1720
000016  f00080e7          BEQ.W    |L7.488|
00001a  dc08              BGT      |L7.46|
00001c  f04f0112          MOV      r1,#0x12              ;1725
000020  2d01              CMP      r5,#1                 ;1720
000022  d00a              BEQ      |L7.58|
000024  2d02              CMP      r5,#2                 ;1720
000026  d010              BEQ      |L7.74|
000028  2d03              CMP      r5,#3                 ;1720
00002a  d019              BEQ      |L7.96|
00002c  e026              B        |L7.124|
                  |L7.46|
;;;1794   						MS_OS_Descriptor.Signature[0] = 'M';
;;;1795   						MS_OS_Descriptor.Signature[2] = 'S';
;;;1796   						MS_OS_Descriptor.Signature[4] = 'F';
;;;1797   						MS_OS_Descriptor.Signature[6] = 'T';
;;;1798   						MS_OS_Descriptor.Signature[8] = '1';
;;;1799   						MS_OS_Descriptor.Signature[10] = '0';
;;;1800   						MS_OS_Descriptor.Signature[12] = '0';
;;;1801   						MS_OS_Descriptor.MSVendorCode = SETUPPACKET_DESCRIPTOR__MS_OS_VENDOR_CODE;
;;;1802   						MS_OS_Descriptor.Pad = 0x00;
;;;1803   
;;;1804   						g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;1805   						g_EP0_BufferLength = sizeof(MS_OS_STRING_DESCRIPTOR);
;;;1806   						
;;;1807   						// Tx
;;;1808   						EP0_TxRx_Proc(DIRECTION_IN);
;;;1809   						bStall = FALSE;
;;;1810   #endif
;;;1811   					}
;;;1812   
;;;1813   					break;
;;;1814   				}
;;;1815   			}
;;;1816   
;;;1817   			break;
;;;1818   		}
;;;1819   
;;;1820   		case SETUPPACKET_DESCRIPTOR__HID:
;;;1821   		{
;;;1822   			uint8_t	i = 0;
;;;1823   			uint8_t*	pBuffer = (uint8_t*)&g_HID_Descriptor;
;;;1824   
;;;1825   			g_HID_Descriptor.bLength = HID_DESCRIPTOR_LENGTH;
;;;1826   			g_HID_Descriptor.bDescriptorType = SETUPPACKET_DESCRIPTOR__HID;
;;;1827   			g_HID_Descriptor.bcdHID = HID_VERSION;
;;;1828   			g_HID_Descriptor.bCountryCode = 0;
;;;1829   			g_HID_Descriptor.bNumDescriptors = 1;
;;;1830   			g_HID_Descriptor.bDescriptorType_Class = SETUPPACKET_DESCRIPTOR__REPORT;
;;;1831   	
;;;1832   			switch (g_pSetupPacket->wIndex)
;;;1833   			{
;;;1834   #ifdef ADD_TOUCH
;;;1835   				// Multi-Touch
;;;1836   				case TOUCH_INTERFACE_NUM:
;;;1837   				{
;;;1838   					g_HID_Descriptor.wDescriptorLength = HID_MULTITOUCH_DESC_HEAD_LENGTH;
;;;1839   					for (i = 0; i < HID_MAX_TOUCH; i++)
;;;1840   					{
;;;1841   						g_HID_Descriptor.wDescriptorLength += HID_MULTITOUCH_DESC_MAIN_LENGTH;
;;;1842   					}
;;;1843   
;;;1844   					g_HID_Descriptor.wDescriptorLength += HID_MULTITOUCH_DESC_TAIL_LENGTH;
;;;1845   					break;
;;;1846   				}
;;;1847   #endif
;;;1848   
;;;1849   #ifdef ADD_CUSTOM
;;;1850   				// Custom
;;;1851   				case CUSTOM_INTERFACE_NUM:
;;;1852   				{
;;;1853   					g_HID_Descriptor.wDescriptorLength = HID_CUSTOM_DESC_LENGTH;
00002e  2326              MOVS     r3,#0x26
000030  2d21              CMP      r5,#0x21              ;1720
000032  d07d              BEQ      |L7.304|
000034  2d22              CMP      r5,#0x22              ;1720
000036  d07c              BEQ      |L7.306|
000038  e020              B        |L7.124|
                  |L7.58|
00003a  487e              LDR      r0,|L7.564|
00003c  6238              STR      r0,[r7,#0x20]         ;1725  ; g_EP0_BufferAddr
00003e  81b9              STRH     r1,[r7,#0xc]          ;1725
000040  e8bd41f0          POP      {r4-r8,lr}            ;1728
000044  2000              MOVS     r0,#0                 ;1728
000046  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.74|
00004a  487b              LDR      r0,|L7.568|
00004c  6a79              LDR      r1,[r7,#0x24]         ;1735  ; g_EP0_Offset
00004e  4408              ADD      r0,r0,r1              ;1735
000050  6238              STR      r0,[r7,#0x20]         ;1736  ; g_EP0_BufferAddr
000052  2052              MOVS     r0,#0x52              ;1736
000054  81b8              STRH     r0,[r7,#0xc]          ;1736
000056  e8bd41f0          POP      {r4-r8,lr}            ;1739
00005a  2000              MOVS     r0,#0                 ;1739
00005c  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.96|
000060  f01003ff          ANDS     r3,r0,#0xff           ;1746
000064  d01b              BEQ      |L7.158|
000066  2b01              CMP      r3,#1                 ;1746
000068  d024              BEQ      |L7.180|
00006a  2b02              CMP      r3,#2                 ;1746
00006c  d02d              BEQ      |L7.202|
00006e  2bee              CMP      r3,#0xee              ;1746
000070  bf04              ITT      EQ                    ;1787
000072  f5a07300          SUBEQ    r3,r0,#0x200          ;1787
000076  f5b373f7          SUBSEQ   r3,r3,#0x1ee          ;1787
00007a  d031              BEQ      |L7.224|
                  |L7.124|
;;;1854   					break;
;;;1855   				}
;;;1856   #endif
;;;1857   
;;;1858   #ifdef ADD_PEN
;;;1859   				// Pen
;;;1860   				case PEN_INTERFACE_NUM:
;;;1861   				{
;;;1862   					g_HID_Descriptor.wDescriptorLength = HID_PEN_DESC_LENGTH;
;;;1863   					break;
;;;1864   				}
;;;1865   #endif
;;;1866   			}
;;;1867   
;;;1868   			g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;1869   			g_EP0_BufferLength = HID_DESCRIPTOR_LENGTH;
;;;1870   
;;;1871   			// Tx
;;;1872   			EP0_TxRx_Proc(DIRECTION_IN);
;;;1873   			bStall = FALSE;
;;;1874   			break;
;;;1875   		}
;;;1876   
;;;1877   		case SETUPPACKET_DESCRIPTOR__REPORT:
;;;1878   		{
;;;1879   			switch (g_pSetupPacket->wIndex)
;;;1880   			{
;;;1881   #ifdef ADD_TOUCH
;;;1882   				// Multi-Touch
;;;1883   				case TOUCH_INTERFACE_NUM:
;;;1884   				{
;;;1885   					uint8_t	i = 0;
;;;1886   					uint16_t	Offset = 0;
;;;1887   
;;;1888   					// Head
;;;1889   					memcpy(&u8_HID_MultiTouchReportDesc_Temp[Offset], u8_HID_MultiTouch_Descriptor_Head, HID_MULTITOUCH_DESC_HEAD_LENGTH);
;;;1890   					Offset += HID_MULTITOUCH_DESC_HEAD_LENGTH;
;;;1891   
;;;1892   					// Main
;;;1893   					for (i = 0; i < HID_MAX_TOUCH; i++)
;;;1894   					{
;;;1895   						memcpy(&u8_HID_MultiTouchReportDesc_Temp[Offset], u8_HID_MultiTouch_Descriptor_Main, HID_MULTITOUCH_DESC_MAIN_LENGTH);
;;;1896   						Offset += HID_MULTITOUCH_DESC_MAIN_LENGTH;
;;;1897   					}
;;;1898   
;;;1899   					// Tail
;;;1900   					memcpy(&u8_HID_MultiTouchReportDesc_Temp[Offset], u8_HID_MultiTouch_Descriptor_Tail, HID_MULTITOUCH_DESC_TAIL_LENGTH);
;;;1901   					Offset += HID_MULTITOUCH_DESC_TAIL_LENGTH;
;;;1902   					
;;;1903   
;;;1904   					g_EP0_BufferAddr = &u8_HID_MultiTouchReportDesc_Temp[g_EP0_Offset];
;;;1905   					g_EP0_BufferLength = Offset;
;;;1906   					break;
;;;1907   				}
;;;1908   #endif
;;;1909   
;;;1910   #ifdef ADD_CUSTOM
;;;1911   				// Custom
;;;1912   				case CUSTOM_INTERFACE_NUM:
;;;1913   				{
;;;1914   					g_EP0_BufferAddr = &u8_HID_Custom_Descriptor[g_EP0_Offset];
;;;1915   					g_EP0_BufferLength = HID_CUSTOM_DESC_LENGTH;
;;;1916   					break;
;;;1917   				}
;;;1918   #endif
;;;1919   
;;;1920   #ifdef ADD_PEN
;;;1921   				// Pen
;;;1922   				case PEN_INTERFACE_NUM:
;;;1923   				{
;;;1924   					g_EP0_BufferAddr = &u8_HID_Pen_Descriptor[g_EP0_Offset];
;;;1925   					g_EP0_BufferLength = HID_PEN_DESC_LENGTH;
;;;1926   					break;
;;;1927   				}
;;;1928   #endif
;;;1929   			}
;;;1930   
;;;1931   			// Tx
;;;1932   			EP0_TxRx_Proc(DIRECTION_IN);
;;;1933   			bStall = FALSE;
;;;1934   			break;
;;;1935   		}
;;;1936   
;;;1937   #ifdef USB_SELECTIVE_SUSPEND
;;;1938   		case SETUPPACKET_DESCRIPTOR__BOS:
;;;1939   		{
;;;1940   			uint8_t*	pBuffer = (uint8_t*)&BOS_Descriptor;
;;;1941   
;;;1942   			BOS_Descriptor.Length = 5;
;;;1943   			BOS_Descriptor.Type = SETUPPACKET_DESCRIPTOR__BOS;
;;;1944   			BOS_Descriptor.TotalLength = sizeof(BOS_DESCRIPTOR);
;;;1945   			BOS_Descriptor.NumCapability = 1;
;;;1946   			BOS_Descriptor.Usb20ExtDesc.Length = sizeof(USB20_EXT_DESCRIPTOR);
;;;1947   			BOS_Descriptor.Usb20ExtDesc.Type = 0x10;
;;;1948   			BOS_Descriptor.Usb20ExtDesc.DevCapabilityType = 0x02;
;;;1949   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_LPM_Support = 1;
;;;1950   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_BESL_Support = 1;
;;;1951   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_BaseLineBESL = 1;
;;;1952   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_DeepBESL = 1;
;;;1953   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_BESL = 10;
;;;1954   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_DBESL = 11;
;;;1955   
;;;1956   			g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;1957   			g_EP0_BufferLength = sizeof(BOS_DESCRIPTOR);
;;;1958   			EP0_TxRx_Proc(DIRECTION_IN);
;;;1959   			bStall = FALSE;
;;;1960   			break;
;;;1961   		}
;;;1962   #endif
;;;1963   	}
;;;1964   
;;;1965   
;;;1966   	if (bStall == TRUE)
;;;1967   	{
;;;1968   		mUsbEP0StallSet();
00007c  486f              LDR      r0,|L7.572|
00007e  f8d01120          LDR      r1,[r0,#0x120]
000082  f0410104          ORR      r1,r1,#4
000086  f8c01120          STR      r1,[r0,#0x120]
;;;1969   		mUsbEP0DoneSet();
00008a  f8d01120          LDR      r1,[r0,#0x120]
00008e  f0410101          ORR      r1,r1,#1
000092  f8c01120          STR      r1,[r0,#0x120]
;;;1970   		g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
000096  f887c002          STRB     r12,[r7,#2]
;;;1971   	}
;;;1972   
;;;1973   	return;
;;;1974   }
00009a  e8bd81f0          POP      {r4-r8,pc}
                  |L7.158|
00009e  4868              LDR      r0,|L7.576|
0000a0  6a79              LDR      r1,[r7,#0x24]         ;1751  ; g_EP0_Offset
0000a2  4408              ADD      r0,r0,r1              ;1751
0000a4  6238              STR      r0,[r7,#0x20]         ;1752  ; g_EP0_BufferAddr
0000a6  2004              MOVS     r0,#4                 ;1752
0000a8  81b8              STRH     r0,[r7,#0xc]          ;1752
0000aa  e8bd41f0          POP      {r4-r8,lr}            ;1755
0000ae  2000              MOVS     r0,#0                 ;1755
0000b0  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.180|
0000b4  4863              LDR      r0,|L7.580|
0000b6  6a79              LDR      r1,[r7,#0x24]         ;1763  ; g_EP0_Offset
0000b8  4408              ADD      r0,r0,r1              ;1763
0000ba  6238              STR      r0,[r7,#0x20]         ;1764  ; g_EP0_BufferAddr
0000bc  2032              MOVS     r0,#0x32              ;1764
0000be  81b8              STRH     r0,[r7,#0xc]          ;1764
0000c0  e8bd41f0          POP      {r4-r8,lr}            ;1767
0000c4  2000              MOVS     r0,#0                 ;1767
0000c6  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.202|
0000ca  485f              LDR      r0,|L7.584|
0000cc  6a79              LDR      r1,[r7,#0x24]         ;1775  ; g_EP0_Offset
0000ce  4408              ADD      r0,r0,r1              ;1775
0000d0  6238              STR      r0,[r7,#0x20]         ;1776  ; g_EP0_BufferAddr
0000d2  201a              MOVS     r0,#0x1a              ;1776
0000d4  81b8              STRH     r0,[r7,#0xc]          ;1776
0000d6  e8bd41f0          POP      {r4-r8,lr}            ;1779
0000da  2000              MOVS     r0,#0                 ;1779
0000dc  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.224|
0000e0  4b5a              LDR      r3,|L7.588|
0000e2  4618              MOV      r0,r3                 ;1792
0000e4  7001              STRB     r1,[r0,#0]            ;1792
0000e6  f880c001          STRB     r12,[r0,#1]           ;1793
0000ea  f04f0c4d          MOV      r12,#0x4d             ;1794
0000ee  f880c002          STRB     r12,[r0,#2]           ;1794
0000f2  f04f0c53          MOV      r12,#0x53             ;1795
0000f6  f880c004          STRB     r12,[r0,#4]           ;1795
0000fa  f04f0c46          MOV      r12,#0x46             ;1796
0000fe  f880c006          STRB     r12,[r0,#6]           ;1796
000102  f04f0c54          MOV      r12,#0x54             ;1797
000106  f880c008          STRB     r12,[r0,#8]           ;1797
00010a  f04f0c31          MOV      r12,#0x31             ;1798
00010e  f880c00a          STRB     r12,[r0,#0xa]         ;1798
000112  f04f0c30          MOV      r12,#0x30             ;1799
000116  f880c00c          STRB     r12,[r0,#0xc]         ;1799
00011a  f880c00e          STRB     r12,[r0,#0xe]         ;1800
00011e  f04f0c98          MOV      r12,#0x98             ;1801
000122  f880c010          STRB     r12,[r0,#0x10]        ;1801
000126  7442              STRB     r2,[r0,#0x11]         ;1802
000128  6a78              LDR      r0,[r7,#0x24]         ;1804  ; g_EP0_Offset
00012a  4418              ADD      r0,r0,r3              ;1804
00012c  6238              STR      r0,[r7,#0x20]         ;1805  ; g_EP0_BufferAddr
00012e  e001              B        |L7.308|
                  |L7.304|
000130  e006              B        |L7.320|
                  |L7.306|
000132  e02a              B        |L7.394|
                  |L7.308|
000134  81b9              STRH     r1,[r7,#0xc]          ;1805
000136  e8bd41f0          POP      {r4-r8,lr}            ;1808
00013a  2000              MOVS     r0,#0                 ;1808
00013c  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.320|
000140  4d43              LDR      r5,|L7.592|
000142  f04f0c09          MOV      r12,#9                ;1825
000146  4628              MOV      r0,r5                 ;1825
000148  2621              MOVS     r6,#0x21              ;1826
00014a  f880c000          STRB     r12,[r0,#0]           ;1825
00014e  7046              STRB     r6,[r0,#1]            ;1826
000150  f2401611          MOV      r6,#0x111             ;1827
000154  8046              STRH     r6,[r0,#2]            ;1827
000156  7102              STRB     r2,[r0,#4]            ;1828
000158  7144              STRB     r4,[r0,#5]            ;1829
00015a  2222              MOVS     r2,#0x22              ;1830
00015c  7182              STRB     r2,[r0,#6]            ;1830
00015e  8889              LDRH     r1,[r1,#4]            ;1832
000160  2900              CMP      r1,#0                 ;1832
000162  bf04              ITT      EQ                    ;1844
000164  f24021cd          MOVEQ    r1,#0x2cd             ;1844
000168  f8a01007          STRHEQ   r1,[r0,#7]            ;1844
00016c  d003              BEQ      |L7.374|
00016e  2901              CMP      r1,#1                 ;1832
000170  bf08              IT       EQ                    ;1853
000172  f8a03007          STRHEQ   r3,[r0,#7]            ;1853
                  |L7.374|
000176  6a78              LDR      r0,[r7,#0x24]         ;1868  ; g_EP0_Offset
000178  4428              ADD      r0,r0,r5              ;1868
00017a  6238              STR      r0,[r7,#0x20]         ;1869  ; g_EP0_BufferAddr
00017c  f8a7c00c          STRH     r12,[r7,#0xc]         ;1869
000180  e8bd41f0          POP      {r4-r8,lr}            ;1872
000184  2000              MOVS     r0,#0                 ;1872
000186  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.394|
00018a  8888              LDRH     r0,[r1,#4]            ;1879
00018c  b110              CBZ      r0,|L7.404|
00018e  2801              CMP      r0,#1                 ;1879
000190  d020              BEQ      |L7.468|
000192  e024              B        |L7.478|
                  |L7.404|
000194  4830              LDR      r0,|L7.600|
000196  4c2f              LDR      r4,|L7.596|
000198  2600              MOVS     r6,#0                 ;1885
00019a  6801              LDR      r1,[r0,#0]            ;1889  ; u8_HID_MultiTouch_Descriptor_Head
00019c  6021              STR      r1,[r4,#0]            ;1889
00019e  6840              LDR      r0,[r0,#4]            ;1889  ; u8_HID_MultiTouch_Descriptor_Head
0001a0  6060              STR      r0,[r4,#4]            ;1889
0001a2  2508              MOVS     r5,#8                 ;1890
                  |L7.420|
0001a4  1960              ADDS     r0,r4,r5              ;1895
0001a6  2240              MOVS     r2,#0x40              ;1895
0001a8  492c              LDR      r1,|L7.604|
0001aa  f7fffffe          BL       __aeabi_memcpy
0001ae  f1050040          ADD      r0,r5,#0x40           ;1896
0001b2  b285              UXTH     r5,r0                 ;1896
0001b4  1c70              ADDS     r0,r6,#1              ;1896
0001b6  b2c6              UXTB     r6,r0                 ;1896
0001b8  2e0a              CMP      r6,#0xa               ;1896
0001ba  d3f3              BCC      |L7.420|
0001bc  1960              ADDS     r0,r4,r5              ;1900
0001be  2245              MOVS     r2,#0x45              ;1900
0001c0  4927              LDR      r1,|L7.608|
0001c2  f7fffffe          BL       __aeabi_memcpy
0001c6  6a79              LDR      r1,[r7,#0x24]         ;1904  ; g_EP0_Offset
0001c8  f1050045          ADD      r0,r5,#0x45           ;1901
0001cc  4421              ADD      r1,r1,r4              ;1904
0001ce  6239              STR      r1,[r7,#0x20]         ;1905  ; g_EP0_BufferAddr
0001d0  81b8              STRH     r0,[r7,#0xc]          ;1905
0001d2  e004              B        |L7.478|
                  |L7.468|
0001d4  4823              LDR      r0,|L7.612|
0001d6  6a79              LDR      r1,[r7,#0x24]         ;1914  ; g_EP0_Offset
0001d8  4408              ADD      r0,r0,r1              ;1914
0001da  6238              STR      r0,[r7,#0x20]         ;1915  ; g_EP0_BufferAddr
0001dc  81bb              STRH     r3,[r7,#0xc]          ;1915
                  |L7.478|
0001de  e8bd41f0          POP      {r4-r8,lr}            ;1932
0001e2  2000              MOVS     r0,#0                 ;1932
0001e4  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.488|
0001e8  4a1f              LDR      r2,|L7.616|
0001ea  2105              MOVS     r1,#5                 ;1942
0001ec  4610              MOV      r0,r2                 ;1942
0001ee  2307              MOVS     r3,#7                 ;1946
0001f0  7001              STRB     r1,[r0,#0]            ;1942
0001f2  210f              MOVS     r1,#0xf               ;1943
0001f4  7041              STRB     r1,[r0,#1]            ;1943
0001f6  210c              MOVS     r1,#0xc               ;1944
0001f8  8041              STRH     r1,[r0,#2]            ;1944
0001fa  7104              STRB     r4,[r0,#4]            ;1945
0001fc  7143              STRB     r3,[r0,#5]            ;1946
0001fe  2310              MOVS     r3,#0x10              ;1947
000200  7183              STRB     r3,[r0,#6]            ;1947
000202  2302              MOVS     r3,#2                 ;1948
000204  71c3              STRB     r3,[r0,#7]            ;1948
000206  7a03              LDRB     r3,[r0,#8]            ;1949  ; BOS_Descriptor
000208  f043031e          ORR      r3,r3,#0x1e           ;1952
00020c  7203              STRB     r3,[r0,#8]            ;1952
00020e  7a43              LDRB     r3,[r0,#9]            ;1953  ; BOS_Descriptor
000210  f023030f          BIC      r3,r3,#0xf            ;1953
000214  330a              ADDS     r3,r3,#0xa            ;1953
000216  f02303f0          BIC      r3,r3,#0xf0           ;1954
00021a  33b0              ADDS     r3,r3,#0xb0           ;1954
00021c  7243              STRB     r3,[r0,#9]            ;1954
00021e  6a78              LDR      r0,[r7,#0x24]         ;1956  ; g_EP0_Offset
000220  4410              ADD      r0,r0,r2              ;1956
000222  6238              STR      r0,[r7,#0x20]         ;1957  ; g_EP0_BufferAddr
000224  81b9              STRH     r1,[r7,#0xc]          ;1957
000226  e8bd41f0          POP      {r4-r8,lr}            ;1958
00022a  2000              MOVS     r0,#0                 ;1958
00022c  f7ffbffe          B.W      EP0_TxRx_Proc
;;;1975   
                          ENDP

                  |L7.560|
                          DCD      ||.data||
                  |L7.564|
                          DCD      u8_FS_DeviceDesc
                  |L7.568|
                          DCD      u8_FS_ConfigDesc
                  |L7.572|
                          DCD      0x20100000
                  |L7.576|
                          DCD      u8O_StrDesc_LangIDs
                  |L7.580|
                          DCD      u8O_StrDesc_Product
                  |L7.584|
                          DCD      u8O_StrDesc_Manufacturer
                  |L7.588|
                          DCD      MS_OS_Descriptor
                  |L7.592|
                          DCD      ||.bss||+0x111
                  |L7.596|
                          DCD      ||.bss||+0x9cf
                  |L7.600|
                          DCD      u8_HID_MultiTouch_Descriptor_Head
                  |L7.604|
                          DCD      u8_HID_MultiTouch_Descriptor_Main
                  |L7.608|
                          DCD      u8_HID_MultiTouch_Descriptor_Tail
                  |L7.612|
                          DCD      u8_HID_Custom_Descriptor
                  |L7.616|
                          DCD      BOS_Descriptor

                          AREA ||i.EP0_TxRx_Proc||, CODE, READONLY, ALIGN=2

                  EP0_TxRx_Proc PROC
;;;1669   
;;;1670   void EP0_TxRx_Proc(uint8_t Dirction)
000000  4b1d              LDR      r3,|L8.120|
;;;1671   {
;;;1672   	uint16_t wLength = 0;
;;;1673   
;;;1674   	// 처음 데이터를 처리하는 경우
;;;1675   	if (g_EP0_Remain == 0)
000002  461a              MOV      r2,r3
000004  6a99              LDR      r1,[r3,#0x28]         ;1671  ; g_EP0_Remain
;;;1676   	{
;;;1677   		if (g_pSetupPacket->wLength >= g_EP0_BufferLength)
000006  8992              LDRH     r2,[r2,#0xc]
000008  b121              CBZ      r1,|L8.20|
;;;1678   		{
;;;1679   			wLength = (g_EP0_BufferLength >= MX_PA_SZ_64) ? MX_PA_SZ_64 : g_EP0_BufferLength;
;;;1680   		}
;;;1681   		else
;;;1682   		{
;;;1683   			wLength = g_pSetupPacket->wLength;
;;;1684   		}
;;;1685   	}
;;;1686   	// 이어서 데이터를 처리하는 경우
;;;1687   	else
;;;1688   	{
;;;1689   		if (g_EP0_Remain >= MX_PA_SZ_64)
00000a  2940              CMP      r1,#0x40
;;;1690   		{
;;;1691   			wLength = MX_PA_SZ_64;
;;;1692   		}
;;;1693   		else
;;;1694   		{
;;;1695   			wLength = g_EP0_Remain;
00000c  bf38              IT       CC
00000e  b289              UXTHCC   r1,r1
000010  d208              BCS      |L8.36|
000012  e008              B        |L8.38|
                  |L8.20|
000014  69d9              LDR      r1,[r3,#0x1c]         ;1677  ; g_pSetupPacket
000016  88c9              LDRH     r1,[r1,#6]            ;1677
000018  4291              CMP      r1,r2                 ;1677
00001a  d304              BCC      |L8.38|
00001c  2a40              CMP      r2,#0x40              ;1679
00001e  bf38              IT       CC                    ;1679
000020  4611              MOVCC    r1,r2                 ;1679
000022  d300              BCC      |L8.38|
                  |L8.36|
000024  2140              MOVS     r1,#0x40              ;1679
                  |L8.38|
;;;1696   		}
;;;1697   	}
;;;1698   
;;;1699   	
;;;1700   
;;;1701   	g_EP0_Offset += wLength;
000026  f8d3c024          LDR      r12,[r3,#0x24]  ; g_EP0_Offset
00002a  448c              ADD      r12,r12,r1
;;;1702   	g_EP0_Remain = g_EP0_BufferLength - g_EP0_Offset;
00002c  eba2020c          SUB      r2,r2,r12
;;;1703   	g_EP0_Check = 1;
000030  f8c3c024          STR      r12,[r3,#0x24]  ; g_EP0_Offset
000034  629a              STR      r2,[r3,#0x28]  ; g_EP0_Remain
000036  2201              MOVS     r2,#1
000038  715a              STRB     r2,[r3,#5]
;;;1704   
;;;1705   	// Virtual DMA
;;;1706   	mUsbCXIntDmaErrEn();
00003a  4a10              LDR      r2,|L8.124|
00003c  f8d2c32c          LDR      r12,[r2,#0x32c]
000040  f42c3c80          BIC      r12,r12,#0x10000
000044  f8c2c32c          STR      r12,[r2,#0x32c]
;;;1707   	mUsbCXIntDmaFinishEn();
000048  f8d2c32c          LDR      r12,[r2,#0x32c]
00004c  f02c0c01          BIC      r12,r12,#1
000050  f8c2c32c          STR      r12,[r2,#0x32c]
;;;1708   
;;;1709   	mUsbCXDmaConfig(wLength, Dirction);
000054  0209              LSLS     r1,r1,#8
000056  f1c00001          RSB      r0,r0,#1
00005a  ea410040          ORR      r0,r1,r0,LSL #1
00005e  f8c20300          STR      r0,[r2,#0x300]
;;;1710   	mUsbCXDmaAddr((uint32_t)g_EP0_BufferAddr);
000062  6a18              LDR      r0,[r3,#0x20]  ; g_EP0_BufferAddr
000064  f8c20304          STR      r0,[r2,#0x304]
;;;1711   	mUsbCXDmaStart();
000068  f8d20300          LDR      r0,[r2,#0x300]
00006c  f0400001          ORR      r0,r0,#1
000070  f8c20300          STR      r0,[r2,#0x300]
;;;1712   	return;
;;;1713   }
000074  4770              BX       lr
;;;1714   
                          ENDP

000076  0000              DCW      0x0000
                  |L8.120|
                          DCD      ||.data||
                  |L8.124|
                          DCD      0x20100000

                          AREA ||i.GetScanTime||, CODE, READONLY, ALIGN=2

                  GetScanTime PROC
;;;507    
;;;508    uint16_t GetScanTime(uint64_t* StartTime, uint32_t* ScanTime)
000000  b570              PUSH     {r4-r6,lr}
;;;509    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  e9d60100          LDRD     r0,r1,[r6,#0]
00000a  2400              MOVS     r4,#0
;;;510    	uint16_t Temp = 0;
;;;511    
;;;512    	if (*StartTime == 0)
00000c  ea500201          ORRS     r2,r0,r1
000010  d00e              BEQ      |L9.48|
;;;513    	{
;;;514    		goto GETSCANTIME__GOTO_END;
;;;515    	}
;;;516    
;;;517    	// getLongSysTick() 함수를 통해서 구한 값은 계속 작아진다.
;;;518    	// 일반적인 Tick Count 와는 다른 듯...
;;;519    	Temp = (uint16_t)(getElapsedUS(*StartTime) / 100);
000012  f7fffffe          BL       getElapsedLongSYSTICK
000016  4a10              LDR      r2,|L9.88|
000018  6812              LDR      r2,[r2,#0]  ; _timer_clock_
00001a  4623              MOV      r3,r4
00001c  f7fffffe          BL       __aeabi_uldivmod
000020  2264              MOVS     r2,#0x64
000022  2300              MOVS     r3,#0
000024  f7fffffe          BL       __aeabi_uldivmod
;;;520    	*ScanTime += Temp;
000028  6829              LDR      r1,[r5,#0]
00002a  b280              UXTH     r0,r0                 ;519
00002c  4408              ADD      r0,r0,r1
00002e  6028              STR      r0,[r5,#0]
                  |L9.48|
;;;521    
;;;522    GETSCANTIME__GOTO_END:
;;;523    
;;;524    	*StartTime = (uint64_t)getLongSysTick();
000030  480a              LDR      r0,|L9.92|
000032  6800              LDR      r0,[r0,#0]  ; _timertick_high_rank_count_
000034  03a2              LSLS     r2,r4,#14
000036  ea424190          ORR      r1,r2,r0,LSR #18
00003a  0382              LSLS     r2,r0,#14
00003c  f04f4080          MOV      r0,#0x40000000
000040  f8d001b8          LDR      r0,[r0,#0x1b8]
000044  f3c0000d          UBFX     r0,r0,#0,#14
000048  4310              ORRS     r0,r0,r2
00004a  4321              ORRS     r1,r1,r4
00004c  e9c60100          STRD     r0,r1,[r6,#0]
;;;525    	return *ScanTime;
000050  8828              LDRH     r0,[r5,#0]
000052  b280              UXTH     r0,r0
;;;526    }
000054  bd70              POP      {r4-r6,pc}
;;;527    
                          ENDP

000056  0000              DCW      0x0000
                  |L9.88|
                          DCD      _timer_clock_
                  |L9.92|
                          DCD      _timertick_high_rank_count_

                          AREA ||i.HidReadWrite__Read||, CODE, READONLY, ALIGN=2

                  HidReadWrite__Read PROC
;;;886    
;;;887    void HidReadWrite__Read(PHJ_HID_CONTROL_STRUCT pOutBuffer)
000000  b570              PUSH     {r4-r6,lr}
;;;888    {
000002  4604              MOV      r4,r0
;;;889    	uint16_t	index = 0;
;;;890    	uint16_t	test_InputOffset = 0;
;;;891    
;;;892    	pOutBuffer->PacketID = HID_REPORT_ID__CUSTOM_IN;
000004  200a              MOVS     r0,#0xa
000006  7020              STRB     r0,[r4,#0]
;;;893    	pOutBuffer->DeviceID_b.addr = 0x34;
000008  7860              LDRB     r0,[r4,#1]
00000a  2600              MOVS     r6,#0                 ;889
00000c  f02000fe          BIC      r0,r0,#0xfe
000010  3068              ADDS     r0,r0,#0x68
;;;894    	pOutBuffer->DeviceID_b.bRead = TRUE;
000012  f0400001          ORR      r0,r0,#1
000016  7060              STRB     r0,[r4,#1]
000018  4635              MOV      r5,r6                 ;890
;;;895    //	pOutBuffer->Length = pOutBuffer->Length;
;;;896    	
;;;897    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_START, 0, 0, 0);
00001a  4633              MOV      r3,r6
00001c  4632              MOV      r2,r6
00001e  4631              MOV      r1,r6
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;898    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH, 0, 0, 0);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  4619              MOV      r1,r3
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;899    
;;;900    	for (index = 0; index<pOutBuffer->Length; index++)
000032  8860              LDRH     r0,[r4,#2]
000034  2800              CMP      r0,#0
000036  d90f              BLS      |L10.88|
                  |L10.56|
;;;901    	{
;;;902    		pOutBuffer->Data[test_InputOffset++] = protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER, 0, I2C_SLAVE_FSM_STATUS_READ_END, 0);
000038  2300              MOVS     r3,#0
00003a  f44f6280          MOV      r2,#0x400
00003e  4619              MOV      r1,r3
000040  2003              MOVS     r0,#3
000042  f7fffffe          BL       protocol_hid_mapping_emul_handler
000046  1961              ADDS     r1,r4,r5
000048  7108              STRB     r0,[r1,#4]
00004a  1c68              ADDS     r0,r5,#1
00004c  b285              UXTH     r5,r0
00004e  1c70              ADDS     r0,r6,#1              ;900
000050  b286              UXTH     r6,r0                 ;900
000052  8860              LDRH     r0,[r4,#2]            ;900
000054  42b0              CMP      r0,r6                 ;900
000056  d8ef              BHI      |L10.56|
                  |L10.88|
;;;903    	}
;;;904    
;;;905    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_STOP, 0, 0, 0);
000058  2300              MOVS     r3,#0
00005a  461a              MOV      r2,r3
00005c  4619              MOV      r1,r3
00005e  2002              MOVS     r0,#2
000060  f7fffffe          BL       protocol_hid_mapping_emul_handler
000064  4817              LDR      r0,|L10.196|
;;;906    
;;;907    #ifdef ADD_CUSTOM
;;;908    	SendCustomData_USB((uint8_t*)pOutBuffer);
000066  4621              MOV      r1,r4
000068  f8d007c2          LDR      r0,[r0,#0x7c2]
00006c  281e              CMP      r0,#0x1e
00006e  d304              BCC      |L10.122|
000070  4815              LDR      r0,|L10.200|
000072  6d81              LDR      r1,[r0,#0x58]  ; g_Full
000074  1c49              ADDS     r1,r1,#1
000076  6581              STR      r1,[r0,#0x58]  ; g_Full
;;;909    #endif
;;;910    	return;
;;;911    }
000078  bd70              POP      {r4-r6,pc}
                  |L10.122|
00007a  4c12              LDR      r4,|L10.196|
00007c  2900              CMP      r1,#0
00007e  bf08              IT       EQ
000080  bd70              POPEQ    {r4-r6,pc}
000082  2001              MOVS     r0,#1
000084  f88407c6          STRB     r0,[r4,#0x7c6]
000088  f89407c0          LDRB     r0,[r4,#0x7c0]
00008c  2242              MOVS     r2,#0x42
00008e  eb001040          ADD      r0,r0,r0,LSL #5
000092  eb040040          ADD      r0,r4,r0,LSL #1
000096  1d00              ADDS     r0,r0,#4
000098  f7fffffe          BL       __aeabi_memcpy
00009c  f8d407c2          LDR      r0,[r4,#0x7c2]
0000a0  2100              MOVS     r1,#0
0000a2  1c40              ADDS     r0,r0,#1
0000a4  f8c407c2          STR      r0,[r4,#0x7c2]
0000a8  f89407c0          LDRB     r0,[r4,#0x7c0]
0000ac  1c40              ADDS     r0,r0,#1
0000ae  b2c0              UXTB     r0,r0
0000b0  f88407c0          STRB     r0,[r4,#0x7c0]
0000b4  281e              CMP      r0,#0x1e
0000b6  bf28              IT       CS
0000b8  f88417c0          STRBCS   r1,[r4,#0x7c0]
0000bc  f88417c6          STRB     r1,[r4,#0x7c6]
0000c0  bd70              POP      {r4-r6,pc}
;;;912    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L10.196|
                          DCD      ||.bss||+0x208
                  |L10.200|
                          DCD      ||.data||

                          AREA ||i.HidReadWrite__Read_I2C||, CODE, READONLY, ALIGN=1

                  HidReadWrite__Read_I2C PROC
;;;913    
;;;914    void HidReadWrite__Read_I2C(PHJ_HID_CONTROL_STRUCT_I2C pHidControl)
000000  b570              PUSH     {r4-r6,lr}
;;;915    {
000002  4604              MOV      r4,r0
;;;916    	uint16_t	index = 0;
;;;917    	uint16_t	test_InputOffset = 0;
;;;918    
;;;919    	pHidControl->Data.PacketID = HID_REPORT_ID__CUSTOM_IN;
000004  200a              MOVS     r0,#0xa
000006  70a0              STRB     r0,[r4,#2]
;;;920    	pHidControl->Data.DeviceID_b.addr = 0x34;
000008  78e0              LDRB     r0,[r4,#3]
00000a  2600              MOVS     r6,#0                 ;916
00000c  f02000fe          BIC      r0,r0,#0xfe
000010  3068              ADDS     r0,r0,#0x68
;;;921    	pHidControl->Data.DeviceID_b.bRead = TRUE;
000012  f0400001          ORR      r0,r0,#1
000016  70e0              STRB     r0,[r4,#3]
000018  4635              MOV      r5,r6                 ;917
;;;922    //	pHidControl->Data.Length = pHidControl->Data.Length;
;;;923    
;;;924    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_START, 0, 0, 0);
00001a  4633              MOV      r3,r6
00001c  4632              MOV      r2,r6
00001e  4631              MOV      r1,r6
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;925    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH, 0, 0, 0);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  4619              MOV      r1,r3
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;926    
;;;927    	for (index = 0; index < pHidControl->Data.Length; index++)
000032  88a0              LDRH     r0,[r4,#4]
000034  2800              CMP      r0,#0
000036  d90f              BLS      |L11.88|
                  |L11.56|
;;;928    	{
;;;929    		pHidControl->Data.Data[test_InputOffset++] = protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER, 0, I2C_SLAVE_FSM_STATUS_READ_END, 0);
000038  2300              MOVS     r3,#0
00003a  f44f6280          MOV      r2,#0x400
00003e  4619              MOV      r1,r3
000040  2003              MOVS     r0,#3
000042  f7fffffe          BL       protocol_hid_mapping_emul_handler
000046  1961              ADDS     r1,r4,r5
000048  7188              STRB     r0,[r1,#6]
00004a  1c68              ADDS     r0,r5,#1
00004c  b285              UXTH     r5,r0
00004e  1c70              ADDS     r0,r6,#1              ;927
000050  b286              UXTH     r6,r0                 ;927
000052  88a0              LDRH     r0,[r4,#4]            ;927
000054  42b0              CMP      r0,r6                 ;927
000056  d8ef              BHI      |L11.56|
                  |L11.88|
;;;930    	}
;;;931    
;;;932    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_STOP, 0, 0, 0);
000058  2300              MOVS     r3,#0
00005a  461a              MOV      r2,r3
00005c  4619              MOV      r1,r3
00005e  2002              MOVS     r0,#2
000060  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;933    
;;;934    	// Send
;;;935    	SendCustomData_I2C(pHidControl);
000064  4620              MOV      r0,r4
000066  e8bd4070          POP      {r4-r6,lr}
00006a  f7ffbffe          B.W      SendCustomData_I2C
;;;936    	return;
;;;937    }
;;;938    
                          ENDP


                          AREA ||i.HidReadWrite__Write||, CODE, READONLY, ALIGN=1

                  HidReadWrite__Write PROC
;;;939    
;;;940    void HidReadWrite__Write(PHJ_HID_CONTROL_STRUCT pHidControl)
000000  b570              PUSH     {r4-r6,lr}
;;;941    {
;;;942    	uint16_t index = 0;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;941
;;;943    
;;;944    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_START, 0, 0, 0);
000006  4623              MOV      r3,r4
000008  4622              MOV      r2,r4
00000a  4621              MOV      r1,r4
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;945    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH, 0, 0, 0);
000012  2300              MOVS     r3,#0
000014  461a              MOV      r2,r3
000016  4619              MOV      r1,r3
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;946    
;;;947    	for (index = 0; index < pHidControl->Length; index++)
00001e  8868              LDRH     r0,[r5,#2]
000020  2800              CMP      r0,#0
000022  d90c              BLS      |L12.62|
                  |L12.36|
;;;948    	{
;;;949    		protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER, index + 1, I2C_SLAVE_FSM_STATUS_WRITE_ACK, pHidControl->Data[index]);
000024  1928              ADDS     r0,r5,r4
000026  1c64              ADDS     r4,r4,#1
000028  7903              LDRB     r3,[r0,#4]
00002a  b2a1              UXTH     r1,r4
00002c  f44f5280          MOV      r2,#0x1000
000030  2003              MOVS     r0,#3
000032  f7fffffe          BL       protocol_hid_mapping_emul_handler
000036  8868              LDRH     r0,[r5,#2]            ;947
000038  b2a4              UXTH     r4,r4                 ;947
00003a  42a0              CMP      r0,r4                 ;947
00003c  d8f2              BHI      |L12.36|
                  |L12.62|
;;;950    	}
;;;951    
;;;952    	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_STOP, 0, 0, 0);
00003e  2300              MOVS     r3,#0
000040  e8bd4070          POP      {r4-r6,lr}
000044  461a              MOV      r2,r3
000046  4619              MOV      r1,r3
000048  2002              MOVS     r0,#2
00004a  f7ffbffe          B.W      protocol_hid_mapping_emul_handler
;;;953    	return;
;;;954    }
;;;955    
                          ENDP


                          AREA ||i.QueueCommonData_USB||, CODE, READONLY, ALIGN=2

                  QueueCommonData_USB PROC
;;;1564   #endif
;;;1565   void QueueCommonData_USB(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1566   {
000004  4c3c              LDR      r4,|L13.248|
000006  7820              LDRB     r0,[r4,#0]  ; g_Configuration
;;;1567   #ifndef MODE_I2C
;;;1568   	uint8_t* pCheckID = NULL;
;;;1569   
;;;1570   	if ((CheckUsbConfig() == 0) || (CheckHIDReady() == 0) || (g_CXF_Done != CXF_STATUS__COMPLETE_DONE))
000008  2800              CMP      r0,#0
00000a  bf1a              ITTE     NE
00000c  7860              LDRBNE   r0,[r4,#1]  ; g_HIDReady
00000e  2800              CMPNE    r0,#0
;;;1571   	{
;;;1572   		goto QUEUECOMMONDATA_USB__GOTO_END;
;;;1573   	}
;;;1574   	
;;;1575   	if (g_RemoteWakeup == 1)
;;;1576   	{
;;;1577   		goto QUEUECOMMONDATA_USB__GOTO_END;
;;;1578   	}
;;;1579   	
;;;1580   #if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
;;;1581   	if(bReportDelayFlag == 0)
;;;1582   #endif
;;;1583   	{
;;;1584   		if (StaticQueue_CheckEmpty(&g_Queue_Common) == 0)
;;;1585   		{
;;;1586   			pCheckID = StaticQueue_Get(&g_Queue_Common);
;;;1587   			switch (pCheckID[0])
;;;1588   			{
;;;1589   				case HID_REPORT_ID__MULTI_TOUCH:
;;;1590   	#if USED_S3_WAKEUP_MOUSE_DEVICE
;;;1591   				case HID_REPORT_ID__MOUSE:
;;;1592   	#endif /* USED_S3_WAKEUP_MOUSE_DEVICE */
;;;1593   				{
;;;1594   	#ifdef ADD_TOUCH
;;;1595   					if ((g_CheckVDMAComplete_Touch == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;1596   					{
;;;1597   						// Pop
;;;1598   						if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Touch) == TRUE)
;;;1599   	                    {
;;;1600   	                        g_CheckVDMAComplete_Touch = DMA_NOT_READY;
;;;1601   	                        mUsbIntF1INEn(); // Touch IN
;;;1602   	                    }
;;;1603   					}
;;;1604   	#endif
;;;1605   					break;
;;;1606   				}
;;;1607   
;;;1608   				case HID_REPORT_ID__PEN:
;;;1609   				case HID_REPORT_ID__PEN_SECOND:
;;;1610   				{
;;;1611   	#ifdef ADD_PEN
;;;1612   					if ((g_CheckVDMAComplete_Pen == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;1613   					{
;;;1614   						// Pop
;;;1615   						if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Pen) == TRUE)
;;;1616   	                    {
;;;1617   	                        g_CheckVDMAComplete_Pen = DMA_NOT_READY;
;;;1618   	                        mUsbIntF3INEn(); // Pen IN
;;;1619   	                    }
;;;1620   					}
;;;1621   	#endif
;;;1622   
;;;1623   					break;
;;;1624   				}
;;;1625   
;;;1626   				// Custom or Bulk
;;;1627   				case HID_REPORT_ID__CUSTOM_IN:
;;;1628   				default:
;;;1629   				{
;;;1630   	#ifdef ADD_CUSTOM
;;;1631   					if ((g_CheckVDMAComplete_Custom == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;1632   					{
;;;1633   						// Pop
;;;1634   						if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_CustomBuffer) == TRUE)
;;;1635   	                    {
;;;1636   	                        g_CheckVDMAComplete_Custom = DMA_NOT_READY;
;;;1637   	                        mUsbIntF0INEn(); // Custom IN
;;;1638   	                    }
;;;1639   					}
;;;1640   	#endif
;;;1641   
;;;1642   					break;
;;;1643   				}
;;;1644   			}
;;;1645   		}
;;;1646   	}
;;;1647   QUEUECOMMONDATA_USB__GOTO_END:
;;;1648   
;;;1649   #endif
;;;1650   	return;
;;;1651   }
000010  e8bd81f0          POPEQ    {r4-r8,pc}
000014  78a0              LDRB     r0,[r4,#2]            ;1570  ; g_CXF_Done
000016  2803              CMP      r0,#3                 ;1570
000018  bf18              IT       NE
00001a  e8bd81f0          POPNE    {r4-r8,pc}
00001e  78e0              LDRB     r0,[r4,#3]            ;1575  ; g_RemoteWakeup
000020  2801              CMP      r0,#1                 ;1575
000022  bf08              IT       EQ
000024  e8bd81f0          POPEQ    {r4-r8,pc}
000028  4834              LDR      r0,|L13.252|
00002a  f8d007c2          LDR      r0,[r0,#0x7c2]        ;1584
00002e  2800              CMP      r0,#0                 ;1584
000030  bf08              IT       EQ
000032  e8bd81f0          POPEQ    {r4-r8,pc}
000036  4831              LDR      r0,|L13.252|
000038  f89017c1          LDRB     r1,[r0,#0x7c1]        ;1586
00003c  eb011141          ADD      r1,r1,r1,LSL #5       ;1586
000040  eb000241          ADD      r2,r0,r1,LSL #1       ;1586
000044  7913              LDRB     r3,[r2,#4]            ;1587
000046  2b0b              CMP      r3,#0xb               ;1587
000048  bf14              ITE      NE                    ;1587
00004a  2b0c              CMPNE    r3,#0xc               ;1587
00004c  e8bd81f0          POPEQ    {r4-r8,pc}
000050  4d2b              LDR      r5,|L13.256|
000052  482a              LDR      r0,|L13.252|
000054  f04f0700          MOV      r7,#0                 ;1584
000058  2b10              CMP      r3,#0x10              ;1587
00005a  f89017c6          LDRB     r1,[r0,#0x7c6]        ;1587
00005e  f8d007c2          LDR      r0,[r0,#0x7c2]        ;1587
000062  f1a00801          SUB      r8,r0,#1              ;1587
000066  d025              BEQ      |L13.180|
000068  7a60              LDRB     r0,[r4,#9]            ;1631  ; g_CheckVDMAComplete_Custom
00006a  2801              CMP      r0,#1                 ;1631
00006c  bf18              IT       NE
00006e  e8bd81f0          POPNE    {r4-r8,pc}
000072  4e22              LDR      r6,|L13.252|
000074  2901              CMP      r1,#1                 ;1634
000076  f6062094          ADD      r0,r6,#0xa94          ;1634
00007a  bf08              IT       EQ
00007c  e8bd81f0          POPEQ    {r4-r8,pc}
000080  1d11              ADDS     r1,r2,#4
000082  2242              MOVS     r2,#0x42
000084  f7fffffe          BL       __aeabi_memcpy
000088  f8c687c2          STR      r8,[r6,#0x7c2]
00008c  f89607c1          LDRB     r0,[r6,#0x7c1]
000090  1c40              ADDS     r0,r0,#1
000092  b2c0              UXTB     r0,r0
000094  f88607c1          STRB     r0,[r6,#0x7c1]
000098  281e              CMP      r0,#0x1e
00009a  bf28              IT       CS
00009c  f88677c1          STRBCS   r7,[r6,#0x7c1]
0000a0  7267              STRB     r7,[r4,#9]            ;1636
0000a2  f8d50138          LDR      r0,[r5,#0x138]        ;1637
0000a6  f4203080          BIC      r0,r0,#0x10000        ;1637
0000aa  bf00              NOP                            ;1601
                  |L13.172|
0000ac  f8c50138          STR      r0,[r5,#0x138]        ;1601
0000b0  e8bd81f0          POP      {r4-r8,pc}
                  |L13.180|
0000b4  79a0              LDRB     r0,[r4,#6]            ;1595  ; g_CheckVDMAComplete_Touch
0000b6  2801              CMP      r0,#1                 ;1595
0000b8  bf18              IT       NE
0000ba  e8bd81f0          POPNE    {r4-r8,pc}
0000be  4e0f              LDR      r6,|L13.252|
0000c0  2901              CMP      r1,#1                 ;1598
0000c2  f1a600ee          SUB      r0,r6,#0xee           ;1598
0000c6  bf08              IT       EQ
0000c8  e8bd81f0          POPEQ    {r4-r8,pc}
0000cc  1d11              ADDS     r1,r2,#4
0000ce  2242              MOVS     r2,#0x42
0000d0  f7fffffe          BL       __aeabi_memcpy
0000d4  f8c687c2          STR      r8,[r6,#0x7c2]
0000d8  f89607c1          LDRB     r0,[r6,#0x7c1]
0000dc  1c40              ADDS     r0,r0,#1
0000de  b2c0              UXTB     r0,r0
0000e0  f88607c1          STRB     r0,[r6,#0x7c1]
0000e4  281e              CMP      r0,#0x1e
0000e6  bf28              IT       CS
0000e8  f88677c1          STRBCS   r7,[r6,#0x7c1]
0000ec  71a7              STRB     r7,[r4,#6]            ;1600
0000ee  f8d50138          LDR      r0,[r5,#0x138]        ;1601
0000f2  f4203000          BIC      r0,r0,#0x20000        ;1601
0000f6  e7d9              B        |L13.172|
;;;1652   
                          ENDP

                  |L13.248|
                          DCD      ||.data||
                  |L13.252|
                          DCD      ||.bss||+0x208
                  |L13.256|
                          DCD      0x20100000

                          AREA ||i.RecieveBulkCustomData||, CODE, READONLY, ALIGN=2

                  RecieveBulkCustomData PROC
;;;1534   // Host to Device
;;;1535   void RecieveBulkCustomData(uint8_t* pData)
000000  480d              LDR      r0,|L14.56|
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4213100          BIC      r1,r1,#0x20000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210102          BIC      r1,r1,#2
000016  f8c0132c          STR      r1,[r0,#0x32c]
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01308          STR      r1,[r0,#0x308]
000022  4906              LDR      r1,|L14.60|
000024  f8c0130c          STR      r1,[r0,#0x30c]
000028  f8d01308          LDR      r1,[r0,#0x308]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01308          STR      r1,[r0,#0x308]
;;;1536   {
;;;1537   #ifndef MODE_I2C
;;;1538   	// Something !!!
;;;1539   
;;;1540   	DMABulkData_USB();
;;;1541   
;;;1542   	// Something !!!
;;;1543   #endif
;;;1544   	return;
;;;1545   }
000034  4770              BX       lr
;;;1546   
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x20100000
                  |L14.60|
                          DCD      ||.bss||+0xcdc

                          AREA ||i.RecieveBulkCustomData_DMA||, CODE, READONLY, ALIGN=1

                  RecieveBulkCustomData_DMA PROC
;;;1494   // Host to Device
;;;1495   void RecieveBulkCustomData_DMA(void)
000000  4770              BX       lr
;;;1496   {
;;;1497   #ifndef MODE_I2C
;;;1498   #ifdef ADD_BULK_CUSTOM
;;;1499   	// Bulk Custom OUT
;;;1500   	mUsbEXDmaFinishClr(BULK_CUSTOM_FIFO_OUT);
;;;1501   	mUsbEXIntDmaErrDis(BULK_CUSTOM_FIFO_OUT);
;;;1502   	mUsbEXIntDmaFinishDis(BULK_CUSTOM_FIFO_OUT);
;;;1503   
;;;1504   	// Virtual DMA Mask - Bulk Custom OUT
;;;1505   	mUsbEXIntDmaErrEn(BULK_CUSTOM_FIFO_OUT);
;;;1506   	mUsbEXIntDmaFinishEn(BULK_CUSTOM_FIFO_OUT);
;;;1507   
;;;1508   	// Virtual DMA Start !!!!
;;;1509   	mUsbEXDmaConfig(BULK_CUSTOM_FIFO_OUT, MX_PA_SZ_64, DIRECTION_OUT);
;;;1510   	mUsbEXDmaAddr(BULK_CUSTOM_FIFO_OUT, (uint32_t)g_BulkCustomBuffer);
;;;1511   	mUsbEXDmaStart(BULK_CUSTOM_FIFO_OUT);
;;;1512   #endif
;;;1513   #endif
;;;1514   	return;
;;;1515   }
;;;1516   
                          ENDP


                          AREA ||i.RecieveCustomData||, CODE, READONLY, ALIGN=1

                  RecieveCustomData PROC
;;;956    // Host to Device
;;;957    void RecieveCustomData(uint8_t* pData)
000000  b570              PUSH     {r4-r6,lr}
;;;958    {
;;;959    	switch (pData[0])
000002  7801              LDRB     r1,[r0,#0]
000004  2909              CMP      r1,#9
;;;960    	{
;;;961    		case HID_REPORT_ID__CUSTOM_OUT:
;;;962    		{
;;;963    			PHJ_HID_CONTROL_STRUCT  pHidControl = (PHJ_HID_CONTROL_STRUCT)pData;
;;;964    			if (pHidControl->DeviceID_b.bRead)
;;;965    			{
;;;966    				HidReadWrite__Read(pHidControl);
;;;967    			}
;;;968    			else
;;;969    			{
;;;970    				HidReadWrite__Write((PHJ_HID_CONTROL_STRUCT)pData);
;;;971    			}
;;;972    
;;;973    			break;
;;;974    		}
;;;975    	}
;;;976    
;;;977    	return;
;;;978    }
000006  bf18              IT       NE
000008  bd70              POPNE    {r4-r6,pc}
00000a  7841              LDRB     r1,[r0,#1]            ;964
00000c  f0110f01          TST      r1,#1                 ;964
000010  d003              BEQ      |L16.26|
000012  e8bd4070          POP      {r4-r6,lr}            ;966
000016  f7ffbffe          B.W      HidReadWrite__Read
                  |L16.26|
00001a  2500              MOVS     r5,#0                 ;966
00001c  4604              MOV      r4,r0                 ;970
00001e  462b              MOV      r3,r5                 ;970
000020  462a              MOV      r2,r5                 ;970
000022  4629              MOV      r1,r5                 ;970
000024  2001              MOVS     r0,#1                 ;970
000026  f7fffffe          BL       protocol_hid_mapping_emul_handler
00002a  2300              MOVS     r3,#0                 ;970
00002c  461a              MOV      r2,r3                 ;970
00002e  4619              MOV      r1,r3                 ;970
000030  2004              MOVS     r0,#4                 ;970
000032  f7fffffe          BL       protocol_hid_mapping_emul_handler
000036  8860              LDRH     r0,[r4,#2]            ;970
000038  2800              CMP      r0,#0                 ;970
00003a  d90c              BLS      |L16.86|
                  |L16.60|
00003c  1960              ADDS     r0,r4,r5              ;970
00003e  1c6d              ADDS     r5,r5,#1              ;970
000040  7903              LDRB     r3,[r0,#4]            ;970
000042  b2a9              UXTH     r1,r5                 ;970
000044  f44f5280          MOV      r2,#0x1000            ;970
000048  2003              MOVS     r0,#3                 ;970
00004a  f7fffffe          BL       protocol_hid_mapping_emul_handler
00004e  8860              LDRH     r0,[r4,#2]            ;970
000050  b2ad              UXTH     r5,r5                 ;970
000052  42a8              CMP      r0,r5                 ;970
000054  d8f2              BHI      |L16.60|
                  |L16.86|
000056  2300              MOVS     r3,#0                 ;970
000058  e8bd4070          POP      {r4-r6,lr}            ;970
00005c  461a              MOV      r2,r3                 ;970
00005e  4619              MOV      r1,r3                 ;970
000060  2002              MOVS     r0,#2                 ;970
000062  f7ffbffe          B.W      protocol_hid_mapping_emul_handler
;;;979    
                          ENDP


                          AREA ||i.RecieveCustomData_DMA||, CODE, READONLY, ALIGN=2

                  RecieveCustomData_DMA PROC
;;;805    
;;;806    void RecieveCustomData_DMA(void)
000000  4814              LDR      r0,|L17.84|
;;;807    {
;;;808    #ifndef MODE_I2C
;;;809    #ifdef ADD_CUSTOM
;;;810    	// Custom OUT
;;;811    	mUsbEXDmaFinishClr(CUSTOM_FIFO_OUT);
000002  2108              MOVS     r1,#8
000004  f8c01328          STR      r1,[r0,#0x328]
;;;812    	mUsbEXIntDmaErrDis(CUSTOM_FIFO_OUT);
000008  f8d0132c          LDR      r1,[r0,#0x32c]
00000c  f4412100          ORR      r1,r1,#0x80000
000010  f8c0132c          STR      r1,[r0,#0x32c]
;;;813    	mUsbEXIntDmaFinishDis(CUSTOM_FIFO_OUT);
000014  f8d0132c          LDR      r1,[r0,#0x32c]
000018  f0410108          ORR      r1,r1,#8
00001c  f8c0132c          STR      r1,[r0,#0x32c]
;;;814    
;;;815    	// Virtual DMA Mask - Custom OUT
;;;816    	mUsbEXIntDmaErrEn(CUSTOM_FIFO_OUT);
000020  f8d0132c          LDR      r1,[r0,#0x32c]
000024  f4212100          BIC      r1,r1,#0x80000
000028  f8c0132c          STR      r1,[r0,#0x32c]
;;;817    	mUsbEXIntDmaFinishEn(CUSTOM_FIFO_OUT);
00002c  f8d0132c          LDR      r1,[r0,#0x32c]
000030  f0210108          BIC      r1,r1,#8
000034  f8c0132c          STR      r1,[r0,#0x32c]
;;;818    
;;;819    	// Virtual DMA Start !!!!
;;;820    	mUsbEXDmaConfig(CUSTOM_FIFO_OUT, MX_PA_SZ_64, DIRECTION_OUT);
000038  f44f4180          MOV      r1,#0x4000
00003c  f8c01318          STR      r1,[r0,#0x318]
;;;821    	mUsbEXDmaAddr(CUSTOM_FIFO_OUT, (uint32_t)g_CustomBuffer);
000040  4905              LDR      r1,|L17.88|
000042  f8c0131c          STR      r1,[r0,#0x31c]
;;;822    	mUsbEXDmaStart(CUSTOM_FIFO_OUT);
000046  f8d01318          LDR      r1,[r0,#0x318]
00004a  f0410101          ORR      r1,r1,#1
00004e  f8c01318          STR      r1,[r0,#0x318]
;;;823    #endif
;;;824    #endif
;;;825    	return;
;;;826    }
000052  4770              BX       lr
;;;827    
                          ENDP

                  |L17.84|
                          DCD      0x20100000
                  |L17.88|
                          DCD      ||.bss||+0xc9c

                          AREA ||i.ResumeSigal||, CODE, READONLY, ALIGN=1

                  ResumeSigal PROC
;;;266    
;;;267    void ResumeSigal(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;268    {
;;;269    	mUsbRemoteWakeUpSet_1();
000004  f8101fa4          LDRB     r1,[r0,#0xa4]!
000008  f0410102          ORR      r1,r1,#2
00000c  7001              STRB     r1,[r0,#0]
;;;270    }
00000e  4770              BX       lr
;;;271    
                          ENDP


                          AREA ||i.SendCustomData_USB||, CODE, READONLY, ALIGN=2

                  SendCustomData_USB PROC
;;;773    
;;;774    void SendCustomData_USB(uint8_t* pUserData)
000000  4917              LDR      r1,|L19.96|
;;;775    {
000002  b510              PUSH     {r4,lr}
000004  f8d117c2          LDR      r1,[r1,#0x7c2]
000008  291e              CMP      r1,#0x1e
00000a  d304              BCC      |L19.22|
00000c  4815              LDR      r0,|L19.100|
00000e  6d81              LDR      r1,[r0,#0x58]  ; g_Full
000010  1c49              ADDS     r1,r1,#1
000012  6581              STR      r1,[r0,#0x58]  ; g_Full
;;;776    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
;;;777    	{
;;;778    		// 큐의 최대치를 넘어가면..  (데이터 손실)
;;;779    		goto SENDCUSTOMDATA_USB__GOTO_END;
;;;780    	}
;;;781    
;;;782    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
;;;783    
;;;784    SENDCUSTOMDATA_USB__GOTO_END:
;;;785    
;;;786    	return;
;;;787    }
000014  bd10              POP      {r4,pc}
                  |L19.22|
000016  4c12              LDR      r4,|L19.96|
000018  0001              MOVS     r1,r0                 ;782
00001a  bf08              IT       EQ
00001c  bd10              POPEQ    {r4,pc}
00001e  2001              MOVS     r0,#1
000020  f88407c6          STRB     r0,[r4,#0x7c6]
000024  f89407c0          LDRB     r0,[r4,#0x7c0]
000028  2242              MOVS     r2,#0x42
00002a  eb001040          ADD      r0,r0,r0,LSL #5
00002e  eb040040          ADD      r0,r4,r0,LSL #1
000032  1d00              ADDS     r0,r0,#4
000034  f7fffffe          BL       __aeabi_memcpy
000038  f8d407c2          LDR      r0,[r4,#0x7c2]
00003c  2100              MOVS     r1,#0
00003e  1c40              ADDS     r0,r0,#1
000040  f8c407c2          STR      r0,[r4,#0x7c2]
000044  f89407c0          LDRB     r0,[r4,#0x7c0]
000048  1c40              ADDS     r0,r0,#1
00004a  b2c0              UXTB     r0,r0
00004c  f88407c0          STRB     r0,[r4,#0x7c0]
000050  281e              CMP      r0,#0x1e
000052  bf28              IT       CS
000054  f88417c0          STRBCS   r1,[r4,#0x7c0]
000058  f88417c6          STRB     r1,[r4,#0x7c6]
00005c  bd10              POP      {r4,pc}
;;;788    
                          ENDP

00005e  0000              DCW      0x0000
                  |L19.96|
                          DCD      ||.bss||+0x208
                  |L19.100|
                          DCD      ||.data||

                          AREA ||i.SendTouchData||, CODE, READONLY, ALIGN=2

                  SendTouchData PROC
;;;571    
;;;572    void SendTouchData(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;573    {
000004  b091              SUB      sp,sp,#0x44
;;;574    	uint8_t				i = 0;
;;;575    	uint8_t				ContactCount = 0;
000006  2500              MOVS     r5,#0
;;;576    	uint8_t				TouchDownCount = 0;
000008  462f              MOV      r7,r5
;;;577    	HID_MULTITOUCH_I2C	TouchData_I2C = { 0, };
00000a  2144              MOVS     r1,#0x44
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;578    	PHID_MULTITOUCH		TouchData = &TouchData_I2C.Data;
000012  f10d0602          ADD      r6,sp,#2
;;;579    
;;;580    	if (module_Skip_Event())
000016  f7fffffe          BL       module_Skip_Event
00001a  2800              CMP      r0,#0
;;;581    	{
;;;582    		goto SENDTOUCHDATA__GOTO_END;
;;;583    	}
;;;584    
;;;585    	TouchData->ReportID = HID_REPORT_ID__MULTI_TOUCH;
;;;586    
;;;587    	for (i = 0; i < HID_MAX_TOUCH; i++)
;;;588    	{
;;;589    		if (HID_id[i] != 0)
;;;590    		{
;;;591    #if (ID_MAPPING_CHANGE)
;;;592    			ContactCount += 1;
;;;593    #else
;;;594    			// Up 처리를 정확히 하기 위한 작업
;;;595    			if (g_TouchTip[HID_id[i]] != HID_status[i]) // It may be deleted on Current F/W... 200730, HanCH
;;;596    			{
;;;597    				g_TouchTip[HID_id[i]] = HID_status[i];
;;;598    				ContactCount += 1;
;;;599    			}
;;;600    			else
;;;601    			{
;;;602    				if (HID_status[i] == FINGER_STATUS__TIP_SWITCH)
;;;603    				{
;;;604    					ContactCount += 1;
;;;605    				}
;;;606    			}
;;;607    #endif
;;;608    			// ScanTime 을 위해서 Touch Down 의 개수를 확인한다.
;;;609    			if (HID_status[i] == FINGER_STATUS__TIP_SWITCH)
;;;610    			{
;;;611    				TouchDownCount += 1;
;;;612    			}
;;;613    		}
;;;614    
;;;615    		TouchData->Touch[i].Status = HID_status[i];
;;;616    		TouchData->Touch[i].ID = HID_id[i];
;;;617    		TouchData->Touch[i].x = HID_x[i];
;;;618    		TouchData->Touch[i].y = HID_y[i];
;;;619    	}
;;;620    
;;;621    
;;;622    	for (i = 0; i < HID_MAX_TOUCH; i++)
;;;623    	{
;;;624    		HID_status[i] = 0;
;;;625    		HID_id[i] = 0;
;;;626    		HID_x[i] = 0;
;;;627    		HID_y[i] = 0;
;;;628    	}
;;;629    
;;;630    
;;;631    
;;;632    
;;;633    	
;;;634    //	if (ContactCount == 0)
;;;635    //	{
;;;636    //		goto SENDTOUCHDATA__GOTO_END;
;;;637    //	}
;;;638    	
;;;639    	if (ContactCount)
;;;640    	{
;;;641    		TouchData->ContactCount = ContactCount;
;;;642    		TouchData->ScanTime = GetScanTime(&g_StartTime, &g_ScanTime);
;;;643    
;;;644    		// ScanTime Init
;;;645    		if (TouchDownCount == 0)
;;;646    		{
;;;647    			g_ScanTime = 0;
;;;648    			g_StartTime = 0;
;;;649    		}
;;;650    	}
;;;651    
;;;652    	
;;;653    
;;;654    #ifndef MODE_I2C
;;;655    #ifdef USB_SELECTIVE_SUSPEND
;;;656    //	if (g_RemoteWakeup == 0)
;;;657    //	{
;;;658    //		g_ScanTime_Recovery = 0;
;;;659    //		g_StartTime_Recovery = 0;
;;;660    //	}
;;;661    
;;;662    			
;;;663    	//for (i = 0; i < HID_MAX_TOUCH; i++)
;;;664    	{
;;;665    		//if (TouchData->Touch[i].Status != 0)
;;;666    		{
;;;667    			if (g_RemoteWakeup == 1)// || g_Status[0].Status.Global.RemoteWakeup == 1)
;;;668    			{
;;;669    				if (ContactCount)
;;;670    				{
;;;671    					ResumeSigal();
;;;672    					SendTouchData_USB(TouchData);
;;;673    					if(g_StartTime_Recovery == 0)
;;;674    					{
;;;675    						GetScanTime(&g_StartTime_Recovery, &g_ScanTime_Recovery);
;;;676    					}
;;;677    				}
;;;678    				
;;;679    				if(g_StartTime_Recovery > 0)
;;;680    				{
;;;681    					if (GetScanTime(&g_StartTime_Recovery, &g_ScanTime_Recovery) >= 20000)
;;;682    					{
;;;683    						g_RemoteWakeup = 0;
;;;684    						g_Status[0].Status.Global.RemoteWakeup = 0;
;;;685    						g_ScanTime_Recovery = 0;
;;;686    						g_StartTime_Recovery = 0;
;;;687    						ResumeCnt = 0;
;;;688    						
;;;689    						// H/W Reset !!
;;;690    						module_Protocol_Init();
;;;691    						while(1);
;;;692    					}
;;;693    				}
;;;694    			}
;;;695    #if (CUSTOMER == NEC)
;;;696    			else if(g_Status[0].Status.Global.RemoteWakeup == 1 && Recovery_ClearSus_Flag == 1)
;;;697    			{
;;;698    				if(ResumeCnt==5)
;;;699    				{
;;;700    					while(1);
;;;701    				}
;;;702    				else if(GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus )> 200 && ResumeCnt < 5) 
;;;703    				{
;;;704    					mUsbGoSuspend();						
;;;705    					g_RemoteWakeup = 1;	
;;;706    					ResumeSigal();
;;;707    					ResumeCnt++;
;;;708    					g_StartTime_Recovery_ClearSus = g_ScanTime_Recovery_ClearSus =0;
;;;709    					Recovery_ClearSus_Flag = 0;
;;;710    				}
;;;711    			}
;;;712    #endif				
;;;713    		}
;;;714    	}
;;;715    #endif
;;;716    #endif
;;;717    
;;;718    	
;;;719    
;;;720    	// USB
;;;721    	if (ContactCount 
;;;722    #ifndef MODE_I2C
;;;723    		&& g_RemoteWakeup==0
;;;724    #endif
;;;725    	)
;;;726    	{
;;;727    		if ((CheckUsbConfig() != 0) && (CheckHIDReady() != 0))
;;;728    		{
;;;729    			SendTouchData_USB(TouchData);
;;;730    		}
;;;731    #ifdef MODE_I2C
;;;732    		// I2C
;;;733    		else if (CheckI2CReady() != 0 && (custom_tool == 0))
;;;734    		{
;;;735    			TouchData_I2C.I2C_Length = sizeof(HID_MULTITOUCH_I2C);
;;;736    			SendTouchData_I2C(&TouchData_I2C);
;;;737    		}
;;;738    #endif
;;;739    	}
;;;740    
;;;741    SENDTOUCHDATA__GOTO_END:
;;;742    
;;;743    	return;
;;;744    }
00001c  bf1c              ITT      NE
00001e  b011              ADDNE    sp,sp,#0x44
000020  e8bd8ff0          POPNE    {r4-r11,pc}
000024  2010              MOVS     r0,#0x10              ;585
000026  f88d0002          STRB     r0,[sp,#2]            ;585
00002a  4879              LDR      r0,|L20.528|
00002c  2200              MOVS     r2,#0                 ;587
00002e  f1000178          ADD      r1,r0,#0x78           ;587
000032  f1000c28          ADD      r12,r0,#0x28          ;587
000036  f1000350          ADD      r3,r0,#0x50           ;587
00003a  f04f080a          MOV      r8,#0xa               ;587
00003e  f1a0090c          SUB      r9,r0,#0xc            ;595
000042  bf00              NOP                            ;589
                  |L20.68|
000044  f8d0a000          LDR      r10,[r0,#0]           ;589
000048  f1ba0f00          CMP      r10,#0                ;589
00004c  d013              BEQ      |L20.118|
00004e  f819b00a          LDRB     r11,[r9,r10]          ;595
000052  680c              LDR      r4,[r1,#0]            ;595
000054  45a3              CMP      r11,r4                ;595
000056  d007              BEQ      |L20.104|
000058  f809400a          STRB     r4,[r9,r10]           ;597
00005c  1c6c              ADDS     r4,r5,#1              ;598
00005e  b2e5              UXTB     r5,r4                 ;598
000060  680c              LDR      r4,[r1,#0]            ;609
000062  2c01              CMP      r4,#1                 ;609
000064  d005              BEQ      |L20.114|
000066  e006              B        |L20.118|
                  |L20.104|
000068  2c01              CMP      r4,#1                 ;602
00006a  bf04              ITT      EQ                    ;604
00006c  1c6c              ADDEQ    r4,r5,#1              ;604
00006e  b2e5              UXTBEQ   r5,r4                 ;604
000070  d101              BNE      |L20.118|
                  |L20.114|
000072  1c7c              ADDS     r4,r7,#1              ;611
000074  b2e7              UXTB     r7,r4                 ;611
                  |L20.118|
000076  eb020442          ADD      r4,r2,r2,LSL #1       ;615
00007a  eb060444          ADD      r4,r6,r4,LSL #1       ;615
00007e  f811ab04          LDRB     r10,[r1],#4           ;615
000082  f884a001          STRB     r10,[r4,#1]           ;615
000086  f810ab04          LDRB     r10,[r0],#4           ;616
00008a  f884a002          STRB     r10,[r4,#2]           ;616
00008e  f83cab04          LDRH     r10,[r12],#4          ;617
000092  f8a4a003          STRH     r10,[r4,#3]           ;617
000096  f833ab04          LDRH     r10,[r3],#4           ;618
00009a  1c52              ADDS     r2,r2,#1              ;618
00009c  f8a4a005          STRH     r10,[r4,#5]           ;618
0000a0  f1b80801          SUBS     r8,r8,#1              ;618
0000a4  d1ce              BNE      |L20.68|
0000a6  485b              LDR      r0,|L20.532|
0000a8  2400              MOVS     r4,#0                 ;622
0000aa  f8df816c          LDR      r8,|L20.536|
0000ae  f8c041e0          STR      r4,[r0,#0x1e0]        ;622  ; HID_status
0000b2  f8c041e4          STR      r4,[r0,#0x1e4]        ;622  ; HID_status
0000b6  f8c041e8          STR      r4,[r0,#0x1e8]        ;622  ; HID_status
0000ba  f8c041ec          STR      r4,[r0,#0x1ec]        ;622  ; HID_status
0000be  f8c041f0          STR      r4,[r0,#0x1f0]        ;622  ; HID_status
0000c2  f8c041f4          STR      r4,[r0,#0x1f4]        ;622  ; HID_status
0000c6  f8c041f8          STR      r4,[r0,#0x1f8]        ;622  ; HID_status
0000ca  f8c041fc          STR      r4,[r0,#0x1fc]        ;622  ; HID_status
0000ce  f8c04200          STR      r4,[r0,#0x200]        ;622  ; HID_status
0000d2  f8c04204          STR      r4,[r0,#0x204]        ;622  ; HID_status
0000d6  f8c04168          STR      r4,[r0,#0x168]        ;622  ; HID_id
0000da  f8c0416c          STR      r4,[r0,#0x16c]        ;622  ; HID_id
0000de  f8c04170          STR      r4,[r0,#0x170]        ;622  ; HID_id
0000e2  f8c04174          STR      r4,[r0,#0x174]        ;622  ; HID_id
0000e6  f8c04178          STR      r4,[r0,#0x178]        ;622  ; HID_id
0000ea  f8c0417c          STR      r4,[r0,#0x17c]        ;622  ; HID_id
0000ee  f8c04180          STR      r4,[r0,#0x180]        ;622  ; HID_id
0000f2  f8c04184          STR      r4,[r0,#0x184]        ;622  ; HID_id
0000f6  f8c04188          STR      r4,[r0,#0x188]        ;622  ; HID_id
0000fa  f8c0418c          STR      r4,[r0,#0x18c]        ;622  ; HID_id
0000fe  f8c04190          STR      r4,[r0,#0x190]        ;622  ; HID_x
000102  f8c04194          STR      r4,[r0,#0x194]        ;622  ; HID_x
000106  f8c04198          STR      r4,[r0,#0x198]        ;622  ; HID_x
00010a  f8c0419c          STR      r4,[r0,#0x19c]        ;622  ; HID_x
00010e  f8c041a0          STR      r4,[r0,#0x1a0]        ;622  ; HID_x
000112  f8c041a4          STR      r4,[r0,#0x1a4]        ;622  ; HID_x
000116  f8c041a8          STR      r4,[r0,#0x1a8]        ;622  ; HID_x
00011a  f8c041ac          STR      r4,[r0,#0x1ac]        ;622  ; HID_x
00011e  f8c041b0          STR      r4,[r0,#0x1b0]        ;622  ; HID_x
000122  f8c041b4          STR      r4,[r0,#0x1b4]        ;622  ; HID_x
000126  f8c041b8          STR      r4,[r0,#0x1b8]        ;622  ; HID_y
00012a  f8c041bc          STR      r4,[r0,#0x1bc]        ;622  ; HID_y
00012e  f8c041c0          STR      r4,[r0,#0x1c0]        ;622  ; HID_y
000132  f8c041c4          STR      r4,[r0,#0x1c4]        ;622  ; HID_y
000136  f8c041c8          STR      r4,[r0,#0x1c8]        ;622  ; HID_y
00013a  f8c041cc          STR      r4,[r0,#0x1cc]        ;622  ; HID_y
00013e  f8c041d0          STR      r4,[r0,#0x1d0]        ;622  ; HID_y
000142  f8c041d4          STR      r4,[r0,#0x1d4]        ;622  ; HID_y
000146  f8c041d8          STR      r4,[r0,#0x1d8]        ;622  ; HID_y
00014a  f8c041dc          STR      r4,[r0,#0x1dc]        ;639  ; HID_y
00014e  b175              CBZ      r5,|L20.366|
000150  f1080140          ADD      r1,r8,#0x40           ;642
000154  f886503d          STRB     r5,[r6,#0x3d]         ;641
000158  f1010038          ADD      r0,r1,#0x38           ;642
00015c  f7fffffe          BL       GetScanTime
000160  87f0              STRH     r0,[r6,#0x3e]         ;642
000162  b927              CBNZ     r7,|L20.366|
000164  2100              MOVS     r1,#0                 ;647
000166  f8c84040          STR      r4,[r8,#0x40]         ;647  ; g_ScanTime
00016a  e9c8111e          STRD     r1,r1,[r8,#0x78]      ;647
                  |L20.366|
00016e  f8980003          LDRB     r0,[r8,#3]            ;667  ; g_RemoteWakeup
000172  2801              CMP      r0,#1                 ;667
000174  d130              BNE      |L20.472|
000176  b18d              CBZ      r5,|L20.412|
000178  0780              LSLS     r0,r0,#30             ;669
00017a  f8101fa4          LDRB     r1,[r0,#0xa4]!        ;669
00017e  f0410102          ORR      r1,r1,#2              ;669
000182  7001              STRB     r1,[r0,#0]            ;669
000184  4630              MOV      r0,r6                 ;672
000186  f7fffffe          BL       SendTouchData_USB
00018a  e9d80120          LDRD     r0,r1,[r8,#0x80]      ;672
00018e  4308              ORRS     r0,r0,r1              ;673
000190  d104              BNE      |L20.412|
000192  4922              LDR      r1,|L20.540|
000194  f101003c          ADD      r0,r1,#0x3c           ;675
000198  f7fffffe          BL       GetScanTime
                  |L20.412|
00019c  e9d81020          LDRD     r1,r0,[r8,#0x80]      ;675
0001a0  4308              ORRS     r0,r0,r1              ;679
0001a2  d019              BEQ      |L20.472|
0001a4  491d              LDR      r1,|L20.540|
0001a6  f101003c          ADD      r0,r1,#0x3c           ;681
0001aa  f7fffffe          BL       GetScanTime
0001ae  f6446120          MOV      r1,#0x4e20            ;681
0001b2  4281              CMP      r1,r0                 ;681
0001b4  d810              BHI      |L20.472|
0001b6  4817              LDR      r0,|L20.532|
0001b8  f8884003          STRB     r4,[r8,#3]            ;683
0001bc  7801              LDRB     r1,[r0,#0]            ;684  ; g_Status
0001be  f0210102          BIC      r1,r1,#2              ;684
0001c2  7001              STRB     r1,[r0,#0]            ;684
0001c4  2000              MOVS     r0,#0                 ;685
0001c6  f8c84044          STR      r4,[r8,#0x44]         ;685  ; g_ScanTime_Recovery
0001ca  e9c80020          STRD     r0,r0,[r8,#0x80]      ;685
0001ce  f8884007          STRB     r4,[r8,#7]            ;687
0001d2  f7fffffe          BL       module_Protocol_Init
                  |L20.470|
0001d6  e7fe              B        |L20.470|
                  |L20.472|
0001d8  2d00              CMP      r5,#0                 ;721
0001da  bf04              ITT      EQ
0001dc  b011              ADDEQ    sp,sp,#0x44
0001de  e8bd8ff0          POPEQ    {r4-r11,pc}
0001e2  f8980003          LDRB     r0,[r8,#3]            ;721  ; g_RemoteWakeup
0001e6  2800              CMP      r0,#0                 ;721
0001e8  bf1c              ITT      NE
0001ea  b011              ADDNE    sp,sp,#0x44
0001ec  e8bd8ff0          POPNE    {r4-r11,pc}
0001f0  f8980000          LDRB     r0,[r8,#0]  ; g_Configuration
0001f4  2800              CMP      r0,#0                 ;727
0001f6  bf19              ITTEE    NE                    ;727
0001f8  f8980001          LDRBNE   r0,[r8,#1]            ;727  ; g_HIDReady
0001fc  2800              CMPNE    r0,#0                 ;727
0001fe  b011              ADDEQ    sp,sp,#0x44
000200  e8bd8ff0          POPEQ    {r4-r11,pc}
000204  4630              MOV      r0,r6                 ;729
000206  f7fffffe          BL       SendTouchData_USB
00020a  b011              ADD      sp,sp,#0x44
00020c  e8bd8ff0          POP      {r4-r11,pc}
;;;745    
                          ENDP

                  |L20.528|
                          DCD      ||.bss||+0x168
                  |L20.532|
                          DCD      ||.bss||
                  |L20.536|
                          DCD      ||.data||
                  |L20.540|
                          DCD      ||.data||+0x44

                          AREA ||i.SendTouchData_USB||, CODE, READONLY, ALIGN=2

                  SendTouchData_USB PROC
;;;537    // 유효한 데이터가 있을 때만 호출 된다.
;;;538    void SendTouchData_USB(PHID_MULTITOUCH pUserData)
000000  b570              PUSH     {r4-r6,lr}
;;;539    {
;;;540    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
000002  4920              LDR      r1,|L21.132|
000004  2500              MOVS     r5,#0
000006  f8d117c2          LDR      r1,[r1,#0x7c2]
00000a  291e              CMP      r1,#0x1e
00000c  d311              BCC      |L21.50|
00000e  4a1e              LDR      r2,|L21.136|
;;;541    	{
;;;542    		StaticQueue_HeadDelete(&g_Queue_Common);
000010  1e49              SUBS     r1,r1,#1
000012  6d93              LDR      r3,[r2,#0x58]  ; g_Full
000014  1c5b              ADDS     r3,r3,#1
000016  6593              STR      r3,[r2,#0x58]  ; g_Full
000018  4a1a              LDR      r2,|L21.132|
00001a  f8c217c2          STR      r1,[r2,#0x7c2]
00001e  f89217c1          LDRB     r1,[r2,#0x7c1]
000022  1c49              ADDS     r1,r1,#1
000024  b2c9              UXTB     r1,r1
000026  f88217c1          STRB     r1,[r2,#0x7c1]
00002a  291e              CMP      r1,#0x1e
00002c  bf28              IT       CS
00002e  f88257c1          STRBCS   r5,[r2,#0x7c1]
                  |L21.50|
;;;543    	}
;;;544    
;;;545    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
000032  4c14              LDR      r4,|L21.132|
000034  0001              MOVS     r1,r0
;;;546    
;;;547    //SENDTOUCHDATA_USB__GOTO_END:
;;;548    
;;;549    	return;
;;;550    }
000036  bf08              IT       EQ
000038  bd70              POPEQ    {r4-r6,pc}
00003a  f8d407c2          LDR      r0,[r4,#0x7c2]
00003e  281e              CMP      r0,#0x1e
000040  bf28              IT       CS
000042  bd70              POPCS    {r4-r6,pc}
000044  2001              MOVS     r0,#1
000046  f88407c6          STRB     r0,[r4,#0x7c6]
00004a  f89407c0          LDRB     r0,[r4,#0x7c0]
00004e  2242              MOVS     r2,#0x42
000050  eb001040          ADD      r0,r0,r0,LSL #5
000054  eb040040          ADD      r0,r4,r0,LSL #1
000058  1d00              ADDS     r0,r0,#4
00005a  f7fffffe          BL       __aeabi_memcpy
00005e  f8d407c2          LDR      r0,[r4,#0x7c2]
000062  1c40              ADDS     r0,r0,#1
000064  f8c407c2          STR      r0,[r4,#0x7c2]
000068  f89407c0          LDRB     r0,[r4,#0x7c0]
00006c  1c40              ADDS     r0,r0,#1
00006e  b2c0              UXTB     r0,r0
000070  f88407c0          STRB     r0,[r4,#0x7c0]
000074  281e              CMP      r0,#0x1e
000076  bf28              IT       CS
000078  f88457c0          STRBCS   r5,[r4,#0x7c0]
00007c  f88457c6          STRB     r5,[r4,#0x7c6]
000080  bd70              POP      {r4-r6,pc}
;;;551    
                          ENDP

000082  0000              DCW      0x0000
                  |L21.132|
                          DCD      ||.bss||+0x208
                  |L21.136|
                          DCD      ||.data||

                          AREA ||i.SetupPacket_AfterCheck||, CODE, READONLY, ALIGN=2

                  SetupPacket_AfterCheck PROC
;;;2663   
;;;2664   void SetupPacket_AfterCheck(PSETUP_PACKET pSetupPacket)
000000  4808              LDR      r0,|L22.36|
;;;2665   {
;;;2666   	switch (g_pSetupPacket->bRequest)
000002  69c1              LDR      r1,[r0,#0x1c]  ; g_pSetupPacket
000004  784a              LDRB     r2,[r1,#1]
000006  2a01              CMP      r2,#1
;;;2667   	{
;;;2668   		// Get Report
;;;2669   		case SETUPPACKET_CLASS_REQUEST__GET_REPORT:
;;;2670   		{
;;;2671   			// Feature
;;;2672   			if ((g_pSetupPacket->wValue & 0xFF00) == 0x0300)
;;;2673   			{
;;;2674   				switch (g_pSetupPacket->wValue & 0x00FF)
;;;2675   				{
;;;2676   					case HID_REPORT_ID__CONTACT_COUNT:
;;;2677   					{
;;;2678   						g_HIDReady = 1;
;;;2679   						break;
;;;2680   					}
;;;2681   				}
;;;2682   			}
;;;2683   
;;;2684   			break;
;;;2685   		}
;;;2686   	}
;;;2687   
;;;2688   	return;
;;;2689   }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  8849              LDRH     r1,[r1,#2]            ;2672
00000e  f401427f          AND      r2,r1,#0xff00         ;2672
000012  f5b27f40          CMP      r2,#0x300             ;2672
000016  bf01              ITTTT    EQ                    ;2674
000018  b2c9              UXTBEQ   r1,r1                 ;2674
00001a  2908              CMPEQ    r1,#8                 ;2674
00001c  2101              MOVEQ    r1,#1                 ;2678
00001e  7041              STRBEQ   r1,[r0,#1]            ;2678
000020  4770              BX       lr
;;;2690   #endif
                          ENDP

000022  0000              DCW      0x0000
                  |L22.36|
                          DCD      ||.data||

                          AREA ||i.StaticQueue_CheckEmpty||, CODE, READONLY, ALIGN=1

                  StaticQueue_CheckEmpty PROC
;;;485    
;;;486    uint8_t StaticQueue_CheckEmpty(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;487    {
000002  b120              CBZ      r0,|L23.14|
;;;488    	uint8_t nRet = 0;
;;;489    
;;;490    	if (pQueue == NULL)
;;;491    	{
;;;492    		goto STATICQUEUE_CHECKEMPTY__GOTO_END;
;;;493    	}
;;;494    
;;;495    	//EnterCriticalSection(&g_cs);
;;;496    	if (pQueue->Count <= 0)
000004  f8d007c2          LDR      r0,[r0,#0x7c2]
000008  2800              CMP      r0,#0
;;;497    	{
;;;498    		nRet = 1;
00000a  bf08              IT       EQ
00000c  2101              MOVEQ    r1,#1
                  |L23.14|
;;;499    	}
;;;500    	//LeaveCriticalSection(&g_cs);
;;;501    
;;;502    STATICQUEUE_CHECKEMPTY__GOTO_END:
;;;503    
;;;504    	return nRet;
00000e  4608              MOV      r0,r1
;;;505    }
000010  4770              BX       lr
;;;506    
                          ENDP


                          AREA ||i.StaticQueue_CheckFull||, CODE, READONLY, ALIGN=2

                  StaticQueue_CheckFull PROC
;;;462    
;;;463    uint8_t StaticQueue_CheckFull(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;464    {
000002  b140              CBZ      r0,|L24.22|
;;;465    	uint8_t nRet = 0;
;;;466    
;;;467    	if (pQueue == NULL)
;;;468    	{
;;;469    		goto STATICQUEUE_CHECKFULL__GOTO_END;
;;;470    	}
;;;471    
;;;472    	//EnterCriticalSection(&g_cs);
;;;473    	if (pQueue->Count >= QUEUE_MAX_COUNT__COMMON)
000004  f8d007c2          LDR      r0,[r0,#0x7c2]
000008  281e              CMP      r0,#0x1e
00000a  d304              BCC      |L24.22|
;;;474    	{
;;;475    		g_Full += 1;
00000c  4803              LDR      r0,|L24.28|
00000e  6d81              LDR      r1,[r0,#0x58]  ; g_Full
000010  1c49              ADDS     r1,r1,#1
;;;476    		nRet = 1;
000012  6581              STR      r1,[r0,#0x58]  ; g_Full
000014  2101              MOVS     r1,#1
                  |L24.22|
;;;477    	}
;;;478    	//LeaveCriticalSection(&g_cs);
;;;479    
;;;480    STATICQUEUE_CHECKFULL__GOTO_END:
;;;481    
;;;482    	return nRet;
000016  4608              MOV      r0,r1
;;;483    }
000018  4770              BX       lr
;;;484    
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      ||.data||

                          AREA ||i.StaticQueue_CheckInit||, CODE, READONLY, ALIGN=1

                  StaticQueue_CheckInit PROC
;;;308    
;;;309    uint8_t StaticQueue_CheckInit(PSTATIC_QUEUE pQueue)
000000  2101              MOVS     r1,#1
;;;310    {
000002  b138              CBZ      r0,|L25.20|
;;;311    	uint8_t	nRet = 1;
;;;312    	uint8_t*	pCompare = (uint8_t*)QUEUE_SIGNATURE;
;;;313    	uint8_t	i = 0;
;;;314    
;;;315    	if (pQueue == NULL)
;;;316    	{
;;;317    		goto  STATICQUEUE_CHECKINIT__GOTO_END;
;;;318    	}
;;;319    
;;;320    	for (i = 0; i < 4; i++)
;;;321    	{
;;;322    		if (pQueue->Signature[i] != pCompare[i])
000004  7802              LDRB     r2,[r0,#0]
000006  2a53              CMP      r2,#0x53
000008  bf04              ITT      EQ
00000a  7842              LDRBEQ   r2,[r0,#1]
00000c  2a49              CMPEQ    r2,#0x49
00000e  d003              BEQ      |L25.24|
                  |L25.16|
;;;323    		{
;;;324    			nRet = 0;
000010  f04f0100          MOV      r1,#0
                  |L25.20|
;;;325    			break;
;;;326    		}
;;;327    	}
;;;328    
;;;329    STATICQUEUE_CHECKINIT__GOTO_END:
;;;330    
;;;331    	return nRet;
000014  4608              MOV      r0,r1
;;;332    }
000016  4770              BX       lr
                  |L25.24|
000018  7882              LDRB     r2,[r0,#2]            ;322
00001a  2a57              CMP      r2,#0x57              ;322
00001c  bf04              ITT      EQ                    ;322
00001e  78c0              LDRBEQ   r0,[r0,#3]            ;322
000020  2834              CMPEQ    r0,#0x34              ;322
000022  d1f5              BNE      |L25.16|
000024  e7f6              B        |L25.20|
;;;333    
                          ENDP


                          AREA ||i.StaticQueue_Get||, CODE, READONLY, ALIGN=1

                  StaticQueue_Get PROC
;;;437    
;;;438    uint8_t* StaticQueue_Get(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;439    {
;;;440    	uint8_t* pRet = 0;
;;;441    
;;;442    	if (pQueue == NULL)
000002  2800              CMP      r0,#0
;;;443    	{
;;;444    		goto STATICQUEUE_GET__GOTO_END;
;;;445    	}
;;;446    
;;;447    	// Empty
;;;448    	if (pQueue->Count <= 0)
000004  bf1c              ITT      NE
000006  f8d027c2          LDRNE    r2,[r0,#0x7c2]
00000a  2a00              CMPNE    r2,#0
00000c  d007              BEQ      |L26.30|
;;;449    	{
;;;450    		goto STATICQUEUE_GET__GOTO_END;
;;;451    	}
;;;452    
;;;453    	pRet = &pQueue->Buffer[pQueue->PopPoint * QUEUE_BLOCK_SIZE];
00000e  f89017c1          LDRB     r1,[r0,#0x7c1]
000012  eb011141          ADD      r1,r1,r1,LSL #5
000016  eb000041          ADD      r0,r0,r1,LSL #1
00001a  f1000104          ADD      r1,r0,#4
                  |L26.30|
;;;454    
;;;455    STATICQUEUE_GET__GOTO_END:
;;;456    
;;;457    	return pRet;
00001e  4608              MOV      r0,r1
;;;458    }
000020  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.StaticQueue_HeadDelete||, CODE, READONLY, ALIGN=1

                  StaticQueue_HeadDelete PROC
;;;403    
;;;404    uint8_t StaticQueue_HeadDelete(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;405    {
;;;406    	uint8_t nRet = 0;
;;;407    
;;;408    	if (pQueue == NULL)
000002  2800              CMP      r0,#0
;;;409    	{
;;;410    		goto STATICQUEUE_POP__GOTO_END;
;;;411    	}
;;;412    
;;;413    	//EnterCriticalSection(&g_cs);
;;;414    
;;;415    	// Empty
;;;416    	if (pQueue->Count <= 0)
000004  bf1c              ITT      NE
000006  f8d027c2          LDRNE    r2,[r0,#0x7c2]
00000a  2a00              CMPNE    r2,#0
00000c  d010              BEQ      |L27.48|
;;;417    	{
;;;418    		goto STATICQUEUE_POP__GOTO_END;
;;;419    	}
;;;420    
;;;421    	pQueue->Count -= 1;
00000e  f1a20101          SUB      r1,r2,#1
000012  f8c017c2          STR      r1,[r0,#0x7c2]
;;;422    	pQueue->PopPoint += 1;
000016  f89017c1          LDRB     r1,[r0,#0x7c1]
00001a  f1010101          ADD      r1,r1,#1
00001e  b2c9              UXTB     r1,r1
000020  f88017c1          STRB     r1,[r0,#0x7c1]
;;;423    	if (pQueue->PopPoint >= QUEUE_MAX_COUNT__COMMON)
000024  291e              CMP      r1,#0x1e
;;;424    	{
;;;425    		pQueue->PopPoint = 0;
000026  bf24              ITT      CS
000028  2100              MOVCS    r1,#0
00002a  f88017c1          STRBCS   r1,[r0,#0x7c1]
;;;426    	}
;;;427    
;;;428    	nRet = 1;
00002e  2101              MOVS     r1,#1
                  |L27.48|
;;;429    
;;;430    STATICQUEUE_POP__GOTO_END:
;;;431    
;;;432    	//LeaveCriticalSection(&g_cs);
;;;433    	return nRet;
000030  4608              MOV      r0,r1
;;;434    }
000032  4770              BX       lr
;;;435    
                          ENDP


                          AREA ||i.StaticQueue_Init||, CODE, READONLY, ALIGN=2

                  StaticQueue_Init PROC
;;;284    
;;;285    uint8_t StaticQueue_Init(PSTATIC_QUEUE pQueue)
000000  b510              PUSH     {r4,lr}
;;;286    {
000002  0004              MOVS     r4,r0
;;;287    	uint8_t nRet = 0;
000004  f04f0000          MOV      r0,#0
;;;288    
;;;289    	if (pQueue == NULL)
;;;290    	{
;;;291    		goto STATICQUEUE_INIT__GOTO_END;
;;;292    	}
;;;293    
;;;294    	//InitializeCriticalSection(&g_cs);
;;;295    	memcpy(pQueue->Signature, (uint8_t*)QUEUE_SIGNATURE, 4);
;;;296    	memset(pQueue->Buffer, 0, QUEUE_BLOCK_SIZE * QUEUE_MAX_COUNT__COMMON);
;;;297    	pQueue->PushPoint = 0;
;;;298    	pQueue->PopPoint = 0;
;;;299    	pQueue->Count = 0;
;;;300    
;;;301    	nRet = 1;
;;;302    
;;;303    STATICQUEUE_INIT__GOTO_END:
;;;304    
;;;305    	return nRet;
;;;306    }
000008  bf08              IT       EQ
00000a  bd10              POPEQ    {r4,pc}
00000c  a008              ADR      r0,|L28.48|
00000e  f24071bc          MOV      r1,#0x7bc             ;296
000012  6800              LDR      r0,[r0,#0]            ;295
000014  6020              STR      r0,[r4,#0]            ;295
000016  1d20              ADDS     r0,r4,#4              ;296
000018  f7fffffe          BL       __aeabi_memclr
00001c  2000              MOVS     r0,#0                 ;297
00001e  f88407c0          STRB     r0,[r4,#0x7c0]        ;297
000022  f88407c1          STRB     r0,[r4,#0x7c1]        ;298
000026  f8c407c2          STR      r0,[r4,#0x7c2]        ;299
00002a  2001              MOVS     r0,#1                 ;301
00002c  bd10              POP      {r4,pc}
;;;307    
                          ENDP

00002e  0000              DCW      0x0000
                  |L28.48|
000030  53495734          DCB      "SIW4",0
000034  00      
000035  00                DCB      0
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.StaticQueue_Pop||, CODE, READONLY, ALIGN=1

                  StaticQueue_Pop PROC
;;;367    
;;;368    uint8_t StaticQueue_Pop(PSTATIC_QUEUE pQueue, uint8_t* pData)
000000  b510              PUSH     {r4,lr}
;;;369    {
000002  0004              MOVS     r4,r0
000004  460b              MOV      r3,r1
;;;370    	uint8_t nRet = FALSE;
000006  f04f0000          MOV      r0,#0
;;;371    
;;;372    	if ((pQueue == NULL) || (pData == NULL))
00000a  bf14              ITE      NE
00000c  2b00              CMPNE    r3,#0
;;;373    	{
;;;374    		goto STATICQUEUE_POP__GOTO_END;
;;;375    	}
;;;376    
;;;377    	// Empty
;;;378    	if (pQueue->Count <= 0)
;;;379    	{
;;;380    		goto STATICQUEUE_POP__GOTO_END;
;;;381    	}
;;;382        
;;;383        if (pQueue->Doing == TRUE)
;;;384        {
;;;385            goto STATICQUEUE_POP__GOTO_END;
;;;386        }
;;;387    
;;;388    	memcpy(pData, &pQueue->Buffer[pQueue->PopPoint * QUEUE_BLOCK_SIZE], QUEUE_BLOCK_SIZE);
;;;389    	pQueue->Count -= 1;
;;;390    	pQueue->PopPoint += 1;
;;;391    	if (pQueue->PopPoint >= QUEUE_MAX_COUNT__COMMON)
;;;392    	{
;;;393    		pQueue->PopPoint = 0;
;;;394    	}
;;;395    
;;;396    	nRet = TRUE;
;;;397    
;;;398    STATICQUEUE_POP__GOTO_END:
;;;399    
;;;400    	return nRet;
;;;401    }
00000e  bd10              POPEQ    {r4,pc}
000010  f8d417c2          LDR      r1,[r4,#0x7c2]        ;378
000014  2900              CMP      r1,#0                 ;378
000016  bf1a              ITTE     NE                    ;383
000018  f89417c6          LDRBNE   r1,[r4,#0x7c6]        ;383
00001c  2901              CMPNE    r1,#1                 ;383
00001e  bd10              POPEQ    {r4,pc}
000020  f89407c1          LDRB     r0,[r4,#0x7c1]        ;388
000024  f04f0242          MOV      r2,#0x42              ;388
000028  eb001040          ADD      r0,r0,r0,LSL #5       ;388
00002c  eb040040          ADD      r0,r4,r0,LSL #1       ;388
000030  f1000104          ADD      r1,r0,#4              ;388
000034  4618              MOV      r0,r3                 ;388
000036  f7fffffe          BL       __aeabi_memcpy
00003a  f8d407c2          LDR      r0,[r4,#0x7c2]        ;389
00003e  1e40              SUBS     r0,r0,#1              ;389
000040  f8c407c2          STR      r0,[r4,#0x7c2]        ;389
000044  f89407c1          LDRB     r0,[r4,#0x7c1]        ;390
000048  1c40              ADDS     r0,r0,#1              ;390
00004a  b2c0              UXTB     r0,r0                 ;390
00004c  f88407c1          STRB     r0,[r4,#0x7c1]        ;390
000050  281e              CMP      r0,#0x1e              ;391
000052  bf24              ITT      CS                    ;393
000054  2000              MOVCS    r0,#0                 ;393
000056  f88407c1          STRBCS   r0,[r4,#0x7c1]        ;393
00005a  2001              MOVS     r0,#1                 ;396
00005c  bd10              POP      {r4,pc}
;;;402    
                          ENDP


                          AREA ||i.StaticQueue_Push||, CODE, READONLY, ALIGN=1

                  StaticQueue_Push PROC
;;;333    
;;;334    uint8_t StaticQueue_Push(PSTATIC_QUEUE pQueue, uint8_t* pData)
000000  b510              PUSH     {r4,lr}
;;;335    {
000002  0004              MOVS     r4,r0
;;;336    	uint8_t nRet = 0;
000004  f04f0000          MOV      r0,#0
;;;337    
;;;338    	if ((pQueue == NULL) || (pData == NULL))
000008  bf14              ITE      NE
00000a  2900              CMPNE    r1,#0
;;;339    	{
;;;340    		goto STATICQUEUE_PUSH__GOTO_END;
;;;341    	}
;;;342    
;;;343    	// Full
;;;344    	if (pQueue->Count >= QUEUE_MAX_COUNT__COMMON)
;;;345    	{
;;;346    		goto STATICQUEUE_PUSH__GOTO_END;
;;;347    	}
;;;348    
;;;349        pQueue->Doing = TRUE;
;;;350        
;;;351    	memcpy(&pQueue->Buffer[pQueue->PushPoint * QUEUE_BLOCK_SIZE], pData, QUEUE_BLOCK_SIZE);
;;;352    	pQueue->Count += 1;
;;;353    	pQueue->PushPoint += 1;
;;;354    	if (pQueue->PushPoint >= QUEUE_MAX_COUNT__COMMON)
;;;355    	{
;;;356    		pQueue->PushPoint = 0;
;;;357    	}
;;;358    
;;;359    	nRet = 1;
;;;360        pQueue->Doing = FALSE;
;;;361    
;;;362    STATICQUEUE_PUSH__GOTO_END:
;;;363    
;;;364    	return nRet;
;;;365    }
00000c  bd10              POPEQ    {r4,pc}
00000e  f8d427c2          LDR      r2,[r4,#0x7c2]        ;344
000012  2a1e              CMP      r2,#0x1e              ;344
000014  bf28              IT       CS
000016  bd10              POPCS    {r4,pc}
000018  2001              MOVS     r0,#1                 ;349
00001a  f88407c6          STRB     r0,[r4,#0x7c6]        ;349
00001e  f89407c0          LDRB     r0,[r4,#0x7c0]        ;351
000022  2242              MOVS     r2,#0x42              ;351
000024  eb001040          ADD      r0,r0,r0,LSL #5       ;351
000028  eb040040          ADD      r0,r4,r0,LSL #1       ;351
00002c  1d00              ADDS     r0,r0,#4              ;351
00002e  f7fffffe          BL       __aeabi_memcpy
000032  f8d407c2          LDR      r0,[r4,#0x7c2]        ;352
000036  2100              MOVS     r1,#0                 ;353
000038  1c40              ADDS     r0,r0,#1              ;352
00003a  f8c407c2          STR      r0,[r4,#0x7c2]        ;352
00003e  f89407c0          LDRB     r0,[r4,#0x7c0]        ;353
000042  1c40              ADDS     r0,r0,#1              ;353
000044  b2c0              UXTB     r0,r0                 ;353
000046  f88407c0          STRB     r0,[r4,#0x7c0]        ;353
00004a  281e              CMP      r0,#0x1e              ;354
00004c  bf28              IT       CS                    ;356
00004e  f88417c0          STRBCS   r1,[r4,#0x7c0]        ;356
000052  2001              MOVS     r0,#1                 ;359
000054  f88417c6          STRB     r1,[r4,#0x7c6]        ;360
000058  bd10              POP      {r4,pc}
;;;366    
                          ENDP


                          AREA ||i.USB_DevInit||, CODE, READONLY, ALIGN=2

                  USB_DevInit PROC
;;;3041   
;;;3042   void USB_DevInit(void)
000000  4938              LDR      r1,|L31.228|
;;;3043   {
000002  b510              PUSH     {r4,lr}
;;;3044   #ifndef MODE_I2C
;;;3045   	Fncp_USB_IRQHandler = &USB_InterruptHandler;
000004  4836              LDR      r0,|L31.224|
;;;3046   	
;;;3047   	// suspend counter
;;;3048   	mUsbIdleCnt(7);
000006  6008              STR      r0,[r1,#0]  ; Fncp_USB_IRQHandler
000008  4837              LDR      r0,|L31.232|
00000a  2107              MOVS     r1,#7
00000c  f8c01124          STR      r1,[r0,#0x124]
;;;3049   
;;;3050   	mUsbUnPLGClr();
000010  f8d01114          LDR      r1,[r0,#0x114]
000014  f0210101          BIC      r1,r1,#1
000018  f8c01114          STR      r1,[r0,#0x114]
;;;3051   
;;;3052   	// Clear interrupt
;;;3053   	mUsbIntBusRstClr();
00001c  2101              MOVS     r1,#1
00001e  f8c0114c          STR      r1,[r0,#0x14c]
;;;3054   	mUsbIntSuspClr();
000022  2202              MOVS     r2,#2
000024  f8c0214c          STR      r2,[r0,#0x14c]
;;;3055   	mUsbIntResmClr();
000028  2204              MOVS     r2,#4
00002a  f8c0214c          STR      r2,[r0,#0x14c]
;;;3056   
;;;3057   	// Disable all fifo interrupt
;;;3058   	mUsbIntFIFO0_3OUTDis();
00002e  f8d02138          LDR      r2,[r0,#0x138]
000032  f04202ff          ORR      r2,r2,#0xff
000036  f8c02138          STR      r2,[r0,#0x138]
;;;3059   	mUsbIntFIFO0_3INDis();
00003a  f8d02138          LDR      r2,[r0,#0x138]
00003e  f4422270          ORR      r2,r2,#0xf0000
000042  f8c02138          STR      r2,[r0,#0x138]
;;;3060   
;;;3061   	// Clear all fifo
;;;3062   	mUsbClrAllFIFOSet();
000046  f8d02108          LDR      r2,[r0,#0x108]
00004a  f0420201          ORR      r2,r2,#1
00004e  f8c02108          STR      r2,[r0,#0x108]
;;;3063   
;;;3064   	mUsbIntWakebyVbusDis();
000052  f8d0213c          LDR      r2,[r0,#0x13c]
000056  f4426280          ORR      r2,r2,#0x400
00005a  f8c0213c          STR      r2,[r0,#0x13c]
;;;3065   	mUsbIntDevIdleDis();
00005e  f8d0213c          LDR      r2,[r0,#0x13c]
000062  f4427200          ORR      r2,r2,#0x200
000066  f8c0213c          STR      r2,[r0,#0x13c]
;;;3066   
;;;3067   	// Enable usb200 global interrupt
;;;3068   	mUsbGlobIntEnSet();
00006a  f8d02100          LDR      r2,[r0,#0x100]
00006e  f0420204          ORR      r2,r2,#4
000072  f8c02100          STR      r2,[r0,#0x100]
;;;3069   	mUsbChipEnSet();
000076  f8d02100          LDR      r2,[r0,#0x100]
00007a  f0420220          ORR      r2,r2,#0x20
00007e  f8c02100          STR      r2,[r0,#0x100]
;;;3070   	mUsbOTGDevFS();
000082  f8d02100          LDR      r2,[r0,#0x100]
000086  f4427200          ORR      r2,r2,#0x200
00008a  f8c02100          STR      r2,[r0,#0x100]
;;;3071   
;;;3072   	// Interrupt Mode
;;;3073   	mUsbIntPolarityLow();
00008e  f8502fc4          LDR      r2,[r0,#0xc4]!
000092  f0220208          BIC      r2,r2,#8
000096  f8402b0c          STR      r2,[r0],#0xc
;;;3074   
;;;3075   	
;;;3076   	// Virtual DMA
;;;3077   	mUsbVDMAEnable();
00009a  f8c01260          STR      r1,[r0,#0x260]
;;;3078   
;;;3079   	// Virtual DMA Mask - CXF Enable
;;;3080   	mUsbCXIntDmaErrEn();
00009e  f8d0125c          LDR      r1,[r0,#0x25c]
0000a2  f4213180          BIC      r1,r1,#0x10000
0000a6  f8c0125c          STR      r1,[r0,#0x25c]
;;;3081   	mUsbCXIntDmaFinishEn();
0000aa  f8d0125c          LDR      r1,[r0,#0x25c]
0000ae  f0210101          BIC      r1,r1,#1
0000b2  f8c0125c          STR      r1,[r0,#0x25c]
;;;3082   	
;;;3083   
;;;3084   	// RemoteWakeup
;;;3085   	mUsbRmWkupSet(); 
0000b6  6b01              LDR      r1,[r0,#0x30]
0000b8  f0410101          ORR      r1,r1,#1
0000bc  6301              STR      r1,[r0,#0x30]
0000be  480c              LDR      r0,|L31.240|
;;;3086   #endif
;;;3087   
;;;3088   #ifdef ADD_PEN //ADD_CUSTOM // NOTE : PEN일 경우에만 참조하고 있음..
;;;3089       sptAlgorithmInfo = algorithm_GetInfo();
;;;3090   #endif
;;;3091   
;;;3092   	// Queue
;;;3093   	StaticQueue_Init(&g_Queue_Common);
0000c0  4c0a              LDR      r4,|L31.236|
0000c2  f24071bc          MOV      r1,#0x7bc
0000c6  6800              LDR      r0,[r0,#0]
0000c8  6020              STR      r0,[r4,#0]
0000ca  1d20              ADDS     r0,r4,#4
0000cc  f7fffffe          BL       __aeabi_memclr
0000d0  2000              MOVS     r0,#0
0000d2  f88407c0          STRB     r0,[r4,#0x7c0]
0000d6  f88407c1          STRB     r0,[r4,#0x7c1]
0000da  f8c407c2          STR      r0,[r4,#0x7c2]
;;;3094   	return;
;;;3095   }
0000de  bd10              POP      {r4,pc}
;;;3096   
                          ENDP

                  |L31.224|
                          DCD      USB_InterruptHandler
                  |L31.228|
                          DCD      Fncp_USB_IRQHandler
                  |L31.232|
                          DCD      0x20100000
                  |L31.236|
                          DCD      ||.bss||+0x208
                  |L31.240|
                          DCD      ||i.StaticQueue_Init||+0x30

                          AREA ||i.USB_InterruptHandler||, CODE, READONLY, ALIGN=2

                  USB_InterruptHandler PROC
;;;2692   
;;;2693   void USB_InterruptHandler(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2694   {
;;;2695   //	SCRB->USB_INTR_CLR.ulBulk = 0x7; // USB CM3 Internal Interrupt clear!!
;;;2696   
;;;2697   #ifndef MODE_I2C
;;;2698   	g_IntGroup = mUsbIntGroupRegRd();	// 0x140
000004  4efd              LDR      r6,|L32.1020|
000006  f8d60140          LDR      r0,[r6,#0x140]
00000a  f8dfb3f4          LDR      r11,|L32.1024|
;;;2699   	// EP0
;;;2700   	if (g_IntGroup & BIT0)
00000e  f0100f01          TST      r0,#1
;;;2701   	{
;;;2702   		g_IntEP0 = mUsbIntSrc0Rd(); // 0x144
;;;2703   
;;;2704   		if (g_IntEP0 & BIT0)
;;;2705   		{
;;;2706   			//if ((g_CheckVDMAComplete_Touch == DMA_READY) && (g_CheckVDMAComplete_Custom == DMA_READY) && (g_CheckVDMAComplete_Pen == DMA_READY))
;;;2707   			if ((g_CXF_Done == CXF_STATUS__NORMAL) || (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;2708   			{
;;;2709   				g_CXF_Done = CXF_STATUS__DOING;
000012  f04f0801          MOV      r8,#1
000016  f8cb002c          STR      r0,[r11,#0x2c]        ;2694  ; g_IntGroup
00001a  d027              BEQ      |L32.108|
00001c  f8d61144          LDR      r1,[r6,#0x144]        ;2702
000020  f8cb1038          STR      r1,[r11,#0x38]        ;2704  ; g_IntEP0
000024  f0110f01          TST      r1,#1                 ;2704
000028  d020              BEQ      |L32.108|
00002a  f89b1002          LDRB     r1,[r11,#2]           ;2707  ; g_CXF_Done
00002e  2900              CMP      r1,#0                 ;2707
000030  bf18              IT       NE                    ;2707
000032  2903              CMPNE    r1,#3                 ;2707
000034  d11a              BNE      |L32.108|
000036  f88b8002          STRB     r8,[r11,#2]
;;;2710   
;;;2711   				mUsbCXIntDmaErrEn();
00003a  f8d6132c          LDR      r1,[r6,#0x32c]
00003e  f4213180          BIC      r1,r1,#0x10000
000042  f8c6132c          STR      r1,[r6,#0x32c]
;;;2712   				mUsbCXIntDmaFinishEn();
000046  f8d6132c          LDR      r1,[r6,#0x32c]
00004a  f0210101          BIC      r1,r1,#1
00004e  f8c6132c          STR      r1,[r6,#0x32c]
;;;2713   
;;;2714   				mUsbCXDmaConfig(8, DIRECTION_OUT); // Memory To FIFO
000052  f44f6100          MOV      r1,#0x800
000056  f8c61300          STR      r1,[r6,#0x300]
;;;2715   				mUsbCXDmaAddr((uint32_t)g_EP0_Packet);
00005a  49ea              LDR      r1,|L32.1028|
00005c  f8c61304          STR      r1,[r6,#0x304]
;;;2716   				mUsbCXDmaStart();
000060  f8d61300          LDR      r1,[r6,#0x300]
000064  f0410101          ORR      r1,r1,#1
000068  f8c61300          STR      r1,[r6,#0x300]
                  |L32.108|
;;;2717   			}
;;;2718   
;;;2719   		}
;;;2720   	}
;;;2721   
;;;2722   
;;;2723   
;;;2724   	// Virtual DMA 
;;;2725   	if (g_IntGroup & BIT3)
00006c  f0100f08          TST      r0,#8
;;;2726   	{
;;;2727   		g_IntVDMA = mUsbIntSrc3Rd();
;;;2728   
;;;2729   		// CXF Complete
;;;2730   		if (g_IntVDMA & BIT0)
;;;2731   		{
;;;2732   			// DMA 작업이 완료 되고 난 뒤에 g_CXF_Done 상태 값을 CXF_STATUS__NEED_TO_DONE 으로 바꿔야 한다.
;;;2733   			if (g_EP0_Check == 1)
;;;2734   			{
;;;2735   				// Buffer 의 크기 만큼 처리 했거나 Host 의 요청 크기 만큼 처리 했으면 Done !!
;;;2736   				if ((g_EP0_Offset == g_EP0_BufferLength) || (g_EP0_Offset == g_pSetupPacket->wLength))
;;;2737   				{
;;;2738   					// Cx Done!!!
;;;2739   					g_CXF_Done = CXF_STATUS__NEED_TO_DONE;
000070  f04f0902          MOV      r9,#2
000074  f04f0700          MOV      r7,#0
000078  f0008101          BEQ.W    |L32.638|
00007c  f8d60328          LDR      r0,[r6,#0x328]        ;2727
;;;2740   
;;;2741   					g_EP0_Offset = 0;
;;;2742   					g_EP0_Remain = 0;
;;;2743   					g_EP0_BufferLength = 0;
;;;2744   				}
;;;2745   
;;;2746   				g_EP0_Check = 0;
;;;2747   			}
;;;2748   
;;;2749   			if (g_CXF_Done == CXF_STATUS__NEED_TO_DONE)
;;;2750   			{
;;;2751   				mUsbCXDmaFinishClr();
;;;2752   				mUsbCXDmaErrClr();
000080  f44f3a80          MOV      r10,#0x10000
000084  f0100f01          TST      r0,#1                 ;2730
000088  f8cb0034          STR      r0,[r11,#0x34]        ;2730  ; g_IntVDMA
00008c  d01e              BEQ      |L32.204|
00008e  f89b1005          LDRB     r1,[r11,#5]           ;2733  ; g_EP0_Check
000092  2901              CMP      r1,#1                 ;2733
000094  d114              BNE      |L32.192|
000096  f8bb200c          LDRH     r2,[r11,#0xc]         ;2736  ; g_EP0_BufferLength
00009a  f8db1024          LDR      r1,[r11,#0x24]        ;2736  ; g_EP0_Offset
00009e  4291              CMP      r1,r2                 ;2736
0000a0  d004              BEQ      |L32.172|
0000a2  f8db201c          LDR      r2,[r11,#0x1c]        ;2736  ; g_pSetupPacket
0000a6  88d2              LDRH     r2,[r2,#6]            ;2736
0000a8  428a              CMP      r2,r1                 ;2736
0000aa  d107              BNE      |L32.188|
                  |L32.172|
0000ac  f88b9002          STRB     r9,[r11,#2]           ;2739
0000b0  f8cb7024          STR      r7,[r11,#0x24]        ;2742  ; g_EP0_Offset
0000b4  f8cb7028          STR      r7,[r11,#0x28]        ;2743  ; g_EP0_Remain
0000b8  f8ab700c          STRH     r7,[r11,#0xc]         ;2743
                  |L32.188|
0000bc  f88b7005          STRB     r7,[r11,#5]           ;2746
                  |L32.192|
0000c0  f89b1002          LDRB     r1,[r11,#2]           ;2749  ; g_CXF_Done
0000c4  2902              CMP      r1,#2                 ;2749
0000c6  d045              BEQ      |L32.340|
;;;2753   				mUsbCXIntDmaFinishDis();
;;;2754   				mUsbEP0DoneSet();
;;;2755   
;;;2756   				g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2757   
;;;2758   				// DMA 작업이 완료 되고 난 뒤에 관련 Flag 를 바꿔야 한다.
;;;2759   				SetupPacket_AfterCheck(g_pSetupPacket);
;;;2760   
;;;2761   				memset(g_pSetupPacket, 0, sizeof(SETUP_PACKET));
;;;2762   				return;
;;;2763   			}
;;;2764   			else if (g_CXF_Done == CXF_STATUS__DOING)
0000c8  2901              CMP      r1,#1
0000ca  d069              BEQ      |L32.416|
                  |L32.204|
;;;2765   			{
;;;2766   				//if ((g_CheckVDMAComplete_Touch == DMA_READY) && (g_CheckVDMAComplete_Custom == DMA_READY) && (g_CheckVDMAComplete_Pen == DMA_READY))
;;;2767   				{
;;;2768   					mUsbCXDmaFinishClr();
;;;2769   					mUsbCXDmaErrClr();
;;;2770   					mUsbCXIntDmaFinishDis();
;;;2771   
;;;2772   					EP0_SetupPacket();
;;;2773   					return;
;;;2774   				}
;;;2775   			}
;;;2776   		}
;;;2777   
;;;2778   #ifdef ADD_TOUCH
;;;2779   		// FIFO Complete - MultiTouch
;;;2780   		if (g_IntVDMA & (BIT1 << TOUCH_FIFO_IN))
0000cc  f0100f04          TST      r0,#4
0000d0  d010              BEQ      |L32.244|
;;;2781   		{
;;;2782   			mUsbEXDmaFinishClr(TOUCH_FIFO_IN);
0000d2  2104              MOVS     r1,#4
0000d4  f8c61328          STR      r1,[r6,#0x328]
;;;2783   			mUsbEXIntDmaErrDis(TOUCH_FIFO_IN);
0000d8  f8d6132c          LDR      r1,[r6,#0x32c]
0000dc  f4412180          ORR      r1,r1,#0x40000
0000e0  f8c6132c          STR      r1,[r6,#0x32c]
;;;2784   			mUsbEXIntDmaFinishDis(TOUCH_FIFO_IN);
0000e4  f8d6132c          LDR      r1,[r6,#0x32c]
0000e8  f0410104          ORR      r1,r1,#4
0000ec  f8c6132c          STR      r1,[r6,#0x32c]
;;;2785   
;;;2786   			// Touch DMA 처리가 완료 되었음을 표시한다.
;;;2787   			g_CheckVDMAComplete_Touch = DMA_READY;
0000f0  f88b8006          STRB     r8,[r11,#6]
                  |L32.244|
;;;2788   		}
;;;2789   #endif
;;;2790   		
;;;2791   		
;;;2792   #ifdef ADD_CUSTOM
;;;2793   		// FIFO Complete - Custom OUT
;;;2794   		if (g_IntVDMA & (BIT1 << CUSTOM_FIFO_OUT))
0000f4  f0100f08          TST      r0,#8
0000f8  d066              BEQ      |L32.456|
0000fa  2008              MOVS     r0,#8
0000fc  f8c60328          STR      r0,[r6,#0x328]
000100  f8d6032c          LDR      r0,[r6,#0x32c]
000104  f4402000          ORR      r0,r0,#0x80000
000108  f8c6032c          STR      r0,[r6,#0x32c]
00010c  f8d6032c          LDR      r0,[r6,#0x32c]
000110  f0400008          ORR      r0,r0,#8
000114  f8c6032c          STR      r0,[r6,#0x32c]
000118  f8d6032c          LDR      r0,[r6,#0x32c]
00011c  f4202000          BIC      r0,r0,#0x80000
000120  f8c6032c          STR      r0,[r6,#0x32c]
000124  f8d6032c          LDR      r0,[r6,#0x32c]
000128  f0200008          BIC      r0,r0,#8
00012c  f8c6032c          STR      r0,[r6,#0x32c]
000130  f44f4080          MOV      r0,#0x4000
000134  f8c60318          STR      r0,[r6,#0x318]
000138  48b3              LDR      r0,|L32.1032|
00013a  f8c6031c          STR      r0,[r6,#0x31c]
00013e  f8d60318          LDR      r0,[r6,#0x318]
000142  f0400001          ORR      r0,r0,#1
000146  f8c60318          STR      r0,[r6,#0x318]
;;;2795   		{
;;;2796   			// Custom OUT
;;;2797   			RecieveCustomData_DMA();
;;;2798   			
;;;2799   #ifdef JOSH3_LOOP_BACK_TEST
;;;2800   			g_CustomBuffer[0] = HID_REPORT_ID__CUSTOM_IN;
;;;2801   			SendCustomData_USB((UINT8*)g_CustomBuffer);
;;;2802   #else
;;;2803   			// App Call
;;;2804   			RecieveCustomData(g_CustomBuffer);
00014a  48af              LDR      r0,|L32.1032|
00014c  7801              LDRB     r1,[r0,#0]
00014e  2909              CMP      r1,#9
000150  d034              BEQ      |L32.444|
000152  e05e              B        |L32.530|
                  |L32.340|
000154  f8c68328          STR      r8,[r6,#0x328]        ;2751
000158  f8c6a328          STR      r10,[r6,#0x328]       ;2752
00015c  f8d6032c          LDR      r0,[r6,#0x32c]        ;2753
000160  f0400001          ORR      r0,r0,#1              ;2753
000164  f8c6032c          STR      r0,[r6,#0x32c]        ;2753
000168  f8d60120          LDR      r0,[r6,#0x120]        ;2754
00016c  f0400001          ORR      r0,r0,#1              ;2754
000170  f8c60120          STR      r0,[r6,#0x120]        ;2754
000174  2003              MOVS     r0,#3                 ;2756
000176  f88b0002          STRB     r0,[r11,#2]           ;2756
00017a  f8db001c          LDR      r0,[r11,#0x1c]        ;2756  ; g_pSetupPacket
00017e  7841              LDRB     r1,[r0,#1]            ;2756
000180  2901              CMP      r1,#1                 ;2756
000182  d109              BNE      |L32.408|
000184  8841              LDRH     r1,[r0,#2]            ;2759
000186  f401427f          AND      r2,r1,#0xff00         ;2759
00018a  f5b27f40          CMP      r2,#0x300             ;2759
00018e  bf02              ITTT     EQ                    ;2759
000190  b2c9              UXTBEQ   r1,r1                 ;2759
000192  2908              CMPEQ    r1,#8                 ;2759
000194  f88b8001          STRBEQ   r8,[r11,#1]           ;2759
                  |L32.408|
000198  e8bd5ff0          POP      {r4-r12,lr}           ;2761
00019c  f7ffbffe          B.W      __ARM_common_memclr4_8
                  |L32.416|
0001a0  f8c68328          STR      r8,[r6,#0x328]        ;2768
0001a4  f8c6a328          STR      r10,[r6,#0x328]       ;2769
0001a8  f8d6032c          LDR      r0,[r6,#0x32c]        ;2770
0001ac  f0400001          ORR      r0,r0,#1              ;2770
0001b0  f8c6032c          STR      r0,[r6,#0x32c]        ;2770
0001b4  e8bd5ff0          POP      {r4-r12,lr}           ;2772
0001b8  f7ffbffe          B.W      EP0_SetupPacket
                  |L32.444|
0001bc  7841              LDRB     r1,[r0,#1]            ;2772
0001be  f0110f01          TST      r1,#1                 ;2772
0001c2  d002              BEQ      |L32.458|
0001c4  f7fffffe          BL       HidReadWrite__Read
                  |L32.456|
0001c8  e023              B        |L32.530|
                  |L32.458|
0001ca  2500              MOVS     r5,#0                 ;2772
0001cc  4604              MOV      r4,r0                 ;2772
0001ce  462b              MOV      r3,r5                 ;2772
0001d0  462a              MOV      r2,r5                 ;2772
0001d2  4629              MOV      r1,r5                 ;2772
0001d4  2001              MOVS     r0,#1                 ;2772
0001d6  f7fffffe          BL       protocol_hid_mapping_emul_handler
0001da  2300              MOVS     r3,#0                 ;2772
0001dc  461a              MOV      r2,r3                 ;2772
0001de  4619              MOV      r1,r3                 ;2772
0001e0  2004              MOVS     r0,#4                 ;2772
0001e2  f7fffffe          BL       protocol_hid_mapping_emul_handler
0001e6  8860              LDRH     r0,[r4,#2]            ;2772
0001e8  2800              CMP      r0,#0                 ;2772
0001ea  d90c              BLS      |L32.518|
                  |L32.492|
0001ec  1960              ADDS     r0,r4,r5              ;2772
0001ee  1c6d              ADDS     r5,r5,#1              ;2772
0001f0  7903              LDRB     r3,[r0,#4]            ;2772
0001f2  b2a9              UXTH     r1,r5                 ;2772
0001f4  f44f5280          MOV      r2,#0x1000            ;2772
0001f8  2003              MOVS     r0,#3                 ;2772
0001fa  f7fffffe          BL       protocol_hid_mapping_emul_handler
0001fe  8860              LDRH     r0,[r4,#2]            ;2772
000200  b2ad              UXTH     r5,r5                 ;2772
000202  42a8              CMP      r0,r5                 ;2772
000204  d8f2              BHI      |L32.492|
                  |L32.518|
000206  2300              MOVS     r3,#0                 ;2772
000208  461a              MOV      r2,r3                 ;2772
00020a  4619              MOV      r1,r3                 ;2772
00020c  2002              MOVS     r0,#2                 ;2772
00020e  f7fffffe          BL       protocol_hid_mapping_emul_handler
                  |L32.530|
;;;2805   #endif
;;;2806   		}
;;;2807   
;;;2808   		// FIFO Complete - Custom IN
;;;2809   		if (g_IntVDMA & (BIT1 << CUSTOM_FIFO_IN))
000212  f8db0034          LDR      r0,[r11,#0x34]  ; g_IntVDMA
000216  f0100f02          TST      r0,#2
00021a  d00f              BEQ      |L32.572|
;;;2810   		{
;;;2811   			mUsbEXDmaFinishClr(CUSTOM_FIFO_IN);
00021c  f8c69328          STR      r9,[r6,#0x328]
;;;2812   			mUsbEXIntDmaErrDis(CUSTOM_FIFO_IN);
000220  f8d6132c          LDR      r1,[r6,#0x32c]
000224  f4413100          ORR      r1,r1,#0x20000
000228  f8c6132c          STR      r1,[r6,#0x32c]
;;;2813   			mUsbEXIntDmaFinishDis(CUSTOM_FIFO_IN);
00022c  f8d6132c          LDR      r1,[r6,#0x32c]
000230  f0410102          ORR      r1,r1,#2
000234  f8c6132c          STR      r1,[r6,#0x32c]
;;;2814   
;;;2815   			// Custom DMA 처리가 완료 되었음을 표시한다.
;;;2816   			g_CheckVDMAComplete_Custom = DMA_READY;
000238  f88b8009          STRB     r8,[r11,#9]
                  |L32.572|
;;;2817   		}
;;;2818   #endif
;;;2819   		
;;;2820   		
;;;2821   		
;;;2822   #ifdef ADD_PEN
;;;2823   		// FIFO Complete - Pen
;;;2824   		if (g_IntVDMA & (BIT1 << PEN_FIFO_IN))
;;;2825   		{
;;;2826   			mUsbEXDmaFinishClr(PEN_FIFO_IN);
;;;2827   			mUsbEXIntDmaErrDis(PEN_FIFO_IN);
;;;2828   			mUsbEXIntDmaFinishDis(PEN_FIFO_IN);
;;;2829   
;;;2830   			// Touch DMA 처리가 완료 되었음을 표시한다.
;;;2831   			g_CheckVDMAComplete_Pen = DMA_READY;
;;;2832   		}
;;;2833   #endif
;;;2834   
;;;2835   
;;;2836   
;;;2837   #ifdef ADD_BULK_CUSTOM
;;;2838   		// FIFO Complete - Bulk Custom OUT
;;;2839   		if (g_IntVDMA & (BIT1 << BULK_CUSTOM_FIFO_OUT))
;;;2840   		{
;;;2841   			// Bulk Custom OUT
;;;2842   			RecieveBulkCustomData_DMA();
;;;2843   
;;;2844   			// App Call
;;;2845   			RecieveBulkCustomData(g_BulkCustomBuffer);
;;;2846   		}
;;;2847   
;;;2848   		// FIFO Complete - Bulk Custom IN
;;;2849   		if (g_IntVDMA & (BIT1 << BULK_CUSTOM_FIFO_IN))
;;;2850   		{
;;;2851   			mUsbEXDmaFinishClr(BULK_CUSTOM_FIFO_IN);
;;;2852   			mUsbEXIntDmaErrDis(BULK_CUSTOM_FIFO_IN);
;;;2853   			mUsbEXIntDmaFinishDis(BULK_CUSTOM_FIFO_IN);
;;;2854   
;;;2855   			// Bulk Custom DMA 처리가 완료 되었음을 표시한다.
;;;2856   			g_CheckVDMAComplete_BulkCustom = DMA_READY;
;;;2857   		}
;;;2858   #endif
;;;2859   
;;;2860   
;;;2861   
;;;2862   		// CXF Error
;;;2863   		if (g_IntVDMA & BIT16)
00023c  f4103f80          TST      r0,#0x10000
;;;2864   		{
;;;2865   			mUsbCXDmaErrClr();
000240  bf18              IT       NE
000242  f8c6a328          STRNE    r10,[r6,#0x328]
;;;2866   		}
;;;2867   
;;;2868   		// FIFO 0 Error
;;;2869   		if (g_IntVDMA & BIT17)
000246  f4103f00          TST      r0,#0x20000
;;;2870   		{
;;;2871   			mUsbEXDmaErrClr(0);
00024a  bf1c              ITT      NE
00024c  f44f3100          MOVNE    r1,#0x20000
000250  f8c61328          STRNE    r1,[r6,#0x328]
;;;2872   		}
;;;2873   
;;;2874   		// FIFO 1 Error
;;;2875   		if (g_IntVDMA & BIT18)
000254  f4102f80          TST      r0,#0x40000
;;;2876   		{
;;;2877   			mUsbEXDmaErrClr(1);
000258  bf1c              ITT      NE
00025a  f44f2180          MOVNE    r1,#0x40000
00025e  f8c61328          STRNE    r1,[r6,#0x328]
;;;2878   		}
;;;2879   
;;;2880   		// FIFO 2 Error
;;;2881   		if (g_IntVDMA & BIT19)
000262  f4102f00          TST      r0,#0x80000
;;;2882   		{
;;;2883   			mUsbEXDmaErrClr(2);
000266  bf1c              ITT      NE
000268  f44f2100          MOVNE    r1,#0x80000
00026c  f8c61328          STRNE    r1,[r6,#0x328]
;;;2884   		}
;;;2885   
;;;2886   		// FIFO 3 Error
;;;2887   		if (g_IntVDMA & BIT20)
000270  f4101f80          TST      r0,#0x100000
;;;2888   		{
;;;2889   			mUsbEXDmaErrClr(3);
000274  bf1c              ITT      NE
000276  f44f1080          MOVNE    r0,#0x100000
00027a  f8c60328          STRNE    r0,[r6,#0x328]
                  |L32.638|
;;;2890   		}
;;;2891   	}
;;;2892   
;;;2893   
;;;2894   
;;;2895   	// USB Controll
;;;2896   	if (g_IntGroup & BIT2)
00027e  f89b002c          LDRB     r0,[r11,#0x2c]  ; g_IntGroup
000282  f0100f04          TST      r0,#4
000286  d074              BEQ      |L32.882|
;;;2897   	{
;;;2898   		g_IntControl = mUsbIntSrc2Rd();
000288  f8d6014c          LDR      r0,[r6,#0x14c]
;;;2899   
;;;2900   		// USBRST_INT
;;;2901   		if (g_IntControl & BIT0)
00028c  f8cb0030          STR      r0,[r11,#0x30]  ; g_IntControl
000290  f0100f01          TST      r0,#1
000294  d034              BEQ      |L32.768|
;;;2902   		{
;;;2903   			g_RemoteWakeup = 0;
000296  f88b7003          STRB     r7,[r11,#3]
;;;2904   			g_Configuration = 0;
00029a  f88b7000          STRB     r7,[r11,#0]
;;;2905   			g_HIDReady = 0;
00029e  f88b7001          STRB     r7,[r11,#1]
;;;2906   
;;;2907   			// Clear
;;;2908   			mUsbIntBusRstClr();
0002a2  f8c6814c          STR      r8,[r6,#0x14c]
;;;2909   
;;;2910   			// Addr
;;;2911   			mUsbDevAddrSet(0);
0002a6  f8c67104          STR      r7,[r6,#0x104]
;;;2912   
;;;2913   			// FIFO
;;;2914   			mUsbClrAllFIFOSet();
0002aa  f8d60108          LDR      r0,[r6,#0x108]
0002ae  f0400001          ORR      r0,r0,#1
0002b2  f8c60108          STR      r0,[r6,#0x108]
;;;2915   
;;;2916   			// EP0 FIFO Clear
;;;2917   			mUsbCxFClr();
0002b6  f8d60120          LDR      r0,[r6,#0x120]
0002ba  f0400008          ORR      r0,r0,#8
0002be  f8c60120          STR      r0,[r6,#0x120]
;;;2918   
;;;2919   			// Full Speed
;;;2920   			mUsbOTGDevFS();
0002c2  f8d60100          LDR      r0,[r6,#0x100]
0002c6  f4407000          ORR      r0,r0,#0x200
0002ca  f8c60100          STR      r0,[r6,#0x100]
;;;2921   
;;;2922   			// Init
;;;2923   			USB_ResetResume();
0002ce  f7fffffe          BL       USB_ResetResume
0002d2  484f              LDR      r0,|L32.1040|
;;;2924   			
;;;2925   			// Queue
;;;2926   			StaticQueue_Init(&g_Queue_Common);
0002d4  4c4d              LDR      r4,|L32.1036|
0002d6  f24071bc          MOV      r1,#0x7bc
0002da  6800              LDR      r0,[r0,#0]
0002dc  6020              STR      r0,[r4,#0]
0002de  1d20              ADDS     r0,r4,#4
0002e0  f7fffffe          BL       __aeabi_memclr
0002e4  f88477c0          STRB     r7,[r4,#0x7c0]
0002e8  f88477c1          STRB     r7,[r4,#0x7c1]
;;;2927   
;;;2928   			// SelfPowerd, RemoteWakeup 비활성화 상태
;;;2929   			g_Status[0].Status.Global.SelfPowered = 1;
0002ec  f5a47102          SUB      r1,r4,#0x208
0002f0  f8c477c2          STR      r7,[r4,#0x7c2]
0002f4  7808              LDRB     r0,[r1,#0]  ; g_Status
0002f6  f0200002          BIC      r0,r0,#2
;;;2930   			g_Status[0].Status.Global.RemoteWakeup = 0;
0002fa  f0400001          ORR      r0,r0,#1
0002fe  7008              STRB     r0,[r1,#0]
                  |L32.768|
;;;2931   		}
;;;2932   
;;;2933   		// SUSP_INT
;;;2934   		if (g_IntControl & BIT1)
000300  f8db0030          LDR      r0,[r11,#0x30]  ; g_IntControl
000304  f0100f02          TST      r0,#2
000308  d005              BEQ      |L32.790|
;;;2935   		{
;;;2936   			g_Configuration = 0;
00030a  f88b7000          STRB     r7,[r11,#0]
;;;2937   			g_HIDReady = 0;
00030e  f88b7001          STRB     r7,[r11,#1]
;;;2938   
;;;2939   			mUsbIntSuspClr();
000312  f8c6914c          STR      r9,[r6,#0x14c]
                  |L32.790|
;;;2940   		}
;;;2941   
;;;2942   		// RESM_INT
;;;2943   		if (g_IntControl & BIT2)
000316  f0100f04          TST      r0,#4
00031a  d020              BEQ      |L32.862|
;;;2944   		{
;;;2945   			if (g_RemoteWakeup == 1)
00031c  f89b0003          LDRB     r0,[r11,#3]  ; g_RemoteWakeup
000320  2801              CMP      r0,#1
000322  d113              BNE      |L32.844|
;;;2946   			{
;;;2947   				g_RemoteWakeup = 0;
;;;2948   				mUsbRemoteWakeUpSet_0();
000324  0780              LSLS     r0,r0,#30
000326  f88b7003          STRB     r7,[r11,#3]           ;2947
00032a  f8101fa4          LDRB     r1,[r0,#0xa4]!
00032e  f0210102          BIC      r1,r1,#2
000332  7001              STRB     r1,[r0,#0]
;;;2949   				g_ScanTime_Recovery = 0;
000334  2100              MOVS     r1,#0
000336  f8cb7044          STR      r7,[r11,#0x44]  ; g_ScanTime_Recovery
00033a  e9cb1120          STRD     r1,r1,[r11,#0x80]
;;;2950   				g_StartTime_Recovery = 0;
;;;2951   				GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus);
00033e  4935              LDR      r1,|L32.1044|
000340  f1010040          ADD      r0,r1,#0x40
000344  f7fffffe          BL       GetScanTime
;;;2952   				Recovery_ClearSus_Flag = 1;
000348  f88b8008          STRB     r8,[r11,#8]
                  |L32.844|
;;;2953   			}
;;;2954   
;;;2955   			mUsbIntResmClr();
00034c  2004              MOVS     r0,#4
00034e  f8c6014c          STR      r0,[r6,#0x14c]
;;;2956   			g_Configuration=1;
000352  f88b8000          STRB     r8,[r11,#0]
;;;2957   			g_HIDReady=1;
000356  f88b8001          STRB     r8,[r11,#1]
;;;2958   
;;;2959   			// Init
;;;2960   			USB_ResetResume();
00035a  f7fffffe          BL       USB_ResetResume
                  |L32.862|
;;;2961   		}
;;;2962   
;;;2963   		// DMA_COMPLT
;;;2964   		if (g_IntControl & BIT7)
00035e  f89b0030          LDRB     r0,[r11,#0x30]  ; g_IntControl
000362  f0100f80          TST      r0,#0x80
000366  d004              BEQ      |L32.882|
;;;2965   		{
;;;2966   			// Finish
;;;2967   			mUsbIntDmaFinishClr();
000368  2080              MOVS     r0,#0x80
00036a  f8c6014c          STR      r0,[r6,#0x14c]
;;;2968   
;;;2969   			// FIFO Control 중지
;;;2970   			mUsbDMA2FIFOSel(0);
00036e  f8c671c0          STR      r7,[r6,#0x1c0]
                  |L32.882|
;;;2971   		}
;;;2972   
;;;2973   	}
;;;2974   
;;;2975   
;;;2976   
;;;2977   
;;;2978   	if (g_IntGroup & BIT1)
000372  f89b002c          LDRB     r0,[r11,#0x2c]  ; g_IntGroup
000376  f0100f02          TST      r0,#2
;;;2979   	{
;;;2980   		g_IntEP = mUsbIntSrc1Rd(); // 0x148
;;;2981   
;;;2982   #ifdef ADD_TOUCH
;;;2983   		// Multi Touch (IN)
;;;2984   		if (g_IntEP & (BIT16 << TOUCH_FIFO_IN))
;;;2985   		{
;;;2986   			if ((g_CheckVDMAComplete_Touch == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;2987   			{
;;;2988   				mUsbIntF1INDis();
;;;2989   				DMATouchData_USB();
;;;2990   				return;
;;;2991   			}
;;;2992   		}
;;;2993   #endif
;;;2994   
;;;2995   #ifdef ADD_CUSTOM
;;;2996   		// Custom (IN)
;;;2997   		if (g_IntEP & (BIT16 << CUSTOM_FIFO_IN))
;;;2998   		{
;;;2999   			if ((g_CheckVDMAComplete_Custom == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3000   			{
;;;3001   				mUsbIntF0INDis();
;;;3002   				DMACustomData_USB();
;;;3003   				return;
;;;3004   			}
;;;3005   		}
;;;3006   #endif
;;;3007   
;;;3008   #ifdef ADD_PEN
;;;3009   		// Pen (IN)
;;;3010   		if (g_IntEP & (BIT16 << PEN_FIFO_IN))
;;;3011   		{
;;;3012   			if ((g_CheckVDMAComplete_Pen == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3013   			{
;;;3014   				mUsbIntF3INDis();
;;;3015   				DMAPenData_USB();
;;;3016   				return;
;;;3017   			}
;;;3018   		}
;;;3019   #endif
;;;3020   
;;;3021   #ifdef ADD_BULK_CUSTOM
;;;3022   		// Bulk Custom (IN)
;;;3023   		if (g_IntEP & (BIT16 << BULK_CUSTOM_FIFO_IN))
;;;3024   		{
;;;3025   			if ((g_CheckVDMAComplete_BulkCustom == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3026   			{
;;;3027   				mUsbIntF0INDis();
;;;3028   				DMABulkData_USB();
;;;3029   				return;
;;;3030   			}
;;;3031   		}
;;;3032   #endif
;;;3033   
;;;3034   	}
;;;3035   
;;;3036   #endif
;;;3037   	return;
;;;3038   }
00037a  bf08              IT       EQ
00037c  e8bd9ff0          POPEQ    {r4-r12,pc}
000380  f8d60148          LDR      r0,[r6,#0x148]        ;2980
000384  f2440102          MOV      r1,#0x4002            ;2980
000388  f4103f00          TST      r0,#0x20000           ;2984
00038c  f8cb003c          STR      r0,[r11,#0x3c]        ;2984  ; g_IntEP
000390  d007              BEQ      |L32.930|
000392  f89b2006          LDRB     r2,[r11,#6]           ;2986  ; g_CheckVDMAComplete_Touch
000396  2a00              CMP      r2,#0                 ;2986
000398  bf04              ITT      EQ                    ;2986
00039a  f89b2002          LDRBEQ   r2,[r11,#2]           ;2986  ; g_CXF_Done
00039e  2a03              CMPEQ    r2,#3                 ;2986
0003a0  d03a              BEQ      |L32.1048|
                  |L32.930|
0003a2  f4103f80          TST      r0,#0x10000           ;2997
0003a6  bf08              IT       EQ
0003a8  e8bd9ff0          POPEQ    {r4-r12,pc}
0003ac  f89b0009          LDRB     r0,[r11,#9]           ;2999  ; g_CheckVDMAComplete_Custom
0003b0  2800              CMP      r0,#0                 ;2999
0003b2  bf06              ITTE     EQ                    ;2999
0003b4  f89b0002          LDRBEQ   r0,[r11,#2]           ;2999  ; g_CXF_Done
0003b8  2803              CMPEQ    r0,#3                 ;2999
0003ba  e8bd9ff0          POPNE    {r4-r12,pc}
0003be  f8d60138          LDR      r0,[r6,#0x138]        ;3001
0003c2  f4403080          ORR      r0,r0,#0x10000        ;3001
0003c6  f8c60138          STR      r0,[r6,#0x138]        ;3001
0003ca  f8d6032c          LDR      r0,[r6,#0x32c]        ;3001
0003ce  f4203000          BIC      r0,r0,#0x20000        ;3001
0003d2  f8c6032c          STR      r0,[r6,#0x32c]        ;3001
0003d6  f8d6032c          LDR      r0,[r6,#0x32c]        ;3001
0003da  f0200002          BIC      r0,r0,#2              ;3001
0003de  f8c6032c          STR      r0,[r6,#0x32c]        ;3001
0003e2  f8c61308          STR      r1,[r6,#0x308]        ;3001
0003e6  4808              LDR      r0,|L32.1032|
0003e8  f8c6030c          STR      r0,[r6,#0x30c]        ;3001
0003ec  f8d60308          LDR      r0,[r6,#0x308]        ;3001
0003f0  f0400001          ORR      r0,r0,#1              ;3001
0003f4  f8c60308          STR      r0,[r6,#0x308]        ;3001
                  |L32.1016|
0003f8  e8bd9ff0          POP      {r4-r12,pc}
                  |L32.1020|
                          DCD      0x20100000
                  |L32.1024|
                          DCD      ||.data||
                  |L32.1028|
                          DCD      ||.data||+0x6c
                  |L32.1032|
                          DCD      ||.bss||+0xc9c
                  |L32.1036|
                          DCD      ||.bss||+0x208
                  |L32.1040|
                          DCD      ||i.StaticQueue_Init||+0x30
                  |L32.1044|
                          DCD      ||.data||+0x48
                  |L32.1048|
000418  f8d60138          LDR      r0,[r6,#0x138]        ;2988
00041c  f4403000          ORR      r0,r0,#0x20000        ;2988
000420  f8c60138          STR      r0,[r6,#0x138]        ;2988
000424  f8d6032c          LDR      r0,[r6,#0x32c]        ;2988
000428  f4202080          BIC      r0,r0,#0x40000        ;2988
00042c  f8c6032c          STR      r0,[r6,#0x32c]        ;2988
000430  f8d6032c          LDR      r0,[r6,#0x32c]        ;2988
000434  f0200004          BIC      r0,r0,#4              ;2988
000438  f8c6032c          STR      r0,[r6,#0x32c]        ;2988
00043c  f8c61310          STR      r1,[r6,#0x310]        ;2988
000440  4804              LDR      r0,|L32.1108|
000442  f8c60314          STR      r0,[r6,#0x314]        ;2988
000446  f8d60310          LDR      r0,[r6,#0x310]        ;2988
00044a  f0400001          ORR      r0,r0,#1              ;2988
00044e  f8c60310          STR      r0,[r6,#0x310]        ;2988
000452  e7d1              B        |L32.1016|
;;;3039   
                          ENDP

                  |L32.1108|
                          DCD      ||.bss||+0x11a

                          AREA ||i.USB_ResetResume||, CODE, READONLY, ALIGN=2

                  USB_ResetResume PROC
;;;2608   
;;;2609   void USB_ResetResume(void)
000000  482b              LDR      r0,|L33.176|
;;;2610   {
;;;2611   	// DMA
;;;2612   	mUsbVDMADisable();
000002  2100              MOVS     r1,#0
000004  f8c01330          STR      r1,[r0,#0x330]
;;;2613   	mUsbVDMAEnable();
000008  2101              MOVS     r1,#1
00000a  f8c01330          STR      r1,[r0,#0x330]
;;;2614   
;;;2615   #ifdef ADD_TOUCH
;;;2616   	mUsbEXDmaAbort(TOUCH_FIFO_IN);
00000e  f8d02310          LDR      r2,[r0,#0x310]
000012  f0420208          ORR      r2,r2,#8
000016  f8c02310          STR      r2,[r0,#0x310]
;;;2617   	mUsbEXDmaStop(TOUCH_FIFO_IN);
00001a  f8d02310          LDR      r2,[r0,#0x310]
00001e  f0220201          BIC      r2,r2,#1
000022  f8c02310          STR      r2,[r0,#0x310]
;;;2618   
;;;2619   	//g_ScanTime = 0;
;;;2620   	//g_StartTime = 0;
;;;2621   	g_CheckVDMAComplete_Touch = DMA_READY;
000026  4a23              LDR      r2,|L33.180|
000028  7191              STRB     r1,[r2,#6]
;;;2622   	mUsbIntF1INDis();
00002a  f8d03138          LDR      r3,[r0,#0x138]
00002e  f4433300          ORR      r3,r3,#0x20000
000032  f8c03138          STR      r3,[r0,#0x138]
;;;2623   #endif
;;;2624   
;;;2625   #ifdef ADD_PEN
;;;2626   	mUsbEXDmaAbort(PEN_FIFO_IN);
;;;2627   	mUsbEXDmaStop(PEN_FIFO_IN);
;;;2628   
;;;2629   	//g_ScanTime_Pen = 0;
;;;2630   	//g_StartTime_Pen = 0;
;;;2631   	g_CheckVDMAComplete_Pen = DMA_READY;
;;;2632   	mUsbIntF3INDis();
;;;2633   #endif
;;;2634   
;;;2635   #ifdef ADD_CUSTOM
;;;2636   	// Custom IN
;;;2637   	mUsbEXDmaAbort(CUSTOM_FIFO_IN);
000036  f8d03308          LDR      r3,[r0,#0x308]
00003a  f0430308          ORR      r3,r3,#8
00003e  f8c03308          STR      r3,[r0,#0x308]
;;;2638   	mUsbEXDmaStop(CUSTOM_FIFO_IN);
000042  f8d03308          LDR      r3,[r0,#0x308]
000046  f0230301          BIC      r3,r3,#1
00004a  f8c03308          STR      r3,[r0,#0x308]
;;;2639   
;;;2640   	g_CheckVDMAComplete_Custom = DMA_READY;
00004e  7251              STRB     r1,[r2,#9]
;;;2641   	mUsbIntF0INDis();
000050  f8d01138          LDR      r1,[r0,#0x138]
000054  f4413180          ORR      r1,r1,#0x10000
000058  f8c01138          STR      r1,[r0,#0x138]
00005c  2108              MOVS     r1,#8
00005e  f8c01328          STR      r1,[r0,#0x328]
000062  f8d0132c          LDR      r1,[r0,#0x32c]
000066  f4412100          ORR      r1,r1,#0x80000
00006a  f8c0132c          STR      r1,[r0,#0x32c]
00006e  f8d0132c          LDR      r1,[r0,#0x32c]
000072  f0410108          ORR      r1,r1,#8
000076  f8c0132c          STR      r1,[r0,#0x32c]
00007a  f8d0132c          LDR      r1,[r0,#0x32c]
00007e  f4212100          BIC      r1,r1,#0x80000
000082  f8c0132c          STR      r1,[r0,#0x32c]
000086  f8d0132c          LDR      r1,[r0,#0x32c]
00008a  f0210108          BIC      r1,r1,#8
00008e  f8c0132c          STR      r1,[r0,#0x32c]
000092  f44f4180          MOV      r1,#0x4000
000096  f8c01318          STR      r1,[r0,#0x318]
00009a  4907              LDR      r1,|L33.184|
00009c  f8c0131c          STR      r1,[r0,#0x31c]
0000a0  f8d01318          LDR      r1,[r0,#0x318]
0000a4  f0410101          ORR      r1,r1,#1
0000a8  f8c01318          STR      r1,[r0,#0x318]
;;;2642   
;;;2643   	// Custom OUT
;;;2644   	RecieveCustomData_DMA();
;;;2645   #endif
;;;2646   
;;;2647   #ifdef ADD_BULK_CUSTOM
;;;2648   	// Bulk Custom IN
;;;2649   	mUsbEXDmaAbort(BULK_CUSTOM_FIFO_IN);
;;;2650   	mUsbEXDmaStop(BULK_CUSTOM_FIFO_IN);
;;;2651   
;;;2652   	g_CheckVDMAComplete_BulkCustom = DMA_READY;
;;;2653   	mUsbIntF0INDis();
;;;2654   
;;;2655   	// Bulk Custom OUT
;;;2656   	RecieveBulkCustomData_DMA();
;;;2657   #endif
;;;2658   
;;;2659   	return;
;;;2660   }
0000ac  4770              BX       lr
;;;2661   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L33.176|
                          DCD      0x20100000
                  |L33.180|
                          DCD      ||.data||
                  |L33.184|
                          DCD      ||.bss||+0xc9c

                          AREA ||i.protocol_hid_PushPenEvent||, CODE, READONLY, ALIGN=2

                  protocol_hid_PushPenEvent PROC
;;;1008   
;;;1009   void protocol_hid_PushPenEvent(const uSWIPTouchItem_t* _kptItem)
000000  490b              LDR      r1,|L34.48|
;;;1010   {
;;;1011   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1012   	HID_PEN_STATUS = (_kptItem->tItem00.tInfo.b1Status & 0x01);
;;;1013   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1014   	HID_PEN_STATUS = sptAlgorithmInfo->bLocal_sensing | (sptAlgorithmInfo->tPenInfo.bPenContact<<1);
000002  6e4a              LDR      r2,[r1,#0x64]  ; sptAlgorithmInfo
000004  f8923fb8          LDRB     r3,[r2,#0xfb8]
000008  f8922fbf          LDRB     r2,[r2,#0xfbf]
00000c  ea430242          ORR      r2,r3,r2,LSL #1
;;;1015   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1016   	HID_PEN_X = _kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow;
000010  654a              STR      r2,[r1,#0x54]  ; HID_PEN_STATUS
000012  78c2              LDRB     r2,[r0,#3]
000014  7843              LDRB     r3,[r0,#1]
000016  ea422203          ORR      r2,r2,r3,LSL #8
;;;1017   	HID_PEN_Y = _kptItem->tItem00.ucYHigh << 8 | _kptItem->tItem00.ucYLow;
00001a  64ca              STR      r2,[r1,#0x4c]  ; HID_PEN_X
00001c  7902              LDRB     r2,[r0,#4]
00001e  7880              LDRB     r0,[r0,#2]
000020  ea422000          ORR      r0,r2,r0,LSL #8
;;;1018   
;;;1019   	g_PenEventNum++;
000024  6508              STR      r0,[r1,#0x50]  ; HID_PEN_Y
000026  7a88              LDRB     r0,[r1,#0xa]  ; g_PenEventNum
000028  1c40              ADDS     r0,r0,#1
00002a  7288              STRB     r0,[r1,#0xa]
;;;1020   }
00002c  4770              BX       lr
;;;1021   
                          ENDP

00002e  0000              DCW      0x0000
                  |L34.48|
                          DCD      ||.data||

                          AREA ||i.protocol_hid_PushTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_hid_PushTouchEvent PROC
;;;981    
;;;982    void protocol_hid_PushTouchEvent(const uSWIPTouchItem_t* _kptItem)
000000  4914              LDR      r1,|L35.84|
;;;983    {
;;;984    	if (hid_index < HID_MAX_TOUCH)
000002  6e8a              LDR      r2,[r1,#0x68]  ; hid_index
000004  2a0a              CMP      r2,#0xa
;;;985    	{
;;;986    #if USED_SHARP_SPECIFIC_PROTOCOL
;;;987    		HID_status[hid_index] = (_kptItem->tItem00.tInfo.b1Status & 0x01);
;;;988    #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;989    		HID_status[hid_index] = _kptItem->tItem00.tInfo.bTouch;
;;;990    #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;991    		HID_id[hid_index] = _kptItem->tItem00.tInfo.b4FingerID;;
;;;992    #if USED_POOR_PANEL_COLLINE_DISABLE
;;;993    		uint32_t ulTempXPos;
;;;994    		ulTempXPos = ((uint32_t)((_kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow) * 10145))/10000;
;;;995    		if(ulTempXPos > I2C_X_RESOLUTION)
;;;996    			ulTempXPos = I2C_X_RESOLUTION;
;;;997    		HID_x[hid_index] = ulTempXPos;
;;;998    #else /* USED_POOR_PANEL_COLLINE_DISABLE */
;;;999    		HID_x[hid_index] = _kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow;
;;;1000   #endif /* USED_POOR_PANEL_COLLINE_DISABLE */
;;;1001   		HID_y[hid_index] = _kptItem->tItem00.ucYHigh << 8 | _kptItem->tItem00.ucYLow;
;;;1002   
;;;1003   		hid_index++;
;;;1004   	}
;;;1005   }
000006  bfa8              IT       GE
000008  4770              BXGE     lr
00000a  7802              LDRB     r2,[r0,#0]            ;989
00000c  f8d1c068          LDR      r12,[r1,#0x68]        ;989  ; hid_index
000010  09d2              LSRS     r2,r2,#7              ;989
000012  4b11              LDR      r3,|L35.88|
000014  f843202c          STR      r2,[r3,r12,LSL #2]    ;989
000018  7802              LDRB     r2,[r0,#0]            ;991
00001a  f8d1c068          LDR      r12,[r1,#0x68]        ;991  ; hid_index
00001e  f002020f          AND      r2,r2,#0xf            ;991
000022  3b78              SUBS     r3,r3,#0x78           ;991
000024  f843202c          STR      r2,[r3,r12,LSL #2]    ;991
000028  78c2              LDRB     r2,[r0,#3]            ;999
00002a  7843              LDRB     r3,[r0,#1]            ;999
00002c  f8d1c068          LDR      r12,[r1,#0x68]        ;999  ; hid_index
000030  ea422203          ORR      r2,r2,r3,LSL #8       ;999
000034  4b09              LDR      r3,|L35.92|
000036  f843202c          STR      r2,[r3,r12,LSL #2]    ;999
00003a  7902              LDRB     r2,[r0,#4]            ;1001
00003c  7880              LDRB     r0,[r0,#2]            ;1001
00003e  ea422000          ORR      r0,r2,r0,LSL #8       ;1001
000042  f1030228          ADD      r2,r3,#0x28           ;1001
000046  6e8b              LDR      r3,[r1,#0x68]         ;1001  ; hid_index
000048  f8420023          STR      r0,[r2,r3,LSL #2]     ;1001
00004c  6e88              LDR      r0,[r1,#0x68]         ;1003  ; hid_index
00004e  1c40              ADDS     r0,r0,#1              ;1003
000050  6688              STR      r0,[r1,#0x68]         ;1003  ; hid_index
000052  4770              BX       lr
;;;1006   
                          ENDP

                  |L35.84|
                          DCD      ||.data||
                  |L35.88|
                          DCD      ||.bss||+0x1e0
                  |L35.92|
                          DCD      ||.bss||+0x190

                          AREA ||i.protocol_hid_mapping_emul_handler||, CODE, READONLY, ALIGN=2

                  protocol_hid_mapping_emul_handler PROC
;;;828    
;;;829    uint8_t protocol_hid_mapping_emul_handler(uint8_t ucType, uint16_t nTransCnt, uint16_t state, uint8_t InData)
000000  b570              PUSH     {r4-r6,lr}
;;;830    {
;;;831    	uint8_t OutData = 0x00;
000002  2500              MOVS     r5,#0
;;;832    	switch (ucType)
000004  2801              CMP      r0,#1
000006  bf18              IT       NE
000008  2802              CMPNE    r0,#2
00000a  d03d              BEQ      |L36.136|
00000c  2803              CMP      r0,#3
00000e  d13b              BNE      |L36.136|
;;;833    	{
;;;834    	case I2C_SLAVE_INTERRUPT_STATUS_START:
;;;835    		break;
;;;836    	case I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER:
;;;837    		if (state & (I2C_SLAVE_FSM_STATUS_WRITE_ACK))
;;;838    		{
;;;839    			if (nTransCnt == 1)
;;;840    			{
;;;841    				usRegAddr = InData;
000010  4c1e              LDR      r4,|L36.140|
000012  f4125f80          TST      r2,#0x1000            ;837
000016  d023              BEQ      |L36.96|
000018  2901              CMP      r1,#1                 ;839
00001a  d00c              BEQ      |L36.54|
;;;842    				usRegAddr <<= 8;
;;;843    			}
;;;844    			else if (nTransCnt == 2)
00001c  2902              CMP      r1,#2
00001e  d012              BEQ      |L36.70|
;;;845    			{
;;;846    				usRegAddr |= InData;
;;;847    				if (protocol_GetMappedPointer != NULL)
;;;848    				{
;;;849    					rmi_read_ptr = rmi_write_ptr = (*protocol_GetMappedPointer)(usRegAddr);
;;;850    					usb_sent_byte = usb_received_byte = 0;
;;;851    				}
;;;852    			}
;;;853    			else if (nTransCnt > 2)
000020  d932              BLS      |L36.136|
;;;854    			{
;;;855    				if (rmi_write_ptr != NULL)
000022  6e21              LDR      r1,[r4,#0x60]  ; rmi_write_ptr
000024  2900              CMP      r1,#0
000026  d02f              BEQ      |L36.136|
;;;856    				{
;;;857    					*(rmi_write_ptr++) = InData;
000028  f8013b01          STRB     r3,[r1],#1
;;;858    					usb_received_byte++;
00002c  6621              STR      r1,[r4,#0x60]  ; rmi_write_ptr
00002e  8ae0              LDRH     r0,[r4,#0x16]  ; usb_received_byte
000030  1c40              ADDS     r0,r0,#1
000032  82e0              STRH     r0,[r4,#0x16]
000034  e028              B        |L36.136|
                  |L36.54|
000036  8263              STRH     r3,[r4,#0x12]         ;841
000038  8a60              LDRH     r0,[r4,#0x12]         ;842  ; usRegAddr
00003a  f64f71ff          MOV      r1,#0xffff            ;842
00003e  ea012000          AND      r0,r1,r0,LSL #8       ;842
000042  8260              STRH     r0,[r4,#0x12]         ;842
000044  e020              B        |L36.136|
                  |L36.70|
000046  8a60              LDRH     r0,[r4,#0x12]         ;846  ; usRegAddr
000048  4318              ORRS     r0,r0,r3              ;846
00004a  8260              STRH     r0,[r4,#0x12]         ;846
00004c  4810              LDR      r0,|L36.144|
00004e  6801              LDR      r1,[r0,#0]            ;847  ; protocol_GetMappedPointer
000050  b1d1              CBZ      r1,|L36.136|
000052  8a60              LDRH     r0,[r4,#0x12]         ;849  ; usRegAddr
000054  4788              BLX      r1                    ;849
000056  6620              STR      r0,[r4,#0x60]         ;849  ; rmi_write_ptr
000058  65e0              STR      r0,[r4,#0x5c]         ;850  ; rmi_read_ptr
00005a  2000              MOVS     r0,#0                 ;850
00005c  82e0              STRH     r0,[r4,#0x16]         ;850
00005e  e012              B        |L36.134|
                  |L36.96|
;;;859    				}
;;;860    			}
;;;861    		}
;;;862    		else if (state & (I2C_SLAVE_FSM_STATUS_READ_WAIT | I2C_SLAVE_FSM_STATUS_READ_END))
000060  f4126fa0          TST      r2,#0x500
;;;863    		{
;;;864    			if (rmi_read_ptr)
000064  bf1c              ITT      NE
000066  6de1              LDRNE    r1,[r4,#0x5c]  ; rmi_read_ptr
000068  2900              CMPNE    r1,#0
00006a  d00d              BEQ      |L36.136|
;;;865    			{
;;;866    				OutData = *(rmi_read_ptr++);
00006c  f8115b01          LDRB     r5,[r1],#1
;;;867    				if (protocol_ClearInterrupt != NULL)
000070  4808              LDR      r0,|L36.148|
000072  65e1              STR      r1,[r4,#0x5c]  ; rmi_read_ptr
000074  6801              LDR      r1,[r0,#0]  ; protocol_ClearInterrupt
000076  b121              CBZ      r1,|L36.130|
;;;868    				{
;;;869    					(*protocol_ClearInterrupt)(usRegAddr + usb_sent_byte);
000078  8a60              LDRH     r0,[r4,#0x12]  ; usRegAddr
00007a  8aa2              LDRH     r2,[r4,#0x14]  ; usb_sent_byte
00007c  4410              ADD      r0,r0,r2
00007e  b280              UXTH     r0,r0
000080  4788              BLX      r1
                  |L36.130|
;;;870    				}
;;;871    				usb_sent_byte++;
000082  8aa0              LDRH     r0,[r4,#0x14]  ; usb_sent_byte
000084  1c40              ADDS     r0,r0,#1
                  |L36.134|
000086  82a0              STRH     r0,[r4,#0x14]
                  |L36.136|
;;;872    			}
;;;873    		}
;;;874    		break;
;;;875    	case I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH:
;;;876    		break;
;;;877    	case I2C_SLAVE_INTERRUPT_STATUS_STOP:
;;;878    		break;
;;;879    	default:
;;;880    		break;
;;;881    	}
;;;882    
;;;883    	return OutData;
000088  4628              MOV      r0,r5
;;;884    }
00008a  bd70              POP      {r4-r6,pc}
;;;885    
                          ENDP

                  |L36.140|
                          DCD      ||.data||
                  |L36.144|
                          DCD      protocol_GetMappedPointer
                  |L36.148|
                          DCD      protocol_ClearInterrupt

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Status
                          %        18
                  g_IdleDuration
                          %        255
                  g_HID_Descriptor
                          %        9
                  g_Touch
                          %        66
                  g_TouchTip
                          %        12
                  HID_id
                          %        40
                  HID_x
                          %        40
                  HID_y
                          %        40
                  HID_status
                          %        40
                  g_Queue_Common
                          %        1991
                  u8_HID_MultiTouchReportDesc_Temp
                          %        717
                  g_CustomBuffer
                          %        64
                  g_BulkCustomBuffer
                          %        66

                          AREA ||.data||, DATA, ALIGN=3

                  g_Configuration
000000  00                DCB      0x00
                  g_HIDReady
000001  00                DCB      0x00
                  g_CXF_Done
000002  00                DCB      0x00
                  g_RemoteWakeup
000003  00                DCB      0x00
                  g_SuspendOn
000004  00                DCB      0x00
                  g_EP0_Check
000005  00                DCB      0x00
                  g_CheckVDMAComplete_Touch
000006  01                DCB      0x01
                  ResumeCnt
000007  00                DCB      0x00
                  Recovery_ClearSus_Flag
000008  00                DCB      0x00
                  g_CheckVDMAComplete_Custom
000009  01                DCB      0x01
                  g_PenEventNum
00000a  0000              DCB      0x00,0x00
                  g_EP0_BufferLength
00000c  0000              DCW      0x0000
                  g_LatencyMode
00000e  0000              DCB      0x00,0x00
                  g_MaxTouchCount
000010  0000              DCB      0x00,0x00
                  usRegAddr
000012  0000              DCW      0x0000
                  usb_sent_byte
000014  0000              DCW      0x0000
                  usb_received_byte
000016  0000              DCW      0x0000
                  g_DeviceMode
000018  00000000          DCB      0x00,0x00,0x00,0x00
                  g_pSetupPacket
                          DCD      g_EP0_Packet
                  g_EP0_BufferAddr
                          DCD      0x00000000
                  g_EP0_Offset
                          DCD      0x00000000
                  g_EP0_Remain
                          DCD      0x00000000
                  g_IntGroup
                          DCD      0x00000000
                  g_IntControl
                          DCD      0x00000000
                  g_IntVDMA
                          DCD      0x00000000
                  g_IntEP0
                          DCD      0x00000000
                  g_IntEP
                          DCD      0x00000000
                  g_ScanTime
                          DCD      0x00000000
                  g_ScanTime_Recovery
                          DCD      0x00000000
                  g_ScanTime_Recovery_ClearSus
                          DCD      0x00000000
                  HID_PEN_X
                          DCD      0x00000000
                  HID_PEN_Y
                          DCD      0x00000000
                  HID_PEN_STATUS
                          DCD      0x00000000
                  g_Full
                          DCD      0x00000000
                  rmi_read_ptr
                          DCD      0x00000000
                  rmi_write_ptr
                          DCD      0x00000000
                  sptAlgorithmInfo
                          DCD      0x00000000
                  hid_index
                          DCD      0x00000000
                  g_EP0_Packet
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                  g_StartTime
000078  00000000          DCQ      0x0000000000000000
00007c  00000000
                  g_StartTime_Recovery
000080  00000000          DCQ      0x0000000000000000
000084  00000000
                  g_StartTime_Recovery_ClearSus
000088  00000000          DCQ      0x0000000000000000
00008c  00000000

                          AREA ||area_number.41||, DATA, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.data||
                  g_EP0_BufferAddr_Free
                          DCD      0x00000000

                          AREA ||area_number.42||, DATA, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.data||
                  g_CheckVDMAComplete_Pen
000000  01                DCB      0x01

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  g_CheckVDMAComplete_BulkCustom
000000  01                DCB      0x01

                          AREA ||area_number.44||, DATA, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.data||
                  i2c_sent_byte
                          DCD      0x00000000

                          AREA ||area_number.45||, DATA, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.data||
                  i2c_received_byte
                          DCD      0x00000000

                          AREA ||i.__ARM_common_memclr4_8||, COMGROUP=__ARM_common_memclr4_8, CODE, READONLY, ALIGN=1

                  __ARM_common_memclr4_8 PROC
000000  2100              MOVS     r1,#0
000002  6001              STR      r1,[r0,#0]
000004  6041              STR      r1,[r0,#4]
000006  4770              BX       lr
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\usb\\FWOTG210_F000\\Pe_usb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___8_Pe_usb_c_669b9ed5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____REVSH|
#line 402
|__asm___8_Pe_usb_c_669b9ed5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____RRX|
#line 587
|__asm___8_Pe_usb_c_669b9ed5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
