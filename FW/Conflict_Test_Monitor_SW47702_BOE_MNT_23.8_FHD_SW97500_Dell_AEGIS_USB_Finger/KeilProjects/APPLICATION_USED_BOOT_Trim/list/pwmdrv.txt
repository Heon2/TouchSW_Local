; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\pwmdrv.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\pwmdrv.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\pwmdrv.crf ..\..\Hal\pwmdrv\pwmdrv.c]
                          THUMB

                          AREA ||i.PWMDRV_Cmd||, CODE, READONLY, ALIGN=2

                  PWMDRV_Cmd PROC
;;;1493   
;;;1494   void PWMDRV_Cmd(FunctionalState _NewState)
000000  4905              LDR      r1,|L1.24|
;;;1495   {
;;;1496   	PWMDRV->PWMGEN_CR0.tBit.pwm_gen_enable = _NewState;
000002  680a              LDR      r2,[r1,#0]
000004  f3600200          BFI      r2,r0,#0,#1
000008  600a              STR      r2,[r1,#0]
;;;1497   //	if(_NewState == ENABLE)
;;;1498   //	{
;;;1499   //		SCRB->SYS_RST_CTL.tBit.pwm_rst = 0;
;;;1500   //	}
;;;1501   //	else
;;;1502   //	{
;;;1503   //		SCRB->SYS_RST_CTL.tBit.pwm_rst = 1;
;;;1504   //	}
;;;1505   	PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = _NewState;
00000a  f8d120c0          LDR      r2,[r1,#0xc0]
00000e  f3600200          BFI      r2,r0,#0,#1
000012  f8c120c0          STR      r2,[r1,#0xc0]
;;;1506   
;;;1507   //	PWMDRV->PWMGEN_CR0.tBit.pwm_gen_enable = _NewState;
;;;1508   //	if(_NewState == DISABLE)
;;;1509   //	{
;;;1510   //		PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = DISABLE;
;;;1511   //	}
;;;1512   }
000016  4770              BX       lr
;;;1513   
                          ENDP

                  |L1.24|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_GPIO_Init||, CODE, READONLY, ALIGN=1

                  PWMDRV_GPIO_Init PROC
;;;1423   
;;;1424   void PWMDRV_GPIO_Init(eSENSING_MODE_t _eSensingMode)
000000  b510              PUSH     {r4,lr}
;;;1425   {
;;;1426   	// I/O COnfiguration
;;;1427   #if USED_OPERATION_STAND_ALONE
;;;1428   	GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_0, GPIO_DIR_OUTPUT, GPIO_DATA_NONE);
;;;1429   	GPIO_Init(GPIO_TSYNC_IN, GPIO_MODE_FUNC_0, GPIO_DIR_OUTPUT, GPIO_DATA_NONE);
;;;1430   #if USED_TSYNC2_INPUT_FROM_TCON
;;;1431   	GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_NONE);
;;;1432   #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;1433   #else /* USED_OPERATION_STAND_ALONE */
;;;1434   
;;;1435   	if(IS_S3_MODE(_eSensingMode))
000002  f4106f00          TST      r0,#0x800
;;;1436   	{
;;;1437   		GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1438   		GPIO_Init(_GPIO_TSYNC_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1439   #if USED_TSYNC2_INPUT_FROM_TCON
;;;1440   		GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1441   #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;1442   	}
;;;1443   	else
;;;1444   	{
;;;1445   #if USED_TOUCH_TUNING_PROCESS
;;;1446   		GPIO_Set_Mode(_GPIO_VSYNC, GPIO_MODE_FUNC_0); // Used VSync Interrupt
;;;1447   #else /* USED_TOUCH_TUNING_PROCESS */
;;;1448   		GPIO_Init(_GPIO_VSYNC, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
000006  f04f0302          MOV      r3,#2
00000a  f04f0201          MOV      r2,#1
00000e  f04f0103          MOV      r1,#3
000012  f04f002d          MOV      r0,#0x2d
000016  d008              BEQ      |L2.42|
000018  f7fffffe          BL       GPIO_Init
00001c  2302              MOVS     r3,#2                 ;1438
00001e  2201              MOVS     r2,#1                 ;1438
000020  2103              MOVS     r1,#3                 ;1438
000022  202e              MOVS     r0,#0x2e              ;1438
000024  f7fffffe          BL       GPIO_Init
000028  e005              B        |L2.54|
                  |L2.42|
00002a  f7fffffe          BL       GPIO_Init
;;;1449   #endif /* USED_TOUCH_TUNING_PROCESS */
;;;1450   		GPIO_Set_Mode(_GPIO_TSYNC_IN, GPIO_MODE_FUNC_0);
00002e  2100              MOVS     r1,#0
000030  202e              MOVS     r0,#0x2e
000032  f7fffffe          BL       GPIO_Set_Mode
                  |L2.54|
;;;1451   #if USED_TSYNC2_INPUT_FROM_TCON
;;;1452   		GPIO_Init(_GPIO_TSYNC_2_IN, GPIO_MODE_FUNC_3, GPIO_DIR_INPUT, GPIO_DATA_NONE);
;;;1453   #endif /* USED_TSYNC2_INPUT_FROM_TCON */
;;;1454   	}
;;;1455   #endif /* USED_OPERATION_STAND_ALONE */
;;;1456   
;;;1457   	GPIO_Set_Mode(_GPIO_PWM_SRIC, GPIO_MODE_FUNC_0); // PWM_TX
000036  2100              MOVS     r1,#0
000038  202f              MOVS     r0,#0x2f
00003a  f7fffffe          BL       GPIO_Set_Mode
;;;1458   	GPIO_Set_Mode(_GPIO_PWM_TPIC, GPIO_MODE_FUNC_0); // PWM_DATA (PWM_LFD)
00003e  2100              MOVS     r1,#0
000040  2030              MOVS     r0,#0x30
000042  f7fffffe          BL       GPIO_Set_Mode
;;;1459   #if USED_PWM_GATE_CONTROL
;;;1460   	GPIO_Set_Mode(_GPIO_PWM_GATE, GPIO_MODE_FUNC_1); // PWM_DATA (PWM_LFD)
000046  2101              MOVS     r1,#1
000048  2029              MOVS     r0,#0x29
00004a  f7fffffe          BL       GPIO_Set_Mode
;;;1461   #endif /* USED_PWM_GATE_CONTROL */
;;;1462   
;;;1463   	GPIO_Set_DS(_GPIO_PWM_SRIC, GPIO_DRIVE_STR_20mA);
00004e  2103              MOVS     r1,#3
000050  202f              MOVS     r0,#0x2f
000052  f7fffffe          BL       GPIO_Set_DS
;;;1464   	GPIO_Set_DS(_GPIO_PWM_TPIC, GPIO_DRIVE_STR_20mA);
000056  2103              MOVS     r1,#3
000058  2030              MOVS     r0,#0x30
00005a  f7fffffe          BL       GPIO_Set_DS
;;;1465   #if USED_PWM_GATE_CONTROL
;;;1466   	GPIO_Set_DS(_GPIO_PWM_GATE, GPIO_DRIVE_STR_20mA);
00005e  2103              MOVS     r1,#3
000060  2029              MOVS     r0,#0x29
000062  f7fffffe          BL       GPIO_Set_DS
;;;1467   #endif /* USED_PWM_GATE_CONTROL */
;;;1468   
;;;1469   	GPIO_Set_Mode(_GPIO_TSYNC_OUT, GPIO_MODE_FUNC_0); // TSYNCN_OUT
000066  2100              MOVS     r1,#0
000068  2032              MOVS     r0,#0x32
00006a  f7fffffe          BL       GPIO_Set_Mode
;;;1470   	GPIO_Set_DS(_GPIO_TSYNC_OUT, GPIO_DRIVE_STR_20mA);
00006e  2103              MOVS     r1,#3
000070  2032              MOVS     r0,#0x32
000072  f7fffffe          BL       GPIO_Set_DS
;;;1471   
;;;1472   #if (USED_MODULE_DEF == MODULE_DEF_B_1)
;;;1473   #if USED_REVISION_PINMAP
;;;1474   #if (USED_REVISION_PINMAP_2)
;;;1475   	GPIO_Set_Mode(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_0);
;;;1476   	GPIO_Set_DS(_GPIO_TSYNC_TMIC, GPIO_DRIVE_STR_20mA);
;;;1477   #endif /* (USED_REVISION_PINMAP_2 */
;;;1478   #else  /* USED_REVISION_PINMAP */
;;;1479   #if USED_TSYNC_TMIC_GPIO_CONTROL
;;;1480   	GPIO_Init(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_3, GPIO_DIR_OUTPUT, GPIO_DATA_HIGH);
;;;1481   #else  /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;1482   	GPIO_Set_Mode(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_0);
000076  2100              MOVS     r1,#0
000078  2033              MOVS     r0,#0x33
00007a  f7fffffe          BL       GPIO_Set_Mode
;;;1483   	GPIO_Set_DS(_GPIO_TSYNC_TMIC, GPIO_DRIVE_STR_20mA);
00007e  2103              MOVS     r1,#3
000080  e8bd4010          POP      {r4,lr}
000084  2033              MOVS     r0,#0x33
000086  f7ffbffe          B.W      GPIO_Set_DS
;;;1484   #endif /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;1485   #endif /* USED_REVISION_PINMAP */
;;;1486   #elif (USED_MODULE_DEF == MODULE_DEF_S_1)
;;;1487   #if (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01)
;;;1488   	GPIO_Set_Mode(_GPIO_TSYNC_TMIC, GPIO_MODE_FUNC_0);
;;;1489   	GPIO_Set_DS(_GPIO_TSYNC_TMIC, GPIO_DRIVE_STR_20mA);
;;;1490   #endif /* (USED_PCB_PINMAP == SHARP_NBPC_PIN_TYPE_S01) */
;;;1491   #endif /* (USED_MODULE_DEF == MODULE_DEF_B_1) */
;;;1492   }
;;;1493   
                          ENDP


                          AREA ||i.PWMDRV_ITConfig||, CODE, READONLY, ALIGN=1

                  PWMDRV_ITConfig PROC
;;;1513   
;;;1514   void PWMDRV_ITConfig(tPWM_INTR_CFG_t * pIntrCfg, uint32_t ulNum)
000000  2300              MOVS     r3,#0
;;;1515   {
;;;1516   	uint32_t ulIdx;
;;;1517   
;;;1518   	for(ulIdx = 0; ulIdx < ulNum; ulIdx++)
000002  2900              CMP      r1,#0
;;;1519   	{
;;;1520   		NVIC_ClearPendingIRQ(pIntrCfg[ulIdx].PWM_IRQ_TYPE);
;;;1521   		NVIC_SetPriority(pIntrCfg[ulIdx].PWM_IRQ_TYPE, pIntrCfg[ulIdx].ulIRQ_Priority);
;;;1522   		if(pIntrCfg[ulIdx].newState != DISABLE)
;;;1523   		{
;;;1524   			NVIC_EnableIRQ(pIntrCfg[ulIdx].PWM_IRQ_TYPE);
;;;1525   		}
;;;1526   		else
;;;1527   		{
;;;1528   			NVIC_DisableIRQ(pIntrCfg[ulIdx].PWM_IRQ_TYPE);
;;;1529   		}
;;;1530   	}
;;;1531   }
000004  bf98              IT       LS
000006  4770              BXLS     lr
000008  b430              PUSH     {r4,r5}               ;1515
00000a  2401              MOVS     r4,#1                 ;1515
                  |L3.12|
00000c  eb030243          ADD      r2,r3,r3,LSL #1       ;1520
000010  eb000282          ADD      r2,r0,r2,LSL #2       ;1520
000014  f992c000          LDRSB    r12,[r2,#0]           ;1520
000018  f00c051f          AND      r5,r12,#0x1f          ;1520
00001c  ea4f1c5c          LSR      r12,r12,#5            ;1520
000020  ea4f0c8c          LSL      r12,r12,#2            ;1520
000024  f10c2ce0          ADD      r12,r12,#0xe000e000   ;1520
000028  fa04f505          LSL      r5,r4,r5              ;1520
00002c  f8cc5280          STR      r5,[r12,#0x280]       ;1520
000030  f992c000          LDRSB    r12,[r2,#0]           ;1521
000034  6855              LDR      r5,[r2,#4]            ;1521
000036  f1bc0f00          CMP      r12,#0                ;1521
00003a  ea4f1545          LSL      r5,r5,#5              ;1521
00003e  bfb8              IT       LT                    ;1521
000040  f00c0c0f          ANDLT    r12,r12,#0xf          ;1521
000044  f10c2ce0          ADD      r12,r12,#0xe000e000   ;1521
000048  bfb4              ITE      LT                    ;1521
00004a  f88c5d14          STRBLT   r5,[r12,#0xd14]       ;1521
00004e  f88c5400          STRBGE   r5,[r12,#0x400]       ;1521
000052  f892c008          LDRB     r12,[r2,#8]           ;1522
000056  f9922000          LDRSB    r2,[r2,#0]            ;1528
00005a  f1bc0f00          CMP      r12,#0                ;1522
00005e  f0020c1f          AND      r12,r2,#0x1f          ;1522
000062  ea4f1252          LSR      r2,r2,#5              ;1522
000066  ea4f0282          LSL      r2,r2,#2              ;1522
00006a  fa04fc0c          LSL      r12,r4,r12            ;1522
00006e  f10222e0          ADD      r2,r2,#0xe000e000     ;1522
000072  bf14              ITE      NE                    ;1522
000074  f8c2c100          STRNE    r12,[r2,#0x100]       ;1522
000078  f8c2c180          STREQ    r12,[r2,#0x180]       ;1522
00007c  1c5b              ADDS     r3,r3,#1              ;1522
00007e  428b              CMP      r3,r1                 ;1518
000080  d3c4              BCC      |L3.12|
000082  bc30              POP      {r4,r5}
000084  4770              BX       lr
;;;1532   
                          ENDP


                          AREA ||i.PWMDRV_Init||, CODE, READONLY, ALIGN=2

                  PWMDRV_Init PROC
;;;882    
;;;883    void PWMDRV_Init(eSENSING_MODE_t _eSensingMode)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885    	Fncp_VSYNC_IN_IRQHandler = &PWMDRV_VSync_In_InterruptHandler;
000002  4964              LDR      r1,|L4.404|
000004  4604              MOV      r4,r0                 ;884
000006  b08c              SUB      sp,sp,#0x30           ;884
000008  4861              LDR      r0,|L4.400|
;;;886    	Fncp_TSYNC_IN_IRQHandler = &PWMDRV_TSync_In_InterruptHandler;
00000a  6008              STR      r0,[r1,#0]  ; Fncp_VSYNC_IN_IRQHandler
00000c  4963              LDR      r1,|L4.412|
00000e  4862              LDR      r0,|L4.408|
;;;887    	Fncp_TSYNC_OUT_IRQHandler = &PWMDRV_TSync_Out_InterruptHandler;
000010  6008              STR      r0,[r1,#0]  ; Fncp_TSYNC_IN_IRQHandler
000012  4964              LDR      r1,|L4.420|
000014  4862              LDR      r0,|L4.416|
;;;888    	Fncp_PWMDRV_IRQHandler = &PWMDRV_PWM_Out_InterruptHandler;
000016  6008              STR      r0,[r1,#0]  ; Fncp_TSYNC_OUT_IRQHandler
000018  4964              LDR      r1,|L4.428|
00001a  4863              LDR      r0,|L4.424|
;;;889    
;;;890    	PWMDRV_RegisterInit(_eSensingMode);
00001c  6008              STR      r0,[r1,#0]  ; Fncp_PWMDRV_IRQHandler
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       PWMDRV_RegisterInit
000024  f4146f00          TST      r4,#0x800
000028  f04f0302          MOV      r3,#2
00002c  f04f0201          MOV      r2,#1
000030  f04f0103          MOV      r1,#3
000034  f04f002d          MOV      r0,#0x2d
000038  d008              BEQ      |L4.76|
00003a  f7fffffe          BL       GPIO_Init
00003e  2302              MOVS     r3,#2
000040  2201              MOVS     r2,#1
000042  2103              MOVS     r1,#3
000044  202e              MOVS     r0,#0x2e
000046  f7fffffe          BL       GPIO_Init
00004a  e005              B        |L4.88|
                  |L4.76|
00004c  f7fffffe          BL       GPIO_Init
000050  2100              MOVS     r1,#0
000052  202e              MOVS     r0,#0x2e
000054  f7fffffe          BL       GPIO_Set_Mode
                  |L4.88|
000058  2100              MOVS     r1,#0
00005a  202f              MOVS     r0,#0x2f
00005c  f7fffffe          BL       GPIO_Set_Mode
000060  2100              MOVS     r1,#0
000062  2030              MOVS     r0,#0x30
000064  f7fffffe          BL       GPIO_Set_Mode
000068  2101              MOVS     r1,#1
00006a  2029              MOVS     r0,#0x29
00006c  f7fffffe          BL       GPIO_Set_Mode
000070  2103              MOVS     r1,#3
000072  202f              MOVS     r0,#0x2f
000074  f7fffffe          BL       GPIO_Set_DS
000078  2103              MOVS     r1,#3
00007a  2030              MOVS     r0,#0x30
00007c  f7fffffe          BL       GPIO_Set_DS
000080  2103              MOVS     r1,#3
000082  2029              MOVS     r0,#0x29
000084  f7fffffe          BL       GPIO_Set_DS
000088  2100              MOVS     r1,#0
00008a  2032              MOVS     r0,#0x32
00008c  f7fffffe          BL       GPIO_Set_Mode
000090  2103              MOVS     r1,#3
000092  2032              MOVS     r0,#0x32
000094  f7fffffe          BL       GPIO_Set_DS
000098  2100              MOVS     r1,#0
00009a  2033              MOVS     r0,#0x33
00009c  f7fffffe          BL       GPIO_Set_Mode
0000a0  2103              MOVS     r1,#3
0000a2  2033              MOVS     r0,#0x33
0000a4  f7fffffe          BL       GPIO_Set_DS
;;;891    	PWMDRV_GPIO_Init(_eSensingMode);
;;;892    
;;;893    #if USED_MNT_S3_MODE_FUNCTION
;;;894    	if(IS_S3_MODE(_eSensingMode))
;;;895    	{
;;;896    		SCRB->PWM_INT_CTRL.tBit.int_en_pwm_ab = PWM_INTR_DISABLE;
0000a8  f04f4080          MOV      r0,#0x40000000
;;;897    		SCRB->PWM_INT_CTRL.tBit.int_en_pwm_frame = PWM_INTR_DISABLE;
;;;898    		SCRB->PWM_INT_CTRL.tBit.int_en_tsync_ab = PWM_INTR_DISABLE;
;;;899    #if (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL)
;;;900    		SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_ENABLE;
;;;901    	#if USED_PWM_PULSE_END_FLAG_CHECK
;;;902    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_BOTH_EDGE;
;;;903    	#else /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;904    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_FALLING_EDGE;
;;;905    	#endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;906    #else /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;907    		SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_DISABLE;
;;;908    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_RISING_EDGE;
;;;909    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;910    
;;;911    #if USED_TOUCH_TUNING_PROCESS
;;;912    		SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_RISING_EDGE;
;;;913    #else /* USED_TOUCH_TUNING_PROCESS */
;;;914    		SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_DISABLE;
;;;915    #endif /* USED_TOUCH_TUNING_PROCESS */
;;;916    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncin = PWM_INTR_DISABLE;
;;;917    		SCRB->PWM_INT_CTRL.tBit.int_tsyncin_src_sel = PWM_TYNCIN_INT_SOURCE_TSYNC_D;
;;;918    
;;;919    		{
;;;920    			tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
0000ac  4940              LDR      r1,|L4.432|
;;;921    			{
;;;922    				{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;923    				{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, DISABLE},
;;;924    				{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, ENABLE},
;;;925    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL)
;;;926    				{PWMDRV_IRQn, PWMDRV_IRQn_Priority, ENABLE}
;;;927    	#else /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;928    				{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;929    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL || USED_ECLK_ON_OFF_CONTROL) */
;;;930    			};
;;;931    			PWMDRV_ITConfig((tPWM_INTR_CFG_t *)&tPWM_INTR_CFG[0], 4);
;;;932    		}
;;;933    	}
;;;934    	else
;;;935    #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;936    	{
;;;937    		SCRB->PWM_INT_CTRL.tBit.int_en_pwm_ab = PWM_INTR_DISABLE;
0000ae  f8d02088          LDR      r2,[r0,#0x88]
0000b2  f4146f00          TST      r4,#0x800             ;894
0000b6  f0220201          BIC      r2,r2,#1
0000ba  f8c02088          STR      r2,[r0,#0x88]
;;;938    		SCRB->PWM_INT_CTRL.tBit.int_en_pwm_frame = PWM_INTR_DISABLE;
0000be  f8d02088          LDR      r2,[r0,#0x88]
0000c2  f0220202          BIC      r2,r2,#2
0000c6  f8c02088          STR      r2,[r0,#0x88]
;;;939    		SCRB->PWM_INT_CTRL.tBit.int_en_tsync_ab = PWM_INTR_DISABLE;
0000ca  f8d02088          LDR      r2,[r0,#0x88]
0000ce  f0220204          BIC      r2,r2,#4
0000d2  f8c02088          STR      r2,[r0,#0x88]
;;;940    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;941    		SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_ENABLE;
0000d6  f8d02088          LDR      r2,[r0,#0x88]
0000da  f4426280          ORR      r2,r2,#0x400
0000de  f8c02088          STR      r2,[r0,#0x88]
;;;942    #else /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;943    		SCRB->PWM_INT_CTRL.tBit.int_en_lhb = PWM_INTR_DISABLE;
;;;944    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;945    
;;;946    #if USED_TOUCH_TUNING_PROCESS
;;;947    		SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_RISING_EDGE;
;;;948    #else /* USED_TOUCH_TUNING_PROCESS */
;;;949    		SCRB->PWM_INT_CTRL.tBit.int_en_vsyncin = PWM_INTR_DISABLE;
0000e2  f8d02088          LDR      r2,[r0,#0x88]
0000e6  d028              BEQ      |L4.314|
0000e8  f44272c0          ORR      r2,r2,#0x180          ;902
0000ec  f8c02088          STR      r2,[r0,#0x88]         ;902
0000f0  f8d02088          LDR      r2,[r0,#0x88]         ;914
0000f4  f0220260          BIC      r2,r2,#0x60           ;914
0000f8  f8c02088          STR      r2,[r0,#0x88]         ;914
0000fc  f8d02088          LDR      r2,[r0,#0x88]         ;916
000100  f0220218          BIC      r2,r2,#0x18           ;916
000104  f8c02088          STR      r2,[r0,#0x88]         ;916
000108  f8d02088          LDR      r2,[r0,#0x88]         ;917
00010c  f4427200          ORR      r2,r2,#0x200          ;917
000110  f8c02088          STR      r2,[r0,#0x88]         ;917
000114  e8b1100d          LDM      r1!,{r0,r2,r3,r12}    ;917
000118  e88d100d          STM      sp,{r0,r2,r3,r12}     ;917
00011c  e8b1100d          LDM      r1!,{r0,r2,r3,r12}    ;917
000120  ac04              ADD      r4,sp,#0x10           ;917
000122  e884100d          STM      r4,{r0,r2,r3,r12}     ;917
000126  c90f              LDM      r1,{r0-r3}            ;917
000128  ac08              ADD      r4,sp,#0x20           ;917
00012a  e884000f          STM      r4,{r0-r3}            ;917
00012e  2104              MOVS     r1,#4                 ;931
000130  4668              MOV      r0,sp                 ;931
000132  f7fffffe          BL       PWMDRV_ITConfig
;;;950    #endif /* USED_TOUCH_TUNING_PROCESS */
;;;951    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncin = PWM_INTR_BOTH_EDGE;
;;;952    #if USED_VCF_SYNC_CONTROL
;;;953    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_BOTH_EDGE; // Rising
;;;954    #else
;;;955    		SCRB->PWM_INT_CTRL.tBit.int_en_tsyncout = PWM_INTR_DISABLE; // Rising
;;;956    #endif /* USED_VCF_SYNC_CONTROL */
;;;957    		SCRB->PWM_INT_CTRL.tBit.int_tsyncin_src_sel = PWM_TYNCIN_INT_SOURCE_TSYNC_T;
;;;958    
;;;959    		{
;;;960    	#if USED_DO_NOT_TOUCH_ONLY_DISPLAY
;;;961    			tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
;;;962    			{
;;;963    				{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;964    				{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, DISABLE},
;;;965    				{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, DISABLE},
;;;966    				{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;967    			};
;;;968    	#else /* USED_DO_NOT_TOUCH_ONLY_DISPLAY */
;;;969    			tPWM_INTR_CFG_t tPWM_INTR_CFG[4] =
;;;970    			{
;;;971    	#if USED_TOUCH_TUNING_PROCESS
;;;972    				{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, ENABLE},
;;;973    	#else /* USED_TOUCH_TUNING_PROCESS */
;;;974    				{VSYNC_IN_IRQn, VSYNC_IN_IRQn_Priority, DISABLE},
;;;975    	#endif /* USED_TOUCH_TUNING_PROCESS */
;;;976    
;;;977    				{TSYNC_IN_IRQn, TSYNC_IN_IRQn_Priority, ENABLE},
;;;978    	#if USED_VCF_SYNC_CONTROL
;;;979    				{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, ENABLE},
;;;980    	#else
;;;981    				{TSYNC_OUT_IRQn, TSYNC_OUT_IRQn_Priority, DISABLE},
;;;982    	#endif /* USED_VCF_SYNC_CONTROL */
;;;983    
;;;984    	#if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;985    				{PWMDRV_IRQn, PWMDRV_IRQn_Priority, ENABLE}
;;;986    	#else /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;987    				{PWMDRV_IRQn, PWMDRV_IRQn_Priority, DISABLE}
;;;988    	#endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;989    
;;;990    			};
;;;991    	#endif /* USED_DO_NOT_TOUCH_ONLY_DISPLAY */
;;;992    			PWMDRV_ITConfig((tPWM_INTR_CFG_t *)&tPWM_INTR_CFG[0], 4);
;;;993    		}
;;;994    	}
;;;995    }
000136  b00c              ADD      sp,sp,#0x30
000138  bd10              POP      {r4,pc}
                  |L4.314|
00013a  f0220260          BIC      r2,r2,#0x60           ;949
00013e  f8c02088          STR      r2,[r0,#0x88]         ;949
000142  f8d02088          LDR      r2,[r0,#0x88]         ;951
000146  f0420218          ORR      r2,r2,#0x18           ;951
00014a  f8c02088          STR      r2,[r0,#0x88]         ;951
00014e  f8d02088          LDR      r2,[r0,#0x88]         ;955
000152  f42272c0          BIC      r2,r2,#0x180          ;955
000156  f8c02088          STR      r2,[r0,#0x88]         ;955
00015a  f8d02088          LDR      r2,[r0,#0x88]         ;957
00015e  f4227200          BIC      r2,r2,#0x200          ;957
000162  f8c02088          STR      r2,[r0,#0x88]         ;957
000166  3130              ADDS     r1,r1,#0x30           ;957
000168  ac04              ADD      r4,sp,#0x10           ;957
00016a  e8b1100d          LDM      r1!,{r0,r2,r3,r12}    ;957
00016e  e88d100d          STM      sp,{r0,r2,r3,r12}     ;957
000172  e8b1100d          LDM      r1!,{r0,r2,r3,r12}    ;957
000176  e884100d          STM      r4,{r0,r2,r3,r12}     ;957
00017a  c90f              LDM      r1,{r0-r3}            ;957
00017c  ac08              ADD      r4,sp,#0x20           ;957
00017e  e884000f          STM      r4,{r0-r3}            ;957
000182  2104              MOVS     r1,#4                 ;992
000184  4668              MOV      r0,sp                 ;992
000186  f7fffffe          BL       PWMDRV_ITConfig
00018a  b00c              ADD      sp,sp,#0x30
00018c  bd10              POP      {r4,pc}
;;;996    
                          ENDP

00018e  0000              DCW      0x0000
                  |L4.400|
                          DCD      PWMDRV_VSync_In_InterruptHandler
                  |L4.404|
                          DCD      Fncp_VSYNC_IN_IRQHandler
                  |L4.408|
                          DCD      PWMDRV_TSync_In_InterruptHandler
                  |L4.412|
                          DCD      Fncp_TSYNC_IN_IRQHandler
                  |L4.416|
                          DCD      PWMDRV_TSync_Out_InterruptHandler
                  |L4.420|
                          DCD      Fncp_TSYNC_OUT_IRQHandler
                  |L4.424|
                          DCD      PWMDRV_PWM_Out_InterruptHandler
                  |L4.428|
                          DCD      Fncp_PWMDRV_IRQHandler
                  |L4.432|
                          DCD      ||.constdata||

                          AREA ||i.PWMDRV_LocalLHBSetting||, CODE, READONLY, ALIGN=2

                  PWMDRV_LocalLHBSetting PROC
;;;1357   
;;;1358   void PWMDRV_LocalLHBSetting(eSENSING_MODE_t _eSensingMode)
000000  b510              PUSH     {r4,lr}
;;;1359   {
000002  4604              MOV      r4,r0
;;;1360   	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000004  f7fffffe          BL       hal_pwmdrv_GetControlConfig
;;;1361   
;;;1362   #if USED_MNT_S3_MODE_FUNCTION
;;;1363   	if(IS_S3_MODE(_eSensingMode))
;;;1364   	{
;;;1365   		PWMDRV->LHB_CONFIG11.ulBulk = g_tCP_S3_LHB_CONFIG11.ulBulk;
000008  4922              LDR      r1,|L5.148|
00000a  f4146f00          TST      r4,#0x800             ;1363
00000e  d020              BEQ      |L5.82|
000010  4a21              LDR      r2,|L5.152|
000012  6812              LDR      r2,[r2,#0]  ; g_tCP_S3_LHB_CONFIG11
000014  f8c1209c          STR      r2,[r1,#0x9c]
;;;1366   		PWMDRV->LHB_CONFIG12.ulBulk = g_tCP_S3_LHB_CONFIG12.ulBulk;
000018  4a20              LDR      r2,|L5.156|
00001a  6812              LDR      r2,[r2,#0]  ; g_tCP_S3_LHB_CONFIG12
00001c  f8c120a0          STR      r2,[r1,#0xa0]
;;;1367   		PWMDRV->LHB_CONFIG13.ulBulk = g_tCP_S3_LHB_CONFIG13.ulBulk;
000020  4a1f              LDR      r2,|L5.160|
000022  6812              LDR      r2,[r2,#0]  ; g_tCP_S3_LHB_CONFIG13
000024  f8c120a4          STR      r2,[r1,#0xa4]
;;;1368   		PWMDRV->LHB_CONFIG14.ulBulk = g_tCP_S3_LHB_CONFIG14.ulBulk;
000028  4a1e              LDR      r2,|L5.164|
00002a  6812              LDR      r2,[r2,#0]  ; g_tCP_S3_LHB_CONFIG14
00002c  f8c120a8          STR      r2,[r1,#0xa8]
;;;1369   
;;;1370   		PWMDRV->LHB_CONFIG21.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG21.ulBulk;
000030  f8d02140          LDR      r2,[r0,#0x140]
000034  f8c120ac          STR      r2,[r1,#0xac]
;;;1371   		PWMDRV->LHB_CONFIG22.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG22.ulBulk;
000038  f8d02144          LDR      r2,[r0,#0x144]
00003c  f8c120b0          STR      r2,[r1,#0xb0]
;;;1372   		PWMDRV->LHB_CONFIG23.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG23.ulBulk;
000040  f8d02148          LDR      r2,[r0,#0x148]
000044  f8c120b4          STR      r2,[r1,#0xb4]
;;;1373   		PWMDRV->LHB_CONFIG24.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG24.ulBulk;
000048  f8d0014c          LDR      r0,[r0,#0x14c]
00004c  f8c100b8          STR      r0,[r1,#0xb8]
;;;1374   	}
;;;1375   	else
;;;1376   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1377   	{
;;;1378   	#if USED_IDLE_MODE_CONTROL
;;;1379   		if(IS_ACTIVE_MODE(_eSensingMode))
;;;1380   		{
;;;1381   			PWMDRV->LHB_CONFIG11.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG11.ulBulk;
;;;1382   			PWMDRV->LHB_CONFIG12.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG12.ulBulk;
;;;1383   			PWMDRV->LHB_CONFIG13.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG13.ulBulk;
;;;1384   			PWMDRV->LHB_CONFIG14.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG14.ulBulk;
;;;1385   		}
;;;1386   		else
;;;1387   		{
;;;1388   			PWMDRV->LHB_CONFIG11.ulBulk = g_tCP_LHB_CONFIG21.ulBulk;
;;;1389   			PWMDRV->LHB_CONFIG12.ulBulk = g_tCP_LHB_CONFIG22.ulBulk;
;;;1390   			PWMDRV->LHB_CONFIG13.ulBulk = g_tCP_LHB_CONFIG23.ulBulk;
;;;1391   			PWMDRV->LHB_CONFIG14.ulBulk = g_tCP_LHB_CONFIG24.ulBulk;
;;;1392   		}
;;;1393   	#else /* USED_IDLE_MODE_CONTROL */
;;;1394   		PWMDRV->LHB_CONFIG11.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG11.ulBulk;
;;;1395   		PWMDRV->LHB_CONFIG12.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG12.ulBulk;
;;;1396   		PWMDRV->LHB_CONFIG13.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG13.ulBulk;
;;;1397   		PWMDRV->LHB_CONFIG14.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG14.ulBulk;
;;;1398   	#endif /* USED_IDLE_MODE_CONTROL */
;;;1399   
;;;1400   	#if  USED_LOCAL_IDLE_MODE_CONTROL
;;;1401   		if(IS_ACTIVE_MODE(_eSensingMode))
;;;1402   		{
;;;1403   			PWMDRV->LHB_CONFIG21.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG21.ulBulk;
;;;1404   			PWMDRV->LHB_CONFIG22.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG22.ulBulk;
;;;1405   			PWMDRV->LHB_CONFIG23.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG23.ulBulk;
;;;1406   			PWMDRV->LHB_CONFIG24.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG24.ulBulk;
;;;1407   		}
;;;1408   		else
;;;1409   		{
;;;1410   			PWMDRV->LHB_CONFIG21.ulBulk = g_tCP_LHB_CONFIG21.ulBulk;
;;;1411   			PWMDRV->LHB_CONFIG22.ulBulk = g_tCP_LHB_CONFIG22.ulBulk;
;;;1412   			PWMDRV->LHB_CONFIG23.ulBulk = g_tCP_LHB_CONFIG23.ulBulk;
;;;1413   			PWMDRV->LHB_CONFIG24.ulBulk = g_tCP_LHB_CONFIG24.ulBulk;
;;;1414   		}
;;;1415   	#else /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1416   		PWMDRV->LHB_CONFIG21.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG21.ulBulk;
;;;1417   		PWMDRV->LHB_CONFIG22.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG22.ulBulk;
;;;1418   		PWMDRV->LHB_CONFIG23.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG23.ulBulk;
;;;1419   		PWMDRV->LHB_CONFIG24.ulBulk = ptHalPwmdrvControlConf->tCP_LHB_CONFIG24.ulBulk;
;;;1420   	#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1421   	}
;;;1422   }
000050  bd10              POP      {r4,pc}
                  |L5.82|
000052  f8d02130          LDR      r2,[r0,#0x130]        ;1394
000056  f8c1209c          STR      r2,[r1,#0x9c]         ;1394
00005a  f8d02134          LDR      r2,[r0,#0x134]        ;1395
00005e  f8c120a0          STR      r2,[r1,#0xa0]         ;1395
000062  f8d02138          LDR      r2,[r0,#0x138]        ;1396
000066  f8c120a4          STR      r2,[r1,#0xa4]         ;1396
00006a  f8d0213c          LDR      r2,[r0,#0x13c]        ;1397
00006e  f8c120a8          STR      r2,[r1,#0xa8]         ;1397
000072  f8d02140          LDR      r2,[r0,#0x140]        ;1416
000076  f8c120ac          STR      r2,[r1,#0xac]         ;1416
00007a  f8d02144          LDR      r2,[r0,#0x144]        ;1417
00007e  f8c120b0          STR      r2,[r1,#0xb0]         ;1417
000082  f8d02148          LDR      r2,[r0,#0x148]        ;1418
000086  f8c120b4          STR      r2,[r1,#0xb4]         ;1418
00008a  f8d0014c          LDR      r0,[r0,#0x14c]        ;1419
00008e  f8c100b8          STR      r0,[r1,#0xb8]         ;1419
000092  bd10              POP      {r4,pc}
;;;1423   
                          ENDP

                  |L5.148|
                          DCD      0x40002000
                  |L5.152|
                          DCD      ||.data||
                  |L5.156|
                          DCD      ||.data||+0x4
                  |L5.160|
                          DCD      ||.data||+0x8
                  |L5.164|
                          DCD      ||.data||+0xc

                          AREA ||i.PWMDRV_PWM_Out_InterruptHandler||, CODE, READONLY, ALIGN=2

                  PWMDRV_PWM_Out_InterruptHandler PROC
;;;838    
;;;839    void PWMDRV_PWM_Out_InterruptHandler(void)
000000  b510              PUSH     {r4,lr}
;;;840    {
;;;841    	if(SCRB->SYS_INT_ST.tBit.r_pwm_ab_intr != 0)
000002  f04f4480          MOV      r4,#0x40000000
000006  69a0              LDR      r0,[r4,#0x18]
000008  f4100f80          TST      r0,#0x400000
00000c  d005              BEQ      |L6.26|
;;;842    	{
;;;843    		SCRB->PWM_INT_CLR.tBit.pwm_ab_int_clr = 0x1;
00000e  f8d4008c          LDR      r0,[r4,#0x8c]
000012  f0400001          ORR      r0,r0,#1
000016  f8c4008c          STR      r0,[r4,#0x8c]
                  |L6.26|
;;;844    	}
;;;845    
;;;846    	if(SCRB->SYS_INT_ST.tBit.r_pwm_frame_intr != 0)
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  f4101f00          TST      r0,#0x200000
000020  d005              BEQ      |L6.46|
;;;847    	{
;;;848    		SCRB->PWM_INT_CLR.tBit.pwm_frame_int_clr = 0x1;
000022  f8d4008c          LDR      r0,[r4,#0x8c]
000026  f0400002          ORR      r0,r0,#2
00002a  f8c4008c          STR      r0,[r4,#0x8c]
                  |L6.46|
;;;849    	}
;;;850    
;;;851    	if(SCRB->SYS_INT_ST2.tBit.int_lhb != 0)
00002e  f8d40098          LDR      r0,[r4,#0x98]
000032  f0100f01          TST      r0,#1
;;;852    	{
;;;853    #if (USED_TPIC_MUXEN_ON_OFF_CONTROL && USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM)
;;;854    		if(HAL_GetTPICMuxEnControl())
;;;855    		{
;;;856    			// MUX EN Code Add
;;;857    	#if USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE
;;;858    			if(IS_ACTIVE_MODE(HAL_GetSensingMode()))
;;;859    			{
;;;860    				SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;861    			}
;;;862    			else
;;;863    			{
;;;864    				SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;865    			}
;;;866    	#else /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;867    			SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;868    	#endif /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;869    	#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;870    			GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_LOW);
;;;871    	#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;872    		}
;;;873    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM) */
;;;874    
;;;875    #if USED_PWM_PULSE_END_FLAG_CHECK
;;;876    		tHalIntrHandle.ulPWM_Pulse_End_Flag = YES;
;;;877    #endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;878    
;;;879    		SCRB->PWM_INT_CLR.tBit.lhb_int_clr = 0x1;
;;;880    	}
;;;881    }
000036  bf08              IT       EQ
000038  bd10              POPEQ    {r4,pc}
00003a  f7fffffe          BL       HAL_GetTPICMuxEnControl
00003e  b128              CBZ      r0,|L6.76|
000040  f8d40124          LDR      r0,[r4,#0x124]        ;867
000044  f0206080          BIC      r0,r0,#0x4000000      ;867
000048  f8c40124          STR      r0,[r4,#0x124]        ;867
                  |L6.76|
00004c  4904              LDR      r1,|L6.96|
00004e  2001              MOVS     r0,#1                 ;876
000050  6248              STR      r0,[r1,#0x24]         ;876  ; tHalIntrHandle
000052  f8d4008c          LDR      r0,[r4,#0x8c]         ;879
000056  f0400040          ORR      r0,r0,#0x40           ;879
00005a  f8c4008c          STR      r0,[r4,#0x8c]         ;879
00005e  bd10              POP      {r4,pc}
;;;882    
                          ENDP

                  |L6.96|
                          DCD      tHalIntrHandle

                          AREA ||i.PWMDRV_RegisterInit||, CODE, READONLY, ALIGN=2

                  PWMDRV_RegisterInit PROC
;;;996    
;;;997    void PWMDRV_RegisterInit(eSENSING_MODE_t _eSensingMode)
000000  b570              PUSH     {r4-r6,lr}
;;;998    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
;;;999    	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000006  f7fffffe          BL       hal_pwmdrv_GetControlConfig
00000a  4604              MOV      r4,r0
;;;1000   	tCP_PWMGEN_CR0_t tCP_PWMGEN_CR0;
;;;1001   	tCP_PWMGEN_CR1_t tCP_PWMGEN_CR1;
;;;1002   	tCP_PWMGEN_CR2_t tCP_PWMGEN_CR2;
;;;1003   
;;;1004   	tCP_PWMGEN_CR0.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR0.ulBulk;
00000c  6800              LDR      r0,[r0,#0]
00000e  9001              STR      r0,[sp,#4]
;;;1005   
;;;1006   #if USED_MNT_S3_MODE_FUNCTION
;;;1007   	if(IS_S3_MODE(_eSensingMode))
;;;1008   	{
;;;1009   		tCP_PWMGEN_CR0.tBit.pen_mode = (PWM_FULL_FINGER_MODE);
;;;1010   		PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
000010  4df9              LDR      r5,|L7.1016|
000012  f4166f00          TST      r6,#0x800             ;1007
000016  d037              BEQ      |L7.136|
000018  f89d0006          LDRB     r0,[sp,#6]            ;1009
00001c  f0200002          BIC      r0,r0,#2              ;1009
000020  f88d0006          STRB     r0,[sp,#6]            ;1009
000024  6860              LDR      r0,[r4,#4]
000026  6068              STR      r0,[r5,#4]
;;;1011   		PWMDRV->PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
000028  68a0              LDR      r0,[r4,#8]
00002a  60a8              STR      r0,[r5,#8]
;;;1012   		PWMDRV->PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_Idle_total_mux_num;
00002c  68a8              LDR      r0,[r5,#8]
00002e  f02060fc          BIC      r0,r0,#0x7e00000
000032  f5000080          ADD      r0,r0,#0x400000
000036  60a8              STR      r0,[r5,#8]
;;;1013   		PWMDRV->PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_Idle_finger_pwmnum;
000038  68a8              LDR      r0,[r5,#8]
00003a  f420507e          BIC      r0,r0,#0x3f80
00003e  f50050a4          ADD      r0,r0,#0x1480
000042  60a8              STR      r0,[r5,#8]
;;;1014   
;;;1015   
;;;1016   		PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
000044  6920              LDR      r0,[r4,#0x10]
000046  6128              STR      r0,[r5,#0x10]
;;;1017   		PWMDRV->TSYNC_CR.tBit.tsync_num = 0;
000048  6928              LDR      r0,[r5,#0x10]
00004a  f020001f          BIC      r0,r0,#0x1f
00004e  6128              STR      r0,[r5,#0x10]
;;;1018   		PWMDRV->TSYNC_CR.tBit.tsynct_in_sel = PWM_TSYNC_INTR_INTERNAL;
000050  6928              LDR      r0,[r5,#0x10]
000052  f4407000          ORR      r0,r0,#0x200
000056  6128              STR      r0,[r5,#0x10]
;;;1019   		PWMDRV->TSYNC_CR.tBit.tsynct_in_inv = 0;
000058  6928              LDR      r0,[r5,#0x10]
00005a  f4206080          BIC      r0,r0,#0x400
00005e  6128              STR      r0,[r5,#0x10]
;;;1020   		PWMDRV->TSYNC_CR.tBit.tsync_sric_in_sel = PWM_TSYNC_SRIC_INTR_INTERNAL;
000060  6928              LDR      r0,[r5,#0x10]
000062  f4405080          ORR      r0,r0,#0x1000
000066  6128              STR      r0,[r5,#0x10]
;;;1021   		PWMDRV->TSYNC_CR.tBit.tsync_sric_out_inv = 0;
000068  6928              LDR      r0,[r5,#0x10]
00006a  f4204000          BIC      r0,r0,#0x8000
00006e  6128              STR      r0,[r5,#0x10]
;;;1022   		{
;;;1023   #define TSYNCGEN_TIMING_DIV_VALUE		(534)
;;;1024   			uint32_t ulTotal_Time_usec;
;;;1025   //			ulTotal_Time_usec = (1000*1000/S3_MODE_FRAME_RATE_Hz)>>1; // 1LHB of 2LHB?? (/2)
;;;1026   //			PWMDRV->TE_TCH_T_HIGH = ((ulTotal_Time_usec-S3_MODE_TOUCH_TIME_usec)*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1027   //			PWMDRV->TE_TCH_D_HIGH = ((ulTotal_Time_usec-S3_MODE_TOUCH_TIME_usec)*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1028   //			PWMDRV->TE_TCH_LOW = (S3_MODE_TOUCH_TIME_usec*100)/TSYNCGEN_TIMING_DIV_VALUE;
;;;1029   
;;;1030   			ulTotal_Time_usec = (1000*1000/S3_MODE_FRAME_RATE_Hz); // 1LHB of 1LHB
;;;1031   			PWMDRV->TE_TCH_T_HIGH = (S3_MODE_TOUCH_TIME_usec*100)/TSYNCGEN_TIMING_DIV_VALUE;
000070  f240501e          MOV      r0,#0x51e
000074  f8c500d4          STR      r0,[r5,#0xd4]
;;;1032   			PWMDRV->TE_TCH_D_HIGH = (S3_MODE_TOUCH_TIME_usec*100)/TSYNCGEN_TIMING_DIV_VALUE;
000078  f8c500d8          STR      r0,[r5,#0xd8]
;;;1033   			PWMDRV->TE_TCH_LOW = ((ulTotal_Time_usec-S3_MODE_TOUCH_TIME_usec)*100)/TSYNCGEN_TIMING_DIV_VALUE;
00007c  48df              LDR      r0,|L7.1020|
00007e  f2402116          MOV      r1,#0x216
000082  fbb0f0f1          UDIV     r0,r0,r1
;;;1034   #undef TSYNCGEN_TIMING_DIV_VALUE
;;;1035   		}
000086  e052              B        |L7.302|
                  |L7.136|
;;;1036   //		PWMDRV->TE_TCH_T_HIGH = 3933;//ptHalPwmdrvControlConf->tCP_TE_TCH_T_HIGH;
;;;1037   //		PWMDRV->TE_TCH_D_HIGH = 2000;//ptHalPwmdrvControlConf->tCP_TE_TCH_D_HIGH;
;;;1038   //		PWMDRV->TE_TCH_LOW = 749;//ptHalPwmdrvControlConf->tCP_TE_TCH_LOW;
;;;1039   	}
;;;1040   	else
;;;1041   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1042   	{
;;;1043   		if(IS_FINGER_PEN_MODE(_eSensingMode))
;;;1044   		{
;;;1045   			tCP_PWMGEN_CR0.tBit.pen_mode = (PWM_LOCAL_PEN_MODE);
;;;1046   			if(IS_ACTIVE_MODE(_eSensingMode))
;;;1047   			{
;;;1048   				/*
;;;1049   				 * PWM Pulse Setting
;;;1050   				 */
;;;1051   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1052   				PWMDRV->PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1053   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1054   			}
;;;1055   	#if USED_LOCAL_IDLE_MODE_CONTROL
;;;1056   			else
;;;1057   			{
;;;1058   				/*
;;;1059   				 * PWM Pulse Setting
;;;1060   				 */
;;;1061   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1062   
;;;1063   				tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1064   				tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_num;
;;;1065   				tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_total_mux_num;
;;;1066   				PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1067   
;;;1068   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1069   				PWMDRV->TSYNC_CR.tBit.tsync_num = (LOCAL_IDLE_LHB_NUM-1);
;;;1070   			}
;;;1071   	#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1072   		}
;;;1073   		else
;;;1074   		{
;;;1075   			tCP_PWMGEN_CR0.tBit.pen_mode = (PWM_FULL_FINGER_MODE);
000088  f89d0006          LDRB     r0,[sp,#6]
00008c  f4164f80          TST      r6,#0x4000            ;1043
000090  d00d              BEQ      |L7.174|
000092  f0400002          ORR      r0,r0,#2              ;1045
000096  f88d0006          STRB     r0,[sp,#6]            ;1045
00009a  f0160f01          TST      r6,#1                 ;1046
00009e  d03c              BEQ      |L7.282|
0000a0  6860              LDR      r0,[r4,#4]            ;1051
0000a2  6068              STR      r0,[r5,#4]            ;1051
0000a4  68a0              LDR      r0,[r4,#8]            ;1052
0000a6  60a8              STR      r0,[r5,#8]            ;1052
0000a8  6920              LDR      r0,[r4,#0x10]         ;1053
0000aa  6128              STR      r0,[r5,#0x10]         ;1053
0000ac  e035              B        |L7.282|
                  |L7.174|
0000ae  f0200002          BIC      r0,r0,#2
0000b2  f88d0006          STRB     r0,[sp,#6]
;;;1076   			if(IS_ACTIVE_MODE(_eSensingMode))
0000b6  f0160f01          TST      r6,#1
0000ba  d02e              BEQ      |L7.282|
;;;1077   			{
;;;1078   #if USED_NOISE_HOPPING_FREQ
;;;1079   				if(IS_ACTIVE_MODE_FRQ_MAIN(_eSensingMode))
0000bc  f0160f02          TST      r6,#2
0000c0  d010              BEQ      |L7.228|
;;;1080   				{
;;;1081   					/*
;;;1082   					 * PWM Pulse Setting
;;;1083   					 */
;;;1084   					PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
0000c2  6860              LDR      r0,[r4,#4]
0000c4  6068              STR      r0,[r5,#4]
;;;1085   					tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
0000c6  68a0              LDR      r0,[r4,#8]
0000c8  9000              STR      r0,[sp,#0]
;;;1086   					tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_total_mux_num;
0000ca  f8bd0002          LDRH     r0,[sp,#2]
0000ce  f42060fc          BIC      r0,r0,#0x7e0
0000d2  f5007090          ADD      r0,r0,#0x120
0000d6  f8ad0002          STRH     r0,[sp,#2]
;;;1087   					PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
0000da  9800              LDR      r0,[sp,#0]
0000dc  60a8              STR      r0,[r5,#8]
;;;1088   
;;;1089   					PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
0000de  6920              LDR      r0,[r4,#0x10]
0000e0  6128              STR      r0,[r5,#0x10]
0000e2  e01a              B        |L7.282|
                  |L7.228|
;;;1090   				}
;;;1091   				else if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
0000e4  f0160f04          TST      r6,#4
0000e8  d017              BEQ      |L7.282|
;;;1092   				{
;;;1093   					/*
;;;1094   					 * PWM Pulse Setting
;;;1095   					 */
;;;1096   					PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
0000ea  6860              LDR      r0,[r4,#4]
0000ec  6068              STR      r0,[r5,#4]
;;;1097   					tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
0000ee  68a0              LDR      r0,[r4,#8]
0000f0  9000              STR      r0,[sp,#0]
;;;1098   					tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_HoppFrq_finger_pwmnum;
0000f2  f8bd0000          LDRH     r0,[sp,#0]
0000f6  f420507e          BIC      r0,r0,#0x3f80
0000fa  f5006050          ADD      r0,r0,#0xd00
0000fe  f8ad0000          STRH     r0,[sp,#0]
;;;1099   					tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_total_mux_num;
000102  f8bd0002          LDRH     r0,[sp,#2]
000106  f42060fc          BIC      r0,r0,#0x7e0
00010a  f5007090          ADD      r0,r0,#0x120
00010e  f8ad0002          STRH     r0,[sp,#2]
;;;1100   					PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
000112  9800              LDR      r0,[sp,#0]
000114  60a8              STR      r0,[r5,#8]
;;;1101   
;;;1102   					PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
000116  6920              LDR      r0,[r4,#0x10]
000118  6128              STR      r0,[r5,#0x10]
                  |L7.282|
;;;1103   				}
;;;1104   #else
;;;1105   				/*
;;;1106   				 * PWM Pulse Setting
;;;1107   				 */
;;;1108   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1109   				tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1110   				tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_total_mux_num;
;;;1111   				PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1112   
;;;1113   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1114   #endif
;;;1115   			}
;;;1116   #if USED_IDLE_MODE_CONTROL
;;;1117   			else
;;;1118   			{
;;;1119   				/*
;;;1120   				 * PWM Pulse Setting
;;;1121   				 */
;;;1122   				PWMDRV->PWMGEN_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR1.ulBulk;
;;;1123   				tCP_PWMGEN_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWMGEN_CR2.ulBulk;
;;;1124   				tCP_PWMGEN_CR2.tBit.finger_pwmnum = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_num;
;;;1125   				tCP_PWMGEN_CR2.tBit.total_mux_num = PARAMSET_PWMDRV_WGP_PWMGEN_CR2_nm_total_mux_num;
;;;1126   				PWMDRV->PWMGEN_CR2.ulBulk = tCP_PWMGEN_CR2.ulBulk;
;;;1127   
;;;1128   				PWMDRV->TSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_CR.ulBulk;
;;;1129   			}
;;;1130   #endif /* USED_IDLE_MODE_CONTROL */
;;;1131   		}
;;;1132   
;;;1133   		PWMDRV->TE_TCH_T_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_T_HIGH;
00011a  f8d40168          LDR      r0,[r4,#0x168]
00011e  f8c500d4          STR      r0,[r5,#0xd4]
;;;1134   		PWMDRV->TE_TCH_D_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_D_HIGH;
000122  f8d4016c          LDR      r0,[r4,#0x16c]
000126  f8c500d8          STR      r0,[r5,#0xd8]
;;;1135   		PWMDRV->TE_TCH_LOW = ptHalPwmdrvControlConf->tCP_TE_TCH_LOW;
00012a  f8d40170          LDR      r0,[r4,#0x170]
                  |L7.302|
00012e  f8c500dc          STR      r0,[r5,#0xdc]
;;;1136   	}
;;;1137   
;;;1138   	PWMDRV->PWMGEN_CR0.ulBulk = tCP_PWMGEN_CR0.ulBulk;
000132  9801              LDR      r0,[sp,#4]
000134  6028              STR      r0,[r5,#0]
;;;1139   	PWMDRV->SET_TX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_SET_TX_CR.ulBulk;
000136  68e0              LDR      r0,[r4,#0xc]
000138  60e8              STR      r0,[r5,#0xc]
;;;1140   	PWMDRV->TSYNC_D2_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_D2_CR.ulBulk;
00013a  6960              LDR      r0,[r4,#0x14]
00013c  6168              STR      r0,[r5,#0x14]
;;;1141   	PWMDRV->DLY_CNT1.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT1.ulBulk;
00013e  69a0              LDR      r0,[r4,#0x18]
000140  61a8              STR      r0,[r5,#0x18]
;;;1142   	PWMDRV->DLY_CNT2.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT2.ulBulk;
000142  69e0              LDR      r0,[r4,#0x1c]
000144  61e8              STR      r0,[r5,#0x1c]
;;;1143   	PWMDRV->DLY_CNT3.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT3.ulBulk;
000146  6a20              LDR      r0,[r4,#0x20]
000148  6228              STR      r0,[r5,#0x20]
;;;1144   	PWMDRV->TSYNC_TPIC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_TSYNC_TPIC_CR.ulBulk;
00014a  6a60              LDR      r0,[r4,#0x24]
00014c  6268              STR      r0,[r5,#0x24]
;;;1145   	PWMDRV->PWM_DLY1.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY1.ulBulk;
00014e  6aa0              LDR      r0,[r4,#0x28]
000150  62a8              STR      r0,[r5,#0x28]
;;;1146   	PWMDRV->DSSS_INFO0.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO0.ulBulk;
000152  6ae0              LDR      r0,[r4,#0x2c]
000154  62e8              STR      r0,[r5,#0x2c]
;;;1147   	PWMDRV->PWM_TPIC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_TPIC_CR.ulBulk;
000156  f8d40118          LDR      r0,[r4,#0x118]
00015a  f8c50080          STR      r0,[r5,#0x80]
;;;1148   	PWMDRV->PWM_SRIC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_SRIC_CR.ulBulk;
00015e  f8d4011c          LDR      r0,[r4,#0x11c]
000162  f8c50084          STR      r0,[r5,#0x84]
;;;1149   	PWMDRV->PWM_MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_MUX_CR.ulBulk;
000166  f8d40120          LDR      r0,[r4,#0x120]
00016a  f8c50088          STR      r0,[r5,#0x88]
;;;1150   #if USED_NOISE_HOPPING_FREQ
;;;1151   	{
;;;1152   		if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
00016e  f0160f04          TST      r6,#4
000172  d01b              BEQ      |L7.428|
;;;1153   		{
;;;1154   			PWMDRV->DMY_FREQ = PARAMSET_PWMDRV_WGP_HOPP1_DMY_FREQ;
000174  20d5              MOVS     r0,#0xd5
000176  f8c50090          STR      r0,[r5,#0x90]
;;;1155   			tCP_FREQ_CR1_t tCP_FREQ_CR1;
;;;1156   			tCP_FREQ_CR1.tBit.pen_s = PARAMSET_PWMDRV_WGP_HOPP1_PEN_POS_FREQ;
00017a  f8bd0001          LDRH     r0,[sp,#1]
00017e  f36f008b          BFC      r0,#2,#10
000182  f5007055          ADD      r0,r0,#0x354
000186  f8ad0001          STRH     r0,[sp,#1]
;;;1157   			tCP_FREQ_CR1.tBit.pen_d = PARAMSET_PWMDRV_WGP_HOPP1_PEN_DAT_FREQ;
00018a  f8bd0000          LDRH     r0,[sp,#0]
00018e  f400407c          AND      r0,r0,#0xfc00
000192  30d5              ADDS     r0,r0,#0xd5
000194  f8ad0000          STRH     r0,[sp,#0]
;;;1158   			tCP_FREQ_CR1.tBit.finger = PARAMSET_PWMDRV_WGP_HOPP1_FINGER_FREQ;
000198  f8bd0002          LDRH     r0,[sp,#2]
00019c  f36f100d          BFC      r0,#4,#10
0001a0  f5006055          ADD      r0,r0,#0xd50
0001a4  f8ad0002          STRH     r0,[sp,#2]
;;;1159   			PWMDRV->FREQ_CR1.ulBulk = tCP_FREQ_CR1.ulBulk;
0001a8  9800              LDR      r0,[sp,#0]
;;;1160   		}
0001aa  e005              B        |L7.440|
                  |L7.428|
;;;1161   		else
;;;1162   		{
;;;1163   			PWMDRV->DMY_FREQ = ptHalPwmdrvControlConf->tCP_DMY_FREQ;
0001ac  f8d40124          LDR      r0,[r4,#0x124]
0001b0  f8c50090          STR      r0,[r5,#0x90]
;;;1164   			PWMDRV->FREQ_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_FREQ_CR1.ulBulk;
0001b4  f8d40128          LDR      r0,[r4,#0x128]
                  |L7.440|
0001b8  f8c50094          STR      r0,[r5,#0x94]
;;;1165   		}
;;;1166   	}
;;;1167   #else
;;;1168   	PWMDRV->DMY_FREQ = ptHalPwmdrvControlConf->tCP_DMY_FREQ;
;;;1169   	PWMDRV->FREQ_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_FREQ_CR1.ulBulk;
;;;1170   #endif
;;;1171   	PWMDRV->FREQ_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_FREQ_CR2.ulBulk;
0001bc  f8d4012c          LDR      r0,[r4,#0x12c]
0001c0  f8c50098          STR      r0,[r5,#0x98]
0001c4  f7fffffe          BL       hal_pwmdrv_GetControlConfig
0001c8  f4066100          AND      r1,r6,#0x800
0001cc  2900              CMP      r1,#0
0001ce  d020              BEQ      |L7.530|
0001d0  498b              LDR      r1,|L7.1024|
0001d2  6809              LDR      r1,[r1,#0]  ; g_tCP_S3_LHB_CONFIG11
0001d4  f8c5109c          STR      r1,[r5,#0x9c]
0001d8  498a              LDR      r1,|L7.1028|
0001da  6809              LDR      r1,[r1,#0]  ; g_tCP_S3_LHB_CONFIG12
0001dc  f8c510a0          STR      r1,[r5,#0xa0]
0001e0  4989              LDR      r1,|L7.1032|
0001e2  6809              LDR      r1,[r1,#0]  ; g_tCP_S3_LHB_CONFIG13
0001e4  f8c510a4          STR      r1,[r5,#0xa4]
0001e8  4988              LDR      r1,|L7.1036|
0001ea  6809              LDR      r1,[r1,#0]  ; g_tCP_S3_LHB_CONFIG14
0001ec  f8c510a8          STR      r1,[r5,#0xa8]
0001f0  f8d01140          LDR      r1,[r0,#0x140]
0001f4  f8c510ac          STR      r1,[r5,#0xac]
0001f8  f8d01144          LDR      r1,[r0,#0x144]
0001fc  f8c510b0          STR      r1,[r5,#0xb0]
000200  f8d01148          LDR      r1,[r0,#0x148]
000204  f8c510b4          STR      r1,[r5,#0xb4]
000208  f8d0014c          LDR      r0,[r0,#0x14c]
00020c  f8c500b8          STR      r0,[r5,#0xb8]
000210  e01f              B        |L7.594|
                  |L7.530|
000212  f8d01130          LDR      r1,[r0,#0x130]
000216  f8c5109c          STR      r1,[r5,#0x9c]
00021a  f8d01134          LDR      r1,[r0,#0x134]
00021e  f8c510a0          STR      r1,[r5,#0xa0]
000222  f8d01138          LDR      r1,[r0,#0x138]
000226  f8c510a4          STR      r1,[r5,#0xa4]
00022a  f8d0113c          LDR      r1,[r0,#0x13c]
00022e  f8c510a8          STR      r1,[r5,#0xa8]
000232  f8d01140          LDR      r1,[r0,#0x140]
000236  f8c510ac          STR      r1,[r5,#0xac]
00023a  f8d01144          LDR      r1,[r0,#0x144]
00023e  f8c510b0          STR      r1,[r5,#0xb0]
000242  f8d01148          LDR      r1,[r0,#0x148]
000246  f8c510b4          STR      r1,[r5,#0xb4]
00024a  f8d0014c          LDR      r0,[r0,#0x14c]
00024e  f8c500b8          STR      r0,[r5,#0xb8]
                  |L7.594|
;;;1172   
;;;1173   	PWMDRV_LocalLHBSetting(_eSensingMode);
;;;1174   	PWMDRV->PING_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PING_CR.ulBulk;
000252  f8d40150          LDR      r0,[r4,#0x150]
000256  f8c500bc          STR      r0,[r5,#0xbc]
;;;1175   	PWMDRV->SYNC_GEN_CR.ulBulk = ptHalPwmdrvControlConf->tCP_SYNC_GEN_CR.ulBulk;
00025a  f8d40154          LDR      r0,[r4,#0x154]
00025e  f8c500c0          STR      r0,[r5,#0xc0]
;;;1176   	PWMDRV->TE_RDY_CNT = ptHalPwmdrvControlConf->tCP_TE_RDY_CNT;
000262  f8d40158          LDR      r0,[r4,#0x158]
000266  f8c500c4          STR      r0,[r5,#0xc4]
;;;1177   	PWMDRV->TE_TCH_V_FPCH = ptHalPwmdrvControlConf->tCP_TE_TCH_V_FPCH;
00026a  f8d4015c          LDR      r0,[r4,#0x15c]
00026e  f8c500c8          STR      r0,[r5,#0xc8]
;;;1178   	PWMDRV->TE_TCH_V_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_V_HIGH;
000272  f8d40160          LDR      r0,[r4,#0x160]
000276  f8c500cc          STR      r0,[r5,#0xcc]
;;;1179   	PWMDRV->TE_TCH_FPCH = ptHalPwmdrvControlConf->tCP_TE_TCH_FPCH;
00027a  f8d40164          LDR      r0,[r4,#0x164]
00027e  f8c500d0          STR      r0,[r5,#0xd0]
;;;1180   //	PWMDRV->TE_TCH_T_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_T_HIGH;
;;;1181   //	PWMDRV->TE_TCH_D_HIGH = ptHalPwmdrvControlConf->tCP_TE_TCH_D_HIGH;
;;;1182   //	PWMDRV->TE_TCH_LOW = ptHalPwmdrvControlConf->tCP_TE_TCH_LOW;
;;;1183   	PWMDRV->TE_TCH_BPCH = ptHalPwmdrvControlConf->tCP_TE_TCH_BPCH;
000282  f8d40174          LDR      r0,[r4,#0x174]
000286  f8c500e0          STR      r0,[r5,#0xe0]
;;;1184   	PWMDRV->TE_TCH_PD_LOW = ptHalPwmdrvControlConf->tCP_TE_TCH_PD_LOW;
00028a  f8d40178          LDR      r0,[r4,#0x178]
00028e  f8c500e4          STR      r0,[r5,#0xe4]
;;;1185   	PWMDRV->TG_DUM1 = ptHalPwmdrvControlConf->tCP_TG_DUM1;
000292  f8d4017c          LDR      r0,[r4,#0x17c]
000296  f8c500ec          STR      r0,[r5,#0xec]
;;;1186   	PWMDRV->TG_DUM2 = ptHalPwmdrvControlConf->tCP_TG_DUM2;
00029a  f8d40180          LDR      r0,[r4,#0x180]
00029e  f8c500f0          STR      r0,[r5,#0xf0]
;;;1187   	PWMDRV->TG_DUM3 = ptHalPwmdrvControlConf->tCP_TG_DUM3;
0002a2  f8d40184          LDR      r0,[r4,#0x184]
0002a6  f8c500f4          STR      r0,[r5,#0xf4]
;;;1188   	PWMDRV->TG_DUM4 = ptHalPwmdrvControlConf->tCP_TG_DUM4;
0002aa  f8d40188          LDR      r0,[r4,#0x188]
0002ae  f8c500f8          STR      r0,[r5,#0xf8]
;;;1189   	PWMDRV->TG_DUM5.ulBulk = ptHalPwmdrvControlConf->tCP_TG_DUM5.ulBulk;
0002b2  f8d4018c          LDR      r0,[r4,#0x18c]
0002b6  f8c500fc          STR      r0,[r5,#0xfc]
;;;1190   #if USED_MNT_S3_MODE_FUNCTION
;;;1191   	if(IS_S3_MODE(_eSensingMode))
0002ba  d005              BEQ      |L7.712|
;;;1192   	{
;;;1193   		PWMDRV->TG_DUM5.tBit.tsync_sric_out_bypass_enb = 1; //0:Bypass, 1:Internal Timing
0002bc  f8d500fc          LDR      r0,[r5,#0xfc]
0002c0  f0400002          ORR      r0,r0,#2
0002c4  f8c500fc          STR      r0,[r5,#0xfc]
                  |L7.712|
;;;1194   	}
;;;1195   #endif /* USED_MNT_S3_MODE_FUNCTION */
;;;1196   
;;;1197   	PWMDRV->DISP_OFF_CR.ulBulk = ptHalPwmdrvControlConf->tCP_DISP_OFF_CR.ulBulk;
0002c8  f8d40190          LDR      r0,[r4,#0x190]
0002cc  f8c50100          STR      r0,[r5,#0x100]
;;;1198   #if USED_NOISE_HOPPING_FREQ
;;;1199   	{
;;;1200   		if(IS_ACTIVE_MODE_FRQ_HOP1(_eSensingMode))
0002d0  f0160f04          TST      r6,#4
0002d4  d024              BEQ      |L7.800|
;;;1201   		{
;;;1202   			tCP_PWM_CR1_t tCP_PWM_CR1;
;;;1203   			tCP_PWM_CR1.tBit.pen_s_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_pen_s_h_pnt;
0002d6  f8bd0000          LDRH     r0,[sp,#0]
0002da  f400407c          AND      r0,r0,#0xfc00
0002de  f100006b          ADD      r0,r0,#0x6b
0002e2  f8ad0000          STRH     r0,[sp,#0]
;;;1204   			tCP_PWM_CR1.tBit.pen_d_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_pen_d_h_pnt;
0002e6  f8bd0001          LDRH     r0,[sp,#1]
0002ea  f36f008b          BFC      r0,#2,#10
0002ee  f50070d6          ADD      r0,r0,#0x1ac
0002f2  f8ad0001          STRH     r0,[sp,#1]
;;;1205   			PWMDRV->PWM_CR1.ulBulk = tCP_PWM_CR1.ulBulk;
0002f6  9800              LDR      r0,[sp,#0]
0002f8  f8c50104          STR      r0,[r5,#0x104]
;;;1206   
;;;1207   			tCP_PWM_CR2_t tCP_PWM_CR2;
;;;1208   			tCP_PWM_CR2.tBit.finger_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_finger_h_pnt;
0002fc  f8bd0004          LDRH     r0,[sp,#4]
000300  f400407c          AND      r0,r0,#0xfc00
000304  f100006b          ADD      r0,r0,#0x6b
000308  f8ad0004          STRH     r0,[sp,#4]
;;;1209   			tCP_PWM_CR2.tBit.dmy_h_pnt = PARAMSET_PWMDRV_WGP_HOPP1_PWM_CR2_dmy_h_pnt;
00030c  f8bd0005          LDRH     r0,[sp,#5]
000310  f36f008b          BFC      r0,#2,#10
000314  f50070d6          ADD      r0,r0,#0x1ac
000318  f8ad0005          STRH     r0,[sp,#5]
;;;1210   			PWMDRV->PWM_CR2.ulBulk = tCP_PWM_CR2.ulBulk;
00031c  9801              LDR      r0,[sp,#4]
;;;1211   		}
00031e  e005              B        |L7.812|
                  |L7.800|
;;;1212   		else
;;;1213   		{
;;;1214   			PWMDRV->PWM_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR1.ulBulk;
000320  f8d40194          LDR      r0,[r4,#0x194]
000324  f8c50104          STR      r0,[r5,#0x104]
;;;1215   			PWMDRV->PWM_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR2.ulBulk;
000328  f8d40198          LDR      r0,[r4,#0x198]
                  |L7.812|
00032c  f8c50108          STR      r0,[r5,#0x108]
;;;1216   		}
;;;1217   	}
;;;1218   #else
;;;1219   	PWMDRV->PWM_CR1.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR1.ulBulk;
;;;1220   	PWMDRV->PWM_CR2.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_CR2.ulBulk;
;;;1221   #endif
;;;1222   	PWMDRV->VSYNC_CR.ulBulk = ptHalPwmdrvControlConf->tCP_VSYNC_CR.ulBulk;
000330  f8d4019c          LDR      r0,[r4,#0x19c]
000334  f8c5010c          STR      r0,[r5,#0x10c]
;;;1223   
;;;1224   	if(IS_ACTIVE_MODE(_eSensingMode))
000338  f0160f01          TST      r6,#1
;;;1225   	{
;;;1226   		PWMDRV->MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_MUX_CR.ulBulk;
00033c  bf1c              ITT      NE
00033e  f8d401a0          LDRNE    r0,[r4,#0x1a0]
000342  f8c50110          STRNE    r0,[r5,#0x110]
;;;1227   	}
;;;1228   #if USED_LOCAL_IDLE_MODE_CONTROL
;;;1229   	else
;;;1230   	{
;;;1231   		tCP_MUX_CR_t tCP_MUX_CR;
;;;1232   		tCP_MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_MUX_CR.ulBulk;
;;;1233   		tCP_MUX_CR.tBit.pen_s = PARAMSET_PWMDRV_WGP_MUX_CR_Idle_pen_s;
;;;1234   		tCP_MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_MUX_CR_Idle_finger;
;;;1235   		PWMDRV->MUX_CR.ulBulk = tCP_MUX_CR.ulBulk;
;;;1236   	}
;;;1237   #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;1238   #if USED_IDLE_MODE_CONTROL
;;;1239   	else
;;;1240   	{
;;;1241   		tCP_MUX_CR_t tCP_MUX_CR;
;;;1242   		tCP_MUX_CR.ulBulk = ptHalPwmdrvControlConf->tCP_MUX_CR.ulBulk;
;;;1243   		tCP_MUX_CR.tBit.finger = PARAMSET_PWMDRV_WGP_MUX_CR_Idle_finger;
;;;1244   		PWMDRV->MUX_CR.ulBulk = tCP_MUX_CR.ulBulk;
;;;1245   	}
;;;1246   #endif /* USED_IDLE_MODE_CONTROL */
;;;1247   
;;;1248   	PWMDRV->PWM_TPIC_ST_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_TPIC_ST_CR.ulBulk;
000346  f8d401a4          LDR      r0,[r4,#0x1a4]
00034a  f8c50114          STR      r0,[r5,#0x114]
;;;1249   	PWMDRV->PWM_SRIC_ST_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_SRIC_ST_CR.ulBulk;
00034e  f8d401a8          LDR      r0,[r4,#0x1a8]
000352  f8c50118          STR      r0,[r5,#0x118]
;;;1250   	PWMDRV->PWM_MUX_ST_CR.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_MUX_ST_CR.ulBulk;
000356  f8d401ac          LDR      r0,[r4,#0x1ac]
00035a  f8c5011c          STR      r0,[r5,#0x11c]
;;;1251   	PWMDRV->NM_FREQ.ulBulk = ptHalPwmdrvControlConf->tCP_NM_FREQ.ulBulk;
00035e  f8d401b0          LDR      r0,[r4,#0x1b0]
000362  f8c50120          STR      r0,[r5,#0x120]
;;;1252   	PWMDRV->PWM_DLY2.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY2.ulBulk;
000366  f8d401b4          LDR      r0,[r4,#0x1b4]
00036a  f8c50128          STR      r0,[r5,#0x128]
;;;1253   	PWMDRV->DLY_CNT4.ulBulk = ptHalPwmdrvControlConf->tCP_DLY_CNT4.ulBulk;
00036e  f8d401b8          LDR      r0,[r4,#0x1b8]
000372  f8c5012c          STR      r0,[r5,#0x12c]
;;;1254   	PWMDRV->KIOSK_VSYNC_TIMER = ptHalPwmdrvControlConf->tCP_KIOSK_VSYNC_TIMER;
000376  f8d401bc          LDR      r0,[r4,#0x1bc]
00037a  f8c50130          STR      r0,[r5,#0x130]
;;;1255   	PWMDRV->PWM_DLY3.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY3.ulBulk;
00037e  f8d401c0          LDR      r0,[r4,#0x1c0]
000382  f8c50134          STR      r0,[r5,#0x134]
;;;1256   	PWMDRV->PWM_DLY4.ulBulk = ptHalPwmdrvControlConf->tCP_PWM_DLY4.ulBulk;
000386  f8d401c4          LDR      r0,[r4,#0x1c4]
00038a  f8c50138          STR      r0,[r5,#0x138]
;;;1257   
;;;1258   	/*
;;;1259   	 * Pen Beacon Setting
;;;1260   	 */
;;;1261   	PWMDRV_Set_DSSS_INFO(PWMDRV->PWMGEN_CR0.tBit.pen_mode);
00038e  6828              LDR      r0,[r5,#0]
000390  f3c04440          UBFX     r4,r0,#17,#1
000394  f7fffffe          BL       hal_pwmdrv_GetControlConfig
000398  eb000084          ADD      r0,r0,r4,LSL #2
00039c  6b01              LDR      r1,[r0,#0x30]
00039e  6329              STR      r1,[r5,#0x30]
0003a0  6b80              LDR      r0,[r0,#0x38]
0003a2  6368              STR      r0,[r5,#0x34]
0003a4  f7fffffe          BL       hal_pwmdrv_GetControlConfig
0003a8  f8501f40          LDR      r1,[r0,#0x40]!
0003ac  63a9              STR      r1,[r5,#0x38]
0003ae  6841              LDR      r1,[r0,#4]
0003b0  63e9              STR      r1,[r5,#0x3c]
0003b2  6881              LDR      r1,[r0,#8]
0003b4  6429              STR      r1,[r5,#0x40]
0003b6  68c1              LDR      r1,[r0,#0xc]
0003b8  6469              STR      r1,[r5,#0x44]
0003ba  6901              LDR      r1,[r0,#0x10]
0003bc  64a9              STR      r1,[r5,#0x48]
0003be  6941              LDR      r1,[r0,#0x14]
0003c0  64e9              STR      r1,[r5,#0x4c]
0003c2  6981              LDR      r1,[r0,#0x18]
0003c4  6529              STR      r1,[r5,#0x50]
0003c6  69c1              LDR      r1,[r0,#0x1c]
0003c8  6569              STR      r1,[r5,#0x54]
0003ca  6a01              LDR      r1,[r0,#0x20]
0003cc  65a9              STR      r1,[r5,#0x58]
0003ce  6a41              LDR      r1,[r0,#0x24]
0003d0  65e9              STR      r1,[r5,#0x5c]
0003d2  6a81              LDR      r1,[r0,#0x28]
0003d4  6629              STR      r1,[r5,#0x60]
0003d6  6ac1              LDR      r1,[r0,#0x2c]
0003d8  6669              STR      r1,[r5,#0x64]
0003da  6b01              LDR      r1,[r0,#0x30]
0003dc  66a9              STR      r1,[r5,#0x68]
0003de  6b41              LDR      r1,[r0,#0x34]
0003e0  66e9              STR      r1,[r5,#0x6c]
0003e2  6b81              LDR      r1,[r0,#0x38]
0003e4  6729              STR      r1,[r5,#0x70]
0003e6  6bc1              LDR      r1,[r0,#0x3c]
0003e8  6769              STR      r1,[r5,#0x74]
0003ea  6c01              LDR      r1,[r0,#0x40]
0003ec  67a9              STR      r1,[r5,#0x78]
0003ee  6c40              LDR      r0,[r0,#0x44]
0003f0  67e8              STR      r0,[r5,#0x7c]
;;;1262   	PWMDRV_Set_DSSS_CODE(PWM_PEN_COMMON_BEACON);
;;;1263   }
0003f2  b002              ADD      sp,sp,#8
0003f4  bd70              POP      {r4-r6,pc}
0003f6  0000              DCW      0x0000
                  |L7.1016|
                          DCD      0x40002000
                  |L7.1020|
                          DCD      0x00419ce0
                  |L7.1024|
                          DCD      ||.data||
                  |L7.1028|
                          DCD      ||.data||+0x4
                  |L7.1032|
                          DCD      ||.data||+0x8
                  |L7.1036|
                          DCD      ||.data||+0xc
                          ENDP


                          AREA ||i.PWMDRV_Set_DSSS_CODE||, CODE, READONLY, ALIGN=2

                  PWMDRV_Set_DSSS_CODE PROC
;;;1539   
;;;1540   void PWMDRV_Set_DSSS_CODE(uint32_t ulIdx)
000000  b510              PUSH     {r4,lr}
;;;1541   {
000002  4604              MOV      r4,r0
;;;1542   	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000004  f7fffffe          BL       hal_pwmdrv_GetControlConfig
;;;1543   	tCP_DSSS_CODE_Value_t * pCP_DSSS_CODE_Value = (tCP_DSSS_CODE_Value_t *)&ptHalPwmdrvControlConf->tCP_DSSS_CODE_Value[ulIdx];
000008  eb0401c4          ADD      r1,r4,r4,LSL #3
00000c  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;1544   
;;;1545   	PWMDRV->DSSS_CODE_P_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_P_0;
000010  4913              LDR      r1,|L8.96|
000012  f8502f40          LDR      r2,[r0,#0x40]!
000016  638a              STR      r2,[r1,#0x38]
;;;1546   	PWMDRV->DSSS_CODE_P_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_P_1;
000018  6842              LDR      r2,[r0,#4]
00001a  63ca              STR      r2,[r1,#0x3c]
;;;1547   	PWMDRV->DSSS_CODE_0_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_0_0;
00001c  6882              LDR      r2,[r0,#8]
00001e  640a              STR      r2,[r1,#0x40]
;;;1548   	PWMDRV->DSSS_CODE_0_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_0_1;
000020  68c2              LDR      r2,[r0,#0xc]
000022  644a              STR      r2,[r1,#0x44]
;;;1549   	PWMDRV->DSSS_CODE_1_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_1_0;
000024  6902              LDR      r2,[r0,#0x10]
000026  648a              STR      r2,[r1,#0x48]
;;;1550   	PWMDRV->DSSS_CODE_1_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_1_1;
000028  6942              LDR      r2,[r0,#0x14]
00002a  64ca              STR      r2,[r1,#0x4c]
;;;1551   	PWMDRV->DSSS_CODE_2_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_2_0;
00002c  6982              LDR      r2,[r0,#0x18]
00002e  650a              STR      r2,[r1,#0x50]
;;;1552   	PWMDRV->DSSS_CODE_2_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_2_1;
000030  69c2              LDR      r2,[r0,#0x1c]
000032  654a              STR      r2,[r1,#0x54]
;;;1553   	PWMDRV->DSSS_CODE_3_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_3_0;
000034  6a02              LDR      r2,[r0,#0x20]
000036  658a              STR      r2,[r1,#0x58]
;;;1554   	PWMDRV->DSSS_CODE_3_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_3_1;
000038  6a42              LDR      r2,[r0,#0x24]
00003a  65ca              STR      r2,[r1,#0x5c]
;;;1555   	PWMDRV->DSSS_CODE_4_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_4_0;
00003c  6a82              LDR      r2,[r0,#0x28]
00003e  660a              STR      r2,[r1,#0x60]
;;;1556   	PWMDRV->DSSS_CODE_4_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_4_1;
000040  6ac2              LDR      r2,[r0,#0x2c]
000042  664a              STR      r2,[r1,#0x64]
;;;1557   	PWMDRV->DSSS_CODE_5_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_5_0;
000044  6b02              LDR      r2,[r0,#0x30]
000046  668a              STR      r2,[r1,#0x68]
;;;1558   	PWMDRV->DSSS_CODE_5_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_5_1;
000048  6b42              LDR      r2,[r0,#0x34]
00004a  66ca              STR      r2,[r1,#0x6c]
;;;1559   	PWMDRV->DSSS_CODE_6_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_6_0;
00004c  6b82              LDR      r2,[r0,#0x38]
00004e  670a              STR      r2,[r1,#0x70]
;;;1560   	PWMDRV->DSSS_CODE_6_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_6_1;
000050  6bc2              LDR      r2,[r0,#0x3c]
000052  674a              STR      r2,[r1,#0x74]
;;;1561   	PWMDRV->DSSS_CODE_7_0 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_7_0;
000054  6c02              LDR      r2,[r0,#0x40]
000056  678a              STR      r2,[r1,#0x78]
;;;1562   	PWMDRV->DSSS_CODE_7_1 = pCP_DSSS_CODE_Value->tCP_DSSS_CODE_7_1;
000058  6c40              LDR      r0,[r0,#0x44]
00005a  67c8              STR      r0,[r1,#0x7c]
;;;1563   }
00005c  bd10              POP      {r4,pc}
;;;1564   
                          ENDP

00005e  0000              DCW      0x0000
                  |L8.96|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_Set_DSSS_INFO||, CODE, READONLY, ALIGN=2

                  PWMDRV_Set_DSSS_INFO PROC
;;;1532   
;;;1533   void PWMDRV_Set_DSSS_INFO(uint32_t ulIdx)
000000  b510              PUSH     {r4,lr}
;;;1534   {
000002  4604              MOV      r4,r0
;;;1535   	const tHalPwmdrvControlConf_t * ptHalPwmdrvControlConf = hal_pwmdrv_GetControlConfig();
000004  f7fffffe          BL       hal_pwmdrv_GetControlConfig
;;;1536   	PWMDRV->DSSS_INFO1.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO1[ulIdx].ulBulk;
000008  eb000184          ADD      r1,r0,r4,LSL #2
00000c  6b0a              LDR      r2,[r1,#0x30]
00000e  4802              LDR      r0,|L9.24|
000010  6302              STR      r2,[r0,#0x30]
;;;1537   	PWMDRV->DSSS_INFO2.ulBulk = ptHalPwmdrvControlConf->tCP_DSSS_INFO2[ulIdx].ulBulk;
000012  6b89              LDR      r1,[r1,#0x38]
000014  6341              STR      r1,[r0,#0x34]
;;;1538   }
000016  bd10              POP      {r4,pc}
;;;1539   
                          ENDP

                  |L9.24|
                          DCD      0x40002000

                          AREA ||i.PWMDRV_TSync_In_InterruptHandler||, CODE, READONLY, ALIGN=2

                  PWMDRV_TSync_In_InterruptHandler PROC
;;;70     
;;;71     void PWMDRV_TSync_In_InterruptHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;72     {
;;;73     	if(SCRB->SYS_INT_ST.tBit.int_tsyncin != 0)
000004  f04f4580          MOV      r5,#0x40000000
000008  69a8              LDR      r0,[r5,#0x18]
00000a  f4102f00          TST      r0,#0x80000
;;;74     	{
;;;75     #if USED_VCF_SYNC_CONTROL
;;;76     		if(tHalIntrHandle.ulInitFirstFrame == 0)
;;;77     #else
;;;78     		if(tHalIntrHandle.ulInitFirstFrame == 1)
;;;79     		{
;;;80     			tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;81     			tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;82     		}
;;;83     		else
;;;84     #endif /* USED_VCF_SYNC_CONTROL */
;;;85     		{
;;;86     			eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
;;;87     			eActivePenType_t ePenType = hal_Info_GetControlActivePenOPType();
;;;88     
;;;89     			if(GET_GPIO_TSYNC_IN_STATUS == GPIO_DATA_LOW)
;;;90     			{
;;;91     				/*
;;;92     				 * Falling
;;;93     				 */
;;;94     #if USED_TSYNC_TMIC_GPIO_CONTROL
;;;95     				GPIO_Set_DATA(_GPIO_TSYNC_TMIC, GPIO_DATA_LOW);
;;;96     #endif /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;97     
;;;98     #if (USED_VCF_SYNC_CONTROL == NO)
;;;99     				tHalIntrHandle.ulTSyncInFallingCnt++;
;;;100    	#if USED_LOCAL_IDLE_MODE_CONTROL
;;;101    				if(IS_IDLE_MODE(eSensingMode))
;;;102    				{
;;;103    					if(tHalIntrHandle.ulTSyncInFallingCnt >= LOCAL_IDLE_LHB_NUM)
;;;104    					{
;;;105    						tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;106    					}
;;;107    				}
;;;108    				else
;;;109    	#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;110    				{
;;;111    					if(tHalIntrHandle.ulTSyncInFallingCnt >= LHB_NUM)
;;;112    					{
;;;113    						tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;114    //						_gT(_GPIO_TP_INTR);
;;;115    					}
;;;116    				}
;;;117    
;;;118    #endif /* USED_VCF_SYNC_CONTROL */
;;;119    
;;;120    				switch(ePenType)
;;;121    				{
;;;122    #if ((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN))
;;;123    					case ACTIVEPEN_TYPE_LOCAL_MS:
;;;124    					{
;;;125    						if(IS_FINGER_PEN_MODE(eSensingMode))
;;;126    						{
;;;127    							if(IS_ACTIVE_MODE(eSensingMode))
;;;128    							{
;;;129    	#if (USED_ECLK_ON_OFF_CONTROL && (USED_ROIC_DEF == ROIC_SWL92407))
;;;130    								if(tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;131    								   tHalIntrHandle.ulTSyncInFallingCnt == 8 ||
;;;132    								   tHalIntrHandle.ulTSyncInFallingCnt == 9)
;;;133    								{
;;;134    									if(HAL_GetECLKOnOffControl())
;;;135    									{
;;;136    										HAL_ECLK_Off();
;;;137    									}
;;;138    								}
;;;139    	#endif /* #if (USED_ECLK_ON_OFF_CONTROL && (USED_ROIC_DEF == ROIC_SWL92407)) */
;;;140    
;;;141    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;142    								if(HAL_GetTPICMuxEnControl())
;;;143    								{
;;;144    									if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;145    										tHalIntrHandle.ulTSyncInFallingCnt == 2 ||
;;;146    										tHalIntrHandle.ulTSyncInFallingCnt == 3 ||
;;;147    										tHalIntrHandle.ulTSyncInFallingCnt == 4 ||
;;;148    										tHalIntrHandle.ulTSyncInFallingCnt == 5 ||
;;;149    										tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;150    										tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;151    										tHalIntrHandle.ulTSyncInFallingCnt == 9 ||
;;;152    										tHalIntrHandle.ulTSyncInFallingCnt == 10 ||
;;;153    		//								tHalIntrHandle.ulTSyncInFallingCnt == 11 ||
;;;154    		//								tHalIntrHandle.ulTSyncInFallingCnt == 12 ||
;;;155    										tHalIntrHandle.ulTSyncInFallingCnt == 13 ||
;;;156    										tHalIntrHandle.ulTSyncInFallingCnt == 14 ||
;;;157    										tHalIntrHandle.ulTSyncInFallingCnt == 15 ||
;;;158    										tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;159    									{
;;;160    										SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;161    //										GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_HIGH);
;;;162    									}
;;;163    								}
;;;164    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;165    							}
;;;166    							else
;;;167    							{
;;;168    	#if USED_LOCAL_IDLE_MODE_CONTROL
;;;169    	#if (USED_ECLK_ON_OFF_CONTROL && (USED_ROIC_DEF == ROIC_SWL92407))
;;;170    								if(tHalIntrHandle.ulTSyncInFallingCnt != 2)
;;;171    								{
;;;172    									if(HAL_GetECLKOnOffControl())
;;;173    									{
;;;174    										HAL_ECLK_Off();
;;;175    									}
;;;176    								}
;;;177    	#endif /* (USED_ECLK_ON_OFF_CONTROL && (USED_ROIC_DEF == ROIC_SWL92407)) */
;;;178    	#endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;179    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;180    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;181    							}
;;;182    						}
;;;183    						else
;;;184    						{
;;;185    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;186    							if(HAL_GetTPICMuxEnControl())
;;;187    							{
;;;188    								if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;189    									tHalIntrHandle.ulTSyncInFallingCnt == 2 ||
;;;190    									tHalIntrHandle.ulTSyncInFallingCnt == 4 ||
;;;191    									tHalIntrHandle.ulTSyncInFallingCnt == 5 ||
;;;192    									tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;193    									tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;194    									tHalIntrHandle.ulTSyncInFallingCnt == 8 ||
;;;195    									tHalIntrHandle.ulTSyncInFallingCnt == 9 ||
;;;196    									tHalIntrHandle.ulTSyncInFallingCnt == 10 ||
;;;197    									tHalIntrHandle.ulTSyncInFallingCnt == 11 ||
;;;198    									tHalIntrHandle.ulTSyncInFallingCnt == 12 ||
;;;199    									tHalIntrHandle.ulTSyncInFallingCnt == 13 ||
;;;200    									tHalIntrHandle.ulTSyncInFallingCnt == 14 ||
;;;201    									tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;202    								{
;;;203    									SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;204    //									GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_HIGH);
;;;205    								}
;;;206    							}
;;;207    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;208    						}
;;;209    
;;;210    						break;
;;;211    					}
;;;212    					case ACTIVEPEN_TYPE_LOCAL_WACOM:
;;;213    					{
;;;214    						break;
;;;215    					}
;;;216    #endif /* ((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)) */
;;;217    					case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;218    					{
;;;219    #if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;220    						if(tHalIntrHandle.ulTSyncInFallingCnt == 1)
;;;221    						{
;;;222    							GPIO_Set_DATA(_GPIO_Uplink_GPIO, GPIO_DATA_HIGH);
;;;223    						}
;;;224    #endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;225    
;;;226    #if USED_PEN_MODE_OPERATION
;;;227    						if(IS_FINGER_PEN_MODE(eSensingMode))
;;;228    						{
;;;229    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;230    							// MUX EN Code Add
;;;231    							if(HAL_GetTPICMuxEnControl())
;;;232    							{
;;;233    								bool_t bIsControl = NO;
;;;234    		#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;235    								if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;236    									tHalIntrHandle.ulTSyncInFallingCnt == 2 ||
;;;237    									tHalIntrHandle.ulTSyncInFallingCnt == 3 ||
;;;238    									tHalIntrHandle.ulTSyncInFallingCnt == 4 ||
;;;239    									tHalIntrHandle.ulTSyncInFallingCnt == 5 ||
;;;240    									tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;241    									tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;242    									tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;243    								{
;;;244    									bIsControl = YES;
;;;245    								}
;;;246    		#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;247    			#if USED_WGP_16LHB_ACTIVEPEN
;;;248    				#if  USED_LOCAL_IDLE_MODE_CONTROL
;;;249    								if(IS_ACTIVE_MODE(eSensingMode))
;;;250    								{
;;;251    									if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;252    										tHalIntrHandle.ulTSyncInFallingCnt == 2 ||
;;;253    										tHalIntrHandle.ulTSyncInFallingCnt == 5 ||
;;;254    										tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;255    										tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;256    										tHalIntrHandle.ulTSyncInFallingCnt == 8 ||
;;;257    										tHalIntrHandle.ulTSyncInFallingCnt == 9 ||
;;;258    										tHalIntrHandle.ulTSyncInFallingCnt == 10 ||
;;;259    										tHalIntrHandle.ulTSyncInFallingCnt == 11 ||
;;;260    										tHalIntrHandle.ulTSyncInFallingCnt == 12 ||
;;;261    										tHalIntrHandle.ulTSyncInFallingCnt == 13 ||
;;;262    										tHalIntrHandle.ulTSyncInFallingCnt == 14 ||
;;;263    										tHalIntrHandle.ulTSyncInFallingCnt == 15 ||
;;;264    										tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;265    									{
;;;266    										bIsControl = YES;
;;;267    									}
;;;268    								}
;;;269    								else
;;;270    								{
;;;271    					#if USED_LOCAL_IDLE_30Hz
;;;272    									if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;273    										tHalIntrHandle.ulTSyncInFallingCnt == 15 ||
;;;274    										tHalIntrHandle.ulTSyncInFallingCnt == 16)
;;;275    					#else /* USED_LOCAL_IDLE_30Hz */
;;;276    										if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;277    											tHalIntrHandle.ulTSyncInFallingCnt == 15 ||
;;;278    											tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;279    					#endif /* USED_LOCAL_IDLE_30Hz */
;;;280    									{
;;;281    										bIsControl = YES;
;;;282    									}
;;;283    								}
;;;284    				#else
;;;285    								if(IS_ACTIVE_MODE(eSensingMode))
;;;286    								{
;;;287    									if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;288    										tHalIntrHandle.ulTSyncInFallingCnt == 2 ||
;;;289    										tHalIntrHandle.ulTSyncInFallingCnt == 5 ||
;;;290    										tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;291    										tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;292    										tHalIntrHandle.ulTSyncInFallingCnt == 8 ||
;;;293    										tHalIntrHandle.ulTSyncInFallingCnt == 9 ||
;;;294    										tHalIntrHandle.ulTSyncInFallingCnt == 10 ||
;;;295    										tHalIntrHandle.ulTSyncInFallingCnt == 11 ||
;;;296    										tHalIntrHandle.ulTSyncInFallingCnt == 12 ||
;;;297    										tHalIntrHandle.ulTSyncInFallingCnt == 13 ||
;;;298    										tHalIntrHandle.ulTSyncInFallingCnt == 14 ||
;;;299    										tHalIntrHandle.ulTSyncInFallingCnt == 15 ||
;;;300    										tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;301    									{
;;;302    										bIsControl = YES;
;;;303    									}
;;;304    								}
;;;305    				#endif
;;;306    			#else /* USED_WGP_16LHB_ACTIVEPEN */
;;;307    								if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;308    									tHalIntrHandle.ulTSyncInFallingCnt == 2 ||
;;;309    									tHalIntrHandle.ulTSyncInFallingCnt == 4 ||
;;;310    									tHalIntrHandle.ulTSyncInFallingCnt == 5 ||
;;;311    									tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;312    									tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;313    									tHalIntrHandle.ulTSyncInFallingCnt == 8 ||
;;;314    									tHalIntrHandle.ulTSyncInFallingCnt == 9 ||
;;;315    									tHalIntrHandle.ulTSyncInFallingCnt == 10 ||
;;;316    									tHalIntrHandle.ulTSyncInFallingCnt == 11 ||
;;;317    									tHalIntrHandle.ulTSyncInFallingCnt == 12 ||
;;;318    									tHalIntrHandle.ulTSyncInFallingCnt == 13 ||
;;;319    									tHalIntrHandle.ulTSyncInFallingCnt == 14 ||
;;;320    									tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;321    								{
;;;322    									bIsControl = YES;
;;;323    								}
;;;324    			#endif /* USED_WGP_16LHB_ACTIVEPEN */
;;;325    		#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;326    
;;;327    								if(bIsControl)
;;;328    								{
;;;329    									SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;330    //									GPIO_Set_DATA(_GPIO_MUX_EN_TPIC, GPIO_DATA_HIGH);
;;;331    								}
;;;332    							}
;;;333    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;334    
;;;335    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;336    //							if(tHalIntrHandle.ulTSyncInFallingCnt == 1)
;;;337    //							{
;;;338    //								/*
;;;339    //								 * Defense Code!! for matching sync mspi buf index
;;;340    //								 */
;;;341    //								MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;342    //				//				MSPI->tMSPI_FINDEX0.tBit.findex0 = 0;
;;;343    //							}
;;;344    	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;345    						}
;;;346    						else
;;;347    #endif /* USED_PEN_MODE_OPERATION */
;;;348    						{
;;;349    #if USED_ECLK_ON_OFF_CONTROL
;;;350    							if(HAL_GetECLKOnOffControl())
;;;351    							{
;;;352    								HAL_ECLK_On();
;;;353    							}
;;;354    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;355    #if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON)
;;;356    							// MUX EN Code Add
;;;357    							if(HAL_GetTPICMuxEnControl())
;;;358    							{
;;;359    								bool_t bIsControl = NO;
;;;360    								if(IS_ACTIVE_MODE(eSensingMode))
;;;361    								{
;;;362    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;363    									if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;364    										tHalIntrHandle.ulTSyncInFallingCnt == 2 ||
;;;365    										tHalIntrHandle.ulTSyncInFallingCnt == 4 ||
;;;366    										tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;367    										tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;368    	#elif (CUSTOMER == MODEL_DEF_FHD_97500_MNT_S3)
;;;369    	#else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;370    		#if USED_WGP_16LHB_ACTIVEPEN
;;;371    										if (
;;;372    			#if USED_PEN_MODE_OPERATION
;;;373    										tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;374    			#endif /* USED_PEN_MODE_OPERATION */
;;;375    										tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;376    										tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;377    										tHalIntrHandle.ulTSyncInFallingCnt == 8 ||
;;;378    										tHalIntrHandle.ulTSyncInFallingCnt == 14 ||
;;;379    										tHalIntrHandle.ulTSyncInFallingCnt == 15 ||
;;;380    										tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;381    		#else /* USED_WGP_16LHB_ACTIVEPEN */
;;;382    									if (tHalIntrHandle.ulTSyncInFallingCnt == 1 ||
;;;383    										tHalIntrHandle.ulTSyncInFallingCnt == 5 ||
;;;384    										tHalIntrHandle.ulTSyncInFallingCnt == 6 ||
;;;385    										tHalIntrHandle.ulTSyncInFallingCnt == 7 ||
;;;386    										tHalIntrHandle.ulTSyncInFallingCnt == 13 ||
;;;387    										tHalIntrHandle.ulTSyncInFallingCnt == 14 ||
;;;388    										tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;389    		#endif /* USED_WGP_16LHB_ACTIVEPEN */
;;;390    	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;391    									{
;;;392    										bIsControl = YES;
;;;393    									}
;;;394    								}
;;;395    								else
;;;396    								{
;;;397    									if (tHalIntrHandle.ulTSyncInFallingCnt == 0)
;;;398    									{
;;;399    										bIsControl = YES;
;;;400    									}
;;;401    								}
;;;402    
;;;403    								if(bIsControl)
;;;404    								{
;;;405    									SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;406    								}
;;;407    							}
;;;408    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON) */
;;;409    						}
;;;410    						break;
;;;411    					}
;;;412    				}
;;;413    #if USED_MSPEN_LINEDIM_WORKAROUND
;;;414    				if(ePenType == ACTIVEPEN_TYPE_LOCAL_MS)
;;;415    				{
;;;416    					switch(tHalIntrHandle.ulTSyncInFallingCnt)
;;;417    					{
;;;418    						case 1: case 8: case 15:
;;;419    						{
;;;420    							/*
;;;421    							 * CMUX Off
;;;422    							 */
;;;423    							MSPI_Set_TLPMODE();
;;;424    							MSPI_RegisterWrite(0x3FE, 0x1000);
;;;425    							MSPI_Set_AITMODE(HAL_GetSensingMode());
;;;426    							MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;427    							MSPI->SPIAITSTART = MSPI_START_VAL;
;;;428    							break;
;;;429    						}
;;;430    						case 2:
;;;431    						{
;;;432    							/*
;;;433    							 * CMUX On
;;;434    							 */
;;;435    							MSPI_Set_TLPMODE();
;;;436    							MSPI_RegisterWrite(0x3FE, 0x2000);
;;;437    							MSPI_Set_AITMODE(HAL_GetSensingMode());
;;;438    							MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;439    							MSPI->SPIAITSTART = MSPI_START_VAL;
;;;440    							break;
;;;441    						}
;;;442    						case 10:
;;;443    						{
;;;444    							/*
;;;445    							 * CMUX On
;;;446    							 */
;;;447    							MSPI_Set_TLPMODE();
;;;448    							MSPI_RegisterWrite(0x3FE, 0x2000);
;;;449    							MSPI_Set_AITMODE(HAL_GetSensingMode());
;;;450    							MSPI_Set_BUFSIZE_FingerPenMode(6);
;;;451    							MSPI->SPIAITSTART = MSPI_START_VAL;
;;;452    							break;
;;;453    						}
;;;454    						case 0:
;;;455    						{
;;;456    							/*
;;;457    							 * CMUX On
;;;458    							 */
;;;459    							MSPI_Set_TLPMODE();
;;;460    							MSPI_RegisterWrite(0x3FE, 0x2000);
;;;461    							MSPI_Set_AITMODE(HAL_GetSensingMode());
;;;462    							MSPI_Set_BUFSIZE_FingerPenMode(11);
;;;463    							MSPI->SPIAITSTART = MSPI_START_VAL;
;;;464    							break;
;;;465    						}
;;;466    					}
;;;467    				}
;;;468    #endif /* USED_MSPEN_LINEDIM_WORKAROUND */
;;;469    			}
;;;470    			else
;;;471    			{
;;;472    				/*
;;;473    				 * Rising
;;;474    				 */
;;;475    #if USED_TSYNC_TMIC_GPIO_CONTROL
;;;476    				GPIO_Set_DATA(_GPIO_TSYNC_TMIC, GPIO_DATA_HIGH);
;;;477    #endif /* USED_TSYNC_TMIC_GPIO_CONTROL */
;;;478    
;;;479    #if (USED_VCF_SYNC_CONTROL == NO)
;;;480    				tHalIntrHandle.ulTSyncInRisingCnt++;
;;;481    
;;;482    #if USED_LOCAL_IDLE_MODE_CONTROL
;;;483    				if(IS_IDLE_MODE(eSensingMode))
;;;484    				{
;;;485    					if(tHalIntrHandle.ulTSyncInRisingCnt >= LOCAL_IDLE_LHB_NUM)
;;;486    					{
;;;487    						tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;488    					}
;;;489    				}
;;;490    				else
;;;491    #endif /* USED_LOCAL_IDLE_MODE_CONTROL */
;;;492    				{
;;;493    					if(tHalIntrHandle.ulTSyncInRisingCnt >= LHB_NUM)
;;;494    					{
;;;495    						tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;496    					}
;;;497    				}
;;;498    #endif /* USED_VCF_SYNC_CONTROL */
;;;499    
;;;500    				if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;501    				{
;;;502    #if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;503    	#if 1 // R00
;;;504    					SCRB->SYS_RST_CTL.tBit.pwm_rst = 1;
;;;505    					SCRB->SYS_RST_CTL.tBit.pwm_rst = 0;
;;;506    	#else // R01
;;;507    					PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = DISABLE;
;;;508    					delay_us(30);
;;;509    					PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;510    	#endif
;;;511    #else /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;512    	#if 1 // R00
;;;513    					SCRB->SYS_RST_CTL.tBit.pwm_rst = 1;
;;;514    					SCRB->SYS_RST_CTL.tBit.pwm_rst = 0;
;;;515    	#else // R01
;;;516    					PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = DISABLE;
;;;517    					delay_us(30);
;;;518    					PWMDRV->SYNC_GEN_CR.tBit.sync_gen_en = ENABLE;
;;;519    	#endif
;;;520    #endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;521    					tHalIntrHandle.ulTSyncInFallingCnt = 0; // Sync Matching Count of Rising and Falling
;;;522    					tHalIntrHandle.ulVSyncFlag = 1;
;;;523    
;;;524    #if USED_LOCAL_IDLE_30Hz
;;;525    					if(IS_IDLE_MODE(eSensingMode))
;;;526    					{
;;;527    						tCFGR_SYS_CFG_t tCFGR_SYS_CFG;
;;;528    						const tModuleSRICCommonConf_t * pktmoduleSRICCommonConf = module_SRIC_GetCommonConfig();
;;;529    						tCFGR_SYS_CFG.ulBulk = pktmoduleSRICCommonConf->CFGR_SYS_CFG.ulBulk;
;;;530    						MSPI_Set_TLPMODE();
;;;531    						/*
;;;532    						 * ROIC Power On!!
;;;533    						 */
;;;534    						MSPI_RegisterWrite((uint32_t)(0x01C0), pktmoduleSRICCommonConf->CFGR_SSU_PW_CTRL.ulBulk);
;;;535    						/*
;;;536    						 * TG Reset 1 -> 0
;;;537    						 */
;;;538    						tCFGR_SYS_CFG.tBit.tg_reset = 1;
;;;539    						MSPI_RegisterWrite((uint32_t)(0x0014), tCFGR_SYS_CFG.ulBulk);
;;;540    						tCFGR_SYS_CFG.tBit.tg_reset = 0;
;;;541    						MSPI_RegisterWrite((uint32_t)(0x0014), tCFGR_SYS_CFG.ulBulk);
;;;542    
;;;543    						MSPI_Set_AITMODE(HAL_GetSensingMode());
;;;544    					}
;;;545    #endif /* USED_LOCAL_IDLE_30Hz */
;;;546    //					_gT(_GPIO_TP_INTR);
;;;547    				}
;;;548    
;;;549    				switch(ePenType)
;;;550    				{
;;;551    #if ((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN))
;;;552    					case ACTIVEPEN_TYPE_LOCAL_MS:
;;;553    					{
;;;554    //						if(IS_FINGER_PEN_MODE(eSensingMode))
;;;555    						{
;;;556    	#if USED_TPIC_VCOM_LEVEL_I2CM_CONTROL
;;;557    							switch(tHalIntrHandle.ulTSyncInRisingCnt)
;;;558    							{
;;;559    								case 0:
;;;560    								{
;;;561    									/*
;;;562    									 * 첫 번째 Beacon
;;;563    									 */
;;;564    									PWMDRV_Set_DSSS_CODE(hal_Info_GetMPPPen1stBeaconType());
;;;565    									HAL_TPIC_UplinkModulation_LevelCtrl_Enable();
;;;566    									break;
;;;567    								}
;;;568    								case 1:
;;;569    								{
;;;570    									HAL_TPIC_UplinkModulation_LevelCtrl_Disable();
;;;571    									break;
;;;572    								}
;;;573    								case 2:
;;;574    								case 3:
;;;575    								case 4:
;;;576    								case 5:
;;;577    								case 6:
;;;578    								case 7:
;;;579    									break;
;;;580    								case 8:
;;;581    								{
;;;582    									/*
;;;583    									 * 두 번째 Beacon
;;;584    									 */
;;;585    									PWMDRV_Set_DSSS_CODE(PWM_MPP_PEN_2nd_BEACON);
;;;586    									HAL_TPIC_UplinkModulation_LevelCtrl_Enable();
;;;587    									break;
;;;588    								}
;;;589    								case 9:
;;;590    									HAL_TPIC_UplinkModulation_LevelCtrl_Disable();
;;;591    									break;
;;;592    								case 10:
;;;593    								case 11:
;;;594    								case 12:
;;;595    								case 13:
;;;596    								case 14:
;;;597    								case 15:
;;;598    									break;
;;;599    							}
;;;600    	#else /* USED_TPIC_VCOM_LEVEL_I2CM_CONTROL */
;;;601    							if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;602    							{
;;;603    								/*
;;;604    								 * 첫 번째 Beacon
;;;605    								 */
;;;606    								PWMDRV_Set_DSSS_CODE(hal_Info_GetMPPPen1stBeaconType());
;;;607    							}
;;;608    							else if(tHalIntrHandle.ulTSyncInRisingCnt == 8)
;;;609    							{
;;;610    								/*
;;;611    								 * 두 번째 Beacon
;;;612    								 */
;;;613    								PWMDRV_Set_DSSS_CODE(PWM_MPP_PEN_2nd_BEACON);
;;;614    							}
;;;615    	#endif /* USED_TPIC_VCOM_LEVEL_I2CM_CONTROL */
;;;616    						}
;;;617    						break;
;;;618    					}
;;;619    					case ACTIVEPEN_TYPE_LOCAL_WACOM:
;;;620    					{
;;;621    	#if USED_SW47701_PINGONLY_LHB_WORKAROUND
;;;622    						if(tHalIntrHandle.ulTSyncInRisingCnt == 10)
;;;623    						{
;;;624    							PWMDRV->PWM_SRIC_CR.tBit.pen_s_en = DISABLE;
;;;625    							PWMDRV->PWM_SRIC_CR.tBit.pen_s_ping_en = DISABLE;
;;;626    						}
;;;627    		#if (USED_ROIC_DEF == ROIC_SWL92406)
;;;628    						else if(tHalIntrHandle.ulTSyncInRisingCnt == 12)
;;;629    						{
;;;630    							PWMDRV->PWM_SRIC_CR.tBit.pen_s_en = ENABLE;
;;;631    							PWMDRV->PWM_SRIC_CR.tBit.pen_s_ping_en = ENABLE;
;;;632    						}
;;;633    		#elif (USED_ROIC_DEF == ROIC_SWL92407)
;;;634    						else if(tHalIntrHandle.ulTSyncInRisingCnt == 11)
;;;635    						{
;;;636    							PWMDRV->PWM_SRIC_CR.tBit.pen_s_en = ENABLE;
;;;637    							PWMDRV->PWM_SRIC_CR.tBit.pen_s_ping_en = ENABLE;
;;;638    						}
;;;639    		#endif /* (USED_ROIC_DEF == ROIC_SWL92406) */
;;;640    	#endif /* USED_SW47701_PINGONLY_LHB_WORKAROUND */
;;;641    						break;
;;;642    					}
;;;643    #endif /* ((USED_PEN_PROTOCOL == PEN_PROTOCOL_MS_PEN) || (USED_PEN_PROTOCOL == PEN_PROTOCOL_MSnWGP_PEN)) */
;;;644    					case ACTIVEPEN_TYPE_LOCAL_WGP:
;;;645    					{
;;;646    #if (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL))
;;;647    						if(tHalIntrHandle.ulTSyncInRisingCnt == 1)
;;;648    						{
;;;649    							GPIO_Set_DATA(_GPIO_Uplink_GPIO, GPIO_DATA_LOW);
;;;650    						}
;;;651    #endif /* (USED_GPIO_UPLINK_LEVEL_CONTROL && (DEF_UPLINK_CONTROL_OPERATION == DEF_UPLINK_SW_CONTROL)) */
;;;652    
;;;653    #if USED_PEN_MODE_OPERATION
;;;654    						if(IS_FINGER_PEN_MODE(eSensingMode))
;;;655    						{
;;;656    							if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;657    							{
;;;658    								/*
;;;659    								 * 첫 번째 Beacon
;;;660    								 */
;;;661    								PWMDRV_Set_DSSS_INFO(hal_Info_GetWGPPenBeaconType());
;;;662    							}
;;;663    	#if (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN)
;;;664    							if(tHalIntrHandle.ulLocalIndexChangeStart == 1 && tHalIntrHandle.ulTSyncInRisingCnt == 1)
;;;665    							{
;;;666    								tAlgorithmInfo_t * ptAlgorithmInfo = algorithm_GetInfo();
;;;667    								SRIC_SetLocalIndex(sensingRowStart);
;;;668    								MSPI_Set_BUFSIZE_FingerPenMode(0);
;;;669    								p_currentRowStart = currentRowStart;
;;;670    								currentRowStart = sensingRowStart;
;;;671    								currentColStart = ptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;672    							}
;;;673    	#endif /* (USED_PEN_PROTOCOL == PEN_PROTOCOL_WGP_UHD_PEN) */
;;;674    						}
;;;675    						else
;;;676    #endif /* USED_PEN_MODE_OPERATION */
;;;677    						{
;;;678    #if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON && !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM)
;;;679    							if(HAL_GetTPICMuxEnControl())
;;;680    							{
;;;681    
;;;682    	#if USED_PWM_PULSE_END_FLAG_CHECK
;;;683    								if(tHalIntrHandle.ulPWM_Pulse_End_Flag == YES)
;;;684    								{
;;;685    		#if USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE
;;;686    									SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;687    		#else /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;688    									SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;689    		#endif /* USED_MUX_EN_DONOT_CONTROL_IN_ACTVIEMODE */
;;;690    	#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;691    									GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_LOW);
;;;692    	#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;693    									tHalIntrHandle.ulPWM_Pulse_End_Flag = NO;
;;;694    								}
;;;695    	#endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;696    							}
;;;697    #endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TSYNC2_INPUT_FROM_TCON !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM) */
;;;698    						}
;;;699    						break;
;;;700    					}
;;;701    				}
;;;702    
;;;703    #if (!USED_QUEUECOMMONDATA_SEND_Timer_Tick)
;;;704    				#ifdef MODE_I2C
;;;705    					QueueCommonData_I2C();
;;;706    				#else
;;;707    					QueueCommonData_USB();
;;;708    				#endif
;;;709    #endif /* (!USED_QUEUECOMMONDATA_SEND_Timer_Tick) */
;;;710    			}
;;;711    		}
;;;712    
;;;713    		SCRB->PWM_INT_CLR.tBit.tsyncin_int_clr = 0x1;
;;;714    	}
;;;715    }
00000e  bf08              IT       EQ
000010  e8bd81f0          POPEQ    {r4-r8,pc}
000014  4c26              LDR      r4,|L10.176|
000016  6aa0              LDR      r0,[r4,#0x28]         ;78  ; tHalIntrHandle
000018  2600              MOVS     r6,#0                 ;78
00001a  2801              CMP      r0,#1                 ;78
00001c  bf04              ITT      EQ                    ;80
00001e  6226              STREQ    r6,[r4,#0x20]         ;80  ; tHalIntrHandle
000020  61e6              STREQ    r6,[r4,#0x1c]         ;81  ; tHalIntrHandle
000022  d03c              BEQ      |L10.158|
000024  f7fffffe          BL       HAL_GetSensingMode
000028  4607              MOV      r7,r0                 ;86
00002a  f7fffffe          BL       hal_Info_GetControlActivePenOPType
00002e  f8d51150          LDR      r1,[r5,#0x150]        ;89
000032  f0110f08          TST      r1,#8                 ;89
000036  d009              BEQ      |L10.76|
000038  6a20              LDR      r0,[r4,#0x20]         ;480  ; tHalIntrHandle
00003a  1c40              ADDS     r0,r0,#1              ;480
00003c  6220              STR      r0,[r4,#0x20]         ;480  ; tHalIntrHandle
00003e  6a20              LDR      r0,[r4,#0x20]         ;493  ; tHalIntrHandle
000040  2800              CMP      r0,#0                 ;493
000042  bf18              IT       NE                    ;495
000044  6226              STRNE    r6,[r4,#0x20]         ;495  ; tHalIntrHandle
000046  6a20              LDR      r0,[r4,#0x20]         ;500  ; tHalIntrHandle
000048  bb48              CBNZ     r0,|L10.158|
00004a  e01d              B        |L10.136|
                  |L10.76|
00004c  69e1              LDR      r1,[r4,#0x1c]         ;99  ; tHalIntrHandle
00004e  1c49              ADDS     r1,r1,#1              ;99
000050  61e1              STR      r1,[r4,#0x1c]         ;99  ; tHalIntrHandle
000052  69e1              LDR      r1,[r4,#0x1c]         ;111  ; tHalIntrHandle
000054  2900              CMP      r1,#0                 ;111
000056  bf18              IT       NE                    ;113
000058  61e6              STRNE    r6,[r4,#0x1c]         ;113  ; tHalIntrHandle
00005a  2802              CMP      r0,#2                 ;120
00005c  d11f              BNE      |L10.158|
00005e  f7fffffe          BL       HAL_GetECLKOnOffControl
000062  2800              CMP      r0,#0                 ;350
000064  bf18              IT       NE                    ;352
000066  f7fffffe          BLNE     HAL_ECLK_On
00006a  f7fffffe          BL       HAL_GetTPICMuxEnControl
00006e  b1b0              CBZ      r0,|L10.158|
000070  f0170f01          TST      r7,#1                 ;360
000074  d101              BNE      |L10.122|
000076  69e0              LDR      r0,[r4,#0x1c]         ;397  ; tHalIntrHandle
000078  b988              CBNZ     r0,|L10.158|
                  |L10.122|
00007a  f8d50124          LDR      r0,[r5,#0x124]        ;405
00007e  f0406080          ORR      r0,r0,#0x4000000      ;405
000082  f8c50124          STR      r0,[r5,#0x124]        ;405
000086  e00a              B        |L10.158|
                  |L10.136|
000088  68e8              LDR      r0,[r5,#0xc]          ;513
00008a  f0400040          ORR      r0,r0,#0x40           ;513
00008e  60e8              STR      r0,[r5,#0xc]          ;513
000090  68e8              LDR      r0,[r5,#0xc]          ;514
000092  f0200040          BIC      r0,r0,#0x40           ;514
000096  60e8              STR      r0,[r5,#0xc]          ;514
000098  61e6              STR      r6,[r4,#0x1c]         ;521  ; tHalIntrHandle
00009a  2001              MOVS     r0,#1                 ;522
00009c  61a0              STR      r0,[r4,#0x18]         ;522  ; tHalIntrHandle
                  |L10.158|
00009e  f8d5008c          LDR      r0,[r5,#0x8c]         ;713
0000a2  f0400010          ORR      r0,r0,#0x10           ;713
0000a6  f8c5008c          STR      r0,[r5,#0x8c]         ;713
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;716    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L10.176|
                          DCD      tHalIntrHandle

                          AREA ||i.PWMDRV_TSync_Out_InterruptHandler||, CODE, READONLY, ALIGN=2

                  PWMDRV_TSync_Out_InterruptHandler PROC
;;;716    
;;;717    void PWMDRV_TSync_Out_InterruptHandler(void)
000000  b510              PUSH     {r4,lr}
;;;718    {
;;;719    	if(SCRB->SYS_INT_ST.tBit.int_tsyncout != 0)
000002  f04f4480          MOV      r4,#0x40000000
000006  69a0              LDR      r0,[r4,#0x18]
000008  f4101f80          TST      r0,#0x100000
;;;720    	{
;;;721    #if USED_VCF_SYNC_CONTROL
;;;722    		if(tHalIntrHandle.ulInitFirstFrame == 1)
;;;723    		{
;;;724    			tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;725    			tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;726    		}
;;;727    		else
;;;728    		{
;;;729    			if(IS_GPIO_PIN(_GPIO_TSYNC_IN) == GPIO_DATA_LOW)
;;;730    			{
;;;731    				/*
;;;732    				 * Falling
;;;733    				 */
;;;734    				tHalIntrHandle.ulTSyncInFallingCnt++;
;;;735    				if(tHalIntrHandle.ulTSyncInFallingCnt >= LHB_NUM)
;;;736    				{
;;;737    					tHalIntrHandle.ulTSyncInFallingCnt = 0;
;;;738    				}
;;;739    				
;;;740    				// VCF Signal : Floating Sync
;;;741    				if(tHalIntrHandle.ulTSyncInFallingCnt != 1)
;;;742    					_gOut(_GPIO_FLOAT_SYNC, GPIO_DATA_LOW);
;;;743    				
;;;744    				if(HAL_GetPrivacyEnControl())
;;;745    				{
;;;746    					// VCF Signal : Discharging Sync
;;;747    					if(tHalIntrHandle.ulTSyncInFallingCnt == 2)
;;;748    						_gOut(_GPIO_DISCHG_SYNC, GPIO_DATA_HIGH);
;;;749    				}
;;;750    			}
;;;751    			else
;;;752    			{
;;;753    				/*
;;;754    				 * Rising
;;;755    				 */
;;;756    				tHalIntrHandle.ulTSyncInRisingCnt++;
;;;757    				if(tHalIntrHandle.ulTSyncInRisingCnt >= LHB_NUM)
;;;758    				{
;;;759    					tHalIntrHandle.ulTSyncInRisingCnt = 0;
;;;760    				}
;;;761    				
;;;762    				// VCF Signal : Floating Sync
;;;763    				if(tHalIntrHandle.ulTSyncInRisingCnt != 1)
;;;764    					_gOut(_GPIO_FLOAT_SYNC, GPIO_DATA_HIGH);
;;;765    				
;;;766    				if(HAL_GetPrivacyEnControl())
;;;767    				{
;;;768    					// VCF Signal : Discharging Sync
;;;769    					if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;770    						_gOut(_GPIO_DISCHG_SYNC, GPIO_DATA_LOW);
;;;771    					
;;;772    				#if (USED_VCF_SYNC_CONTROL_FREQ == VCF_SYNC_30Hz)
;;;773    					// VCF Signal : VCF Sync 30Hz
;;;774    					if(tHalIntrHandle.ulTSyncInRisingCnt == 0)		_gToggle(_GPIO_VCF_SYNC);
;;;775    				#elif (USED_VCF_SYNC_CONTROL_FREQ == VCF_SYNC_60Hz)
;;;776    					// VCF Signal : VCF Sync 60Hz
;;;777    					if(tHalIntrHandle.ulTSyncInRisingCnt == 0)
;;;778    						_gOut(_GPIO_VCF_SYNC, GPIO_DATA_HIGH);
;;;779    					if(tHalIntrHandle.ulTSyncInRisingCnt == 9)
;;;780    						_gOut(_GPIO_VCF_SYNC, GPIO_DATA_LOW);
;;;781    				#endif
;;;782    					
;;;783    				}
;;;784    			}
;;;785    		}
;;;786    #endif /* USED_VCF_SYNC_CONTROL */
;;;787    
;;;788    #if (USED_S3_VDD_OE_INPUT_OUTPUT_CTRL || USED_ECLK_ON_OFF_CONTROL || USED_TPIC_MUXEN_ON_OFF_CONTROL)
;;;789    		if(tHalIntrHandle.ulInitFirstFrame == 1)
;;;790    		{
;;;791    //			_gT(_GPIO_TP_INTR);
;;;792    		}
;;;793    		else
;;;794    		{
;;;795    #if USED_PWM_PULSE_END_FLAG_CHECK
;;;796    			if(tHalIntrHandle.ulPWM_Pulse_End_Flag == YES)
;;;797    			{
;;;798    				tHalIntrHandle.ulPWM_Pulse_End_Flag = NO;
;;;799    	#if (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM)
;;;800    				if(HAL_GetTPICMuxEnControl())
;;;801    				{
;;;802    					SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_LOW;
;;;803    		#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;804    					GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_LOW);
;;;805    		#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;806    				}
;;;807    	#endif /* (USED_TPIC_MUXEN_ON_OFF_CONTROL && !USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM) */
;;;808    			}
;;;809    			else
;;;810    #endif /* USED_PWM_PULSE_END_FLAG_CHECK */
;;;811    			{
;;;812    #if USED_ECLK_ON_OFF_CONTROL
;;;813    				if(HAL_GetECLKOnOffControl())
;;;814    				{
;;;815    					HAL_ECLK_On();
;;;816    				}
;;;817    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;818    
;;;819    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;820    				if(HAL_GetTPICMuxEnControl())
;;;821    				{
;;;822    					SET_GPIO_MUX_EN_TPIC_STATUS = GPIO_DATA_HIGH;
;;;823    	#if USED_TPIC_MUXEN_2_ON_OFF_CONTROL
;;;824    					GPIO_Set_DATA(_GPIO_MUX_EN2_TPIC, GPIO_DATA_HIGH);
;;;825    	#endif /* USED_TPIC_MUXEN_2_ON_OFF_CONTROL */
;;;826    				}
;;;827    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;828    #if USED_S3_VDD_OE_INPUT_OUTPUT_CTRL
;;;829    				HAL_Change_S3_VDD_OddEven_Stauts();
;;;830    #endif /* USED_S3_VDD_OE_INPUT_OUTPUT_CTRL */
;;;831    			}
;;;832    		}
;;;833    #endif /* (USED_S3_VDD_OE_INPUT_OUTPUT_CTRL || USED_ECLK_ON_OFF_CONTROL || USED_TPIC_MUXEN_ON_OFF_CONTROL) */
;;;834    
;;;835    		SCRB->PWM_INT_CLR.tBit.tsyncout_int_clr = 0x1;
;;;836    	}
;;;837    }
00000c  bf08              IT       EQ
00000e  bd10              POPEQ    {r4,pc}
000010  4810              LDR      r0,|L11.84|
000012  6a81              LDR      r1,[r0,#0x28]         ;789  ; tHalIntrHandle
000014  2901              CMP      r1,#1                 ;789
000016  d016              BEQ      |L11.70|
000018  6a41              LDR      r1,[r0,#0x24]         ;796  ; tHalIntrHandle
00001a  2901              CMP      r1,#1                 ;796
00001c  bf04              ITT      EQ                    ;798
00001e  2100              MOVEQ    r1,#0                 ;798
000020  6241              STREQ    r1,[r0,#0x24]         ;798  ; tHalIntrHandle
000022  d010              BEQ      |L11.70|
000024  f7fffffe          BL       HAL_GetECLKOnOffControl
000028  2800              CMP      r0,#0                 ;813
00002a  bf18              IT       NE                    ;815
00002c  f7fffffe          BLNE     HAL_ECLK_On
000030  f7fffffe          BL       HAL_GetTPICMuxEnControl
000034  b128              CBZ      r0,|L11.66|
000036  f8d40124          LDR      r0,[r4,#0x124]        ;822
00003a  f0406080          ORR      r0,r0,#0x4000000      ;822
00003e  f8c40124          STR      r0,[r4,#0x124]        ;822
                  |L11.66|
000042  f7fffffe          BL       HAL_Change_S3_VDD_OddEven_Stauts
                  |L11.70|
000046  f8d4008c          LDR      r0,[r4,#0x8c]         ;835
00004a  f0400020          ORR      r0,r0,#0x20           ;835
00004e  f8c4008c          STR      r0,[r4,#0x8c]         ;835
000052  bd10              POP      {r4,pc}
;;;838    
                          ENDP

                  |L11.84|
                          DCD      tHalIntrHandle

                          AREA ||i.PWMDRV_VSync_In_InterruptHandler||, CODE, READONLY, ALIGN=1

                  PWMDRV_VSync_In_InterruptHandler PROC
;;;44     
;;;45     void PWMDRV_VSync_In_InterruptHandler(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;46     {
;;;47     	if(SCRB->SYS_INT_ST.tBit.int_vsyncin != 0)
000004  6981              LDR      r1,[r0,#0x18]
000006  f4112f80          TST      r1,#0x40000
00000a  d005              BEQ      |L12.24|
;;;48     	{
;;;49     		SCRB->PWM_INT_CLR.tBit.vsyncin_int_clr = 0x1;
00000c  f8d0108c          LDR      r1,[r0,#0x8c]
000010  f0410108          ORR      r1,r1,#8
000014  f8c0108c          STR      r1,[r0,#0x8c]
                  |L12.24|
;;;50     #if USED_TOUCH_TUNING_PROCESS
;;;51     #include "app_tuning_process.h"
;;;52     		if(gtuning_ctrl_RawTune_Type.ulVSync_TouchSync_Timing_Index != tHalIntrHandle.ulTSyncInFallingCnt)
;;;53     		{
;;;54     			gtuning_ctrl_RawTune_Type.ulVSync_TouchSync_Timing_Index = tHalIntrHandle.ulTSyncInFallingCnt;
;;;55     			gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_Count = gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_CheckCount;
;;;56     			gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_CheckCount = 0;
;;;57     		}
;;;58     		else
;;;59     		{
;;;60     			gtuning_ctrl_RawTune_Type.ulVsync_and_Touch_Timing_Continuos_CheckCount++;
;;;61     		}
;;;62     #endif /* USED_TOUCH_TUNING_PROCESS */
;;;63     	}
;;;64     
;;;65     	if(SCRB->SYS_INT_ST.tBit.int_tsync_ab != 0)
000018  6981              LDR      r1,[r0,#0x18]
00001a  f4110f00          TST      r1,#0x800000
;;;66     	{
;;;67     		SCRB->PWM_INT_CLR.tBit.tsync_ab_int_clr = 0x1;
;;;68     	}
;;;69     }
00001e  bf08              IT       EQ
000020  4770              BXEQ     lr
000022  f8d0108c          LDR      r1,[r0,#0x8c]         ;67
000026  f0410104          ORR      r1,r1,#4              ;67
00002a  f8c0108c          STR      r1,[r0,#0x8c]         ;67
00002e  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  0a000000          DCB      0x0a,0x00,0x00,0x00
                          DCD      0x00000003
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      0x00000003
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      0x00000003
000020  01000000          DCB      0x01,0x00,0x00,0x00
000024  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x00000003
00002c  01000000          DCB      0x01,0x00,0x00,0x00
000030  0a000000          DCB      0x0a,0x00,0x00,0x00
                          DCD      0x00000003
000038  00000000          DCB      0x00,0x00,0x00,0x00
00003c  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      0x00000003
000044  01000000          DCB      0x01,0x00,0x00,0x00
000048  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      0x00000003
000050  00000000          DCB      0x00,0x00,0x00,0x00
000054  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x00000003
00005c  01000000          DCB      0x01,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  g_tCP_S3_LHB_CONFIG11
000000  dbb66d1b          DCB      0xdb,0xb6,0x6d,0x1b
                  g_tCP_S3_LHB_CONFIG12
000004  dbb66d1b          DCB      0xdb,0xb6,0x6d,0x1b
                  g_tCP_S3_LHB_CONFIG13
000008  dbb66d1b          DCB      0xdb,0xb6,0x6d,0x1b
                  g_tCP_S3_LHB_CONFIG14
00000c  1b000000          DCB      0x1b,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\pwmdrv\\pwmdrv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_pwmdrv_c_b42e3490____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___8_pwmdrv_c_b42e3490____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_pwmdrv_c_b42e3490____REVSH|
#line 402
|__asm___8_pwmdrv_c_b42e3490____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_pwmdrv_c_b42e3490____RRX|
#line 587
|__asm___8_pwmdrv_c_b42e3490____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
