; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\i2c.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\i2c.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\i2c.crf ..\..\Hal\i2c\i2c.c]
                          THUMB

                          AREA ||i.CheckI2CReady||, CODE, READONLY, ALIGN=2

                  CheckI2CReady PROC
;;;181    
;;;182    uint8_t CheckI2CReady(void)
000000  4803              LDR      r0,|L1.16|
;;;183    {
;;;184    	if (g_ConnectedDevice == I2C_CONNECT_TOOL)
000002  78c1              LDRB     r1,[r0,#3]  ; g_ConnectedDevice
000004  2901              CMP      r1,#1
;;;185    	{
;;;186    		return 1;
000006  bf0c              ITE      EQ
000008  2001              MOVEQ    r0,#1
;;;187    	}
;;;188    	else
;;;189    	{
;;;190    		return g_Ready_Complete;
00000a  7840              LDRBNE   r0,[r0,#1]  ; g_Ready_Complete
;;;191    	}
;;;192    }
00000c  4770              BX       lr
;;;193    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      ||area_number.14||

                          AREA ||i.GetCustomData_I2C||, CODE, READONLY, ALIGN=2

                  GetCustomData_I2C PROC
;;;432    
;;;433    void GetCustomData_I2C(uint8_t* pData)
000000  4601              MOV      r1,r0
;;;434    {
;;;435    	memcpy(&g_CustomBuffer_I2C.Data, pData, I2C_DATA_LENGTH);
000002  2240              MOVS     r2,#0x40
000004  4801              LDR      r0,|L2.12|
000006  f7ffbffe          B.W      __aeabi_memcpy
;;;436    	return;
;;;437    }
;;;438    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||+0xa8

                          AREA ||i.I2C_DeInitialize||, CODE, READONLY, ALIGN=1

                  I2C_DeInitialize PROC
;;;1302   
;;;1303   void I2C_DeInitialize(void)
000000  4770              BX       lr
;;;1304   {
;;;1305   //	tCK_ENA_RUN0_t tLocal_CK_ENA_RUN0;
;;;1306   //	Fncp_I2C_SLV_IRQHandler = NULL;
;;;1307   //	/*
;;;1308   //	 * ISP모드가 아닐 경우에만 I2C초기화를 수행한다.
;;;1309   //	 */
;;;1310   //	// I2C SLAVE Setting
;;;1311   //	NVIC_DisableIRQ(I2C_SLV_IRQn);    /* Interrupt Disable */
;;;1312   //	tLocal_CK_ENA_RUN0.ulBulk = SCRB->CK_ENA_RUN0.ulBulk;
;;;1313   //	tLocal_CK_ENA_RUN0.tBit.r_I2C_CLK_ENA = 0;
;;;1314   //	tLocal_CK_ENA_RUN0.tBit._VECTKEY = SCB_VECTKEY_VALUE;
;;;1315   //	SCRB->CK_ENA_RUN0.ulBulk = tLocal_CK_ENA_RUN0.ulBulk;
;;;1316   }
;;;1317   
                          ENDP


                          AREA ||i.I2C_Initialize||, CODE, READONLY, ALIGN=2

                  I2C_Initialize PROC
;;;1251   
;;;1252   void I2C_Initialize(void)
000000  491a              LDR      r1,|L4.108|
;;;1253   {
000002  b510              PUSH     {r4,lr}
;;;1254   	Fncp_I2C_SLV_IRQHandler = &I2C_InterruptHandler;
000004  4818              LDR      r0,|L4.104|
;;;1255   
;;;1256   	GPIO_Set_Mode(_GPIO_SLV_SCL, GPIO_MODE_FUNC_0);
000006  6008              STR      r0,[r1,#0]  ; Fncp_I2C_SLV_IRQHandler
000008  2100              MOVS     r1,#0
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       GPIO_Set_Mode
;;;1257   	GPIO_Set_Mode(_GPIO_SLV_SDA, GPIO_MODE_FUNC_0);
000010  2100              MOVS     r1,#0
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       GPIO_Set_Mode
000018  f04f21e0          MOV      r1,#0xe000e000
00001c  f04f7000          MOV      r0,#0x2000000
000020  2200              MOVS     r2,#0
000022  f8c10200          STR      r0,[r1,#0x200]
000026  f8c10100          STR      r0,[r1,#0x100]
00002a  4811              LDR      r0,|L4.112|
00002c  f8802400          STRB     r2,[r0,#0x400]
;;;1258   
;;;1259   #ifdef MODE_I2C
;;;1260   	// I2C SLAVE Setting
;;;1261   	Init_HidDescriptor();
;;;1262   	Init_HidReportDescriptor();
;;;1263   #endif
;;;1264   
;;;1265   	/*
;;;1266   	 * ISP모드가 아닐 경우에만 I2C초기화를 수행한다.
;;;1267   	 */
;;;1268   	// I2C SLAVE Setting
;;;1269   	NVIC_SetPendingIRQ(I2C_SLV_IRQn);    /* Interrupt Enable */
;;;1270   	NVIC_EnableIRQ(I2C_SLV_IRQn);    /* Interrupt Enable */
;;;1271   	NVIC_SetPriority(I2C_SLV_IRQn, I2C_SLV_IRQn_Priority);
;;;1272   
;;;1273   	I2C->I2C_DEVICE_ADDR.tBit.I2cId = I2C_ADDRESS;
000030  4810              LDR      r0,|L4.116|
000032  f8501f80          LDR      r1,[r0,#0x80]!
000036  f021017f          BIC      r1,r1,#0x7f
00003a  3109              ADDS     r1,r1,#9
00003c  6001              STR      r1,[r0,#0]
;;;1274   	I2C->I2C_SW_RESET.tBit.I2cSWReset = 1;
00003e  6841              LDR      r1,[r0,#4]
000040  f0410101          ORR      r1,r1,#1
000044  6041              STR      r1,[r0,#4]
;;;1275   	I2C->I2C_DEVICE_ADDR.tBit.I2cId	= I2C_ADDRESS;
000046  6801              LDR      r1,[r0,#0]
000048  f021017f          BIC      r1,r1,#0x7f
00004c  3109              ADDS     r1,r1,#9
00004e  6001              STR      r1,[r0,#0]
;;;1276   	I2C->I2C_GLB_CR.ulBulk = 0x000007FF;
000050  f24071ff          MOV      r1,#0x7ff
000054  6081              STR      r1,[r0,#8]
;;;1277   
;;;1278   	// FIFO
;;;1279   	I2C->I2C_FIFO_CR.tBit.TxFifoInit = 1;
000056  69c1              LDR      r1,[r0,#0x1c]
000058  f0410101          ORR      r1,r1,#1
00005c  61c1              STR      r1,[r0,#0x1c]
;;;1280   	I2C->I2C_FIFO_CR.tBit.RxFifoInit = 1;
00005e  69c1              LDR      r1,[r0,#0x1c]
000060  f4417180          ORR      r1,r1,#0x100
000064  61c1              STR      r1,[r0,#0x1c]
;;;1281   
;;;1282   #ifdef I2C_SELECTIVE_SUSPEND
;;;1283   	// Sleep Interrupt Enable
;;;1284   	I2C->I2C_SET_PWR_INT.tBit.SleepItrptEn = 1;
;;;1285   
;;;1286   	// WakeUp Interrupt Enable
;;;1287   	I2C->I2C_SET_PWR_INT.tBit.WakeUpItrptEn = 1;
;;;1288   
;;;1289   	// Power Reg
;;;1290   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBFirst = 0;
;;;1291   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegMSB = (uint8_t)I2C_COMMAND_REGISTER;
;;;1292   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBSleep = 0;
;;;1293   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBOn = 1; // 현재는 Wakeup 상태
;;;1294   
;;;1295   	// Power Command
;;;1296   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdEn = 1;
;;;1297   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrLSBFirst = 0;
;;;1298   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdMSB = I2C__REQUEST_REPORT_POWER_STATE__SLEEP; // Sleep 명령이 오길 기다린다.
;;;1299   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdLSB = I2C__REQUEST_OPCODE__SET_POWER;
;;;1300   #endif
;;;1301   }
000066  bd10              POP      {r4,pc}
;;;1302   
                          ENDP

                  |L4.104|
                          DCD      I2C_InterruptHandler
                  |L4.108|
                          DCD      Fncp_I2C_SLV_IRQHandler
                  |L4.112|
                          DCD      0xe000e019
                  |L4.116|
                          DCD      0x40007000

                          AREA ||i.I2C_InterruptHandler||, CODE, READONLY, ALIGN=2

                  I2C_InterruptHandler PROC
;;;670    
;;;671    void I2C_InterruptHandler(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;672    {
;;;673    	uint16_t nTransCnt = 0;
;;;674    
;;;675    	nTransCnt = I2C->I2C_SLV_DBG.tBit.I2cSlvTrCnt;
000004  4de7              LDR      r5,|L5.932|
000006  f8d500bc          LDR      r0,[r5,#0xbc]
00000a  f3c0490e          UBFX     r9,r0,#16,#15
;;;676    
;;;677    	// Interrupt Clear
;;;678    	I2C->I2C_GLB_SR.tBit.I2C_ITRPT = 0;
00000e  f8d50094          LDR      r0,[r5,#0x94]
000012  f0200001          BIC      r0,r0,#1
000016  f8c50094          STR      r0,[r5,#0x94]
;;;679    
;;;680    	// Reset 관련 처리 중
;;;681    	if (g_bReset == I2C_RESET)
00001a  4ce3              LDR      r4,|L5.936|
00001c  2600              MOVS     r6,#0
00001e  7960              LDRB     r0,[r4,#5]  ; g_bReset
000020  2801              CMP      r0,#1
000022  d10d              BNE      |L5.64|
;;;682    	{
;;;683    		g_bReset = I2C_NORMAL;
000024  7166              STRB     r6,[r4,#5]
;;;684    
;;;685    		// Check GPIO Interrupt
;;;686    		if (IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_LOW)
000026  2004              MOVS     r0,#4
000028  f7fffffe          BL       GPIO_Get_IN
00002c  b918              CBNZ     r0,|L5.54|
;;;687    		{
;;;688    			// Disable GPIO Interrupt
;;;689    			GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
00002e  2101              MOVS     r1,#1
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       GPIO_Set_DATA
                  |L5.54|
;;;690    		}
;;;691    
;;;692    		// Touch, Pen 데이터를 내보내는 작업을 지연시킨다.
;;;693    		g_DelayCheck = 0;
000036  70a6              STRB     r6,[r4,#2]
000038  2000              MOVS     r0,#0
;;;694    		g_StartTime_I2C = 0;
;;;695    		g_DelayTime = 0;
00003a  60e6              STR      r6,[r4,#0xc]  ; g_DelayTime
00003c  e9c4000e          STRD     r0,r0,[r4,#0x38]
                  |L5.64|
;;;696    	}
;;;697    
;;;698    
;;;699    #ifdef I2C_SELECTIVE_SUSPEND
;;;700    	// Sleep Interrupt 처리
;;;701    	if (I2C->I2C_SET_PWR_INT.tBit.SleepItrpt == 1)
;;;702    	{
;;;703    		// Clear
;;;704    		I2C->I2C_SET_PWR_INT.tBit.SleepItrpt = 0;
;;;705    
;;;706    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBSleep = 1; // 현재는 Sleep 상태
;;;707    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBOn = 0;
;;;708    
;;;709    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdMSB = I2C__REQUEST_REPORT_POWER_STATE__ON; // WakeUp 명령이 오길 기다린다.
;;;710    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdLSB = I2C__REQUEST_OPCODE__SET_POWER;
;;;711    	
;;;712    		// Sleep Enable
;;;713    		I2C->I2C_SLP_CR.tBit.SlpCr = 1;
;;;714    		I2C->I2C_SLP_CR.tBit.PrMux = 1;
;;;715    
;;;716    		goto I2C_IRQHANDLER__GOTO_END;
;;;717    	}
;;;718    
;;;719    	// WakeUp Interrupt 처리
;;;720    	if (I2C->I2C_SET_PWR_INT.tBit.WakeUpItrpt == 1)
;;;721    	{
;;;722    		// Clear
;;;723    		I2C->I2C_SET_PWR_INT.tBit.WakeUpItrpt = 0;
;;;724    
;;;725    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBSleep = 0;
;;;726    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBOn = 1;	// 현재는 WakeUp 상태
;;;727    
;;;728    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdMSB = I2C__REQUEST_REPORT_POWER_STATE__SLEEP; // Sleep 명령이 오길 기다린다.
;;;729    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdLSB = I2C__REQUEST_OPCODE__SET_POWER;
;;;730    	
;;;731    		// Sleep Enable
;;;732    		I2C->I2C_SLP_CR.tBit.SlpCr = 0;
;;;733    		I2C->I2C_SLP_CR.tBit.PrMux = 0;
;;;734    
;;;735    		goto I2C_IRQHANDLER__GOTO_END;
;;;736    	}
;;;737    #endif
;;;738    
;;;739    
;;;740    
;;;741    
;;;742    	// Start
;;;743    	if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_STR_ITRPT)
000040  f8d50094          LDR      r0,[r5,#0x94]
000044  2701              MOVS     r7,#1                 ;681
000046  f3c04003          UBFX     r0,r0,#16,#4
00004a  2801              CMP      r0,#1
00004c  d02c              BEQ      |L5.168|
;;;744    	{
;;;745    #if USED_I2C_STOP_STATE_CHECK
;;;746    		g_bSkipStopProcess = NO;
;;;747    #endif
;;;748    
;;;749    		// Command 를 처리하고 있지 않을 때
;;;750    		if (g_RxCommandIndex == 0)
;;;751    		{
;;;752    			if (CheckI2CReady() == 1)
;;;753    			{
;;;754    				if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;755    				{
;;;756    					// 2바이트를 먼저 넣어놓고 (Length)
;;;757    					I2C->I2C_TXFIFO_DATA = g_TxPtr_Common[g_TxIndex_Common];
;;;758    					g_TxIndex_Common += 1;
;;;759    
;;;760    					I2C->I2C_TXFIFO_DATA = g_TxPtr_Common[g_TxIndex_Common];
;;;761    					g_TxIndex_Common += 1;
;;;762    					goto I2C_IRQHANDLER__PASS;
;;;763    				}
;;;764    			}
;;;765    		}
;;;766    		else
;;;767    		{
;;;768    			// 만약 Command 를 처리해야 할 때 Touch, Custom, Pen 데이터의 처리 과정이 겹치게 되면
;;;769    			// Touch, Custom, Pen 데이터를 처리하지 않도록 한다.
;;;770    			if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;771    			{
;;;772    				g_CheckComplete_Common_I2C = DMA_READY;
;;;773    
;;;774    				g_DelayCheck = 0;
;;;775    				g_StartTime_I2C = 0;
;;;776    				g_DelayTime = 0;
;;;777    
;;;778    				// Check GPIO Interrupt
;;;779    				if (IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_LOW)
;;;780    				{
;;;781    					// Disable GPIO Interrupt 
;;;782    					GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;783    				}
;;;784    			}
;;;785    		}
;;;786    
;;;787    
;;;788    I2C_IRQHANDLER__PASS:
;;;789    
;;;790    
;;;791    		if (g_RxCommandIndex > 0)
;;;792    		{
;;;793    			uint16_t*	pCheckRegister = (uint16_t*)g_RxCommand;
;;;794    
;;;795    			if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;796    			{
;;;797    				goto I2C_IRQHANDLER__GOTO_END;
;;;798    			}
;;;799    
;;;800    			switch (*pCheckRegister)
;;;801    			{
;;;802    #ifdef MODE_I2C
;;;803    				// 첫 번째로 받는 명령어
;;;804    				// I2C HID Descriptor 로 응답한다.
;;;805    				case HID_DESCRIPTOR_ADDRESS:
;;;806    				{
;;;807    					uint16_t	Length = 0;
;;;808    					
;;;809    					g_ConnectedDevice = I2C_CONNECT_PC;
;;;810    
;;;811    					// Clear Tx
;;;812    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;813    
;;;814    					// I2C HID Descriptor
;;;815    					Length = sizeof(I2C_HID_DESCRIPTOR) + 2;
;;;816    
;;;817    					// 2 바이트 먼저 입력
;;;818    					I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;819    					I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;820    
;;;821    					g_TxPtr = (uint8_t*)&g_I2CHidDescriptor;
;;;822    					g_TxIndex = 0;
;;;823    					break;
;;;824    				}
;;;825    
;;;826    				// Master 에서 I2C HID Descriptor 의 내용을 참고해서 Report Register 를 명령어로 보낸다.
;;;827    				// HID Report Descriptor 로 응답한다.
;;;828    				case I2C_REPORT_REGISTER:
;;;829    				{
;;;830    					// Clear Tx
;;;831    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;832    
;;;833    					// HID Report Descriptor
;;;834    					g_TxPtr = (uint8_t*)g_HID_ReportDesc_Temp;
;;;835    					g_TxIndex = 0;
;;;836    
;;;837    					// 2바이트 먼저 입력
;;;838    					I2C->I2C_TXFIFO_DATA = g_TxPtr[g_TxIndex];
;;;839    					g_TxIndex += 1;
;;;840    					I2C->I2C_TXFIFO_DATA = g_TxPtr[g_TxIndex];
;;;841    					g_TxIndex += 1;
;;;842    					break;
;;;843    				}
;;;844    #endif
;;;845    				// Master 에서 I2C HID Descriptor 의 내용을 참고해서 Command Register 를 명령어로 보낸다.
;;;846    				case I2C_COMMAND_REGISTER:
;;;847    				{
;;;848    					PI2C__REQUEST pRequest = (PI2C__REQUEST)g_RxCommand;
;;;849    
;;;850    					if (pRequest->OpCode == I2C__REQUEST_OPCODE__GET_REPORT)
;;;851    					{
;;;852    #ifdef MODE_I2C
;;;853    #ifdef ADD_TOUCH
;;;854    						// Report ID : 8 - Get MaxTouch Count (22 00 38 02 23 00)
;;;855    						if (pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__CONTACT_COUNT)
;;;856    						{
;;;857    							uint16_t	Length = 0;
;;;858    							
;;;859    							// Clear Tx
;;;860    							I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;861    
;;;862    							// I2C HID Descriptor
;;;863    							Length = sizeof(TOUCH_MAX_COUNT) + 2;
;;;864    
;;;865    							// 2 바이트 먼저 입력
;;;866    							I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;867    							I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;868    
;;;869    							g_TxPtr = (uint8_t*)&g_MaxTouchCount_I2C;
;;;870    							g_TxIndex = 0;
;;;871    
;;;872    							g_MaxTouchCount_I2C.ReportID = HID_REPORT_ID__CONTACT_COUNT;
;;;873    							g_MaxTouchCount_I2C.Count = HID_MAX_TOUCH;
;;;874    							break;
;;;875    						}
;;;876    
;;;877    						// Report ID : 6 - Get BlobCode (22 00 36 02 23 00)
;;;878    						if (pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__BLOB_CODE)
;;;879    						{
;;;880    							uint16_t	Length = 0;
;;;881    							
;;;882    							// Clear Tx
;;;883    							I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;884    
;;;885    							// I2C HID Descriptor
;;;886    							Length = HID_TOUCH_BLOB_LENGTH + 2;
;;;887    
;;;888    							// 2 바이트 먼저 입력
;;;889    							I2C->I2C_TXFIFO_DATA = (uint8_t)(Length & 0x00FF);
;;;890    							I2C->I2C_TXFIFO_DATA = (uint8_t)(Length >> 8);
;;;891    
;;;892    							g_TxPtr = (uint8_t*)u8_HID_Touch_Blob;
;;;893    							g_TxIndex = 0;
;;;894    							break;
;;;895    						}
;;;896    #endif
;;;897    #endif
;;;898    					}
;;;899    
;;;900    					break;
;;;901    				}
;;;902    
;;;903    				case I2C_DATA_REGISTER:
;;;904    				{
;;;905    					break;
;;;906    				}
;;;907    
;;;908    				case I2C_INPUT_REGISTER:
;;;909    				{
;;;910    					break;
;;;911    				}
;;;912    
;;;913    				case I2C_OUTPUT_REGISTER:
;;;914    				{
;;;915    					break;
;;;916    				}
;;;917    			}
;;;918    		}
;;;919    
;;;920    	}
;;;921    	else if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_BYTE_ITRPT)
00004e  f8d50094          LDR      r0,[r5,#0x94]
;;;922    	{
;;;923    		// Master --> Slave
;;;924    		if (I2C->I2C_GLB_SR.tBit.I2cSlvRdWrFlag == 0)
;;;925    		{
;;;926    			//
;;;927    			// I2C 장치에 연결할 때
;;;928    			//
;;;929    			if (g_ConnectedDevice > I2C_CONNECT_PC)
;;;930    			{
;;;931    				if (nTransCnt == 1)
;;;932    				{
;;;933    					usRegAddr = (uint8_t)(I2C->I2C_RXFIFO_DATA & 0xFF);
;;;934    					usRegAddr <<= 8;
;;;935    				}
;;;936    				else if (nTransCnt == 2)
;;;937    				{
;;;938    					usRegAddr |= (uint8_t)(I2C->I2C_RXFIFO_DATA & 0xFF);
;;;939    
;;;940    					if (g_ConnectedDevice_FirstCheck == 0)
;;;941    					{
;;;942    						if ((swap_uint16(usRegAddr) == HID_DESCRIPTOR_ADDRESS) || (swap_uint16(usRegAddr) == I2C_COMMAND_REGISTER) || (swap_uint16(usRegAddr) == I2C_OUTPUT_REGISTER))
;;;943    						{
;;;944    							// PC 에 연결했다고 판단한다.
;;;945    							g_ConnectedDevice_FirstCheck = 1;
;;;946    							g_ConnectedDevice = I2C_CONNECT_PC;
;;;947    
;;;948    							g_RxCommand[0] = (uint8_t)(usRegAddr >> 8);
;;;949    							g_RxCommand[1] = (uint8_t)(usRegAddr & 0x00FF);
;;;950    							g_RxCommandIndex = 2;
;;;951    							goto I2C_IRQHANDLER__GOTO_END;
;;;952    						}
;;;953    
;;;954    						// 장치랑 연결하게 되면 가장 먼저 0x0150 을 받게 된다!!
;;;955    						if (usRegAddr == 0x0150)
;;;956    						{
;;;957    							g_ConnectedDevice = I2C_CONNECT_TOOL_0x150;
;;;958    						}
;;;959    					}
;;;960    
;;;961    					g_ConnectedDevice_FirstCheck = 1;
;;;962    
;;;963    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;	// Clear
;;;964    
;;;965    					if (protocol_GetMappedPointer != NULL)
;;;966    					{
;;;967    						rmi_read_ptr = rmi_write_ptr = (*protocol_GetMappedPointer)(usRegAddr);
;;;968    						i2c_sent_byte = i2c_received_byte = 0;
;;;969    
;;;970    						if (rmi_read_ptr != NULL)
;;;971    						{
;;;972    							I2C->I2C_TXFIFO_DATA = *(rmi_read_ptr++);
;;;973    							if (protocol_ClearInterrupt != NULL)
000052  f8df8358          LDR      r8,|L5.940|
000056  f3c04003          UBFX     r0,r0,#16,#4          ;921
00005a  2803              CMP      r0,#3                 ;921
;;;974    							{
;;;975    								(*protocol_ClearInterrupt)(usRegAddr + i2c_sent_byte);
;;;976    							}
;;;977    
;;;978    							i2c_sent_byte++;
;;;979    						}
;;;980    					}
;;;981    				}
;;;982    				else if (nTransCnt > 2)
;;;983    				{
;;;984    					if (rmi_write_ptr != NULL)
;;;985    					{
;;;986    						*(rmi_write_ptr++) = I2C->I2C_RXFIFO_DATA;
;;;987    						i2c_received_byte++;
;;;988    					}
;;;989    				}
;;;990    			}
;;;991    
;;;992    			//
;;;993    			// PC 에 연결할 때
;;;994    			//
;;;995    			else
;;;996    			{
;;;997    				if (I2C->I2C_FIFO_SR2.tBit.RxFifoEmpty == 0)
;;;998    				{
;;;999    					uint8_t ReadData = 0;
;;;1000   
;;;1001   					ReadData = (uint8_t)(I2C->I2C_RXFIFO_DATA & 0xFF);
;;;1002   					if (g_RxCommandIndex < 100)
;;;1003   					{
;;;1004   						g_RxCommand[g_RxCommandIndex] = ReadData;
;;;1005   						g_RxCommandIndex += 1;
;;;1006   
;;;1007   						// OUTPUT 데이터가 들어올 때는 Delay 작업을 하지 않는다.
;;;1008   						if ((g_RxCommand[0] != (uint8_t)I2C_OUTPUT_REGISTER))
;;;1009   						{
;;;1010   							// Touch, Pen 데이터를 내보내는 작업을 지연시킨다.
;;;1011   							g_DelayCheck = 0;
;;;1012   							g_StartTime_I2C = 0;
;;;1013   							g_DelayTime = 0;
;;;1014   						}
;;;1015   					}
;;;1016   				}
;;;1017   			}
;;;1018   		}
;;;1019   		// Slave --> Master
;;;1020   		else
;;;1021   		{
;;;1022   			// g_ConnectedDevice 값이 1인 경우에는 Slave --> Master 방향으로 데이터가 처리 될 수 없다.
;;;1023   			// 이 경우는 PC 에 연결되었다고 판단하게 되므로 g_ConnectedDevice 값을 0 으로 바꿔서 처리 해야 한다.
;;;1024   			if (g_ConnectedDevice == I2C_CONNECT_TOOL)
;;;1025   			{
;;;1026   				g_ConnectedDevice = I2C_CONNECT_PC;
;;;1027   				g_Ready_Complete = I2C_READY;
;;;1028   				g_Ready = I2C_READY;
;;;1029   			}
;;;1030   
;;;1031   			//
;;;1032   			// I2C 장치에 연결할 때
;;;1033   			//
;;;1034   			if (g_ConnectedDevice > I2C_CONNECT_PC) // Tool 에 연결되었고 0x0150 데이터를 받았다는 것 까지 체크 한다.
;;;1035   			{
;;;1036   				if (rmi_read_ptr)
;;;1037   				{
;;;1038   					I2C->I2C_TXFIFO_DATA = *(rmi_read_ptr++);
;;;1039   					if (protocol_ClearInterrupt != NULL)
;;;1040   					{
;;;1041   						(*protocol_ClearInterrupt)(usRegAddr + i2c_sent_byte);
;;;1042   					}
;;;1043   
;;;1044   					i2c_sent_byte++;
;;;1045   				}
;;;1046   			}
;;;1047   
;;;1048   			//
;;;1049   			// PC 에 연결할 때
;;;1050   			//
;;;1051   			else
;;;1052   			{
;;;1053   				g_Ready = I2C_READY;
;;;1054   
;;;1055   				// HID Descriptor 처리 하는 부분
;;;1056   				if (g_RxCommandIndex > 0)
;;;1057   				{
;;;1058   					I2C->I2C_TXFIFO_DATA = g_TxPtr[g_TxIndex];
;;;1059   					g_TxIndex += 1;
;;;1060   				}
;;;1061   
;;;1062   				if (CheckI2CReady() == 1)
;;;1063   				{
;;;1064   					if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;1065   					{
;;;1066   						I2C->I2C_TXFIFO_DATA = g_TxPtr_Common[g_TxIndex_Common];
;;;1067   						g_TxIndex_Common += 1;
;;;1068   //						goto I2C_IRQHANDLER__GOTO_END;
;;;1069   
;;;1070   #if USED_I2C_STOP_STATE_CHECK
;;;1071   						if (I2C->I2C_SLV_DBG.tBit.I2cSlvTrCnt == I2C_SLV_TR_MAX_CNT_ && I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_STP_ITRPT)
;;;1072   						{
;;;1073   							I2C_StopProcess();
;;;1074   							g_bSkipStopProcess = YES;
;;;1075   						}
;;;1076   #endif
;;;1077   					}
;;;1078   				}
;;;1079   			}
;;;1080   
;;;1081   		}
;;;1082   	}
;;;1083   	// Stop
;;;1084   	else if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_STP_ITRPT)
00005c  f8d50094          LDR      r0,[r5,#0x94]
000060  d056              BEQ      |L5.272|
000062  f3c04003          UBFX     r0,r0,#16,#4
000066  2802              CMP      r0,#2
000068  f0008129          BEQ.W    |L5.702|
;;;1085   	{
;;;1086   #if USED_I2C_STOP_STATE_CHECK
;;;1087   		if (!g_bSkipStopProcess)
;;;1088   		{
;;;1089   			I2C_StopProcess();
;;;1090   		}
;;;1091   #else
;;;1092   		if (g_RxCommandIndex > 0)
;;;1093   		{
;;;1094   			uint16_t*	pCheckRegister = (uint16_t*)g_RxCommand;
;;;1095   
;;;1096   			switch (*pCheckRegister)
;;;1097   			{
;;;1098   				// Master 에서 I2C HID Descriptor 의 내용을 참고해서 Command Register 를 명령어로 보낸다.
;;;1099   				case I2C_COMMAND_REGISTER:
;;;1100   				{
;;;1101   					PI2C__REQUEST pRequest = (PI2C__REQUEST)g_RxCommand;
;;;1102   
;;;1103   					// Set Power (22 00 00 08)
;;;1104   					if ((pRequest->I2C_Request_Power.PowerState == I2C__REQUEST_REPORT_POWER_STATE__ON) &&
;;;1105   						(pRequest->OpCode == I2C__REQUEST_OPCODE__SET_POWER))
;;;1106   					{
;;;1107   						g_TxPtr = NULL;
;;;1108   						g_TxIndex = 0;
;;;1109   
;;;1110   						g_Ready = I2C_READY;
;;;1111   						break;
;;;1112   					}
;;;1113   					// Sleep
;;;1114   					else if ((pRequest->I2C_Request_Power.PowerState == I2C__REQUEST_REPORT_POWER_STATE__SLEEP) &&
;;;1115   							 (pRequest->OpCode == I2C__REQUEST_OPCODE__SET_POWER))
;;;1116   					{
;;;1117   						g_TxPtr = NULL;
;;;1118   						g_TxIndex = 0;
;;;1119   
;;;1120   						g_Ready = I2C_NOT_READY;
;;;1121   						break;
;;;1122   					}
;;;1123   					// Reset (22 00 00 01)
;;;1124   					else if ((pRequest->I2C_Request_Common.ReportType == I2C__REQUEST_REPORT_TYPE__NONE) &&
;;;1125   						(pRequest->OpCode == I2C__REQUEST_OPCODE__RESET))
;;;1126   					{
;;;1127   						g_TxPtr = NULL;
;;;1128   						g_TxIndex = 0;
;;;1129   
;;;1130   						g_bReset = I2C_RESET;
;;;1131   						break;
;;;1132   					}
;;;1133   #ifdef MODE_I2C
;;;1134   					// Device Mode - (22 00 37 03 23 00 05 00 07 02 00)
;;;1135   					else if ((pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__DEVICE_MODE) &&
;;;1136   						(pRequest->OpCode == I2C__REQUEST_OPCODE__SET_REPORT))
;;;1137   					{
;;;1138   						g_TxPtr = NULL;
;;;1139   						g_TxIndex = 0;
;;;1140   
;;;1141   						memcpy((uint8_t*)&g_DeviceMode_I2C, (uint8_t*)&pRequest->Data[0], sizeof(SETREPORT_DEVICE_MODE));
;;;1142   						break;
;;;1143   					}
;;;1144   					// Latency Mode (22 00 35 03 23 04 00 05 00 or 01)
;;;1145   					else if ((pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__LATENCY_MODE) &&
;;;1146   						(pRequest->OpCode == I2C__REQUEST_OPCODE__SET_REPORT))
;;;1147   					{
;;;1148   						g_TxPtr = NULL;
;;;1149   						g_TxIndex = 0;
;;;1150   
;;;1151   						memcpy((uint8_t*)&g_LatencyMode_I2C, (uint8_t*)&pRequest->Data[0], sizeof(SETREPORT_LATENCY_MODE));
;;;1152   						break;
;;;1153   					}
;;;1154   #endif
;;;1155   
;;;1156   					break;
;;;1157   				}
;;;1158   				case I2C_OUTPUT_REGISTER:
;;;1159   				{
;;;1160   					PI2C__OUTPUT pOutputData = (PI2C__OUTPUT)g_RxCommand;
;;;1161   					custom_tool=1;
;;;1162   
;;;1163   #ifdef ADD_CUSTOM
;;;1164   					if (pOutputData->ReportID == HID_REPORT_ID__CUSTOM_OUT)
;;;1165   					{
;;;1166   						GetCustomData_I2C(&pOutputData->ReportID);
;;;1167   						RecieveCustomData_I2C(&g_CustomBuffer_I2C);
;;;1168   
;;;1169   						// Init Command 처리 없이 Custom OUT 데이터가 먼저 들어올 수 있다.
;;;1170   						// 이 경우에는 여기서 Ready 를 체크 해줘야 한다.
;;;1171   						g_Ready = I2C_READY;
;;;1172   
;;;1173   						// Custom App 를 사용해서 F/W Download 를 했을 경우 Custom OUT 을 마지막으로
;;;1174   						// 장치가 Reboot 되는데 이후에 Init Command 없이 곧 바로 Touch 가 동작할 수 있어야 한다.
;;;1175   						// 그래서 Delay 작업을 하면 안 된다.
;;;1176   						g_DelayCheck = 1;
;;;1177   					}
;;;1178   #endif
;;;1179   					break;
;;;1180   				}
;;;1181   			}
;;;1182   
;;;1183   			memset(g_RxCommand, 0, 100);
;;;1184   			g_RxCommandIndex = 0;
;;;1185   		}
;;;1186   
;;;1187   		// Touch, Custom, Pen
;;;1188   		else if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;1189   		{
;;;1190   			g_CheckComplete_Common_I2C = DMA_READY;
;;;1191   			g_GpioDisable = I2C_GPIO_DISABLE;
;;;1192   		}
;;;1193   
;;;1194   #ifdef MODE_I2C
;;;1195   		GetDelayTime();
;;;1196   #endif
;;;1197   
;;;1198   		if (g_Ready == I2C_READY)
;;;1199   		{
;;;1200   			g_Ready_Complete = I2C_READY;
;;;1201   		}
;;;1202   		else
;;;1203   		{
;;;1204   			g_Ready_Complete = I2C_NOT_READY;
;;;1205   			g_StartTime_I2C = 0;
;;;1206   			g_DelayTime = 0;
;;;1207   		}
;;;1208   
;;;1209   		if (g_GpioDisable == I2C_GPIO_DISABLE)
;;;1210   		{
;;;1211   			// Check GPIO Interrupt
;;;1212   			if (IS_GPIO_PIN(_GPIO_TP_INTR) == GPIO_DATA_LOW)
;;;1213   			{
;;;1214   				// Disable GPIO Interrupt
;;;1215   				GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_HIGH);
;;;1216   			}
;;;1217   
;;;1218   			g_GpioDisable = I2C_GPIO_NORMAL;
;;;1219   		}
;;;1220   
;;;1221   #ifdef MODE_I2C
;;;1222   		// Reset 명령에 대한 응답을 준비한다.
;;;1223   		if (g_bReset == I2C_RESET)
;;;1224   		{
;;;1225   			Make_EmptyI2CData();
;;;1226   		}
;;;1227   #endif
;;;1228   #endif
;;;1229   	}
;;;1230   	else if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_ADDR_ITRPT)
00006c  f8d50094          LDR      r0,[r5,#0x94]
000070  f3c04003          UBFX     r0,r0,#16,#4
000074  2804              CMP      r0,#4
;;;1231   	{
;;;1232   		if (g_ConnectedDevice > I2C_CONNECT_PC)
;;;1233   		{
;;;1234   			if (rmi_read_ptr)
;;;1235   			{
;;;1236   				I2C->I2C_TXFIFO_DATA = *(rmi_read_ptr++);
;;;1237   				if (protocol_ClearInterrupt != NULL)
;;;1238   				{
;;;1239   					(*protocol_ClearInterrupt)(usRegAddr + i2c_sent_byte);
;;;1240   				}
;;;1241   
;;;1242   				i2c_sent_byte++;
;;;1243   			}
;;;1244   		}
;;;1245   	}
;;;1246   
;;;1247   I2C_IRQHANDLER__GOTO_END:
;;;1248   
;;;1249   	return;
;;;1250   }
000076  bf18              IT       NE
000078  e8bd87f0          POPNE    {r4-r10,pc}
00007c  78e0              LDRB     r0,[r4,#3]            ;1232  ; g_ConnectedDevice
00007e  2800              CMP      r0,#0                 ;1232
000080  bf1a              ITTE     NE                    ;1234
000082  6a60              LDRNE    r0,[r4,#0x24]         ;1234  ; rmi_read_ptr
000084  2800              CMPNE    r0,#0                 ;1234
000086  e8bd87f0          POPEQ    {r4-r10,pc}
00008a  f8101b01          LDRB     r1,[r0],#1            ;1236
00008e  f8c510a0          STR      r1,[r5,#0xa0]         ;1236
000092  6260              STR      r0,[r4,#0x24]         ;1237  ; rmi_read_ptr
000094  f8d81000          LDR      r1,[r8,#0]            ;1237  ; protocol_ClearInterrupt
000098  2900              CMP      r1,#0                 ;1237
00009a  d053              BEQ      |L5.324|
00009c  8960              LDRH     r0,[r4,#0xa]          ;1239  ; usRegAddr
00009e  8da2              LDRH     r2,[r4,#0x2c]         ;1239  ; i2c_sent_byte
0000a0  4410              ADD      r0,r0,r2              ;1239
0000a2  b280              UXTH     r0,r0                 ;1239
                  |L5.164|
0000a4  4788              BLX      r1                    ;1239
0000a6  e04d              B        |L5.324|
                  |L5.168|
0000a8  6920              LDR      r0,[r4,#0x10]         ;750  ; g_RxCommandIndex
0000aa  b1b8              CBZ      r0,|L5.220|
0000ac  79e0              LDRB     r0,[r4,#7]            ;770  ; g_CheckComplete_Common_I2C
0000ae  2800              CMP      r0,#0                 ;770
0000b0  bf18              IT       NE
0000b2  e8bd87f0          POPNE    {r4-r10,pc}
0000b6  71e7              STRB     r7,[r4,#7]            ;772
0000b8  70a6              STRB     r6,[r4,#2]            ;774
0000ba  2100              MOVS     r1,#0                 ;774
0000bc  60e6              STR      r6,[r4,#0xc]          ;776  ; g_DelayTime
0000be  e9c4110e          STRD     r1,r1,[r4,#0x38]      ;776
0000c2  2004              MOVS     r0,#4                 ;779
0000c4  f7fffffe          BL       GPIO_Get_IN
0000c8  2800              CMP      r0,#0                 ;779
0000ca  bf18              IT       NE
0000cc  e8bd87f0          POPNE    {r4-r10,pc}
0000d0  2101              MOVS     r1,#1                 ;782
0000d2  2004              MOVS     r0,#4                 ;782
0000d4  f7fffffe          BL       GPIO_Set_DATA
0000d8  e8bd87f0          POP      {r4-r10,pc}
                  |L5.220|
0000dc  78e0              LDRB     r0,[r4,#3]  ; g_ConnectedDevice
0000de  2801              CMP      r0,#1
0000e0  bf19              ITTEE    NE
0000e2  7860              LDRBNE   r0,[r4,#1]  ; g_Ready_Complete
0000e4  2801              CMPNE    r0,#1                 ;752
0000e6  79e0              LDRBEQ   r0,[r4,#7]            ;754  ; g_CheckComplete_Common_I2C
0000e8  2800              CMPEQ    r0,#0                 ;754
0000ea  bf18              IT       NE
0000ec  e8bd87f0          POPNE    {r4-r10,pc}
0000f0  e9d41007          LDRD     r1,r0,[r4,#0x1c]
0000f4  5c0a              LDRB     r2,[r1,r0]            ;757
0000f6  f8c520a0          STR      r2,[r5,#0xa0]         ;757
0000fa  f1000001          ADD      r0,r0,#1              ;757
0000fe  6220              STR      r0,[r4,#0x20]         ;760  ; g_TxIndex_Common
000100  5c09              LDRB     r1,[r1,r0]            ;760
000102  f8c510a0          STR      r1,[r5,#0xa0]         ;760
000106  f1000001          ADD      r0,r0,#1              ;760
00010a  6220              STR      r0,[r4,#0x20]         ;762  ; g_TxIndex_Common
00010c  e8bd87f0          POP      {r4-r10,pc}
                  |L5.272|
000110  f0100f08          TST      r0,#8                 ;924
000114  d01b              BEQ      |L5.334|
000116  78e0              LDRB     r0,[r4,#3]            ;1024  ; g_ConnectedDevice
000118  2801              CMP      r0,#1                 ;1024
00011a  d07d              BEQ      |L5.536|
00011c  2800              CMP      r0,#0                 ;1034
00011e  d07c              BEQ      |L5.538|
000120  6a60              LDR      r0,[r4,#0x24]         ;1036  ; rmi_read_ptr
000122  2800              CMP      r0,#0                 ;1036
000124  bf08              IT       EQ
000126  e8bd87f0          POPEQ    {r4-r10,pc}
00012a  f8101b01          LDRB     r1,[r0],#1            ;1038
00012e  f8c510a0          STR      r1,[r5,#0xa0]         ;1038
000132  6260              STR      r0,[r4,#0x24]         ;1039  ; rmi_read_ptr
000134  f8d81000          LDR      r1,[r8,#0]            ;1039  ; protocol_ClearInterrupt
000138  b121              CBZ      r1,|L5.324|
00013a  8960              LDRH     r0,[r4,#0xa]          ;1041  ; usRegAddr
00013c  8da2              LDRH     r2,[r4,#0x2c]         ;1041  ; i2c_sent_byte
00013e  4410              ADD      r0,r0,r2              ;1041
000140  b280              UXTH     r0,r0                 ;1041
000142  4788              BLX      r1                    ;1041
                  |L5.324|
000144  6ae0              LDR      r0,[r4,#0x2c]         ;1044  ; i2c_sent_byte
000146  1c40              ADDS     r0,r0,#1              ;1044
000148  62e0              STR      r0,[r4,#0x2c]         ;1044  ; i2c_sent_byte
00014a  e8bd87f0          POP      {r4-r10,pc}
                  |L5.334|
00014e  78e1              LDRB     r1,[r4,#3]            ;929  ; g_ConnectedDevice
000150  4897              LDR      r0,|L5.944|
000152  2900              CMP      r1,#0                 ;929
000154  d077              BEQ      |L5.582|
000156  f1b90f01          CMP      r9,#1                 ;931
00015a  d014              BEQ      |L5.390|
00015c  f1b90f02          CMP      r9,#2                 ;936
000160  d01d              BEQ      |L5.414|
000162  bf98              IT       LS
000164  e8bd87f0          POPLS    {r4-r10,pc}
000168  6aa0              LDR      r0,[r4,#0x28]         ;984  ; rmi_write_ptr
00016a  2800              CMP      r0,#0                 ;984
00016c  bf08              IT       EQ
00016e  e8bd87f0          POPEQ    {r4-r10,pc}
000172  f8d510a4          LDR      r1,[r5,#0xa4]         ;986
000176  f8001b01          STRB     r1,[r0],#1            ;986
00017a  62a0              STR      r0,[r4,#0x28]         ;987  ; rmi_write_ptr
00017c  6b20              LDR      r0,[r4,#0x30]         ;987  ; i2c_received_byte
00017e  1c40              ADDS     r0,r0,#1              ;987
000180  6320              STR      r0,[r4,#0x30]         ;987  ; i2c_received_byte
000182  e8bd87f0          POP      {r4-r10,pc}
                  |L5.390|
000186  f8d500a4          LDR      r0,[r5,#0xa4]         ;933
00018a  b2c0              UXTB     r0,r0                 ;933
00018c  8160              STRH     r0,[r4,#0xa]          ;933
00018e  8960              LDRH     r0,[r4,#0xa]          ;934  ; usRegAddr
000190  f64f71ff          MOV      r1,#0xffff            ;934
000194  ea012000          AND      r0,r1,r0,LSL #8       ;934
000198  8160              STRH     r0,[r4,#0xa]          ;934
00019a  e8bd87f0          POP      {r4-r10,pc}
                  |L5.414|
00019e  f8d510a4          LDR      r1,[r5,#0xa4]         ;938
0001a2  8962              LDRH     r2,[r4,#0xa]          ;938  ; usRegAddr
0001a4  b2c9              UXTB     r1,r1                 ;938
0001a6  4311              ORRS     r1,r1,r2              ;938
0001a8  8161              STRH     r1,[r4,#0xa]          ;938
0001aa  7921              LDRB     r1,[r4,#4]            ;940  ; g_ConnectedDevice_FirstCheck
0001ac  b9d1              CBNZ     r1,|L5.484|
0001ae  8961              LDRH     r1,[r4,#0xa]          ;942  ; usRegAddr
0001b0  020a              LSLS     r2,r1,#8              ;942
0001b2  ea422111          ORR      r1,r2,r1,LSR #8       ;942
0001b6  b289              UXTH     r1,r1                 ;942
0001b8  2202              MOVS     r2,#2                 ;673
0001ba  2920              CMP      r1,#0x20              ;942
0001bc  d038              BEQ      |L5.560|
0001be  8961              LDRH     r1,[r4,#0xa]          ;942  ; usRegAddr
0001c0  020b              LSLS     r3,r1,#8              ;942
0001c2  ea432111          ORR      r1,r3,r1,LSR #8       ;942
0001c6  b289              UXTH     r1,r1                 ;942
0001c8  2922              CMP      r1,#0x22              ;942
0001ca  d031              BEQ      |L5.560|
0001cc  8961              LDRH     r1,[r4,#0xa]          ;942  ; usRegAddr
0001ce  020b              LSLS     r3,r1,#8              ;942
0001d0  ea432111          ORR      r1,r3,r1,LSR #8       ;942
0001d4  b289              UXTH     r1,r1                 ;942
0001d6  2925              CMP      r1,#0x25              ;942
0001d8  d02a              BEQ      |L5.560|
0001da  8960              LDRH     r0,[r4,#0xa]          ;955  ; usRegAddr
0001dc  f5b07fa8          CMP      r0,#0x150             ;955
0001e0  bf08              IT       EQ                    ;957
0001e2  70e2              STRBEQ   r2,[r4,#3]            ;957
                  |L5.484|
0001e4  7127              STRB     r7,[r4,#4]            ;961
0001e6  f8d5009c          LDR      r0,[r5,#0x9c]         ;963
0001ea  f0400001          ORR      r0,r0,#1              ;963
0001ee  f8c5009c          STR      r0,[r5,#0x9c]         ;963
0001f2  4870              LDR      r0,|L5.948|
0001f4  6801              LDR      r1,[r0,#0]            ;965  ; protocol_GetMappedPointer
0001f6  2900              CMP      r1,#0                 ;965
0001f8  bf08              IT       EQ
0001fa  e8bd87f0          POPEQ    {r4-r10,pc}
0001fe  8960              LDRH     r0,[r4,#0xa]          ;967  ; usRegAddr
000200  4788              BLX      r1                    ;967
000202  62a0              STR      r0,[r4,#0x28]         ;967  ; rmi_write_ptr
000204  6326              STR      r6,[r4,#0x30]         ;968  ; i2c_received_byte
000206  62e6              STR      r6,[r4,#0x2c]         ;970  ; i2c_sent_byte
000208  6260              STR      r0,[r4,#0x24]         ;970  ; rmi_read_ptr
00020a  2800              CMP      r0,#0                 ;970
00020c  bf08              IT       EQ
00020e  e8bd87f0          POPEQ    {r4-r10,pc}
000212  f8101b01          LDRB     r1,[r0],#1            ;972
000216  e001              B        |L5.540|
                  |L5.536|
000218  e033              B        |L5.642|
                  |L5.538|
00021a  e035              B        |L5.648|
                  |L5.540|
00021c  f8c510a0          STR      r1,[r5,#0xa0]         ;972
000220  6260              STR      r0,[r4,#0x24]         ;973  ; rmi_read_ptr
000222  f8d81000          LDR      r1,[r8,#0]            ;973  ; protocol_ClearInterrupt
000226  2900              CMP      r1,#0                 ;973
000228  bf18              IT       NE                    ;975
00022a  8960              LDRHNE   r0,[r4,#0xa]          ;975  ; usRegAddr
00022c  d08a              BEQ      |L5.324|
00022e  e739              B        |L5.164|
                  |L5.560|
000230  7127              STRB     r7,[r4,#4]            ;945
000232  70e6              STRB     r6,[r4,#3]            ;946
000234  8961              LDRH     r1,[r4,#0xa]          ;948  ; usRegAddr
000236  0a09              LSRS     r1,r1,#8              ;948
000238  7001              STRB     r1,[r0,#0]            ;948
00023a  8961              LDRH     r1,[r4,#0xa]          ;949  ; usRegAddr
00023c  7041              STRB     r1,[r0,#1]            ;949
00023e  6122              STR      r2,[r4,#0x10]         ;951  ; g_RxCommandIndex
000240  e8bd87f0          POP      {r4-r10,pc}
000244  e7ff              B        |L5.582|
                  |L5.582|
000246  f8d510c8          LDR      r1,[r5,#0xc8]         ;997
00024a  f4113f80          TST      r1,#0x10000           ;997
00024e  bf18              IT       NE
000250  e8bd87f0          POPNE    {r4-r10,pc}
000254  f8d510a4          LDR      r1,[r5,#0xa4]         ;1001
000258  b2ca              UXTB     r2,r1                 ;1001
00025a  6921              LDR      r1,[r4,#0x10]         ;1002  ; g_RxCommandIndex
00025c  2964              CMP      r1,#0x64              ;1002
00025e  bf28              IT       CS
000260  e8bd87f0          POPCS    {r4-r10,pc}
000264  5442              STRB     r2,[r0,r1]            ;1004
000266  1c49              ADDS     r1,r1,#1              ;1004
000268  6121              STR      r1,[r4,#0x10]         ;1008  ; g_RxCommandIndex
00026a  7800              LDRB     r0,[r0,#0]            ;1008  ; g_RxCommand
00026c  2825              CMP      r0,#0x25              ;1008
00026e  bf08              IT       EQ
000270  e8bd87f0          POPEQ    {r4-r10,pc}
000274  70a6              STRB     r6,[r4,#2]            ;1011
000276  2100              MOVS     r1,#0                 ;1011
000278  60e6              STR      r6,[r4,#0xc]          ;1013  ; g_DelayTime
00027a  e9c4110e          STRD     r1,r1,[r4,#0x38]      ;1013
00027e  e8bd87f0          POP      {r4-r10,pc}
                  |L5.642|
000282  70e6              STRB     r6,[r4,#3]            ;1026
000284  7067              STRB     r7,[r4,#1]            ;1027
000286  7027              STRB     r7,[r4,#0]            ;1028
                  |L5.648|
000288  7027              STRB     r7,[r4,#0]            ;1053
00028a  6920              LDR      r0,[r4,#0x10]         ;1056  ; g_RxCommandIndex
00028c  b130              CBZ      r0,|L5.668|
00028e  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;1056
000292  5c09              LDRB     r1,[r1,r0]            ;1058
000294  f8c510a0          STR      r1,[r5,#0xa0]         ;1058
000298  1c40              ADDS     r0,r0,#1              ;1058
00029a  61a0              STR      r0,[r4,#0x18]         ;1059  ; g_TxIndex
                  |L5.668|
00029c  7860              LDRB     r0,[r4,#1]            ;1059  ; g_Ready_Complete
00029e  2801              CMP      r0,#1                 ;1062
0002a0  bf06              ITTE     EQ                    ;1064
0002a2  79e0              LDRBEQ   r0,[r4,#7]            ;1064  ; g_CheckComplete_Common_I2C
0002a4  2800              CMPEQ    r0,#0                 ;1064
0002a6  e8bd87f0          POPNE    {r4-r10,pc}
0002aa  e9d41007          LDRD     r1,r0,[r4,#0x1c]
0002ae  5c09              LDRB     r1,[r1,r0]            ;1066
0002b0  f8c510a0          STR      r1,[r5,#0xa0]         ;1066
0002b4  f1000001          ADD      r0,r0,#1              ;1066
0002b8  6220              STR      r0,[r4,#0x20]         ;1067  ; g_TxIndex_Common
0002ba  e8bd87f0          POP      {r4-r10,pc}
                  |L5.702|
0002be  6920              LDR      r0,[r4,#0x10]         ;1092  ; g_RxCommandIndex
0002c0  b378              CBZ      r0,|L5.802|
0002c2  483b              LDR      r0,|L5.944|
0002c4  8800              LDRH     r0,[r0,#0]            ;1096
0002c6  2822              CMP      r0,#0x22              ;1096
0002c8  d002              BEQ      |L5.720|
0002ca  2825              CMP      r0,#0x25              ;1096
0002cc  d02a              BEQ      |L5.804|
0002ce  e043              B        |L5.856|
                  |L5.720|
0002d0  4837              LDR      r0,|L5.944|
0002d2  7881              LDRB     r1,[r0,#2]            ;1104
0002d4  f0110f0f          TST      r1,#0xf               ;1104
0002d8  d104              BNE      |L5.740|
0002da  78c2              LDRB     r2,[r0,#3]            ;1105
0002dc  f002020f          AND      r2,r2,#0xf            ;1105
0002e0  2a08              CMP      r2,#8                 ;1105
0002e2  d004              BEQ      |L5.750|
                  |L5.740|
0002e4  f001020f          AND      r2,r1,#0xf            ;1114
0002e8  2a01              CMP      r2,#1                 ;1114
0002ea  d109              BNE      |L5.768|
0002ec  e003              B        |L5.758|
                  |L5.750|
0002ee  6166              STR      r6,[r4,#0x14]         ;1108  ; g_TxPtr
0002f0  61a6              STR      r6,[r4,#0x18]         ;1110  ; g_TxIndex
0002f2  7027              STRB     r7,[r4,#0]            ;1110
0002f4  e030              B        |L5.856|
                  |L5.758|
0002f6  78c2              LDRB     r2,[r0,#3]            ;1115
0002f8  f002020f          AND      r2,r2,#0xf            ;1115
0002fc  2a08              CMP      r2,#8                 ;1115
0002fe  d003              BEQ      |L5.776|
                  |L5.768|
000300  f0110f30          TST      r1,#0x30              ;1124
000304  d128              BNE      |L5.856|
000306  e003              B        |L5.784|
                  |L5.776|
000308  6166              STR      r6,[r4,#0x14]         ;1118  ; g_TxPtr
00030a  61a6              STR      r6,[r4,#0x18]         ;1120  ; g_TxIndex
00030c  7026              STRB     r6,[r4,#0]            ;1120
00030e  e023              B        |L5.856|
                  |L5.784|
000310  78c0              LDRB     r0,[r0,#3]            ;1125
000312  f000000f          AND      r0,r0,#0xf            ;1125
000316  2801              CMP      r0,#1                 ;1125
000318  d11e              BNE      |L5.856|
00031a  6166              STR      r6,[r4,#0x14]         ;1128  ; g_TxPtr
00031c  61a6              STR      r6,[r4,#0x18]         ;1130  ; g_TxIndex
00031e  7167              STRB     r7,[r4,#5]            ;1130
000320  e01a              B        |L5.856|
                  |L5.802|
000322  e01f              B        |L5.868|
                  |L5.804|
000324  4822              LDR      r0,|L5.944|
000326  7227              STRB     r7,[r4,#8]            ;1161
000328  7901              LDRB     r1,[r0,#4]            ;1164
00032a  2909              CMP      r1,#9                 ;1164
00032c  d114              BNE      |L5.856|
00032e  1d01              ADDS     r1,r0,#4              ;1166
000330  2240              MOVS     r2,#0x40              ;1166
000332  30a8              ADDS     r0,r0,#0xa8           ;1166
000334  f7fffffe          BL       __aeabi_memcpy
000338  481f              LDR      r0,|L5.952|
00033a  7881              LDRB     r1,[r0,#2]            ;1167
00033c  2909              CMP      r1,#9                 ;1167
00033e  d109              BNE      |L5.852|
000340  78c1              LDRB     r1,[r0,#3]            ;1167
000342  f0110f01          TST      r1,#1                 ;1167
000346  d002              BEQ      |L5.846|
000348  f7fffffe          BL       HidReadWrite__Read_I2C
00034c  e002              B        |L5.852|
                  |L5.846|
00034e  1c80              ADDS     r0,r0,#2              ;1167
000350  f7fffffe          BL       HidReadWrite__Write
                  |L5.852|
000354  7027              STRB     r7,[r4,#0]            ;1171
000356  70a7              STRB     r7,[r4,#2]            ;1176
                  |L5.856|
000358  2164              MOVS     r1,#0x64              ;1183
00035a  4815              LDR      r0,|L5.944|
00035c  f7fffffe          BL       __aeabi_memclr
000360  6126              STR      r6,[r4,#0x10]         ;1185  ; g_RxCommandIndex
000362  e004              B        |L5.878|
                  |L5.868|
000364  79e0              LDRB     r0,[r4,#7]            ;1188  ; g_CheckComplete_Common_I2C
000366  2800              CMP      r0,#0                 ;1188
000368  bf04              ITT      EQ                    ;1190
00036a  71e7              STRBEQ   r7,[r4,#7]            ;1190
00036c  71a7              STRBEQ   r7,[r4,#6]            ;1191
                  |L5.878|
00036e  7820              LDRB     r0,[r4,#0]            ;1198  ; g_Ready
000370  2801              CMP      r0,#1                 ;1198
000372  bf08              IT       EQ                    ;1200
000374  7067              STRBEQ   r7,[r4,#1]            ;1200
000376  d004              BEQ      |L5.898|
000378  7066              STRB     r6,[r4,#1]            ;1204
00037a  2100              MOVS     r1,#0                 ;1204
00037c  60e6              STR      r6,[r4,#0xc]          ;1206  ; g_DelayTime
00037e  e9c4110e          STRD     r1,r1,[r4,#0x38]      ;1206
                  |L5.898|
000382  79a0              LDRB     r0,[r4,#6]            ;1209  ; g_GpioDisable
000384  2801              CMP      r0,#1                 ;1209
000386  bf18              IT       NE
000388  e8bd87f0          POPNE    {r4-r10,pc}
00038c  2004              MOVS     r0,#4                 ;1212
00038e  f7fffffe          BL       GPIO_Get_IN
000392  b918              CBNZ     r0,|L5.924|
000394  2101              MOVS     r1,#1                 ;1215
000396  2004              MOVS     r0,#4                 ;1215
000398  f7fffffe          BL       GPIO_Set_DATA
                  |L5.924|
00039c  71a6              STRB     r6,[r4,#6]            ;1218
00039e  e8bd87f0          POP      {r4-r10,pc}
;;;1251   
                          ENDP

0003a2  0000              DCW      0x0000
                  |L5.932|
                          DCD      0x40007000
                  |L5.936|
                          DCD      ||area_number.14||
                  |L5.940|
                          DCD      protocol_ClearInterrupt
                  |L5.944|
                          DCD      ||.bss||
                  |L5.948|
                          DCD      protocol_GetMappedPointer
                  |L5.952|
                          DCD      ||.bss||+0xa6

                          AREA ||i.QueueCommonData_I2C||, CODE, READONLY, ALIGN=2

                  QueueCommonData_I2C PROC
;;;487    
;;;488    void QueueCommonData_I2C(void)
000000  b510              PUSH     {r4,lr}
;;;489    {
;;;490    	if ((g_CheckComplete_Common_I2C == DMA_READY) && (g_RxCommandIndex == 0))
000002  4c12              LDR      r4,|L6.76|
000004  79e0              LDRB     r0,[r4,#7]  ; g_CheckComplete_Common_I2C
000006  2801              CMP      r0,#1
000008  bf06              ITTE     EQ
00000a  6920              LDREQ    r0,[r4,#0x10]  ; g_RxCommandIndex
00000c  2800              CMPEQ    r0,#0
;;;491    	{
;;;492    		if (StaticQueue_CheckEmpty(&g_Queue_Common) == 0)
;;;493    		{
;;;494    			// Pop
;;;495    			if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Common_I2C) == TRUE)
;;;496    			{
;;;497                    // Flag
;;;498                    g_CheckComplete_Common_I2C = DMA_NOT_READY;
;;;499    
;;;500                    // Pointer
;;;501                    g_TxPtr_Common = (uint8_t*)&g_Common_I2C;
;;;502                    g_TxIndex_Common = 0;
;;;503    
;;;504                    // Clear Tx
;;;505                    I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;506    
;;;507                    // GPIO Interrupt Enable
;;;508                    GPIO_Set_DATA(_GPIO_TP_INTR, GPIO_DATA_LOW);
;;;509                }
;;;510    		}
;;;511    	}
;;;512    
;;;513    	return;
;;;514    }
00000e  bd10              POPNE    {r4,pc}
000010  480f              LDR      r0,|L6.80|
000012  f7fffffe          BL       StaticQueue_CheckEmpty
000016  2800              CMP      r0,#0                 ;492
000018  bf18              IT       NE
00001a  bd10              POPNE    {r4,pc}
00001c  490d              LDR      r1,|L6.84|
00001e  480c              LDR      r0,|L6.80|
000020  f7fffffe          BL       StaticQueue_Pop
000024  2801              CMP      r0,#1                 ;495
000026  bf18              IT       NE
000028  bd10              POPNE    {r4,pc}
00002a  2100              MOVS     r1,#0                 ;498
00002c  71e1              STRB     r1,[r4,#7]            ;498
00002e  4809              LDR      r0,|L6.84|
000030  e9c40107          STRD     r0,r1,[r4,#0x1c]      ;501
000034  4808              LDR      r0,|L6.88|
000036  f8501f9c          LDR      r1,[r0,#0x9c]!        ;505
00003a  f0410101          ORR      r1,r1,#1              ;505
00003e  6001              STR      r1,[r0,#0]            ;505
000040  2100              MOVS     r1,#0                 ;508
000042  e8bd4010          POP      {r4,lr}               ;508
000046  2004              MOVS     r0,#4                 ;508
000048  f7ffbffe          B.W      GPIO_Set_DATA
;;;515    
                          ENDP

                  |L6.76|
                          DCD      ||area_number.14||
                  |L6.80|
                          DCD      g_Queue_Common
                  |L6.84|
                          DCD      ||.bss||+0x64
                  |L6.88|
                          DCD      0x40007000

                          AREA ||i.RecieveCustomData_I2C||, CODE, READONLY, ALIGN=1

                  RecieveCustomData_I2C PROC
;;;403    
;;;404    void RecieveCustomData_I2C(PHJ_HID_CONTROL_STRUCT_I2C pData)
000000  7881              LDRB     r1,[r0,#2]
;;;405    {
;;;406    	switch (pData->Data.PacketID)
000002  2909              CMP      r1,#9
;;;407    	{
;;;408    		case HID_REPORT_ID__CUSTOM_OUT:
;;;409    		{
;;;410    			if (pData->Data.DeviceID_b.bRead)
;;;411    			{
;;;412    				HidReadWrite__Read_I2C(pData);
;;;413    			}
;;;414    			else
;;;415    			{
;;;416    				HidReadWrite__Write(&pData->Data);
;;;417    			}
;;;418    
;;;419    			break;
;;;420    		}
;;;421    	}
;;;422    
;;;423    	return;
;;;424    }
000004  bf18              IT       NE
000006  4770              BXNE     lr
000008  78c1              LDRB     r1,[r0,#3]            ;410
00000a  f0110f01          TST      r1,#1                 ;410
00000e  d001              BEQ      |L7.20|
000010  f7ffbffe          B.W      HidReadWrite__Read_I2C
                  |L7.20|
000014  1c80              ADDS     r0,r0,#2              ;412
000016  f7ffbffe          B.W      HidReadWrite__Write
;;;425    
                          ENDP


                          AREA ||i.SendCustomData_I2C||, CODE, READONLY, ALIGN=2

                  SendCustomData_I2C PROC
;;;381    
;;;382    void SendCustomData_I2C(PHJ_HID_CONTROL_STRUCT_I2C pUserData)
000000  b510              PUSH     {r4,lr}
;;;383    {
000002  4604              MOV      r4,r0
;;;384    	if (StaticQueue_CheckInit(&g_Queue_Common) == 0)
000004  480a              LDR      r0,|L8.48|
000006  f7fffffe          BL       StaticQueue_CheckInit
00000a  2800              CMP      r0,#0
;;;385    	{
;;;386    		// Init Queue
;;;387    		StaticQueue_Init(&g_Queue_Common);
00000c  bf04              ITT      EQ
00000e  4808              LDREQ    r0,|L8.48|
000010  f7fffffe          BLEQ     StaticQueue_Init
;;;388    	}
;;;389    
;;;390    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
000014  4806              LDR      r0,|L8.48|
000016  f7fffffe          BL       StaticQueue_CheckFull
00001a  2801              CMP      r0,#1
;;;391    	{
;;;392    		// 큐의 최대치를 넘어가면..  (데이터 손실)
;;;393    		goto SENDCUSTOMDATA_I2C__GOTO_END;
;;;394    	}
;;;395    
;;;396    	pUserData->I2C_Length = sizeof(HJ_HID_CONTROL_STRUCT_I2C);
;;;397    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
;;;398    
;;;399    SENDCUSTOMDATA_I2C__GOTO_END:
;;;400    
;;;401    	return;
;;;402    }
00001c  bf08              IT       EQ
00001e  bd10              POPEQ    {r4,pc}
000020  2042              MOVS     r0,#0x42              ;396
000022  8020              STRH     r0,[r4,#0]            ;396
000024  4621              MOV      r1,r4                 ;397
000026  e8bd4010          POP      {r4,lr}               ;397
00002a  4801              LDR      r0,|L8.48|
00002c  f7ffbffe          B.W      StaticQueue_Push
;;;403    
                          ENDP

                  |L8.48|
                          DCD      g_Queue_Common

                          AREA ||i.swap_uint16||, CODE, READONLY, ALIGN=1

                  swap_uint16 PROC
;;;426    
;;;427    uint16_t swap_uint16(uint16_t val)
000000  0201              LSLS     r1,r0,#8
;;;428    {
;;;429    	return (val << 8) | (val >> 8);
000002  ea412010          ORR      r0,r1,r0,LSR #8
000006  b280              UXTH     r0,r0
;;;430    }
000008  4770              BX       lr
;;;431    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_RxCommand
                          %        100
                  g_Common_I2C
                          %        66
                  g_CustomBuffer_I2C
                          %        66

                          AREA ||.data||, DATA, ALIGN=2

                  g_I2C
                          DCD      0x40007080

                          AREA ||area_number.14||, DATA, ALIGN=3

                          EXPORTAS ||area_number.14||, ||.data||
                  g_Ready
000000  00                DCB      0x00
                  g_Ready_Complete
000001  00                DCB      0x00
                  g_DelayCheck
000002  00                DCB      0x00
                  g_ConnectedDevice
000003  01                DCB      0x01
                  g_ConnectedDevice_FirstCheck
000004  00                DCB      0x00
                  g_bReset
000005  00                DCB      0x00
                  g_GpioDisable
000006  00                DCB      0x00
                  g_CheckComplete_Common_I2C
000007  01                DCB      0x01
                  custom_tool
000008  0000              DCB      0x00,0x00
                  usRegAddr
00000a  0000              DCW      0x0000
                  g_DelayTime
                          DCD      0x00000000
                  g_RxCommandIndex
                          DCD      0x00000000
                  g_TxPtr
                          DCD      0x00000000
                  g_TxIndex
                          DCD      0x00000000
                  g_TxPtr_Common
                          DCD      0x00000000
                  g_TxIndex_Common
                          DCD      0x00000000
                  rmi_read_ptr
                          DCD      0x00000000
                  rmi_write_ptr
                          DCD      0x00000000
                  i2c_sent_byte
                          DCD      0x00000000
                  i2c_received_byte
                          DCD      0x00000000
                          DCD      0x00000000
                  g_StartTime_I2C
000038  00000000          DCQ      0x0000000000000000
00003c  00000000

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  g_TxPtr_Touch
                          DCD      0x00000000

                          AREA ||area_number.16||, DATA, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.data||
                  g_TxIndex_Touch
                          DCD      0x00000000

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  g_TxPtr_Pen
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  g_TxIndex_Pen
                          DCD      0x00000000

                          AREA ||area_number.19||, DATA, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.data||
                  g_TxPtr_Custom
                          DCD      0x00000000

                          AREA ||area_number.20||, DATA, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.data||
                  g_TxIndex_Custom
                          DCD      0x00000000

                          AREA ||area_number.21||, DATA, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.data||
                  g_CheckComplete_Custom_I2C
000000  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\i2c\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___5_i2c_c_g_I2C____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____REVSH|
#line 402
|__asm___5_i2c_c_g_I2C____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____RRX|
#line 587
|__asm___5_i2c_c_g_I2C____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
