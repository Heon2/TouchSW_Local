; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\timer_tick.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\timer_tick.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Hal\gdma -I..\..\Hal\syscfg -I..\..\Hal\flitf -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\dbgserial -I..\..\Hal\tlvds -I..\..\Tuning_process -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -D_USE_WITH_BOOT_ --wchar32 --omf_browse=.\bin\timer_tick.crf ..\..\Hal\timer\timer_tick.c]
                          THUMB

                          AREA ||i.TimerTick_DeInitialize||, CODE, READONLY, ALIGN=2

                  TimerTick_DeInitialize PROC
;;;82     
;;;83     void TimerTick_DeInitialize(void)
000000  b510              PUSH     {r4,lr}
;;;84     {
;;;85     	TIMER_StopTimer(TIMER_NUM_0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       TIMER_StopTimer
;;;86     	Fncp_Systick_IRQHandler = NULL;
000008  4901              LDR      r1,|L1.16|
00000a  2000              MOVS     r0,#0
00000c  6008              STR      r0,[r1,#0]  ; Fncp_Systick_IRQHandler
;;;87     }
00000e  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L1.16|
                          DCD      Fncp_Systick_IRQHandler

                          AREA ||i.TimerTick_Initialize||, CODE, READONLY, ALIGN=2

                  TimerTick_Initialize PROC
;;;68     
;;;69     void TimerTick_Initialize(uint32_t clk)
000000  b500              PUSH     {lr}
;;;70     {
;;;71     	tTimerOpHandleInfo_t TimerOpHandleInfo;
;;;72     	Fncp_Systick_IRQHandler = &TimerTick_InterruptHandler;
000002  4a0b              LDR      r2,|L2.48|
000004  b083              SUB      sp,sp,#0xc            ;70
000006  4909              LDR      r1,|L2.44|
;;;73     #define TIMER_NUM_0			(0)
;;;74     	TimerOpHandleInfo.ulLoadBGCount = 0;
000008  6011              STR      r1,[r2,#0]  ; Fncp_Systick_IRQHandler
00000a  2100              MOVS     r1,#0
;;;75     	TimerOpHandleInfo.ulLoadCount = SYSTICK_MAXCOUNT;
00000c  f44f4280          MOV      r2,#0x4000
000010  e9cd2101          STRD     r2,r1,[sp,#4]
;;;76     	TimerOpHandleInfo.ulTimerUnit = TIMER_NUM_0;
;;;77     	_timer_clock_ = clk;
000014  9100              STR      r1,[sp,#0]
000016  4907              LDR      r1,|L2.52|
000018  6048              STR      r0,[r1,#4]  ; _timer_clock_
;;;78     	TIMER_SetPeriodicMode(&TimerOpHandleInfo);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       TIMER_SetPeriodicMode
;;;79     //	SysTick_Config(SYSTICK_MAXCOUNT);
;;;80     	TIMER_StartTimer(TIMER_NUM_0);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       TIMER_StartTimer
;;;81     }
000026  b003              ADD      sp,sp,#0xc
000028  bd00              POP      {pc}
;;;82     
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      TimerTick_InterruptHandler
                  |L2.48|
                          DCD      Fncp_Systick_IRQHandler
                  |L2.52|
                          DCD      ||.data||

                          AREA ||i.TimerTick_InterruptHandler||, CODE, READONLY, ALIGN=2

                  TimerTick_InterruptHandler PROC
;;;38     
;;;39     void TimerTick_InterruptHandler(void)
000000  4805              LDR      r0,|L3.24|
;;;40     {
;;;41     	//56bit counter를 만들기 위해 32bit카운트 변수 추가
;;;42     	if (_timertick_high_rank_count_ == 0)
000002  6801              LDR      r1,[r0,#0]  ; _timertick_high_rank_count_
000004  2900              CMP      r1,#0
;;;43     	{
;;;44     		_timertick_high_rank_count_ = SYSTICK_MAX_HIGHT_RANK_COUNT;
000006  bf0e              ITEE     EQ
000008  f04f31ff          MOVEQ    r1,#0xffffffff
;;;45     	}
;;;46     	else
;;;47     	{
;;;48     		--_timertick_high_rank_count_;
00000c  6801              LDRNE    r1,[r0,#0]  ; _timertick_high_rank_count_
00000e  1e49              SUBNE    r1,r1,#1
000010  6001              STR      r1,[r0,#0]  ; _timertick_high_rank_count_
;;;49     	}
;;;50     
;;;51     #if USED_QUEUECOMMONDATA_SEND_Timer_Tick
;;;52     #ifdef MODE_I2C
;;;53     	QueueCommonData_I2C();
;;;54     #else
;;;55     	QueueCommonData_USB();
000012  f7ffbffe          B.W      QueueCommonData_USB
;;;56     #endif
;;;57     #else /* USED_QUEUECOMMONDATA_SEND_Timer_Tick */
;;;58     	if(tHalIntrHandle.ulUSBSendData_TimerTick)
;;;59     	{
;;;60     #ifdef MODE_I2C
;;;61     		QueueCommonData_I2C();
;;;62     #else
;;;63     		QueueCommonData_USB();
;;;64     #endif
;;;65     	}
;;;66     #endif /* USED_QUEUECOMMONDATA_SEND_Timer_Tick */
;;;67     }
;;;68     
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      ||.data||

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;211     */
;;;212    void delay_ms(uint32_t time)
000000  b4f0              PUSH     {r4-r7}
000002  f8dfc080          LDR      r12,|L4.132|
;;;213    {
;;;214    	delay_us(time * 1000);
000006  f44f717a          MOV      r1,#0x3e8
00000a  4348              MULS     r0,r1,r0
00000c  f8dc1004          LDR      r1,[r12,#4]  ; _timer_clock_
000010  f44f4280          MOV      r2,#0x4000
000014  fbb2f1f1          UDIV     r1,r2,r1
000018  f1a1030a          SUB      r3,r1,#0xa
00001c  fbb0f1f3          UDIV     r1,r0,r3
000020  fbb0f5f3          UDIV     r5,r0,r3
000024  fb030611          MLS      r6,r3,r1,r0
000028  2400              MOVS     r4,#0
00002a  0412              LSLS     r2,r2,#16
00002c  2d00              CMP      r5,#0
00002e  dd14              BLE      |L4.90|
                  |L4.48|
000030  f8d201b8          LDR      r0,[r2,#0x1b8]        ;213
000034  f3c0010d          UBFX     r1,r0,#0,#14          ;213
                  |L4.56|
000038  f8d201b8          LDR      r0,[r2,#0x1b8]        ;213
00003c  f3c0000d          UBFX     r0,r0,#0,#14          ;213
000040  1a08              SUBS     r0,r1,r0              ;213
000042  bf48              IT       MI                    ;213
000044  f5004080          ADDMI    r0,r0,#0x4000         ;213
000048  f8dc7004          LDR      r7,[r12,#4]           ;213  ; _timer_clock_
00004c  fbb0f7f7          UDIV     r7,r0,r7              ;213
000050  429f              CMP      r7,r3                 ;213
000052  d3f1              BCC      |L4.56|
000054  1c64              ADDS     r4,r4,#1              ;213
000056  42ac              CMP      r4,r5                 ;213
000058  dbea              BLT      |L4.48|
                  |L4.90|
00005a  f8d201b8          LDR      r0,[r2,#0x1b8]        ;213
00005e  f3c0010d          UBFX     r1,r0,#0,#14          ;213
000062  bf00              NOP                            ;213
                  |L4.100|
000064  f8d201b8          LDR      r0,[r2,#0x1b8]        ;213
000068  f3c0000d          UBFX     r0,r0,#0,#14          ;213
00006c  1a08              SUBS     r0,r1,r0              ;213
00006e  bf48              IT       MI                    ;213
000070  f5004080          ADDMI    r0,r0,#0x4000         ;213
000074  f8dc3004          LDR      r3,[r12,#4]           ;213  ; _timer_clock_
000078  fbb0f0f3          UDIV     r0,r0,r3              ;213
00007c  42b0              CMP      r0,r6                 ;213
00007e  d3f1              BCC      |L4.100|
;;;215    //	int i, count, remainder, block;
;;;216    //	block = SYSTICK_MAXCOUNT/(1000*_timer_clock_) -10;
;;;217    //	count = time / block;//200ms단위로 딜레이
;;;218    //	remainder = time % block;//나머지 딜레이
;;;219    //	for (i=0;i<count;++i)
;;;220    //	{
;;;221    //		delay_ms_useSystick(block);
;;;222    //	}
;;;223    //	delay_ms_useSystick(remainder);
;;;224    }
000080  bcf0              POP      {r4-r7}
000082  4770              BX       lr
                          ENDP

                  |L4.132|
                          DCD      ||.data||

                          AREA ||i.delay_ms_useSystick||, CODE, READONLY, ALIGN=2

                  delay_ms_useSystick PROC
;;;162     */
;;;163    void delay_ms_useSystick(uint32_t time)
000000  b470              PUSH     {r4-r6}
;;;164    {
;;;165    	uint32_t start = getSysTick();
000002  f04f4480          MOV      r4,#0x40000000
000006  f8d411b8          LDR      r1,[r4,#0x1b8]
;;;166    	do {
;;;167    	} while (getMSfromTick(getElapsedSYSTICK(start))<time);
00000a  4b0d              LDR      r3,|L5.64|
00000c  f3c1020d          UBFX     r2,r1,#0,#14          ;165
000010  f04f3cff          MOV      r12,#0xffffffff
                  |L5.20|
000014  f8d411b8          LDR      r1,[r4,#0x1b8]
000018  f3c1010d          UBFX     r1,r1,#0,#14
00001c  1a51              SUBS     r1,r2,r1
00001e  bf48              IT       MI
000020  f5014180          ADDMI    r1,r1,#0x4000
000024  685d              LDR      r5,[r3,#4]  ; _timer_clock_
000026  eb050645          ADD      r6,r5,r5,LSL #1
00002a  ebc615c5          RSB      r5,r6,r5,LSL #7
00002e  eb0c05c5          ADD      r5,r12,r5,LSL #3
000032  fbb1f1f5          UDIV     r1,r1,r5
000036  4281              CMP      r1,r0
000038  d3ec              BCC      |L5.20|
;;;168    }
00003a  bc70              POP      {r4-r6}
00003c  4770              BX       lr
;;;169    /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      ||.data||

                          AREA ||i.delay_systick||, CODE, READONLY, ALIGN=1

                  delay_systick PROC
;;;176     */
;;;177    void delay_systick(uint32_t tick_count)
000000  f04f4380          MOV      r3,#0x40000000
;;;178    {
;;;179    	uint32_t start = getSysTick();
000004  f8d311b8          LDR      r1,[r3,#0x1b8]
000008  f3c1020d          UBFX     r2,r1,#0,#14
                  |L6.12|
00000c  f8d311b8          LDR      r1,[r3,#0x1b8]
000010  f3c1010d          UBFX     r1,r1,#0,#14
000014  1a51              SUBS     r1,r2,r1
000016  bf48              IT       MI
000018  f5014180          ADDMI    r1,r1,#0x4000
;;;180    	do {
;;;181    	} while (getElapsedSYSTICK(start)<tick_count);
00001c  4281              CMP      r1,r0
00001e  d3f5              BCC      |L6.12|
;;;182    }
000020  4770              BX       lr
;;;183    /**
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;191    
;;;192    void delay_us(uint32_t time)
000000  b4f0              PUSH     {r4-r7}
;;;193    {
;;;194    	int i,count,remainder,block;
;;;195    	block = SYSTICK_MAXCOUNT / _timer_clock_ -10;
000002  4d1e              LDR      r5,|L7.124|
000004  6869              LDR      r1,[r5,#4]  ; _timer_clock_
000006  f44f4280          MOV      r2,#0x4000
00000a  fbb2f1f1          UDIV     r1,r2,r1
00000e  f1a1030a          SUB      r3,r1,#0xa
;;;196    	count = time / block;//200ms단위로 딜레이
;;;197    	remainder = time % block;//나머지 딜레이
000012  fbb0f1f3          UDIV     r1,r0,r3
000016  fbb0f4f3          UDIV     r4,r0,r3              ;196
00001a  fb030611          MLS      r6,r3,r1,r0
00001e  0412              LSLS     r2,r2,#16
;;;198    	for (i=0; i<count; ++i)
000020  f04f0c00          MOV      r12,#0
000024  2c00              CMP      r4,#0
000026  dd14              BLE      |L7.82|
                  |L7.40|
000028  f8d201b8          LDR      r0,[r2,#0x1b8]        ;193
00002c  f3c0010d          UBFX     r1,r0,#0,#14          ;193
                  |L7.48|
000030  f8d201b8          LDR      r0,[r2,#0x1b8]        ;193
000034  f3c0000d          UBFX     r0,r0,#0,#14          ;193
000038  1a08              SUBS     r0,r1,r0              ;193
00003a  bf48              IT       MI                    ;193
00003c  f5004080          ADDMI    r0,r0,#0x4000         ;193
000040  686f              LDR      r7,[r5,#4]            ;193  ; _timer_clock_
000042  fbb0f7f7          UDIV     r7,r0,r7              ;193
000046  429f              CMP      r7,r3                 ;193
000048  d3f2              BCC      |L7.48|
00004a  f10c0c01          ADD      r12,r12,#1            ;193
00004e  45a4              CMP      r12,r4
000050  dbea              BLT      |L7.40|
                  |L7.82|
000052  f8d201b8          LDR      r0,[r2,#0x1b8]
000056  f3c0010d          UBFX     r1,r0,#0,#14
00005a  bf00              NOP      
                  |L7.92|
00005c  f8d201b8          LDR      r0,[r2,#0x1b8]
000060  f3c0000d          UBFX     r0,r0,#0,#14
000064  1a08              SUBS     r0,r1,r0
000066  bf48              IT       MI
000068  f5004080          ADDMI    r0,r0,#0x4000
00006c  686b              LDR      r3,[r5,#4]  ; _timer_clock_
00006e  fbb0f0f3          UDIV     r0,r0,r3
000072  42b0              CMP      r0,r6
000074  d3f2              BCC      |L7.92|
;;;199    	{
;;;200    		delay_us_useSystick(block);
;;;201    	}
;;;202    	delay_us_useSystick(remainder);
;;;203    }
000076  bcf0              POP      {r4-r7}
000078  4770              BX       lr
;;;204    /**
                          ENDP

00007a  0000              DCW      0x0000
                  |L7.124|
                          DCD      ||.data||

                          AREA ||i.delay_us_useSystick||, CODE, READONLY, ALIGN=2

                  delay_us_useSystick PROC
;;;148     */
;;;149    void delay_us_useSystick(uint32_t time)
000000  b410              PUSH     {r4}
;;;150    {
;;;151    	uint32_t start = getSysTick();
000002  f04f4380          MOV      r3,#0x40000000
000006  f8d311b8          LDR      r1,[r3,#0x1b8]
;;;152    	do {
;;;153    	} while (getUSfromTick(getElapsedSYSTICK(start))<time);
00000a  f8dfc028          LDR      r12,|L8.52|
00000e  f3c1020d          UBFX     r2,r1,#0,#14          ;151
000012  bf00              NOP                            ;151
                  |L8.20|
000014  f8d311b8          LDR      r1,[r3,#0x1b8]        ;151
000018  f3c1010d          UBFX     r1,r1,#0,#14          ;151
00001c  1a51              SUBS     r1,r2,r1              ;151
00001e  bf48              IT       MI                    ;151
000020  f5014180          ADDMI    r1,r1,#0x4000         ;151
000024  f8dc4004          LDR      r4,[r12,#4]  ; _timer_clock_
000028  fbb1f1f4          UDIV     r1,r1,r4
00002c  4281              CMP      r1,r0
00002e  d3f1              BCC      |L8.20|
;;;154    }
000030  bc10              POP      {r4}
000032  4770              BX       lr
;;;155    /**
                          ENDP

                  |L8.52|
                          DCD      ||.data||

                          AREA ||i.getElapsedLongSYSTICK||, CODE, READONLY, ALIGN=2

                  getElapsedLongSYSTICK PROC
;;;118     */
;;;119    uint64_t getElapsedLongSYSTICK(uint64_t start)
000000  4a0e              LDR      r2,|L9.60|
;;;120    {
000002  b410              PUSH     {r4}
;;;121    	int64_t elapsedTick;
;;;122    	elapsedTick = start-getLongSysTick();
000004  6813              LDR      r3,[r2,#0]  ; _timertick_high_rank_count_
000006  2200              MOVS     r2,#0
000008  0394              LSLS     r4,r2,#14
00000a  ea444c93          ORR      r12,r4,r3,LSR #18
00000e  039c              LSLS     r4,r3,#14
000010  f04f4380          MOV      r3,#0x40000000
000014  f8d331b8          LDR      r3,[r3,#0x1b8]
000018  ea4c0202          ORR      r2,r12,r2
00001c  f3c3030d          UBFX     r3,r3,#0,#14
000020  4323              ORRS     r3,r3,r4
000022  1ac0              SUBS     r0,r0,r3
000024  4191              SBCS     r1,r1,r2
;;;123    	if (elapsedTick < 0)
;;;124    	{
;;;125    		elapsedTick = SYSTICK_MAX_LONG_COUNT + elapsedTick;
;;;126    	}
;;;127    	return elapsedTick;
;;;128    }
000026  bf5c              ITT      PL
000028  bc10              POPPL    {r4}
00002a  4770              BXPL     lr
00002c  f64372fe          MOV      r2,#0x3ffe            ;125
000030  1880              ADDS     r0,r0,r2              ;125
000032  bc10              POP      {r4}
000034  f1410100          ADC      r1,r1,#0              ;125
000038  4770              BX       lr
;;;129    /**
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      ||.data||

                          AREA ||i.getElapsedSYSTICK||, CODE, READONLY, ALIGN=1

                  getElapsedSYSTICK PROC
;;;100    
;;;101    uint32_t getElapsedSYSTICK(uint32_t start)
000000  f04f4180          MOV      r1,#0x40000000
;;;102    {
;;;103    	int32_t elapsedTick;
;;;104    	elapsedTick = start - getSysTick();
000004  f8d111b8          LDR      r1,[r1,#0x1b8]
000008  f3c1010d          UBFX     r1,r1,#0,#14
00000c  1a40              SUBS     r0,r0,r1
00000e  bf48              IT       MI
000010  f5004080          ADDMI    r0,r0,#0x4000
;;;105    	if (elapsedTick < 0)
;;;106    	{
;;;107    		elapsedTick += SYSTICK_MAXCOUNT;
;;;108    	}
;;;109    	return elapsedTick;
;;;110    }
000014  4770              BX       lr
;;;111    /**
                          ENDP


                          AREA ||i.getElapsedSYSTICK2||, CODE, READONLY, ALIGN=1

                  getElapsedSYSTICK2 PROC
;;;92       */
;;;93     uint32_t getElapsedSYSTICK2(uint32_t start,uint32_t end)
000000  1a40              SUBS     r0,r0,r1
;;;94     {
;;;95     	int32_t elapsedTick;
;;;96     	elapsedTick = start-end;
000002  bf48              IT       MI
000004  f5004080          ADDMI    r0,r0,#0x4000
;;;97     	if (elapsedTick < 0) elapsedTick += SYSTICK_MAXCOUNT;
;;;98     	return elapsedTick;
;;;99     }
000008  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.getElapsedTime_us||, CODE, READONLY, ALIGN=2

                  getElapsedTime_us PROC
;;;136     */
;;;137    uint64_t getElapsedTime_us(uint64_t start_tick)
000000  b570              PUSH     {r4-r6,lr}
000002  4a10              LDR      r2,|L12.68|
000004  f8d2c000          LDR      r12,[r2,#0]  ; _timertick_high_rank_count_
000008  2300              MOVS     r3,#0
00000a  039d              LSLS     r5,r3,#14
00000c  ea45449c          ORR      r4,r5,r12,LSR #18
000010  ea4f358c          LSL      r5,r12,#14
000014  f04f4c80          MOV      r12,#0x40000000
000018  f8dcc1b8          LDR      r12,[r12,#0x1b8]
00001c  431c              ORRS     r4,r4,r3
00001e  f3cc0c0d          UBFX     r12,r12,#0,#14
000022  ea450c0c          ORR      r12,r5,r12
000026  ebb0000c          SUBS     r0,r0,r12
00002a  41a1              SBCS     r1,r1,r4
;;;138    {
00002c  d505              BPL      |L12.58|
00002e  f6437cfe          MOV      r12,#0x3ffe
000032  eb10000c          ADDS     r0,r0,r12
000036  f1410100          ADC      r1,r1,#0
                  |L12.58|
;;;139    	return getUSfromTick(getElapsedLongSYSTICK(start_tick));
00003a  6852              LDR      r2,[r2,#4]  ; _timer_clock_
00003c  f7fffffe          BL       __aeabi_uldivmod
;;;140    }
000040  bd70              POP      {r4-r6,pc}
;;;141    /**
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  _timertick_high_rank_count_
                          DCD      0x00000000
                  _timer_clock_
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\timer\\timer_tick.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_timer_tick_c_2dc1a604____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___12_timer_tick_c_2dc1a604____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_timer_tick_c_2dc1a604____REVSH|
#line 402
|__asm___12_timer_tick_c_2dc1a604____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_timer_tick_c_2dc1a604____RRX|
#line 587
|__asm___12_timer_tick_c_2dc1a604____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
