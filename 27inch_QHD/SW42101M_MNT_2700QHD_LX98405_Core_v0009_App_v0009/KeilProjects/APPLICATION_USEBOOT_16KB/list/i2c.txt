; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\i2c.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\i2c.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\i2c.crf ..\..\Hal\i2c\i2c.c]
                          THUMB

                          AREA ||i.CheckI2CReady||, CODE, READONLY, ALIGN=2

                  CheckI2CReady PROC
;;;181    
;;;182    uint8_t CheckI2CReady(void)
000000  4803              LDR      r0,|L1.16|
;;;183    {
;;;184    	if (g_ConnectedDevice == I2C_CONNECT_TOOL)
000002  78c1              LDRB     r1,[r0,#3]  ; g_ConnectedDevice
000004  2901              CMP      r1,#1
;;;185    	{
;;;186    		return 1;
000006  bf0c              ITE      EQ
000008  2001              MOVEQ    r0,#1
;;;187    	}
;;;188    	else
;;;189    	{
;;;190    		return g_Ready_Complete;
00000a  7840              LDRBNE   r0,[r0,#1]  ; g_Ready_Complete
;;;191    	}
;;;192    }
00000c  4770              BX       lr
;;;193    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      ||area_number.14||

                          AREA ||i.GetCustomData_I2C||, CODE, READONLY, ALIGN=2

                  GetCustomData_I2C PROC
;;;432    
;;;433    void GetCustomData_I2C(uint8_t* pData)
000000  4601              MOV      r1,r0
;;;434    {
;;;435    	memcpy(&g_CustomBuffer_I2C.Data, pData, I2C_DATA_LENGTH);
000002  2240              MOVS     r2,#0x40
000004  4801              LDR      r0,|L2.12|
000006  f7ffbffe          B.W      __aeabi_memcpy
;;;436    	return;
;;;437    }
;;;438    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||+0xa8

                          AREA ||i.I2C_DeInitialize||, CODE, READONLY, ALIGN=2

                  I2C_DeInitialize PROC
;;;1134   
;;;1135   void I2C_DeInitialize(void)
000000  490d              LDR      r1,|L3.56|
;;;1136   {
000002  b081              SUB      sp,sp,#4
;;;1137   	tCK_ENA_RUN0_t tLocal_CK_ENA_RUN0;
;;;1138   	Fncp_I2C_IRQHandler = NULL;
000004  2000              MOVS     r0,#0
000006  6008              STR      r0,[r1,#0]  ; Fncp_I2C_IRQHandler
000008  f04f21e0          MOV      r1,#0xe000e000
00000c  2010              MOVS     r0,#0x10
00000e  f8c10180          STR      r0,[r1,#0x180]
;;;1139   	/*
;;;1140   	 * ISP모드가 아닐 경우에만 I2C초기화를 수행한다.
;;;1141   	 */
;;;1142   	// I2C SLAVE Setting
;;;1143   	NVIC_DisableIRQ(I2C_IRQn);    /* Interrupt Disable */
;;;1144   	tLocal_CK_ENA_RUN0.ulBulk = SCRB->CK_ENA_RUN0.ulBulk;
000012  0680              LSLS     r0,r0,#26
000014  69c1              LDR      r1,[r0,#0x1c]
000016  9100              STR      r1,[sp,#0]
;;;1145   	tLocal_CK_ENA_RUN0.tBit.r_I2C_CLK_ENA = 0;
000018  9900              LDR      r1,[sp,#0]
00001a  f4216100          BIC      r1,r1,#0x800
00001e  9100              STR      r1,[sp,#0]
;;;1146   	tLocal_CK_ENA_RUN0.tBit._VECTKEY = SCB_VECTKEY_VALUE;
000020  9900              LDR      r1,[sp,#0]
000022  b289              UXTH     r1,r1
000024  f1016180          ADD      r1,r1,#0x4000000
000028  f10171fd          ADD      r1,r1,#0x1fa0000
00002c  9100              STR      r1,[sp,#0]
;;;1147   	SCRB->CK_ENA_RUN0.ulBulk = tLocal_CK_ENA_RUN0.ulBulk;
00002e  9900              LDR      r1,[sp,#0]
000030  61c1              STR      r1,[r0,#0x1c]
;;;1148   }
000032  b001              ADD      sp,sp,#4
000034  4770              BX       lr
;;;1149   
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      Fncp_I2C_IRQHandler

                          AREA ||i.I2C_Initialize||, CODE, READONLY, ALIGN=2

                  I2C_Initialize PROC
;;;1087   
;;;1088   void I2C_Initialize(void)
000000  4914              LDR      r1,|L4.84|
;;;1089   {
;;;1090   	Fncp_I2C_IRQHandler = &I2C_InterruptHandler;
000002  4813              LDR      r0,|L4.80|
000004  6008              STR      r0,[r1,#0]  ; Fncp_I2C_IRQHandler
000006  f04f21e0          MOV      r1,#0xe000e000
00000a  2010              MOVS     r0,#0x10
00000c  f8c10100          STR      r0,[r1,#0x100]
000010  2020              MOVS     r0,#0x20
000012  1d09              ADDS     r1,r1,#4
000014  f8810400          STRB     r0,[r1,#0x400]
;;;1091   
;;;1092   #ifdef MODE_I2C
;;;1093   	// I2C SLAVE Setting
;;;1094   	Init_HidDescriptor();
;;;1095   	Init_HidReportDescriptor();
;;;1096   #endif
;;;1097   
;;;1098   	/*
;;;1099   	 * ISP모드가 아닐 경우에만 I2C초기화를 수행한다.
;;;1100   	 */
;;;1101   	// I2C SLAVE Setting
;;;1102   	NVIC_EnableIRQ(I2C_IRQn);    /* Interrupt Enable */
;;;1103   	NVIC_SetPriority(I2C_IRQn, I2C_IRQn_Priority);
;;;1104   
;;;1105   	I2C->I2C_DEVICE_ADDR.tBit.I2cId = I2C_ADDRESS;
000018  480f              LDR      r0,|L4.88|
00001a  6801              LDR      r1,[r0,#0]
00001c  f021017f          BIC      r1,r1,#0x7f
000020  3128              ADDS     r1,r1,#0x28
000022  6001              STR      r1,[r0,#0]
;;;1106   	I2C->I2C_SW_RESET.tBit.I2cSWReset = 1;
000024  6841              LDR      r1,[r0,#4]
000026  f0410101          ORR      r1,r1,#1
00002a  6041              STR      r1,[r0,#4]
;;;1107   	I2C->I2C_DEVICE_ADDR.tBit.I2cId	= I2C_ADDRESS;
00002c  6801              LDR      r1,[r0,#0]
00002e  f021017f          BIC      r1,r1,#0x7f
000032  3128              ADDS     r1,r1,#0x28
000034  6001              STR      r1,[r0,#0]
;;;1108   	I2C->I2C_GLB_CR.ulBulk = 0x000007FF;
000036  f24071ff          MOV      r1,#0x7ff
00003a  6081              STR      r1,[r0,#8]
;;;1109   
;;;1110   	// FIFO
;;;1111   	I2C->I2C_FIFO_CR.tBit.TxFifoInit = 1;
00003c  69c1              LDR      r1,[r0,#0x1c]
00003e  f0410101          ORR      r1,r1,#1
000042  61c1              STR      r1,[r0,#0x1c]
;;;1112   	I2C->I2C_FIFO_CR.tBit.RxFifoInit = 1;
000044  69c1              LDR      r1,[r0,#0x1c]
000046  f4417180          ORR      r1,r1,#0x100
00004a  61c1              STR      r1,[r0,#0x1c]
;;;1113   
;;;1114   #ifdef I2C_SELECTIVE_SUSPEND
;;;1115   	// Sleep Interrupt Enable
;;;1116   	I2C->I2C_SET_PWR_INT.tBit.SleepItrptEn = 1;
;;;1117   
;;;1118   	// WakeUp Interrupt Enable
;;;1119   	I2C->I2C_SET_PWR_INT.tBit.WakeUpItrptEn = 1;
;;;1120   
;;;1121   	// Power Reg
;;;1122   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBFirst = 0;
;;;1123   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegMSB = (uint8_t)I2C_COMMAND_REGISTER;
;;;1124   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBSleep = 0;
;;;1125   	I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBOn = 1; // 현재는 Wakeup 상태
;;;1126   
;;;1127   	// Power Command
;;;1128   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdEn = 1;
;;;1129   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrLSBFirst = 0;
;;;1130   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdMSB = I2C__REQUEST_REPORT_POWER_STATE__SLEEP; // Sleep 명령이 오길 기다린다.
;;;1131   	I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdLSB = I2C__REQUEST_OPCODE__SET_POWER;
;;;1132   #endif
;;;1133   }
00004c  4770              BX       lr
;;;1134   
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      I2C_InterruptHandler
                  |L4.84|
                          DCD      Fncp_I2C_IRQHandler
                  |L4.88|
                          DCD      0x40002000

                          AREA ||i.I2C_InterruptHandler||, CODE, READONLY, ALIGN=2

                  I2C_InterruptHandler PROC
;;;524    
;;;525    void I2C_InterruptHandler(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;526    {
;;;527    	uint16_t nTransCnt = 0;
;;;528    
;;;529    	nTransCnt = I2C->I2C_SLV_DBG.tBit.I2cSlvTrCnt;
000004  4bf7              LDR      r3,|L5.996|
000006  b083              SUB      sp,sp,#0xc            ;526
000008  6bd8              LDR      r0,[r3,#0x3c]
00000a  f3c0400e          UBFX     r0,r0,#16,#15
;;;530    
;;;531    	// Interrupt Clear
;;;532    	I2C->I2C_GLB_SR.tBit.I2C_ITRPT = 0;
00000e  9001              STR      r0,[sp,#4]
000010  6958              LDR      r0,[r3,#0x14]
000012  f0200001          BIC      r0,r0,#1
000016  6158              STR      r0,[r3,#0x14]
;;;533    
;;;534    	// Reset 관련 처리 중
;;;535    	if (g_bReset == I2C_RESET)
000018  4cf3              LDR      r4,|L5.1000|
00001a  2500              MOVS     r5,#0
00001c  7960              LDRB     r0,[r4,#5]  ; g_bReset
00001e  2801              CMP      r0,#1
000020  d10e              BNE      |L5.64|
;;;536    	{
;;;537    		g_bReset = I2C_NORMAL;
;;;538    
;;;539    		// Check GPIO Interrupt
;;;540    		if (GPIO->tGPIO_DATA_1.tBit.GPB10 == I2C_GPB10__LOW)
000022  48f2              LDR      r0,|L5.1004|
000024  7165              STRB     r5,[r4,#5]            ;537
000026  6841              LDR      r1,[r0,#4]
000028  f4113f80          TST      r1,#0x10000
00002c  d103              BNE      |L5.54|
;;;541    		{
;;;542    			// Disable GPIO Interrupt
;;;543    			GPIO->tGPIO_DATA_1.tBit.GPB10 = I2C_GPB10__HIGH;
00002e  6841              LDR      r1,[r0,#4]
000030  f4413180          ORR      r1,r1,#0x10000
000034  6041              STR      r1,[r0,#4]
                  |L5.54|
;;;544    		}
;;;545    
;;;546    		// Touch, Pen 데이터를 내보내는 작업을 지연시킨다.
;;;547    		g_DelayCheck = 0;
000036  70a5              STRB     r5,[r4,#2]
000038  2000              MOVS     r0,#0
;;;548    		g_StartTime_I2C = 0;
;;;549    		g_DelayTime = 0;
00003a  60e5              STR      r5,[r4,#0xc]  ; g_DelayTime
00003c  e9c4000e          STRD     r0,r0,[r4,#0x38]
                  |L5.64|
;;;550    	}
;;;551    
;;;552    
;;;553    #ifdef I2C_SELECTIVE_SUSPEND
;;;554    	// Sleep Interrupt 처리
;;;555    	if (I2C->I2C_SET_PWR_INT.tBit.SleepItrpt == 1)
;;;556    	{
;;;557    		// Clear
;;;558    		I2C->I2C_SET_PWR_INT.tBit.SleepItrpt = 0;
;;;559    
;;;560    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBSleep = 1; // 현재는 Sleep 상태
;;;561    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBOn = 0;
;;;562    
;;;563    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdMSB = I2C__REQUEST_REPORT_POWER_STATE__ON; // WakeUp 명령이 오길 기다린다.
;;;564    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdLSB = I2C__REQUEST_OPCODE__SET_POWER;
;;;565    	
;;;566    		// Sleep Enable
;;;567    		I2C->I2C_SLP_CR.tBit.SlpCr = 1;
;;;568    		I2C->I2C_SLP_CR.tBit.PrMux = 1;
;;;569    
;;;570    		goto I2C_IRQHANDLER__GOTO_END;
;;;571    	}
;;;572    
;;;573    	// WakeUp Interrupt 처리
;;;574    	if (I2C->I2C_SET_PWR_INT.tBit.WakeUpItrpt == 1)
;;;575    	{
;;;576    		// Clear
;;;577    		I2C->I2C_SET_PWR_INT.tBit.WakeUpItrpt = 0;
;;;578    
;;;579    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBSleep = 0;
;;;580    		I2C->I2C_SET_PWR_REG.tBit.SetPwrRegLSBOn = 1;	// 현재는 WakeUp 상태
;;;581    
;;;582    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdMSB = I2C__REQUEST_REPORT_POWER_STATE__SLEEP; // Sleep 명령이 오길 기다린다.
;;;583    		I2C->I2C_SET_PWR_CMD.tBit.SetPwrCmdLSB = I2C__REQUEST_OPCODE__SET_POWER;
;;;584    	
;;;585    		// Sleep Enable
;;;586    		I2C->I2C_SLP_CR.tBit.SlpCr = 0;
;;;587    		I2C->I2C_SLP_CR.tBit.PrMux = 0;
;;;588    
;;;589    		goto I2C_IRQHANDLER__GOTO_END;
;;;590    	}
;;;591    #endif
;;;592    
;;;593    
;;;594    
;;;595    
;;;596    	// Start
;;;597    	if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_STR_ITRPT)
000040  6958              LDR      r0,[r3,#0x14]
000042  f8df83a4          LDR      r8,|L5.1000|
000046  f3c04a03          UBFX     r10,r0,#16,#4
00004a  2701              MOVS     r7,#1                 ;535
;;;598    	{
;;;599    		// Command 를 처리하고 있지 않을 때
;;;600    		if (g_RxCommandIndex == 0)
;;;601    		{
;;;602    			if (CheckI2CReady() == 1)
;;;603    			{
;;;604    				if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;605    				{
;;;606    					// 2바이트를 먼저 넣어놓고 (Length)
;;;607    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = g_TxPtr_Common[g_TxIndex_Common];
00004c  f8d80020          LDR      r0,[r8,#0x20]
;;;608    					g_TxIndex_Common += 1;
;;;609    
;;;610    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = g_TxPtr_Common[g_TxIndex_Common];
;;;611    					g_TxIndex_Common += 1;
;;;612    					goto I2C_IRQHANDLER__PASS;
;;;613    				}
;;;614    			}
;;;615    		}
;;;616    		else
;;;617    		{
;;;618    			// 만약 Command 를 처리해야 할 때 Touch, Custom, Pen 데이터의 처리 과정이 겹치게 되면
;;;619    			// Touch, Custom, Pen 데이터를 처리하지 않도록 한다.
;;;620    			if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;621    			{
;;;622    				g_CheckComplete_Common_I2C = DMA_READY;
;;;623    
;;;624    				g_DelayCheck = 0;
;;;625    				g_StartTime_I2C = 0;
;;;626    				g_DelayTime = 0;
;;;627    
;;;628    				// Check GPIO Interrupt
;;;629    				if (GPIO->tGPIO_DATA_1.tBit.GPB10 == I2C_GPB10__LOW)
;;;630    				{
;;;631    					// Disable GPIO Interrupt 
;;;632    					GPIO->tGPIO_DATA_1.tBit.GPB10 = I2C_GPB10__HIGH;
;;;633    				}
;;;634    			}
;;;635    		}
;;;636    
;;;637    
;;;638    I2C_IRQHANDLER__PASS:
;;;639    
;;;640    
;;;641    		if (g_RxCommandIndex > 0)
;;;642    		{
;;;643    			uint16_t*	pCheckRegister = (uint16_t*)g_RxCommand;
000050  9000              STR      r0,[sp,#0]
000052  1c42              ADDS     r2,r0,#1              ;608
000054  48e6              LDR      r0,|L5.1008|
000056  f898c007          LDRB     r12,[r8,#7]           ;604
00005a  f8981003          LDRB     r1,[r8,#3]            ;604
;;;644    
;;;645    			if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;646    			{
;;;647    				goto I2C_IRQHANDLER__GOTO_END;
;;;648    			}
;;;649    
;;;650    			switch (*pCheckRegister)
00005e  8806              LDRH     r6,[r0,#0]
000060  f8d8901c          LDR      r9,[r8,#0x1c]         ;597
000064  f8d80010          LDR      r0,[r8,#0x10]         ;597
000068  f1ba0f01          CMP      r10,#1                ;597
00006c  d036              BEQ      |L5.220|
;;;651    			{
;;;652    #ifdef MODE_I2C
;;;653    				// 첫 번째로 받는 명령어
;;;654    				// I2C HID Descriptor 로 응답한다.
;;;655    				case HID_DESCRIPTOR_ADDRESS:
;;;656    				{
;;;657    					uint16_t	Length = 0;
;;;658    					
;;;659    					g_ConnectedDevice = I2C_CONNECT_PC;
;;;660    
;;;661    					// Clear Tx
;;;662    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;663    
;;;664    					// I2C HID Descriptor
;;;665    					Length = sizeof(I2C_HID_DESCRIPTOR) + 2;
;;;666    
;;;667    					// 2 바이트 먼저 입력
;;;668    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = (uint8_t)(Length & 0x00FF);
;;;669    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = (uint8_t)(Length >> 8);
;;;670    
;;;671    					g_TxPtr = (uint8_t*)&g_I2CHidDescriptor;
;;;672    					g_TxIndex = 0;
;;;673    					break;
;;;674    				}
;;;675    
;;;676    				// Master 에서 I2C HID Descriptor 의 내용을 참고해서 Report Register 를 명령어로 보낸다.
;;;677    				// HID Report Descriptor 로 응답한다.
;;;678    				case I2C_REPORT_REGISTER:
;;;679    				{
;;;680    					// Clear Tx
;;;681    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;682    
;;;683    					// HID Report Descriptor
;;;684    					g_TxPtr = (uint8_t*)g_HID_ReportDesc_Temp;
;;;685    					g_TxIndex = 0;
;;;686    
;;;687    					// 2바이트 먼저 입력
;;;688    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = g_TxPtr[g_TxIndex];
;;;689    					g_TxIndex += 1;
;;;690    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = g_TxPtr[g_TxIndex];
;;;691    					g_TxIndex += 1;
;;;692    					break;
;;;693    				}
;;;694    #endif
;;;695    				// Master 에서 I2C HID Descriptor 의 내용을 참고해서 Command Register 를 명령어로 보낸다.
;;;696    				case I2C_COMMAND_REGISTER:
;;;697    				{
;;;698    					PI2C__REQUEST pRequest = (PI2C__REQUEST)g_RxCommand;
;;;699    
;;;700    					if (pRequest->OpCode == I2C__REQUEST_OPCODE__GET_REPORT)
;;;701    					{
;;;702    #ifdef MODE_I2C
;;;703    #ifdef ADD_TOUCH
;;;704    						// Report ID : 8 - Get MaxTouch Count (22 00 38 02 23 00)
;;;705    						if (pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__CONTACT_COUNT)
;;;706    						{
;;;707    							uint16_t	Length = 0;
;;;708    							
;;;709    							// Clear Tx
;;;710    							I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;711    
;;;712    							// I2C HID Descriptor
;;;713    							Length = sizeof(TOUCH_MAX_COUNT) + 2;
;;;714    
;;;715    							// 2 바이트 먼저 입력
;;;716    							I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = (uint8_t)(Length & 0x00FF);
;;;717    							I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = (uint8_t)(Length >> 8);
;;;718    
;;;719    							g_TxPtr = (uint8_t*)&g_MaxTouchCount_I2C;
;;;720    							g_TxIndex = 0;
;;;721    
;;;722    							g_MaxTouchCount_I2C.ReportID = HID_REPORT_ID__CONTACT_COUNT;
;;;723    							g_MaxTouchCount_I2C.Count = HID_MAX_TOUCH;
;;;724    							break;
;;;725    						}
;;;726    
;;;727    						// Report ID : 6 - Get BlobCode (22 00 36 02 23 00)
;;;728    						if (pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__BLOB_CODE)
;;;729    						{
;;;730    							uint16_t	Length = 0;
;;;731    							
;;;732    							// Clear Tx
;;;733    							I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;734    
;;;735    							// I2C HID Descriptor
;;;736    							Length = HID_TOUCH_BLOB_LENGTH + 2;
;;;737    
;;;738    							// 2 바이트 먼저 입력
;;;739    							I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = (uint8_t)(Length & 0x00FF);
;;;740    							I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = (uint8_t)(Length >> 8);
;;;741    
;;;742    							g_TxPtr = (uint8_t*)u8_HID_Touch_Blob;
;;;743    							g_TxIndex = 0;
;;;744    							break;
;;;745    						}
;;;746    #endif
;;;747    #endif
;;;748    					}
;;;749    
;;;750    					break;
;;;751    				}
;;;752    
;;;753    				case I2C_DATA_REGISTER:
;;;754    				{
;;;755    					break;
;;;756    				}
;;;757    
;;;758    				case I2C_INPUT_REGISTER:
;;;759    				{
;;;760    					break;
;;;761    				}
;;;762    
;;;763    				case I2C_OUTPUT_REGISTER:
;;;764    				{
;;;765    					break;
;;;766    				}
;;;767    			}
;;;768    		}
;;;769    
;;;770    	}
;;;771    	else if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_BYTE_ITRPT)
00006e  4bdd              LDR      r3,|L5.996|
000070  695b              LDR      r3,[r3,#0x14]
000072  f3c34e03          UBFX     lr,r3,#16,#4
000076  4643              MOV      r3,r8                 ;535
000078  f1be0f03          CMP      lr,#3
;;;772    	{
;;;773    		// Master --> Slave
;;;774    		if (I2C->I2C_GLB_SR.tBit.I2cSlvRdWrFlag == 0)
;;;775    		{
;;;776    			//
;;;777    			// I2C 장치에 연결할 때
;;;778    			//
;;;779    			if (g_ConnectedDevice > I2C_CONNECT_PC)
;;;780    			{
;;;781    				if (nTransCnt == 1)
;;;782    				{
;;;783    					usRegAddr = (uint8_t)(I2C->I2C_RXFIFO_DATA.ulBulk & 0xFF);
;;;784    					usRegAddr <<= 8;
;;;785    				}
;;;786    				else if (nTransCnt == 2)
;;;787    				{
;;;788    					usRegAddr |= (uint8_t)(I2C->I2C_RXFIFO_DATA.ulBulk & 0xFF);
;;;789    
;;;790    					if (g_ConnectedDevice_FirstCheck == 0)
;;;791    					{
;;;792    						if ((swap_uint16(usRegAddr) == HID_DESCRIPTOR_ADDRESS) || (swap_uint16(usRegAddr) == I2C_COMMAND_REGISTER) || (swap_uint16(usRegAddr) == I2C_OUTPUT_REGISTER))
;;;793    						{
;;;794    							// PC 에 연결했다고 판단한다.
;;;795    							g_ConnectedDevice_FirstCheck = 1;
;;;796    							g_ConnectedDevice = I2C_CONNECT_PC;
;;;797    
;;;798    							g_RxCommand[0] = (uint8_t)(usRegAddr >> 8);
;;;799    							g_RxCommand[1] = (uint8_t)(usRegAddr & 0x00FF);
;;;800    							g_RxCommandIndex = 2;
;;;801    							goto I2C_IRQHANDLER__GOTO_END;
;;;802    						}
;;;803    
;;;804    						// 장치랑 연결하게 되면 가장 먼저 0x0150 을 받게 된다!!
;;;805    						if (usRegAddr == 0x0150)
;;;806    						{
;;;807    							g_ConnectedDevice = I2C_CONNECT_TOOL_0x150;
;;;808    						}
;;;809    					}
;;;810    
;;;811    					g_ConnectedDevice_FirstCheck = 1;
;;;812    
;;;813    					I2C->I2C_FIFO_CR.ulBulk |= 0x01;	// Clear
;;;814    
;;;815    					if (protocol_GetMappedPointer != NULL)
;;;816    					{
;;;817    						rmi_read_ptr = rmi_write_ptr = (*protocol_GetMappedPointer)(usRegAddr);
;;;818    						i2c_sent_byte = i2c_received_byte = 0;
;;;819    
;;;820    						if (rmi_read_ptr != NULL)
;;;821    						{
;;;822    							I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = *(rmi_read_ptr++);
00007c  f8d38024          LDR      r8,[r3,#0x24]
000080  f8d3a02c          LDR      r10,[r3,#0x2c]        ;535
000084  4bdb              LDR      r3,|L5.1012|
000086  f1080b01          ADD      r11,r8,#1
;;;823    							if (protocol_ClearInterrupt != NULL)
00008a  681b              LDR      r3,[r3,#0]
00008c  d060              BEQ      |L5.336|
;;;824    							{
;;;825    								(*protocol_ClearInterrupt)(usRegAddr + i2c_sent_byte);
;;;826    							}
;;;827    
;;;828    							i2c_sent_byte++;
;;;829    						}
;;;830    					}
;;;831    				}
;;;832    				else if (nTransCnt > 2)
;;;833    				{
;;;834    					if (rmi_write_ptr != NULL)
;;;835    					{
;;;836    						*(rmi_write_ptr++) = I2C->I2C_RXFIFO_DATA.tBit.RxFifoData;
;;;837    						i2c_received_byte++;
;;;838    					}
;;;839    				}
;;;840    			}
;;;841    
;;;842    			//
;;;843    			// PC 에 연결할 때
;;;844    			//
;;;845    			else
;;;846    			{
;;;847    				if (I2C->I2C_FIFO_SR2.tBit.RxFifoEmpty == 0)
;;;848    				{
;;;849    					uint8_t ReadData = 0;
;;;850    
;;;851    					ReadData = (uint8_t)(I2C->I2C_RXFIFO_DATA.ulBulk & 0xFF);
;;;852    					if (g_RxCommandIndex < 100)
;;;853    					{
;;;854    						g_RxCommand[g_RxCommandIndex] = ReadData;
;;;855    						g_RxCommandIndex += 1;
;;;856    
;;;857    						// OUTPUT 데이터가 들어올 때는 Delay 작업을 하지 않는다.
;;;858    						if ((g_RxCommand[0] != (uint8_t)I2C_OUTPUT_REGISTER))
;;;859    						{
;;;860    							// Touch, Pen 데이터를 내보내는 작업을 지연시킨다.
;;;861    							g_DelayCheck = 0;
;;;862    							g_StartTime_I2C = 0;
;;;863    							g_DelayTime = 0;
;;;864    						}
;;;865    					}
;;;866    				}
;;;867    			}
;;;868    		}
;;;869    		// Slave --> Master
;;;870    		else
;;;871    		{
;;;872    			// g_ConnectedDevice 값이 1인 경우에는 Slave --> Master 방향으로 데이터가 처리 될 수 없다.
;;;873    			// 이 경우는 PC 에 연결되었다고 판단하게 되므로 g_ConnectedDevice 값을 0 으로 바꿔서 처리 해야 한다.
;;;874    			if (g_ConnectedDevice == I2C_CONNECT_TOOL)
;;;875    			{
;;;876    				g_ConnectedDevice = I2C_CONNECT_PC;
;;;877    				g_Ready_Complete = I2C_READY;
;;;878    				g_Ready = I2C_READY;
;;;879    			}
;;;880    
;;;881    			//
;;;882    			// I2C 장치에 연결할 때
;;;883    			//
;;;884    			if (g_ConnectedDevice > I2C_CONNECT_PC) // Tool 에 연결되었고 0x0150 데이터를 받았다는 것 까지 체크 한다.
;;;885    			{
;;;886    				if (rmi_read_ptr)
;;;887    				{
;;;888    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = *(rmi_read_ptr++);
;;;889    					if (protocol_ClearInterrupt != NULL)
;;;890    					{
;;;891    						(*protocol_ClearInterrupt)(usRegAddr + i2c_sent_byte);
;;;892    					}
;;;893    
;;;894    					i2c_sent_byte++;
;;;895    				}
;;;896    			}
;;;897    
;;;898    			//
;;;899    			// PC 에 연결할 때
;;;900    			//
;;;901    			else
;;;902    			{
;;;903    				g_Ready = I2C_READY;
;;;904    
;;;905    				// HID Descriptor 처리 하는 부분
;;;906    				if (g_RxCommandIndex > 0)
;;;907    				{
;;;908    					I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = g_TxPtr[g_TxIndex];
;;;909    					g_TxIndex += 1;
;;;910    				}
;;;911    
;;;912    				if (CheckI2CReady() == 1)
;;;913    				{
;;;914    					if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;915    					{
;;;916    						I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = g_TxPtr_Common[g_TxIndex_Common];
;;;917    						g_TxIndex_Common += 1;
;;;918    						goto I2C_IRQHANDLER__GOTO_END;
;;;919    					}
;;;920    				}
;;;921    			}
;;;922    
;;;923    		}
;;;924    	}
;;;925    	// Stop
;;;926    	else if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_STP_ITRPT)
00008e  4ad5              LDR      r2,|L5.996|
000090  f8d29014          LDR      r9,[r2,#0x14]
000094  f3c94903          UBFX     r9,r9,#16,#4
000098  f1b90f02          CMP      r9,#2
00009c  f0008136          BEQ.W    |L5.780|
;;;927    	{
;;;928    		if (g_RxCommandIndex > 0)
;;;929    		{
;;;930    			uint16_t*	pCheckRegister = (uint16_t*)g_RxCommand;
;;;931    
;;;932    			switch (*pCheckRegister)
;;;933    			{
;;;934    				// Master 에서 I2C HID Descriptor 의 내용을 참고해서 Command Register 를 명령어로 보낸다.
;;;935    				case I2C_COMMAND_REGISTER:
;;;936    				{
;;;937    					PI2C__REQUEST pRequest = (PI2C__REQUEST)g_RxCommand;
;;;938    
;;;939    					// Set Power (22 00 00 08)
;;;940    					if ((pRequest->I2C_Request_Power.PowerState == I2C__REQUEST_REPORT_POWER_STATE__ON) &&
;;;941    						(pRequest->OpCode == I2C__REQUEST_OPCODE__SET_POWER))
;;;942    					{
;;;943    						g_TxPtr = NULL;
;;;944    						g_TxIndex = 0;
;;;945    
;;;946    						g_Ready = I2C_READY;
;;;947    						break;
;;;948    					}
;;;949    					// Sleep
;;;950    					else if ((pRequest->I2C_Request_Power.PowerState == I2C__REQUEST_REPORT_POWER_STATE__SLEEP) &&
;;;951    							 (pRequest->OpCode == I2C__REQUEST_OPCODE__SET_POWER))
;;;952    					{
;;;953    						g_TxPtr = NULL;
;;;954    						g_TxIndex = 0;
;;;955    
;;;956    						g_Ready = I2C_NOT_READY;
;;;957    						break;
;;;958    					}
;;;959    					// Reset (22 00 00 01)
;;;960    					else if ((pRequest->I2C_Request_Common.ReportType == I2C__REQUEST_REPORT_TYPE__NONE) &&
;;;961    						(pRequest->OpCode == I2C__REQUEST_OPCODE__RESET))
;;;962    					{
;;;963    						g_TxPtr = NULL;
;;;964    						g_TxIndex = 0;
;;;965    
;;;966    						g_bReset = I2C_RESET;
;;;967    						break;
;;;968    					}
;;;969    #ifdef MODE_I2C
;;;970    					// Device Mode - (22 00 37 03 23 00 05 00 07 02 00)
;;;971    					else if ((pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__DEVICE_MODE) &&
;;;972    						(pRequest->OpCode == I2C__REQUEST_OPCODE__SET_REPORT))
;;;973    					{
;;;974    						g_TxPtr = NULL;
;;;975    						g_TxIndex = 0;
;;;976    
;;;977    						memcpy((uint8_t*)&g_DeviceMode_I2C, (uint8_t*)&pRequest->Data[0], sizeof(SETREPORT_DEVICE_MODE));
;;;978    						break;
;;;979    					}
;;;980    					// Latency Mode (22 00 35 03 23 04 00 05 00 or 01)
;;;981    					else if ((pRequest->I2C_Request_Common.ReportID == HID_REPORT_ID__LATENCY_MODE) &&
;;;982    						(pRequest->OpCode == I2C__REQUEST_OPCODE__SET_REPORT))
;;;983    					{
;;;984    						g_TxPtr = NULL;
;;;985    						g_TxIndex = 0;
;;;986    
;;;987    						memcpy((uint8_t*)&g_LatencyMode_I2C, (uint8_t*)&pRequest->Data[0], sizeof(SETREPORT_LATENCY_MODE));
;;;988    						break;
;;;989    					}
;;;990    #endif
;;;991    
;;;992    					break;
;;;993    				}
;;;994    				case I2C_OUTPUT_REGISTER:
;;;995    				{
;;;996    					PI2C__OUTPUT pOutputData = (PI2C__OUTPUT)g_RxCommand;
;;;997    					custom_tool=1;
;;;998    
;;;999    #ifdef ADD_CUSTOM
;;;1000   					if (pOutputData->ReportID == HID_REPORT_ID__CUSTOM_OUT)
;;;1001   					{
;;;1002   						GetCustomData_I2C(&pOutputData->ReportID);
;;;1003   						RecieveCustomData_I2C(&g_CustomBuffer_I2C);
;;;1004   
;;;1005   						// Init Command 처리 없이 Custom OUT 데이터가 먼저 들어올 수 있다.
;;;1006   						// 이 경우에는 여기서 Ready 를 체크 해줘야 한다.
;;;1007   						g_Ready = I2C_READY;
;;;1008   
;;;1009   						// Custom App 를 사용해서 F/W Download 를 했을 경우 Custom OUT 을 마지막으로
;;;1010   						// 장치가 Reboot 되는데 이후에 Init Command 없이 곧 바로 Touch 가 동작할 수 있어야 한다.
;;;1011   						// 그래서 Delay 작업을 하면 안 된다.
;;;1012   						g_DelayCheck = 1;
;;;1013   					}
;;;1014   #endif
;;;1015   					break;
;;;1016   				}
;;;1017   			}
;;;1018   
;;;1019   			memset(g_RxCommand, 0, 100);
;;;1020   			g_RxCommandIndex = 0;
;;;1021   		}
;;;1022   
;;;1023   		// Touch, Custom, Pen
;;;1024   		else if (g_CheckComplete_Common_I2C == DMA_NOT_READY)
;;;1025   		{
;;;1026   			g_CheckComplete_Common_I2C = DMA_READY;
;;;1027   			g_GpioDisable = I2C_GPIO_DISABLE;
;;;1028   		}
;;;1029   
;;;1030   #ifdef MODE_I2C
;;;1031   		GetDelayTime();
;;;1032   #endif
;;;1033   
;;;1034   		if (g_Ready == I2C_READY)
;;;1035   		{
;;;1036   			g_Ready_Complete = I2C_READY;
;;;1037   		}
;;;1038   		else
;;;1039   		{
;;;1040   			g_Ready_Complete = I2C_NOT_READY;
;;;1041   			g_StartTime_I2C = 0;
;;;1042   			g_DelayTime = 0;
;;;1043   		}
;;;1044   
;;;1045   		if (g_GpioDisable == I2C_GPIO_DISABLE)
;;;1046   		{
;;;1047   			// Check GPIO Interrupt
;;;1048   			if (GPIO->tGPIO_DATA_1.tBit.GPB10 == I2C_GPB10__LOW)
;;;1049   			{
;;;1050   				// Disable GPIO Interrupt
;;;1051   				GPIO->tGPIO_DATA_1.tBit.GPB10 = I2C_GPB10__HIGH;
;;;1052   			}
;;;1053   
;;;1054   			g_GpioDisable = I2C_GPIO_NORMAL;
;;;1055   		}
;;;1056   
;;;1057   #ifdef MODE_I2C
;;;1058   		// Reset 명령에 대한 응답을 준비한다.
;;;1059   		if (g_bReset == I2C_RESET)
;;;1060   		{
;;;1061   			Make_EmptyI2CData();
;;;1062   		}
;;;1063   #endif
;;;1064   	}
;;;1065   	else if (I2C->I2C_GLB_SR.tBit.I2cItrptState == I2C_ADDR_ITRPT)
0000a0  6950              LDR      r0,[r2,#0x14]
0000a2  f3c04003          UBFX     r0,r0,#16,#4
0000a6  2804              CMP      r0,#4
;;;1066   	{
;;;1067   		if (g_ConnectedDevice > I2C_CONNECT_PC)
;;;1068   		{
;;;1069   			if (rmi_read_ptr)
;;;1070   			{
;;;1071   				I2C->I2C_TXFIFO_DATA.tBit.TxFifoData = *(rmi_read_ptr++);
;;;1072   				if (protocol_ClearInterrupt != NULL)
;;;1073   				{
;;;1074   					(*protocol_ClearInterrupt)(usRegAddr + i2c_sent_byte);
;;;1075   				}
;;;1076   
;;;1077   				i2c_sent_byte++;
;;;1078   			}
;;;1079   		}
;;;1080   	}
;;;1081   
;;;1082   
;;;1083   I2C_IRQHANDLER__GOTO_END:
;;;1084   
;;;1085   	return;
;;;1086   }
0000a8  bf1c              ITT      NE
0000aa  b003              ADDNE    sp,sp,#0xc
0000ac  e8bd8ff0          POPNE    {r4-r11,pc}
0000b0  2900              CMP      r1,#0                 ;1067
0000b2  bf12              ITEE     NE                    ;1069
0000b4  f1b80f00          CMPNE    r8,#0                 ;1069
0000b8  b003              ADDEQ    sp,sp,#0xc
0000ba  e8bd8ff0          POPEQ    {r4-r11,pc}
0000be  f8981000          LDRB     r1,[r8,#0]            ;1071
0000c2  f8c4b024          STR      r11,[r4,#0x24]        ;1071  ; rmi_read_ptr
0000c6  6a10              LDR      r0,[r2,#0x20]         ;1071
0000c8  f3610007          BFI      r0,r1,#0,#8           ;1071
0000cc  6210              STR      r0,[r2,#0x20]         ;1071
0000ce  2b00              CMP      r3,#0                 ;1072
0000d0  d058              BEQ      |L5.388|
                  |L5.210|
0000d2  8960              LDRH     r0,[r4,#0xa]          ;1074  ; usRegAddr
0000d4  4450              ADD      r0,r0,r10             ;1074
0000d6  b280              UXTH     r0,r0                 ;1074
0000d8  4798              BLX      r3                    ;1074
0000da  e053              B        |L5.388|
                  |L5.220|
0000dc  b1d0              CBZ      r0,|L5.276|
0000de  f1bc0f00          CMP      r12,#0                ;620
0000e2  bf1c              ITT      NE
0000e4  b003              ADDNE    sp,sp,#0xc
0000e6  e8bd8ff0          POPNE    {r4-r11,pc}
0000ea  71e7              STRB     r7,[r4,#7]            ;622
0000ec  70a5              STRB     r5,[r4,#2]            ;624
0000ee  2100              MOVS     r1,#0                 ;624
0000f0  60e5              STR      r5,[r4,#0xc]          ;626  ; g_DelayTime
0000f2  e9c4110e          STRD     r1,r1,[r4,#0x38]      ;626
0000f6  48bd              LDR      r0,|L5.1004|
0000f8  6841              LDR      r1,[r0,#4]            ;629
0000fa  f4113f80          TST      r1,#0x10000           ;629
0000fe  bf1c              ITT      NE
000100  b003              ADDNE    sp,sp,#0xc
000102  e8bd8ff0          POPNE    {r4-r11,pc}
000106  6841              LDR      r1,[r0,#4]            ;632
000108  f4413180          ORR      r1,r1,#0x10000        ;632
00010c  6041              STR      r1,[r0,#4]            ;632
00010e  b003              ADD      sp,sp,#0xc
000110  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.276|
000114  2901              CMP      r1,#1
000116  bf1b              ITTET    NE
000118  7860              LDRBNE   r0,[r4,#1]  ; g_Ready_Complete
00011a  2801              CMPNE    r0,#1                 ;602
00011c  f1bc0f00          CMPEQ    r12,#0                ;604
000120  b003              ADDNE    sp,sp,#0xc
000122  bf18              IT       NE
000124  e8bd8ff0          POPNE    {r4-r11,pc}
000128  9800              LDR      r0,[sp,#0]            ;607
00012a  f8191000          LDRB     r1,[r9,r0]            ;607
00012e  6a18              LDR      r0,[r3,#0x20]         ;607
000130  f3610007          BFI      r0,r1,#0,#8           ;607
000134  6218              STR      r0,[r3,#0x20]         ;607
000136  6222              STR      r2,[r4,#0x20]         ;610  ; g_TxIndex_Common
000138  f8191002          LDRB     r1,[r9,r2]            ;610
00013c  6a18              LDR      r0,[r3,#0x20]         ;610
00013e  f3610007          BFI      r0,r1,#0,#8           ;610
000142  6218              STR      r0,[r3,#0x20]         ;610
000144  f1020001          ADD      r0,r2,#1              ;611
000148  6220              STR      r0,[r4,#0x20]         ;612  ; g_TxIndex_Common
00014a  b003              ADD      sp,sp,#0xc
00014c  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.336|
000150  4ea4              LDR      r6,|L5.996|
000152  f8d6e014          LDR      lr,[r6,#0x14]         ;774
000156  f01e0f08          TST      lr,#8                 ;774
00015a  d019              BEQ      |L5.400|
00015c  2901              CMP      r1,#1                 ;874
00015e  d07d              BEQ      |L5.604|
000160  2900              CMP      r1,#0                 ;884
000162  d07c              BEQ      |L5.606|
000164  f1b80f00          CMP      r8,#0                 ;886
000168  bf04              ITT      EQ
00016a  b003              ADDEQ    sp,sp,#0xc
00016c  e8bd8ff0          POPEQ    {r4-r11,pc}
000170  f8981000          LDRB     r1,[r8,#0]            ;888
000174  f8c4b024          STR      r11,[r4,#0x24]        ;888  ; rmi_read_ptr
000178  6a30              LDR      r0,[r6,#0x20]         ;888
00017a  f3610007          BFI      r0,r1,#0,#8           ;888
00017e  6230              STR      r0,[r6,#0x20]         ;888
000180  2b00              CMP      r3,#0                 ;889
000182  d1a6              BNE      |L5.210|
                  |L5.388|
000184  6ae0              LDR      r0,[r4,#0x2c]         ;894  ; i2c_sent_byte
000186  1c40              ADDS     r0,r0,#1              ;894
000188  62e0              STR      r0,[r4,#0x2c]         ;894  ; i2c_sent_byte
00018a  b003              ADD      sp,sp,#0xc
00018c  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.400|
000190  4a97              LDR      r2,|L5.1008|
000192  2900              CMP      r1,#0                 ;779
000194  d07a              BEQ      |L5.652|
000196  9801              LDR      r0,[sp,#4]            ;781
000198  2801              CMP      r0,#1                 ;781
00019a  d015              BEQ      |L5.456|
00019c  2802              CMP      r0,#2                 ;786
00019e  d01f              BEQ      |L5.480|
0001a0  bf9c              ITT      LS
0001a2  b003              ADDLS    sp,sp,#0xc
0001a4  e8bd8ff0          POPLS    {r4-r11,pc}
0001a8  6aa0              LDR      r0,[r4,#0x28]         ;834  ; rmi_write_ptr
0001aa  2800              CMP      r0,#0                 ;834
0001ac  bf04              ITT      EQ
0001ae  b003              ADDEQ    sp,sp,#0xc
0001b0  e8bd8ff0          POPEQ    {r4-r11,pc}
0001b4  6a71              LDR      r1,[r6,#0x24]         ;836
0001b6  f8001b01          STRB     r1,[r0],#1            ;836
0001ba  62a0              STR      r0,[r4,#0x28]         ;837  ; rmi_write_ptr
0001bc  6b20              LDR      r0,[r4,#0x30]         ;837  ; i2c_received_byte
0001be  1c40              ADDS     r0,r0,#1              ;837
0001c0  6320              STR      r0,[r4,#0x30]         ;837  ; i2c_received_byte
0001c2  b003              ADD      sp,sp,#0xc
0001c4  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.456|
0001c8  6a70              LDR      r0,[r6,#0x24]         ;783
0001ca  b2c0              UXTB     r0,r0                 ;783
0001cc  8160              STRH     r0,[r4,#0xa]          ;783
0001ce  8960              LDRH     r0,[r4,#0xa]          ;784  ; usRegAddr
0001d0  f64f71ff          MOV      r1,#0xffff            ;784
0001d4  ea012000          AND      r0,r1,r0,LSL #8       ;784
0001d8  8160              STRH     r0,[r4,#0xa]          ;784
0001da  b003              ADD      sp,sp,#0xc
0001dc  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.480|
0001e0  6a70              LDR      r0,[r6,#0x24]         ;788
0001e2  8961              LDRH     r1,[r4,#0xa]          ;788  ; usRegAddr
0001e4  b2c0              UXTB     r0,r0                 ;788
0001e6  4308              ORRS     r0,r0,r1              ;788
0001e8  8160              STRH     r0,[r4,#0xa]          ;788
0001ea  7920              LDRB     r0,[r4,#4]            ;790  ; g_ConnectedDevice_FirstCheck
0001ec  b9d0              CBNZ     r0,|L5.548|
0001ee  8960              LDRH     r0,[r4,#0xa]          ;792  ; usRegAddr
0001f0  0201              LSLS     r1,r0,#8              ;792
0001f2  ea412010          ORR      r0,r1,r0,LSR #8       ;792
0001f6  b280              UXTH     r0,r0                 ;792
0001f8  2102              MOVS     r1,#2                 ;527
0001fa  2820              CMP      r0,#0x20              ;792
0001fc  d03a              BEQ      |L5.628|
0001fe  8960              LDRH     r0,[r4,#0xa]          ;792  ; usRegAddr
000200  0203              LSLS     r3,r0,#8              ;792
000202  ea432010          ORR      r0,r3,r0,LSR #8       ;792
000206  b280              UXTH     r0,r0                 ;792
000208  2822              CMP      r0,#0x22              ;792
00020a  d033              BEQ      |L5.628|
00020c  8960              LDRH     r0,[r4,#0xa]          ;792  ; usRegAddr
00020e  0203              LSLS     r3,r0,#8              ;792
000210  ea432010          ORR      r0,r3,r0,LSR #8       ;792
000214  b280              UXTH     r0,r0                 ;792
000216  2825              CMP      r0,#0x25              ;792
000218  d02c              BEQ      |L5.628|
00021a  8960              LDRH     r0,[r4,#0xa]          ;805  ; usRegAddr
00021c  f5b07fa8          CMP      r0,#0x150             ;805
000220  bf08              IT       EQ                    ;807
000222  70e1              STRBEQ   r1,[r4,#3]            ;807
                  |L5.548|
000224  7127              STRB     r7,[r4,#4]            ;811
000226  69f0              LDR      r0,[r6,#0x1c]         ;813
000228  f0400001          ORR      r0,r0,#1              ;813
00022c  61f0              STR      r0,[r6,#0x1c]         ;813
00022e  4872              LDR      r0,|L5.1016|
000230  6801              LDR      r1,[r0,#0]            ;815  ; protocol_GetMappedPointer
000232  2900              CMP      r1,#0                 ;815
000234  bf04              ITT      EQ
000236  b003              ADDEQ    sp,sp,#0xc
000238  e8bd8ff0          POPEQ    {r4-r11,pc}
00023c  8960              LDRH     r0,[r4,#0xa]          ;817  ; usRegAddr
00023e  4788              BLX      r1                    ;817
000240  62a0              STR      r0,[r4,#0x28]         ;817  ; rmi_write_ptr
000242  6325              STR      r5,[r4,#0x30]         ;818  ; i2c_received_byte
000244  62e5              STR      r5,[r4,#0x2c]         ;820  ; i2c_sent_byte
000246  6260              STR      r0,[r4,#0x24]         ;820  ; rmi_read_ptr
000248  2800              CMP      r0,#0                 ;820
00024a  bf04              ITT      EQ
00024c  b003              ADDEQ    sp,sp,#0xc
00024e  e8bd8ff0          POPEQ    {r4-r11,pc}
000252  f8101b01          LDRB     r1,[r0],#1            ;822
000256  6260              STR      r0,[r4,#0x24]         ;822  ; rmi_read_ptr
000258  6a30              LDR      r0,[r6,#0x20]         ;822
00025a  e001              B        |L5.608|
                  |L5.604|
00025c  e035              B        |L5.714|
                  |L5.606|
00025e  e037              B        |L5.720|
                  |L5.608|
000260  f3610007          BFI      r0,r1,#0,#8           ;822
000264  6230              STR      r0,[r6,#0x20]         ;822
000266  4863              LDR      r0,|L5.1012|
000268  6801              LDR      r1,[r0,#0]            ;823  ; protocol_ClearInterrupt
00026a  2900              CMP      r1,#0                 ;823
00026c  bf1c              ITT      NE                    ;825
00026e  8960              LDRHNE   r0,[r4,#0xa]          ;825  ; usRegAddr
000270  4788              BLXNE    r1                    ;825
000272  e787              B        |L5.388|
                  |L5.628|
000274  7127              STRB     r7,[r4,#4]            ;795
000276  70e5              STRB     r5,[r4,#3]            ;796
000278  8960              LDRH     r0,[r4,#0xa]          ;798  ; usRegAddr
00027a  0a00              LSRS     r0,r0,#8              ;798
00027c  7010              STRB     r0,[r2,#0]            ;798
00027e  8960              LDRH     r0,[r4,#0xa]          ;799  ; usRegAddr
000280  7050              STRB     r0,[r2,#1]            ;799
000282  6121              STR      r1,[r4,#0x10]         ;801  ; g_RxCommandIndex
000284  b003              ADD      sp,sp,#0xc
000286  e8bd8ff0          POP      {r4-r11,pc}
00028a  e7ff              B        |L5.652|
                  |L5.652|
00028c  6cb1              LDR      r1,[r6,#0x48]         ;847
00028e  f4113f80          TST      r1,#0x10000           ;847
000292  bf1c              ITT      NE
000294  b003              ADDNE    sp,sp,#0xc
000296  e8bd8ff0          POPNE    {r4-r11,pc}
00029a  6a71              LDR      r1,[r6,#0x24]         ;851
00029c  2864              CMP      r0,#0x64              ;852
00029e  b2c9              UXTB     r1,r1                 ;851
0002a0  bf24              ITT      CS
0002a2  b003              ADDCS    sp,sp,#0xc
0002a4  e8bd8ff0          POPCS    {r4-r11,pc}
0002a8  5411              STRB     r1,[r2,r0]            ;854
0002aa  1c40              ADDS     r0,r0,#1              ;854
0002ac  6120              STR      r0,[r4,#0x10]         ;858  ; g_RxCommandIndex
0002ae  7810              LDRB     r0,[r2,#0]            ;858  ; g_RxCommand
0002b0  2825              CMP      r0,#0x25              ;858
0002b2  bf04              ITT      EQ
0002b4  b003              ADDEQ    sp,sp,#0xc
0002b6  e8bd8ff0          POPEQ    {r4-r11,pc}
0002ba  70a5              STRB     r5,[r4,#2]            ;861
0002bc  2000              MOVS     r0,#0                 ;861
0002be  60e5              STR      r5,[r4,#0xc]          ;863  ; g_DelayTime
0002c0  e9c4000e          STRD     r0,r0,[r4,#0x38]      ;863
0002c4  b003              ADD      sp,sp,#0xc
0002c6  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.714|
0002ca  70e5              STRB     r5,[r4,#3]            ;876
0002cc  7067              STRB     r7,[r4,#1]            ;877
0002ce  7027              STRB     r7,[r4,#0]            ;878
                  |L5.720|
0002d0  7027              STRB     r7,[r4,#0]            ;903
0002d2  b140              CBZ      r0,|L5.742|
0002d4  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;906
0002d8  5c0b              LDRB     r3,[r1,r0]            ;908
0002da  6a31              LDR      r1,[r6,#0x20]         ;908
0002dc  f3630107          BFI      r1,r3,#0,#8           ;908
0002e0  6231              STR      r1,[r6,#0x20]         ;908
0002e2  1c40              ADDS     r0,r0,#1              ;908
0002e4  61a0              STR      r0,[r4,#0x18]         ;909  ; g_TxIndex
                  |L5.742|
0002e6  7860              LDRB     r0,[r4,#1]            ;909  ; g_Ready_Complete
0002e8  2801              CMP      r0,#1                 ;912
0002ea  bf0e              ITEE     EQ                    ;914
0002ec  f1bc0f00          CMPEQ    r12,#0                ;914
0002f0  b003              ADDNE    sp,sp,#0xc
0002f2  e8bd8ff0          POPNE    {r4-r11,pc}
0002f6  9800              LDR      r0,[sp,#0]            ;916
0002f8  f8191000          LDRB     r1,[r9,r0]            ;916
0002fc  6a30              LDR      r0,[r6,#0x20]         ;916
0002fe  f3610007          BFI      r0,r1,#0,#8           ;916
000302  6230              STR      r0,[r6,#0x20]         ;916
000304  6222              STR      r2,[r4,#0x20]         ;918  ; g_TxIndex_Common
000306  b003              ADD      sp,sp,#0xc
000308  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.780|
00030c  b3d8              CBZ      r0,|L5.902|
00030e  2e22              CMP      r6,#0x22              ;932
000310  d002              BEQ      |L5.792|
000312  2e25              CMP      r6,#0x25              ;932
000314  d022              BEQ      |L5.860|
000316  e03c              B        |L5.914|
                  |L5.792|
000318  4835              LDR      r0,|L5.1008|
00031a  7881              LDRB     r1,[r0,#2]            ;940
00031c  78c0              LDRB     r0,[r0,#3]            ;941
00031e  f0110f0f          TST      r1,#0xf               ;940
000322  f000000f          AND      r0,r0,#0xf            ;941
000326  bf08              IT       EQ                    ;941
000328  2808              CMPEQ    r0,#8                 ;941
00032a  d00b              BEQ      |L5.836|
00032c  f001020f          AND      r2,r1,#0xf            ;950
000330  2a01              CMP      r2,#1                 ;950
000332  bf08              IT       EQ                    ;951
000334  2808              CMPEQ    r0,#8                 ;951
000336  d009              BEQ      |L5.844|
000338  f0110f30          TST      r1,#0x30              ;960
00033c  bf08              IT       EQ                    ;961
00033e  2801              CMPEQ    r0,#1                 ;961
000340  d008              BEQ      |L5.852|
000342  e026              B        |L5.914|
                  |L5.836|
000344  6165              STR      r5,[r4,#0x14]         ;944  ; g_TxPtr
000346  61a5              STR      r5,[r4,#0x18]         ;946  ; g_TxIndex
000348  7027              STRB     r7,[r4,#0]            ;946
00034a  e022              B        |L5.914|
                  |L5.844|
00034c  6165              STR      r5,[r4,#0x14]         ;954  ; g_TxPtr
00034e  61a5              STR      r5,[r4,#0x18]         ;956  ; g_TxIndex
000350  7025              STRB     r5,[r4,#0]            ;956
000352  e01e              B        |L5.914|
                  |L5.852|
000354  6165              STR      r5,[r4,#0x14]         ;964  ; g_TxPtr
000356  61a5              STR      r5,[r4,#0x18]         ;966  ; g_TxIndex
000358  7167              STRB     r7,[r4,#5]            ;966
00035a  e01a              B        |L5.914|
                  |L5.860|
00035c  4824              LDR      r0,|L5.1008|
00035e  7227              STRB     r7,[r4,#8]            ;997
000360  7901              LDRB     r1,[r0,#4]            ;1000
000362  2909              CMP      r1,#9                 ;1000
000364  d115              BNE      |L5.914|
000366  1d01              ADDS     r1,r0,#4              ;1002
000368  2240              MOVS     r2,#0x40              ;1002
00036a  30a8              ADDS     r0,r0,#0xa8           ;1002
00036c  f7fffffe          BL       __aeabi_memcpy
000370  4822              LDR      r0,|L5.1020|
000372  7881              LDRB     r1,[r0,#2]            ;1003
000374  2909              CMP      r1,#9                 ;1003
000376  d10a              BNE      |L5.910|
000378  78c1              LDRB     r1,[r0,#3]            ;1003
00037a  f0110f01          TST      r1,#1                 ;1003
00037e  d003              BEQ      |L5.904|
000380  f7fffffe          BL       HidReadWrite__Read_I2C
000384  e003              B        |L5.910|
                  |L5.902|
000386  e00a              B        |L5.926|
                  |L5.904|
000388  1c80              ADDS     r0,r0,#2              ;1003
00038a  f7fffffe          BL       HidReadWrite__Write
                  |L5.910|
00038e  7027              STRB     r7,[r4,#0]            ;1007
000390  70a7              STRB     r7,[r4,#2]            ;1012
                  |L5.914|
000392  2164              MOVS     r1,#0x64              ;1019
000394  4816              LDR      r0,|L5.1008|
000396  f7fffffe          BL       __aeabi_memclr
00039a  6125              STR      r5,[r4,#0x10]         ;1021  ; g_RxCommandIndex
00039c  e004              B        |L5.936|
                  |L5.926|
00039e  f1bc0f00          CMP      r12,#0                ;1024
0003a2  bf04              ITT      EQ                    ;1026
0003a4  71e7              STRBEQ   r7,[r4,#7]            ;1026
0003a6  71a7              STRBEQ   r7,[r4,#6]            ;1027
                  |L5.936|
0003a8  7820              LDRB     r0,[r4,#0]            ;1034  ; g_Ready
0003aa  2801              CMP      r0,#1                 ;1034
0003ac  bf08              IT       EQ                    ;1036
0003ae  7067              STRBEQ   r7,[r4,#1]            ;1036
0003b0  d004              BEQ      |L5.956|
0003b2  7065              STRB     r5,[r4,#1]            ;1040
0003b4  2100              MOVS     r1,#0                 ;1040
0003b6  60e5              STR      r5,[r4,#0xc]          ;1042  ; g_DelayTime
0003b8  e9c4110e          STRD     r1,r1,[r4,#0x38]      ;1042
                  |L5.956|
0003bc  79a0              LDRB     r0,[r4,#6]            ;1045  ; g_GpioDisable
0003be  2801              CMP      r0,#1                 ;1045
0003c0  bf1c              ITT      NE
0003c2  b003              ADDNE    sp,sp,#0xc
0003c4  e8bd8ff0          POPNE    {r4-r11,pc}
0003c8  4808              LDR      r0,|L5.1004|
0003ca  6841              LDR      r1,[r0,#4]            ;1048
0003cc  f4113f80          TST      r1,#0x10000           ;1048
0003d0  d103              BNE      |L5.986|
0003d2  6841              LDR      r1,[r0,#4]            ;1051
0003d4  f4413180          ORR      r1,r1,#0x10000        ;1051
0003d8  6041              STR      r1,[r0,#4]            ;1051
                  |L5.986|
0003da  71a5              STRB     r5,[r4,#6]            ;1054
0003dc  b003              ADD      sp,sp,#0xc
0003de  e8bd8ff0          POP      {r4-r11,pc}
0003e2  0000              DCW      0x0000
                  |L5.996|
                          DCD      0x40002000
                  |L5.1000|
                          DCD      ||area_number.14||
                  |L5.1004|
                          DCD      0x40007000
                  |L5.1008|
                          DCD      ||.bss||
                  |L5.1012|
                          DCD      protocol_ClearInterrupt
                  |L5.1016|
                          DCD      protocol_GetMappedPointer
                  |L5.1020|
                          DCD      ||.bss||+0xa6
                          ENDP


                          AREA ||i.QueueCommonData_I2C||, CODE, READONLY, ALIGN=2

                  QueueCommonData_I2C PROC
;;;487    
;;;488    void QueueCommonData_I2C(void)
000000  b510              PUSH     {r4,lr}
;;;489    {
;;;490    	if ((g_CheckComplete_Common_I2C == DMA_READY) && (g_RxCommandIndex == 0))
000002  4c12              LDR      r4,|L6.76|
000004  79e0              LDRB     r0,[r4,#7]  ; g_CheckComplete_Common_I2C
000006  2801              CMP      r0,#1
000008  bf06              ITTE     EQ
00000a  6920              LDREQ    r0,[r4,#0x10]  ; g_RxCommandIndex
00000c  2800              CMPEQ    r0,#0
;;;491    	{
;;;492    		if (StaticQueue_CheckEmpty(&g_Queue_Common) == 0)
;;;493    		{
;;;494    			// Pop
;;;495    			if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Common_I2C) == TRUE)
;;;496    			{
;;;497    				// Flag
;;;498    				g_CheckComplete_Common_I2C = DMA_NOT_READY;
;;;499    
;;;500    				// Pointer
;;;501    				g_TxPtr_Common = (uint8_t*)&g_Common_I2C;
;;;502    				g_TxIndex_Common = 0;
;;;503    
;;;504    				// Clear Tx
;;;505    				I2C->I2C_FIFO_CR.ulBulk |= 0x01;
;;;506    
;;;507    				// GPIO Interrupt Enable
;;;508    				GPIO->tGPIO_DATA_1.tBit.GPB10 = I2C_GPB10__LOW;
;;;509    			}
;;;510    		}
;;;511    	}
;;;512    
;;;513    	return;
;;;514    }
00000e  bd10              POPNE    {r4,pc}
000010  480f              LDR      r0,|L6.80|
000012  f7fffffe          BL       StaticQueue_CheckEmpty
000016  2800              CMP      r0,#0                 ;492
000018  bf18              IT       NE
00001a  bd10              POPNE    {r4,pc}
00001c  490d              LDR      r1,|L6.84|
00001e  480c              LDR      r0,|L6.80|
000020  f7fffffe          BL       StaticQueue_Pop
000024  2801              CMP      r0,#1                 ;495
000026  bf18              IT       NE
000028  bd10              POPNE    {r4,pc}
00002a  2100              MOVS     r1,#0                 ;498
00002c  71e1              STRB     r1,[r4,#7]            ;498
00002e  4809              LDR      r0,|L6.84|
000030  e9c40107          STRD     r0,r1,[r4,#0x1c]      ;501
000034  4808              LDR      r0,|L6.88|
000036  69c1              LDR      r1,[r0,#0x1c]         ;505
000038  f0410101          ORR      r1,r1,#1              ;505
00003c  61c1              STR      r1,[r0,#0x1c]         ;505
00003e  4807              LDR      r0,|L6.92|
000040  6841              LDR      r1,[r0,#4]            ;508
000042  f4213180          BIC      r1,r1,#0x10000        ;508
000046  6041              STR      r1,[r0,#4]            ;508
000048  bd10              POP      {r4,pc}
;;;515    
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      ||area_number.14||
                  |L6.80|
                          DCD      g_Queue_Common
                  |L6.84|
                          DCD      ||.bss||+0x64
                  |L6.88|
                          DCD      0x40002000
                  |L6.92|
                          DCD      0x40007000

                          AREA ||i.RecieveCustomData_I2C||, CODE, READONLY, ALIGN=1

                  RecieveCustomData_I2C PROC
;;;403    
;;;404    void RecieveCustomData_I2C(PHJ_HID_CONTROL_STRUCT_I2C pData)
000000  7881              LDRB     r1,[r0,#2]
;;;405    {
;;;406    	switch (pData->Data.PacketID)
000002  2909              CMP      r1,#9
;;;407    	{
;;;408    		case HID_REPORT_ID__CUSTOM_OUT:
;;;409    		{
;;;410    			if (pData->Data.DeviceID_b.bRead)
;;;411    			{
;;;412    				HidReadWrite__Read_I2C(pData);
;;;413    			}
;;;414    			else
;;;415    			{
;;;416    				HidReadWrite__Write(&pData->Data);
;;;417    			}
;;;418    
;;;419    			break;
;;;420    		}
;;;421    	}
;;;422    
;;;423    	return;
;;;424    }
000004  bf18              IT       NE
000006  4770              BXNE     lr
000008  78c1              LDRB     r1,[r0,#3]            ;410
00000a  f0110f01          TST      r1,#1                 ;410
00000e  d001              BEQ      |L7.20|
000010  f7ffbffe          B.W      HidReadWrite__Read_I2C
                  |L7.20|
000014  1c80              ADDS     r0,r0,#2              ;412
000016  f7ffbffe          B.W      HidReadWrite__Write
;;;425    
                          ENDP


                          AREA ||i.SendCustomData_I2C||, CODE, READONLY, ALIGN=2

                  SendCustomData_I2C PROC
;;;381    
;;;382    void SendCustomData_I2C(PHJ_HID_CONTROL_STRUCT_I2C pUserData)
000000  b510              PUSH     {r4,lr}
;;;383    {
000002  4604              MOV      r4,r0
;;;384    	if (StaticQueue_CheckInit(&g_Queue_Common) == 0)
000004  480a              LDR      r0,|L8.48|
000006  f7fffffe          BL       StaticQueue_CheckInit
00000a  2800              CMP      r0,#0
;;;385    	{
;;;386    		// Init Queue
;;;387    		StaticQueue_Init(&g_Queue_Common);
00000c  bf04              ITT      EQ
00000e  4808              LDREQ    r0,|L8.48|
000010  f7fffffe          BLEQ     StaticQueue_Init
;;;388    	}
;;;389    
;;;390    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
000014  4806              LDR      r0,|L8.48|
000016  f7fffffe          BL       StaticQueue_CheckFull
00001a  2801              CMP      r0,#1
;;;391    	{
;;;392    		// 큐의 최대치를 넘어가면..  (데이터 손실)
;;;393    		goto SENDCUSTOMDATA_I2C__GOTO_END;
;;;394    	}
;;;395    
;;;396    	pUserData->I2C_Length = sizeof(HJ_HID_CONTROL_STRUCT_I2C);
;;;397    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
;;;398    
;;;399    SENDCUSTOMDATA_I2C__GOTO_END:
;;;400    
;;;401    	return;
;;;402    }
00001c  bf08              IT       EQ
00001e  bd10              POPEQ    {r4,pc}
000020  2042              MOVS     r0,#0x42              ;396
000022  8020              STRH     r0,[r4,#0]            ;396
000024  4621              MOV      r1,r4                 ;397
000026  e8bd4010          POP      {r4,lr}               ;397
00002a  4801              LDR      r0,|L8.48|
00002c  f7ffbffe          B.W      StaticQueue_Push
;;;403    
                          ENDP

                  |L8.48|
                          DCD      g_Queue_Common

                          AREA ||i.swap_uint16||, CODE, READONLY, ALIGN=1

                  swap_uint16 PROC
;;;426    
;;;427    uint16_t swap_uint16(uint16_t val)
000000  0201              LSLS     r1,r0,#8
;;;428    {
;;;429    	return (val << 8) | (val >> 8);
000002  ea412010          ORR      r0,r1,r0,LSR #8
000006  b280              UXTH     r0,r0
;;;430    }
000008  4770              BX       lr
;;;431    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_RxCommand
                          %        100
                  g_Common_I2C
                          %        66
                  g_CustomBuffer_I2C
                          %        66

                          AREA ||.data||, DATA, ALIGN=2

                  g_I2C
                          DCD      0x40002000

                          AREA ||area_number.14||, DATA, ALIGN=3

                          EXPORTAS ||area_number.14||, ||.data||
                  g_Ready
000000  00                DCB      0x00
                  g_Ready_Complete
000001  00                DCB      0x00
                  g_DelayCheck
000002  00                DCB      0x00
                  g_ConnectedDevice
000003  01                DCB      0x01
                  g_ConnectedDevice_FirstCheck
000004  00                DCB      0x00
                  g_bReset
000005  00                DCB      0x00
                  g_GpioDisable
000006  00                DCB      0x00
                  g_CheckComplete_Common_I2C
000007  01                DCB      0x01
                  custom_tool
000008  0000              DCB      0x00,0x00
                  usRegAddr
00000a  0000              DCW      0x0000
                  g_DelayTime
                          DCD      0x00000000
                  g_RxCommandIndex
                          DCD      0x00000000
                  g_TxPtr
                          DCD      0x00000000
                  g_TxIndex
                          DCD      0x00000000
                  g_TxPtr_Common
                          DCD      0x00000000
                  g_TxIndex_Common
                          DCD      0x00000000
                  rmi_read_ptr
                          DCD      0x00000000
                  rmi_write_ptr
                          DCD      0x00000000
                  i2c_sent_byte
                          DCD      0x00000000
                  i2c_received_byte
                          DCD      0x00000000
                          DCD      0x00000000
                  g_StartTime_I2C
000038  00000000          DCQ      0x0000000000000000
00003c  00000000

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  g_TxPtr_Touch
                          DCD      0x00000000

                          AREA ||area_number.16||, DATA, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.data||
                  g_TxIndex_Touch
                          DCD      0x00000000

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  g_TxPtr_Pen
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  g_TxIndex_Pen
                          DCD      0x00000000

                          AREA ||area_number.19||, DATA, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.data||
                  g_TxPtr_Custom
                          DCD      0x00000000

                          AREA ||area_number.20||, DATA, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.data||
                  g_TxIndex_Custom
                          DCD      0x00000000

                          AREA ||area_number.21||, DATA, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.data||
                  g_CheckComplete_Custom_I2C
000000  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\i2c\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___5_i2c_c_g_I2C____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____REVSH|
#line 402
|__asm___5_i2c_c_g_I2C____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_g_I2C____RRX|
#line 587
|__asm___5_i2c_c_g_I2C____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
