; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\protocol_swip.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\protocol_swip.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\protocol_swip.crf ..\..\Protocol\protocol_swip.c]
                          THUMB

                          AREA ||i.Hal_ClearIntr||, CODE, READONLY, ALIGN=2

                  Hal_ClearIntr PROC
;;;471    
;;;472    void Hal_ClearIntr(void) 
000000  b510              PUSH     {r4,lr}
;;;473    {
;;;474      if(CheckI2CReady() || !protocol_swip_GetEventIntrType()) return;
000002  f7fffffe          BL       CheckI2CReady
000006  2800              CMP      r0,#0
;;;475    	
;;;476    	GPIO->tGPIO_DATA_1.tBit.GPB10 = 0x01;
;;;477    }
000008  bf18              IT       NE
00000a  bd10              POPNE    {r4,pc}
00000c  4805              LDR      r0,|L1.36|
00000e  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000010  7840              LDRB     r0,[r0,#1]
000012  2801              CMP      r0,#1
000014  bf18              IT       NE
000016  bd10              POPNE    {r4,pc}
000018  4803              LDR      r0,|L1.40|
00001a  6841              LDR      r1,[r0,#4]            ;476
00001c  f4413180          ORR      r1,r1,#0x10000        ;476
000020  6041              STR      r1,[r0,#4]            ;476
000022  bd10              POP      {r4,pc}
;;;478    
                          ENDP

                  |L1.36|
                          DCD      tProtocolCtrl
                  |L1.40|
                          DCD      0x40007000

                          AREA ||i.Hal_GetIntr||, CODE, READONLY, ALIGN=2

                  Hal_GetIntr PROC
;;;478    
;;;479    bool_t Hal_GetIntr(void)
000000  b510              PUSH     {r4,lr}
;;;480    {
;;;481     
;;;482     if(CheckI2CReady()||!protocol_swip_GetEventIntrType()) return 0;
000002  f7fffffe          BL       CheckI2CReady
000006  b968              CBNZ     r0,|L2.36|
000008  4807              LDR      r0,|L2.40|
00000a  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
00000c  7840              LDRB     r0,[r0,#1]
00000e  2801              CMP      r0,#1
000010  d108              BNE      |L2.36|
;;;483    	
;;;484    	if(GPIO->tGPIO_DATA_1.tBit.GPB10 == 0x00)
000012  4806              LDR      r0,|L2.44|
000014  6841              LDR      r1,[r0,#4]
000016  f4113f80          TST      r1,#0x10000
00001a  d103              BNE      |L2.36|
;;;485    	{
;;;486    		GPIO->tGPIO_DATA_1.tBit.GPB10 = 0x01;
00001c  6841              LDR      r1,[r0,#4]
00001e  f4413180          ORR      r1,r1,#0x10000
000022  6041              STR      r1,[r0,#4]
                  |L2.36|
;;;487    	}
;;;488    
;;;489    	return 0;
000024  2000              MOVS     r0,#0
;;;490    }
000026  bd10              POP      {r4,pc}
;;;491    void Hal_PendIntr(void)
                          ENDP

                  |L2.40|
                          DCD      tProtocolCtrl
                  |L2.44|
                          DCD      0x40007000

                          AREA ||i.Hal_PendIntr||, CODE, READONLY, ALIGN=2

                  Hal_PendIntr PROC
;;;490    }
;;;491    void Hal_PendIntr(void)
000000  b510              PUSH     {r4,lr}
;;;492    {
;;;493      
;;;494      if(CheckI2CReady() || !protocol_swip_GetEventIntrType()) return;
000002  f7fffffe          BL       CheckI2CReady
000006  2800              CMP      r0,#0
;;;495    	GPIO->tGPIO_DATA_1.tBit.GPB10 = 0x00;
;;;496    }
000008  bf18              IT       NE
00000a  bd10              POPNE    {r4,pc}
00000c  4805              LDR      r0,|L3.36|
00000e  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000010  7840              LDRB     r0,[r0,#1]
000012  2801              CMP      r0,#1
000014  bf18              IT       NE
000016  bd10              POPNE    {r4,pc}
000018  4803              LDR      r0,|L3.40|
00001a  6841              LDR      r1,[r0,#4]            ;495
00001c  f4213180          BIC      r1,r1,#0x10000        ;495
000020  6041              STR      r1,[r0,#4]            ;495
000022  bd10              POP      {r4,pc}
;;;497    
                          ENDP

                  |L3.36|
                          DCD      tProtocolCtrl
                  |L3.40|
                          DCD      0x40007000

                          AREA ||i.protocol_swip_CheckEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_CheckEventInterrupt PROC
;;;719    
;;;720    bool_t protocol_swip_CheckEventInterrupt(void)
000000  480c              LDR      r0,|L4.52|
;;;721    {
;;;722        thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
000002  6841              LDR      r1,[r0,#4]  ; tProtocolCtrl
000004  784a              LDRB     r2,[r1,#1]
000006  490c              LDR      r1,|L4.56|
000008  6849              LDR      r1,[r1,#4]  ; thisInfo
00000a  700a              STRB     r2,[r1,#0]
;;;723        switch( thisInfo->eEventTriggerType )
00000c  b2d1              UXTB     r1,r2
00000e  2901              CMP      r1,#1
000010  d002              BEQ      |L4.24|
000012  2902              CMP      r1,#2
000014  d006              BEQ      |L4.36|
000016  e008              B        |L4.42|
                  |L4.24|
;;;724        {
;;;725        case ETT_INTERRUPT:
;;;726            if(GPIO->tGPIO_DATA_1.tBit.GPB10 == 0x01 )	return YES;
000018  4808              LDR      r0,|L4.60|
00001a  6840              LDR      r0,[r0,#4]
00001c  f4103080          ANDS     r0,r0,#0x10000
000020  d105              BNE      |L4.46|
;;;727    		else									return NO;
;;;728    //        break; // NOTE : warning����
;;;729        case ETT_REGISTER:
;;;730            if(tProtocolCtrl.getter->bEventReady == NO) 	return YES;
;;;731    		else											return NO;
;;;732    //        break; // NOTE : warning����
;;;733        default:
;;;734        	break;
;;;735        }
;;;736    
;;;737        return NO; // NOTE : warning����
;;;738    }
000022  4770              BX       lr
                  |L4.36|
000024  6800              LDR      r0,[r0,#0]            ;730  ; tProtocolCtrl
000026  7840              LDRB     r0,[r0,#1]            ;730
000028  b108              CBZ      r0,|L4.46|
                  |L4.42|
00002a  2000              MOVS     r0,#0                 ;737
00002c  4770              BX       lr
                  |L4.46|
00002e  2001              MOVS     r0,#1                 ;730
000030  4770              BX       lr
;;;739    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      tProtocolCtrl
                  |L4.56|
                          DCD      ||.data||
                  |L4.60|
                          DCD      0x40007000

                          AREA ||i.protocol_swip_ClearEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_ClearEventInterrupt PROC
;;;706    
;;;707    void protocol_swip_ClearEventInterrupt(void)
000000  480e              LDR      r0,|L5.60|
;;;708    {
000002  b510              PUSH     {r4,lr}
;;;709        switch( thisInfo->eEventTriggerType )
000004  6840              LDR      r0,[r0,#4]  ; thisInfo
000006  4c0e              LDR      r4,|L5.64|
000008  7801              LDRB     r1,[r0,#0]
00000a  2000              MOVS     r0,#0
00000c  2901              CMP      r1,#1
00000e  d004              BEQ      |L5.26|
000010  2902              CMP      r1,#2
;;;710        {
;;;711        case ETT_INTERRUPT:
;;;712            Hal_ClearIntr();
;;;713            break;
;;;714        case ETT_REGISTER:
;;;715            tProtocolCtrl.getter->bEventReady = NO;
000012  bf04              ITT      EQ
000014  6821              LDREQ    r1,[r4,#0]  ; tProtocolCtrl
000016  7048              STRBEQ   r0,[r1,#1]
;;;716            break;
;;;717        }
;;;718    }
000018  bd10              POP      {r4,pc}
                  |L5.26|
00001a  f7fffffe          BL       CheckI2CReady
00001e  2800              CMP      r0,#0
000020  bf18              IT       NE
000022  bd10              POPNE    {r4,pc}
000024  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
000026  7840              LDRB     r0,[r0,#1]
000028  2801              CMP      r0,#1
00002a  bf18              IT       NE
00002c  bd10              POPNE    {r4,pc}
00002e  4805              LDR      r0,|L5.68|
000030  6841              LDR      r1,[r0,#4]
000032  f4413180          ORR      r1,r1,#0x10000
000036  6041              STR      r1,[r0,#4]
000038  bd10              POP      {r4,pc}
;;;719    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      ||.data||
                  |L5.64|
                          DCD      tProtocolCtrl
                  |L5.68|
                          DCD      0x40007000

                          AREA ||i.protocol_swip_ClearInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_ClearInterrupt PROC
;;;1660   
;;;1661   void protocol_swip_ClearInterrupt(uint16_t _addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1662   {
;;;1663   	uint16_t SWIP_REG_ADDR;
;;;1664   	
;;;1665   	if(thisInfo->eEventTriggerType == ETT_REGISTER)
000004  4a27              LDR      r2,|L6.164|
000006  f8d2c004          LDR      r12,[r2,#4]  ; thisInfo
00000a  f89c1000          LDRB     r1,[r12,#0]
00000e  2902              CMP      r1,#2
;;;1666   	{
;;;1667   		SWIP_REG_ADDR = SWIP_REG_ADDR_EVENT_PACKET_INFO;
000010  bf0c              ITE      EQ
000012  f44f7304          MOVEQ    r3,#0x210
;;;1668   	}
;;;1669   	else
;;;1670   	{
;;;1671   		SWIP_REG_ADDR = SWIP_REG_ADDR_EVENT_PACKET_CONTENT;
000016  f2402311          MOVNE    r3,#0x211
;;;1672   	}
;;;1673   
;;;1674       if( _addr == SWIP_REG_ADDR_CTRL_GETTER + offsetof(tProtocolGetter_t, eReadyStatus) )
;;;1675       {
;;;1676           if( tProtocolCtrl.getter->eReadyStatus != RS_NONE )
00001a  4c23              LDR      r4,|L6.168|
00001c  f5b06fc0          CMP      r0,#0x600             ;1674
000020  6821              LDR      r1,[r4,#0]
000022  d024              BEQ      |L6.110|
000024  332f              ADDS     r3,r3,#0x2f           ;1662
;;;1677               tProtocolCtrl.getter->eReadyStatus = RS_NONE;
;;;1678       }
;;;1679       //Touch packet�� ������ data�� �о ��,
;;;1680       else if( _addr == SWIP_REG_ADDR + TEST_DEVICE_READ_PACKED - 1 )
000026  4298              CMP      r0,r3
;;;1681       {
;;;1682   #if (SWIP_QUEUE_MODE)
;;;1683   		if(sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear) // Not Queue Empty
;;;1684   		{
;;;1685   			sptAlgorithmInfo->QueueFront++;
;;;1686   			sptAlgorithmInfo->QueueFront = (sptAlgorithmInfo->QueueFront) % SWIP_QUEUE_SIZE;
;;;1687   		}
;;;1688   #endif
;;;1689           protocol_swip_ClearEventInterrupt();
;;;1690       }
;;;1691   
;;;1692   #if defined(SUPPORT_ANDROID)
;;;1693   		else if( _addr == SWIP_REG_ADDR_ANDROID_PACKET_DATA + 12)
;;;1694   		{
;;;1695   			protocol_swip_ClearEventInterrupt();
;;;1696   		}
;;;1697   #endif		
;;;1698   }
000028  bf18              IT       NE
00002a  e8bd81f0          POPNE    {r4-r8,pc}
00002e  6890              LDR      r0,[r2,#8]            ;1683  ; sptAlgorithmInfo
000030  2500              MOVS     r5,#0                 ;1683
000032  f5005080          ADD      r0,r0,#0x1000         ;1683
000036  f8902f9d          LDRB     r2,[r0,#0xf9d]        ;1683
00003a  f8903f9c          LDRB     r3,[r0,#0xf9c]        ;1683
00003e  429a              CMP      r2,r3                 ;1683
000040  d00c              BEQ      |L6.92|
000042  4f1a              LDR      r7,|L6.172|
000044  1c52              ADDS     r2,r2,#1              ;1683
000046  b2d2              UXTB     r2,r2                 ;1685
000048  463e              MOV      r6,r7                 ;1686
00004a  2300              MOVS     r3,#0                 ;1686
00004c  fbe26307          UMLAL    r6,r3,r2,r7           ;1686
000050  085b              LSRS     r3,r3,#1              ;1686
000052  eba303c3          SUB      r3,r3,r3,LSL #3       ;1686
000056  441a              ADD      r2,r2,r3              ;1686
000058  f8802f9d          STRB     r2,[r0,#0xf9d]        ;1686
                  |L6.92|
00005c  f89c0000          LDRB     r0,[r12,#0]           ;1686
000060  2801              CMP      r0,#1                 ;1686
000062  d00b              BEQ      |L6.124|
000064  2802              CMP      r0,#2                 ;1686
000066  bf08              IT       EQ                    ;1686
000068  704d              STRBEQ   r5,[r1,#1]            ;1686
00006a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.110|
00006e  7808              LDRB     r0,[r1,#0]            ;1676
000070  2805              CMP      r0,#5                 ;1676
000072  bf1c              ITT      NE                    ;1677
000074  2005              MOVNE    r0,#5                 ;1677
000076  7008              STRBNE   r0,[r1,#0]            ;1677
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L6.124|
00007c  f7fffffe          BL       CheckI2CReady
000080  2800              CMP      r0,#0
000082  bf18              IT       NE
000084  e8bd81f0          POPNE    {r4-r8,pc}
000088  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
00008a  7840              LDRB     r0,[r0,#1]
00008c  2801              CMP      r0,#1
00008e  bf18              IT       NE
000090  e8bd81f0          POPNE    {r4-r8,pc}
000094  4806              LDR      r0,|L6.176|
000096  6841              LDR      r1,[r0,#4]
000098  f4413180          ORR      r1,r1,#0x10000
00009c  6041              STR      r1,[r0,#4]
00009e  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

0000a2  0000              DCW      0x0000
                  |L6.164|
                          DCD      ||.data||
                  |L6.168|
                          DCD      tProtocolCtrl
                  |L6.172|
                          DCD      0x49249249
                  |L6.176|
                          DCD      0x40007000

                          AREA ||i.protocol_swip_GetABSCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetABSCount PROC
;;;922    
;;;923    uint8_t protocol_swip_GetABSCount(void)
000000  4801              LDR      r0,|L7.8|
;;;924    {
;;;925        return tSWIPTest.tTest.ptCtrl->ucABSCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7880              LDRB     r0,[r0,#2]
;;;926    }
000006  4770              BX       lr
;;;927    
                          ENDP

                  |L7.8|
                          DCD      ||.data||+0x76

                          AREA ||i.protocol_swip_GetABSDiffCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetABSDiffCount PROC
;;;917    
;;;918    uint8_t protocol_swip_GetABSDiffCount(void)
000000  4801              LDR      r0,|L8.8|
;;;919    {
;;;920        return tSWIPTest.tTest.ptCtrl->ucABSDiffCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7840              LDRB     r0,[r0,#1]
;;;921    }
000006  4770              BX       lr
;;;922    
                          ENDP

                  |L8.8|
                          DCD      ||.data||+0x76

                          AREA ||i.protocol_swip_GetChargerAttached||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetChargerAttached PROC
;;;867    
;;;868    bool_t protocol_swip_GetChargerAttached(void)
000000  4801              LDR      r0,|L9.8|
;;;869    {
;;;870        return tProtocolCtrl.setter->bChargerAttached;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7a40              LDRB     r0,[r0,#9]
;;;871    }
000006  4770              BX       lr
;;;872    
                          ENDP

                  |L9.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetDCABSCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetDCABSCount PROC
;;;927    
;;;928    uint8_t protocol_swip_GetDCABSCount(void)
000000  4801              LDR      r0,|L10.8|
;;;929    {
;;;930        return tSWIPTest.tTest.ptCtrl->ucDCABSCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  78c0              LDRB     r0,[r0,#3]
;;;931    }
000006  4770              BX       lr
;;;932    
                          ENDP

                  |L10.8|
                          DCD      ||.data||+0x76

                          AREA ||i.protocol_swip_GetDisableESDAlert||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetDisableESDAlert PROC
;;;857    
;;;858    bool_t protocol_swip_GetDisableESDAlert(void)
000000  4801              LDR      r0,|L11.8|
;;;859    {
;;;860        return tProtocolCtrl.setter->bDisableESDAlert;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7a00              LDRB     r0,[r0,#8]
;;;861    }
000006  4770              BX       lr
;;;862    
                          ENDP

                  |L11.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetDisableEdgeExpand||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetDisableEdgeExpand PROC
;;;907    
;;;908    bool_t protocol_swip_GetDisableEdgeExpand(void)
000000  4801              LDR      r0,|L12.8|
;;;909    {
;;;910        return tProtocolCtrl.setter->bDisableEdgeExpand;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7b40              LDRB     r0,[r0,#0xd]
;;;911    }
000006  4770              BX       lr
;;;912    
                          ENDP

                  |L12.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetEventIntrType||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetEventIntrType PROC
;;;800    
;;;801    bool_t protocol_swip_GetEventIntrType(void)
000000  4803              LDR      r0,|L13.16|
;;;802    {
;;;803       return (tProtocolCtrl.setter->eEventTriggerType == ETT_INTERRUPT) ? YES : NO;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7840              LDRB     r0,[r0,#1]
000006  2801              CMP      r0,#1
000008  bf18              IT       NE
00000a  2000              MOVNE    r0,#0
;;;804    }
00000c  4770              BX       lr
;;;805    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetGNDNoiseHandlingStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetGNDNoiseHandlingStatus PROC
;;;1585   
;;;1586   bool_t protocol_swip_GetGNDNoiseHandlingStatus(void)
000000  4801              LDR      r0,|L14.8|
;;;1587   {
;;;1588       return tSWIPSpecialAction.ptControlForTuning->bGNDNoiseStatus;
000002  6800              LDR      r0,[r0,#0]  ; tSWIPSpecialAction
000004  7800              LDRB     r0,[r0,#0]
;;;1589   }
000006  4770              BX       lr
;;;1590   
                          ENDP

                  |L14.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_GetGestureType||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetGestureType PROC
;;;847    
;;;848    uint32_t protocol_swip_GetGestureType(void)
000000  4801              LDR      r0,|L15.8|
;;;849    {
;;;850        return tProtocolCtrl.setter->ulGestureType;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  6840              LDR      r0,[r0,#4]
;;;851    }
000006  4770              BX       lr
;;;852    
                          ENDP

                  |L15.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetGloveSensingEnable||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetGloveSensingEnable PROC
;;;887    
;;;888    bool_t protocol_swip_GetGloveSensingEnable(void)
000000  4801              LDR      r0,|L16.8|
;;;889    {
;;;890        return tProtocolCtrl.setter->bGloveSensingEnable;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7a80              LDRB     r0,[r0,#0xa]
;;;891    }
000006  4770              BX       lr
;;;892    
                          ENDP

                  |L16.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetJitterAVGCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetJitterAVGCount PROC
;;;932    
;;;933    uint8_t protocol_swip_GetJitterAVGCount(void)
000000  4801              LDR      r0,|L17.8|
;;;934    {
;;;935        return tSWIPTest.tTest.ptCtrl->ucJitterAVGCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7900              LDRB     r0,[r0,#4]
;;;936    }
000006  4770              BX       lr
;;;937    
                          ENDP

                  |L17.8|
                          DCD      ||.data||+0x76

                          AREA ||i.protocol_swip_GetJitterMAXCount||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetJitterMAXCount PROC
;;;937    
;;;938    uint8_t protocol_swip_GetJitterMAXCount(void)
000000  4801              LDR      r0,|L18.8|
;;;939    {
;;;940        return tSWIPTest.tTest.ptCtrl->ucJitterMAXCount;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7940              LDRB     r0,[r0,#5]
;;;941    }
000006  4770              BX       lr
;;;942    
                          ENDP

                  |L18.8|
                          DCD      ||.data||+0x76

                          AREA ||i.protocol_swip_GetLCDNoiseHandlingStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetLCDNoiseHandlingStatus PROC
;;;1595   
;;;1596   bool_t protocol_swip_GetLCDNoiseHandlingStatus(void)
000000  4801              LDR      r0,|L19.8|
;;;1597   {
;;;1598       return tSWIPSpecialAction.ptControlForTuning->bLCDNoiseStatus;
000002  6800              LDR      r0,[r0,#0]  ; tSWIPSpecialAction
000004  7840              LDRB     r0,[r0,#1]
;;;1599   }
000006  4770              BX       lr
;;;1600   
                          ENDP

                  |L19.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_GetMappedPointer||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetMappedPointer PROC
;;;1626   
;;;1627   uint8_t* protocol_swip_GetMappedPointer(uint16_t _addr)
000000  0a02              LSRS     r2,r0,#8
;;;1628   {
;;;1629   	int i;
;;;1630   	uint8_t maddr = MSB(_addr), laddr = LSB(_addr);
000002  b2c1              UXTB     r1,r0
;;;1631   
;;;1632   	if(_addr >= SWIP_REG_ADDR_RESERVED)
000004  f5b04f70          CMP      r0,#0xf000
000008  d22d              BCS      |L20.102|
;;;1633   		return (uint8_t*)0;
;;;1634   	if(maddr < GET_ARRAY_(vtMRmiMap))
00000a  2a15              CMP      r2,#0x15
00000c  d214              BCS      |L20.56|
;;;1635   	{
;;;1636   		const tSWIPSubsetInfo_t* info = vtMRmiMap[maddr];
00000e  4817              LDR      r0,|L20.108|
000010  f8503022          LDR      r3,[r0,r2,LSL #2]
;;;1637   		for(i = info->iSize; i--;)
000014  689a              LDR      r2,[r3,#8]
000016  1e50              SUBS     r0,r2,#1
;;;1638   		{
;;;1639   			int start_addr = info->vucStartLAddr[i];
000018  bf28              IT       CS
00001a  f8d3c004          LDRCS    r12,[r3,#4]
00001e  d322              BCC      |L20.102|
                  |L20.32|
000020  f81c2000          LDRB     r2,[r12,r0]
;;;1640   			if(laddr >= start_addr)
000024  4291              CMP      r1,r2
000026  db04              BLT      |L20.50|
;;;1641   			{
;;;1642   				return info->ppucData[i] + laddr - start_addr;
000028  681b              LDR      r3,[r3,#0]
00002a  f8530020          LDR      r0,[r3,r0,LSL #2]
00002e  4408              ADD      r0,r0,r1
000030  e015              B        |L20.94|
                  |L20.50|
000032  1e40              SUBS     r0,r0,#1
000034  d2f4              BCS      |L20.32|
000036  e016              B        |L20.102|
                  |L20.56|
;;;1643   			}
;;;1644   		}
;;;1645   	}
;;;1646   	else //16K buffers.
;;;1647   	{
;;;1648   		for(i = tSWIPBufferInfo.iSize; i--;)
000038  f8dfc034          LDR      r12,|L20.112|
00003c  f8dc2008          LDR      r2,[r12,#8]  ; tSWIPBufferInfo
000040  1e51              SUBS     r1,r2,#1
;;;1649   		{
;;;1650   			int start_addr = tSWIPBufferInfo.vusStartAddr[i];
000042  bf28              IT       CS
000044  f8dc3004          LDRCS    r3,[r12,#4]
000048  d30d              BCC      |L20.102|
00004a  bf00              NOP      
                  |L20.76|
00004c  f8332011          LDRH     r2,[r3,r1,LSL #1]
;;;1651   
;;;1652   			if(_addr >= start_addr)
000050  4290              CMP      r0,r2
000052  db06              BLT      |L20.98|
;;;1653   			{
;;;1654   				return tSWIPBufferInfo.ppucBuffer[i] + _addr - start_addr;
000054  f8dc3000          LDR      r3,[r12,#0]  ; tSWIPBufferInfo
000058  f8531021          LDR      r1,[r3,r1,LSL #2]
00005c  4408              ADD      r0,r0,r1
                  |L20.94|
00005e  1a80              SUBS     r0,r0,r2
;;;1655   			}
;;;1656   		}
;;;1657   	}
;;;1658   	return (uint8_t*)NULL;
;;;1659   }
000060  4770              BX       lr
                  |L20.98|
000062  1e49              SUBS     r1,r1,#1
000064  d2f2              BCS      |L20.76|
                  |L20.102|
000066  2000              MOVS     r0,#0                 ;1658
000068  4770              BX       lr
;;;1660   
                          ENDP

00006a  0000              DCW      0x0000
                  |L20.108|
                          DCD      ||.data||+0x9c
                  |L20.112|
                          DCD      ||.data||+0x8e

                          AREA ||i.protocol_swip_GetMode||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetMode PROC
;;;790    
;;;791    eProtocolMode_t protocol_swip_GetMode(void)
000000  4801              LDR      r0,|L21.8|
;;;792    {
;;;793        return tProtocolCtrl.setter->eMode;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7800              LDRB     r0,[r0,#0]
;;;794    }
000006  4770              BX       lr
;;;795    
                          ENDP

                  |L21.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetOscVal||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetOscVal PROC
;;;1605   
;;;1606   uint8_t protocol_swip_GetOscVal(void)
000000  4801              LDR      r0,|L22.8|
;;;1607   {
;;;1608       return tSWIPSpecialAction.ptControlForTuning->ucOscVal;
000002  6800              LDR      r0,[r0,#0]  ; tSWIPSpecialAction
000004  7880              LDRB     r0,[r0,#2]
;;;1609   }
000006  4770              BX       lr
;;;1610   
                          ENDP

                  |L22.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_GetPacketFormatId||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetPacketFormatId PROC
;;;993    
;;;994    eSWIPPacketFormatId_t protocol_swip_GetPacketFormatId(void)
000000  4801              LDR      r0,|L23.8|
;;;995    {
;;;996        return thisCommonConf->ePacketFormatId;
000002  6800              LDR      r0,[r0,#0]  ; thisCommonConf
000004  8800              LDRH     r0,[r0,#0]
;;;997    }
000006  4770              BX       lr
;;;998    
                          ENDP

                  |L23.8|
                          DCD      ||.data||

                          AREA ||i.protocol_swip_GetPalmRejectionEnable||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetPalmRejectionEnable PROC
;;;897    
;;;898    bool_t protocol_swip_GetPalmRejectionEnable(void)
000000  4801              LDR      r0,|L24.8|
;;;899    {
;;;900        return tProtocolCtrl.setter->bPalmRejectionEnable;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7b00              LDRB     r0,[r0,#0xc]
;;;901    }
000006  4770              BX       lr
;;;902    
                          ENDP

                  |L24.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetPowerConsumptionState||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetPowerConsumptionState PROC
;;;837    
;;;838    ePowerConsumptionState_t protocol_swip_GetPowerConsumptionState(void)
000000  4801              LDR      r0,|L25.8|
;;;839    {
;;;840        return tProtocolCtrl.setter->ePowerConsumptionState;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  78c0              LDRB     r0,[r0,#3]
;;;841    }
000006  4770              BX       lr
;;;842    
                          ENDP

                  |L25.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetReadModuleConfigStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetReadModuleConfigStatus PROC
;;;1615   
;;;1616   bool_t protocol_swip_GetReadModuleConfigStatus(void)
000000  4801              LDR      r0,|L26.8|
;;;1617   {
;;;1618       return tSWIPSpecialAction.ptControlForTuning->bReadModuleConfig;
000002  6800              LDR      r0,[r0,#0]  ; tSWIPSpecialAction
000004  78c0              LDRB     r0,[r0,#3]
;;;1619   }
000006  4770              BX       lr
;;;1620   
                          ENDP

                  |L26.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_GetRecalibrate||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetRecalibrate PROC
;;;827    #endif
;;;828    bool_t protocol_swip_GetRecalibrate(void)
000000  4801              LDR      r0,|L27.8|
;;;829    {
;;;830        return tProtocolCtrl.setter->bRecalibrate;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7880              LDRB     r0,[r0,#2]
;;;831    }
000006  4770              BX       lr
;;;832    
                          ENDP

                  |L27.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetSensingOnWindowEnable||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetSensingOnWindowEnable PROC
;;;877    
;;;878    bool_t protocol_swip_GetSensingOnWindowEnable(void)
000000  4801              LDR      r0,|L28.8|
;;;879    {
;;;880        return tProtocolCtrl.setter->bSensingOnWindowEnable;
000002  6840              LDR      r0,[r0,#4]  ; tProtocolCtrl
000004  7ac0              LDRB     r0,[r0,#0xb]
;;;881    }
000006  4770              BX       lr
;;;882    
                          ENDP

                  |L28.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_GetTestType||, CODE, READONLY, ALIGN=2

                  protocol_swip_GetTestType PROC
;;;974    
;;;975    eSWIPTestType_t protocol_swip_GetTestType(void)
000000  4801              LDR      r0,|L29.8|
;;;976    {
;;;977        return tSWIPTest.tTest.ptCtrl->eTestType;
000002  6840              LDR      r0,[r0,#4]  ; tSWIPTest
000004  7800              LDRB     r0,[r0,#0]
;;;978    }
000006  4770              BX       lr
;;;979    
                          ENDP

                  |L29.8|
                          DCD      ||.data||+0x76

                          AREA ||i.protocol_swip_Init||, CODE, READONLY, ALIGN=2

                  protocol_swip_Init PROC
;;;500    unsigned int crc_value;
;;;501    void protocol_swip_Init(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;502    {
;;;503    //	volatile unsigned long  BOOT_ADDR = 0x00001FFAUL;
;;;504    #if defined(SUPPORT_ANDROID)		
;;;505    	char PRODUCID_temp[9];
;;;506    	volatile unsigned long TC_ADDR= 0x0001FFECUL;
;;;507    	volatile unsigned long CHIPVER_ADDR= 0x0001FFE8UL;
;;;508    	volatile unsigned long PRODUCID_ADDR= 0x0001FFF0UL;
;;;509    #endif /* SUPPORT_ANDROID */
;;;510    //    tAlgorithmCommonConf_t* _ptAlgorithmCommonConf 	= algorithm_GetCommonConfig();
;;;511    //    tModuleCommonConf_t   *	_ptModuleCommonConf 	= module_GetCommonConfig();
;;;512    //    tModuleInfo_t         *	_ptModuleInfo 			= module_GetInfo();
;;;513    
;;;514    	thisCommonConf = protocol_GetCommonConfig();
000004  f7fffffe          BL       protocol_GetCommonConfig
000008  4d34              LDR      r5,|L30.220|
;;;515    	thisInfo = protocol_GetInfo();
00000a  6028              STR      r0,[r5,#0]  ; thisCommonConf
00000c  f7fffffe          BL       protocol_GetInfo
;;;516    	sptAlgorithmInfo = algorithm_GetInfo();
000010  6068              STR      r0,[r5,#4]  ; thisInfo
000012  f7fffffe          BL       algorithm_GetInfo
;;;517    
;;;518    //    memcpy(tSWIPInfo.ptPanel->vcProductName, _ptAppCommonConf->vcProductCode, sizeof(_ptAppCommonConf->vcProductCode));
;;;519    //
;;;520    #if defined(SUPPORT_ANDROID)
;;;521    	tSWIPInfo.ptPanel->usXResolution = 1920;
;;;522    	tSWIPInfo.ptPanel->usYResolution = 1080;
;;;523    #else
;;;524    	tSWIPInfo.ptPanel->usXResolution = I2C_X_RESOLUTION;//32768;
000016  f1050418          ADD      r4,r5,#0x18
00001a  60a8              STR      r0,[r5,#8]  ; sptAlgorithmInfo
00001c  6821              LDR      r1,[r4,#0]  ; tSWIPInfo
00001e  f44f4000          MOV      r0,#0x8000
000022  8208              STRH     r0,[r1,#0x10]
;;;525    	tSWIPInfo.ptPanel->usYResolution = I2C_Y_RESOLUTION;//32768;
000024  6821              LDR      r1,[r4,#0]  ; tSWIPInfo
000026  8248              STRH     r0,[r1,#0x12]
;;;526    #endif
;;;527    
;;;528    	tSWIPInfo.ptPanel->ucXNode_ = COL_MAX;
000028  6821              LDR      r1,[r4,#0]  ; tSWIPInfo
00002a  2060              MOVS     r0,#0x60
00002c  7508              STRB     r0,[r1,#0x14]
;;;529    	tSWIPInfo.ptPanel->ucYNode_ = ROW_MAX;
00002e  6821              LDR      r1,[r4,#0]  ; tSWIPInfo
000030  2030              MOVS     r0,#0x30
000032  7548              STRB     r0,[r1,#0x15]
;;;530    	
;;;531    #ifdef USE_BOOTLOADER_16KB
;;;532    	if( BACKUP_BOOT_INFO_1->I2C_BOOT_INFO_b.BOOT_VERSION == 0xFFFF)
000034  f44f5078          MOV      r0,#0x3e00
000038  f64f71ff          MOV      r1,#0xffff
00003c  6800              LDR      r0,[r0,#0]
00003e  ebb14f10          CMP      r1,r0,LSR #16
;;;533    	{			
;;;534    		tSWIPInfo.ptVersion->bcdBootVer = BOOT_VER;
000042  bf0c              ITE      EQ
000044  f2403003          MOVEQ    r0,#0x303
;;;535    	}
;;;536    	else
;;;537    	{
;;;538    		tSWIPInfo.ptVersion->bcdBootVer = BACKUP_BOOT_INFO_1->I2C_BOOT_INFO_b.BOOT_VERSION;
000048  0c00              LSRNE    r0,r0,#16
00004a  6861              LDR      r1,[r4,#4]  ; tSWIPInfo
00004c  8008              STRH     r0,[r1,#0]
;;;539    	}
;;;540    #endif
;;;541        tSWIPInfo.ptVersion->bcdCoreVer = CORE_VERSION;
00004e  6861              LDR      r1,[r4,#4]  ; tSWIPInfo
000050  2009              MOVS     r0,#9
000052  8048              STRH     r0,[r1,#2]
;;;542        tSWIPInfo.ptVersion->bcdAppVer  = APP_VERSION;
000054  6861              LDR      r1,[r4,#4]  ; tSWIPInfo
000056  8088              STRH     r0,[r1,#4]
;;;543        tSWIPInfo.ptVersion->bcdParaVer = PARA_VERSION;
000058  6861              LDR      r1,[r4,#4]  ; tSWIPInfo
00005a  2000              MOVS     r0,#0
00005c  80c8              STRH     r0,[r1,#6]
;;;544    
;;;545    #if defined(SUPPORT_ANDROID)
;;;546    	// Read  android version ================================================================
;;;547    	if (((*(volatile uint32_t *)TC_ADDR) & 0xFFFFFFFF) != 0xFFFFFFFF)
;;;548    	{
;;;549    		tSWIPAndroidBaseInfo.ptTcVersion->minor = (*(volatile uint8_t *)TC_ADDR) & 0xFF;
;;;550    		tSWIPAndroidBaseInfo.ptTcVersion->major = (*(volatile uint8_t *)(TC_ADDR+1)) & 0x0F;
;;;551    		tSWIPAndroidBaseInfo.ptTcVersion->build = (*(volatile uint8_t *)(TC_ADDR+1)) & 0xF0;
;;;552    		tSWIPAndroidBaseInfo.ptTcVersion->chip = (*(volatile uint8_t *)(TC_ADDR+2)) & 0xFF;
;;;553    		tSWIPAndroidBaseInfo.ptTcVersion->protocol = (*(volatile uint8_t *)(TC_ADDR+3)) & 0x0F;
;;;554    	}
;;;555    
;;;556    	if (((*(volatile uint32_t *)CHIPVER_ADDR) & 0xFFFFFFFF) != 0xFFFFFFFF)
;;;557    	{
;;;558    		tSWIPAndroidBaseInfo.ptChipVersion->boot = (*(volatile uint16_t *)CHIPVER_ADDR) & 0xFFFF;
;;;559    		tSWIPAndroidBaseInfo.ptChipVersion->core = (*(volatile uint16_t *)(CHIPVER_ADDR+2)) & 0xFFFF;
;;;560    	}
;;;561    
;;;562    	if (((*(volatile uint64_t *)PRODUCID_ADDR) & 0xFFFFFFFFFFFFFFFF) != 0xFFFFFFFFFFFFFFFF)
;;;563    	{
;;;564    		PRODUCID_temp[0] = (*(volatile uint8_t *)(PRODUCID_ADDR)) & 0xFF;
;;;565    		PRODUCID_temp[1] = (*(volatile uint8_t *)(PRODUCID_ADDR+1)) & 0xFF;
;;;566    		PRODUCID_temp[2] = (*(volatile uint8_t *)(PRODUCID_ADDR+2)) & 0xFF;
;;;567    		PRODUCID_temp[3] = (*(volatile uint8_t *)(PRODUCID_ADDR+3)) & 0xFF;
;;;568    		PRODUCID_temp[4] = (*(volatile uint8_t *)(PRODUCID_ADDR+4)) & 0xFF;
;;;569    		PRODUCID_temp[5] = (*(volatile uint8_t *)(PRODUCID_ADDR+5)) & 0xFF;
;;;570    		PRODUCID_temp[6] = (*(volatile uint8_t *)(PRODUCID_ADDR+6)) & 0xFF;
;;;571    		PRODUCID_temp[7] = (*(volatile uint8_t *)(PRODUCID_ADDR+7)) & 0xFF;
;;;572    
;;;573    
;;;574    		tSWIPAndroidBaseInfo.ptTcProductId->string[0] = PRODUCID_temp[0];
;;;575    		tSWIPAndroidBaseInfo.ptTcProductId->string[1] = PRODUCID_temp[1];
;;;576    		tSWIPAndroidBaseInfo.ptTcProductId->string[2] = PRODUCID_temp[2];
;;;577    		tSWIPAndroidBaseInfo.ptTcProductId->string[3] = PRODUCID_temp[3];
;;;578    		tSWIPAndroidBaseInfo.ptTcProductId->string[4] = PRODUCID_temp[4];
;;;579    		tSWIPAndroidBaseInfo.ptTcProductId->string[5] = PRODUCID_temp[5];
;;;580    		tSWIPAndroidBaseInfo.ptTcProductId->string[6] = PRODUCID_temp[6];
;;;581    		tSWIPAndroidBaseInfo.ptTcProductId->string[7] = PRODUCID_temp[7];
;;;582    	}
;;;583    
;;;584    	//=============================================================================================
;;;585    #endif /* SUPPORT_ANDROID */
;;;586    
;;;587    //	if(((*(volatile uint8_t *)BOOT_ADDR) & 0xFF) == 0xFF)
;;;588    //	{
;;;589    //		tSWIPInfo.ptVersion->bcdBootVer = BOOT_VER;
;;;590    //#if defined(SUPPORT_ANDROID)
;;;591    //		tSWIPAndroidBaseInfo.ptChipVersion->boot = tSWIPInfo.ptVersion->bcdBootVer;
;;;592    //#endif /* SUPPORT_ANDROID */
;;;593    //	}
;;;594    //	else
;;;595    //	{
;;;596    //		tSWIPInfo.ptVersion->bcdBootVer = (*(volatile uint8_t *)BOOT_ADDR) & 0xFF;
;;;597    //#if defined(SUPPORT_ANDROID)
;;;598    //		tSWIPAndroidBaseInfo.ptChipVersion->boot = tSWIPInfo.ptVersion->bcdBootVer;
;;;599    //#endif
;;;600    //	}
;;;601    
;;;602    //	fullBuffer = (unsigned char *)BaseAddr; // NOTE : warning����
;;;603    //	crc_value = (uint32_t)(Crc16WordCalc((const uint16_t*)&fullBuffer[0], FW_SIZE / 2 - 4, 0) | (Crc16WordCalc((const uint16_t*)&fullBuffer[2], FW_SIZE / 2 - 4, 0) << 16)); // NOTE : warning����
;;;604    //	crc_value = crc_value ^ 0xFFFFFFFF;
;;;605    //	crc_value = 0x00000000;
;;;606    
;;;607    //	tSWIPInfo.ptIntegrity->ulParamCRC = 0x00000000;
;;;608    #if (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_91K)
;;;609    	tSWIPInfo.ptExtra->usPWMTxFrequecy = 94;
00005e  6961              LDR      r1,[r4,#0x14]  ; tSWIPInfo
000060  205e              MOVS     r0,#0x5e
000062  8008              STRH     r0,[r1,#0]
;;;610    #elif (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_133K)
;;;611    	tSWIPInfo.ptExtra->usPWMTxFrequecy = 133;
;;;612    #elif (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_150K)
;;;613    	tSWIPInfo.ptExtra->usPWMTxFrequecy = 150;
;;;614    #else /* (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_200K) */
;;;615    	tSWIPInfo.ptExtra->usPWMTxFrequecy = 200;
;;;616    #endif /* (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_91K) */
;;;617    
;;;618    #if USED_MOBILE_I2C_PROTOCOL
;;;619    //	int iItemSize = 0x06;
;;;620    	int iTouchEventPacketSize  = sizeof(tSWIPPacketInfo_t);
;;;621    
;;;622    //	tSWIPEvent.ptEventFormat->ucTouchPacketItemSize = iItemSize;
;;;623    	tSWIPEvent.ptPacketInfo = malloc(iTouchEventPacketSize);
;;;624    	memset(tSWIPEvent.ptPacketInfo, 0, iTouchEventPacketSize);
;;;625    #else /* USED_MOBILE_I2C_PROTOCOL */
;;;626    
;;;627    	fullBuffer = (unsigned char *)BaseAddr;
000064  481e              LDR      r0,|L30.224|
000066  6800              LDR      r0,[r0,#0]  ; BaseAddr
000068  4e1e              LDR      r6,|L30.228|
;;;628    	
;;;629    #if defined(USE_BOOTLOADER_16KB)
;;;630    	crc_value = (uint32_t)Crc16WordCalc((const uint16_t*)&fullBuffer[0], FW_CRC_SIZE / 2, 0) | (Crc16WordCalc((const uint16_t*)&fullBuffer[2], FW_CRC_SIZE / 2, 0) << 16);
00006a  2200              MOVS     r2,#0
00006c  f44f4158          MOV      r1,#0xd800
000070  6030              STR      r0,[r6,#0]  ; fullBuffer
000072  f7fffffe          BL       Crc16WordCalc
000076  4607              MOV      r7,r0
000078  6830              LDR      r0,[r6,#0]  ; fullBuffer
00007a  2200              MOVS     r2,#0
00007c  f44f4158          MOV      r1,#0xd800
000080  1c80              ADDS     r0,r0,#2
000082  f7fffffe          BL       Crc16WordCalc
000086  ea474000          ORR      r0,r7,r0,LSL #16
;;;631    #else
;;;632    //	crc_value = (uint32_t)Crc16WordCalc((const uint16_t*)&fullBuffer[0], FW_SIZE / 2 - 4, 0) | (Crc16WordCalc((const uint16_t*)&fullBuffer[2], FW_SIZE / 2 - 4, 0) << 16);
;;;633    //	crc_value = (uint32_t)Crc16WordCalc((const uint16_t*)&fullBuffer[0], 120*1024 / 2, 0) | (Crc16WordCalc((const uint16_t*)&fullBuffer[2], 120*1024 / 2, 0) << 16);
;;;634    	crc_value = (uint32_t)Crc16WordCalc((const uint16_t*)&fullBuffer[0], 108*1024 / 2, 0) | (Crc16WordCalc((const uint16_t*)&fullBuffer[2], 108*1024 / 2, 0) << 16);
;;;635    	#endif
;;;636    
;;;637    	crc_value = crc_value ^ 0xFFFFFFFF;
00008a  43c0              MVNS     r0,r0
;;;638    
;;;639    	tSWIPInfo.ptIntegrity->usCalculateCRC1 = (crc_value>>24) & 0xFF;
00008c  60e8              STR      r0,[r5,#0xc]  ; crc_value
00008e  68e1              LDR      r1,[r4,#0xc]  ; tSWIPInfo
000090  0e00              LSRS     r0,r0,#24
000092  7008              STRB     r0,[r1,#0]
;;;640    	tSWIPInfo.ptIntegrity->usCalculateCRC2 = (crc_value>>16) & 0xFF;
000094  68e8              LDR      r0,[r5,#0xc]  ; crc_value
000096  68e1              LDR      r1,[r4,#0xc]  ; tSWIPInfo
000098  0c00              LSRS     r0,r0,#16
00009a  7048              STRB     r0,[r1,#1]
;;;641    	tSWIPInfo.ptIntegrity->usCalculateCRC3 = (crc_value>>8) & 0xFF;
00009c  89a8              LDRH     r0,[r5,#0xc]  ; crc_value
00009e  68e1              LDR      r1,[r4,#0xc]  ; tSWIPInfo
0000a0  0a00              LSRS     r0,r0,#8
0000a2  7088              STRB     r0,[r1,#2]
;;;642    	tSWIPInfo.ptIntegrity->usCalculateCRC4 = crc_value & 0xFF;
0000a4  68e1              LDR      r1,[r4,#0xc]  ; tSWIPInfo
0000a6  7b28              LDRB     r0,[r5,#0xc]  ; crc_value
0000a8  70c8              STRB     r0,[r1,#3]
;;;643    
;;;644    	tSWIPInfo.ptExtra->usPWMTxFrequecy = 91;
0000aa  6961              LDR      r1,[r4,#0x14]  ; tSWIPInfo
0000ac  205b              MOVS     r0,#0x5b
;;;645    
;;;646    
;;;647    		tSWIPEvent.ptEventFormat->ePacketFormatId = thisCommonConf->ePacketFormatId;
0000ae  4c0e              LDR      r4,|L30.232|
0000b0  8008              STRH     r0,[r1,#0]            ;644
0000b2  6828              LDR      r0,[r5,#0]  ; thisCommonConf
0000b4  6821              LDR      r1,[r4,#0]  ; tSWIPEvent
;;;648    
;;;649    	int iItemSize = 0x06;
;;;650    	int iTouchEventPacketSize  = 0x0042;
0000b6  2542              MOVS     r5,#0x42
0000b8  8800              LDRH     r0,[r0,#0]            ;647
0000ba  8088              STRH     r0,[r1,#4]            ;647
;;;651    
;;;652    
;;;653    	tSWIPEvent.ptEventFormat->ucTouchPacketItemSize = iItemSize;
0000bc  6821              LDR      r1,[r4,#0]  ; tSWIPEvent
0000be  2006              MOVS     r0,#6
0000c0  7188              STRB     r0,[r1,#6]
;;;654    	tSWIPEvent.ptPacketInfo = malloc(iTouchEventPacketSize);
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       malloc
;;;655    	memset(tSWIPEvent.ptPacketInfo, 0, iTouchEventPacketSize);
0000c8  4629              MOV      r1,r5
0000ca  6060              STR      r0,[r4,#4]  ; tSWIPEvent
0000cc  f7fffffe          BL       __aeabi_memclr
;;;656    #endif /* USED_MOBILE_I2C_PROTOCOL */
;;;657    
;;;658    #if defined(SUPPORT_ANDROID)
;;;659    	int AndroidItemSize = sizeof(tTouchData_t);
;;;660    	int AndroidPacketSize  = (AndroidItemSize * MAX_TOUCH_);//120;
;;;661    	stAndroidItemSize = AndroidItemSize;
;;;662    
;;;663    	memset(tSWIPAndroidReportPacket.data, 0, AndroidPacketSize);
;;;664    
;;;665    
;;;666    	tSWIPAndroidReportPacket.tc_status->running_sts        = 0x7;
;;;667    	tSWIPAndroidReportPacket.tc_status->device_checked_sts = 0x0; //Check if system set TC_DEVICE_CTL = 1 then set this register = 1
;;;668    	tSWIPAndroidReportPacket.tc_status->code_valid				 = 0x1;
;;;669    	tSWIPAndroidReportPacket.tc_status->cfg_valid 				 = 0x1;
;;;670    	tSWIPAndroidReportPacket.tc_status->font_valid				 = 0x1;
;;;671    	tSWIPAndroidReportPacket.tc_status->abnormal_sts			 = 0x0;
;;;672    	tSWIPAndroidReportPacket.tc_status->esd_error_sts 		 = 0x0;
;;;673    	tSWIPAndroidReportPacket.tc_status->reserved0 				 = 0x0;
;;;674    	tSWIPAndroidReportPacket.tc_status->disp_mode_mismatch = 0x0;
;;;675    	tSWIPAndroidReportPacket.tc_status->reserved1 				 = 0x0;
;;;676    	tSWIPAndroidReportPacket.tc_status->interrupt_sts 		 = 0x1;
;;;677    	tSWIPAndroidReportPacket.tc_status->interrupt_type		 = 0x5;
;;;678    	tSWIPAndroidReportPacket.tc_status->touch_int_en_sts	 = 0x1;
;;;679    	tSWIPAndroidReportPacket.tc_status->dwatch_int_en_sts  = 0x0;
;;;680    	tSWIPAndroidReportPacket.tc_status->tc_drv_valid			 = 0x1;
;;;681    	tSWIPAndroidReportPacket.tc_status->tc_cfg_load_type	 = 0x0;
;;;682    	tSWIPAndroidReportPacket.tc_status->dic_disp_sts			 = 0x1;
;;;683    	tSWIPAndroidReportPacket.tc_status->model_id_load_flag = 0x1;
;;;684    	tSWIPAndroidReportPacket.tc_status->pt_info_error 		 = 0x0;
;;;685    	tSWIPAndroidReportPacket.tc_status->reserved2 				 = 0x0;
;;;686    #endif /* SUPPORT_ANDROID */
;;;687    	vtProtocolBufferPointers.pParameterBuffer = (void *)PARAM_GetPreMainSet();
0000d0  f7fffffe          BL       PARAM_GetPreMainSet
0000d4  4905              LDR      r1,|L30.236|
0000d6  6048              STR      r0,[r1,#4]  ; vtProtocolBufferPointers
;;;688    }
0000d8  e8bd81f0          POP      {r4-r8,pc}
;;;689    
                          ENDP

                  |L30.220|
                          DCD      ||.data||
                  |L30.224|
                          DCD      BaseAddr
                  |L30.228|
                          DCD      fullBuffer
                  |L30.232|
                          DCD      ||.data||+0x10
                  |L30.236|
                          DCD      vtProtocolBufferPointers

                          AREA ||i.protocol_swip_InitTouchEventBuffer||, CODE, READONLY, ALIGN=2

                  protocol_swip_InitTouchEventBuffer PROC
;;;998    
;;;999    void protocol_swip_InitTouchEventBuffer(void)
000000  4805              LDR      r0,|L31.24|
;;;1000   {
;;;1001   //		int i; // NOTE : warning����
;;;1002   
;;;1003   		thisInfo->iEventPacket_ = 0;
000002  2100              MOVS     r1,#0
000004  6840              LDR      r0,[r0,#4]  ; thisInfo
000006  f8c01003          STR      r1,[r0,#3]
;;;1004   
;;;1005   #if defined(SUPPORT_ANDROID)		
;;;1006   		tSWIPAndroidReportPacket.info->touch_cnt = 0;
;;;1007   		protocol_android_SetDevCtlSts();
;;;1008   #endif
;;;1009   		thisInfo->bEnableHandShake = 0;//tProtocolCtrl.setter->bEnableHandShake;		
00000a  7041              STRB     r1,[r0,#1]
;;;1010   		thisInfo->bApplyCoordinate = tProtocolCtrl.setter->bApplyCoordinate;
00000c  4903              LDR      r1,|L31.28|
00000e  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000010  7bc9              LDRB     r1,[r1,#0xf]
000012  7081              STRB     r1,[r0,#2]
;;;1011   		
;;;1012   //		if(thisInfo->bEnableHandShake && tSWIPEvent.ptPacketInfo->ReportSize == TEST_DEVICE_READ_PACKED)
;;;1013   //		{
;;;1014   //			tSWIPEvent.ptPacketInfo->ReportSize = 0;
;;;1015   //		}
;;;1016   		
;;;1017   		#ifdef MODE_I2C
;;;1018   			protocol_swip_WaitEventInterruptCleared();	
;;;1019   		#endif
;;;1020   	
;;;1021   }
000014  4770              BX       lr
;;;1022   #if (SWIP_QUEUE_MODE)
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      ||.data||
                  |L31.28|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PendEventInterrupt||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendEventInterrupt PROC
;;;689    
;;;690    void protocol_swip_PendEventInterrupt(void)
000000  b510              PUSH     {r4,lr}
;;;691    {
;;;692    #if defined(SUPPORT_ANDROID)
;;;693        protocol_android_SetEventIntrType();
;;;694    #endif		
;;;695        thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
000002  4c0f              LDR      r4,|L32.64|
000004  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
000006  7841              LDRB     r1,[r0,#1]
000008  480e              LDR      r0,|L32.68|
00000a  6840              LDR      r0,[r0,#4]  ; thisInfo
00000c  7001              STRB     r1,[r0,#0]
00000e  2001              MOVS     r0,#1
;;;696        switch( thisInfo->eEventTriggerType )
000010  2901              CMP      r1,#1
000012  d004              BEQ      |L32.30|
000014  2902              CMP      r1,#2
;;;697        {
;;;698        case ETT_INTERRUPT:
;;;699            Hal_PendIntr();
;;;700            break;
;;;701        case ETT_REGISTER:
;;;702            tProtocolCtrl.getter->bEventReady = YES;
000016  bf04              ITT      EQ
000018  6821              LDREQ    r1,[r4,#0]  ; tProtocolCtrl
00001a  7048              STRBEQ   r0,[r1,#1]
;;;703            break;
;;;704        }
;;;705    }
00001c  bd10              POP      {r4,pc}
                  |L32.30|
00001e  f7fffffe          BL       CheckI2CReady
000022  2800              CMP      r0,#0
000024  bf18              IT       NE
000026  bd10              POPNE    {r4,pc}
000028  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
00002a  7840              LDRB     r0,[r0,#1]
00002c  2801              CMP      r0,#1
00002e  bf18              IT       NE
000030  bd10              POPNE    {r4,pc}
000032  4805              LDR      r0,|L32.72|
000034  6841              LDR      r1,[r0,#4]
000036  f4213180          BIC      r1,r1,#0x10000
00003a  6041              STR      r1,[r0,#4]
00003c  bd10              POP      {r4,pc}
;;;706    
                          ENDP

00003e  0000              DCW      0x0000
                  |L32.64|
                          DCD      tProtocolCtrl
                  |L32.68|
                          DCD      ||.data||
                  |L32.72|
                          DCD      0x40007000

                          AREA ||i.protocol_swip_PendReadyStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendReadyStatus PROC
;;;951    
;;;952    void protocol_swip_PendReadyStatus(void)
000000  4804              LDR      r0,|L33.20|
;;;953    {
;;;954        tProtocolCtrl.getter->eReadyStatus = RS_READY;
000002  21a0              MOVS     r1,#0xa0
000004  6802              LDR      r2,[r0,#0]  ; tProtocolCtrl
000006  7011              STRB     r1,[r2,#0]
000008  6800              LDR      r0,[r0,#0]
                  |L33.10|
;;;955        while( tProtocolCtrl.getter->eReadyStatus == RS_READY );
00000a  7801              LDRB     r1,[r0,#0]
00000c  29a0              CMP      r1,#0xa0
00000e  d0fc              BEQ      |L33.10|
;;;956    }
000010  4770              BX       lr
;;;957    
                          ENDP

000012  0000              DCW      0x0000
                  |L33.20|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PendReadyStatusCustom||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendReadyStatusCustom PROC
;;;957    
;;;958    void protocol_swip_PendReadyStatusCustom(eProtocolReadyStatus_t data) // NOTE : warning����
000000  4903              LDR      r1,|L34.16|
;;;959    {
;;;960        tProtocolCtrl.getter->eReadyStatus = data;
000002  680a              LDR      r2,[r1,#0]  ; tProtocolCtrl
000004  7010              STRB     r0,[r2,#0]
000006  6809              LDR      r1,[r1,#0]
                  |L34.8|
;;;961        while( tProtocolCtrl.getter->eReadyStatus == data )
000008  780a              LDRB     r2,[r1,#0]
00000a  4282              CMP      r2,r0
00000c  d0fc              BEQ      |L34.8|
;;;962            ;
;;;963    }
00000e  4770              BX       lr
;;;964    
                          ENDP

                  |L34.16|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PendTestResult||, CODE, READONLY, ALIGN=2

                  protocol_swip_PendTestResult PROC
;;;979    
;;;980    void protocol_swip_PendTestResult(const tSWIPTestDataFmt_t* _ptDataFormat, const void* _pBuf)
000000  4a0a              LDR      r2,|L35.44|
;;;981    {
;;;982        tSWIPTest.tTest.ptCtrl->eTestType = CTT_NONE;
000002  23ff              MOVS     r3,#0xff
000004  f8d2c004          LDR      r12,[r2,#4]  ; tSWIPTest
000008  f88c3000          STRB     r3,[r12,#0]
;;;983        //Set data format.
;;;984        tSWIPTest.tTest.ptFormat = _ptDataFormat;
00000c  6090              STR      r0,[r2,#8]  ; tSWIPTest
;;;985    
;;;986        //Set buffer address.
;;;987        vtProtocolBufferPointers.pGeneralBuffer = (void*)_pBuf;
00000e  4808              LDR      r0,|L35.48|
000010  6001              STR      r1,[r0,#0]  ; vtProtocolBufferPointers
;;;988    
;;;989        //Pend wait flag and wait for image type setting.
;;;990        tProtocolCtrl.getter->eReadyStatus = RS_READY;
000012  4808              LDR      r0,|L35.52|
000014  21a0              MOVS     r1,#0xa0
000016  6803              LDR      r3,[r0,#0]  ; tProtocolCtrl
000018  7019              STRB     r1,[r3,#0]
00001a  6851              LDR      r1,[r2,#4]            ;982
;;;991    	while(tSWIPTest.tTest.ptCtrl->eTestType == CTT_NONE && tProtocolCtrl.setter->eMode == M_TOUCH_DIAG);
00001c  6840              LDR      r0,[r0,#4]
                  |L35.30|
00001e  780a              LDRB     r2,[r1,#0]
000020  2aff              CMP      r2,#0xff
000022  bf04              ITT      EQ
000024  7802              LDRBEQ   r2,[r0,#0]
000026  2a01              CMPEQ    r2,#1
000028  d0f9              BEQ      |L35.30|
;;;992    }
00002a  4770              BX       lr
;;;993    
                          ENDP

                  |L35.44|
                          DCD      ||.data||+0x76
                  |L35.48|
                          DCD      vtProtocolBufferPointers
                  |L35.52|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_PushTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_PushTouchEvent PROC
;;;1045   
;;;1046   void protocol_swip_PushTouchEvent(const uSWIPTouchItem_t* _kptItem)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1047   {
000004  4604              MOV      r4,r0
;;;1048   #if USED_MOBILE_I2C_PROTOCOL
;;;1049   //    int size = 0;
;;;1050   	int index = 0, i = 0;
;;;1051   //	uint16_t BinArray[MAX_TOUCH_] = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200};
;;;1052   
;;;1053   #if (SWIP_QUEUE_MODE)
;;;1054   	if(sptAlgorithmInfo->bQueueStart == 0)
;;;1055   	{
;;;1056   		sptAlgorithmInfo->bQueueStart = 1;
;;;1057   		if( (sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE == sptAlgorithmInfo->QueueFront ) // Queue Full Check
;;;1058   		{
;;;1059   			uint8_t CurrFrontIdx, NextFrontIdx;
;;;1060   
;;;1061   			if( protocol_swip_CheckEventInterrupt() == YES ){
;;;1062   				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE;
;;;1063   			}
;;;1064   			else{
;;;1065   				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 2) % SWIP_QUEUE_SIZE;
;;;1066   			}
;;;1067   			NextFrontIdx = (CurrFrontIdx + 1) % SWIP_QUEUE_SIZE;
;;;1068   
;;;1069   			for(index=0; index<MAX_TOUCH_; index++)
;;;1070   			{
;;;1071   				if(ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].event == 0 && ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].track_id > 0)
;;;1072   //				if( ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].Status == 0 && ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].track_id > 0)
;;;1073   				{
;;;1074   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].tool_type = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].tool_type;
;;;1075   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].event = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].event;
;;;1076   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].track_id = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].track_id;
;;;1077   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].x = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].x;
;;;1078   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].y = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].y;
;;;1079   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].pressure = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].pressure;
;;;1080   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].angle = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].angle;
;;;1081   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].width_major = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].width_major;
;;;1082   					ptPacketInfoQueue[NextFrontIdx].tTouchData[index].width_minor = ptPacketInfoQueue[CurrFrontIdx].tTouchData[index].width_minor;
;;;1083   				}
;;;1084   
;;;1085   //				if( ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status == 0 && ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID > 0)
;;;1086   //				{
;;;1087   //					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].Status = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status;
;;;1088   //					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ID 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID;
;;;1089   //					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucX 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucX;
;;;1090   //					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucY 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucY;
;;;1091   //				}
;;;1092   			}
;;;1093   			ptPacketInfoQueue[NextFrontIdx].tTouchinfo.touch_cnt = ptPacketInfoQueue[CurrFrontIdx].tTouchinfo.touch_cnt;
;;;1094   
;;;1095   			sptAlgorithmInfo->QueueFront++;
;;;1096   			sptAlgorithmInfo->QueueFront = (sptAlgorithmInfo->QueueFront) % SWIP_QUEUE_SIZE;
;;;1097   		}
;;;1098   		memset(&ptPacketInfoQueue[sptAlgorithmInfo->QueueRear], 0x00, sizeof(tSWIPPacketInfo_t));
;;;1099   	}
;;;1100   #endif
;;;1101   
;;;1102   	index = (_kptItem->tItem00.tInfo.b4FingerID-1);
;;;1103   //	size = tSWIPEvent.ptEventFormat->ucTouchPacketItemSize;
;;;1104   
;;;1105   	if(thisInfo->bEnableHandShake)
;;;1106   	{
;;;1107   		ptDummyPacketInfo.tTouchData[index].tool_type = 0x0;
;;;1108   		ptDummyPacketInfo.tTouchData[index].event = _kptItem->tItem00.tInfo.bTouch;
;;;1109   		ptDummyPacketInfo.tTouchData[index].track_id = _kptItem->tItem00.tInfo.b4FingerID;
;;;1110   		ptDummyPacketInfo.tTouchData[index].x = (_kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow) * I2C_X_RESOLUTION / DEFAULT_X_RESOLUTION;
;;;1111   		ptDummyPacketInfo.tTouchData[index].y = (_kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow) * I2C_Y_RESOLUTION / DEFAULT_Y_RESOLUTION;
;;;1112   		ptDummyPacketInfo.tTouchData[index].pressure = _kptItem->tItem00.usStrength;
;;;1113   		ptDummyPacketInfo.tTouchData[index].angle = 0x0;
;;;1114   		ptDummyPacketInfo.tTouchData[index].width_major = 0x0;
;;;1115   		ptDummyPacketInfo.tTouchData[index].width_minor = 0x0;
;;;1116   //		ptDummyPacketInfo.tTouchInfo[index].Status = _kptItem->tItem00.tInfo.bTouch;
;;;1117   //		ptDummyPacketInfo.tTouchInfo[index].ID = _kptItem->tItem00.tInfo.b4FingerID;
;;;1118   //		ptDummyPacketInfo.tTouchInfo[index].ucX = _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
;;;1119   //		ptDummyPacketInfo.tTouchInfo[index].ucY = _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
;;;1120   		ptDummyPacketInfo.RowStart = _kptItem->tItem00.ucRowStart;
;;;1121   		ptDummyPacketInfo.ucContactCnt = index;
;;;1122   		thisInfo->iEventPacket_++;//+= size;
;;;1123   		ptDummyPacketInfo.tTouchinfo.touch_cnt++;
;;;1124   
;;;1125   		if(thisInfo->bApplyCoordinate)
;;;1126   		{
;;;1127   			for( i=0; i<ptMemConf->iMaxTouch_; i++ )
;;;1128   			{
;;;1129   //				tSWIPEvent.ptPacketInfo->ReportSize = (ptDummyPacketInfo.tTouchInfo[i].Status) \
;;;1130   //				? (tSWIPEvent.ptPacketInfo->ReportSize | BinArray[i]) : (tSWIPEvent.ptPacketInfo->ReportSize & ~BinArray[i]);
;;;1131   
;;;1132   				tSWIPEvent.ptPacketInfo->tTouchData[i].tool_type = ptDummyPacketInfo.tTouchData[i].tool_type;
;;;1133   				tSWIPEvent.ptPacketInfo->tTouchData[i].event = ptDummyPacketInfo.tTouchData[i].event;
;;;1134   				tSWIPEvent.ptPacketInfo->tTouchData[i].track_id = ptDummyPacketInfo.tTouchData[i].track_id;
;;;1135   				tSWIPEvent.ptPacketInfo->tTouchData[i].x = ptDummyPacketInfo.tTouchData[i].x;
;;;1136   				tSWIPEvent.ptPacketInfo->tTouchData[i].y = ptDummyPacketInfo.tTouchData[i].y;
;;;1137   				tSWIPEvent.ptPacketInfo->tTouchData[i].pressure = ptDummyPacketInfo.tTouchData[i].pressure;
;;;1138   				tSWIPEvent.ptPacketInfo->tTouchData[i].angle = ptDummyPacketInfo.tTouchData[i].angle;
;;;1139   				tSWIPEvent.ptPacketInfo->tTouchData[i].width_major = ptDummyPacketInfo.tTouchData[i].width_major;
;;;1140   				tSWIPEvent.ptPacketInfo->tTouchData[i].width_minor = ptDummyPacketInfo.tTouchData[i].width_minor;
;;;1141   
;;;1142   //				tSWIPEvent.ptPacketInfo->tTouchInfo[i].Status = ptDummyPacketInfo.tTouchInfo[i].Status;
;;;1143   //				tSWIPEvent.ptPacketInfo->tTouchInfo[i].ID     = ptDummyPacketInfo.tTouchInfo[i].ID ;
;;;1144   //				tSWIPEvent.ptPacketInfo->tTouchInfo[i].ucX    = ptDummyPacketInfo.tTouchInfo[i].ucX;
;;;1145   //				tSWIPEvent.ptPacketInfo->tTouchInfo[i].ucY    = ptDummyPacketInfo.tTouchInfo[i].ucY;
;;;1146   			}
;;;1147   			tSWIPEvent.ptPacketInfo->tTouchinfo.touch_cnt = ptDummyPacketInfo.tTouchinfo.touch_cnt;
;;;1148   			tSWIPEvent.ptPacketInfo->RowStart     = ptDummyPacketInfo.RowStart;
;;;1149   			tSWIPEvent.ptPacketInfo->ucContactCnt = ptDummyPacketInfo.ucContactCnt;
;;;1150   		}
;;;1151   	}
;;;1152   	else
;;;1153   	{
;;;1154   #if (SWIP_QUEUE_MODE)
;;;1155   		tSWIPEvent.ptPacketInfo->tTouchinfo.touch_cnt = ptDummyPacketInfo.tTouchinfo.touch_cnt;
;;;1156   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].tool_type = 0x0;
;;;1157   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].event = _kptItem->tItem00.tInfo.bTouch;
;;;1158   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].track_id = _kptItem->tItem00.tInfo.b4FingerID;
;;;1159   
;;;1160   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].x = (_kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow) * I2C_X_RESOLUTION / DEFAULT_X_RESOLUTION;
;;;1161   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].y = (_kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow) * I2C_Y_RESOLUTION / DEFAULT_Y_RESOLUTION;
;;;1162   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].pressure = _kptItem->tItem00.usStrength;
;;;1163   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].angle = 0x0;
;;;1164   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].width_major = 0x0;
;;;1165   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchData[index].width_minor = 0x0;
;;;1166   
;;;1167   //		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].Status = _kptItem->tItem00.tInfo.bTouch;
;;;1168   //		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ID 	= _kptItem->tItem00.tInfo.b4FingerID;
;;;1169   //		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucX 	= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
;;;1170   //		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucY 	= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
;;;1171   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].RowStart = _kptItem->tItem00.ucRowStart;
;;;1172   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].ucContactCnt = index;
;;;1173   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchinfo.touch_cnt++;
;;;1174   #else
;;;1175   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= _kptItem->tItem00.tInfo.bTouch;
;;;1176   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= _kptItem->tItem00.tInfo.b4FingerID;
;;;1177   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
;;;1178   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
;;;1179   		tSWIPEvent.ptPacketInfo->RowStart 					= _kptItem->tItem00.ucRowStart;
;;;1180   		tSWIPEvent.ptPacketInfo->ucContactCnt 				= index;
;;;1181   		thisInfo->iEventPacket_ += size;
;;;1182   #endif
;;;1183   	}
;;;1184   #else /* USED_MOBILE_I2C_PROTOCOL */
;;;1185       int size = 0;
;;;1186   	int index = 0, i = 0;		
;;;1187   	uint16_t BinArray[MAX_TOUCH_] = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200};
000006  48ba              LDR      r0,|L36.752|
000008  b085              SUB      sp,sp,#0x14           ;1047
;;;1188   
;;;1189   	
;;;1190   #if (SWIP_QUEUE_MODE)
;;;1191   	if(sptAlgorithmInfo->bQueueStart == 0)
00000a  4eba              LDR      r6,|L36.756|
00000c  e890102c          LDM      r0,{r2,r3,r5,r12}     ;1187
000010  e88d102c          STM      sp,{r2,r3,r5,r12}     ;1187
000014  6900              LDR      r0,[r0,#0x10]         ;1187  ; <Data6>
000016  9004              STR      r0,[sp,#0x10]
000018  68b0              LDR      r0,[r6,#8]  ; sptAlgorithmInfo
00001a  2100              MOVS     r1,#0                 ;1186
00001c  f5005080          ADD      r0,r0,#0x1000
;;;1192   	{
;;;1193   		sptAlgorithmInfo->bQueueStart = 1;
;;;1194   		if( (sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE == sptAlgorithmInfo->QueueFront ) // Queue Full Check
;;;1195   		{	
;;;1196   			uint8_t CurrFrontIdx, NextFrontIdx;
;;;1197   
;;;1198   			if( protocol_swip_CheckEventInterrupt() == YES ){
;;;1199   				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 1) % SWIP_QUEUE_SIZE;
;;;1200   			}
;;;1201   			else{
;;;1202   				CurrFrontIdx = (sptAlgorithmInfo->QueueRear + 2) % SWIP_QUEUE_SIZE;
;;;1203   			}
;;;1204   			NextFrontIdx = (CurrFrontIdx + 1) % SWIP_QUEUE_SIZE;
;;;1205   			
;;;1206   			for(index=0; index<MAX_TOUCH_; index++)				
;;;1207   			{
;;;1208   				if( ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status == 0 && ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID > 0)
000020  4db5              LDR      r5,|L36.760|
000022  f8902f9e          LDRB     r2,[r0,#0xf9e]        ;1191
000026  2a00              CMP      r2,#0                 ;1191
000028  d17d              BNE      |L36.294|
00002a  2201              MOVS     r2,#1                 ;1193
00002c  f8802f9e          STRB     r2,[r0,#0xf9e]        ;1193
000030  f8902f9c          LDRB     r2,[r0,#0xf9c]        ;1194
000034  f8df92c4          LDR      r9,|L36.764|
000038  2300              MOVS     r3,#0                 ;1194
00003a  46cc              MOV      r12,r9                ;1194
00003c  1c52              ADDS     r2,r2,#1              ;1194
00003e  fbe2c309          UMLAL    r12,r3,r2,r9          ;1194
000042  085b              LSRS     r3,r3,#1              ;1194
000044  eba303c3          SUB      r3,r3,r3,LSL #3       ;1194
000048  441a              ADD      r2,r2,r3              ;1194
00004a  f8903f9d          LDRB     r3,[r0,#0xf9d]        ;1194
00004e  429a              CMP      r2,r3                 ;1194
000050  d179              BNE      |L36.326|
000052  4aab              LDR      r2,|L36.768|
000054  6853              LDR      r3,[r2,#4]            ;1194  ; tProtocolCtrl
000056  f893c001          LDRB     r12,[r3,#1]           ;1194
00005a  6873              LDR      r3,[r6,#4]            ;1194  ; thisInfo
00005c  f883c000          STRB     r12,[r3,#0]           ;1194
000060  f00c03ff          AND      r3,r12,#0xff          ;1194
000064  2b01              CMP      r3,#1                 ;1194
000066  d002              BEQ      |L36.110|
000068  2b02              CMP      r3,#2                 ;1194
00006a  d006              BEQ      |L36.122|
00006c  e008              B        |L36.128|
                  |L36.110|
00006e  4aa5              LDR      r2,|L36.772|
000070  6852              LDR      r2,[r2,#4]            ;1194
000072  f4123f80          TST      r2,#0x10000           ;1194
000076  d12f              BNE      |L36.216|
000078  e002              B        |L36.128|
                  |L36.122|
00007a  6812              LDR      r2,[r2,#0]            ;1194  ; tProtocolCtrl
00007c  7852              LDRB     r2,[r2,#1]            ;1194
00007e  b35a              CBZ      r2,|L36.216|
                  |L36.128|
000080  f8902f9c          LDRB     r2,[r0,#0xf9c]        ;1202
000084  4b9d              LDR      r3,|L36.764|
000086  f04f0c00          MOV      r12,#0                ;1202
00008a  1c92              ADDS     r2,r2,#2              ;1202
00008c  fbe23c09          UMLAL    r3,r12,r2,r9          ;1202
000090  ea4f035c          LSR      r3,r12,#1             ;1202
000094  eba303c3          SUB      r3,r3,r3,LSL #3       ;1202
000098  441a              ADD      r2,r2,r3              ;1202
00009a  b2d2              UXTB     r2,r2                 ;1202
                  |L36.156|
00009c  1c53              ADDS     r3,r2,#1              ;1204
00009e  4f97              LDR      r7,|L36.764|
0000a0  f04f0c00          MOV      r12,#0                ;1204
0000a4  fbe37c09          UMLAL    r7,r12,r3,r9          ;1204
0000a8  ea4f0c5c          LSR      r12,r12,#1            ;1204
0000ac  ebac0ccc          SUB      r12,r12,r12,LSL #3    ;1204
0000b0  4463              ADD      r3,r3,r12             ;1204
0000b2  b2db              UXTB     r3,r3                 ;1204
;;;1209   				{
;;;1210   					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].Status = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].Status; 
0000b4  eb031343          ADD      r3,r3,r3,LSL #5
0000b8  eb021242          ADD      r2,r2,r2,LSL #5       ;1208
0000bc  eb050743          ADD      r7,r5,r3,LSL #1
0000c0  eb050c42          ADD      r12,r5,r2,LSL #1      ;1208
                  |L36.196|
0000c4  eb010341          ADD      r3,r1,r1,LSL #1       ;1208
0000c8  eb0c0243          ADD      r2,r12,r3,LSL #1      ;1208
0000cc  f8928003          LDRB     r8,[r2,#3]            ;1208
0000d0  f1b80f00          CMP      r8,#0                 ;1208
0000d4  d123              BNE      |L36.286|
0000d6  e00d              B        |L36.244|
                  |L36.216|
0000d8  f8902f9c          LDRB     r2,[r0,#0xf9c]        ;1199
0000dc  f8dfc21c          LDR      r12,|L36.764|
0000e0  2300              MOVS     r3,#0                 ;1199
0000e2  1c52              ADDS     r2,r2,#1              ;1199
0000e4  fbe2c309          UMLAL    r12,r3,r2,r9          ;1199
0000e8  085b              LSRS     r3,r3,#1              ;1199
0000ea  eba303c3          SUB      r3,r3,r3,LSL #3       ;1199
0000ee  441a              ADD      r2,r2,r3              ;1199
0000f0  b2d2              UXTB     r2,r2                 ;1199
0000f2  e7d3              B        |L36.156|
                  |L36.244|
0000f4  f892a004          LDRB     r10,[r2,#4]           ;1208
0000f8  f1ba0f00          CMP      r10,#0                ;1208
0000fc  d00f              BEQ      |L36.286|
0000fe  eb070343          ADD      r3,r7,r3,LSL #1
000102  f8838003          STRB     r8,[r3,#3]
;;;1211   					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ID 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ID; 	 
000106  f8928004          LDRB     r8,[r2,#4]
00010a  f8838004          STRB     r8,[r3,#4]
;;;1212   					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucX 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucX; 	 
00010e  f8b28005          LDRH     r8,[r2,#5]
000112  f8a38005          STRH     r8,[r3,#5]
;;;1213   					ptPacketInfoQueue[NextFrontIdx].tTouchInfo[index].ucY 	 = ptPacketInfoQueue[CurrFrontIdx].tTouchInfo[index].ucY;	 
000116  f8b22007          LDRH     r2,[r2,#7]
00011a  f8a32007          STRH     r2,[r3,#7]
                  |L36.286|
00011e  1c49              ADDS     r1,r1,#1
000120  290a              CMP      r1,#0xa               ;1206
000122  dbcf              BLT      |L36.196|
;;;1214   				}
;;;1215   			}
;;;1216   			
;;;1217   			sptAlgorithmInfo->QueueFront++;
000124  e001              B        |L36.298|
                  |L36.294|
000126  e017              B        |L36.344|
000128  e00d              B        |L36.326|
                  |L36.298|
00012a  f8901f9d          LDRB     r1,[r0,#0xf9d]
00012e  4b73              LDR      r3,|L36.764|
000130  1c49              ADDS     r1,r1,#1
000132  b2c9              UXTB     r1,r1
000134  2200              MOVS     r2,#0
;;;1218   			sptAlgorithmInfo->QueueFront = (sptAlgorithmInfo->QueueFront) % SWIP_QUEUE_SIZE;
000136  fbe13209          UMLAL    r3,r2,r1,r9
00013a  0852              LSRS     r2,r2,#1
00013c  eba202c2          SUB      r2,r2,r2,LSL #3
000140  4411              ADD      r1,r1,r2
000142  f8801f9d          STRB     r1,[r0,#0xf9d]
                  |L36.326|
;;;1219   		}
;;;1220   		memset(&ptPacketInfoQueue[sptAlgorithmInfo->QueueRear], 0x00, sizeof(tSWIPPacketInfo_t));
000146  f8900f9c          LDRB     r0,[r0,#0xf9c]
00014a  2142              MOVS     r1,#0x42
00014c  eb001040          ADD      r0,r0,r0,LSL #5
000150  eb050040          ADD      r0,r5,r0,LSL #1
000154  f7fffffe          BL       __aeabi_memclr
                  |L36.344|
;;;1221   	}
;;;1222   #endif
;;;1223   	
;;;1224   	index = (_kptItem->tItem00.tInfo.b4FingerID-1);
000158  7822              LDRB     r2,[r4,#0]
00015a  f002000f          AND      r0,r2,#0xf
00015e  1e41              SUBS     r1,r0,#1
;;;1225   	size = tSWIPEvent.ptEventFormat->ucTouchPacketItemSize;
000160  4869              LDR      r0,|L36.776|
000162  6803              LDR      r3,[r0,#0]  ; tSWIPEvent
000164  799f              LDRB     r7,[r3,#6]
;;;1226   	
;;;1227   	if(thisInfo->bEnableHandShake)
000166  6873              LDR      r3,[r6,#4]  ; thisInfo
000168  f893c001          LDRB     r12,[r3,#1]
00016c  f1bc0f00          CMP      r12,#0
000170  d072              BEQ      |L36.600|
;;;1228   	{
;;;1229   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1230   		ptDummyPacketInfo.tTouchInfo[index].Status = ((_kptItem->tItem00.tInfo.b6Type << 1) | (_kptItem->tItem00.tInfo.b1Status & 0x01)) & 0xff;
;;;1231   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1232   		ptDummyPacketInfo.tTouchInfo[index].Status = _kptItem->tItem00.tInfo.bTouch;
000172  09d5              LSRS     r5,r2,#7
000174  eb010241          ADD      r2,r1,r1,LSL #1
000178  f1000c24          ADD      r12,r0,#0x24
00017c  eb0c0242          ADD      r2,r12,r2,LSL #1
000180  70d5              STRB     r5,[r2,#3]
;;;1233   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1234   		ptDummyPacketInfo.tTouchInfo[index].ID = _kptItem->tItem00.tInfo.b4FingerID;
000182  7825              LDRB     r5,[r4,#0]
000184  f005050f          AND      r5,r5,#0xf
000188  7115              STRB     r5,[r2,#4]
;;;1235   		ptDummyPacketInfo.tTouchInfo[index].ucX = _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
00018a  78e5              LDRB     r5,[r4,#3]
00018c  7866              LDRB     r6,[r4,#1]
00018e  ea452506          ORR      r5,r5,r6,LSL #8
000192  f8a25005          STRH     r5,[r2,#5]
;;;1236   		ptDummyPacketInfo.tTouchInfo[index].ucY = _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
000196  7925              LDRB     r5,[r4,#4]
000198  78a6              LDRB     r6,[r4,#2]
00019a  ea452506          ORR      r5,r5,r6,LSL #8
00019e  f8a25007          STRH     r5,[r2,#7]
;;;1237   		ptDummyPacketInfo.RowStart = _kptItem->tItem00.ucRowStart;
0001a2  7a22              LDRB     r2,[r4,#8]
0001a4  f8ac2040          STRH     r2,[r12,#0x40]
;;;1238   		ptDummyPacketInfo.ucContactCnt = index;
0001a8  f88c103f          STRB     r1,[r12,#0x3f]
;;;1239   		thisInfo->iEventPacket_ += size;
0001ac  f8d31003          LDR      r1,[r3,#3]
0001b0  4439              ADD      r1,r1,r7
0001b2  f8c31003          STR      r1,[r3,#3]
;;;1240   
;;;1241   		if(thisInfo->bApplyCoordinate)
0001b6  7899              LDRB     r1,[r3,#2]
0001b8  2900              CMP      r1,#0
;;;1242   		{
;;;1243   			for( i=0; i<MAX_TOUCH_; i++ )
;;;1244   			{
;;;1245   				tSWIPEvent.ptPacketInfo->ReportSize = (ptDummyPacketInfo.tTouchInfo[i].Status) \
;;;1246   				? (tSWIPEvent.ptPacketInfo->ReportSize | BinArray[i]) : (tSWIPEvent.ptPacketInfo->ReportSize & ~BinArray[i]);
;;;1247   				
;;;1248   				tSWIPEvent.ptPacketInfo->tTouchInfo[i].Status = ptDummyPacketInfo.tTouchInfo[i].Status;
;;;1249   				tSWIPEvent.ptPacketInfo->tTouchInfo[i].ID     = ptDummyPacketInfo.tTouchInfo[i].ID ;
;;;1250   				tSWIPEvent.ptPacketInfo->tTouchInfo[i].ucX    = ptDummyPacketInfo.tTouchInfo[i].ucX;
;;;1251   				tSWIPEvent.ptPacketInfo->tTouchInfo[i].ucY    = ptDummyPacketInfo.tTouchInfo[i].ucY;
;;;1252   			}
;;;1253   			tSWIPEvent.ptPacketInfo->RowStart     = ptDummyPacketInfo.RowStart;
;;;1254   			tSWIPEvent.ptPacketInfo->ucContactCnt = ptDummyPacketInfo.ucContactCnt;					
;;;1255   		}
;;;1256   	}
;;;1257   	else
;;;1258   	{	
;;;1259   #if (SWIP_QUEUE_MODE)
;;;1260   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1261   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].Status = ((_kptItem->tItem00.tInfo.b6Type << 1) | (_kptItem->tItem00.tInfo.b1Status & 0x01)) & 0xff;
;;;1262   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1263   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].Status = _kptItem->tItem00.tInfo.bTouch;
;;;1264   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1265   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ID 	= _kptItem->tItem00.tInfo.b4FingerID;
;;;1266   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucX 	= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
;;;1267   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].tTouchInfo[index].ucY 	= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
;;;1268   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].RowStart 				= _kptItem->tItem00.ucRowStart;
;;;1269   		ptPacketInfoQueue[sptAlgorithmInfo->QueueRear].ucContactCnt 			= index;
;;;1270   #else
;;;1271   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= _kptItem->tItem00.tInfo.bTouch;
;;;1272   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= _kptItem->tItem00.tInfo.b4FingerID;
;;;1273   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= _kptItem->tItem00.ucXHigh<<8 | _kptItem->tItem00.ucXLow;
;;;1274   		tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= _kptItem->tItem00.ucYHigh<<8 | _kptItem->tItem00.ucYLow;
;;;1275   		tSWIPEvent.ptPacketInfo->RowStart 					= _kptItem->tItem00.ucRowStart;
;;;1276   		tSWIPEvent.ptPacketInfo->ucContactCnt 				= index;
;;;1277   		thisInfo->iEventPacket_ += size;
;;;1278   #endif
;;;1279   	}
;;;1280   #endif /* USED_MOBILE_I2C_PROTOCOL */
;;;1281   }
0001ba  bf04              ITT      EQ
0001bc  b005              ADDEQ    sp,sp,#0x14
0001be  e8bd8ff0          POPEQ    {r4-r11,pc}
0001c2  2100              MOVS     r1,#0                 ;1243
0001c4  2603              MOVS     r6,#3                 ;1248
0001c6  466c              MOV      r4,sp                 ;1187
0001c8  2704              MOVS     r7,#4                 ;1249
0001ca  f04f0805          MOV      r8,#5                 ;1250
0001ce  f04f0907          MOV      r9,#7                 ;1251
0001d2  bf00              NOP                            ;1245
                  |L36.468|
0001d4  eb010341          ADD      r3,r1,r1,LSL #1       ;1245
0001d8  eb0c0243          ADD      r2,r12,r3,LSL #1      ;1245
0001dc  f834a011          LDRH     r10,[r4,r1,LSL #1]    ;1246
0001e0  78d5              LDRB     r5,[r2,#3]            ;1245
0001e2  2d00              CMP      r5,#0                 ;1245
0001e4  6845              LDR      r5,[r0,#4]            ;1246  ; tSWIPEvent
0001e6  882d              LDRH     r5,[r5,#0]            ;1246
0001e8  bf14              ITE      NE                    ;1246
0001ea  ea45050a          ORRNE    r5,r5,r10             ;1246
0001ee  ea25050a          BICEQ    r5,r5,r10             ;1246
0001f2  f8d0a004          LDR      r10,[r0,#4]           ;1246  ; tSWIPEvent
0001f6  eb060b43          ADD      r11,r6,r3,LSL #1      ;1248
0001fa  1c49              ADDS     r1,r1,#1              ;1251
0001fc  f8aa5000          STRH     r5,[r10,#0]           ;1246
000200  f8d0a004          LDR      r10,[r0,#4]           ;1248  ; tSWIPEvent
000204  78d5              LDRB     r5,[r2,#3]            ;1248
000206  290a              CMP      r1,#0xa               ;1243
000208  f80a500b          STRB     r5,[r10,r11]          ;1248
00020c  f8d0a004          LDR      r10,[r0,#4]           ;1249  ; tSWIPEvent
000210  eb070b43          ADD      r11,r7,r3,LSL #1      ;1249
000214  7915              LDRB     r5,[r2,#4]            ;1249
000216  f80a500b          STRB     r5,[r10,r11]          ;1249
00021a  f8d0a004          LDR      r10,[r0,#4]           ;1250  ; tSWIPEvent
00021e  eb080b43          ADD      r11,r8,r3,LSL #1      ;1250
000222  44da              ADD      r10,r10,r11           ;1250
000224  f8b25005          LDRH     r5,[r2,#5]            ;1250
000228  f8aa5000          STRH     r5,[r10,#0]           ;1250
00022c  6845              LDR      r5,[r0,#4]            ;1251  ; tSWIPEvent
00022e  eb090343          ADD      r3,r9,r3,LSL #1       ;1251
000232  442b              ADD      r3,r3,r5              ;1251
000234  f8b22007          LDRH     r2,[r2,#7]            ;1251
000238  801a              STRH     r2,[r3,#0]            ;1251
00023a  dbcb              BLT      |L36.468|
00023c  6840              LDR      r0,[r0,#4]            ;1253  ; tSWIPEvent
00023e  f8bc1040          LDRH     r1,[r12,#0x40]        ;1253  ; ptDummyPacketInfo
000242  f8a01040          STRH     r1,[r0,#0x40]         ;1253
000246  f89c103f          LDRB     r1,[r12,#0x3f]        ;1254  ; ptDummyPacketInfo
00024a  bf00              NOP                            ;1269
                  |L36.588|
00024c  f880103f          STRB     r1,[r0,#0x3f]         ;1269
000250  b005              ADD      sp,sp,#0x14
000252  e8bd8ff0          POP      {r4-r11,pc}
000256  e7ff              B        |L36.600|
                  |L36.600|
000258  68b0              LDR      r0,[r6,#8]            ;1263  ; sptAlgorithmInfo
00025a  09d3              LSRS     r3,r2,#7              ;1263
00025c  f5005080          ADD      r0,r0,#0x1000         ;1263
000260  f8902f9c          LDRB     r2,[r0,#0xf9c]        ;1263
000264  eb021242          ADD      r2,r2,r2,LSL #5       ;1263
000268  eb050c42          ADD      r12,r5,r2,LSL #1      ;1263
00026c  eb010241          ADD      r2,r1,r1,LSL #1       ;1263
000270  eb0c0c42          ADD      r12,r12,r2,LSL #1     ;1263
000274  f88c3003          STRB     r3,[r12,#3]           ;1263
000278  f890cf9c          LDRB     r12,[r0,#0xf9c]       ;1265
00027c  7823              LDRB     r3,[r4,#0]            ;1265
00027e  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;1265
000282  eb050c4c          ADD      r12,r5,r12,LSL #1     ;1265
000286  eb0c0c42          ADD      r12,r12,r2,LSL #1     ;1265
00028a  f003030f          AND      r3,r3,#0xf            ;1265
00028e  f88c3004          STRB     r3,[r12,#4]           ;1265
000292  78e3              LDRB     r3,[r4,#3]            ;1266
000294  f894c001          LDRB     r12,[r4,#1]           ;1266
000298  ea43230c          ORR      r3,r3,r12,LSL #8      ;1266
00029c  f890cf9c          LDRB     r12,[r0,#0xf9c]       ;1266
0002a0  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;1266
0002a4  eb050c4c          ADD      r12,r5,r12,LSL #1     ;1266
0002a8  eb0c0c42          ADD      r12,r12,r2,LSL #1     ;1266
0002ac  f8ac3005          STRH     r3,[r12,#5]           ;1266
0002b0  7923              LDRB     r3,[r4,#4]            ;1267
0002b2  f894c002          LDRB     r12,[r4,#2]           ;1267
0002b6  ea43230c          ORR      r3,r3,r12,LSL #8      ;1267
0002ba  f890cf9c          LDRB     r12,[r0,#0xf9c]       ;1267
0002be  eb0c1c4c          ADD      r12,r12,r12,LSL #5    ;1267
0002c2  eb050c4c          ADD      r12,r5,r12,LSL #1     ;1267
0002c6  eb0c0242          ADD      r2,r12,r2,LSL #1      ;1267
0002ca  f8a23007          STRH     r3,[r2,#7]            ;1267
0002ce  f8903f9c          LDRB     r3,[r0,#0xf9c]        ;1268
0002d2  7a22              LDRB     r2,[r4,#8]            ;1268
0002d4  eb031343          ADD      r3,r3,r3,LSL #5       ;1268
0002d8  eb050343          ADD      r3,r5,r3,LSL #1       ;1268
0002dc  f8a32040          STRH     r2,[r3,#0x40]         ;1268
0002e0  f8900f9c          LDRB     r0,[r0,#0xf9c]        ;1269
0002e4  eb001040          ADD      r0,r0,r0,LSL #5       ;1269
0002e8  eb050040          ADD      r0,r5,r0,LSL #1       ;1269
0002ec  e7ae              B        |L36.588|
;;;1282   
                          ENDP

0002ee  0000              DCW      0x0000
                  |L36.752|
                          DCD      ||.constdata||
                  |L36.756|
                          DCD      ||.data||
                  |L36.760|
                          DCD      ||area_number.59||
                  |L36.764|
                          DCD      0x49249249
                  |L36.768|
                          DCD      tProtocolCtrl
                  |L36.772|
                          DCD      0x40007000
                  |L36.776|
                          DCD      ||.data||+0x10

                          AREA ||i.protocol_swip_SendPenEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_SendPenEvent PROC
;;;1396   
;;;1397   void protocol_swip_SendPenEvent(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1398   {
000004  b097              SUB      sp,sp,#0x5c
;;;1399   #if USED_MOBILE_I2C_PROTOCOL
;;;1400       int i = 0, nFindIdx = 0, index;
;;;1401   	tSWIPPacketInfo_t tPenTouch = { 0, };
;;;1402   //	uint16_t BinArray[MAX_TOUCH_] = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200};
;;;1403   
;;;1404   
;;;1405   	if(thisInfo->bEnableHandShake)
;;;1406   	{
;;;1407   		if(!thisInfo->bApplyCoordinate) return;
;;;1408   
;;;1409   		if(thisInfo->iEventPacket_ )
;;;1410   		{
;;;1411   //			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1412   			tProtocolCtrl.setter->bApplyCoordinate = NO;
;;;1413   
;;;1414   			tPenTouch.tTouchData[index].tool_type = tSWIPEvent.ptPacketInfo->tTouchData[index].tool_type;
;;;1415   			tPenTouch.tTouchData[index].event = tSWIPEvent.ptPacketInfo->tTouchData[index].event;
;;;1416   			tPenTouch.tTouchData[index].track_id = tSWIPEvent.ptPacketInfo->tTouchData[index].track_id;
;;;1417   			tPenTouch.tTouchData[index].x = tSWIPEvent.ptPacketInfo->tTouchData[index].x;
;;;1418   			tPenTouch.tTouchData[index].y = tSWIPEvent.ptPacketInfo->tTouchData[index].y;
;;;1419   			tPenTouch.tTouchData[index].pressure = tSWIPEvent.ptPacketInfo->tTouchData[index].pressure;
;;;1420   			tPenTouch.tTouchData[index].angle = tSWIPEvent.ptPacketInfo->tTouchData[index].angle;
;;;1421   			tPenTouch.tTouchData[index].width_major = tSWIPEvent.ptPacketInfo->tTouchData[index].width_major;
;;;1422   			tPenTouch.tTouchData[index].width_minor = tSWIPEvent.ptPacketInfo->tTouchData[index].width_minor;
;;;1423   //			tPenTouch.tTouchInfo[0].Status = tSWIPEvent.ptPacketInfo->tTouchInfo[0].Status;
;;;1424   //			tPenTouch.tTouchInfo[0].ID     = tSWIPEvent.ptPacketInfo->tTouchInfo[0].ID;
;;;1425   //			tPenTouch.tTouchInfo[0].ucX    = tSWIPEvent.ptPacketInfo->tTouchInfo[0].ucX;
;;;1426   //			tPenTouch.tTouchInfo[0].ucY    = tSWIPEvent.ptPacketInfo->tTouchInfo[0].ucY;
;;;1427   
;;;1428   			for( i=0; i<ptMemConf->iMaxTouch_; i++ )
;;;1429   			{
;;;1430   				if(tSWIPEvent.ptPacketInfo->tTouchData[i].event == 0)
;;;1431   //				if(tSWIPEvent.ptPacketInfo->tTouchInfo[i].Status == 0)
;;;1432   				{
;;;1433   					nFindIdx = i;
;;;1434   				}
;;;1435   
;;;1436   //				tSWIPEvent.ptPacketInfo->ReportSize = (tSWIPEvent.ptPacketInfo->ReportSize & ~BinArray[i]);
;;;1437   				tSWIPEvent.ptPacketInfo->tTouchData[i].event = 0;
;;;1438   //				tSWIPEvent.ptPacketInfo->tTouchInfo[i].Status = 0;
;;;1439   			}
;;;1440   
;;;1441   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].tool_type = tPenTouch.tTouchData[0].tool_type;
;;;1442   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].event = tPenTouch.tTouchData[0].event;
;;;1443   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].track_id = tPenTouch.tTouchData[0].track_id;
;;;1444   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].x = tPenTouch.tTouchData[0].x;
;;;1445   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].y = tPenTouch.tTouchData[0].y;
;;;1446   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].pressure = tPenTouch.tTouchData[0].pressure;
;;;1447   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].angle = tPenTouch.tTouchData[0].angle;
;;;1448   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].width_major = tPenTouch.tTouchData[0].width_major;
;;;1449   			tSWIPEvent.ptPacketInfo->tTouchData[nFindIdx].width_minor = tPenTouch.tTouchData[0].width_minor;
;;;1450   
;;;1451   //			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].Status = tPenTouch.tTouchInfo[0].Status;
;;;1452   //			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].ID     = tPenTouch.tTouchInfo[0].ID ;
;;;1453   //			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].ucX    = tPenTouch.tTouchInfo[0].ucX;
;;;1454   //			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].ucY    = tPenTouch.tTouchInfo[0].ucY;
;;;1455   
;;;1456   
;;;1457   			protocol_swip_PendEventInterrupt();
;;;1458   		}
;;;1459   		else
;;;1460   		{
;;;1461   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1462   		}
;;;1463   	}
;;;1464   	else
;;;1465   	{
;;;1466   #if (SWIP_QUEUE_MODE)
;;;1467   		if( sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
;;;1468   		{
;;;1469   			for(index=0; index<MAX_TOUCH_; index++)
;;;1470   			{
;;;1471   				tSWIPEvent.ptPacketInfo->tTouchData[index].tool_type = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].tool_type;
;;;1472   				tSWIPEvent.ptPacketInfo->tTouchData[index].event = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].event;
;;;1473   				tSWIPEvent.ptPacketInfo->tTouchData[index].track_id = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].track_id;
;;;1474   				tSWIPEvent.ptPacketInfo->tTouchData[index].x = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].x;
;;;1475   				tSWIPEvent.ptPacketInfo->tTouchData[index].y = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].y;
;;;1476   				tSWIPEvent.ptPacketInfo->tTouchData[index].pressure = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].pressure;
;;;1477   				tSWIPEvent.ptPacketInfo->tTouchData[index].angle = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].angle;
;;;1478   				tSWIPEvent.ptPacketInfo->tTouchData[index].width_major = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].width_major;
;;;1479   				tSWIPEvent.ptPacketInfo->tTouchData[index].width_minor = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].width_minor;
;;;1480   
;;;1481   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;1482   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;1483   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;1484   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;1485   			}
;;;1486   
;;;1487   			tSWIPEvent.ptPacketInfo->RowStart = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;1488   			tSWIPEvent.ptPacketInfo->ucContactCnt = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;1489   //			tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;1490   //			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1491   			tSWIPEvent.ptPacketInfo->tTouchinfo.touch_cnt = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchinfo.touch_cnt;
;;;1492   
;;;1493   			protocol_swip_PendEventInterrupt();
;;;1494   		}
;;;1495   #else
;;;1496   		if( thisInfo->iEventPacket_ )
;;;1497   		{
;;;1498   			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1499   			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1500   			protocol_swip_PendEventInterrupt();
;;;1501   		}
;;;1502   		else
;;;1503   		{
;;;1504   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1505   		}
;;;1506   #endif
;;;1507   	}
;;;1508   #else /* USED_MOBILE_I2C_PROTOCOL */
;;;1509       int i = 0, nFindIdx = 0, index;
000006  2400              MOVS     r4,#0
;;;1510   	tSWIPPacketInfo_t tPenTouch = { 0, };
000008  2144              MOVS     r1,#0x44
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memclr4
;;;1511   	uint16_t BinArray[MAX_TOUCH_] = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200};
000010  4889              LDR      r0,|L37.568|
000012  ad11              ADD      r5,sp,#0x44
000014  f1000114          ADD      r1,r0,#0x14
;;;1512   
;;;1513   
;;;1514   	if(thisInfo->bEnableHandShake)
;;;1515   	{
;;;1516   		if(!thisInfo->bApplyCoordinate) return;
;;;1517   
;;;1518   		if(thisInfo->iEventPacket_ )
;;;1519   		{
;;;1520   			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1521   			tProtocolCtrl.setter->bApplyCoordinate = NO;
;;;1522   
;;;1523   			tPenTouch.tTouchInfo[0].Status = tSWIPEvent.ptPacketInfo->tTouchInfo[0].Status;
;;;1524   			tPenTouch.tTouchInfo[0].ID     = tSWIPEvent.ptPacketInfo->tTouchInfo[0].ID;
;;;1525   			tPenTouch.tTouchInfo[0].ucX    = tSWIPEvent.ptPacketInfo->tTouchInfo[0].ucX;
;;;1526   			tPenTouch.tTouchInfo[0].ucY    = tSWIPEvent.ptPacketInfo->tTouchInfo[0].ucY;
;;;1527   
;;;1528   			for( i=0; i<MAX_TOUCH_; i++ )
;;;1529   			{
;;;1530   				if(tSWIPEvent.ptPacketInfo->tTouchInfo[i].Status == 0)
;;;1531   				{
;;;1532   					nFindIdx = i;
;;;1533   				}
;;;1534   				
;;;1535   				tSWIPEvent.ptPacketInfo->ReportSize = (tSWIPEvent.ptPacketInfo->ReportSize & ~BinArray[i]);
;;;1536   				tSWIPEvent.ptPacketInfo->tTouchInfo[i].Status = 0;
;;;1537   			}
;;;1538   
;;;1539   			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].Status = tPenTouch.tTouchInfo[0].Status;
;;;1540   			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].ID     = tPenTouch.tTouchInfo[0].ID ;
000018  2604              MOVS     r6,#4
00001a  e891100e          LDM      r1,{r1-r3,r12}        ;1511
00001e  e885100e          STM      r5,{r1-r3,r12}        ;1511
000022  4b86              LDR      r3,|L37.572|
000024  6a40              LDR      r0,[r0,#0x24]         ;1511  ; <Data7>
000026  9015              STR      r0,[sp,#0x54]         ;1514
000028  6859              LDR      r1,[r3,#4]            ;1514  ; thisInfo
00002a  4a85              LDR      r2,|L37.576|
00002c  2503              MOVS     r5,#3                 ;1539
00002e  f891c001          LDRB     r12,[r1,#1]           ;1514
;;;1541   			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].ucX    = tPenTouch.tTouchInfo[0].ucX;
000032  2705              MOVS     r7,#5
000034  f04f0b01          MOV      r11,#1                ;1520
000038  f1030010          ADD      r0,r3,#0x10           ;1520
;;;1542   			tSWIPEvent.ptPacketInfo->tTouchInfo[nFindIdx].ucY    = tPenTouch.tTouchInfo[0].ucY;
00003c  f04f0807          MOV      r8,#7
000040  f1bc0f00          CMP      r12,#0                ;1514
000044  d05f              BEQ      |L37.262|
000046  788b              LDRB     r3,[r1,#2]            ;1516
000048  2b00              CMP      r3,#0                 ;1516
;;;1543   
;;;1544   
;;;1545   			protocol_swip_PendEventInterrupt();
;;;1546   		}
;;;1547   		else
;;;1548   		{
;;;1549   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1550   		}
;;;1551   	}
;;;1552   	else
;;;1553   	{
;;;1554   #if (SWIP_QUEUE_MODE)
;;;1555   		if( sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
;;;1556   		{
;;;1557   			for(index=0; index<MAX_TOUCH_; index++)
;;;1558   			{
;;;1559   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;1560   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;1561   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;1562   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;1563   				tSWIPEvent.ptPacketInfo->RowStart 					= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;1564   				tSWIPEvent.ptPacketInfo->ucContactCnt 				= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;1565   			}
;;;1566   			tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;1567   			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1568   			protocol_swip_PendEventInterrupt();
;;;1569   		}
;;;1570   #else			
;;;1571   		if( thisInfo->iEventPacket_ )
;;;1572   		{
;;;1573   			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1574   			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1575   			protocol_swip_PendEventInterrupt();
;;;1576   		}
;;;1577   		else
;;;1578   		{
;;;1579   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1580   		}
;;;1581   #endif
;;;1582   	}
;;;1583   #endif /* USED_MOBILE_I2C_PROTOCOL */
;;;1584   }
00004a  bf04              ITT      EQ
00004c  b017              ADDEQ    sp,sp,#0x5c
00004e  e8bd8ff0          POPEQ    {r4-r11,pc}
000052  f8d13003          LDR      r3,[r1,#3]            ;1518
000056  497b              LDR      r1,|L37.580|
000058  f04f0900          MOV      r9,#0                 ;1518
00005c  2b00              CMP      r3,#0                 ;1518
00005e  6849              LDR      r1,[r1,#4]            ;1520
000060  bf02              ITTT     EQ                    ;1549
000062  f881903f          STRBEQ   r9,[r1,#0x3f]         ;1549
000066  b017              ADDEQ    sp,sp,#0x5c
000068  e8bd8ff0          POPEQ    {r4-r11,pc}
00006c  f881b002          STRB     r11,[r1,#2]           ;1520
000070  6851              LDR      r1,[r2,#4]            ;1521  ; tProtocolCtrl
000072  f881900f          STRB     r9,[r1,#0xf]          ;1521
000076  6841              LDR      r1,[r0,#4]            ;1523  ; tSWIPEvent
000078  ab11              ADD      r3,sp,#0x44           ;1528
00007a  f04f0c0a          MOV      r12,#0xa              ;1528
00007e  f8112f03          LDRB     r2,[r1,#3]!           ;1523
000082  f88d2003          STRB     r2,[sp,#3]            ;1523
000086  784a              LDRB     r2,[r1,#1]            ;1524
000088  f88d2004          STRB     r2,[sp,#4]            ;1524
00008c  884a              LDRH     r2,[r1,#2]            ;1525
00008e  f8ad2005          STRH     r2,[sp,#5]            ;1525
000092  888a              LDRH     r2,[r1,#4]            ;1526
000094  f8ad2007          STRH     r2,[sp,#7]            ;1526
000098  2200              MOVS     r2,#0                 ;1528
00009a  bf00              NOP                            ;1530
                  |L37.156|
00009c  f891a000          LDRB     r10,[r1,#0]           ;1530
0000a0  f1ba0f00          CMP      r10,#0                ;1530
0000a4  bf08              IT       EQ                    ;1532
0000a6  4614              MOVEQ    r4,r2                 ;1532
0000a8  f8d0a004          LDR      r10,[r0,#4]           ;1535  ; tSWIPEvent
0000ac  f833eb02          LDRH     lr,[r3],#2            ;1535
0000b0  1c52              ADDS     r2,r2,#1              ;1536
0000b2  f8bab000          LDRH     r11,[r10,#0]          ;1535
0000b6  f1bc0c01          SUBS     r12,r12,#1            ;1536
0000ba  ea2b0b0e          BIC      r11,r11,lr            ;1535
0000be  f8aab000          STRH     r11,[r10,#0]          ;1535
0000c2  f8019b06          STRB     r9,[r1],#6            ;1536
0000c6  d1e9              BNE      |L37.156|
0000c8  eb040144          ADD      r1,r4,r4,LSL #1       ;1539
0000cc  6843              LDR      r3,[r0,#4]            ;1539  ; tSWIPEvent
0000ce  eb050c41          ADD      r12,r5,r1,LSL #1      ;1539
0000d2  f89d2003          LDRB     r2,[sp,#3]            ;1539
0000d6  f803200c          STRB     r2,[r3,r12]           ;1539
0000da  6843              LDR      r3,[r0,#4]            ;1540  ; tSWIPEvent
0000dc  eb060c41          ADD      r12,r6,r1,LSL #1      ;1540
0000e0  f89d2004          LDRB     r2,[sp,#4]            ;1540
0000e4  f803200c          STRB     r2,[r3,r12]           ;1540
0000e8  6843              LDR      r3,[r0,#4]            ;1541  ; tSWIPEvent
0000ea  eb070c41          ADD      r12,r7,r1,LSL #1      ;1541
0000ee  4463              ADD      r3,r3,r12             ;1541
0000f0  f8bd2005          LDRH     r2,[sp,#5]            ;1541
0000f4  801a              STRH     r2,[r3,#0]            ;1541
0000f6  6840              LDR      r0,[r0,#4]            ;1542  ; tSWIPEvent
0000f8  eb080141          ADD      r1,r8,r1,LSL #1       ;1542
0000fc  4408              ADD      r0,r0,r1              ;1542
0000fe  f8bd2007          LDRH     r2,[sp,#7]            ;1542
000102  8002              STRH     r2,[r0,#0]            ;1542
000104  e089              B        |L37.538|
                  |L37.262|
000106  689b              LDR      r3,[r3,#8]            ;1555  ; sptAlgorithmInfo
000108  f5035c80          ADD      r12,r3,#0x1000        ;1555
00010c  f89c4f9d          LDRB     r4,[r12,#0xf9d]       ;1555
000110  f89ccf9c          LDRB     r12,[r12,#0xf9c]      ;1555
000114  4564              CMP      r4,r12                ;1555
000116  bf04              ITT      EQ
000118  b017              ADDEQ    sp,sp,#0x5c
00011a  e8bd8ff0          POPEQ    {r4-r11,pc}
00011e  f8d2c004          LDR      r12,[r2,#4]  ; tProtocolCtrl
000122  f89cc001          LDRB     r12,[r12,#1]
000126  f881c000          STRB     r12,[r1,#0]
00012a  f00c01ff          AND      r1,r12,#0xff
00012e  2901              CMP      r1,#1
000130  d079              BEQ      |L37.550|
000132  2902              CMP      r1,#2
000134  bf1c              ITT      NE
000136  b017              ADDNE    sp,sp,#0x5c
000138  e8bd8ff0          POPNE    {r4-r11,pc}
00013c  6811              LDR      r1,[r2,#0]  ; tProtocolCtrl
00013e  7849              LDRB     r1,[r1,#1]
000140  2900              CMP      r1,#0
000142  bf1c              ITT      NE
000144  b017              ADDNE    sp,sp,#0x5c
000146  e8bd8ff0          POPNE    {r4-r11,pc}
00014a  bf00              NOP                            ;1557
                  |L37.332|
00014c  4a3e              LDR      r2,|L37.584|
00014e  f04f0c00          MOV      r12,#0                ;1557
000152  f5035380          ADD      r3,r3,#0x1000         ;1559
000156  bf00              NOP                            ;1559
                  |L37.344|
000158  f8931f9d          LDRB     r1,[r3,#0xf9d]        ;1559
00015c  f8d09004          LDR      r9,[r0,#4]            ;1559  ; tSWIPEvent
000160  eb011141          ADD      r1,r1,r1,LSL #5       ;1559
000164  eb020441          ADD      r4,r2,r1,LSL #1       ;1559
000168  eb0c014c          ADD      r1,r12,r12,LSL #1     ;1559
00016c  eb040441          ADD      r4,r4,r1,LSL #1       ;1559
000170  eb050a41          ADD      r10,r5,r1,LSL #1      ;1559
000174  78e4              LDRB     r4,[r4,#3]            ;1559
000176  f809400a          STRB     r4,[r9,r10]           ;1559
00017a  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1560
00017e  f8d09004          LDR      r9,[r0,#4]            ;1560  ; tSWIPEvent
000182  eb041444          ADD      r4,r4,r4,LSL #5       ;1560
000186  eb020444          ADD      r4,r2,r4,LSL #1       ;1560
00018a  eb040441          ADD      r4,r4,r1,LSL #1       ;1560
00018e  eb060a41          ADD      r10,r6,r1,LSL #1      ;1560
000192  7924              LDRB     r4,[r4,#4]            ;1560
000194  f809400a          STRB     r4,[r9,r10]           ;1560
000198  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1561
00019c  f8d09004          LDR      r9,[r0,#4]            ;1561  ; tSWIPEvent
0001a0  eb041444          ADD      r4,r4,r4,LSL #5       ;1561
0001a4  eb020444          ADD      r4,r2,r4,LSL #1       ;1561
0001a8  eb040441          ADD      r4,r4,r1,LSL #1       ;1561
0001ac  eb070a41          ADD      r10,r7,r1,LSL #1      ;1561
0001b0  44d1              ADD      r9,r9,r10             ;1561
0001b2  f8b44005          LDRH     r4,[r4,#5]            ;1561
0001b6  f8a94000          STRH     r4,[r9,#0]            ;1561
0001ba  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1562
0001be  f8d09004          LDR      r9,[r0,#4]            ;1562  ; tSWIPEvent
0001c2  eb041444          ADD      r4,r4,r4,LSL #5       ;1562
0001c6  eb020444          ADD      r4,r2,r4,LSL #1       ;1562
0001ca  eb040441          ADD      r4,r4,r1,LSL #1       ;1562
0001ce  eb080141          ADD      r1,r8,r1,LSL #1       ;1562
0001d2  4449              ADD      r1,r1,r9              ;1562
0001d4  f8b44007          LDRH     r4,[r4,#7]            ;1562
0001d8  800c              STRH     r4,[r1,#0]            ;1562
0001da  f8931f9d          LDRB     r1,[r3,#0xf9d]        ;1563
0001de  f10c0c01          ADD      r12,r12,#1            ;1564
0001e2  eb011141          ADD      r1,r1,r1,LSL #5       ;1563
0001e6  eb020141          ADD      r1,r2,r1,LSL #1       ;1563
0001ea  f1bc0f0a          CMP      r12,#0xa              ;1564
0001ee  f8b14040          LDRH     r4,[r1,#0x40]         ;1563
0001f2  6841              LDR      r1,[r0,#4]            ;1563  ; tSWIPEvent
0001f4  f8a14040          STRH     r4,[r1,#0x40]         ;1563
0001f8  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1564
0001fc  eb041444          ADD      r4,r4,r4,LSL #5       ;1564
000200  eb020444          ADD      r4,r2,r4,LSL #1       ;1564
000204  f894403f          LDRB     r4,[r4,#0x3f]         ;1564
000208  f881403f          STRB     r4,[r1,#0x3f]         ;1564
00020c  dba4              BLT      |L37.344|
00020e  6841              LDR      r1,[r0,#4]            ;1566  ; tSWIPEvent
000210  f881b002          STRB     r11,[r1,#2]           ;1566
000214  6840              LDR      r0,[r0,#4]            ;1567  ; tSWIPEvent
000216  2130              MOVS     r1,#0x30              ;1567
000218  8001              STRH     r1,[r0,#0]            ;1567
                  |L37.538|
00021a  f7fffffe          BL       protocol_swip_PendEventInterrupt
00021e  b017              ADD      sp,sp,#0x5c
000220  e8bd8ff0          POP      {r4-r11,pc}
000224  e7ff              B        |L37.550|
                  |L37.550|
000226  4909              LDR      r1,|L37.588|
000228  6849              LDR      r1,[r1,#4]
00022a  f4113f80          TST      r1,#0x10000
00022e  d18d              BNE      |L37.332|
000230  b017              ADD      sp,sp,#0x5c
000232  e8bd8ff0          POP      {r4-r11,pc}
;;;1585   
                          ENDP

000236  0000              DCW      0x0000
                  |L37.568|
                          DCD      ||.constdata||
                  |L37.572|
                          DCD      ||.data||
                  |L37.576|
                          DCD      tProtocolCtrl
                  |L37.580|
                          DCD      ||.data||+0x10
                  |L37.584|
                          DCD      ||area_number.59||
                  |L37.588|
                          DCD      0x40007000

                          AREA ||i.protocol_swip_SendTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_swip_SendTouchEvent PROC
;;;1282   
;;;1283   void protocol_swip_SendTouchEvent(void)
000000  e92d0ff0          PUSH     {r4-r11}
;;;1284   {
;;;1285   #if USED_MOBILE_I2C_PROTOCOL
;;;1286   	int index = 0;
;;;1287   
;;;1288   	if(thisInfo->bEnableHandShake)
;;;1289   	{
;;;1290   		if(!thisInfo->bApplyCoordinate) return;
;;;1291   
;;;1292   		if(thisInfo->iEventPacket_ )
;;;1293   		{
;;;1294   //			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1295   			tProtocolCtrl.setter->bApplyCoordinate = NO;
;;;1296   			protocol_swip_PendEventInterrupt();
;;;1297   		}
;;;1298   		else
;;;1299   		{
;;;1300   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1301   		}
;;;1302   	}
;;;1303   	else
;;;1304   	{
;;;1305   #if (SWIP_QUEUE_MODE)
;;;1306   		if( sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
;;;1307   		{
;;;1308   			for(index=0; index<MAX_TOUCH_; index++)
;;;1309   			{
;;;1310   				tSWIPEvent.ptPacketInfo->tTouchData[index].tool_type = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].tool_type;
;;;1311   				tSWIPEvent.ptPacketInfo->tTouchData[index].event = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].event;
;;;1312   				tSWIPEvent.ptPacketInfo->tTouchData[index].track_id = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].track_id;
;;;1313   				tSWIPEvent.ptPacketInfo->tTouchData[index].x = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].x;
;;;1314   				tSWIPEvent.ptPacketInfo->tTouchData[index].y = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].y;
;;;1315   				tSWIPEvent.ptPacketInfo->tTouchData[index].pressure = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].pressure;
;;;1316   				tSWIPEvent.ptPacketInfo->tTouchData[index].angle = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].angle;
;;;1317   				tSWIPEvent.ptPacketInfo->tTouchData[index].width_major = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].width_major;
;;;1318   				tSWIPEvent.ptPacketInfo->tTouchData[index].width_minor = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchData[index].width_minor;
;;;1319   
;;;1320   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;1321   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;1322   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;1323   //				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;1324   			}
;;;1325   			tSWIPEvent.ptPacketInfo->RowStart = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;1326   			tSWIPEvent.ptPacketInfo->ucContactCnt = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;1327   //			tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;1328   //			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1329   			tSWIPEvent.ptPacketInfo->tTouchinfo.touch_cnt = ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchinfo.touch_cnt;
;;;1330   			protocol_swip_PendEventInterrupt();
;;;1331   		}
;;;1332   #else
;;;1333   		if( thisInfo->iEventPacket_ )
;;;1334   		{
;;;1335   			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1336   			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1337   			protocol_swip_PendEventInterrupt();
;;;1338   		}
;;;1339   		else
;;;1340   		{
;;;1341   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1342   		}
;;;1343   #endif
;;;1344   	}
;;;1345   #else /* USED_MOBILE_I2C_PROTOCOL */
;;;1346   	int index = 0;
;;;1347   
;;;1348   	if(thisInfo->bEnableHandShake)
000004  4b5c              LDR      r3,|L38.376|
;;;1349   	{
;;;1350   		if(!thisInfo->bApplyCoordinate) return;
;;;1351   
;;;1352   		if(thisInfo->iEventPacket_ )
;;;1353   		{
;;;1354   			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1355   			tProtocolCtrl.setter->bApplyCoordinate = NO;
000006  4a5d              LDR      r2,|L38.380|
000008  f04f0c00          MOV      r12,#0                ;1346
00000c  6859              LDR      r1,[r3,#4]            ;1348  ; thisInfo
00000e  f04f0b01          MOV      r11,#1                ;1354
000012  f1030010          ADD      r0,r3,#0x10           ;1354
000016  784c              LDRB     r4,[r1,#1]            ;1348
000018  b1cc              CBZ      r4,|L38.78|
00001a  7888              LDRB     r0,[r1,#2]            ;1350
00001c  2800              CMP      r0,#0                 ;1350
;;;1356   			protocol_swip_PendEventInterrupt();
;;;1357   		}
;;;1358   		else
;;;1359   		{
;;;1360   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1361   		}
;;;1362   	}
;;;1363   	else
;;;1364   	{
;;;1365   #if (SWIP_QUEUE_MODE)
;;;1366   		if( sptAlgorithmInfo->QueueFront != sptAlgorithmInfo->QueueRear && protocol_swip_CheckEventInterrupt() == YES ) // Not Queue Empty
;;;1367   		{
;;;1368   			for(index=0; index<MAX_TOUCH_; index++)
;;;1369   			{
;;;1370   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].Status 	= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].Status;
;;;1371   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ID 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ID;
;;;1372   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucX 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucX;
;;;1373   				tSWIPEvent.ptPacketInfo->tTouchInfo[index].ucY 		= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].tTouchInfo[index].ucY;
;;;1374   				tSWIPEvent.ptPacketInfo->RowStart 					= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].RowStart;
;;;1375   				tSWIPEvent.ptPacketInfo->ucContactCnt 				= ptPacketInfoQueue[sptAlgorithmInfo->QueueFront].ucContactCnt;
;;;1376   			}
;;;1377   			tSWIPEvent.ptPacketInfo->ReportID 	= 0x01;
;;;1378   			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1379   			protocol_swip_PendEventInterrupt();
;;;1380   		}
;;;1381   #else
;;;1382   		if( thisInfo->iEventPacket_ )
;;;1383   		{
;;;1384   			tSWIPEvent.ptPacketInfo->ReportID = 0x01;
;;;1385   			tSWIPEvent.ptPacketInfo->ReportSize = TEST_DEVICE_READ_PACKED;
;;;1386   			protocol_swip_PendEventInterrupt();
;;;1387   		}
;;;1388   		else
;;;1389   		{
;;;1390   			tSWIPEvent.ptPacketInfo->ucContactCnt = 0;
;;;1391   		}
;;;1392   #endif
;;;1393   	}
;;;1394   #endif /* USED_MOBILE_I2C_PROTOCOL */
;;;1395   }
00001e  bf04              ITT      EQ
000020  e8bd0ff0          POPEQ    {r4-r11}
000024  4770              BXEQ     lr
000026  f8d13003          LDR      r3,[r1,#3]            ;1352
00002a  2100              MOVS     r1,#0                 ;1352
00002c  2b00              CMP      r3,#0                 ;1352
00002e  4854              LDR      r0,|L38.384|
000030  6840              LDR      r0,[r0,#4]            ;1354
000032  bf02              ITTT     EQ                    ;1360
000034  f880103f          STRBEQ   r1,[r0,#0x3f]         ;1360
000038  e8bd0ff0          POPEQ    {r4-r11}
00003c  4770              BXEQ     lr
00003e  f880b002          STRB     r11,[r0,#2]           ;1354
000042  6850              LDR      r0,[r2,#4]            ;1355  ; tProtocolCtrl
000044  73c1              STRB     r1,[r0,#0xf]          ;1355
000046  e8bd0ff0          POP      {r4-r11}              ;1356
00004a  f7ffbffe          B.W      protocol_swip_PendEventInterrupt
                  |L38.78|
00004e  689b              LDR      r3,[r3,#8]            ;1366  ; sptAlgorithmInfo
000050  f5035480          ADD      r4,r3,#0x1000         ;1366
000054  f8945f9d          LDRB     r5,[r4,#0xf9d]        ;1366
000058  f8944f9c          LDRB     r4,[r4,#0xf9c]        ;1366
00005c  42a5              CMP      r5,r4                 ;1366
00005e  bf04              ITT      EQ
000060  e8bd0ff0          POPEQ    {r4-r11}
000064  4770              BXEQ     lr
000066  6854              LDR      r4,[r2,#4]  ; tProtocolCtrl
000068  7864              LDRB     r4,[r4,#1]
00006a  700c              STRB     r4,[r1,#0]
00006c  b2e1              UXTB     r1,r4
00006e  2901              CMP      r1,#1
000070  d079              BEQ      |L38.358|
000072  2902              CMP      r1,#2
000074  bf1c              ITT      NE
000076  e8bd0ff0          POPNE    {r4-r11}
00007a  4770              BXNE     lr
00007c  6811              LDR      r1,[r2,#0]  ; tProtocolCtrl
00007e  7849              LDRB     r1,[r1,#1]
000080  2900              CMP      r1,#0
000082  bf1c              ITT      NE
000084  e8bd0ff0          POPNE    {r4-r11}
000088  4770              BXNE     lr
                  |L38.138|
00008a  4a3e              LDR      r2,|L38.388|
00008c  2503              MOVS     r5,#3                 ;1370
00008e  2604              MOVS     r6,#4                 ;1371
000090  2705              MOVS     r7,#5                 ;1372
000092  f04f0807          MOV      r8,#7                 ;1373
000096  f5035380          ADD      r3,r3,#0x1000         ;1373
00009a  bf00              NOP                            ;1370
                  |L38.156|
00009c  f8931f9d          LDRB     r1,[r3,#0xf9d]        ;1370
0000a0  f8d09004          LDR      r9,[r0,#4]            ;1370  ; tSWIPEvent
0000a4  eb011141          ADD      r1,r1,r1,LSL #5       ;1370
0000a8  eb020441          ADD      r4,r2,r1,LSL #1       ;1370
0000ac  eb0c014c          ADD      r1,r12,r12,LSL #1     ;1370
0000b0  eb040441          ADD      r4,r4,r1,LSL #1       ;1370
0000b4  eb050a41          ADD      r10,r5,r1,LSL #1      ;1370
0000b8  78e4              LDRB     r4,[r4,#3]            ;1370
0000ba  f809400a          STRB     r4,[r9,r10]           ;1370
0000be  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1371
0000c2  f8d09004          LDR      r9,[r0,#4]            ;1371  ; tSWIPEvent
0000c6  eb041444          ADD      r4,r4,r4,LSL #5       ;1371
0000ca  eb020444          ADD      r4,r2,r4,LSL #1       ;1371
0000ce  eb040441          ADD      r4,r4,r1,LSL #1       ;1371
0000d2  eb060a41          ADD      r10,r6,r1,LSL #1      ;1371
0000d6  7924              LDRB     r4,[r4,#4]            ;1371
0000d8  f809400a          STRB     r4,[r9,r10]           ;1371
0000dc  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1372
0000e0  f8d09004          LDR      r9,[r0,#4]            ;1372  ; tSWIPEvent
0000e4  eb041444          ADD      r4,r4,r4,LSL #5       ;1372
0000e8  eb020444          ADD      r4,r2,r4,LSL #1       ;1372
0000ec  eb040441          ADD      r4,r4,r1,LSL #1       ;1372
0000f0  eb070a41          ADD      r10,r7,r1,LSL #1      ;1372
0000f4  44d1              ADD      r9,r9,r10             ;1372
0000f6  f8b44005          LDRH     r4,[r4,#5]            ;1372
0000fa  f8a94000          STRH     r4,[r9,#0]            ;1372
0000fe  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1373
000102  f8d09004          LDR      r9,[r0,#4]            ;1373  ; tSWIPEvent
000106  eb041444          ADD      r4,r4,r4,LSL #5       ;1373
00010a  eb020444          ADD      r4,r2,r4,LSL #1       ;1373
00010e  eb040441          ADD      r4,r4,r1,LSL #1       ;1373
000112  eb080141          ADD      r1,r8,r1,LSL #1       ;1373
000116  4449              ADD      r1,r1,r9              ;1373
000118  f8b44007          LDRH     r4,[r4,#7]            ;1373
00011c  800c              STRH     r4,[r1,#0]            ;1373
00011e  f8931f9d          LDRB     r1,[r3,#0xf9d]        ;1374
000122  f10c0c01          ADD      r12,r12,#1            ;1375
000126  eb011141          ADD      r1,r1,r1,LSL #5       ;1374
00012a  eb020141          ADD      r1,r2,r1,LSL #1       ;1374
00012e  f1bc0f0a          CMP      r12,#0xa              ;1368
000132  f8b14040          LDRH     r4,[r1,#0x40]         ;1374
000136  6841              LDR      r1,[r0,#4]            ;1374  ; tSWIPEvent
000138  f8a14040          STRH     r4,[r1,#0x40]         ;1374
00013c  f8934f9d          LDRB     r4,[r3,#0xf9d]        ;1375
000140  eb041444          ADD      r4,r4,r4,LSL #5       ;1375
000144  eb020444          ADD      r4,r2,r4,LSL #1       ;1375
000148  f894403f          LDRB     r4,[r4,#0x3f]         ;1375
00014c  f881403f          STRB     r4,[r1,#0x3f]         ;1375
000150  dba4              BLT      |L38.156|
000152  6841              LDR      r1,[r0,#4]            ;1377  ; tSWIPEvent
000154  f881b002          STRB     r11,[r1,#2]           ;1377
000158  6840              LDR      r0,[r0,#4]            ;1378  ; tSWIPEvent
00015a  2130              MOVS     r1,#0x30              ;1378
00015c  8001              STRH     r1,[r0,#0]            ;1378
00015e  e8bd0ff0          POP      {r4-r11}              ;1379
000162  f7ffbffe          B.W      protocol_swip_PendEventInterrupt
                  |L38.358|
000166  4908              LDR      r1,|L38.392|
000168  6849              LDR      r1,[r1,#4]            ;1379
00016a  f4113f80          TST      r1,#0x10000           ;1379
00016e  d18c              BNE      |L38.138|
000170  e8bd0ff0          POP      {r4-r11}
000174  4770              BX       lr
;;;1396   
                          ENDP

000176  0000              DCW      0x0000
                  |L38.376|
                          DCD      ||.data||
                  |L38.380|
                          DCD      tProtocolCtrl
                  |L38.384|
                          DCD      ||.data||+0x10
                  |L38.388|
                          DCD      ||area_number.59||
                  |L38.392|
                          DCD      0x40007000

                          AREA ||i.protocol_swip_SetChargetAttached||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetChargetAttached PROC
;;;872    
;;;873    void protocol_swip_SetChargetAttached(bool_t _bVal)
000000  4901              LDR      r1,|L39.8|
;;;874    {
;;;875    	tProtocolCtrl.setter->bChargerAttached = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7248              STRB     r0,[r1,#9]
;;;876    }
000006  4770              BX       lr
;;;877    
                          ENDP

                  |L39.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetDiableESDAlert||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetDiableESDAlert PROC
;;;862    
;;;863    void protocol_swip_SetDiableESDAlert(bool_t _bVal)
000000  4901              LDR      r1,|L40.8|
;;;864    {
;;;865    	tProtocolCtrl.setter->bDisableESDAlert = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7208              STRB     r0,[r1,#8]
;;;866    }
000006  4770              BX       lr
;;;867    
                          ENDP

                  |L40.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetDisableEdgeExpand||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetDisableEdgeExpand PROC
;;;912    
;;;913    void protocol_swip_SetDisableEdgeExpand(bool_t _bVal)
000000  4901              LDR      r1,|L41.8|
;;;914    {
;;;915        tProtocolCtrl.setter->bDisableEdgeExpand = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7348              STRB     r0,[r1,#0xd]
;;;916    }
000006  4770              BX       lr
;;;917    
                          ENDP

                  |L41.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetGNDNoiseHandlingStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetGNDNoiseHandlingStatus PROC
;;;1590   
;;;1591   void protocol_swip_SetGNDNoiseHandlingStatus(bool_t _bStatus)
000000  4901              LDR      r1,|L42.8|
;;;1592   {
;;;1593   	tSWIPSpecialAction.ptControlForTuning->bGNDNoiseStatus = _bStatus;
000002  6809              LDR      r1,[r1,#0]  ; tSWIPSpecialAction
000004  7008              STRB     r0,[r1,#0]
;;;1594   }
000006  4770              BX       lr
;;;1595   
                          ENDP

                  |L42.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_SetGestureType||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetGestureType PROC
;;;852    
;;;853    void protocol_swip_SetGestureType(uint32_t _ulGestureType)
000000  4901              LDR      r1,|L43.8|
;;;854    {
;;;855    	tProtocolCtrl.setter->ulGestureType = _ulGestureType;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  6048              STR      r0,[r1,#4]
;;;856    }
000006  4770              BX       lr
;;;857    
                          ENDP

                  |L43.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetGloveSensingEnable||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetGloveSensingEnable PROC
;;;892    
;;;893    void protocol_swip_SetGloveSensingEnable(bool_t _bVal)
000000  4901              LDR      r1,|L44.8|
;;;894    {
;;;895    	tProtocolCtrl.setter->bGloveSensingEnable = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7288              STRB     r0,[r1,#0xa]
;;;896    }
000006  4770              BX       lr
;;;897    
                          ENDP

                  |L44.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetLCDNoiseHandlingStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetLCDNoiseHandlingStatus PROC
;;;1600   
;;;1601   void protocol_swip_SetLCDNoiseHandlingStatus(bool_t _bStatus)
000000  4901              LDR      r1,|L45.8|
;;;1602   {
;;;1603   	tSWIPSpecialAction.ptControlForTuning->bLCDNoiseStatus = _bStatus;
000002  6809              LDR      r1,[r1,#0]  ; tSWIPSpecialAction
000004  7048              STRB     r0,[r1,#1]
;;;1604   }
000006  4770              BX       lr
;;;1605   
                          ENDP

                  |L45.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_SetMode||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetMode PROC
;;;795    
;;;796    void protocol_swip_SetMode(eProtocolMode_t _eMode)
000000  4901              LDR      r1,|L46.8|
;;;797    {
;;;798    	tProtocolCtrl.setter->eMode = _eMode;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7008              STRB     r0,[r1,#0]
;;;799    }
000006  4770              BX       lr
;;;800    
                          ENDP

                  |L46.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetOscVal||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetOscVal PROC
;;;1610   
;;;1611   void protocol_swip_SetOscVal(uint8_t oscval)
000000  4901              LDR      r1,|L47.8|
;;;1612   {
;;;1613   	tSWIPSpecialAction.ptControlForTuning->ucOscVal = oscval;
000002  6809              LDR      r1,[r1,#0]  ; tSWIPSpecialAction
000004  7088              STRB     r0,[r1,#2]
;;;1614   }
000006  4770              BX       lr
;;;1615   
                          ENDP

                  |L47.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_SetPalmRejectionEnable||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetPalmRejectionEnable PROC
;;;902    
;;;903    void protocol_swip_SetPalmRejectionEnable(bool_t _bVal)
000000  4901              LDR      r1,|L48.8|
;;;904    {
;;;905    	tProtocolCtrl.setter->bPalmRejectionEnable = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7308              STRB     r0,[r1,#0xc]
;;;906    }
000006  4770              BX       lr
;;;907    
                          ENDP

                  |L48.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetParameterBuffer||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetParameterBuffer PROC
;;;964    
;;;965    void protocol_swip_SetParameterBuffer(void* p)
000000  4901              LDR      r1,|L49.8|
;;;966    {
;;;967        vtProtocolBufferPointers.pGeneralBuffer = p;
000002  6008              STR      r0,[r1,#0]  ; vtProtocolBufferPointers
;;;968    }
000004  4770              BX       lr
;;;969    
                          ENDP

000006  0000              DCW      0x0000
                  |L49.8|
                          DCD      vtProtocolBufferPointers

                          AREA ||i.protocol_swip_SetPowerConsumptionState||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetPowerConsumptionState PROC
;;;842    
;;;843    void protocol_swip_SetPowerConsumptionState(ePowerConsumptionState_t _eState)
000000  4901              LDR      r1,|L50.8|
;;;844    {
;;;845    	tProtocolCtrl.setter->ePowerConsumptionState = _eState;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  70c8              STRB     r0,[r1,#3]
;;;846    }
000006  4770              BX       lr
;;;847    
                          ENDP

                  |L50.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetReadModuleConfigStatus||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetReadModuleConfigStatus PROC
;;;1620   
;;;1621   void protocol_swip_SetReadModuleConfigStatus(bool_t _bStatus)
000000  4901              LDR      r1,|L51.8|
;;;1622   {
;;;1623   	tSWIPSpecialAction.ptControlForTuning->bReadModuleConfig = _bStatus;
000002  6809              LDR      r1,[r1,#0]  ; tSWIPSpecialAction
000004  70c8              STRB     r0,[r1,#3]
;;;1624   }
000006  4770              BX       lr
;;;1625   
                          ENDP

                  |L51.8|
                          DCD      ||.data||+0x82

                          AREA ||i.protocol_swip_SetRecalibrate||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetRecalibrate PROC
;;;832    
;;;833    void protocol_swip_SetRecalibrate(bool_t _bRecalibrate)
000000  4901              LDR      r1,|L52.8|
;;;834    {
;;;835    	tProtocolCtrl.setter->bRecalibrate = _bRecalibrate;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  7088              STRB     r0,[r1,#2]
;;;836    }
000006  4770              BX       lr
;;;837    
                          ENDP

                  |L52.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetSensingOnWindowEnable||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetSensingOnWindowEnable PROC
;;;882    
;;;883    void protocol_swip_SetSensingOnWindowEnable(bool_t _bVal)
000000  4901              LDR      r1,|L53.8|
;;;884    {
;;;885    	tProtocolCtrl.setter->bSensingOnWindowEnable = _bVal;
000002  6849              LDR      r1,[r1,#4]  ; tProtocolCtrl
000004  72c8              STRB     r0,[r1,#0xb]
;;;886    }
000006  4770              BX       lr
;;;887    
                          ENDP

                  |L53.8|
                          DCD      tProtocolCtrl

                          AREA ||i.protocol_swip_SetTestType||, CODE, READONLY, ALIGN=2

                  protocol_swip_SetTestType PROC
;;;969    
;;;970    void protocol_swip_SetTestType(eSWIPTestType_t _t)
000000  4901              LDR      r1,|L54.8|
;;;971    {
;;;972        tSWIPTest.tTest.ptCtrl->eTestType = _t;
000002  6849              LDR      r1,[r1,#4]  ; tSWIPTest
000004  7008              STRB     r0,[r1,#0]
;;;973    }
000006  4770              BX       lr
;;;974    
                          ENDP

                  |L54.8|
                          DCD      ||.data||+0x76

                          AREA ||i.protocol_swip_WaitEventInterruptCleared||, CODE, READONLY, ALIGN=2

                  protocol_swip_WaitEventInterruptCleared PROC
;;;739    
;;;740    void protocol_swip_WaitEventInterruptCleared(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;741    {
;;;742    #define INTR_HIGH_              300
;;;743    #define WAIT_FOR_INTERRUPT_     0xFFFF
;;;744    	int intr = NO;
000004  2500              MOVS     r5,#0
000006  4f3a              LDR      r7,|L55.240|
;;;745    	int cnt = WAIT_FOR_INTERRUPT_;
;;;746    	
;;;747    	do
;;;748    	{
;;;749    		switch( thisInfo->eEventTriggerType )
000008  4e3a              LDR      r6,|L55.244|
00000a  4c3b              LDR      r4,|L55.248|
00000c  f64f79ff          MOV      r9,#0xffff            ;745
000010  46a8              MOV      r8,r5                 ;745
                  |L55.18|
000012  6870              LDR      r0,[r6,#4]  ; thisInfo
000014  7800              LDRB     r0,[r0,#0]
000016  2800              CMP      r0,#0
;;;750    		{
;;;751    			case ETT_INTERRUPT:
;;;752    			{
;;;753    				intr = Hal_GetIntr();
;;;754    				if( cnt-- == 0 )
;;;755    				{
;;;756    					Hal_ClearIntr();
;;;757    					int i;
;;;758    					for (i = INTR_HIGH_; i--;)
;;;759    					__NOP();
;;;760    					Hal_PendIntr();
;;;761    					cnt = WAIT_FOR_INTERRUPT_;
;;;762    				}
;;;763    			}
;;;764    			break;
;;;765    
;;;766    			case ETT_REGISTER:
;;;767    			{
;;;768    				intr = tProtocolCtrl.getter->bEventReady;
;;;769    				if( intr )
;;;770    				{
;;;771    					protocol_swip_ClearEventInterrupt();
;;;772    				}
;;;773    			}
;;;774    			break;
;;;775    
;;;776    			case ETT_NONE:
;;;777    				intr = NO;
000018  bf08              IT       EQ
00001a  2500              MOVEQ    r5,#0
00001c  d03e              BEQ      |L55.156|
00001e  2801              CMP      r0,#1                 ;749
000020  d002              BEQ      |L55.40|
000022  2802              CMP      r0,#2                 ;749
000024  d034              BEQ      |L55.144|
000026  e039              B        |L55.156|
                  |L55.40|
000028  f7fffffe          BL       CheckI2CReady
00002c  b958              CBNZ     r0,|L55.70|
00002e  6860              LDR      r0,[r4,#4]            ;749  ; tProtocolCtrl
000030  7840              LDRB     r0,[r0,#1]            ;749
000032  2801              CMP      r0,#1                 ;749
000034  bf04              ITT      EQ                    ;749
000036  6878              LDREQ    r0,[r7,#4]            ;749
000038  f4103f80          TSTEQ    r0,#0x10000           ;749
00003c  d103              BNE      |L55.70|
00003e  6878              LDR      r0,[r7,#4]            ;749
000040  f4403080          ORR      r0,r0,#0x10000        ;749
000044  6078              STR      r0,[r7,#4]            ;749
                  |L55.70|
000046  f04f0500          MOV      r5,#0                 ;749
00004a  f1b90901          SUBS     r9,r9,#1              ;749
00004e  d225              BCS      |L55.156|
000050  f7fffffe          BL       CheckI2CReady
000054  b938              CBNZ     r0,|L55.102|
000056  6860              LDR      r0,[r4,#4]            ;756  ; tProtocolCtrl
000058  7840              LDRB     r0,[r0,#1]            ;756
00005a  2801              CMP      r0,#1                 ;756
00005c  d103              BNE      |L55.102|
00005e  6878              LDR      r0,[r7,#4]            ;756
000060  f4403080          ORR      r0,r0,#0x10000        ;756
000064  6078              STR      r0,[r7,#4]            ;756
                  |L55.102|
000066  bf00              NOP                            ;759
000068  bf00              NOP                            ;759
00006a  f2401029          MOV      r0,#0x129             ;758
                  |L55.110|
00006e  bf00              NOP                            ;759
000070  1e40              SUBS     r0,r0,#1              ;759
000072  d2fc              BCS      |L55.110|
000074  f7fffffe          BL       CheckI2CReady
000078  b938              CBNZ     r0,|L55.138|
00007a  6860              LDR      r0,[r4,#4]            ;758  ; tProtocolCtrl
00007c  7840              LDRB     r0,[r0,#1]            ;758
00007e  2801              CMP      r0,#1                 ;758
000080  d103              BNE      |L55.138|
000082  6878              LDR      r0,[r7,#4]            ;758
000084  f4203080          BIC      r0,r0,#0x10000        ;758
000088  6078              STR      r0,[r7,#4]            ;758
                  |L55.138|
00008a  f64f79ff          MOV      r9,#0xffff            ;761
00008e  e005              B        |L55.156|
                  |L55.144|
000090  6820              LDR      r0,[r4,#0]            ;768  ; tProtocolCtrl
000092  7845              LDRB     r5,[r0,#1]            ;768
000094  2d00              CMP      r5,#0                 ;769
000096  bf18              IT       NE                    ;769
000098  f8808001          STRBNE   r8,[r0,#1]            ;769
                  |L55.156|
;;;778    			break;
;;;779    		}
;;;780    
;;;781    		if( thisInfo->eEventTriggerType != tProtocolCtrl.setter->eEventTriggerType )
00009c  6870              LDR      r0,[r6,#4]  ; thisInfo
00009e  6861              LDR      r1,[r4,#4]  ; tProtocolCtrl
0000a0  7800              LDRB     r0,[r0,#0]
0000a2  7849              LDRB     r1,[r1,#1]
0000a4  4288              CMP      r0,r1
0000a6  d01f              BEQ      |L55.232|
;;;782    		{
;;;783    			thisInfo->eEventTriggerType = tProtocolCtrl.setter->eEventTriggerType;
0000a8  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
0000aa  7841              LDRB     r1,[r0,#1]
0000ac  6870              LDR      r0,[r6,#4]  ; thisInfo
0000ae  7001              STRB     r1,[r0,#0]
0000b0  b2c8              UXTB     r0,r1
0000b2  2801              CMP      r0,#1
0000b4  d006              BEQ      |L55.196|
0000b6  2802              CMP      r0,#2
0000b8  bf04              ITT      EQ
0000ba  6820              LDREQ    r0,[r4,#0]  ; tProtocolCtrl
0000bc  f8808001          STRBEQ   r8,[r0,#1]
;;;784    			protocol_swip_ClearEventInterrupt();
;;;785    			break;
;;;786    		}
;;;787    	}
;;;788    	while (intr);
;;;789    }
0000c0  e8bd87f0          POP      {r4-r10,pc}
                  |L55.196|
0000c4  f7fffffe          BL       CheckI2CReady
0000c8  2800              CMP      r0,#0
0000ca  bf18              IT       NE
0000cc  e8bd87f0          POPNE    {r4-r10,pc}
0000d0  6860              LDR      r0,[r4,#4]  ; tProtocolCtrl
0000d2  7840              LDRB     r0,[r0,#1]
0000d4  2801              CMP      r0,#1
0000d6  bf18              IT       NE
0000d8  e8bd87f0          POPNE    {r4-r10,pc}
0000dc  6878              LDR      r0,[r7,#4]
0000de  f4403080          ORR      r0,r0,#0x10000
0000e2  6078              STR      r0,[r7,#4]
0000e4  e8bd87f0          POP      {r4-r10,pc}
                  |L55.232|
0000e8  2d00              CMP      r5,#0                 ;788
0000ea  d192              BNE      |L55.18|
0000ec  e8bd87f0          POP      {r4-r10,pc}
;;;790    
                          ENDP

                  |L55.240|
                          DCD      0x40007000
                  |L55.244|
                          DCD      ||.data||
                  |L55.248|
                          DCD      tProtocolCtrl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ktSWIPInfoPanel
                          %        22

                          AREA ||area_number.58||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.58||, ||.bss||
                  ktSWIPInfoTrimCode
                          %        64

                          AREA ||area_number.59||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.59||, ||.bss||
                  ptPacketInfoQueue
                          %        462

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00010002          DCW      0x0001,0x0002
000004  00040008          DCW      0x0004,0x0008
000008  00100020          DCW      0x0010,0x0020
00000c  00400080          DCW      0x0040,0x0080
000010  01000200          DCW      0x0100,0x0200
000014  00010002          DCW      0x0001,0x0002
000018  00040008          DCW      0x0004,0x0008
00001c  00100020          DCW      0x0010,0x0020
000020  00400080          DCW      0x0040,0x0080
000024  01000200          DCW      0x0100,0x0200

                          AREA ||.data||, DATA, ALIGN=2

                  thisCommonConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  sptAlgorithmInfo
                          DCD      0x00000000
                  crc_value
                          DCD      0x00000000
                  tSWIPEvent
                          DCD      tSWIPEventFormat
                          DCD      0x00000000
                  tSWIPInfo
                          DCD      ktSWIPInfoPanel
                          DCD      ktSWIPInfoFirmwareSectionVersion
                          DCD      ktSWIPInfoFirmwareSectionAddress
                          DCD      ktSWIPInfoFirmwareIntegrity
                          DCD      ktSWIPInfoInterface
                          DCD      ktSWIPInfoExtra
                          DCD      ktSWIPInfoTrimCode
                  ptDummyPacketInfo
000034  0000              DCW      0x0000
000036  0100              DCB      0x01,0x00
                          %        56
000070  00000000          DCB      0x00,0x00,0x00,0x00
000074  0000              DCW      0x0000
                  tSWIPTest
                          DCDU     ktSWIPTestInfo
                          DCDU     ktSWIPTestControl
00007e  0000              DCB      0x00,0x00
000080  0000              DCB      0x00,0x00
                  tSWIPSpecialAction
                          DCDU     ktSWIPControlForTuning
                          DCDU     0x00000000
                          DCDU     0x00000000
                  tSWIPBufferInfo
                          DCDU     vtProtocolBufferPointers
                          DCDU     ktProtocolBufferStartAddr
                          DCDU     0x00000002
00009a  0000              DCB      0x00,0x00
                  vtMRmiMap
                          DCD      0x00000000
                          DCD      ktSubsetInfo
                          DCD      ktSubsetEvent
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ktSubsetCtrl
                          DCD      0x00000000
                          DCD      ktSubsetParam
                          DCD      0x00000000
                          DCD      ktSubsetTest
                          DCD      0x00000000
                          DCD      ktSubsetImage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      ktSubsetLog
                          DCD      0x00000000
                          DCD      ktSubsetSpecialAction
                          DCD      0x00000000
                          DCD      ktSubsetIAP

                          AREA ||area_number.63||, DATA, ALIGN=0

                          EXPORTAS ||area_number.63||, ||.data||
                  ktSWIPInfoInterface
000000  53574950          DCB      0x53,0x57,0x49,0x50
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01101fd2          DCWU     0x0110,0x1fd2
00000c  d101              DCWU     0xd101

                          AREA ||area_number.64||, DATA, ALIGN=0

                          EXPORTAS ||area_number.64||, ||.data||
                  ktSWIPTestInfo
000000  20000001          DCWU     0x2000,0x0001

                          AREA ||area_number.65||, DATA, ALIGN=0

                          EXPORTAS ||area_number.65||, ||.data||
                  ktSWIPTestControl
000000  ff000000          DCB      0xff,0x00,0x00,0x00
000004  0000              DCB      0x00,0x00
                          DCDU     0x00000000

                          AREA ||area_number.66||, DATA, ALIGN=0

                          EXPORTAS ||area_number.66||, ||.data||
                  ktSWIPControlForTuning
000000  0000ff00          DCB      0x00,0x00,0xff,0x00

                          AREA ||area_number.67||, DATA, ALIGN=0

                          EXPORTAS ||area_number.67||, ||.data||
                  ktSWIPParameterInfo
000000  60000001          DCWU     0x6000,0x0001

                          AREA ||area_number.68||, DATA, ALIGN=0

                          EXPORTAS ||area_number.68||, ||.data||
                  tSWIPParameter
                          DCDU     ktSWIPParameterInfo

                          AREA ||area_number.69||, DATA, ALIGN=1

                          EXPORTAS ||area_number.69||, ||.data||
                  ktProtocolBufferStartAddr
000000  20006000          DCW      0x2000,0x6000

                          AREA ||area_number.70||, DATA, ALIGN=0

                          EXPORTAS ||area_number.70||, ||.data||
                  SWIP_REG_ADDR_INFO_LOWER_ADDR
000000  00203040          DCB      0x00,0x20,0x30,0x40
000004  5070a0c0          DCB      0x50,0x70,0xa0,0xc0

                          AREA ||area_number.71||, DATA, ALIGN=0

                          EXPORTAS ||area_number.71||, ||.data||
                  SWIP_REG_ADDR_EVENT_LOWER_ADDR
000000  001011            DCB      0x00,0x10,0x11

                          AREA ||area_number.72||, DATA, ALIGN=0

                          EXPORTAS ||area_number.72||, ||.data||
                  SWIP_REG_ADDR_CTRL_LOWER_ADDR
000000  0010              DCB      0x00,0x10

                          AREA ||area_number.73||, DATA, ALIGN=0

                          EXPORTAS ||area_number.73||, ||.data||
                  SWIP_REG_ADDR_PARAMETER_LOWER_ADDR
000000  00                DCB      0x00

                          AREA ||area_number.74||, DATA, ALIGN=0

                          EXPORTAS ||area_number.74||, ||.data||
                  SWIP_REG_ADDR_TEST_LOWER_ADDR
000000  001020            DCB      0x00,0x10,0x20

                          AREA ||area_number.75||, DATA, ALIGN=0

                          EXPORTAS ||area_number.75||, ||.data||
                  SWIP_REG_ADDR_IMAGE_LOWER_ADDR
000000  00102030          DCB      0x00,0x10,0x20,0x30
000004  31                DCB      0x31

                          AREA ||area_number.76||, DATA, ALIGN=0

                          EXPORTAS ||area_number.76||, ||.data||
                  SWIP_REG_ADDR_LOG_LOWER_ADDR
000000  001020            DCB      0x00,0x10,0x20

                          AREA ||area_number.77||, DATA, ALIGN=0

                          EXPORTAS ||area_number.77||, ||.data||
                  SWIP_REG_ADDR_SPECIAL_ACTION_LOWER_ADDR
000000  001030            DCB      0x00,0x10,0x30

                          AREA ||area_number.78||, DATA, ALIGN=0

                          EXPORTAS ||area_number.78||, ||.data||
                  SWIP_REG_ADDR_FLASH_IAP_CTRL_LOWER_ADDR
000000  00                DCB      0x00

                          AREA ||area_number.79||, DATA, ALIGN=0

                          EXPORTAS ||area_number.79||, ||.data||
                  ktSubsetInfo
                          DCDU     tSWIPInfo
                          DCDU     SWIP_REG_ADDR_INFO_LOWER_ADDR
                          DCDU     0x00000007

                          AREA ||area_number.80||, DATA, ALIGN=0

                          EXPORTAS ||area_number.80||, ||.data||
                  ktSubsetEvent
                          DCDU     tSWIPEvent
                          DCDU     SWIP_REG_ADDR_EVENT_LOWER_ADDR
                          DCDU     0x00000002

                          AREA ||area_number.81||, DATA, ALIGN=0

                          EXPORTAS ||area_number.81||, ||.data||
                  ktSubsetCtrl
                          DCDU     tProtocolCtrl
                          DCDU     SWIP_REG_ADDR_CTRL_LOWER_ADDR
                          DCDU     0x00000002

                          AREA ||area_number.82||, DATA, ALIGN=0

                          EXPORTAS ||area_number.82||, ||.data||
                  ktSubsetParam
                          DCDU     tSWIPParameter
                          DCDU     SWIP_REG_ADDR_PARAMETER_LOWER_ADDR
                          DCDU     0x00000001

                          AREA ||area_number.83||, DATA, ALIGN=0

                          EXPORTAS ||area_number.83||, ||.data||
                  ktSubsetTest
                          DCDU     tSWIPTest
                          DCDU     SWIP_REG_ADDR_TEST_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.84||, DATA, ALIGN=0

                          EXPORTAS ||area_number.84||, ||.data||
                  ktSubsetImage
                          DCDU     tProtocolImage
                          DCDU     SWIP_REG_ADDR_IMAGE_LOWER_ADDR
                          DCDU     0x00000005

                          AREA ||area_number.85||, DATA, ALIGN=0

                          EXPORTAS ||area_number.85||, ||.data||
                  ktSubsetLog
                          DCDU     tProtocolLog
                          DCDU     SWIP_REG_ADDR_LOG_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.86||, DATA, ALIGN=0

                          EXPORTAS ||area_number.86||, ||.data||
                  ktSubsetSpecialAction
                          DCDU     tSWIPSpecialAction
                          DCDU     SWIP_REG_ADDR_SPECIAL_ACTION_LOWER_ADDR
                          DCDU     0x00000003

                          AREA ||area_number.87||, DATA, ALIGN=0

                          EXPORTAS ||area_number.87||, ||.data||
                  ktSubsetIAP
                          DCDU     tFlashIAPPacket
                          DCDU     SWIP_REG_ADDR_FLASH_IAP_CTRL_LOWER_ADDR
                          DCDU     0x00000001

                          AREA ||area_number.88||, DATA, ALIGN=0

                          EXPORTAS ||area_number.88||, ||.data||
                  ktSWIPInfoFirmwareSectionVersion
                          %        8

                          AREA ||area_number.89||, DATA, ALIGN=0

                          EXPORTAS ||area_number.89||, ||.data||
                  ktSWIPInfoFirmwareSectionAddress
                          DCDU     0x00000000
000004  0000              DCB      0x00,0x00

                          AREA ||area_number.90||, DATA, ALIGN=0

                          EXPORTAS ||area_number.90||, ||.data||
                  ktSWIPInfoFirmwareIntegrity
                          DCDU     0x00000000

                          AREA ||area_number.91||, DATA, ALIGN=0

                          EXPORTAS ||area_number.91||, ||.data||
                  ktSWIPInfoExtra
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.92||, DATA, ALIGN=0

                          EXPORTAS ||area_number.92||, ||.data||
                  tSWIPEventFormat
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Protocol\\protocol_swip.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___15_protocol_swip_c_c9478dad____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____REVSH|
#line 402
|__asm___15_protocol_swip_c_c9478dad____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_protocol_swip_c_c9478dad____RRX|
#line 587
|__asm___15_protocol_swip_c_c9478dad____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
