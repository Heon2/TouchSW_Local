; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\app_normal.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\app_normal.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\app_normal.crf ..\..\App\app_normal.c]
                          THUMB

                          AREA ||i.app_normal_Init||, CODE, READONLY, ALIGN=2

                  app_normal_Init PROC
;;;55     
;;;56     void app_normal_Init(void)
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58     	sptAlgorithmInfo = algorithm_GetInfo();
000002  f7fffffe          BL       algorithm_GetInfo
000006  4901              LDR      r1,|L1.12|
000008  6048              STR      r0,[r1,#4]  ; sptAlgorithmInfo
;;;59     #if USED_NOISE_HOPPING_FREQ
;;;60     	thisCommonConf   = app_GetCommonConfig();
;;;61     #endif /* USED_NOISE_HOPPING_FREQ */
;;;62     }
00000a  bd10              POP      {r4,pc}
;;;63     extern uint16_t currentRowStart;
                          ENDP

                  |L1.12|
                          DCD      ||.data||

                          AREA ||i.app_normal_oper_handler||, CODE, READONLY, ALIGN=2

                  app_normal_oper_handler PROC
;;;94     //void initECLK(void);
;;;95     eTouchOperMainState_t app_normal_oper_handler(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;96     {
000004  b085              SUB      sp,sp,#0x14
;;;97     	eTouchOperMainState_t main_state;
;;;98     	eNormalOperSubState_t sub_state;
;;;99     	bool_t bLoop = YES;
000006  2001              MOVS     r0,#1
;;;100    	eProtocolMode_t currMode, prevMode = M_TOUCH_NORMAL;
000008  2600              MOVS     r6,#0
00000a  9001              STR      r0,[sp,#4]
00000c  f7fffffe          BL       algorithm_GetInfo
000010  4fc3              LDR      r7,|L2.800|
;;;101    	
;;;102    	app_normal_Init();
;;;103    #if USED_PEN_MODE_OPERATION
;;;104    	Interrupt_Init();
;;;105    #endif /* USED_PEN_MODE_OPERATION */
;;;106    
;;;107    	sub_state = TOUCH_NORMAL_OPER_ENTER;
000012  2401              MOVS     r4,#1
;;;108    	sptAlgorithmInfo->bDiagMode = NO;
000014  2500              MOVS     r5,#0
000016  6078              STR      r0,[r7,#4]  ; sptAlgorithmInfo
000018  f5005080          ADD      r0,r0,#0x1000
;;;109    	
;;;110    #if USED_LPWG_MODE_CONTROL
;;;111    	HAL_Initialize(NO);
;;;112    	if(module_Check_LcdOn(NO) == NO)
;;;113    	{
;;;114    		HAL_SetSensingMode(SM_FINGER_ONLY_LPWG_MODE);
;;;115    	}
;;;116    #endif /* USED_LPWG_MODE_CONTROL */	
;;;117    
;;;118        while(bLoop)
;;;119        {
;;;120    		custom_tool = 0;
00001c  f8dfa304          LDR      r10,|L2.804|
000020  f8805f96          STRB     r5,[r0,#0xf96]        ;108
;;;121    		if(hal_get_SubState_flag() != TOUCH_NORMAL_OPER_NONCHANGE)
;;;122    		{
;;;123    			sub_state = hal_get_SubState_flag();
;;;124    			hal_clear_SubState_flag();
;;;125    			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;126    		}
;;;127    
;;;128        	switch(sub_state)
;;;129        	{
;;;130    			case TOUCH_NORMAL_OPER_ENTER:
;;;131    			{
;;;132    #ifdef MODE_WDT				
;;;133    				Hal_WDT_DeInit();
;;;134    #endif /* MODE_WDT */
;;;135    				
;;;136    #if USED_RF_NOISE_RECOVERY_CODE
;;;137    				sptAlgorithmInfo->usAbnormalDeltaFrameCnt2 = 0;
;;;138    #endif /* USED_RF_NOISE_RECOVERY_CODE */
;;;139    				
;;;140    #if (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B)
;;;141    				if(HAL_GetSensingChangeMode() == SM_CHANGE_LPWG_MODE)
;;;142    				{
;;;143    					HAL_SetSensingMode(SM_FINGER_ONLY_LPWG_MODE);
;;;144    				}
;;;145    				else if(HAL_GetSensingChangeMode() == SM_CHANGE_ACTIVE_FRQ_MAIN_MODE)
;;;146    				{
;;;147    					HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
;;;148    				}
;;;149    				HAL_SetSensingChangeMode(SM_CHANGE_COMPLETE);
;;;150    #endif /* (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B) */				
;;;151    				TEST_LOCAL_STATE = 0;
;;;152    				
;;;153    #ifdef MODE_SMT
;;;154    				if(module_Defense_Recovery())
;;;155    				{
;;;156    					module_Smt_Mode_Enter();
;;;157    					sub_state = TOUCH_NORMAL_SMT_MODE;
;;;158    					break;
;;;159    				}
;;;160    #endif /* MODE_SMT */		
;;;161    				
;;;162    				if(protocol_swip_GetMode() == M_TOUCH_DFUP)
;;;163    				{
;;;164    					break;
;;;165    				}
;;;166    				else
;;;167    				{
;;;168    					module_start_delay();
;;;169    				}
;;;170    			}
;;;171    			/* no break */
;;;172    			case TOUCH_NORMAL_OPER_RESET_SYSTEM:
;;;173    			{
;;;174    				if(PARAM_GetMode() != PARAM_MODE_NORMAL)
;;;175    				{
;;;176    					PARAM_SetMode(PARAM_MODE_NORMAL);
;;;177    					PARAM_InitConfig();
;;;178    					algorithm_init();
;;;179    #if (USED_PEN_MODE_OPERATION || !defined(FINGER_ONLY))
;;;180    					algorithm_local_init(); //code
;;;181    					algorithm_init_local(); //DSP
;;;182    #endif /* (USED_PEN_MODE_OPERATION || !defined(FINGER_ONLY)) */
;;;183    				}
;;;184    			}
;;;185    			/* no break */
;;;186    			case TOUCH_NORMAL_OPER_RESET_HAL:
;;;187    			{
;;;188    #ifdef MODE_WDT
;;;189    				module_Watch_Enable();
;;;190    #endif /* MODE_WDT */		
;;;191    				MODULE_Initialize();
;;;192    				HAL_Initialize(NO);
;;;193    			}
;;;194    			/* no break */
;;;195    			case TOUCH_NORMAL_OPER_RESET_MODULE:
;;;196    			{
;;;197    				if(!module_Start())
;;;198    				{
;;;199    					sub_state = TOUCH_NORMAL_OPER_ENTER;
;;;200    					break;
;;;201    				}
;;;202    				if(IS_FINGER_PEN_MODE(HAL_GetSensingMode()))
;;;203    				{
;;;204    					sub_state = TOUCH_NORMAL_OPER_RESET_REFERENCE_PEN;
;;;205    				}
;;;206    				else
;;;207    				{
;;;208    					sub_state = TOUCH_NORMAL_OPER_RESET_REFERENCE;
;;;209    				}
;;;210    				break;
;;;211    			}
;;;212    
;;;213    #ifdef MODE_SMT
;;;214    			case TOUCH_NORMAL_SMT_MODE:
;;;215    			{
;;;216    				if(!module_Defense_Recovery())
;;;217    				{
;;;218    					module_Init_LcdOn();
;;;219    					sub_state = TOUCH_NORMAL_OPER_RESET_SYSTEM;
;;;220    				}
;;;221    				else
;;;222    				{
;;;223    					module_Tsync1_SignalBypass();
;;;224    				}
;;;225    				break;
;;;226    			}
;;;227    #endif /* MODE_SMT */
;;;228    
;;;229    			case TOUCH_NORMAL_OPER_RESET_REFERENCE:
;;;230    			{
;;;231    #if USED_NOISE_HOPPING_FREQ
;;;232    #if (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B)
;;;233    				if(IS_LPWG_MODE(HAL_GetSensingMode()))
;;;234    				{
;;;235    					algorithm_baseline_tracking_initial();
;;;236    				}
;;;237    				else
;;;238    #endif /* (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B) */		
;;;239    				{
;;;240    					if(module_Switch_Freq(thisCommonConf->HoppFreq1))
;;;241    					{
;;;242    						HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_HOP1_MODE);
;;;243    						algorithm_baseline_tracking_initial();
;;;244    					}
;;;245    					if(module_Switch_Freq(thisCommonConf->MainFreq))
;;;246    					{
;;;247    						HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
;;;248    						algorithm_baseline_tracking_initial();
;;;249    					}
;;;250    				}
;;;251    #else /* USED_NOISE_HOPPING_FREQ */
;;;252    				algorithm_baseline_tracking_initial();
;;;253    #endif /* USED_NOISE_HOPPING_FREQ */
;;;254    
;;;255    				sptAlgorithmInfo->bLineFilterRepeatCheck = 0;
;;;256    
;;;257    				if(IS_FINGER_ONLY_MODE(HAL_GetSensingMode()))
;;;258    				{
;;;259    					sub_state = TOUCH_NORMAL_OPER_NORMAL_READY;
;;;260    				}
;;;261    				else
;;;262    				{
;;;263    					sub_state = TOUCH_NORMAL_OPER_READY_REFERENCE_PEN;
;;;264    				}
;;;265    				break;
;;;266    			}
;;;267    
;;;268    #if USED_IDLE_MODE_CONTROL
;;;269    			case TOUCH_NORMAL_OPER_RESET_REFERENCE_IDLE:
;;;270    			{
;;;271    				algorithm_baseline_tracking_initial();
;;;272    				//algorithm_baseline_tracking_initial_idle(NO);
;;;273    				sub_state = TOUCH_NORMAL_OPER_IDLE;
;;;274    				break;
;;;275    			}
;;;276    #endif /* USED_IDLE_MODE_CONTROL */
;;;277    
;;;278    			case TOUCH_NORMAL_OPER_NORMAL_READY:
;;;279    			{
;;;280    				tHalIntrHandle.ulInitFirstFrame = 0;
;;;281    
;;;282    #if USED_ECLK_ON_OFF_CONTROL
;;;283    				HAL_SetECLKOnOffControl(YES);
;;;284    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;285    	
;;;286    #if (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL)				
;;;287    				sptAlgorithmInfo->ulIdleModeEnterCheckCount = 0;
;;;288    #endif /* (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL) */
;;;289    				
;;;290    				sub_state = TOUCH_NORMAL_OPER_NORMAL;				
;;;291    				break;
;;;292    			}
;;;293    
;;;294    			case TOUCH_NORMAL_OPER_NORMAL:
;;;295    			{	
;;;296    #ifdef MODE_WDT				
;;;297    				KICK_DOG();
;;;298    #endif /* MODE_WDT */
;;;299    				if(RESET_FLAG == 1)
;;;300    				{
;;;301    #if USED_ESD_RECOVERY_CODE
;;;302    					while(1); //WDT Reset
;;;303    #else /* USED_ESD_RECOVERY_CODE */
;;;304    					RESET_FLAG = 0;
;;;305    					sub_state = TOUCH_NORMAL_OPER_RESET_MODULE;
;;;306    #endif /* USED_ESD_RECOVERY_CODE */
;;;307    					break;
;;;308    				}
;;;309    				
;;;310    				if(!module_wait_full_sample_done())
;;;311    				{
;;;312    					sub_state = TOUCH_NORMAL_OPER_ENTER;
;;;313    					break;
;;;314    				}
;;;315    				
;;;316    				//Interpolation_LYB
;;;317    				if(DoReportOrgPos){
;;;318    					algorithm_PendTouchEvent();
;;;319    					algorithm_coord_UpdatePosHistoryInfo();
;;;320    					DoReportOrgPos = NO;
;;;321    				}
;;;322    				
;;;323    #if USED_ESD_RECOVERY_CODE
;;;324    				if(algorithm_check_abnormal_rawdata())
;;;325    				{
;;;326    					while(1); //WDT Reset
;;;327    				}
;;;328    #endif /* USED_ESD_RECOVERY_CODE */ 
;;;329    				
;;;330    #if LGD_ERROR_FRAME_PROCESS_EN
;;;331    				if(LGD_error_frame_process())	break;
;;;332    #endif
;;;333    
;;;334    				protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_GET_RAW_IMAGE_PTR(), COL_MAX, ROW_MAX, 84/*Raw Data*/);
000024  48c0              LDR      r0,|L2.808|
000026  f8df9304          LDR      r9,|L2.812|
00002a  9000              STR      r0,[sp,#0]
                  |L2.44|
00002c  f88a5000          STRB     r5,[r10,#0]           ;120
000030  f7fffffe          BL       hal_get_SubState_flag
000034  b138              CBZ      r0,|L2.70|
000036  f7fffffe          BL       hal_get_SubState_flag
00003a  4604              MOV      r4,r0                 ;123
00003c  f7fffffe          BL       hal_clear_SubState_flag
000040  2003              MOVS     r0,#3                 ;125
000042  f7fffffe          BL       hal_clear_irq_flag
                  |L2.70|
000046  2c05              CMP      r4,#5                 ;128
000048  d033              BEQ      |L2.178|
00004a  dc08              BGT      |L2.94|
00004c  2c01              CMP      r4,#1                 ;128
00004e  d00f              BEQ      |L2.112|
000050  2c02              CMP      r4,#2                 ;128
000052  d03d              BEQ      |L2.208|
000054  2c03              CMP      r4,#3                 ;128
000056  d01b              BEQ      |L2.144|
000058  2c04              CMP      r4,#4                 ;128
00005a  d023              BEQ      |L2.164|
00005c  e0c2              B        |L2.484|
                  |L2.94|
00005e  2c06              CMP      r4,#6                 ;128
000060  d040              BEQ      |L2.228|
000062  2c0b              CMP      r4,#0xb               ;128
000064  d04d              BEQ      |L2.258|
000066  2c0c              CMP      r4,#0xc               ;128
000068  d057              BEQ      |L2.282|
00006a  2c16              CMP      r4,#0x16              ;128
00006c  d07e              BEQ      |L2.364|
00006e  e0b9              B        |L2.484|
                  |L2.112|
000070  f7fffffe          BL       Hal_WDT_DeInit
000074  60fd              STR      r5,[r7,#0xc]          ;154  ; TEST_LOCAL_STATE
000076  f7fffffe          BL       module_Defense_Recovery
00007a  b118              CBZ      r0,|L2.132|
00007c  f7fffffe          BL       module_Smt_Mode_Enter
000080  2402              MOVS     r4,#2                 ;157
000082  e0af              B        |L2.484|
                  |L2.132|
000084  f7fffffe          BL       protocol_swip_GetMode
000088  2802              CMP      r0,#2                 ;162
00008a  d045              BEQ      |L2.280|
00008c  f7fffffe          BL       module_start_delay
                  |L2.144|
000090  f7fffffe          BL       PARAM_GetMode
000094  b130              CBZ      r0,|L2.164|
000096  2000              MOVS     r0,#0                 ;176
000098  f7fffffe          BL       PARAM_SetMode
00009c  f7fffffe          BL       PARAM_InitConfig
0000a0  f7fffffe          BL       algorithm_init
                  |L2.164|
0000a4  f7fffffe          BL       module_Watch_Enable
0000a8  f7fffffe          BL       MODULE_Initialize
0000ac  2000              MOVS     r0,#0                 ;192
0000ae  f7fffffe          BL       HAL_Initialize
                  |L2.178|
0000b2  f7fffffe          BL       module_Start
0000b6  b138              CBZ      r0,|L2.200|
0000b8  f7fffffe          BL       HAL_GetSensingMode
0000bc  f4104f80          TST      r0,#0x4000            ;202
0000c0  bf18              IT       NE                    ;204
0000c2  240a              MOVNE    r4,#0xa               ;204
0000c4  d002              BEQ      |L2.204|
0000c6  e08d              B        |L2.484|
                  |L2.200|
0000c8  2401              MOVS     r4,#1                 ;199
0000ca  e08b              B        |L2.484|
                  |L2.204|
0000cc  2406              MOVS     r4,#6                 ;208
0000ce  e089              B        |L2.484|
                  |L2.208|
0000d0  f7fffffe          BL       module_Defense_Recovery
0000d4  b110              CBZ      r0,|L2.220|
0000d6  f7fffffe          BL       module_Tsync1_SignalBypass
0000da  e083              B        |L2.484|
                  |L2.220|
0000dc  f7fffffe          BL       module_Init_LcdOn
0000e0  2403              MOVS     r4,#3                 ;219
0000e2  e07f              B        |L2.484|
                  |L2.228|
0000e4  f7fffffe          BL       algorithm_baseline_tracking_initial
0000e8  6878              LDR      r0,[r7,#4]            ;255  ; sptAlgorithmInfo
0000ea  f5005080          ADD      r0,r0,#0x1000         ;255
0000ee  f8805fb7          STRB     r5,[r0,#0xfb7]        ;255
0000f2  f7fffffe          BL       HAL_GetSensingMode
0000f6  f4105f80          TST      r0,#0x1000            ;257
0000fa  bf14              ITE      NE                    ;259
0000fc  240b              MOVNE    r4,#0xb               ;259
0000fe  2409              MOVEQ    r4,#9                 ;263
000100  e070              B        |L2.484|
                  |L2.258|
000102  488b              LDR      r0,|L2.816|
000104  6185              STR      r5,[r0,#0x18]         ;280  ; tHalIntrHandle
000106  2001              MOVS     r0,#1                 ;283
000108  f7fffffe          BL       HAL_SetECLKOnOffControl
00010c  6878              LDR      r0,[r7,#4]            ;287  ; sptAlgorithmInfo
00010e  240c              MOVS     r4,#0xc               ;290
000110  f5005080          ADD      r0,r0,#0x1000         ;287
000114  f8c05fa4          STR      r5,[r0,#0xfa4]        ;291
                  |L2.280|
000118  e064              B        |L2.484|
                  |L2.282|
00011a  f7fffffe          BL       Hal_Kick_DOG
00011e  4885              LDR      r0,|L2.820|
000120  7801              LDRB     r1,[r0,#0]            ;299  ; RESET_FLAG
000122  2901              CMP      r1,#1                 ;299
000124  bf04              ITT      EQ                    ;304
000126  7005              STRBEQ   r5,[r0,#0]            ;304
000128  2405              MOVEQ    r4,#5                 ;305
00012a  d05b              BEQ      |L2.484|
00012c  f7fffffe          BL       module_wait_full_sample_done
000130  2800              CMP      r0,#0                 ;310
000132  d0c9              BEQ      |L2.200|
000134  f8dfb200          LDR      r11,|L2.824|
000138  f89b0000          LDRB     r0,[r11,#0]           ;317  ; DoReportOrgPos
00013c  b128              CBZ      r0,|L2.330|
00013e  f7fffffe          BL       algorithm_PendTouchEvent
000142  f7fffffe          BL       algorithm_coord_UpdatePosHistoryInfo
000146  f88b5000          STRB     r5,[r11,#0]           ;320
                  |L2.330|
00014a  e9d90102          LDRD     r0,r1,[r9,#8]         ;320
00014e  e9cd0102          STRD     r0,r1,[sp,#8]         ;320
000152  a902              ADD      r1,sp,#8
000154  2003              MOVS     r0,#3
000156  9a00              LDR      r2,[sp,#0]
000158  f7fffffe          BL       protocol_Log
;;;335    
;;;336    #if USED_NORMAL_NI_SENSING
;;;337    				if(algorithm_process_ni() == NO)
;;;338    				{
;;;339    					sub_state = TOUCH_NORMAL_OPER_RESET_REFERENCE;
;;;340    					break;
;;;341    				}
;;;342    #endif /* USED_NORMAL_NI_SENSING */
;;;343    
;;;344    //				usbConnected = mUsbCfgST();
;;;345    
;;;346    				if (wakeupSignalEn)
00015c  7838              LDRB     r0,[r7,#0]  ; wakeupSignalEn
00015e  2800              CMP      r0,#0
;;;347    				{
;;;348    					if (frameCntForUSBAbnormal++ > 2)
;;;349    					{
;;;350    						wakeupSignalEn = NO;
;;;351    						frameCntForUSBAbnormal = 0;
;;;352    						abnormalUSBOperating = YES;
;;;353    					}
;;;354    				}
;;;355    				else
;;;356    				{
;;;357    					frameCntForUSBAbnormal = 0;
;;;358    					abnormalUSBOperating = NO;
000160  bf04              ITT      EQ
000162  60bd              STREQ    r5,[r7,#8]  ; frameCntForUSBAbnormal
000164  707d              STRBEQ   r5,[r7,#1]
000166  d00a              BEQ      |L2.382|
000168  68b8              LDR      r0,[r7,#8]            ;348  ; frameCntForUSBAbnormal
00016a  e000              B        |L2.366|
                  |L2.364|
00016c  e03f              B        |L2.494|
                  |L2.366|
00016e  1c41              ADDS     r1,r0,#1              ;348
000170  60b9              STR      r1,[r7,#8]            ;348  ; frameCntForUSBAbnormal
000172  2802              CMP      r0,#2                 ;348
000174  dd03              BLE      |L2.382|
000176  703d              STRB     r5,[r7,#0]            ;350
000178  2001              MOVS     r0,#1                 ;352
00017a  60bd              STR      r5,[r7,#8]            ;352  ; frameCntForUSBAbnormal
00017c  7078              STRB     r0,[r7,#1]            ;352
                  |L2.382|
;;;359    				}
;;;360    
;;;361    #if 1
;;;362    				if(algorithm_process(FULL_MODE) == NO)
00017e  2000              MOVS     r0,#0
000180  f7fffffe          BL       algorithm_process
000184  2800              CMP      r0,#0
000186  d0a1              BEQ      |L2.204|
;;;363    				{
;;;364    #if USED_ESD_RECOVERY_CODE
;;;365    					while(1); //WDT Reset
;;;366    #else /* USED_ESD_RECOVERY_CODE */
;;;367    					sub_state = TOUCH_NORMAL_OPER_RESET_REFERENCE;
;;;368    #endif /* USED_ESD_RECOVERY_CODE */
;;;369    					break;
;;;370    				}
;;;371    #endif
;;;372    				//Phone Noise
;;;373    				if(SRIC_reset_flag)
000188  486c              LDR      r0,|L2.828|
00018a  7801              LDRB     r1,[r0,#0]  ; SRIC_reset_flag
00018c  2900              CMP      r1,#0
;;;374    				{
;;;375    #if USED_ESD_RECOVERY_CODE
;;;376    					while(1); //WDT Reset
;;;377    #else /* USED_ESD_RECOVERY_CODE */
;;;378    					SRIC_reset_flag = NO;
00018e  bf1c              ITT      NE
000190  7005              STRBNE   r5,[r0,#0]
;;;379    					sub_state = TOUCH_NORMAL_OPER_RESET_MODULE;
000192  2405              MOVNE    r4,#5
;;;380    #endif /* USED_ESD_RECOVERY_CODE */
;;;381    				}
;;;382    
;;;383    #if ABNORMAL_TSYNC_FALLING_TIME_CHECK
;;;384    				if(abnormalTsyncLowTime)
000194  486a              LDR      r0,|L2.832|
000196  7801              LDRB     r1,[r0,#0]  ; abnormalTsyncLowTime
000198  b121              CBZ      r1,|L2.420|
;;;385    				{
;;;386    					abnormalTsyncLowTime = NO;
00019a  7005              STRB     r5,[r0,#0]
;;;387    					abnormal_rawdata_temp(NO);  // abnormal raw data count init...
00019c  2000              MOVS     r0,#0
00019e  f7fffffe          BL       abnormal_rawdata_temp
;;;388    
;;;389    					SensingBufferInit();
;;;390    					sub_state = TOUCH_NORMAL_OPER_ENTER;
;;;391    					TEST_LOCAL_STATE = 0;
;;;392    
;;;393    					break;
0001a2  e003              B        |L2.428|
                  |L2.420|
;;;394    				}
;;;395    				else
;;;396    				{
;;;397    					if (abnormal_rawdata_temp(NO))
0001a4  2000              MOVS     r0,#0
0001a6  f7fffffe          BL       abnormal_rawdata_temp
0001aa  b120              CBZ      r0,|L2.438|
                  |L2.428|
;;;398    					{
;;;399    #if USED_ESD_RECOVERY_CODE
;;;400    						while(1); //WDT Reset
;;;401    #else /* USED_ESD_RECOVERY_CODE */
;;;402    						SensingBufferInit();
0001ac  f7fffffe          BL       SensingBufferInit
;;;403    						sub_state = TOUCH_NORMAL_OPER_ENTER;
0001b0  2401              MOVS     r4,#1
;;;404    						TEST_LOCAL_STATE = 0;
;;;405    #endif /* USED_ESD_RECOVERY_CODE */
;;;406    
;;;407    						break;
0001b2  60fd              STR      r5,[r7,#0xc]  ; TEST_LOCAL_STATE
0001b4  e016              B        |L2.484|
                  |L2.438|
;;;408    					}
;;;409    				}
;;;410    #else
;;;411    				if(abnormal_rawdata_temp(NO))
;;;412    				{
;;;413    #if USED_ESD_RECOVERY_CODE
;;;414    					while(1); //WDT Reset
;;;415    #else /* USED_ESD_RECOVERY_CODE */
;;;416    					SensingBufferInit();
;;;417    					sub_state = TOUCH_NORMAL_OPER_ENTER;
;;;418    					TEST_LOCAL_STATE = 0;
;;;419    #endif /* USED_ESD_RECOVERY_CODE */
;;;420    					break;
;;;421    				}
;;;422    #endif
;;;423    
;;;424    #if USED_RF_NOISE_RECOVERY_CODE
;;;425    				if(algorithm_check_abnormal_deltadata())
;;;426    				{
;;;427    					while(1); //WDT Reset
;;;428    				}
;;;429    
;;;430    //				if (GPIO->tGPIO_DATA_1._GPIO_VUSB18 == 0x1)
;;;431    //				{
;;;432    //					if (CheckRemoteWakeup() == 0  && (CheckUsbConfig() != 1) && (CheckHIDReady() != 1))
;;;433    //					{
;;;434    //						while(1); //WDT Reset
;;;435    //					}
;;;436    //				}
;;;437    #endif /* USED_RF_NOISE_RECOVERY_CODE */	
;;;438    				
;;;439    #if USED_NOISE_HOPPING_FREQ
;;;440    				if (algorithm_Check_FreqHopping())
;;;441    				{
;;;442    #if (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B)
;;;443    					if(IS_LPWG_MODE(HAL_GetSensingMode())) break;
;;;444    #endif /* (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B) */		
;;;445    					sub_state = TOUCH_NORMAL_OPER_SWITCH_FREQ;
;;;446    					break;
;;;447    				}
;;;448    #endif /* USED_NOISE_HOPPING_FREQ */
;;;449    
;;;450    #if USED_IDLE_MODE_CONTROL
;;;451    				if(algorithm_CheckFingerIdleModeControl())
;;;452    				{
;;;453    					if(FLAG_mode == 130)
;;;454    						sub_state = TOUCH_NORMAL_OPER_SWITCH_FREQ;
;;;455    					else
;;;456    						sub_state = TOUCH_NORMAL_OPER_IDLE_READY;
;;;457    					break;
;;;458    				}
;;;459    #endif /* USED_IDLE_MODE_CONTROL */
;;;460    				
;;;461    #if USED_FRAME_SKIP_IDLE_MODE_CONTROL
;;;462    				if(algorithm_CheckFingerIdleModeControl())
0001b6  f7fffffe          BL       algorithm_CheckFingerIdleModeControl
0001ba  b198              CBZ      r0,|L2.484|
;;;463    				{					
;;;464    #if (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B)
;;;465    					if(IS_LPWG_MODE(HAL_GetSensingMode())) break;
;;;466    #endif /* (USED_LPWG_MODE_CONTROL && CUSTOMER == MODEL_LGD_SW97400B) */		
;;;467    					if(HAL_GetSensingChangeMode() == SM_CHANGE_IDLE_MODE)
0001bc  f7fffffe          BL       HAL_GetSensingChangeMode
0001c0  2801              CMP      r0,#1
;;;468    					{
;;;469    						HAL_SetSensingMode(SM_FINGER_ONLY_IDLE_MODE);
0001c2  bf08              IT       EQ
0001c4  f44f5088          MOVEQ    r0,#0x1100
0001c8  d006              BEQ      |L2.472|
;;;470    					}
;;;471    					else if(HAL_GetSensingChangeMode() == SM_CHANGE_ACTIVE_FRQ_MAIN_MODE)
0001ca  f7fffffe          BL       HAL_GetSensingChangeMode
0001ce  2802              CMP      r0,#2
;;;472    					{
;;;473    						HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
0001d0  bf08              IT       EQ
0001d2  f2410003          MOVEQ    r0,#0x1003
0001d6  d101              BNE      |L2.476|
                  |L2.472|
0001d8  f7fffffe          BL       HAL_SetSensingMode
                  |L2.476|
;;;474    					}
;;;475    					HAL_SetSensingChangeMode(SM_CHANGE_COMPLETE);
0001dc  2000              MOVS     r0,#0
0001de  f7fffffe          BL       HAL_SetSensingChangeMode
;;;476    
;;;477    					sub_state = TOUCH_NORMAL_OPER_NORMAL_READY;
0001e2  240b              MOVS     r4,#0xb
                  |L2.484|
;;;478    
;;;479    					break;
;;;480    				}
;;;481    #endif /* USED_FRAME_SKIP_IDLE_MODE_CONTROL */			
;;;482    				break;
;;;483    			}
;;;484    #if USED_IDLE_MODE_CONTROL
;;;485    			case TOUCH_NORMAL_OPER_IDLE_READY:
;;;486    			{
;;;487    				//HAL_SetSensingChangeMode(SM_CHANGE_IDLE_MODE);
;;;488    				if(IDLE_FLAG==NORMAL_OPER)
;;;489    				{
;;;490    					IDLE_FLAG = IDLE_READY;
;;;491    					FLAG_30Hz = 1;
;;;492    				}
;;;493    				sptAlgorithmInfo->ulIdleModeEnterCheckCount = 0;
;;;494    				tHalIntrHandle.ulInitFirstFrame = 0;
;;;495    #if USED_ECLK_ON_OFF_CONTROL
;;;496    				HAL_SetECLKOnOffControl(YES);
;;;497    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;498    #if USED_REFERENCE_INIT_IDLE_MODE_ENTER
;;;499    				sub_state = TOUCH_NORMAL_OPER_RESET_REFERENCE_IDLE;
;;;500    #else /* USED_REFERENCE_INIT_IDLE_MODE_ENTER */
;;;501    				sub_state = TOUCH_NORMAL_OPER_IDLE;
;;;502    #endif /* USED_REFERENCE_INIT_IDLE_MODE_ENTER */
;;;503    				break;
;;;504    			}
;;;505    			case TOUCH_NORMAL_OPER_IDLE:
;;;506    			{
;;;507    #ifdef MODE_WDT
;;;508    				KICK_DOG();
;;;509    #endif /* MODE_WDT */
;;;510    				if(RESET_FLAG == 1)
;;;511                    {	
;;;512    					RESET_FLAG = 0;
;;;513    					IDLE_FLAG = IDLE_END;
;;;514    					FLAG_30Hz = 3;
;;;515    					sub_state = TOUCH_NORMAL_OPER_RESET_MODULE;
;;;516    					break;
;;;517                    }	
;;;518    				if(IDLE_FLAG==IDLE_OPER)
;;;519    				{
;;;520    					if(!module_wait_full_sample_done())
;;;521    					//if(!module_wait_NI_sample_done())
;;;522    					{
;;;523    						sub_state = TOUCH_NORMAL_OPER_ENTER;
;;;524    						break;
;;;525    					}
;;;526    					//protocol_LogMatrix(LT_RAWDATA, sptAlgorithmInfo->ucScreenCol, HAL_GET_RAW_IMAGE_PTR(), COL_MAX, sptAlgorithmInfo->ucScreenRow, 84/*Raw Data*/);
;;;527    
;;;528    					if(algorithm_process_Idle() == NO)
;;;529    					{
;;;530    						SensingBufferInit();
;;;531    						sub_state = TOUCH_NORMAL_OPER_RESET_MODULE;//TOUCH_NORMAL_OPER_NORMAL_READY;
;;;532    						break;
;;;533    					}
;;;534    	
;;;535    					if(algorithm_CheckFingerIdleModeControl()||protocol_swip_GetMode()==M_TOUCH_DIAG)
;;;536    					{
;;;537    						IDLE_FLAG = IDLE_END;
;;;538    						FLAG_30Hz = 3;
;;;539    						SensingBufferInit();
;;;540    						sub_state = TOUCH_NORMAL_OPER_NORMAL_READY;//TOUCH_NORMAL_OPER_RESET_MODULE;
;;;541    						HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
;;;542    						break;
;;;543    					}
;;;544    				}
;;;545    				break;
;;;546    			}
;;;547    #endif /* USED_IDLE_MODE_CONTROL */
;;;548    #if USED_NOISE_HOPPING_FREQ
;;;549    			case TOUCH_NORMAL_OPER_SWITCH_FREQ:
;;;550    			{
;;;551    				eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
;;;552    				eSENSING_FREQ_t _Freq;
;;;553    				
;;;554    				if(IS_ACTIVE_MODE_FRQ_MAIN(eSensingMode))
;;;555    				{
;;;556    					_Freq = thisCommonConf->HoppFreq1;
;;;557    				}
;;;558    				else if(IS_ACTIVE_MODE_FRQ_HOP1(eSensingMode))
;;;559    				{
;;;560    					_Freq = thisCommonConf->MainFreq;
;;;561    				}
;;;562    				
;;;563    #if USED_ECLK_ON_OFF_CONTROL
;;;564    				HAL_SetECLKOnOffControl(NO);
;;;565    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;566    
;;;567    				if(module_Switch_Freq(_Freq))
;;;568    				{
;;;569    					if(_Freq == thisCommonConf->HoppFreq1)
;;;570    					{
;;;571    						HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_HOP1_MODE);
;;;572    						sub_state = TOUCH_NORMAL_OPER_NORMAL_READY;
;;;573    					}
;;;574    					else if(_Freq == thisCommonConf->MainFreq)
;;;575    					{
;;;576    						HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
;;;577    						sub_state = TOUCH_NORMAL_OPER_NORMAL_READY;
;;;578    					}
;;;579    				}
;;;580    				else
;;;581    				{
;;;582    					sub_state = TOUCH_NORMAL_OPER_RESET_MODULE;
;;;583    				}
;;;584    				break;
;;;585    			}
;;;586    #endif /* USED_NOISE_HOPPING_FREQ */
;;;587    
;;;588    			case TOUCH_NORMAL_OPER_EXIT:
;;;589    			{
;;;590    #ifdef MODE_WDT				
;;;591    				Hal_WDT_DeInit();
;;;592    #endif /* MODE_WDT */
;;;593    				module_Stop(); // NOTE : �Լ� ���������� ����!!
;;;594    				
;;;595    				bLoop = NO;
;;;596    				continue;
;;;597    				/* no break */
;;;598    			}
;;;599        	}
;;;600    
;;;601    		if( protocol_swip_GetRecalibrate() == YES)
0001e4  f7fffffe          BL       protocol_swip_GetRecalibrate
0001e8  2801              CMP      r0,#1
0001ea  d112              BNE      |L2.530|
0001ec  e004              B        |L2.504|
                  |L2.494|
0001ee  f7fffffe          BL       Hal_WDT_DeInit
0001f2  f7fffffe          BL       module_Stop
0001f6  e08f              B        |L2.792|
                  |L2.504|
0001f8  e9d90100          LDRD     r0,r1,[r9,#0]         ;596
;;;602    		{
;;;603    			protocol_LogCode(LT_DIAGNOSIS, (4)/*System is Entered!*/);
0001fc  e9cd0102          STRD     r0,r1,[sp,#8]
000200  2200              MOVS     r2,#0
000202  a902              ADD      r1,sp,#8
000204  4610              MOV      r0,r2
000206  f7fffffe          BL       protocol_Log
;;;604    
;;;605    			sub_state = TOUCH_NORMAL_OPER_RESET_REFERENCE;
00020a  2406              MOVS     r4,#6
;;;606    
;;;607    			protocol_swip_SetRecalibrate(NO);
00020c  2000              MOVS     r0,#0
00020e  f7fffffe          BL       protocol_swip_SetRecalibrate
                  |L2.530|
;;;608    		}
;;;609    
;;;610    		if( protocol_swip_GetReadModuleConfigStatus() == YES )
000212  f7fffffe          BL       protocol_swip_GetReadModuleConfigStatus
000216  2801              CMP      r0,#1
000218  d103              BNE      |L2.546|
;;;611    		{
;;;612    //			module_Stop();
;;;613    
;;;614    			sub_state = TOUCH_NORMAL_OPER_RESET_MODULE;
00021a  2405              MOVS     r4,#5
;;;615    
;;;616    			protocol_swip_SetReadModuleConfigStatus(NO);
00021c  2000              MOVS     r0,#0
00021e  f7fffffe          BL       protocol_swip_SetReadModuleConfigStatus
                  |L2.546|
;;;617    		}
;;;618    
;;;619    		currMode = protocol_swip_GetMode();
000222  f7fffffe          BL       protocol_swip_GetMode
000226  4683              MOV      r11,r0
;;;620    		if(currMode != prevMode)
000228  42b0              CMP      r0,r6
00022a  d070              BEQ      |L2.782|
;;;621    		{
;;;622    			switch( currMode )
00022c  f1bb0f05          CMP      r11,#5
000230  d26d              BCS      |L2.782|
000232  e8dff00b          TBB      [pc,r11]
000236  0306              DCB      0x03,0x06
000238  173c6900          DCB      0x17,0x3c,0x69,0x00
;;;623    			{
;;;624    				case M_TOUCH_NORMAL:
;;;625    				{
;;;626    					protocol_swip_PendReadyStatus();
00023c  f7fffffe          BL       protocol_swip_PendReadyStatus
;;;627    
;;;628    					break;
000240  e065              B        |L2.782|
;;;629    				}
;;;630    				case M_TOUCH_DIAG:
;;;631    				{
;;;632    					eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
000242  f7fffffe          BL       HAL_GetSensingMode
;;;633    					sub_state = TOUCH_NORMAL_OPER_EXIT;
000246  2416              MOVS     r4,#0x16
;;;634    					main_state = TOUCH_MAIN_OPERATION_DIAG;
000248  f04f0804          MOV      r8,#4
;;;635    					
;;;636    #if USED_ECLK_ON_OFF_CONTROL
;;;637    					HAL_SetECLKOnOffControl(NO);
00024c  2000              MOVS     r0,#0
00024e  f7fffffe          BL       HAL_SetECLKOnOffControl
;;;638    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;639    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;640    					HAL_SetTPICMuxEnControl(NO);
000252  2000              MOVS     r0,#0
000254  f7fffffe          BL       HAL_SetTPICMuxEnControl
;;;641    					GPIO->tGPIO_DATA_1._GPIO_TPIC_MUX_EN = 1;
000258  483a              LDR      r0,|L2.836|
00025a  6841              LDR      r1,[r0,#4]
00025c  f0410110          ORR      r1,r1,#0x10
000260  6041              STR      r1,[r0,#4]
;;;642    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;643    //					if(IS_FINGER_PEN_MODE(eSensingMode))
;;;644    //					{
;;;645    //						HAL_SetSensingChangeMode(SM_CHANGE_FINGER_PEN_SEARCH_MODE);
;;;646    //					}
;;;647    //					else
;;;648    //					{
;;;649    //						if(IS_IDLE_MODE(eSensingMode))
;;;650    //						{
;;;651    //							HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
;;;652    //						}
;;;653    //						else
;;;654    //						{
;;;655    //							if(!IS_ACTIVE_MODE_FRQ_MAIN(eSensingMode))
;;;656    //							{
;;;657    //								HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
;;;658    //							}
;;;659    //						}
;;;660    //					}
;;;661    					/*
;;;662    					 * Wait Mode Change!!
;;;663    					 */
;;;664    //					module_wait_full_sample_done();
;;;665    
;;;666    					break;
000262  e054              B        |L2.782|
;;;667    				}
;;;668    				case M_TOUCH_DFUP:
;;;669    				{
;;;670    					sub_state = TOUCH_NORMAL_OPER_EXIT;
;;;671    					main_state = TOUCH_MAIN_OPERATION_DFUP;
;;;672    
;;;673    					// TSYNCN_OUT High
;;;674    					GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x01;
000264  4837              LDR      r0,|L2.836|
000266  2416              MOVS     r4,#0x16              ;670
000268  f04f0805          MOV      r8,#5                 ;671
00026c  6841              LDR      r1,[r0,#4]
00026e  f0410108          ORR      r1,r1,#8
000272  6041              STR      r1,[r0,#4]
;;;675    					GPIO->tGPIO_DIR_1._GPIO_TSYNC_OUT = 0x1;  // OUTPUT
000274  68c1              LDR      r1,[r0,#0xc]
000276  f0410108          ORR      r1,r1,#8
00027a  60c1              STR      r1,[r0,#0xc]
;;;676    					GPIO->tGPIO_AFIO_2._GPIO_TSYNC_OUT = 0x0;
00027c  6e81              LDR      r1,[r0,#0x68]
00027e  f02101c0          BIC      r1,r1,#0xc0
000282  6681              STR      r1,[r0,#0x68]
;;;677    					PWMDRV_ITConfig(DISABLE);
000284  2000              MOVS     r0,#0
000286  f7fffffe          BL       PWMDRV_ITConfig
00028a  f04f20e0          MOV      r0,#0xe000e000
00028e  2102              MOVS     r1,#2
000290  f8c01180          STR      r1,[r0,#0x180]
000294  2104              MOVS     r1,#4
000296  f8c01180          STR      r1,[r0,#0x180]
;;;678    					NVIC_DisableIRQ(EXTI0_IRQn);
;;;679    					NVIC_DisableIRQ(EXTI1_IRQn);
;;;680    					MSPI_ITConfig(DISABLE);
00029a  2000              MOVS     r0,#0
00029c  f7fffffe          BL       MSPI_ITConfig
;;;681    					MSPI_Cmd(DISABLE);
0002a0  2000              MOVS     r0,#0
0002a2  f7fffffe          BL       MSPI_Cmd
;;;682    					PWMDRV_Cmd(DISABLE);
0002a6  2000              MOVS     r0,#0
0002a8  f7fffffe          BL       PWMDRV_Cmd
;;;683    
;;;684    					break;
0002ac  e02f              B        |L2.782|
;;;685    				}
;;;686    				case M_PARAMETER:
;;;687    				{
;;;688    //					F_GPB11();
;;;689    #if USED_ECLK_ON_OFF_CONTROL
;;;690    					HAL_SetECLKOnOffControl(NO);
0002ae  2000              MOVS     r0,#0
0002b0  f7fffffe          BL       HAL_SetECLKOnOffControl
;;;691    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;692    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;693    					HAL_SetTPICMuxEnControl(NO);
0002b4  2000              MOVS     r0,#0
0002b6  f7fffffe          BL       HAL_SetTPICMuxEnControl
;;;694    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;695    					GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x01;
0002ba  4822              LDR      r0,|L2.836|
0002bc  6841              LDR      r1,[r0,#4]
0002be  f0410108          ORR      r1,r1,#8
0002c2  6041              STR      r1,[r0,#4]
;;;696    					GPIO->tGPIO_DIR_1._GPIO_TSYNC_OUT = 0x1;  // OUTPUT
0002c4  68c1              LDR      r1,[r0,#0xc]
0002c6  f0410108          ORR      r1,r1,#8
0002ca  60c1              STR      r1,[r0,#0xc]
;;;697    					GPIO->tGPIO_AFIO_2._GPIO_TSYNC_OUT = 0x0;
0002cc  6e81              LDR      r1,[r0,#0x68]
0002ce  f02101c0          BIC      r1,r1,#0xc0
0002d2  6681              STR      r1,[r0,#0x68]
;;;698    					PWMDRV_ITConfig(DISABLE);
0002d4  2000              MOVS     r0,#0
0002d6  f7fffffe          BL       PWMDRV_ITConfig
0002da  f04f20e0          MOV      r0,#0xe000e000
0002de  2102              MOVS     r1,#2
0002e0  f8c01180          STR      r1,[r0,#0x180]
0002e4  2104              MOVS     r1,#4
0002e6  f8c01180          STR      r1,[r0,#0x180]
;;;699    					NVIC_DisableIRQ(EXTI0_IRQn);
;;;700    					NVIC_DisableIRQ(EXTI1_IRQn);
;;;701    					MSPI_ITConfig(DISABLE);
0002ea  2000              MOVS     r0,#0
0002ec  f7fffffe          BL       MSPI_ITConfig
;;;702    					MSPI_Cmd(DISABLE);
0002f0  2000              MOVS     r0,#0
0002f2  f7fffffe          BL       MSPI_Cmd
;;;703    					PWMDRV_Cmd(DISABLE);
0002f6  2000              MOVS     r0,#0
0002f8  f7fffffe          BL       PWMDRV_Cmd
;;;704    
;;;705    					PARAM_SetMode(PARAM_MODE_NONE);
0002fc  f04f30ff          MOV      r0,#0xffffffff
000300  f7fffffe          BL       PARAM_SetMode
;;;706    					sub_state = TOUCH_NORMAL_OPER_RESET_SYSTEM;
000304  2403              MOVS     r4,#3
;;;707    					break;
000306  e002              B        |L2.782|
;;;708    				}
;;;709    				case M_TOUCH_LPWG:
;;;710    				{
;;;711    					sub_state = TOUCH_NORMAL_OPER_EXIT;
000308  2416              MOVS     r4,#0x16
;;;712    					main_state = TOUCH_MAIN_OPERATION_LPWG;
00030a  f04f0803          MOV      r8,#3
                  |L2.782|
00030e  9801              LDR      r0,[sp,#4]            ;596
;;;713    					break;
;;;714    				}
;;;715    			}
;;;716    		}
;;;717    
;;;718    		prevMode = currMode;	
000310  465e              MOV      r6,r11
000312  2800              CMP      r0,#0                 ;596
000314  f47fae8a          BNE      |L2.44|
                  |L2.792|
;;;719        }
;;;720    
;;;721        return main_state;
;;;722    }
000318  b005              ADD      sp,sp,#0x14
00031a  4640              MOV      r0,r8                 ;721
00031c  e8bd8ff0          POP      {r4-r11,pc}
;;;723    
                          ENDP

                  |L2.800|
                          DCD      ||.data||
                  |L2.804|
                          DCD      custom_tool
                  |L2.808|
                          DCD      FullSharedBuff+0x10294
                  |L2.812|
                          DCD      ||.constdata||
                  |L2.816|
                          DCD      tHalIntrHandle
                  |L2.820|
                          DCD      RESET_FLAG
                  |L2.824|
                          DCD      DoReportOrgPos
                  |L2.828|
                          DCD      SRIC_reset_flag
                  |L2.832|
                          DCD      abnormalTsyncLowTime
                  |L2.836|
                          DCD      0x40007000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ||<Data1>||
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  04000000          DCB      0x04,0x00,0x00,0x00
000008  30606082          DCB      0x30,0x60,0x60,0x82
00000c  5400              DCB      0x54,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  wakeupSignalEn
000000  00                DCB      0x00
                  abnormalUSBOperating
000001  000000            DCB      0x00,0x00,0x00
                  sptAlgorithmInfo
                          DCD      0x00000000
                  frameCntForUSBAbnormal
                          DCD      0x00000000
                  TEST_LOCAL_STATE
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  GoToThisState
000000  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=1

                          EXPORTAS ||area_number.8||, ||.data||
                  currentColStart
000000  0000              DCW      0x0000

                          AREA ||area_number.9||, DATA, ALIGN=0

                          EXPORTAS ||area_number.9||, ||.data||
                  diff_rs_cnt
000000  00                DCB      0x00

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  bChangeSampling
000000  00                DCB      0x00

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  check_frm
                          DCD      0x00000008

                          AREA ||area_number.12||, DATA, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.data||
                  check_cnt
                          DCD      0x00000008

                          AREA ||area_number.13||, DATA, ALIGN=0

                          EXPORTAS ||area_number.13||, ||.data||
                  sensing_cont_cnt
000000  01                DCB      0x01

                          AREA ||area_number.14||, DATA, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.data||
                  g_pendata_pressure
000000  0000              DCW      0x0000

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  gDCFullMode
                          DCD      0x00000001

                          AREA ||area_number.16||, DATA, ALIGN=0

                          EXPORTAS ||area_number.16||, ||.data||
                  FLAG_mode
000000  6e                DCB      0x6e

;*** Start embedded assembler ***

#line 1 "..\\..\\App\\app_normal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_app_normal_c_669f049c____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___12_app_normal_c_669f049c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_app_normal_c_669f049c____REVSH|
#line 402
|__asm___12_app_normal_c_669f049c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_app_normal_c_669f049c____RRX|
#line 587
|__asm___12_app_normal_c_669f049c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
