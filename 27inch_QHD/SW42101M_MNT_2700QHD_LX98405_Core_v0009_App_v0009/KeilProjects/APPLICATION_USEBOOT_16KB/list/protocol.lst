L 1 "..\..\Protocol\protocol.c"
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : protocol.c
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#include "protocol_def.h"
L 1 "..\..\Protocol\protocol_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  protocol_def.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _PROTOCOL_DEF_H_
N#define _PROTOCOL_DEF_H_
N
N
N#include "env_def.h"
L 1 "..\..\Env\env_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_def.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_DEF_H_
N#define _ENV_DEF_H_
N
N
N#include "MFTP.h"
L 1 "..\..\Hal\system\MFTP.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : MFTP.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N/** @addtogroup MFTP
N  * @{
N  */
N
N#ifndef _MFTP_H_
N#define _MFTP_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M3 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
N                                                         and No Match                                                          */
N  BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
N                                                         related Fault                                                         */
N  UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* -----------------------  MFTP Specific Interrupt Numbers  ----------------------- */
N  WDT_IRQn                      =   0,              /*!<   0  WatchDog Timer                                              */
N  EXTI0_IRQn                    =   1,              /*!<   1  EXTI0                                                            */
N  EXTI1_IRQn                    =   2,              /*!<   2  EXTI1                                                            */
N  TIMER_IRQn                    =   3,              /*!<   3  TIMER                                                           */
N  I2C_IRQn                      =   4,              /*!<   6  I2C                                                              */
N  TSPI_IRQn                     =   5,              /*!<   8  TSPI                                                        */
N  USB_IRQn                      =   6,              /*!<   5  USB                                                              */
N  PWMDRV_IRQn                   =   7,              /*!<   4  PWMDRV                                                            */
N  MSPI_IRQn                     =   8,              /*!<   9  MSPI                                                        */
N  GPDMA_IRQn                    =   9,              /*!<  10  GPDMA                                                            */
N  DSP_A_IRQn                    =  10,              /*!<  11  DSPA(LGD)                                                            */
N  DSP_B_IRQn                    =  11,              /*!<  11  DSPB(SiW)                                                            */
N  PLL_IRQn                      =  12,              /*!<   7  PLL                                                  */
N  FLITF_IRQn                    =  13               /*!<  12  FLITF                                                            */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the Cortex-M3 Processor and Core Peripherals---------------- */
N#define __CM3_REV                 0x0201            /*!< Cortex-M3 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               3            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include <core_cm3.h>                               /*!< Cortex-M3 processor and core peripherals                              */
L 1 "..\..\Hal\system\CMSIS\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   0xffffffffU
N#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM3_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x03U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __attribute__ ((packed))
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\..\Hal\system\CMSIS\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\Hal\system\CMSIS\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x03U) == 0x04U) || ((0x03U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x03U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\..\Hal\system\CMSIS\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\..\Hal\system\CMSIS\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201U)                   /* core r2p1 */
X#if (0x0201 < 0x0201U)                    
S#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
S#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
S
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200U))
X#if ((1L) && (0x0201 >= 0x200U))
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N#else
S        uint32_t RESERVED1[1U];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 96 "..\..\Hal\system\MFTP.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#define __BITBAND					__attribute__ ((bitband))
N#define __PACKED                    __attribute__ ((packed))
N#define __ALIGNED4                  __attribute__ ((aligned(4)))
N#define __INTERRUPT                 __attribute__ ((interrupt))
N#define __WEAK                      __attribute__ ((weak))
N#elif defined ( __ICCARM__ )
S#define __NOP           __no_operation                              /*!< no operation intrinsic in IAR Compiler */
S
S#elif defined ( __GNUC__ )
S#define __BITBAND					__attribute__ ((bitband))
S#define __PACKED                    __attribute__ ((packed))
S#define __ALIGNED4                  __attribute__ ((aligned(4)))
S#define __INTERRUPT                 __attribute__ ((interrupt))
S#define __WEAK                      __attribute__ ((weak))
N#endif
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N/*
NCode Memory
NFLASH: 128kB
N0x00000000~0x0001FFFF
N
NCode Memory
NSRAM: 64kB
N0x10000000~0x1000FFFF
N
NSystem Memory
NSRAM: 64kB
N0x20000000~0x2000FFFF
N
NSystem Memory
NSRAM: 32kB
N0x20010000~0x20017FFF
N
NSystem Memory
NSRAM: 32kB
N0x20018000~0x2001FFFF
N
NMSPI Memory
NSRAM: 64kB
N0x20020000~0x2002FFFF
N*/
N
N/* ============================================= */
N/* ===========    F/W & BOOT Size    =========== */
N/* ============================================= */
N#define FLASH_SIZE					( 128 * 1024 )
N
N#define FW_SECTOR_SIZE				( 112 * 1024 )
N#define ECC_SECTOR_SIZE				(   6 * 1024 )
N#define BOOT_SECTOR_SIZE			(  10 * 1024 )
N
N#define FW_CODE_MAX_SIZE			( 108 * 1024 )
N#define ECC_CODE_MAX_SIZE			(   5 * 1024 )
N#define BOOT_CODE_MAX_SIZE			(   9 * 1024 )
N	
N#define ECC_CODE_SIZE				(		   3 )	//   3byte
N#define ECC_BLOCK_SIZE				( 		 256 )	// 256byte
N#define ECC_SPARE_SIZE				( FW_CODE_MAX_SIZE / ECC_BLOCK_SIZE * ECC_CODE_SIZE )
N
N/* ============================================ */
N/* ===========    ECC Memory Map    =========== */
N/* ============================================ */
N#define	BASEADDR_FW					0x00004000UL	
N#define	BASEADDR_FW_CRC				0x0001FC00UL	
N#define	BASEADDR_FW_ECC_1			0x0001F000UL	
N#define	BASEADDR_FW_ECC_2			0x0001F600UL
N#define BASEADDR_BOOT				0x00001800UL
N#define BASEADDR_BOOT_CRC			0x00003F80UL
N#define BASEADDR_BOOT_ECC_1			0x00003C00UL
N#define BASEADDR_BOOT_ECC_2			0x00003D00UL
N#define BASEADDR_BOOT_INFO_1		0x00003E00UL
N#define BASEADDR_BOOT_INFO_2		0x00003E80UL
N#define BASEADDR_BOOT_INFO_3		0x00003F00UL
N
N#define BASEADDR_FW_ERROR			0x000017F4UL
N#define BASEADDR_BOOT_INFO_ERROR	0x000017F0UL
N
N/* ============================================================================================ */
N/* ===================================    ECC Declaration    ================================== */
N/* ============================================================================================ */
N#define BACKUP_FW_CRC				((BACKUP_CRC_TypeDef	*) 		BASEADDR_FW_CRC				)
N#define BACKUP_BOOT_CRC        		((BACKUP_CRC_TypeDef	*) 		BASEADDR_BOOT_CRC			)
N#define BACKUP_BOOT_INFO_1          ((BACKUP_INFO_TypeDef	*) 		BASEADDR_BOOT_INFO_1		)
N#define BACKUP_BOOT_INFO_2         	((BACKUP_INFO_TypeDef	*) 		BASEADDR_BOOT_INFO_2		)
N#define BACKUP_BOOT_INFO_3          ((BACKUP_INFO_TypeDef	*) 		BASEADDR_BOOT_INFO_3		)
N#define BACKUP_BOOT_INFO_ERROR		((BACKUP_INFO_ERROR_TypeDef	*)	BASEADDR_BOOT_INFO_ERROR	)
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N#define BASE_INFO                       0x00020000UL
N
N#define BASE_SRAM1                      0x20000000UL
N#define BASE_SRAM2                      0x20010000UL
N#define BASE_SRAM3                      0x20018000UL
N#define BASE_MSPI_SRAM					0x20020000UL
N
N#define BASE_SCRB                       0x40000000UL
N#define BASE_FLITF                      0x40001000UL
N#define BASE_I2C                        0x40002000UL
N#define BASE_TSPI                       0x40003000UL
N#define BASE_PWMDRV                     0x40004000UL
N#define BASE_MSPI                       0x40005000UL
N#define BASE_TIMER                      0x40006000UL
N#define BASE_GPIO                       0x40007000UL
N#define BASE_UWDT                       0x40008000UL
N#define BASE_HWACC                      0x40009000UL
N#define BASE_SIW						0x4000A000UL
N#define BASE_LWDT                       0x4000B000UL
N
N#define BASE_GPDMA                      0x40020000UL
N#define BASE_USB                        0x40030000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N#define INFO                            ((INFO_TypeDef        *) BASE_INFO  )
N#define SCRB                            ((tSCRB_CtrlReg_t     *) BASE_SCRB  )
N#define FLITF                           ((FLITF_TypeDef       *) BASE_FLITF )
N//#define SYSCFG                          ((tSYSCFG_CtrlReg_t   *) BASE_FLITF )
N#define I2C                             ((tI2C_CtrlReg_t      *) BASE_I2C   )
N#define TSPI                            ((TSPI_TypeDef        *) BASE_TSPI  )
N#define PWMDRV                          ((PWMDRV_TypeDef      *) BASE_PWMDRV)
N#define MSPI                            ((MSPI_TypeDef        *) BASE_MSPI  )
N#define TIMER                           ((tTIMER_CtrlReg_t    *) BASE_TIMER )
N#define GPIO                            ((tGPIO_CtrlReg_t     *) BASE_GPIO)
N#define UWDT                            ((WDT_TypeDef         *) BASE_UWDT  )
N#define LWDT                            ((WDT_TypeDef         *) BASE_LWDT  )
N#define DSPA                            ((tDSPA_CtrlReg_t     *) BASE_HWACC )
N#define DSP_CON                         ((DSP_CONTROL_TypeDef *) BASE_SIW   )
N#define GPDMA                           ((GDMA_TypeDef        *) BASE_GDMA )
N#define USB_HC							((USB_HC_TypeDef      *) BASE_USB  )
N#define USB_OTG							((USB_OTG_TypeDef     *) (BASE_USB+0x80))
N#define USB_GLOBAL						((USB_GLOBAL_TypeDef  *) (BASE_USB+0xC0))
N#define USB_DEVICE						((USB_DEVICE_TypeDef  *) (BASE_USB+0x100))
N
N/* -------------------  Include System Peripheral CMSIS Definition ------------------ */
N#include "../scrb/_scrb.h"
L 1 "..\..\Hal\system\../scrb/_scrb.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _scrb.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __SCRB_H_
N#define __SCRB_H_
N
N
N/* ================================================================================ */
N/* ================                      SCR                       ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  SCR Control Register
N */
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t METAL_REV		: 4;
X		volatile const uint32_t METAL_REV		: 4;
N		__I uint32_t FULL_REV		: 4;
X		volatile const uint32_t FULL_REV		: 4;
N		__I uint32_t CHIP_NAME		: 16;
X		volatile const uint32_t CHIP_NAME		: 16;
N		__I uint32_t reserved		: 8;
X		volatile const uint32_t reserved		: 8;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tDEVICE_ID_t;
N
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t LOCKUP		: 1;
X		volatile const uint32_t LOCKUP		: 1;
N		__I uint32_t HALTED		: 1;
X		volatile const uint32_t HALTED		: 1;
N		__I uint32_t reserved	: 30;
X		volatile const uint32_t reserved	: 30;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tCM3_STATUS_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t RST_STS_CLR	: 1;
X		volatile uint32_t RST_STS_CLR	: 1;
N		__I uint32_t SYSTEM_RST		: 1;
X		volatile const uint32_t SYSTEM_RST		: 1;
N		__I uint32_t WDT_RST		: 1;
X		volatile const uint32_t WDT_RST		: 1;
N		__I uint32_t EXT_RST		: 1;
X		volatile const uint32_t EXT_RST		: 1;
N		__I uint32_t reserved		: 28;
X		volatile const uint32_t reserved		: 28;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tRST_STATUS_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t I2C_BLK		: 1;
X		volatile uint32_t I2C_BLK		: 1;
N		__IO uint32_t I2C_WAKEUP	: 1;
X		volatile uint32_t I2C_WAKEUP	: 1;
N		__IO uint32_t I2C_SLEEP		: 1;
X		volatile uint32_t I2C_SLEEP		: 1;
N		__I uint32_t reserved		: 29;
X		volatile const uint32_t reserved		: 29;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tINTR_I2C_CFG_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t INTR_USR_WDT			: 1;
X		volatile uint32_t INTR_USR_WDT			: 1;
N		__IO uint32_t INTR_EXTI0			: 1;
X		volatile uint32_t INTR_EXTI0			: 1;
N		__IO uint32_t INTR_EXTI1			: 1;
X		volatile uint32_t INTR_EXTI1			: 1;
N		__IO uint32_t INTR_TIMER			: 1;
X		volatile uint32_t INTR_TIMER			: 1;
N		__IO uint32_t INTR_I2C				: 1;
X		volatile uint32_t INTR_I2C				: 1;
N		__IO uint32_t INTR_TSPI				: 1;
X		volatile uint32_t INTR_TSPI				: 1;
N		__IO uint32_t INTR_USB				: 1;
X		volatile uint32_t INTR_USB				: 1;
N		__IO uint32_t INTR_LFDTX			: 1;
X		volatile uint32_t INTR_LFDTX			: 1;
N		__IO uint32_t INTR_MSPI				: 1;
X		volatile uint32_t INTR_MSPI				: 1;
N		__IO uint32_t INTR_GDMA				: 1;
X		volatile uint32_t INTR_GDMA				: 1;
N		__IO uint32_t INTR_DSPA				: 1;
X		volatile uint32_t INTR_DSPA				: 1;
N		__IO uint32_t INTR_DSPB				: 1;
X		volatile uint32_t INTR_DSPB				: 1;
N		__IO uint32_t INTR_PLL				: 1;
X		volatile uint32_t INTR_PLL				: 1;
N		__IO uint32_t INTR_FLITF			: 1;
X		volatile uint32_t INTR_FLITF			: 1;
N		__IO uint32_t INTR_LOCK_WDT			: 1;
X		volatile uint32_t INTR_LOCK_WDT			: 1;
N		__IO uint32_t INTR_I2C_wakeup		: 1;
X		volatile uint32_t INTR_I2C_wakeup		: 1;
N		__IO uint32_t INTR_USB_SUSMPENDM	: 1;
X		volatile uint32_t INTR_USB_SUSMPENDM	: 1;
N		__IO uint32_t INTR_USB_LPMEN		: 1;
X		volatile uint32_t INTR_USB_LPMEN		: 1;
N		__I uint32_t reserved				: 14;
X		volatile const uint32_t reserved				: 14;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tINTR_NMI_CFG_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t TENMS			: 24;
X		volatile uint32_t TENMS			: 24;
N		__IO uint32_t SKEW			: 1;
X		volatile uint32_t SKEW			: 1;
N		__IO uint32_t NOREF			: 1;
X		volatile uint32_t NOREF			: 1;
N		__IO uint32_t SYSTICK_SRC	: 2;
X		volatile uint32_t SYSTICK_SRC	: 2;
N		__I uint32_t reserved		: 4;
X		volatile const uint32_t reserved		: 4;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSTCALIB_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t r_USB_CLK_ENA		: 1;
X		volatile uint32_t r_USB_CLK_ENA		: 1;
N		__IO uint32_t r_WDT_CLK_ENA		: 1;
X		volatile uint32_t r_WDT_CLK_ENA		: 1;
N		__IO uint32_t r_TIM_CLK_ENA		: 1;
X		volatile uint32_t r_TIM_CLK_ENA		: 1;
N		__IO uint32_t r_LFDTX_CLK_ENA	: 1;
X		volatile uint32_t r_LFDTX_CLK_ENA	: 1;
N		__IO uint32_t r_TSPI_CLK_ENA	: 1;
X		volatile uint32_t r_TSPI_CLK_ENA	: 1;
N		__IO uint32_t r_DSPA_CLK_ENA	: 1;
X		volatile uint32_t r_DSPA_CLK_ENA	: 1;
N		__IO uint32_t r_DSPB_CLK_ENA	: 1;
X		volatile uint32_t r_DSPB_CLK_ENA	: 1;
N		__IO uint32_t r_SRAM1_CLK_ENA	: 1;
X		volatile uint32_t r_SRAM1_CLK_ENA	: 1;
N		__IO uint32_t r_SRAM2_CLK_ENA	: 1;
X		volatile uint32_t r_SRAM2_CLK_ENA	: 1;
N		__IO uint32_t r_SRAM3_CLK_ENA	: 1;
X		volatile uint32_t r_SRAM3_CLK_ENA	: 1;
N		__IO uint32_t r_DMAC_CLK_ENA	: 1;
X		volatile uint32_t r_DMAC_CLK_ENA	: 1;
N		__IO uint32_t r_I2C_CLK_ENA		: 1;
X		volatile uint32_t r_I2C_CLK_ENA		: 1;
N		__IO uint32_t r_FLITF_CLK_ENA	: 1;
X		volatile uint32_t r_FLITF_CLK_ENA	: 1;
N		__IO uint32_t r_GPIO_CLK_ENA	: 1;
X		volatile uint32_t r_GPIO_CLK_ENA	: 1;
N		__I uint32_t reserved			: 2;
X		volatile const uint32_t reserved			: 2;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_RUN0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t r_MSPI01_CLK_ENA	: 1;
X		volatile uint32_t r_MSPI01_CLK_ENA	: 1;
N		__IO uint32_t r_MSPI23_CLK_ENA	: 1;
X		volatile uint32_t r_MSPI23_CLK_ENA	: 1;
N		__IO uint32_t r_MSPI45_CLK_ENA	: 1;
X		volatile uint32_t r_MSPI45_CLK_ENA	: 1;
N		__IO uint32_t r_SIF_CLK_ENA		: 1;
X		volatile uint32_t r_SIF_CLK_ENA		: 1;
N		__IO uint32_t r_SFL_CLK_ENA		: 1;
X		volatile uint32_t r_SFL_CLK_ENA		: 1;
N		__I uint32_t reserved			: 11;
X		volatile const uint32_t reserved			: 11;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_RUN1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t s_USB_CLK_ENA		: 1;
X		volatile uint32_t s_USB_CLK_ENA		: 1;
N		__IO uint32_t s_WDT_CLK_ENA		: 1;
X		volatile uint32_t s_WDT_CLK_ENA		: 1;
N		__IO uint32_t s_TIM_CLK_ENA		: 1;
X		volatile uint32_t s_TIM_CLK_ENA		: 1;
N		__IO uint32_t s_LFDTX_CLK_ENA	: 1;
X		volatile uint32_t s_LFDTX_CLK_ENA	: 1;
N		__IO uint32_t s_TSPI_CLK_ENA	: 1;
X		volatile uint32_t s_TSPI_CLK_ENA	: 1;
N		__IO uint32_t s_DSPA_CLK_ENA	: 1;
X		volatile uint32_t s_DSPA_CLK_ENA	: 1;
N		__IO uint32_t s_DSPB_CLK_ENA	: 1;
X		volatile uint32_t s_DSPB_CLK_ENA	: 1;
N		__IO uint32_t s_SRAM1_CLK_ENA	: 1;
X		volatile uint32_t s_SRAM1_CLK_ENA	: 1;
N		__IO uint32_t s_SRAM2_CLK_ENA	: 1;
X		volatile uint32_t s_SRAM2_CLK_ENA	: 1;
N		__IO uint32_t s_SRAM3_CLK_ENA	: 1;
X		volatile uint32_t s_SRAM3_CLK_ENA	: 1;
N		__IO uint32_t s_DMAC_CLK_ENA	: 1;
X		volatile uint32_t s_DMAC_CLK_ENA	: 1;
N		__IO uint32_t s_I2C_CLK_ENA		: 1;
X		volatile uint32_t s_I2C_CLK_ENA		: 1;
N		__IO uint32_t s_FLITF_CLK_ENA	: 1;
X		volatile uint32_t s_FLITF_CLK_ENA	: 1;
N		__IO uint32_t s_GPIO_CLK_ENA	: 1;
X		volatile uint32_t s_GPIO_CLK_ENA	: 1;
N		__I uint32_t reserved			: 2;
X		volatile const uint32_t reserved			: 2;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_SLP0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t s_MSPI01_CLK_ENA	: 1;
X		volatile uint32_t s_MSPI01_CLK_ENA	: 1;
N		__IO uint32_t s_MSPI23_CLK_ENA	: 1;
X		volatile uint32_t s_MSPI23_CLK_ENA	: 1;
N		__IO uint32_t s_MSPI45_CLK_ENA	: 1;
X		volatile uint32_t s_MSPI45_CLK_ENA	: 1;
N		__IO uint32_t s_SCB_CLK_ENA		: 1;
X		volatile uint32_t s_SCB_CLK_ENA		: 1;
N		__IO uint32_t s_COR_CLK_ENA		: 1;
X		volatile uint32_t s_COR_CLK_ENA		: 1;
N		__IO uint32_t s_SYS_CLK_ENA		: 1;
X		volatile uint32_t s_SYS_CLK_ENA		: 1;
N		__IO uint32_t s_SIF_CLK_ENA		: 1;
X		volatile uint32_t s_SIF_CLK_ENA		: 1;
N		__IO uint32_t s_SFL_CLK_ENA		: 1;
X		volatile uint32_t s_SFL_CLK_ENA		: 1;
N		__I uint32_t reserved			: 8;
X		volatile const uint32_t reserved			: 8;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_SLP1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t USB_RSTN_CTRL		: 1;
X		volatile uint32_t USB_RSTN_CTRL		: 1;
N		__IO uint32_t WDT_RSTN_CTRL		: 1;
X		volatile uint32_t WDT_RSTN_CTRL		: 1;
N		__IO uint32_t TIM_RSTN_CTRL		: 1;
X		volatile uint32_t TIM_RSTN_CTRL		: 1;
N		__IO uint32_t LFDTX_RSTN_CTRL	: 1;
X		volatile uint32_t LFDTX_RSTN_CTRL	: 1;
N		__IO uint32_t TSPI_RSTN_CTRL	: 1;
X		volatile uint32_t TSPI_RSTN_CTRL	: 1;
N		__IO uint32_t DSPA_RSTN_CTRL	: 1;
X		volatile uint32_t DSPA_RSTN_CTRL	: 1;
N		__IO uint32_t DSPB_RSTN_CTRL	: 1;
X		volatile uint32_t DSPB_RSTN_CTRL	: 1;
N		__IO uint32_t I2C_RSTN_CTRL		: 1;
X		volatile uint32_t I2C_RSTN_CTRL		: 1;
N		__IO uint32_t GPIO_RSTN_CTRL	: 1;
X		volatile uint32_t GPIO_RSTN_CTRL	: 1;
N		__IO uint32_t MSPI_RSTN_CTRL	: 1;
X		volatile uint32_t MSPI_RSTN_CTRL	: 1;
N		__IO uint32_t SIF_RSTN_CTRL		: 1;
X		volatile uint32_t SIF_RSTN_CTRL		: 1;
N		__IO uint32_t SFL_RSTN_CTRL		: 1;
X		volatile uint32_t SFL_RSTN_CTRL		: 1;
N		__I uint32_t reserved			: 4;
X		volatile const uint32_t reserved			: 4;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tRST_CTRL_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t DLY_SLP			: 16;
X		volatile uint32_t DLY_SLP			: 16;
N		__IO uint32_t BYPASS_SLP		: 1;
X		volatile uint32_t BYPASS_SLP		: 1;
N		__IO uint32_t PMUENABLE			: 1;
X		volatile uint32_t PMUENABLE			: 1;
N		__I uint32_t reserved			: 14;
X		volatile const uint32_t reserved			: 14;
N//        	__O uint32_t _VECTKEY			: 16; // Write : 0x05FA NOTE :  !!
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tPMU_CONTROL_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t CCLK_SEL			: 2;
X		volatile uint32_t CCLK_SEL			: 2;
N		__IO uint32_t WDCLK_SEL			: 2;
X		volatile uint32_t WDCLK_SEL			: 2;
N		__IO uint32_t TIMCLK_SEL		: 2;
X		volatile uint32_t TIMCLK_SEL		: 2;
N		__IO uint32_t SSCGOUT_SEL		: 1;
X		volatile uint32_t SSCGOUT_SEL		: 1;
N		__IO uint32_t SSCGOUT2X_SEL		: 1;
X		volatile uint32_t SSCGOUT2X_SEL		: 1;
N		__IO uint32_t TOUCHCLK_SEL		: 2;
X		volatile uint32_t TOUCHCLK_SEL		: 2;
N		__IO uint32_t PLLOUT_SEL		: 3;
X		volatile uint32_t PLLOUT_SEL		: 3;
N		__IO uint32_t SSCGIN_SEL		: 1;
X		volatile uint32_t SSCGIN_SEL		: 1;
N		__I uint32_t reserved			: 2;
X		volatile const uint32_t reserved			: 2;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCLK_SRC_SEL_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t HCLK_DIV			: 3;
X		volatile uint32_t HCLK_DIV			: 3;
N		__IO uint32_t PCLK_DIV			: 2;
X		volatile uint32_t PCLK_DIV			: 2;
N		__IO uint32_t TIMCLK_DIV		: 3;
X		volatile uint32_t TIMCLK_DIV		: 3;
N		__IO uint32_t WDTCLK_DIV		: 3;
X		volatile uint32_t WDTCLK_DIV		: 3;
N		__IO uint32_t SSCGIN_DIV		: 2;
X		volatile uint32_t SSCGIN_DIV		: 2;
N		__IO uint32_t TOUCHCLK_DIV		: 3;
X		volatile uint32_t TOUCHCLK_DIV		: 3;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCLK_DIV_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t ECLK_SEL		: 4;
X		volatile uint32_t ECLK_SEL		: 4;
N		__IO uint32_t ECLK_DIV1		: 3;
X		volatile uint32_t ECLK_DIV1		: 3;
N		__IO uint32_t ECLK_DIV2		: 2;
X		volatile uint32_t ECLK_DIV2		: 2;
N		__IO uint32_t USBPHY_SEL	: 2;
X		volatile uint32_t USBPHY_SEL	: 2;
N		__I uint32_t reserved		: 5;
X		volatile const uint32_t reserved		: 5;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tECLK_CFG_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t PLL_STBY_I	: 1;	// Powerdown Input : (0)Normal Operation, (1)Powerdown Mode
X		volatile uint32_t PLL_STBY_I	: 1;	
N		__IO uint32_t REFDIV		: 3;	// Reference divider control : M = REFDIV[2:0] + 1, M = {1~8}
X		volatile uint32_t REFDIV		: 3;	
N		__IO uint32_t FBDIV			: 6;	// Feedback divider control : N = FBDIV[5:0], N = {5~50}
X		volatile uint32_t FBDIV			: 6;	
N		__IO uint32_t OUTDIV		: 2;	// Output divider control : O = 2*OUTDIV[1:0], O = {1,2,4,8}
X		volatile uint32_t OUTDIV		: 2;	
N		__I uint32_t reserved		: 4;
X		volatile const uint32_t reserved		: 4;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t RSEL			: 3;
X		volatile uint32_t RSEL			: 3;
N		__IO uint32_t ICPSELA		: 1;
X		volatile uint32_t ICPSELA		: 1;
N		__IO uint32_t ICPSELB		: 1;
X		volatile uint32_t ICPSELB		: 1;
N		__IO uint32_t VCOSETUPSEL	: 1;
X		volatile uint32_t VCOSETUPSEL	: 1;
N		__I uint32_t reserved		: 10;
X		volatile const uint32_t reserved		: 10;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t PLL_IE	: 1;
X		volatile uint32_t PLL_IE	: 1;
N		__IO uint32_t PLL_IEV	: 1;
X		volatile uint32_t PLL_IEV	: 1;
N		__IO uint32_t PLL_IBE	: 1;
X		volatile uint32_t PLL_IBE	: 1;
N		__I uint32_t reserved	: 29;
X		volatile const uint32_t reserved	: 29;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_IC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t PLL_INTC		: 1;
X		volatile uint32_t PLL_INTC		: 1;
N		__I uint32_t PLL_MIS		: 1;
X		volatile const uint32_t PLL_MIS		: 1;
N		__I uint32_t PLL_RIS		: 1;
X		volatile const uint32_t PLL_RIS		: 1;
N		__I uint32_t PLL_LOCKED_O	: 1;
X		volatile const uint32_t PLL_LOCKED_O	: 1;
N		__I uint32_t reserved		: 28;
X		volatile const uint32_t reserved		: 28;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_IS_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t OSC_PDB_12M	: 1;
X		volatile uint32_t OSC_PDB_12M	: 1;
N		__IO uint32_t OSC_PDB_40K	: 1;
X		volatile uint32_t OSC_PDB_40K	: 1;
N		__I uint32_t reserved		: 14;
X		volatile const uint32_t reserved		: 14;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_OSC_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t IREF_TST		: 1;
X		volatile uint32_t IREF_TST		: 1;
N		__IO uint32_t OSC_TRIM		: 7;
X		volatile uint32_t OSC_TRIM		: 7;
N		__IO uint32_t LOSC_TRIM		: 4;
X		volatile uint32_t LOSC_TRIM		: 4;
N		__I uint32_t reserved		: 4;
X		volatile const uint32_t reserved		: 4;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_OSC_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t CAL_SEL  		:  4;
X		volatile uint32_t CAL_SEL  		:  4;
N		__I uint32_t VSEL_OUT 		:  1;
X		volatile const uint32_t VSEL_OUT 		:  1;
N		__I uint32_t reserved		: 11;
X		volatile const uint32_t reserved		: 11;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_LDO_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t SSCG_PDB		: 1;
X		volatile uint32_t SSCG_PDB		: 1;
N		__IO uint32_t SSCG_EN		: 1;
X		volatile uint32_t SSCG_EN		: 1;
N		__IO uint32_t SSCG_INIT		: 1;
X		volatile uint32_t SSCG_INIT		: 1;
N		__I uint32_t reserved		: 13;
X		volatile const uint32_t reserved		: 13;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_SSC_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t SSCG_MR		: 3;
X		volatile uint32_t SSCG_MR		: 3;
N		__IO uint32_t SSCG_MF		: 2;
X		volatile uint32_t SSCG_MF		: 2;
N		__IO uint32_t SSCG_FRAC_EN	: 1;
X		volatile uint32_t SSCG_FRAC_EN	: 1;
N		__IO uint32_t SSCG_ICP		: 2;
X		volatile uint32_t SSCG_ICP		: 2;
N		__IO uint32_t SSCG_RSEL		: 2;
X		volatile uint32_t SSCG_RSEL		: 2;
N		__IO uint32_t SSCG_KVC		: 1;
X		volatile uint32_t SSCG_KVC		: 1;
N		__I uint32_t reserved		: 5;
X		volatile const uint32_t reserved		: 5;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_SSC_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t SSCG_SEL_NRST	: 1;
X		volatile uint32_t SSCG_SEL_NRST	: 1;
N		__IO uint32_t SSCG_DIG_RSTN	: 1;
X		volatile uint32_t SSCG_DIG_RSTN	: 1;
N		__IO uint32_t SSCG_DIG_TST	: 1;
X		volatile uint32_t SSCG_DIG_TST	: 1;
N		__I uint32_t SSCG_FLAG		: 1;
X		volatile const uint32_t SSCG_FLAG		: 1;
N		__I uint32_t reserved		: 12;
X		volatile const uint32_t reserved		: 12;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_SSC_TC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t ATOP_DUMMY 	: 8;
X		volatile uint32_t ATOP_DUMMY 	: 8;
N		__I uint32_t reserved 		: 8;
X		volatile const uint32_t reserved 		: 8;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_ANA_DM_t;
N//    __IO uint32_t LGD_ANA_DM;                     //0x001A
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t VBUSVALID			: 1;
X		volatile uint32_t VBUSVALID			: 1;
N		__IO uint32_t WAKEUP			: 1;
X		volatile uint32_t WAKEUP			: 1;
N		__IO uint32_t L1_WAKEUP			: 1;
X		volatile uint32_t L1_WAKEUP			: 1;
N		__IO uint32_t SEL_VBUSVALID		: 1;
X		volatile uint32_t SEL_VBUSVALID		: 1;
N		__IO uint32_t SEL_WAKEUP		: 1;
X		volatile uint32_t SEL_WAKEUP		: 1;
N		__IO uint32_t SEL_L1_WAKEUP		: 1;
X		volatile uint32_t SEL_L1_WAKEUP		: 1;
N		__I uint32_t reserved			: 26;
X		volatile const uint32_t reserved			: 26;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_CTL_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t EXTCTRL_SUSPENDM	: 1;
X		volatile uint32_t EXTCTRL_SUSPENDM	: 1;
N		__IO uint32_t OSCOUTEN			: 1;
X		volatile uint32_t OSCOUTEN			: 1;
N		__IO uint32_t XTLSEL			: 1;
X		volatile uint32_t XTLSEL			: 1;
N		__IO uint32_t PLLALIV			: 1;
X		volatile uint32_t PLLALIV			: 1;
N		__IO uint32_t PONRST			: 1;
X		volatile uint32_t PONRST			: 1;
N		__IO uint32_t OUTCLKSEL			: 1;
X		volatile uint32_t OUTCLKSEL			: 1;
N		__IO uint32_t TA				: 1;
X		volatile uint32_t TA				: 1;
N		__IO uint32_t TB				: 1;
X		volatile uint32_t TB				: 1;
N		__IO uint32_t TC				: 1;
X		volatile uint32_t TC				: 1;
N		__I uint32_t reserved			: 23;
X		volatile const uint32_t reserved			: 23;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_PHY_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t USB_SUSM_INTR_EN		: 1;
X		volatile uint32_t USB_SUSM_INTR_EN		: 1;
N		__IO uint32_t USB_SUSM_INTR_POSNEG	: 1;
X		volatile uint32_t USB_SUSM_INTR_POSNEG	: 1;
N		__IO uint32_t USB_SUSM_INTR_BOTH	: 1;
X		volatile uint32_t USB_SUSM_INTR_BOTH	: 1;
N		__IO uint32_t USB_LPM_INTR_EN		: 1;
X		volatile uint32_t USB_LPM_INTR_EN		: 1;
N		__IO uint32_t USB_LPM_INTR_POSNEG	: 1;
X		volatile uint32_t USB_LPM_INTR_POSNEG	: 1;
N		__IO uint32_t USB_LPM_INTR_BOTH		: 1;
X		volatile uint32_t USB_LPM_INTR_BOTH		: 1;
N		__IO uint32_t USB_IP_INTR_EN		: 1;
X		volatile uint32_t USB_IP_INTR_EN		: 1;
N		__IO uint32_t USB_IP_INTR_INV		: 1;
X		volatile uint32_t USB_IP_INTR_INV		: 1;
N		__I uint32_t reserved				: 24;
X		volatile const uint32_t reserved				: 24;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_ITR_IC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t USB_SUSM_INTC		: 1;
X		volatile uint32_t USB_SUSM_INTC		: 1;
N		__I uint32_t USB_SUSM_MIS		: 1;
X		volatile const uint32_t USB_SUSM_MIS		: 1;
N		__I uint32_t USB_SUSM_RIS		: 1;
X		volatile const uint32_t USB_SUSM_RIS		: 1;
N		__I uint32_t USB_SUSM_RAW		: 1;
X		volatile const uint32_t USB_SUSM_RAW		: 1;
N		__O uint32_t USB_LPM_EN_INTC	: 1;
X		volatile uint32_t USB_LPM_EN_INTC	: 1;
N		__I uint32_t USB_LPM_EN_MIS		: 1;
X		volatile const uint32_t USB_LPM_EN_MIS		: 1;
N		__I uint32_t USB_LPM_EN_RIS		: 1;
X		volatile const uint32_t USB_LPM_EN_RIS		: 1;
N		__I uint32_t USB_LPM_EN_RAW		: 1;
X		volatile const uint32_t USB_LPM_EN_RAW		: 1;
N		__I uint32_t reserved			: 24;
X		volatile const uint32_t reserved			: 24;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_ITR_IS_t;
N
N//typedef union
N//{
N//	struct
N//	{
N//		__IO uint32_t BEN_TST		: 1;
N//		__IO uint32_t REN_TST		: 1;
N//		__IO uint32_t CEN_TST		: 1;
N//		__IO uint32_t IREF_TST		: 1;
N//		__IO uint32_t IREF_TRIM		: 4;
N//		__IO uint32_t BOFF_TRIM		: 3;
N//		__I uint32_t reserved		: 5;
N//		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
N//	} tBit;
N//	__IO uint32_t ulBulk;
N//} tMAIN_BIAS_t;
N//
N//typedef union
N//{
N//	struct
N//	{
N//		__IO uint32_t DCTC_AMUX_EN_LV	: 1;
N//		__IO uint32_t DCTC_LV_MUX0		: 4;
N//		__IO uint32_t DCTC_LV_MUX1		: 4;
N//		__I uint32_t reserved			: 7;
N//		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
N//	} tBit;
N//	__IO uint32_t ulBulk;
N//} tTEST_MUX_t;
N
Ntypedef struct
N{
N	tDEVICE_ID_t DEVICE_ID;
N    __IO uint32_t SYSTEM_INFO;                    //0x0001
X    volatile uint32_t SYSTEM_INFO;                    
N    tCM3_STATUS_t CM3_STATUS;
N    tRST_STATUS_t RST_STATUS;
N    tINTR_I2C_CFG_t INTR_I2C_CFG;
N    tINTR_NMI_CFG_t INTR_NMI_CFG;
N    tSTCALIB_t STCALIB;
N    tCK_ENA_RUN0_t CK_ENA_RUN0;
N    tCK_ENA_RUN1_t CK_ENA_RUN1;
N    tCK_ENA_SLP0_t CK_ENA_SLP0;
N    tCK_ENA_SLP1_t CK_ENA_SLP1;
N    tRST_CTRL_t RST_CTRL;
N    tPMU_CONTROL_t PMU_CONTROL;
N    tCLK_SRC_SEL_t CLK_SRC_SEL;
N    tCLK_DIV_t CLK_DIV;
N    tECLK_CFG_t ECLK_CFG;
N    tUMC_PLL_UC_t UMC_PLL_UC;
N    tUMC_PLL_FC_t UMC_PLL_FC;
N    tUMC_PLL_IC_t UMC_PLL_IC;
N    tUMC_PLL_IS_t UMC_PLL_IS;
N    tLGD_OSC_UC_t LGD_OSC_UC;
N    tLGD_OSC_FC_t LGD_OSC_FC;
N    tLGD_LDO_FC_t LGD_LDO_FC;
N    tLGD_SSC_UC_t LGD_SSC_UC;
N    tLGD_SSC_FC_t LGD_SSC_FC;
N    tLGD_SSC_TC_t LGD_SSC_TC;
N    tLGD_ANA_DM_t LGD_ANA_DM;
N//    __IO uint32_t LGD_ANA_DM;                     //0x001A
N    tUSB_CTL_UC_t USB_CTL_UC;
N    tUSB_PHY_FC_t USB_PHY_FC;
N    tUSB_ITR_IC_t USB_ITR_IC;
N    tUSB_ITR_IS_t USB_ITR_IS;
N//    tMAIN_BIAS_t MAIN_BIAS;
N//    tTEST_MUX_t TEST_MUX;
N	
N} tSCRB_CtrlReg_t;
N
N
N#endif /* __SCRB_H_ */
L 278 "..\..\Hal\system\MFTP.h" 2
N#include "_gpio.h"
L 1 "..\..\Hal\gpio\_gpio.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _gpio.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __GPIO_H_
N#define __GPIO_H_
N
N
N/* ================================================================================ */
N/* ================               GPIO Control Registers           ================ */
N/* ================================================================================ */
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 1;		 
N		__IO uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 1;		 
N		__IO uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 1;		 
N		__IO uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 1;		 
N		__IO uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 1;		 
N		__IO uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 1;		 
N		__IO uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 1;		 
N		__IO uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 1;		 
N		__IO uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 1;		 
N		__IO uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 1;		 
N		__IO uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 1;		 
N		__IO uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 1;		 
N		__IO uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 1;		 
N		__IO uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 1;		 
N		__IO uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 1;		 
N		__IO uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 1;		 
N		__IO uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 1;		 
N		__IO uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 1;		 
N		__IO uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 1;		 
N		__IO uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 1;		 
N		__IO uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 1;		 
N		__IO uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 1;		 
N		__IO uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 1;		 
N		__IO uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 1;		 
N		__IO uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 1;		 
N		__IO uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 1;		 
N		__IO uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 1;		 
N		__IO uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 1;		 
N		__IO uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 1;		 
N		__IO uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 1;		 
N		__IO uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 1;		 
N		__IO uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 1;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_PIN_0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 1;		 
N		__IO uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 1;		 
N		__IO uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 1;		 
N		__IO uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 1;		 
N		__IO uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 1;		 
N		__IO uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 1;		 
N		__IO uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 1;		 
N		__IO uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 1;		 
N		__IO uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 1;		 
N		__IO uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 1;		 
N		__IO uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 1;		 
N		__IO uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 1;		 
N		__IO uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 1;		 
N		__IO uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 1;		 
N		__IO uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 1;		 
N		__IO uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 1;		 
N		__IO uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 1;		 
N		__IO uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 1;		 
N		/*
N		 * Serial Flash SPI Pin
N		 */
N//		__I uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 10;
N		__I uint32_t RESERVED	: 14;
X		volatile const uint32_t RESERVED	: 14;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_PIN_1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 1;		 
N		__IO uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 1;		 
N		__IO uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 1;		 
N		__IO uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 1;		 
N		__IO uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 1;		 
N		__IO uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 1;		 
N		__IO uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 1;		 
N		__IO uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 1;		 
N		__IO uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 1;		 
N		__IO uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 1;		 
N		__IO uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 1;		 
N		__IO uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 1;		 
N		__IO uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 1;		 
N		__IO uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 1;		 
N		__IO uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 1;		 
N		__IO uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 1;		 
N		__IO uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 1;		 
N		__IO uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 1;		 
N		__IO uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 1;		 
N		__IO uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 1;		 
N		__IO uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 1;		 
N		__IO uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 1;		 
N		__IO uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 1;		 
N		__IO uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 1;		 
N		__IO uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 1;		 
N		__IO uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 1;		 
N		__I uint32_t RESERVED	: 6;
X		volatile const uint32_t RESERVED	: 6;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_EXTI_0_IO_t;
N
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile const uint32_t GPA00		: 1;		 
N		__I uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile const uint32_t GPA01		: 1;		 
N		__I uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile const uint32_t GPA02		: 1;		 
N		__I uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile const uint32_t GPA03		: 1;		 
N		__I uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile const uint32_t GPA04		: 1;		 
N		__I uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile const uint32_t GPA05		: 1;		 
N		__I uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile const uint32_t GPA06		: 1;		 
N		__I uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile const uint32_t GPA07		: 1;		 
N		__I uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile const uint32_t GPA08		: 1;		 
N		__I uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile const uint32_t GPA09		: 1;		 
N		__I uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile const uint32_t GPA10		: 1;		 
N		__I uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile const uint32_t GPA11		: 1;		 
N		__I uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile const uint32_t GPA24		: 1;		 
N		__I uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile const uint32_t GPA25		: 1;		 
N		__I uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile const uint32_t GPA26		: 1;		 
N		__I uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile const uint32_t GPA27		: 1;		 
N		__I uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile const uint32_t GPA28		: 1;		 
N		__I uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile const uint32_t GPA29		: 1;		 
N		__I uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile const uint32_t GPA30		: 1;		 
N		__I uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile const uint32_t GPA31		: 1;		 
N		__I uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile const uint32_t GPA32		: 1;		 
N		__I uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile const uint32_t GPA33		: 1;		 
N		__I uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile const uint32_t GPA34		: 1;		 
N		__I uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile const uint32_t GPA35		: 1;		 
N		__I uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile const uint32_t GPA36		: 1;		 
N		__I uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile const uint32_t GPA37		: 1;		 
N		__I uint32_t RESERVED	: 6;
X		volatile const uint32_t RESERVED	: 6;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tGPIO_EXTI_0_I_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 1;		 
N		__O uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 1;		 
N		__O uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 1;		 
N		__O uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 1;		 
N		__O uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 1;		 
N		__O uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 1;		 
N		__O uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 1;		 
N		__O uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 1;		 
N		__O uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 1;		 
N		__O uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 1;		 
N		__O uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 1;		 
N		__O uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 1;		 
N		__O uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 1;		 
N		__O uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 1;		 
N		__O uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 1;		 
N		__O uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 1;		 
N		__O uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 1;		 
N		__O uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 1;		 
N		__O uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 1;		 
N		__O uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 1;		 
N		__O uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 1;		 
N		__O uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 1;		 
N		__O uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 1;		 
N		__O uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 1;		 
N		__O uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 1;		 
N		__O uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 1;		 
N		__I uint32_t RESERVED	: 6;
X		volatile const uint32_t RESERVED	: 6;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tGPIO_EXTI_0_O_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 1;		 
N		__IO uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 1;		 
N		__IO uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 1;		 
N		__IO uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 1;		 
N		__IO uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 1;		 
N		__IO uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 1;		 
N		__IO uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 1;		 
N		__IO uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 1;		 
N		__IO uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 1;		 
N		__IO uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 1;		 
N		__IO uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 1;		 
N		__IO uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 1;		 
N		__IO uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 1;		 
N		__IO uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 1;		 
N		__IO uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 1;		 
N		__IO uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 1;		 
N		__IO uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 1;		 
N		__IO uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 1;		 
N		__IO uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 1;		 
N		__IO uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 1;		 
N		__IO uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 1;		 
N		__IO uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 1;		 
N		__IO uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 1;		 
N		__IO uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 1;		 
N//		__I uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 4;
N		__I uint32_t RESERVED	: 8;
X		volatile const uint32_t RESERVED	: 8;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_EXTI_1_IO_t;
N
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile const uint32_t GPA12		: 1;		 
N		__I uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile const uint32_t GPA13		: 1;		 
N		__I uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile const uint32_t GPA14		: 1;		 
N		__I uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile const uint32_t GPA15		: 1;		 
N		__I uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile const uint32_t GPA16		: 1;		 
N		__I uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile const uint32_t GPA17		: 1;		 
N		__I uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile const uint32_t GPA18		: 1;		 
N		__I uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile const uint32_t GPA19		: 1;		 
N		__I uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile const uint32_t GPA20		: 1;		 
N		__I uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile const uint32_t GPA21		: 1;		 
N		__I uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile const uint32_t GPA22		: 1;		 
N		__I uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile const uint32_t GPA23		: 1;		 
N		__I uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile const uint32_t GPB00		: 1;		 
N		__I uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile const uint32_t GPB01		: 1;		 
N		__I uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile const uint32_t GPB02		: 1;		 
N		__I uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile const uint32_t GPB03		: 1;		 
N		__I uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile const uint32_t GPB04		: 1;		 
N		__I uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile const uint32_t GPB05		: 1;		 
N		__I uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile const uint32_t GPB06		: 1;		 
N		__I uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile const uint32_t GPB07		: 1;		 
N		__I uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile const uint32_t GPB08		: 1;		 
N		__I uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile const uint32_t GPB09		: 1;		 
N		__I uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile const uint32_t GPB10		: 1;		 
N		__I uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile const uint32_t GPB11		: 1;		 
N//		__I uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 4;
N		__I uint32_t RESERVED	: 8;
X		volatile const uint32_t RESERVED	: 8;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tGPIO_EXTI_1_I_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 1;		 
N		__O uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 1;		 
N		__O uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 1;		 
N		__O uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 1;		 
N		__O uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 1;		 
N		__O uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 1;		 
N		__O uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 1;		 
N		__O uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 1;		 
N		__O uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 1;		 
N		__O uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 1;		 
N		__O uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 1;		 
N		__O uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 1;		 
N		__O uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 1;		 
N		__O uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 1;		 
N		__O uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 1;		 
N		__O uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 1;		 
N		__O uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 1;		 
N		__O uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 1;		 
N		__O uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 1;		 
N		__O uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 1;		 
N		__O uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 1;		 
N		__O uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 1;		 
N		__O uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 1;		 
N		__O uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 1;		 
N//		__O uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 4;
N		__I uint32_t RESERVED	: 8;
X		volatile const uint32_t RESERVED	: 8;
N	} tBit;
N	__O uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_EXTI_1_O_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA00		: 2;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 2;		 
N		__IO uint32_t GPA01		: 2;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 2;		 
N		__IO uint32_t GPA02		: 2;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 2;		 
N		__IO uint32_t GPA03		: 2;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 2;		 
N		__IO uint32_t GPA04		: 2;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 2;		 
N		__IO uint32_t GPA05		: 2;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 2;		 
N		__IO uint32_t GPA06		: 2;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 2;		 
N		__IO uint32_t GPA07		: 2;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 2;		 
N		__IO uint32_t GPA08		: 2;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 2;		 
N		__IO uint32_t GPA09		: 2;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 2;		 
N		__IO uint32_t GPA10		: 2;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 2;		 
N		__IO uint32_t GPA11		: 2;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 2;		 
N		__IO uint32_t GPA12		: 2;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 2;		 
N		__IO uint32_t GPA13		: 2;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 2;		 
N		__IO uint32_t GPA14		: 2;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 2;		 
N		__IO uint32_t GPA15		: 2;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 2;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA16		: 2;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 2;		 
N		__IO uint32_t GPA17		: 2;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 2;		 
N		__IO uint32_t GPA18		: 2;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 2;		 
N		__IO uint32_t GPA19		: 2;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 2;		 
N		__IO uint32_t GPA20		: 2;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 2;		 
N		__IO uint32_t GPA21		: 2;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 2;		 
N		__IO uint32_t GPA22		: 2;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 2;		 
N		__IO uint32_t GPA23		: 2;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 2;		 
N		__IO uint32_t GPA24		: 2;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 2;		 
N		__IO uint32_t GPA25		: 2;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 2;		 
N		__IO uint32_t GPA26		: 2;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 2;		 
N		__IO uint32_t GPA27		: 2;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 2;		 
N		__IO uint32_t GPA28		: 2;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 2;		 
N		__IO uint32_t GPA29		: 2;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 2;		 
N		__IO uint32_t GPA30		: 2;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 2;		 
N		__IO uint32_t GPA31		: 2;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 2;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA32		: 2;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 2;		 
N		__IO uint32_t GPA33		: 2;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 2;		 
N		__IO uint32_t GPA34		: 2;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 2;		 
N		__IO uint32_t GPA35		: 2;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 2;		 
N		__IO uint32_t GPA36		: 2;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 2;		 
N		__IO uint32_t GPA37		: 2;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 2;		 
N		__IO uint32_t GPB00		: 2;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 2;		 
N		__IO uint32_t GPB01		: 2;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 2;		 
N		__IO uint32_t GPB02		: 2;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 2;		 
N		__IO uint32_t GPB03		: 2;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 2;		 
N		__IO uint32_t GPB04		: 2;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 2;		 
N		__IO uint32_t GPB05		: 2;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 2;		 
N		__IO uint32_t GPB06		: 2;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 2;		 
N		__IO uint32_t GPB07		: 2;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 2;		 
N		__IO uint32_t GPB08		: 2;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 2;		 
N		__IO uint32_t GPB09		: 2;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 2;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_2_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPB10		: 2;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 2;		 
N		__IO uint32_t GPB11		: 2;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 2;		 
N//		__I uint32_t GPB12		: 2;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 2;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 2;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 2;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 20;
N		__I uint32_t RESERVED	: 28;
X		volatile const uint32_t RESERVED	: 28;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_3_t;
N
Ntypedef struct
N{
N	/*
N	 * When AFIO is GPIO Mode, observe the external input and control the internal output value
N	 * At Read operation : Observe the external input value
N	 * At Write operation : Control the internal output value (0:Low, 1:High)
N	 */
N	tGPIO_PIN_0_t tGPIO_DATA_0;
N	tGPIO_PIN_1_t tGPIO_DATA_1;
N	/*
N	 * When AFIO is GPIO Mode, configuration the input/output of GPIO Pins
N	 * 0 : Set as Input
N	 * 1 : Set as Output
N	 */
N	tGPIO_PIN_0_t tGPIO_DIR_0;
N	tGPIO_PIN_1_t tGPIO_DIR_1;
N	/*
N	 * Open Drain Control
N	 * 0 : Disable
N	 * 1 : Enable
N	 */
N	tGPIO_PIN_0_t tGPIO_OD_0;
N	tGPIO_PIN_1_t tGPIO_OD_1;
N	/*
N	 * Control the Pull-Up function
N	 * 0 : Disable Pull-Up function
N	 * 1 : Enable Pull-Up function
N	 */
N	tGPIO_PIN_0_t tGPIO_PU_0;
N	tGPIO_PIN_1_t tGPIO_PU_1;
N	/*
N	 * Control the Pull-Down function
N	 * 0 : Disable Pull-Down function
N	 * 1 : Enable Pull-Down function
N	 */
N	tGPIO_PIN_0_t tGPIO_PD_0;
N	tGPIO_PIN_1_t tGPIO_PD_1;
N	/*
N	 * GPIO interrupt Detection control
N	 * 0 : Edge Detection
N	 * 1 : Level Detection
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IS;
N	/*
N	 * GPIO interrupt edge control
N	 * 0 : Single Edge
N	 * 1 : Both Edge
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IBE;
N	/*
N	 * GPIO interrupt direction control
N	 * 0 : Negative Edge / Low Level
N	 * 1 : Positive Edge / High Level
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IEV;
N	/*
N	 * Set the Interrupt operation
N	 * 0 : Disable Interrupt
N	 * 1 : Enable Interrupt
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IE;
N	/*
N	 * GPIO raw interrupt status from
N	 */
N	tGPIO_EXTI_0_I_t tGPIO_EXTI0_RIS;
N	/*
N	 * GPIO masked interrupt status from
N	 */
N	tGPIO_EXTI_0_I_t tGPIO_EXTI0_MIS;
N	/*
N	 * GPIO interrupt clear register
N	 */
N	tGPIO_EXTI_0_O_t tGPIO_EXTI0_INTC;
N
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IS;
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IBE;
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IEV;
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IE;
N	tGPIO_EXTI_1_I_t tGPIO_EXTI1_RIS;
N	tGPIO_EXTI_1_I_t tGPIO_EXTI1_MIS;
N	tGPIO_EXTI_1_O_t tGPIO_EXTI1_INTC;
N
N	tGPIO_AFIO_0_t tGPIO_AFIO_0;
N	tGPIO_AFIO_1_t tGPIO_AFIO_1;
N	tGPIO_AFIO_2_t tGPIO_AFIO_2;
N	tGPIO_AFIO_3_t tGPIO_AFIO_3;
N
N	tGPIO_PIN_0_t tGPIO_IE0;
N	tGPIO_PIN_1_t tGPIO_IE1;
N
N	tGPIO_PIN_0_t tGPIO_P2_0;
N	tGPIO_PIN_1_t tGPIO_P2_1;
N
N	tGPIO_PIN_0_t tGPIO_P1_0;
N	tGPIO_PIN_1_t tGPIO_P1_1;
N
N	tGPIO_PIN_0_t tGPIO_SMT_0;
N	tGPIO_PIN_1_t tGPIO_SMT_1;
N
N} tGPIO_CtrlReg_t;
N
N
N#endif /* __GPIO_H_ */
L 279 "..\..\Hal\system\MFTP.h" 2
N#include "_timer.h"
L 1 "..\..\Hal\timer\_timer.h" 1
N
N/****************************************************************************************************//**
N * @file     timer.h
N *
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File for
N *           default TIGER Device Series
N *
N * @version  Vrev.B
N * @date     19. April 2013
N *
N * @note     Generated with SVDConv V2.73b  on Friday, 19.04.2013 19:56:29
N *           from CMSIS SVD File 'LDC1004A_TIGER_svd.xml' Version rev.B,
N *           created on Monday, 08.04.2013 08:30:30, last modified on Friday, 19.04.2013 10:55:20
N *
N * @par      ARM Limited (ARM) is supplying this software for use with Cortex-M
N *           processor based microcontroller, but can be equally used for other
N *           suitable processor architectures. This file can be freely distributed.
N *           Modifications to this file shall be clearly marked.
N *           
N *           THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N *           OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N *           MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N *           ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N *           CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
N *
N *******************************************************************************************************/
N
N
N/* ================================================================================ */
N/* ================                     TIMER                      ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  Flash Control Register
N */
N
N
Nextern uint8_t TMA0_cnt;
Nextern uint8_t TMB0_cnt;
Nextern uint8_t TMA1_cnt;
Nextern uint8_t TMB1_cnt;
N
Nextern uint8_t mode;
N
N
N
N
Ntypedef struct
N{
N    //-----------------------------------
N    //              Timer0
N    //-----------------------------------
N    union {   // 0x00 : Timer0
N	    __IO uint32_t	Timer0_LoadCount_CR;        // Timer0 Load Count CR 
X	    volatile uint32_t	Timer0_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer0_LoadCount      : 32; // Timer0 Load Count 
X          volatile uint32_t Timer0_LoadCount      : 32; 
N      } Timer0_LoadCount_R_b;
N    } ;
N
N    union {   // 0x04 : Timer0
N	    __IO uint32_t	Timer0_CurrentValue_SR;     // Timer0 CurrentValue SR
X	    volatile uint32_t	Timer0_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer0_CurrentValue   : 32; // Timer0 CurrentValue 
X          volatile uint32_t Timer0_CurrentValue   : 32; 
N      } Timer0_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x08 : Timer0
N	    __IO uint32_t	Timer0_CR;                  // Timer0 CR
X	    volatile uint32_t	Timer0_CR;                  
N
N      struct {
N          __IO uint32_t Timer0_En             : 1;  // Timer0 Enable 
X          volatile uint32_t Timer0_En             : 1;  
N          __IO uint32_t Timer0_Mode           : 1;  // Timer0 Mode         
X          volatile uint32_t Timer0_Mode           : 1;  
N          __IO uint32_t Timer0_InterruptMask  : 1;  // Timer0 InterruptMask
X          volatile uint32_t Timer0_InterruptMask  : 1;  
N      } Timer0_CR_b;
N    } ;
N
N    union {   // 0x0C : Timer0
N	    __IO uint32_t	Timer0_EOI_SR;              // Timer0 End of Interrupt SR
X	    volatile uint32_t	Timer0_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer0_EOI            : 1;  // Timer0 EOI 
X          volatile uint32_t Timer0_EOI            : 1;  
N      } Timer0_EOI_SR_b;
N    } ;
N
N    union {   // 0x10 : Timer0
N	    __IO uint32_t	Timer0_Int_SR;              // Timer0 Interrupt SR
X	    volatile uint32_t	Timer0_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer0_Int            : 1;  // Timer0 Interrupt
X          volatile uint32_t Timer0_Int            : 1;  
N      } Timer0_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer1
N    //-----------------------------------
N    union {   // 0x14 : Timer1
N	    __IO uint32_t	Timer1_LoadCount_CR;        // Timer1 Load Count CR 
X	    volatile uint32_t	Timer1_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer1_LoadCount      : 32; // Timer1 Load Count 
X          volatile uint32_t Timer1_LoadCount      : 32; 
N      } Timer1_LoadCount_R_b;
N    } ;
N
N    union {   // 0x18 : Timer1
N	    __IO uint32_t	Timer1_CurrentValue_SR;     // Timer1 CurrentValue SR
X	    volatile uint32_t	Timer1_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer1_CurrentValue   : 32; // Timer1 CurrentValue 
X          volatile uint32_t Timer1_CurrentValue   : 32; 
N      } Timer1_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x1C : Timer1
N	    __IO uint32_t	Timer1_CR;                  // Timer1 CR
X	    volatile uint32_t	Timer1_CR;                  
N
N      struct {
N          __IO uint32_t Timer1_En             : 1;  // Timer1 Enable 
X          volatile uint32_t Timer1_En             : 1;  
N          __IO uint32_t Timer1_Mode           : 1;  // Timer1 Mode         
X          volatile uint32_t Timer1_Mode           : 1;  
N          __IO uint32_t Timer1_InterruptMask  : 1;  // Timer1 InterruptMask
X          volatile uint32_t Timer1_InterruptMask  : 1;  
N      } Timer1_CR_b;
N    } ;
N
N    union {   // 0x20 : Timer1
N	    __IO uint32_t	Timer1_EOI_SR;              // Timer1 End of Interrupt SR
X	    volatile uint32_t	Timer1_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer1_EOI            : 1;  // Timer1 EOI 
X          volatile uint32_t Timer1_EOI            : 1;  
N      } Timer1_EOI_SR_b;
N    } ;
N
N    union {   // 0x24 : Timer1
N	    __IO uint32_t	Timer1_Int_SR;              // Timer1 Interrupt SR
X	    volatile uint32_t	Timer1_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer1_Int            : 1;  // Timer1 Interrupt
X          volatile uint32_t Timer1_Int            : 1;  
N      } Timer1_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer2
N    //-----------------------------------
N    union {   // 0x28 : Timer2
N	    __IO uint32_t	Timer2_LoadCount_CR;        // Timer2 Load Count CR 
X	    volatile uint32_t	Timer2_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer2_LoadCount      : 32; // Timer2 Load Count 
X          volatile uint32_t Timer2_LoadCount      : 32; 
N      } Timer2_LoadCount_R_b;
N    } ;
N
N    union {   // 0x2C : Timer2
N	    __IO uint32_t	Timer2_CurrentValue_SR;     // Timer2 CurrentValue SR
X	    volatile uint32_t	Timer2_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer2_CurrentValue   : 32; // Timer2 CurrentValue 
X          volatile uint32_t Timer2_CurrentValue   : 32; 
N      } Timer2_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x30 : Timer2
N	    __IO uint32_t	Timer2_CR;                  // Timer2 CR
X	    volatile uint32_t	Timer2_CR;                  
N
N      struct {
N          __IO uint32_t Timer2_En             : 1;  // Timer2 Enable 
X          volatile uint32_t Timer2_En             : 1;  
N          __IO uint32_t Timer2_Mode           : 1;  // Timer2 Mode         
X          volatile uint32_t Timer2_Mode           : 1;  
N          __IO uint32_t Timer2_InterruptMask  : 1;  // Timer2 InterruptMask
X          volatile uint32_t Timer2_InterruptMask  : 1;  
N      } Timer2_CR_b;
N    } ;
N
N    union {   // 0x34 : Timer2
N	    __IO uint32_t	Timer2_EOI_SR;              // Timer2 End of Interrupt SR
X	    volatile uint32_t	Timer2_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer2_EOI            : 1;  // Timer2 EOI 
X          volatile uint32_t Timer2_EOI            : 1;  
N      } Timer2_EOI_SR_b;
N    } ;
N
N    union {   // 0x38 : Timer2
N	    __IO uint32_t	Timer2_Int_SR;              // Timer2 Interrupt SR
X	    volatile uint32_t	Timer2_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer2_Int            : 1;  // Timer2 Interrupt
X          volatile uint32_t Timer2_Int            : 1;  
N      } Timer2_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer3
N    //-----------------------------------
N    union {   // 0x3C : Timer3
N	    __IO uint32_t	Timer3_LoadCount_CR;        // Timer3 Load Count CR 
X	    volatile uint32_t	Timer3_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer3_LoadCount      : 32; // Timer3 Load Count 
X          volatile uint32_t Timer3_LoadCount      : 32; 
N      } Timer3_LoadCount_R_b;
N    } ;
N
N    union {   // 0x40 : Timer3
N	    __IO uint32_t	Timer3_CurrentValue_SR;     // Timer3 CurrentValue SR
X	    volatile uint32_t	Timer3_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer3_CurrentValue   : 32; // Timer3 CurrentValue 
X          volatile uint32_t Timer3_CurrentValue   : 32; 
N      } Timer3_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x44 : Timer3
N	    __IO uint32_t	Timer3_CR;                  // Timer3 CR
X	    volatile uint32_t	Timer3_CR;                  
N
N      struct {
N          __IO uint32_t Timer3_En             : 1;  // Timer3 Enable 
X          volatile uint32_t Timer3_En             : 1;  
N          __IO uint32_t Timer3_Mode           : 1;  // Timer3 Mode         
X          volatile uint32_t Timer3_Mode           : 1;  
N          __IO uint32_t Timer3_InterruptMask  : 1;  // Timer3 InterruptMask
X          volatile uint32_t Timer3_InterruptMask  : 1;  
N      } Timer3_CR_b;
N    } ;
N
N    union {   // 0x48 : Timer3
N	    __IO uint32_t	Timer3_EOI_SR;              // Timer3 End of Interrupt SR
X	    volatile uint32_t	Timer3_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer3_EOI            : 1;  // Timer3 EOI 
X          volatile uint32_t Timer3_EOI            : 1;  
N      } Timer3_EOI_SR_b;
N    } ;
N
N    union {   // 0x4C : Timer3
N	    __IO uint32_t	Timer3_Int_SR;              // Timer3 Interrupt SR
X	    volatile uint32_t	Timer3_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer3_Int            : 1;  // Timer3 Interrupt
X          volatile uint32_t Timer3_Int            : 1;  
N      } Timer3_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer4
N    //-----------------------------------
N    union {   // 0x50 : Timer4
N	    __IO uint32_t	Timer4_LoadCount_CR;        // Timer4 Load Count CR 
X	    volatile uint32_t	Timer4_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer4_LoadCount      : 32; // Timer4 Load Count 
X          volatile uint32_t Timer4_LoadCount      : 32; 
N      } Timer4_LoadCount_R_b;
N    } ;
N
N    union {   // 0x54 : Timer4
N	    __IO uint32_t	Timer4_CurrentValue_SR;     // Timer4 CurrentValue SR
X	    volatile uint32_t	Timer4_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer4_CurrentValue   : 32; // Timer4 CurrentValue 
X          volatile uint32_t Timer4_CurrentValue   : 32; 
N      } Timer4_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x58 : Timer4
N	    __IO uint32_t	Timer4_CR;                  // Timer4 CR
X	    volatile uint32_t	Timer4_CR;                  
N
N      struct {
N          __IO uint32_t Timer4_En             : 1;  // Timer4 Enable 
X          volatile uint32_t Timer4_En             : 1;  
N          __IO uint32_t Timer4_Mode           : 1;  // Timer4 Mode         
X          volatile uint32_t Timer4_Mode           : 1;  
N          __IO uint32_t Timer4_InterruptMask  : 1;  // Timer4 InterruptMask
X          volatile uint32_t Timer4_InterruptMask  : 1;  
N      } Timer4_CR_b;
N    } ;
N
N    union {   // 0x5C : Timer4
N	    __IO uint32_t	Timer4_EOI_SR;              // Timer4 End of Interrupt SR
X	    volatile uint32_t	Timer4_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer4_EOI            : 1;  // Timer4 EOI 
X          volatile uint32_t Timer4_EOI            : 1;  
N      } Timer4_EOI_SR_b;
N    } ;
N
N    union {   // 0x60 : Timer4
N	    __IO uint32_t	Timer4_Int_SR;              // Timer4 Interrupt SR
X	    volatile uint32_t	Timer4_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer4_Int            : 1;  // Timer4 Interrupt
X          volatile uint32_t Timer4_Int            : 1;  
N      } Timer4_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer5
N    //-----------------------------------
N    union {   // 0x64 : Timer5
N	    __IO uint32_t	Timer5_LoadCount_CR;        // Timer5 Load Count CR 
X	    volatile uint32_t	Timer5_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer5_LoadCount      : 32; // Timer5 Load Count 
X          volatile uint32_t Timer5_LoadCount      : 32; 
N      } Timer5_LoadCount_R_b;
N    } ;
N
N    union {   // 0x68 : Timer5
N	    __IO uint32_t	Timer5_CurrentValue_SR;     // Timer5 CurrentValue SR
X	    volatile uint32_t	Timer5_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer5_CurrentValue   : 32; // Timer5 CurrentValue 
X          volatile uint32_t Timer5_CurrentValue   : 32; 
N      } Timer5_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x6C : Timer5
N	    __IO uint32_t	Timer5_CR;                  // Timer5 CR
X	    volatile uint32_t	Timer5_CR;                  
N
N      struct {
N          __IO uint32_t Timer5_En             : 1;  // Timer5 Enable 
X          volatile uint32_t Timer5_En             : 1;  
N          __IO uint32_t Timer5_Mode           : 1;  // Timer5 Mode         
X          volatile uint32_t Timer5_Mode           : 1;  
N          __IO uint32_t Timer5_InterruptMask  : 1;  // Timer5 InterruptMask
X          volatile uint32_t Timer5_InterruptMask  : 1;  
N      } Timer5_CR_b;
N    } ;
N
N    union {   // 0x70 : Timer5
N	    __IO uint32_t	Timer5_EOI_SR;              // Timer5 End of Interrupt SR
X	    volatile uint32_t	Timer5_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer5_EOI            : 1;  // Timer5 EOI 
X          volatile uint32_t Timer5_EOI            : 1;  
N      } Timer5_EOI_SR_b;
N    } ;
N
N    union {   // 0x74 : Timer5
N	    __IO uint32_t	Timer5_Int_SR;              // Timer5 Interrupt SR
X	    volatile uint32_t	Timer5_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer5_Int            : 1;  // Timer5 Interrupt
X          volatile uint32_t Timer5_Int            : 1;  
N      } Timer5_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer6
N    //-----------------------------------
N    union {   // 0x78 : Timer6
N	    __IO uint32_t	Timer6_LoadCount_CR;        // Timer6 Load Count CR 
X	    volatile uint32_t	Timer6_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer6_LoadCount      : 32; // Timer6 Load Count 
X          volatile uint32_t Timer6_LoadCount      : 32; 
N      } Timer6_LoadCount_R_b;
N    } ;
N
N    union {   // 0x7C : Timer6
N	    __IO uint32_t	Timer6_CurrentValue_SR;     // Timer6 CurrentValue SR
X	    volatile uint32_t	Timer6_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer6_CurrentValue   : 32; // Timer6 CurrentValue 
X          volatile uint32_t Timer6_CurrentValue   : 32; 
N      } Timer6_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x80 : Timer6
N	    __IO uint32_t	Timer6_CR;                  // Timer6 CR
X	    volatile uint32_t	Timer6_CR;                  
N
N      struct {
N          __IO uint32_t Timer6_En             : 1;  // Timer6 Enable 
X          volatile uint32_t Timer6_En             : 1;  
N          __IO uint32_t Timer6_Mode           : 1;  // Timer6 Mode         
X          volatile uint32_t Timer6_Mode           : 1;  
N          __IO uint32_t Timer6_InterruptMask  : 1;  // Timer6 InterruptMask
X          volatile uint32_t Timer6_InterruptMask  : 1;  
N      } Timer6_CR_b;
N    } ;
N
N    union {   // 0x84 : Timer6
N	    __IO uint32_t	Timer6_EOI_SR;              // Timer6 End of Interrupt SR
X	    volatile uint32_t	Timer6_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer6_EOI            : 1;  // Timer6 EOI 
X          volatile uint32_t Timer6_EOI            : 1;  
N      } Timer6_EOI_SR_b;
N    } ;
N
N    union {   // 0x88 : Timer6
N	    __IO uint32_t	Timer6_Int_SR;              // Timer6 Interrupt SR
X	    volatile uint32_t	Timer6_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer6_Int            : 1;  // Timer6 Interrupt
X          volatile uint32_t Timer6_Int            : 1;  
N      } Timer6_Int_SR_b;
N    } ;
N
N    
N    //-----------------------------------
N    //              Timer7
N    //-----------------------------------
N    union {   // 0x8C : Timer7
N	    __IO uint32_t	Timer7_LoadCount_CR;        // Timer7 Load Count CR 
X	    volatile uint32_t	Timer7_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer7_LoadCount      : 32; // Timer7 Load Count 
X          volatile uint32_t Timer7_LoadCount      : 32; 
N      } Timer7_LoadCount_R_b;
N    } ;
N
N    union {   // 0x90 : Timer7
N	    __IO uint32_t	Timer7_CurrentValue_SR;     // Timer7 CurrentValue SR
X	    volatile uint32_t	Timer7_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer7_CurrentValue   : 32; // Timer7 CurrentValue 
X          volatile uint32_t Timer7_CurrentValue   : 32; 
N      } Timer7_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x94 : Timer7
N	    __IO uint32_t	Timer7_CR;                  // Timer7 CR
X	    volatile uint32_t	Timer7_CR;                  
N
N      struct {
N          __IO uint32_t Timer7_En             : 1;  // Timer7 Enable 
X          volatile uint32_t Timer7_En             : 1;  
N          __IO uint32_t Timer7_Mode           : 1;  // Timer7 Mode         
X          volatile uint32_t Timer7_Mode           : 1;  
N          __IO uint32_t Timer7_InterruptMask  : 1;  // Timer7 InterruptMask
X          volatile uint32_t Timer7_InterruptMask  : 1;  
N      } Timer7_CR_b;
N    } ;
N
N    union {   // 0x98 : Timer7
N	    __IO uint32_t	Timer7_EOI_SR;              // Timer7 End of Interrupt SR
X	    volatile uint32_t	Timer7_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer7_EOI            : 1;  // Timer7 EOI 
X          volatile uint32_t Timer7_EOI            : 1;  
N      } Timer7_EOI_SR_b;
N    } ;
N
N    union {   // 0x9C : Timer7
N	    __IO uint32_t	Timer7_Int_SR;              // Timer7 Interrupt SR
X	    volatile uint32_t	Timer7_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer7_Int            : 1;  // Timer7 Interrupt
X          volatile uint32_t Timer7_Int            : 1;  
N      } Timer7_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //    Global Status Register 
N    //-----------------------------------
N    union {   // 0xA0 : Global Status Register 
N	    __IO uint32_t	Timers_Int_SR;              // Timers Interrupt SR
X	    volatile uint32_t	Timers_Int_SR;              
N
N      struct {
N          __IO uint32_t Timers_Int            : 8;  // Timers Interrupt
X          volatile uint32_t Timers_Int            : 8;  
N      } Timers_Int_SR_b;
N    } ;
N
N    union {   // 0xA4 : Global Status Register 
N	    __IO uint32_t	Timers_EOI_SR;              // Timers End of Interrupt SR
X	    volatile uint32_t	Timers_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timers_EOI            : 8;  // Timers EOI
X          volatile uint32_t Timers_EOI            : 8;  
N      } Timers_EOI_SR_b;
N    } ;
N
N    union {   // 0xA8 : Global Status Register 
N	    __IO uint32_t	Timers_RawInt_SR;           // Timers Raw Interrupt SR
X	    volatile uint32_t	Timers_RawInt_SR;           
N
N      struct {
N          __IO uint32_t Timers_RawInt         : 8;  // Timers Raw Interrupt 
X          volatile uint32_t Timers_RawInt         : 8;  
N      } Timers_RawInt_SR_b;
N    } ;
N
N    union {   // 0xAC : Global Status Register 
N	    __IO uint32_t	Timers_Comp_Version_SR;     // Current Verion number of the timers component SR
X	    volatile uint32_t	Timers_Comp_Version_SR;     
N
N      struct {
N          __IO uint32_t Timers_Comp_Version   : 32; // Current Verion number of the timers component 
X          volatile uint32_t Timers_Comp_Version   : 32; 
N      } Timers_Comp_Version_SR_b;
N    } ;
N
N
N}tTIMER_CtrlReg_t;
N
N
N
N
N//typedef struct
N//{
N////// A
N//    union {
N//	    __IO uint32_t	TCLR0A;			     //	 Timer0 A Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0AClr : 1; // Timer0 A Clear 
N//      } TCLR0A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON0A;			     //	 Timer0 A Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0AEn     : 1; // Timer0 A Enable
N//          __IO uint32_t Tm0AIntrEn : 1; // Timer0 A Interrupt Enable
N//          __IO uint32_t Tm0AClkSel : 2; // Timer0 A Clock Select
N//          __IO uint32_t Tm0AMode   : 2; // Timer0 A Mode Select
N//          __IO uint32_t Tm0ASize   : 2; // Timer0 A Counter Size Select
N//      } TCON0A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH0A;			     //	 Timer0 A Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0AWIDTH     : 32; // Timer0 A Period Width
N//      } TWIDTH0A_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD0A;			     //	 Timer0 A Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm0ACntLoad   : 32; // Timer0 A Counting Value
N//      } LOAD0A_b;
N//    } ;
N/////// B
N//    union {
N//	    __IO uint32_t	TCLR0B;			     //	 Timer0 B Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0BClr : 1; // Timer0 B Clear 
N//      } TCLR0B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON0B;			     //	 Timer0 B Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0BEn     : 1; // Timer0 B Enable
N//          __IO uint32_t Tm0BIntrEn : 1; // Timer0 B Interrupt Enable
N//          __IO uint32_t Tm0BClkSel : 2; // Timer0 B Clock Select
N//          __IO uint32_t Tm0BMode   : 2; // Timer0 B Mode Select
N//          __IO uint32_t Tm0BSize   : 2; // Timer0 B Counter Size Select
N//      } TCON0B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH0B;			     //	 Timer0 B Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0BWIDTH     : 32; // Timer0 B Period Width
N//      } TWIDTH0B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD0B;			     //	 Timer0 B Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm0BCntLoad   : 32; // Timer0 B Counting Value
N//      } LOAD0B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPLOW0;			   //	 Capture0 Low Value
N//
N//      struct {
N//          __I uint32_t CaptureLow   : 32; // Timer  Counting High Value 0
N//      } CAPLOW0_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPHIGH0;			   //	 Capture0 High Value
N//
N//      struct {
N//          __I uint32_t CaptureHigh   : 32; // Timer Counting High Value 0
N//      } CAPHIGH0_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	PWMLOW0;			   //	 PWM Low Value0
N//
N//      struct {
N//          __IO uint32_t PWMLowWidth   : 32; // Timer PWM Low Width Value 0
N//      } PWMLOW0_b;
N//    } ;
N//
N//
N/////// 1
N////// A
N//    union {
N//	    __IO uint32_t	TCLR1A;			     //	 Timer1 A Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1AClr : 1; // Timer1 A Clear 
N//      } TCLR1A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON1A;			     //	 Timer1 A Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1AEn     : 1; // Timer1 A Enable
N//          __IO uint32_t Tm1AIntrEn : 1; // Timer1 A Interrupt Enable
N//          __IO uint32_t Tm1AClkSel : 2; // Timer1 A Clock Select
N//          __IO uint32_t Tm1AMode   : 2; // Timer1 A Mode Select
N//          __IO uint32_t Tm1ASize   : 2; // Timer1 A Counter Size Select
N//      } TCON1A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH1A;			     //	 Timer1 A Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1AWIDTH     : 32; // Timer1 A Period Width
N//      } TWIDTH1A_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD1A;			     //	 Timer1 A Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm1ACntLoad   : 32; // Timer1 A Counting Value
N//      } LOAD1A_b;
N//    } ;
N/////// B
N//    union {
N//	    __IO uint32_t	TCLR1B;			     //	 Timer1 B Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1BClr : 1; // Timer1 B Clear 
N//      } TCLR1B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON1B;			     //	 Timer1 B Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1BEn     : 1; // Timer1 B Enable
N//          __IO uint32_t Tm1BIntrEn : 1; // Timer1 B Interrupt Enable
N//          __IO uint32_t Tm1BClkSel : 2; // Timer1 B Clock Select
N//          __IO uint32_t Tm1BMode   : 2; // Timer1 B Mode Select
N//          __IO uint32_t Tm1BSize   : 2; // Timer1 B Counter Size Select
N//      } TCON1B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH1B;			     //	 Timer1 B Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1BWIDTH     : 32; // Timer1 B Period Width
N//      } TWIDTH1B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD1B;			     //	 Timer1 B Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm1BCntLoad   : 32; // Timer1 B Counting Value
N//      } LOAD1B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPLOW1;			   //	 Capture1 Low Value
N//
N//      struct {
N//          __IO uint32_t CaptureLow   : 32; // Timer  Counting High Value 1
N//      } CAPLOW1_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPHIGH1;			   //	 Capture1 High Value
N//
N//      struct {
N//          __IO uint32_t CaptureHigh   : 32; // Timer Counting High Value 1
N//      } CAPHIGH1_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	PWMLOW1;			   //	 PWM Low Value1
N//
N//      struct {
N//          __IO uint32_t PWMLowWidth   : 32; // Timer PWM Low Width Value 1
N//      } PWMLOW1_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	CONFIG;			     //	 Timer Configuration Register
N//
N//      struct {
N//          __IO uint32_t  Tm0CapMode       : 1; // Timer0 Capture Mode 
N//          __IO uint32_t  Tm0PwmMode       : 1; // Timer0 Pulse Width Modulator Mode 
N//          __IO uint32_t  Tm1CapMode       : 1; // Timer1 Capture Mode 
N//          __IO uint32_t  Tm1PwmMode       : 1; // Timer1 Pulse Width Modulator Mode 
N//          __IO uint32_t  Tm0AIntrAutoClr  : 1; // Timer0 A Interrupt Auto Clear  
N//          __IO uint32_t  Tm0BIntrAutoClr  : 1; // Timer0 B Interrupt Auto Clear 
N//          __IO uint32_t  Tm1AIntrAutoClr  : 1; // Timer1 A Interrupt Auto Clear 
N//          __IO uint32_t  Tm1BIntrAutoClr  : 1; // Timer1 B Interrupt Auto Clear
N//      } CONFIG_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	LRAWINTSTATUS;    //	 Timer Raw Level Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0ARLIS       : 1; // Timer0 A Raw Level Interrupt Status
N//          __IO uint32_t  Tm0BRLIS       : 1; // Timer0 B Raw Leve1 Interrupt Status
N//          __IO uint32_t  Tm1ARLIS       : 1; // Timer1 A Raw Leve1 Interrupt Status
N//          __IO uint32_t  Tm1BRLIS       : 1; // Timer1 B Raw Level Interrupt Status
N//      } RAWLINTSTATUS_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	LINTSTATUS;	        //	 Timer Mask Level Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0AMLIS       : 1; // Timer0 A Mask Level Interrupt Status
N//          __IO uint32_t  Tm0BMLIS       : 1; // Timer0 B Mask Leve1 Interrupt Status
N//          __IO uint32_t  Tm1AMLIS       : 1; // Timer1 A Mask Leve1 Interrupt Status
N//          __IO uint32_t  Tm1BMLIS       : 1; // Timer1 B Mask Level Interrupt Status
N//      } LINTSTATUS_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	INTRMODE;	        //	 Timer Interrupt Mode Edeg : Level
N//
N//      struct {
N//          __IO uint32_t  Tm0AINTRMode         : 1; // Timer0 A Interrupt Detect Mode Select
N//          __IO uint32_t  Tm0BINTRMode         : 1; // Timer0 B Interrupt Detect Mode Select
N//          __IO uint32_t  Tm1AINTRMode         : 1; // Timer1 A Interrupt Detect Mode Select
N//          __IO uint32_t  Tm1BINTRMode         : 1; // Timer1 B Interrupt Detect Mode Select
N//      } INTRMODE_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	RAWEINTSTATUS;    //	 Timer Raw Edge Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0AREIS       : 1; // Timer0 A Raw Edge Interrupt Status
N//          __IO uint32_t  Tm0BREIS       : 1; // Timer0 B Raw Edge Interrupt Status
N//          __IO uint32_t  Tm1AREIS       : 1; // Timer1 A Raw Edge Interrupt Status
N//          __IO uint32_t  Tm1BREIS       : 1; // Timer1 B Raw Edge Interrupt Status
N//      } RAWEINTSTATUS_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	EINTSTATUS;	        //	 Timer Mask Edge Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0AMEIS       : 1; // Timer0 A Mask Edge Interrupt Status
N//          __IO uint32_t  Tm0BMEIS       : 1; // Timer0 B Mask Edge Interrupt Status
N//          __IO uint32_t  Tm1AMEIS       : 1; // Timer1 A Mask Edge Interrupt Status
N//          __IO uint32_t  Tm1BMEIS       : 1; // Timer1 B Mask Edge Interrupt Status
N//      } EINTSTATUS_b;
N//    } ;
N//       
N//}TIMER_TypeDef;
N
N
N
N
L 280 "..\..\Hal\system\MFTP.h" 2
N#include "_i2c.h"
L 1 "..\..\Hal\i2c\_i2c.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _i2c.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __I2C_H_
N#define __I2C_H_
N
N
N/* ================================================================================ */
N/* ================                      I2C                       ================ */
N/* ================================================================================ */
N
Ntypedef struct
N{
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cId : 7;	// I2C Master/Slave Device Address
X			volatile uint32_t I2cId : 7;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x00
X		volatile uint32_t ulBulk;	  
N	} I2C_DEVICE_ADDR;	// I2C Master/Slave Device Address Register
N
N	union
N	{
N		struct
N		{
N			__O uint32_t I2cSWReset : 1;	// I2C Software Reset
X			volatile uint32_t I2cSWReset : 1;	
N		} tBit;
N		__O uint32_t ulBulk;	  // 0x04
X		volatile uint32_t ulBulk;	  
N	} I2C_SW_RESET;	// I2C Master/Slave Software Reset Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cItrptEn        : 1;	// I2C Interrupt Enable
X			volatile uint32_t I2cItrptEn        : 1;	
N			__IO uint32_t I2cStrItrptEn     : 1;	// I2C Slave Start Interrupt Enable
X			volatile uint32_t I2cStrItrptEn     : 1;	
N			__IO uint32_t I2cStpItrptEn     : 1;	// I2C Stop Interrupt Enable
X			volatile uint32_t I2cStpItrptEn     : 1;	
N			__IO uint32_t I2cAddChkItrptEn  : 1;	// I2C Slave Device Address matched Intrrupt Enable
X			volatile uint32_t I2cAddChkItrptEn  : 1;	
N			__IO uint32_t I2cByteItrptEn    : 1;	// I2C Slave Byte Done Intrrupt Enable
X			volatile uint32_t I2cByteItrptEn    : 1;	
N			__IO uint32_t I2cMstItrptEn     : 1;	// I2C Master Packet Done Interrupt Enable
X			volatile uint32_t I2cMstItrptEn     : 1;	
N			__IO uint32_t I2cIspModeEn      : 1;	// I2C ISP Protocol Entry Mode Enable
X			volatile uint32_t I2cIspModeEn      : 1;	
N			__IO uint32_t I2cTxFifoItrptEn  : 1;	// I2C TX FIFO Interrupt Enable
X			volatile uint32_t I2cTxFifoItrptEn  : 1;	
N			__IO uint32_t I2cRxFifoItrptEn  : 1;	// I2C RX FIFO Interrupt Enable
X			volatile uint32_t I2cRxFifoItrptEn  : 1;	
N			__IO uint32_t I2cSclHoldItrptEn : 1;	// I2C SCL Hold Interrupt Enable
X			volatile uint32_t I2cSclHoldItrptEn : 1;	
N			__IO uint32_t I2cFilterEn       : 1;	// I2C Filter Enable
X			volatile uint32_t I2cFilterEn       : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x08
X		volatile uint32_t ulBulk;	  
N	} I2C_GLB_CR;	// I2C Interrupt Control Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cMstClkDiv : 16;	// I2C Master SCLK Clock Divide Value
X			volatile uint32_t I2cMstClkDiv : 16;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x0C
X		volatile uint32_t ulBulk;	  
N	} I2C_MST_CR1;	// I2C Master Control Register 1
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cMstDataTr	: 8;	// I2C Master Data Transfer
X			volatile uint32_t I2cMstDataTr	: 8;	
N			__IO uint32_t I2cMstStr		: 1;	// I2C Master Start Condition
X			volatile uint32_t I2cMstStr		: 1;	
N			__IO uint32_t I2cMstStop		: 1;	// I2C Master Stop Condition
X			volatile uint32_t I2cMstStop		: 1;	
N			__IO uint32_t I2cMstRcvMode	: 1;	// I2C Master Receive Mode
X			volatile uint32_t I2cMstRcvMode	: 1;	
N			__IO uint32_t I2cMstNackTr	: 1;	// I2C Ack Condition
X			volatile uint32_t I2cMstNackTr	: 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x10
X		volatile uint32_t ulBulk;	  
N	} I2C_MST_CR2;	// I2C Master Control Register 2
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2C_ITRPT       : 1;	// I2C Interrupt Flag
X			volatile uint32_t I2C_ITRPT       : 1;	
N			__I uint32_t IspMode         : 1;	// I2C ISP Mode Status
X			volatile const uint32_t IspMode         : 1;	
N			__I uint32_t Rsvd1           : 1;	// Not Used
X			volatile const uint32_t Rsvd1           : 1;	
N			__I uint32_t I2cSlvRdWrFlag  : 1;	// I2C Slave R/W Condition Status
X			volatile const uint32_t I2cSlvRdWrFlag  : 1;	
N			__I uint32_t I2cSlvAckRcv    : 1;	// I2C Slave Ack Condition
X			volatile const uint32_t I2cSlvAckRcv    : 1;	
N			__I uint32_t I2cPacketEn     : 1;	// I2CMaster packet Status
X			volatile const uint32_t I2cPacketEn     : 1;	
N			__I uint32_t I2cMstAckRcv    : 1;	// I2C Master Received Ack Condition
X			volatile const uint32_t I2cMstAckRcv    : 1;	
N			__I uint32_t Rsvd2           : 1;	// Not Used
X			volatile const uint32_t Rsvd2           : 1;	
N			__I uint32_t I2cMstDataRcv   : 8;	// I2C Master Received Data Status
X			volatile const uint32_t I2cMstDataRcv   : 8;	
N			__I uint32_t I2cItrptState   : 4;	// I2C Interrupt State
X			volatile const uint32_t I2cItrptState   : 4;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x14
X		volatile uint32_t ulBulk;		  
N	} I2C_GLB_SR;	// I2C Global Status Register
N
N	union
N	{
N		struct
N		{
N			__I uint32_t I2cSlvStSR   : 14;	// I2C Slave FSM Status
X			volatile const uint32_t I2cSlvStSR   : 14;	
N		} tBit;
N		__I  uint32_t ulBulk;	  // 0x18
X		volatile const  uint32_t ulBulk;	  
N	} I2C_SLV_ST_SR;	// I2C Slave Status Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t TxFifoInit    : 1;	// I2C TXFIFO WPTR / RPTR Clear
X			volatile uint32_t TxFifoInit    : 1;	
N			__IO uint32_t TxDmaIfEn     : 1;	// I2C DMA I/F TX Enable
X			volatile uint32_t TxDmaIfEn     : 1;	
N			__IO uint32_t TxFifoWmLv    : 5;	// I2C TXFIFO Watermark Level
X			volatile uint32_t TxFifoWmLv    : 5;	
N			__IO uint32_t TxFifoReqSel  : 1;	// TXFIFO Request Selection
X			volatile uint32_t TxFifoReqSel  : 1;	
N			__IO uint32_t RxFifoInit    : 1;	// I2C RXFIFO WPTR / RPTR Clear
X			volatile uint32_t RxFifoInit    : 1;	
N			__IO uint32_t RxDmaIfEn     : 1;	// I2C DMA I/F RX Enable
X			volatile uint32_t RxDmaIfEn     : 1;	
N			__IO uint32_t RxFifoWmLv    : 5;	// I2C RXFIFO Watermark Level
X			volatile uint32_t RxFifoWmLv    : 5;	
N			__IO uint32_t RxFifoReqSel  : 1;	// RXFIFO Request Selection
X			volatile uint32_t RxFifoReqSel  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x1C
X		volatile uint32_t ulBulk;	  
N	}I2C_FIFO_CR;	// I2C FIFO Control Register
N
N	union
N	{
N		struct
N		{
N			__O uint32_t TxFifoData  : 8;	// TXFIFO Data
X			volatile uint32_t TxFifoData  : 8;	
N		} tBit;
N		__O uint32_t ulBulk;  // 0x20
X		volatile uint32_t ulBulk;  
N	} I2C_TXFIFO_DATA;	// I2C TXFIFO Data Register
N
N	union
N	{
N		struct
N		{
N			__I uint32_t RxFifoData  : 8;	// RXFIFO Data
X			volatile const uint32_t RxFifoData  : 8;	
N		} tBit;
N		__I uint32_t ulBulk;  // 0x24
X		volatile const uint32_t ulBulk;  
N	} I2C_RXFIFO_DATA;	// I2C RXFIFO Data Register
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TxFifoEmpty   : 1;	// TXFIFO Empty Flag
X			volatile const uint32_t TxFifoEmpty   : 1;	
N			__I uint32_t TxFifoFull    : 1;	// TXFIFO Full Flag
X			volatile const uint32_t TxFifoFull    : 1;	
N			__I uint32_t TxFifoWmFlag  : 1;	// TXFIFO Watermark Level Flag
X			volatile const uint32_t TxFifoWmFlag  : 1;	
N			__I uint32_t TxFifoWmBlw   : 1;	// TXFIFO Watermark Level Below Flag
X			volatile const uint32_t TxFifoWmBlw   : 1;	
N			__I uint32_t TxWrPtr       : 5;	// TXFIFO Write Pointer
X			volatile const uint32_t TxWrPtr       : 5;	
N			__I uint32_t TxRdPtr       : 5;	// TXFIFO Read Pointer
X			volatile const uint32_t TxRdPtr       : 5;	
N			__I uint32_t Rsvd1         : 2;	// Not Used
X			volatile const uint32_t Rsvd1         : 2;	
N			__I uint32_t RxFifoEmpty   : 1;	// RXFIFO Empty Flag
X			volatile const uint32_t RxFifoEmpty   : 1;	
N			__I uint32_t RxFifoFull    : 1;	// RXFIFO Full Flag
X			volatile const uint32_t RxFifoFull    : 1;	
N			__I uint32_t RxFifoWmFlag  : 1;	// RXFIFO Watermark Level Flag
X			volatile const uint32_t RxFifoWmFlag  : 1;	
N			__I uint32_t RxFifoWmAbv   : 1;	// RXFIFO Watermark Level Above Flag
X			volatile const uint32_t RxFifoWmAbv   : 1;	
N			__I uint32_t RxWrPtr       : 5;	// RXFIFO Write Pointer
X			volatile const uint32_t RxWrPtr       : 5;	
N			__I uint32_t RxRdPtr       : 5;	// RXFIFO Read Pointer
X			volatile const uint32_t RxRdPtr       : 5;	
N			__I uint32_t Rsvd2         : 2;	// Not Used
X			volatile const uint32_t Rsvd2         : 2;	
N		} tBit;
N		__I uint32_t ulBulk;  // 0x28
X		volatile const uint32_t ulBulk;  
N	} I2C_FIFO_SR;	// I2C TXFIFO / RXFIFO Status Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SetPwrRegLSBOn    : 8;	// Power Register LSB for Wakeup Mode
X			volatile uint32_t SetPwrRegLSBOn    : 8;	
N			__IO uint32_t SetPwrRegLSBSleep : 8;	// Power Register LSB for Sleep Mode
X			volatile uint32_t SetPwrRegLSBSleep : 8;	
N			__IO uint32_t SetPwrRegMSB      : 8;	// Register MSB of Power Mode
X			volatile uint32_t SetPwrRegMSB      : 8;	
N			__IO uint32_t SetPwrRegLSBFirst : 1;	// Set I2C protocol, LSB first
X			volatile uint32_t SetPwrRegLSBFirst : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;  // 0x2C
X		volatile uint32_t ulBulk;  
N	} I2C_SET_PWR_REG;	// I2C Set Power Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SetPwrCmdLSB    : 8;	// Command LSB of Power Mode
X			volatile uint32_t SetPwrCmdLSB    : 8;	
N			__IO uint32_t SetPwrCmdMSB    : 8;	// Command MSB of Power mode
X			volatile uint32_t SetPwrCmdMSB    : 8;	
N			__IO uint32_t SetPwrCmdEn     : 1;	// Power Command Enable
X			volatile uint32_t SetPwrCmdEn     : 1;	
N			__IO uint32_t SetPwrLSBFirst  : 1;	// Set I2C Protocol, LB first
X			volatile uint32_t SetPwrLSBFirst  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;  // 0x30
X		volatile uint32_t ulBulk;  
N	} I2C_SET_PWR_CMD;	// I2C Set Power Command Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t WakeUpItrptEn   : 1;	// Wake up Interrupt Enable
X			volatile uint32_t WakeUpItrptEn   : 1;	
N			__IO uint32_t SleepItrptEn    : 1;	// Sleep Interrup Enable
X			volatile uint32_t SleepItrptEn    : 1;	
N			__IO uint32_t WakeUpItrpt     : 1;	// Wake Up Interrupt
X			volatile uint32_t WakeUpItrpt     : 1;	
N			__IO uint32_t SleepItrpt      : 1;	// Sleep Interrupt
X			volatile uint32_t SleepItrpt      : 1;	
N			__I uint32_t PowerState      : 1;	// State of Power Save Mode
X			volatile const uint32_t PowerState      : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;  // 0x34
X		volatile uint32_t ulBulk;  
N	} I2C_SET_PWR_INT;	// I2C Set Power Interrupt Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cDlyVal   : 6;	// Delay after negative edge of SCL
X			volatile uint32_t I2cDlyVal   : 6;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x38
X		volatile uint32_t ulBulk;	  
N	} I2C_DLY_VALUE;	// I2C Delay Value Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cSlvTrLen   : 15;	// I2C Slave Transfer Length
X			volatile uint32_t I2cSlvTrLen   : 15;	
N			__IO uint32_t Rsvd          : 1;	// Not Used
X			volatile uint32_t Rsvd          : 1;	
N			__I uint32_t I2cSlvTrCnt   : 15;	// I2C Slave Transfer Count Value
X			volatile const uint32_t I2cSlvTrCnt   : 15;	
N			__I uint32_t I2cSlvTrDone  : 1;	// I2C Slave Transfer Done Flag
X			volatile const uint32_t I2cSlvTrDone  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x3C
X		volatile uint32_t ulBulk;	  
N	} I2C_SLV_DBG;	// I2C Slave Debugging Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cMstTrLen   : 15;	// I2C Master Transfer Length
X			volatile uint32_t I2cMstTrLen   : 15;	
N			__IO uint32_t Rsvd          : 1;	// Not Used
X			volatile uint32_t Rsvd          : 1;	
N			__I uint32_t I2cMstTrCnt   : 15;	// I2C Master Transfer Count Value
X			volatile const uint32_t I2cMstTrCnt   : 15;	
N			__I uint32_t I2cMstTrDone  : 1;	// I2C Master Transfer Done Flag
X			volatile const uint32_t I2cMstTrDone  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x40
X		volatile uint32_t ulBulk;	  
N	} I2C_MST_DBG;	// I2C Master Debugging Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t TxFifoInit2   : 1;	// TXFIFO WPTR / RPTR Clear
X			volatile uint32_t TxFifoInit2   : 1;	
N			__IO uint32_t TxFifoIntEna2 : 1;	// Interrupt I/F TX Enable
X			volatile uint32_t TxFifoIntEna2 : 1;	
N			__IO uint32_t TxFifoWmLv2   : 5;	// TXFIFO Watermark Level 2
X			volatile uint32_t TxFifoWmLv2   : 5;	
N			__IO uint32_t TxFifoIntSel  : 1;	// TXFIFO Interrupt Selection
X			volatile uint32_t TxFifoIntSel  : 1;	
N			__IO uint32_t RxFifoInit2   : 1;	// RXFIFO WPTR / RPTR Clear
X			volatile uint32_t RxFifoInit2   : 1;	
N			__IO uint32_t RxFifoIntEna2 : 1;	// Interrupt I/F RX Enable
X			volatile uint32_t RxFifoIntEna2 : 1;	
N			__IO uint32_t RxFifoWmLv2   : 5;	// RXFIFO Watermark Level 2
X			volatile uint32_t RxFifoWmLv2   : 5;	
N			__IO uint32_t RxFifoIntSel  : 1;	// RXFIFO Interrupt Selection
X			volatile uint32_t RxFifoIntSel  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x44
X		volatile uint32_t ulBulk;	  
N	} I2C_FIFO_CR2;	// I2C FIFO Control Register 2
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TxFifoEmpty   : 1;	// TXFIFO Empty Flag
X			volatile const uint32_t TxFifoEmpty   : 1;	
N			__I uint32_t TxFifoFull    : 1;	// TXFIFO Full Flag
X			volatile const uint32_t TxFifoFull    : 1;	
N			__I uint32_t TxFifoWmFlag2 : 1;	// TXFIFO Watermark Level Flag
X			volatile const uint32_t TxFifoWmFlag2 : 1;	
N			__I uint32_t TxFifoWmBlw2  : 1;	// TXFIFO Watermark Level Below Flag
X			volatile const uint32_t TxFifoWmBlw2  : 1;	
N			__I uint32_t TxWrPtr       : 5;	// TXFIFO Write Pointer
X			volatile const uint32_t TxWrPtr       : 5;	
N			__I uint32_t TxRdPtr       : 5;	// TXFIFO Read Pointer
X			volatile const uint32_t TxRdPtr       : 5;	
N			__I uint32_t TxFifoInt     : 1;	// TXFIFO Interrupt
X			volatile const uint32_t TxFifoInt     : 1;	
N			__I uint32_t Rsvd          : 1;	// Not Used
X			volatile const uint32_t Rsvd          : 1;	
N			__I uint32_t RxFifoEmpty   : 1;	// RXFIFO Empty Flag
X			volatile const uint32_t RxFifoEmpty   : 1;	
N			__I uint32_t RxFifoFull    : 1;	// RXFIFO Full Flag
X			volatile const uint32_t RxFifoFull    : 1;	
N			__I uint32_t RxFifoWmFlag2 : 1;	// RXFIFO Watermark Level Flag
X			volatile const uint32_t RxFifoWmFlag2 : 1;	
N			__I uint32_t RxFifoWmAbv2  : 1;	// RXFIFO Watermark Level Above Flag
X			volatile const uint32_t RxFifoWmAbv2  : 1;	
N			__I uint32_t RxWrPtr       : 5;	// RXFIFO Write Pointer
X			volatile const uint32_t RxWrPtr       : 5;	
N			__I uint32_t RxRdPtr       : 5;	// RXFIFO Read Pointer
X			volatile const uint32_t RxRdPtr       : 5;	
N			__I uint32_t RxFifoInt     : 1;	// RXFIFO Interrupt
X			volatile const uint32_t RxFifoInt     : 1;	
N		} tBit;
N		__I uint32_t ulBulk;	  // 0x48
X		volatile const uint32_t ulBulk;	  
N	} I2C_FIFO_SR2;	// I2C TXFIFO / RXFIFO Status Register 2
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cStretchEn  : 1;
X			volatile uint32_t I2cStretchEn  : 1;
N			__IO uint32_t I2cStretchVal : 31;
X			volatile uint32_t I2cStretchVal : 31;
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x4C
X		volatile uint32_t ulBulk;	  
N	} I2C_STRTCH_CR1;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cStretchSel   : 1;
X			volatile uint32_t I2cStretchSel   : 1;
N			__IO uint32_t I2cStretchApp   : 1;
X			volatile uint32_t I2cStretchApp   : 1;
N			__IO uint32_t I2cStretchType  : 1;
X			volatile uint32_t I2cStretchType  : 1;
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x50
X		volatile uint32_t ulBulk;	  
N	} I2C_STRTCH_CR2;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cSclLowVal  : 32;
X			volatile uint32_t I2cSclLowVal  : 32;
N		} tBit;
N		__I uint32_t ulBulk;	  // 0x54
X		volatile const uint32_t ulBulk;	  
N	} I2C_SCL_VAL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SlpCr     : 1;	// Sleep Enable
X			volatile uint32_t SlpCr     : 1;	
N			__IO uint32_t PrMux     : 1;	// APB Bus RDATA Selection
X			volatile uint32_t PrMux     : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x58
X		volatile uint32_t ulBulk;		  
N	} I2C_SLP_CR; 	// I2C Sleep Control Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SlpSr		: 1;	// Device Address Check Interrupt
X			volatile uint32_t SlpSr		: 1;	
N			__I uint32_t PclkEna	: 1;	// Normal PCLK Enable
X			volatile const uint32_t PclkEna	: 1;	
N			__I uint32_t PclkCr		: 1;	// SCLK Enable
X			volatile const uint32_t PclkCr		: 1;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x5C
X		volatile uint32_t ulBulk;		  
N	} I2C_SLP_SR;	// I2C Sleep Status Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cSclHoldEn		: 1;	// SCL Stretch Function1 Enable
X			volatile uint32_t I2cSclHoldEn		: 1;	
N			__I uint32_t I2cSclHoldStatus	: 1;	// SCL Sretch Status
X			volatile const uint32_t I2cSclHoldStatus	: 1;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x60
X		volatile uint32_t ulBulk;		  
N	} I2C_SCL_HOLD;	// I2C SCL Stretch Control Register
N
N	union 
N	{
N		struct 
N		{
N			__IO uint32_t I2cSclHoldEn2		: 1;	// SCL Stretch Fuction2 Enable
X			volatile uint32_t I2cSclHoldEn2		: 1;	
N			__I uint32_t I2cSclHoldRls		: 1;	// SCL Stretch Status 
X			volatile const uint32_t I2cSclHoldRls		: 1;	
N			__IO uint32_t I2cSclHoldCntEn	: 1;	// SCL Hold Timeout Count Enable
X			volatile uint32_t I2cSclHoldCntEn	: 1;	
N			__I uint32_t I2cSclHoldTOutSt	: 1;	// SCL Hold Timeout Status
X			volatile const uint32_t I2cSclHoldTOutSt	: 1;	
N			__IO uint32_t Rsvd				: 12;	// Not Used
X			volatile uint32_t Rsvd				: 12;	
N			__IO uint32_t I2cSclHoldTOutVal	: 16;	// SCL Hold Timeout Counter Value
X			volatile uint32_t I2cSclHoldTOutVal	: 16;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x64
X		volatile uint32_t ulBulk;		  
N	} I2C_SCL_HOLD2;	// I2C SCL Stretch Control Register 2
N
N	__IO uint32_t Reserved0;	          // 0x68
X	volatile uint32_t Reserved0;	          
N	__IO uint32_t Reserved1;	          // 0x6C
X	volatile uint32_t Reserved1;	          
N	__IO uint32_t Reserved2;	          // 0x70
X	volatile uint32_t Reserved2;	          
N	__IO uint32_t Reserved3;	          // 0x74
X	volatile uint32_t Reserved3;	          
N	__IO uint32_t SLP_I2C_DEVICE_ADDR;  // 0x78
X	volatile uint32_t SLP_I2C_DEVICE_ADDR;  
N	__IO uint32_t SLP_I2C_SW_RESET;	  // 0x7C
X	volatile uint32_t SLP_I2C_SW_RESET;	  
N	__IO uint32_t SLP_I2C_GLB_CR;	      // 0x80
X	volatile uint32_t SLP_I2C_GLB_CR;	      
N	__IO uint32_t SLP_I2C_MST_CR1;	  // 0x84
X	volatile uint32_t SLP_I2C_MST_CR1;	  
N	__IO uint32_t SLP_I2C_MST_CR2;	  // 0x88
X	volatile uint32_t SLP_I2C_MST_CR2;	  
N	__IO uint32_t SLP_I2C_GLB_SR;		  // 0x8C
X	volatile uint32_t SLP_I2C_GLB_SR;		  
N	__I  uint32_t SLP_I2C_SLV_ST_SR;	  // 0x90
X	volatile const  uint32_t SLP_I2C_SLV_ST_SR;	  
N	__IO uint32_t SLP_I2C_FIFO_CR;	  // 0x94
X	volatile uint32_t SLP_I2C_FIFO_CR;	  
N	__IO uint32_t SLP_I2C_TXFIFO_DATA;  // 0x98
X	volatile uint32_t SLP_I2C_TXFIFO_DATA;  
N	__I	 uint32_t SLP_I2C_RXFIFO_DATA;  // 0x9C
X	volatile const	 uint32_t SLP_I2C_RXFIFO_DATA;  
N	__I  uint32_t SLP_I2C_FIFO_SR;	  // 0xA0
X	volatile const  uint32_t SLP_I2C_FIFO_SR;	  
N	__IO uint32_t SLP_I2C_SET_PWR_REG;  // 0xA4
X	volatile uint32_t SLP_I2C_SET_PWR_REG;  
N	__IO uint32_t SLP_I2C_SET_PWR_CMD;  // 0xA8
X	volatile uint32_t SLP_I2C_SET_PWR_CMD;  
N	__IO uint32_t SLP_I2C_SET_PWR_INT;  // 0xAC
X	volatile uint32_t SLP_I2C_SET_PWR_INT;  
N	__IO uint32_t SLP_I2C_DLY_VALUE;	  // 0xB0
X	volatile uint32_t SLP_I2C_DLY_VALUE;	  
N	__IO uint32_t SLP_I2C_SLV_DBG;	  // 0xB4
X	volatile uint32_t SLP_I2C_SLV_DBG;	  
N	__IO uint32_t SLP_I2C_MST_DBG;	  // 0xB8
X	volatile uint32_t SLP_I2C_MST_DBG;	  
N	__IO uint32_t SLP_I2C_FIFO_CR2;	  // 0xBC
X	volatile uint32_t SLP_I2C_FIFO_CR2;	  
N	__IO uint32_t SLP_I2C_FIFO_SR2;	  // 0xC0
X	volatile uint32_t SLP_I2C_FIFO_SR2;	  
N	__IO uint32_t SLP_I2C_STRTCH_CR1;	  // 0xC4
X	volatile uint32_t SLP_I2C_STRTCH_CR1;	  
N	__IO uint32_t SLP_I2C_STRTCH_CR2;	  // 0xC8
X	volatile uint32_t SLP_I2C_STRTCH_CR2;	  
N	__IO uint32_t SLP_I2C_SCL_VAL;	  // 0xCC
X	volatile uint32_t SLP_I2C_SCL_VAL;	  
N	__IO uint32_t SLP_I2C_SCL_HOLD;	  // 0xD0
X	volatile uint32_t SLP_I2C_SCL_HOLD;	  
N	__IO uint32_t SLP_I2C_SCL_HOLD2;	  // 0xD4
X	volatile uint32_t SLP_I2C_SCL_HOLD2;	  
N
N} tI2C_CtrlReg_t;    
N
N#endif /* __I2C_H_ */
L 281 "..\..\Hal\system\MFTP.h" 2
N#include "_dma.h"
L 1 "..\..\Hal\dma\_dma.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _dma.h
N * version : 0.1
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __DMA_H_
N#define __DMA_H_
N
N
Ntypedef struct
N{
N	__IO uint32_t 	SAR;          /*!< 0x?? : SAR : Channel? Source Address Register		*/
X	volatile uint32_t 	SAR;           
N	     uint32_t		xRESERVED0;
N	
N	__IO uint32_t	  DAR;				  /*!< 0x?? : DAR : Channel? Destination Address Register		*/
X	volatile uint32_t	  DAR;				   
N	     uint32_t		xRESERVED1;
N
N	__IO uint32_t	  LLP;				  /*!< 0x?? : LLP	: Channel? Linked List Pointer Register		*/
X	volatile uint32_t	  LLP;				   
N	     uint32_t		xRESERVED2;
N
N	__IO uint64_t	  CTL;				  /*!< 0x?? : CTL	: Channel? Control Register		*/
X	volatile uint64_t	  CTL;				   
N
N	__IO uint32_t	  SSTAT;				/*!< 0x?? : SSTAT	: Channel? Source Status Register	*/
X	volatile uint32_t	  SSTAT;				 
N	     uint32_t		xRESERVED3;
N
N	__IO uint32_t	  DSTAT;				/*!< 0x?? : DSTAT	: Channel? Destination Status Register	*/
X	volatile uint32_t	  DSTAT;				 
N	     uint32_t		xRESERVED4;
N
N	__IO uint32_t	  SSTATAR;			/*!< 0x?? : SSTATAR	: Channel? Source Status Register	*/
X	volatile uint32_t	  SSTATAR;			 
N	     uint32_t		xRESERVED5;
N
N	__IO uint32_t	  DSTATAR;			/*!< 0x?? : DSTATAR	: Channel? Destination Status Address Register	*/
X	volatile uint32_t	  DSTATAR;			 
N	     uint32_t		xRESERVED6;
N
N	__IO uint64_t	  CFG;				  /*!< 0x?? : CFG	: Channel? Configuration Register		*/
X	volatile uint64_t	  CFG;				   
N
N	__IO uint32_t 	SGR;			  	/*!< 0x?? : SGR	: Channel? Source Gather Register		*/
X	volatile uint32_t 	SGR;			  	 
N	     uint32_t		xRESERVED7;
N
N	__IO uint32_t	  DSR;				  /*!< 0x?? : DSR	: Channel? Destination Scatter Register		*/
X	volatile uint32_t	  DSR;				   
N	     uint32_t		xRESERVED8;
N} DMA_Channel_TypeDef, *pDMA_Channel_TypeDef;
N
Ntypedef struct
N{
N	__IO uint32_t	  RawTfr;				      /*!< 0x2C0 : RawTfr : Raw Status for IntTfr Interrupt	*/
X	volatile uint32_t	  RawTfr;				       
N	     uint32_t		RawTfrRsvd;
N	__IO uint32_t	  RawIntBlock;		    /*!< 0x2C8 : RawBlock : Raw Status for IntBlock Interrupt	*/
X	volatile uint32_t	  RawIntBlock;		     
N	     uint32_t		RawBlockRsvd;
N	__IO uint32_t	  RawSrcTran;			    /*!< 0x2D0 : RawSrcTran : Raw Status for IntSrcTran Interrupt	*/
X	volatile uint32_t	  RawSrcTran;			     
N	     uint32_t		RawSrcTranRsvd;
N	__IO uint32_t	  RawDstTran;			    /*!< 0x2D8 : RawDstTran : Raw Status for IntDstTran Interrupt	*/
X	volatile uint32_t	  RawDstTran;			     
N	     uint32_t		RawDstTranRsvd;
N	__IO uint32_t	  RawErr;				      /*!< 0x2E0 : RawErr : Raw Status for IntErr Interrupt	*/
X	volatile uint32_t	  RawErr;				       
N	     uint32_t		RawErrRsvd;
N
N	__I  uint32_t	  StatusTfr;			    /*!< 0x2E8 : StatusTfr : Status for IntTfr Interrupt	*/
X	volatile const  uint32_t	  StatusTfr;			     
N	     uint32_t		StatusTfrRsvd;
N	__I  uint32_t	  StatusBlock;		    /*!< 0x2F0 : StatusBlock : Status for IntBlock Interrupt	*/
X	volatile const  uint32_t	  StatusBlock;		     
N	     uint32_t		StatusBlockRsvd;
N	__I  uint32_t	  StatusSrcTran;		  /*!< 0x2F8 : StatusSrcTran : Status for IntSrcTran Interrupt	*/
X	volatile const  uint32_t	  StatusSrcTran;		   
N	     uint32_t		StatusSrcTranRsvd;
N	__I  uint32_t	  StatusDstTran;		  /*!< 0x300 : StatusDstTran : Status for IntDstTran Interrupt	*/
X	volatile const  uint32_t	  StatusDstTran;		   
N	     uint32_t		StatusDstTranRsvd;
N	__I  uint32_t	  StatusErr;			    /*!< 0x308 : StatusErr : Status for IntErr Interrupt	*/
X	volatile const  uint32_t	  StatusErr;			     
N	     uint32_t		StatusErrRsvd;
N
N	__IO uint32_t	  MaskTfr;			      /*!< 0x310 : MaskTfr : Mask for IntTfr Interrupt	*/
X	volatile uint32_t	  MaskTfr;			       
N	     uint32_t		MaskTfrRsvd;
N	__IO uint32_t	  MaskBlock;			    /*!< 0x318 : MaskBlock : Mask for IntBlock Interrupt	*/
X	volatile uint32_t	  MaskBlock;			     
N	     uint32_t		MaskBlockRsvd;
N	__IO uint32_t	  MaskSrcTran;		    /*!< 0x320 : MaskSrcTran : Mask for IntSrcTran Interrupt	*/
X	volatile uint32_t	  MaskSrcTran;		     
N	     uint32_t		MaskSrcTranRsvd;
N	__IO uint32_t	  MaskDstTran;		    /*!< 0x328 : MaskDstTran : Mask for IntDstTran Interrupt	*/
X	volatile uint32_t	  MaskDstTran;		     
N	     uint32_t		MaskDstTranRsvd;
N	__IO uint32_t	  MaskErr;			      /*!< 0x330 : MaskErr : Mask for IntErr Interrupt	*/
X	volatile uint32_t	  MaskErr;			       
N	     uint32_t		MaskErrRsvd;
N
N	__IO uint32_t	  ClearTfr;			      /*!< 0x338 : ClearTfr : Clear for IntTfr Interrupt	*/
X	volatile uint32_t	  ClearTfr;			       
N	     uint32_t		ClearTfrRsvd;
N	__IO uint32_t	  ClearBlock;			    /*!< 0x340 : ClearBlock : Clear for IntBlock Interrupt	*/
X	volatile uint32_t	  ClearBlock;			     
N	     uint32_t		ClearBlockRsvd;
N	__IO uint32_t	  ClearSrcTran;		    /*!< 0x348 : ClearSrcTran : Clear for IntSrcTran Interrupt	*/
X	volatile uint32_t	  ClearSrcTran;		     
N	     uint32_t		ClearSrcTranRsvd;
N	__IO uint32_t	  ClearDstTran;		    /*!< 0x350 : ClearDstTran : Clear for IntDstTran Interrupt	*/
X	volatile uint32_t	  ClearDstTran;		     
N	     uint32_t		ClearDstTranRsvd;
N	__IO uint32_t	  ClearErr;			      /*!< 0x358 : ClearErr : Clear for IntErr Interrupt	*/
X	volatile uint32_t	  ClearErr;			       
N	     uint32_t		ClearErrRsvd;
N
N	__IO uint64_t	  StatusInt;			    /*!< 0x360 : StatusInt : Status for each interrupt type	*/
X	volatile uint64_t	  StatusInt;			     
N	__IO uint64_t	  ReqSrcReg;			    /*!< 0x368 : ReqSrcReg : Source Software Transaction Request Register	*/
X	volatile uint64_t	  ReqSrcReg;			     
N	__IO uint64_t	  ReqDstReg;			    /*!< 0x370 : ReqDstReg : Destination Software Transaction Request Register	*/
X	volatile uint64_t	  ReqDstReg;			     
N	__IO uint64_t	  SglReqSrcReg;		    /*!< 0x378 : SglReqSrcReg : Single Source Transaction Request Register	*/
X	volatile uint64_t	  SglReqSrcReg;		     
N	__IO uint64_t	  SglReqDstReg;		    /*!< 0x380 : SglReqDstReg : Single Destination Transaction Request Register	*/
X	volatile uint64_t	  SglReqDstReg;		     
N	__IO uint64_t	  LstSrcReg;			    /*!< 0x388 : LstSrcReg : Last Source Transaction Request Register	*/
X	volatile uint64_t	  LstSrcReg;			     
N	__IO uint64_t	  LstDstReg;			    /*!< 0x390 : LstDstReg : Last Destination Transaction Request Register	*/
X	volatile uint64_t	  LstDstReg;			     
N
N	__IO uint32_t	  DmaCfgReg;			    /*!< 0x398 : DmaCfgReg : DMA Configuration Register	*/
X	volatile uint32_t	  DmaCfgReg;			     
N	     uint32_t 	DmaCfgRegReserved;	  
N
N	__IO uint32_t	  ChEnReg;			      /*!< 0x3a0 : ChEnReg : DMA Channel Enable Register	*/
X	volatile uint32_t	  ChEnReg;			       
N	     uint32_t		ChEnRegReserved;
N
N	__IO uint64_t	  DmaIdReg;			      /*!< 0x3a8 : DmaIdReg : DMA ID Register	*/
X	volatile uint64_t	  DmaIdReg;			       
N	__IO uint64_t	  DmaTestReg;			    /*!< 0x3b0 : DmaTestReg : DMA Test Register	*/
X	volatile uint64_t	  DmaTestReg;			     
N
N	__IO uint64_t	  DMA_COMP_PARAMS_4;	/*!< 0x3d8 : DMA_COMP_PARAMS_4 : Component parameter settings for Channel4 and Channel3 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_4;	 
N	__IO uint64_t	  DMA_COMP_PARAMS_3;	/*!< 0x3e0 : DMA_COMP_PARAMS_3 : Component parameter settings for Channel2 and Channel1 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_3;	 
N	__IO uint64_t	  DMA_COMP_PARAMS_2;	/*!< 0x3e8 : DMA_COMP_PARAMS_2 : Component parameter settings 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_2;	 
N	__IO uint64_t	  DMA_COMP_PARAMS_1;	/*!< 0x3f0 : DMA_COMP_PARAMS_1 : Component parameter settings 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_1;	 
N
N	__IO uint64_t	DmaCompID;			    /*!< 0x3f8 : DMA Component ID Register : Component version register	*/
X	volatile uint64_t	DmaCompID;			     
N} DMA_GLOBAL_TypeDef;
N
N#endif /* __DMA_H_ */
L 282 "..\..\Hal\system\MFTP.h" 2
N#include "../wdgt/_wdgt.h"
L 1 "..\..\Hal\system\../wdgt/_wdgt.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _wdt.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __WDT_H_
N#define __WDT_H_
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  Flash Control Register
N */
N
N
N
Nextern uint8_t cnt;
N
Ntypedef struct
N{
N
N    union {
N	    __IO uint32_t	WDT_CLR;		  // 0x00	WDT Clear				      0x0 
X	    volatile uint32_t	WDT_CLR;		  
N      
N      struct {
N          __IO uint32_t wdtClr : 1; // WDT Clear 
X          volatile uint32_t wdtClr : 1; 
N      } WDT_CLR_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_ACCE;		  // 0x04	WDT Access Control		0x0 
X	    volatile uint32_t	WDT_ACCE;		  
N      
N      struct {
N          __IO uint32_t wdtLock : 1; // WDT Access lock 
X          volatile uint32_t wdtLock : 1; 
N      } WDT_ACCE_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_CON;		  // 0x08	WDT Control Register	0x0000_0007 
X	    volatile uint32_t	WDT_CON;		  
N      
N      struct {
N          __IO uint32_t wdtclksel    : 3; // WDT divided clock source sel
X          volatile uint32_t wdtclksel    : 3; 
N          __IO uint32_t wdten        : 1; // WDT Enable in normal mode 
X          volatile uint32_t wdten        : 1; 
N          __IO uint32_t wdtintren    : 1; // WDT Interrupt Enable  
X          volatile uint32_t wdtintren    : 1; 
N          __IO uint32_t wdtrsten     : 1; // WDT Reset Enable  
X          volatile uint32_t wdtrsten     : 1; 
N          __IO uint32_t wdtreserved  : 2; // WDT reserved
X          volatile uint32_t wdtreserved  : 2; 
N          __I  uint32_t wdtovf       : 1; // WDT count overflow
X          volatile const  uint32_t wdtovf       : 1; 
N          __I  uint32_t wdtintrout   : 1; // WDT interrupt out
X          volatile const  uint32_t wdtintrout   : 1; 
N          __I  uint32_t wdtrstout    : 1; // WDT reset out
X          volatile const  uint32_t wdtrstout    : 1; 
N      } WDT_CON_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_WIDTH;		// 0x0C	WDT Period Value		  0xFFFF_FFFF 
X	    volatile uint32_t	WDT_WIDTH;		
N      
N      struct {
N          __IO uint32_t wdtwidth : 16; // WDT timer period
X          volatile uint32_t wdtwidth : 16; 
N          __I  uint32_t wdttmcnt : 16; // WDT timer count
X          volatile const  uint32_t wdttmcnt : 16; 
N      } WDT_WIDTH_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_RST_DLY;	// 0x10	Reset Delay.			    0xFFFF_FFFF 
X	    volatile uint32_t	WDT_RST_DLY;	
N      
N      struct {
N          __IO uint32_t rstdlywidth : 16; // WDT Reset delay Width 
X          volatile uint32_t rstdlywidth : 16; 
N          __I  uint32_t rstdlycnt   : 16; // WDT Reset delay count
X          volatile const  uint32_t rstdlycnt   : 16; 
N      } WDT_RST_DLY_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_RST_DUR;	// 0x14	Reset Duration			  0x0000_00FF 
X	    volatile uint32_t	WDT_RST_DUR;	
N      
N      struct {
N          __IO uint32_t rstdlywidth : 4; // WDT Reset delay Width 
X          volatile uint32_t rstdlywidth : 4; 
N          __I  uint32_t rstdlycnt   : 4; // WDT Reset delay count
X          volatile const  uint32_t rstdlycnt   : 4; 
N      } WDT_RST_DUR_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_CLR_DLY;
X	    volatile uint32_t	WDT_CLR_DLY;
N      
N      struct {
N          __IO uint32_t rstdlywidth : 8; // WDT Timer Clear delay Width 
X          volatile uint32_t rstdlywidth : 8; 
N          __IO  uint32_t rstdlycnt   : 1; // WDT Timer Clear delay enable
X          volatile  uint32_t rstdlycnt   : 1; 
N      } WDT_CLR_DLY_b;
N    } ;
N
N} WDT_TypeDef;
N
N
N#endif /* __WDT_H_ */
L 283 "..\..\Hal\system\MFTP.h" 2
N#include "_flitf.h"
L 1 "..\..\Hal\flitf\_flitf.h" 1
N
N/****************************************************************************************************//**
N * @file     flitf.h
N *
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File for
N *           default mtlp Device Series
N *
N * @version  Vrev.B
N * @date     19. April 2013
N *
N * @note     
N *
N * @par      ARM Limited (ARM) is supplying this software for use with Cortex-M
N *           processor based microcontroller, but can be equally used for other
N *           suitable processor architectures. This file can be freely distributed.
N *           Modifications to this file shall be clearly marked.
N *           
N *           THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N *           OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N *           MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N *           ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N *           CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
N *
N *******************************************************************************************************/
N
N
N
N/* ================================================================================ */
N/* ================                     FLITF                      ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  FLITF Register Map
N */
N#define FLITFCTRL_COMMAND_FLASH_NONE			(0x00)
N#define FLITFCTRL_COMMAND_FLASH_PAGE_ERASE		(0x01)
N#define FLITFCTRL_COMMAND_FLASH_MASS_ERASE		(0x02)
N#define FLITFCTRL_COMMAND_FLASH_WRITE			(0x03)
N#define FLITFCTRL_COMMAND_FLASH_READ			(0x04)
N#define FLITFCTRL_COMMAND_FLASH_GET_VERIFY		(0x05)
N#define FLITFCTRL_COMMAND_FLASH_ENTER_IAP_MODE	(0x06)
N#define FLITFCTRL_COMMAND_FLASH_EXIT_IAP_MODE	(0x07)
N#define FLITFCTRL_COMMAND_FLASH_4KB_UPDATE_MODE	(0x08)
N
N#define FLASHCTRL_STATUS_NONE					(0x00)
N#define FLASHCTRL_STATUS_SUCCESS				(0x01)
N#define FLASHCTRL_STATUS_PAGE_ERASE_FAILED		(0x02)
N#define FLASHCTRL_STATUS_PAGE_WRITE_FAILED		(0x03)
N#define FLASHCTRL_STATUS_PAFE_READ_FAILED		(0x03)
N
Nextern void hal_flitf_init(void);
Nextern void hal_flitf_process(void);
Nextern void hal_flitf_another_process(void);
N#if defined(USE_BOOTLOADER_16KB)
X#if 1L
Nextern void FLASH_Write(uint32_t addr, uint32_t val);
Nextern uint32_t FLASH_Read(uint32_t addr);
N#endif /* (USE_BOOTLOADER_16KB) */
N
Ntypedef struct
N{
N	uint32_t addr;
N	uint16_t size;
N	volatile uint8_t status;
N	volatile uint8_t cmd;
N} __attribute__ ((packed)) tFlashIAPCmd_t;
N
Ntypedef struct
N{
N	tFlashIAPCmd_t * Ctrl;
N} tFlashIAPPacket_t;
N
Nextern tFlashIAPPacket_t tFlashIAPPacket;
N
N#define FLASH_WRITE_SIZE	128
N#define	DFUP_BUFFER_SIZE	4096
Nextern uint8_t DFUP_BUFFER[DFUP_BUFFER_SIZE];
Xextern uint8_t DFUP_BUFFER[4096];
Ntypedef struct
N{
N	union
N    {	
N       uint32_t FACR;	
N		
N		struct {
N			uint32_t LATENCY				:4;
N            uint32_t RESERVED0			:28;
N        } FACR_b ;
N    };
N
N	
N	uint32_t FKEYR;                  // 0x0004 | FCR register write enable KEY1/KEY2
N	uint32_t FOPTKEYR;               // 0x0008 | Reserved
N	union 
N    {	
N       uint32_t FSR;                    // 0x000C | Status register      
N		
N		struct{
N			uint32_t NVSTR         :1 ; //FSR[ 0]
N			uint32_t RSVD3         :1 ; //FSR[ 1]
N			uint32_t PGERR         :1 ; //FSR[ 2]
N			uint32_t RSVD2         :1 ; //FSR[ 3]
N			uint32_t RSVD1         :1 ; //FSR[ 4]
N			uint32_t EOP           :1 ; //FSR[ 5]
N			uint32_t INT_FLITF     :1 ; //FSR[ 6]
N			uint32_t RSVD0         :1 ; //FSR[ 7]
N			uint32_t key1_ok       :1 ; //FSR[ 8]
N			uint32_t key2_ok       :1 ; //FSR[ 9]
N			uint32_t optkey1_ok    :1 ; //FSR[10]
N			uint32_t optkey2_ok    :1 ; //FSR[11]
N			uint32_t ISP_MODE      :1 ; //FSR[12]
N			uint32_t ISP_REGISTER  :1 ; //FSR[13]
N			uint32_t AHBPATH_EN    :1 ; //FSR[14]
N			uint32_t INFOBLK_LOAD  :1 ; //FSR[15]
N			uint32_t STANDBY       :1 ; //FSR[16]
N			uint32_t WFIC_EN       :1 ; //FSR[17]
N			uint32_t OE            :1 ; //FSR[18]
N			uint32_t CS            :1 ; //FSR[19]
N			uint32_t fsm_wfirgset  :1 ; //FSR[20]
N			uint32_t fsm_rdmd      :1 ; //FSR[21]
N			uint32_t fsm_wrmd      :1 ; //FSR[22]
N			uint32_t fsm_scer      :1 ; //FSR[23]
N			uint32_t fsm_mcer      :1 ; //FSR[24]
N			uint32_t fsm_wfic      :1 ; //FSR[25]
N			uint32_t fsm_isp       :1 ; //FSR[26]
N			uint32_t fsm_ifmd      :1 ; //FSR[27]
N			uint32_t fsm_ifbrd     :1 ; //FSR[28]
N			uint32_t fsm_idle      :1 ; //FSR[29]  
N			uint32_t fsm_bist      :1 ; //FSR[30]
N			uint32_t BIST_MODE     :1 ; //FSR[31] 
N		} FSR_b ;
N	};
N
N	union 
N    {		
N		uint32_t FCR;                    // 0x0010 | Control register             
N		struct{
N			uint32_t PG               :1 ;//FCR[ 0]   program
N			uint32_t PER              :1 ;//FCR[ 1]   page erase 
N			uint32_t MER              :1 ;//FCR[ 2]   macro erase
N			uint32_t READ_             :1 ;//FCR[ 3]   read operation
N			uint32_t RSVD0            :2 ;//FCR[5:4]  
N			uint32_t STRT             :1 ;//FCR[ 6]   operation start 
N			uint32_t LOCK             :1 ;//FCR[ 7]   control register write lock : write '1' is only 
N			uint32_t WFRGSET          :1 ;//FCR[ 8]   WFIC mode register setting mode 
N			uint32_t WFIETEN          :1 ;//FCR[ 9]   WFIC mode Enter Enable
N			uint32_t ERRIE            :1 ;//FCR[10]   error interrupt enable 
N			uint32_t RSVD1            :1 ;//FCR[11]   
N			uint32_t EOPIE            :1 ;//FCR[12]   end of operation interrupt enable
N			uint32_t CS_TIE_LOW       :1 ;//FCR[13]   CS Tie Low
N			uint32_t CS_SLP           :1 ;//FCR[14]   CS Controlled by SLEEP signal
N			uint32_t FCR_CE_OPTEN     :1 ;//FCR[15]   CE option control enable (ONLY use in PT measuring cell current) 
N			uint32_t FCR_CE_OPTVAL    :1 ;//FCR[16]   CE option control value (ONLY use in PT measuring cell current) 
N			uint32_t PRFTEN_FCR       :1 ;//FCR[17]   
N			uint32_t RSVD3            :4 ;//FCR[21:18]   
N			uint32_t OTFLTPG_DIS      :1 ;//FCR[22]    On the fly latency programming disable
N			uint32_t CACHE_EN_FCR     :1 ;//FCR[23]    Cache Enable !!! 
N			uint32_t ALTRDEN_FCR      :1 ;//FCR[24]    Cache Enable !!! 
N			uint32_t RSVD4            :5 ;//FCR[29:25]
N			uint32_t IFMDCGEN         :1 ;//FCR[30]    Mode Change Enable, 0 (default) : Option Byte select, 1: r_FCR register select
N			uint32_t NVSSEL           :1 ;//FCR[31]    NVSTR drive select, 0 : TBIT , 1 : Self Count 
N		} FCR_b ;
N	};
N	
N       uint32_t FAR;                    // 0x0014 | Address register 
N	
N	union 
N    {				
N		uint32_t FCR1;                   // 0x0018 | Control register1 
N		struct{
N			uint32_t FCR1_INF         :1 ;//FCR1[0]     INF signal value 
N			uint32_t FCR1_SAVEN       :1 ;//FCR1[1]     SAVEN signal value 
N			uint32_t FCR1_WRONLY      :1 ;//FCR1[2]     WRONLY signal value 
N			uint32_t FCR1_PROG        :1 ;//FCR1[3]     PROG signal value 
N			uint32_t FCR1_PERASE      :1 ;//FCR1[4]     PERASE signal value 
N			uint32_t FCR1_SERASE      :1 ;//FCR1[5]     SERASE signal value 
N			uint32_t FCR1_SAV_SRCSEL  :1 ;//FCR1[6]     SAV_SRCSEL signal value 
N			uint32_t RSVD0            :1 ;//FCR1[7]   
N			uint32_t FCR1_TM          :4 ;//FCR1[11:8]  TM signal value    
N		} FCR1_b ;
N	};
N	
N	union 
N    {		
N		uint32_t FCR2;                   // 0x001C | Control register2
N		struct{
N			uint32_t FCR2_PGM_BYTE_LEN:5 ;//FCR2[4:0]   Byte & Page program and Page write data length
N			uint32_t RSVD0											:2; //FCR2[6:5]
N			uint32_t FCR2_SFR_WREN    :1 ;//FCR2[5]     SFR or non SFR write selection                
N		} FCR2_b ;
N	};
N
N		uint32_t Reserved0;              // 0x0020 | Reserved 
N		uint32_t Reserved1;              // 0x0024 | Reserved
N		uint32_t FWDRLW;                 // 0x0028 | Write Data Buffer Register0
N		uint32_t FACR1;                  // 0x002C | Access Control Register1
N		uint32_t FRDRLW;                 // 0x0030 | Read Data Buffer Register Low Word
N		uint32_t Reserved3;              // 0x0034 | Reserved
N		uint32_t PGERSR0;                // 0x0038 | Page Erase Status  Register 0 
N		uint32_t PGERSR1;                // 0x003C | Page Erase Status  Register 1
N		uint32_t PGERSR2;                // 0x0040 | Page Erase Status  Register 2 
N		uint32_t PGERSR3;                // 0x0044 | Page Erase Status  Register 3 
N
N	union 
N    {		
N		uint32_t ERRESPCR;               // 0x0048 | Error Response Control Register
N		struct{
N			uint32_t EN_KEY1:1 ;
N			uint32_t EN_KEY2    :1 ;
N			uint32_t EN_OPTKEY1    :1 ;
N			uint32_t EN_OPTKEY2    :1 ;
N			uint32_t EN_LOCK_WR0    :1 ;
N			uint32_t RSVD0            :1 ;
N			uint32_t EN_FAR_DW    :1 ;
N			uint32_t EN_FRDRLW    :1 ;
N		} ERRESPCR_b ;
N	};
N
N		uint32_t ISPMSCR;                // 0x004C | SW ISP Mode config register
N		uint32_t EXTRASCR0;              // 0x0050 | Extra System Configuration 0 
N		uint32_t EXTRASCR1;              // 0x0054 | Extra System Configuration 1 
N		uint32_t EXTRASCR2;              // 0x0058 | Extra System Configuration 2 
N		uint32_t EXTRASCR3;              // 0x005C | Extra System Configuration 3 
N		uint32_t PROTECTION;             // 0x0060 | READ data protection
N		uint32_t PGERSR4;                // 0x0064 | Page Erase Status  Register 4 
N		uint32_t PGERSR5;                // 0x0068 | Page Erase Status  Register 5
N		uint32_t PGERSR6;                // 0x006C | Page Erase Status  Register 6 
N		uint32_t PGERSR7;                // 0x0070 | Page Erase Status  Register 7 
N		uint32_t PGERSR8;                // 0x0074 | Page Erase Status  Register 8 
N		uint32_t PGERSR9;                // 0x0078 | Page Erase Status  Register 9 
N		uint32_t PGERSR10;               // 0x007C | Page Erase Status  Register 10 
N		uint32_t IFBRD_TCNT_END;         // 0x0080 | Flash Control signal timing tuning register
N		uint32_t MCER_TCNT_END;          // 0x0084 | Flash Control signal timing tuning register
N		uint32_t SCER_TCNT_END;          // 0x0088 | Flash Control signal timing tuning register
N		uint32_t WRMD_TCNT_END;          // 0x008C | Flash Control signal timing tuning register
N		uint32_t RDMD_TCNT_END;          // 0x0090 | Flash Control signal timing tuning register
N		uint32_t AE_IFBRD_STR;           // 0x0094 | Flash Control signal timing tuning register
N		uint32_t AE_MCER_STR;            // 0x0098 | Flash Control signal timing tuning register
N		uint32_t AE_SCER_STR;            // 0x009C | Flash Control signal timing tuning register
N		uint32_t AE_WRMD_STR;            // 0x00A0 | Flash Control signal timing tuning register
N		uint32_t AE_RDMD_STR;            // 0x00A4 | Flash Control signal timing tuning register
N		uint32_t AE_IFBRD_END;           // 0x00A8 | Flash Control signal timing tuning register
N		uint32_t AE_MCER_END;            // 0x00AC | Flash Control signal timing tuning register
N		uint32_t AE_SCER_END;            // 0x00B0 | Flash Control signal timing tuning register
N		uint32_t AE_WRMD_END;            // 0x00B4 | Flash Control signal timing tuning register
N		uint32_t AE_RDMD_END;            // 0x00B8 | Flash Control signal timing tuning register
N		uint32_t NVSTR_MCER_STR;         // 0x00BC | Flash Control signal timing tuning register
N		uint32_t NVSTR_SCER_STR;         // 0x00C0 | Flash Control signal timing tuning register
N		uint32_t NVSTR_WRMD_STR;         // 0x00C4 | Flash Control signal timing tuning register
N		uint32_t NVSTR_MCER_LTH;         // 0x00C8 | Flash Control signal timing tuning register
N		uint32_t NVSTR_SCER_LTH;         // 0x00CC | Flash Control signal timing tuning register
N		uint32_t NVSTR_WRMD_LTH;         // 0x00D0 | Flash Control signal timing tuning register
N		uint32_t DOUTVALID_IFBRD;        // 0x00D4 | Flash Control signal timing tuning register
N		uint32_t DOUTVALID_RDMD;         // 0x00D8 | Flash Control signal timing tuning register
N		uint32_t A17_WRMD_STR;           // 0x00DC | Flash Control signal timing tuning register
N		uint32_t A17_WRMD_END;           // 0x00E0 | Flash Control signal timing tuning register
N		uint32_t WFRGST_TCNT_END;        // 0x00E4 | Flash Control signal timing tuning register
N		uint32_t DBGR;                   // 0x00E8 | Flash Debug register
N	union 
N    {
N		uint32_t BCR;                    // 0x00EC | Flash BIST : Page Number
N		struct{
N			uint32_t RSVD0            :5 ;
N			uint32_t NB_PG_NUM:10 ;
N			uint32_t RSVD1            :6 ;
N			uint32_t INFO_PG_NUM    :10 ;
N		} BCR_b ;
N	};
N		uint32_t BWDRLW;                 // 0x00F0 | Flash BIST Data register
N		uint32_t FSM_INIT;               // 0x00F4 | Reserved
N	union 
N    {	
N		uint32_t BSCR;                   // 0x00F8 | Flash BIST Control register
N		struct{
N			uint32_t NERASE_EN            :1 ;
N			uint32_t NERRD_EN:1 ;
N			uint32_t NPG_EN            :1 ;
N			uint32_t NPGRD_EN    :1 ;
N			uint32_t IERASE_EN    :1 ;
N			uint32_t IERRD_EN    :1 ;
N			uint32_t IPG_EN    :1 ;
N			uint32_t IPGRD_EN    :1 ;
N			uint32_t SECTOR_NUM    :1 ;
N		} BSCR_b ;
N	};
N		uint32_t DEVID;                  // 0x00FC | Device ID
N		uint32_t FWDRLW01;               // 0x0100 | Write Data Buffer Register01
N		uint32_t FWDRLW02;               // 0x0104 | Write Data Buffer Register02
N		uint32_t FWDRLW03;               // 0x0108 | Write Data Buffer Register03
N		uint32_t FWDRLW04;               // 0x010C | Write Data Buffer Register04
N		uint32_t FWDRLW05;               // 0x0110 | Write Data Buffer Register05
N		uint32_t FWDRLW06;               // 0x0114 | Write Data Buffer Register06
N		uint32_t FWDRLW07;               // 0x0118 | Write Data Buffer Register07
N		uint32_t FWDRLW08;               // 0x011C | Write Data Buffer Register08
N		uint32_t FWDRLW09;               // 0x0120 | Write Data Buffer Register09
N		uint32_t FWDRLW10;               // 0x0124 | Write Data Buffer Register10
N		uint32_t FWDRLW11;               // 0x0128 | Write Data Buffer Register11
N		uint32_t FWDRLW12;               // 0x012C | Write Data Buffer Register12
N		uint32_t FWDRLW13;               // 0x0130 | Write Data Buffer Register13
N		uint32_t FWDRLW14;               // 0x0134 | Write Data Buffer Register14
N		uint32_t FWDRLW15;               // 0x0138 | Write Data Buffer Register15
N		uint32_t FWDRLW16;               // 0x013C | Write Data Buffer Register16
N		uint32_t FWDRLW17;               // 0x0140 | Write Data Buffer Register17
N		uint32_t FWDRLW18;               // 0x0144 | Write Data Buffer Register18
N		uint32_t FWDRLW19;               // 0x0148 | Write Data Buffer Register19
N		uint32_t FWDRLW20;               // 0x014C | Write Data Buffer Register20
N		uint32_t FWDRLW21;               // 0x0150 | Write Data Buffer Register21
N		uint32_t FWDRLW22;               // 0x0154 | Write Data Buffer Register22
N		uint32_t FWDRLW23;               // 0x0158 | Write Data Buffer Register23
N		uint32_t FWDRLW24;               // 0x015C | Write Data Buffer Register24
N		uint32_t FWDRLW25;               // 0x0160 | Write Data Buffer Register25
N		uint32_t FWDRLW26;               // 0x0164 | Write Data Buffer Register26
N		uint32_t FWDRLW27;               // 0x0168 | Write Data Buffer Register27
N		uint32_t FWDRLW28;               // 0x016C | Write Data Buffer Register28
N		uint32_t FWDRLW29;               // 0x0170 | Write Data Buffer Register29
N		uint32_t FWDRLW30;               // 0x0174 | Write Data Buffer Register30
N		uint32_t FWDRLW31;               // 0x0178 | Write Data Buffer Register31
N		uint32_t PGERSR11;               // 0x017C | Page Erase Status  Register 11
N		uint32_t PGERSR12;               // 0x0180 | Page Erase Status  Register 12
N		uint32_t PGERSR13;               // 0x0184 | Page Erase Status  Register 13
N		uint32_t PGERSR14;               // 0x0188 | Page Erase Status  Register 14
N		uint32_t PGERSR15;               // 0x018C | Page Erase Status  Register 15
N		uint32_t PGERSR16;               // 0x0190 | Page Erase Status  Register 16
N		uint32_t PGERSR17;               // 0x0194 | Page Erase Status  Register 17
N		uint32_t PGERSR18;               // 0x0198 | Page Erase Status  Register 18
N		uint32_t PGERSR19;               // 0x019C | Page Erase Status  Register 19
N		uint32_t PGERSR20;               // 0x01A0 | Page Erase Status  Register 20
N		uint32_t PGERSR21;               // 0x01A4 | Page Erase Status  Register 21
N		uint32_t PGERSR22;               // 0x01A8 | Page Erase Status  Register 22
N		uint32_t PGERSR23;               // 0x01AC | Page Erase Status  Register 23
N		uint32_t PGERSR24;               // 0x01B0 | Page Erase Status  Register 24
N		uint32_t PGERSR25;               // 0x01B4 | Page Erase Status  Register 25
N		uint32_t PGERSR26;               // 0x01B8 | Page Erase Status  Register 26
N		uint32_t PGERSR27;               // 0x01BC | Page Erase Status  Register 27
N		uint32_t PGERSR28;               // 0x01C0 | Page Erase Status  Register 28
N		uint32_t PGERSR29;               // 0x01C4 | Page Erase Status  Register 29
N		uint32_t PGERSR30;               // 0x01C8 | Page Erase Status  Register 30
N		uint32_t PGERSR31;               // 0x01CC | Page Erase Status  Register 31
N} FLITF_TypeDef ;
N
Ntypedef struct
N{
N
N  union {
N    __I  uint32_t  CALIB_OSC  ;       
X    volatile const  uint32_t  CALIB_OSC  ;       
N    
N    struct {
N      __I  uint32_t  R_FINE   :  4;  
X      volatile const  uint32_t  R_FINE   :  4;  
N      __I  uint32_t  R_COARSE :  4;  
X      volatile const  uint32_t  R_COARSE :  4;  
N    } CALIB_OSC_b;                      
N  } ;
N
N
N  union {
N    __I  uint32_t  CALIB_LDO ;       
X    volatile const  uint32_t  CALIB_LDO ;       
N    
N    struct {
N      __I  uint32_t  CAL_SEL :  4;  
X      volatile const  uint32_t  CAL_SEL :  4;  
N    } CALIB_LDO_b;                      
N  } ;
N
N
N} INFO_TypeDef;
N
N//ECCBOOT_v3.00 : CRC Info
Ntypedef struct
N{	
N	uint32_t CRC_1;   
N	uint32_t CRC_2;   
N	
N} BACKUP_CRC_TypeDef;
N
N//ECCBOOT_v3.00 : Back-Up Info
Ntypedef struct
N{	
N	union {
N		uint32_t I2C_BOOT_INFO;
N
N		struct {
N			uint32_t	DUMMY			:  8;
N			uint32_t	I2C_SADDR		:  8;
N			uint32_t	BOOT_VERSION	:  16;
N		} I2C_BOOT_INFO_b;
N	};
N
N	union {
N		uint32_t VID_PID_INFO;
N
N		struct {
N			uint32_t	VID_INFO		:  16;
N			uint32_t	PID_INFO		:  16;
N		} VID_PID_INFO_b;
N	};
N	
N} BACKUP_INFO_TypeDef;
N
N//ECCBOOT_v3.00 : Back-Up Info Error
Ntypedef struct
N{	
N	union {
N		uint32_t BACKUP_INFO_ERROR;
N
N		struct {
N			uint32_t	I2C_INFO_ERROR		:  8;
N			uint32_t	BOOT_VER_ERROR		:  8;
N			uint32_t	VID_INFO_ERROR		:  8;
N			uint32_t	PID_INFO_ERROR		:  8;
N		} BACKUP_INFO_ERROR_b;
N	};
N	
N} BACKUP_INFO_ERROR_TypeDef, *P_BACKUP_INFO_ERROR_TypeDef;
L 284 "..\..\Hal\system\MFTP.h" 2
N#include "_mspi.h"
L 1 "..\..\Hal\spi\_mspi.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _mspi.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __MSPI_H_
N#define __MSPI_H_
N
N
N#include "mspi_.h"
L 1 "..\..\Hal\spi\mspi_.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : mspi_.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MSPI__H_
N#define _MSPI__H_
N
N
N//----------------------------------------------------------------------------------------------
N// SPI CR register setting parameters
N//----------------------------------------------------------------------------------------------
N#define bitLen8			(0)
N#define bitLen10		(1)
N#define bitLen12		(2)
N#define bitLen16		(3)
N#define mosiOutEn		(1)
N#define mosiOutDis		(0)
N#define CphaIs0			(0)
N#define CphaIs1			(1)
N#define CpolIs0			(0)
N#define CpolIs1			(1)
N#define spiMstMode		(1)
N#define spiSlvMode		(0)
N#define LsbFirst		(1)
N#define MsbFirst		(0)
N#define spiEna			(1)
N#define spiDis			(0)
N
N//----------------------------------------------------------------------------------------------
N// SPI FIFO CR register setting parameters
N//----------------------------------------------------------------------------------------------
N#define FifoTxClr		(1)
N#define FifoTxLet		(0)
N#define FifoRxClr		(1)
N#define FifoRxLet		(0)
N#define FifoRxWmLv31	(31)
N#define FifoRxWmLv16	(16)
N#define FifoRxWmLv08	(8)
N#define FifoRxWmLv02	(2)
N#define FifoRxWmLv01	(1)
N#define FifoRxWmLv00	(0)
N#define FifoTxWmLv31	(31)
N#define FifoTxWmLv16	(16)
N#define FifoTxWmLv08 	(8)
N#define FifoTxWmLv02 	(2)
N#define FifoTxWmLv01 	(1)
N#define FifoTxWmLv00 	(0)
N#define FifoTxDmaEna 	(1)
N#define FifoTxDmaDis 	(0)
N#define FifoRxDmaEna 	(1)
N#define FifoRxDmaDis 	(0)
N#define FifoTxErrClr 	(1)
N#define FifoTxErrLet 	(0)
N#define FifoRxErrClr 	(1)
N#define FifoRxErrLet 	(0)
N
N//----------------------------------------------------------------------------------------------
N// SPI Enalbe & Transfer Size register setting parameters
N//----------------------------------------------------------------------------------------------
N#define spi0TxEna 		(1)
N#define spi1TxEna 		(1)
N#define spi2TxEna 		(1)
N#define spi3TxEna 		(1)
N#define spi4TxEna 		(1)
N#define spi5TxEna 		(1)
N
N#define spi0TxDis 		(0)
N#define spi1TxDis 		(0)
N#define spi2TxDis 		(0)
N#define spi3TxDis 		(0)
N#define spi4TxDis 		(0)
N#define spi5TxDis 		(0)
N
N#define spi0RxEna 		(1)
N#define spi1RxEna 		(1)
N#define spi2RxEna 		(1)
N#define spi3RxEna 		(1)
N#define spi4RxEna 		(1)
N#define spi5RxEna 		(1)
N
N#define spi0RxDis 		(0)
N#define spi1RxDis 		(0)
N#define spi2RxDis 		(0)
N#define spi3RxDis 		(0)
N#define spi4RxDis 		(0)
N#define spi5RxDis 		(0)
N
N#define TxEna0 			(1)
N#define TxEna1 			(1)
N#define TxEna2 			(1)
N#define TxEna3 			(1)
N#define TxEna4 			(1)
N#define TxEna5 			(1)
N
N#define TxDis0 			(0)
N#define TxDis1 			(0)
N#define TxDis2 			(0)
N#define TxDis3 			(0)
N#define TxDis4 			(0)
N#define TxDis5 			(0)
N
N#define RxEna0 			(1)
N#define RxEna1 			(1)
N#define RxEna2 			(1)
N#define RxEna3 			(1)
N#define RxEna4 			(1)
N#define RxEna5 			(1)
N
N#define RxDis0 			(0)
N#define RxDis1 			(0)
N#define RxDis2 			(0)
N#define RxDis3 			(0)
N#define RxDis4 			(0)
N#define RxDis5 			(0)
N
N#define spi0TrSze 		(8)
N#define spi1TrSze 		(8)
N#define spi2TrSze 		(8)
N#define spi3TrSze 		(8)
N#define spi4TrSze 		(8)
N#define spi5TrSze 		(8)
N
N//----------------------------------------------------------------------------------------------
N// SPI Each State length setting parameters
N//----------------------------------------------------------------------------------------------
N#define spiPreShftLenIs2  		(2)
N#define spiTmpIdleLenIs2  		(2)
N#define spiPostShftLenIs2 		(2)
N#define spiPostShftLenIs4 		(4)
N#define spiPostShftLenIs5 		(5)
N#define spiPostShftLenIs6 		(6)
N#define spiPostShftLenIs8 		(8)
N#define spiPostShftLenIsF 		(15)
N#define spiSnglIdleLenIs2 		(2)
N#define spiAitIdleLenIs2 		(2)
N#define spiAitIdleLenIs8 		(8)
N#define spiAitIdleLenIs9 		(9)
N
N//----------------------------------------------------------------------------------------------
N// SPI Operation Start Command register setting 
N//----------------------------------------------------------------------------------------------
N#define spiStartAll 			(63)
N#define spiStart0 				(1)
N#define spiStart1 				(2)
N#define spiStart2 				(4)
N#define spiStart3 				(8)
N#define spiStart4 				(16)
N#define spiStart5 				(32)
N
N//----------------------------------------------------------------------------------------------
N// SPI Operation Mode register setting 
N//----------------------------------------------------------------------------------------------
N#define spiTlpMode 				0
N#define spiAitMode 				1
N#define spiFifoMode 0
N#define spiSramMode 1
N#define spiSwMode 0
N#define spiHwMode 1
N#define spiSnglMode 1
N#define spiBrstMode 1
N#define spiSramNormMode 0
N#define spiSramDebugMode 1
N#define spiSramWrDefault 0
N#define spiSramWrOpt 1
N#define spiTrsPerWr0 0
N#define spiTrsPerWr1 1
N#define spiTrsPerWr2 2
N#define spiTrsPerRd0 0
N#define spiTrsPerRd1 1
N#define spiTrsPerRd2 2
N#define spiPwfe0Sel 0
N#define spiPwfe1Sel 1
N#define spiPwfe2Sel 2
N#define spiPwfe3Sel 3
N#define spiPwfe4Sel 4
N#define spiPwfe5Sel 5
N#define spiCommPwfeSel 1
N#define spiEachPwfeSel 0
N#define spiNonProtocol 0
N#define spiTlpProtocol 1
N#define spiHatProtocol 2
N#define spiRdHlfWrdLsbFrst 0
N#define spiRdHlfWrdMsbFrst 1
N#define spiWrHlfWrdLsbFrst 0
N#define spiWrHlfWrdMsbFrst 1
N
N//----------------------------------------------------------------------------------------------
N// SPI example pattern for Optional Write Mode
N//----------------------------------------------------------------------------------------------
N#define spiStrtWAd0 7
N#define spiStrtWAd1 115
N#define spiStrtWAd2 231
N#define spiStrtWAd3 364
N#define spiStrtWAd4 528
N#define spiStrtWAd5 755
N
N#define spiStrtRAd0 1007
N#define spiStrtRAd1 1115
N#define spiStrtRAd2 1231
N#define spiStrtRAd3 1364
N#define spiStrtRAd4 1528
N#define spiStrtRAd5 1755
N
N#define spiStrtDin0 99
N#define spiStrtDin1 55
N#define spiStrtDin2 33
N#define spiStrtDin3 66
N#define spiStrtDin4 1010
N#define spiStrtDin5 1212
N
N//----------------------------------------------------------------------------------------------
N// SPI Interrupt Masking register setting
N//----------------------------------------------------------------------------------------------
N#define IntrAitWlvEna 1
N#define IntrAitWlvDis 0
N#define IntrMemEna 1
N#define IntrMemDis 0
N#define IntrRoriEna 1
N#define IntrRoriDis 0
N#define IntrToriEna 1
N#define IntrToriDis 0
N#define IntrRxuriEna 1
N#define IntrRxuriDis 0
N#define IntrTxuriEna 1
N#define IntrTxuriDis 0
N#define IntrRxiEna 1
N#define IntrRxiDis 0
N#define IntrTxiEna 1
N#define IntrTxiDis 0
N
N//----------------------------------------------------------------------------------------------
N// TLP/HAT SPIS regiser setting             
N//----------------------------------------------------------------------------------------------
N#define SensBase 0
N#define RefrBase 4
N#define CfgrBase 8
N#define TlpWrite 0
N#define TlpRead  1
N#define TlpBulk  0
N#define TlpSngl  1 
N
N#define HatSensBase 0
N#define HatRefrBase 4
N#define HatCfgrBase 8
N#define HatWrite 0
N#define HatRead  1
N#define HatBulk  0
N#define HatSngl  1 
N
N#define TlpAddr0 0 
N#define TlpAddr2 2 
N#define TlpAddr4 4 
N#define TlpAddr6 6 
N
N#define TlpAddr8 8 
N#define TlpAddrA 10 
N#define TlpAddrC 12 
N#define TlpAddrE 14 
N
N#define HatAddr0 0 
N#define HatAddr2 2 
N#define HatAddr4 4 
N#define HatAddr6 6 
N
N#define HatAddr8 8 
N#define HatAddrA 10 
N#define HatAddrC 12 
N#define HatAddrE 14
N
N#define TlpWDat0 0
N
N#define HatWDat0 0
N
N//#define HatIndvl 8'h40
N//#define HatIndvl 8'h41
N
N
N#define spiAitWlvEna 1
N#define spiAitWlvDis 0
N#define spiAitWlvSel0 0
N#define spiAitWlvSel1 1
N#define spiAitWlvSel2 2
N#define spiAitWlvSel3 3
N#define spiAitWlvSel4 4
N#define spiAitWlvSel5 5
N
N#define AitDmyDelEna 1
N#define AitDmyDelDis 0
N
N//----------------------------------------------------------------------------------------------
N// RAIT SPIS regiser setting             
N//----------------------------------------------------------------------------------------------
N#define AlgnLbuf 0
N#define Ait0Lbuf 1
N#define Ait1Lbuf 2
N#define AitCfgr0 3
N#define AitCfgr1 4
N
N#define AitWrite 0
N#define AitRead  1
N#define AitBulk  0
N#define AitSngl  1 
N
N#define AitAddr0 0 
N#define AitAddr2 2 
N#define AitAddr4 4 
N#define AitAddr6 6 
N
N#define MdIdle   0
N#define SnrStr   2
N#define MdGnrl   4
N#define AipAdc   6
N#define SsuCtrl  8
N#define TsyncNum0 10
N#define TsyncNum1 12
N#define TsyncDmy1 14
N#define PwmNum0   16
N#define PwmNum1   18 
N#define CmuxNrm   20 
N#define CmuxNse   22 
N//#define ColNum    24 
N//#define RowNum    26 
N#define DigGain0  28 
N#define DigGain1  30 
N#define NihMin0   32 
N#define NihMax0   34 
N#define NihMin1   36 
N#define NihMax1   38 
N#define NihMin2   40 
N#define NihMax2   42 
N#define NihMin3   44 
N#define NihMax3   46 
N#define NihRdat0  48 
N#define NihRdat1  50 
N#define NihRdat2  52 
N#define NihRdat3  54 
N#define MdSpcl    56 
N#define ShaStr0   58 
N#define ShaStr1   60 
N#define ShaStr2   62 
N#define VcrStr    64 
N#define VcrNum0   66 
N#define VcrNum1   68 
N#define VcrNum2   70 
N#define VcrNum3   72 
N#define VcrNum4   74 
N#define VcrNum5   76 
N
N#define StrTsync0Is0 0 
N#define EndTsync0Is1 1 
N#define StrTsync1Is0 0 
N#define EndTsync1Is1 1 
N#define DmyTsync1Is0 0 
N#define ChMxIntvlIs8 8 
N#define PrePwmNumIs5 5 
N#define SetPwmNumIs1 1 
N#define ActPwmNumIs20 20 
N#define DinPwmNumIs4 4 
N#define StrCmxNumIs0 0 
N#define EndCmxNumIs15 15 
N#define Ni1CmxNumIs8 8 
N#define Ni2CmxNumIs8 8 
N#define StrColNumIs0 0 
N#define EndColNumIs6 6 
N#define EndColNumIs19 19 
N#define ColLen0IsIs7 7 
N#define ColLen1IsIs7 7 
N#define ColLen0Is15 15 
N#define ColLen1Is15 15 
N#define ColLen0Is20 20 
N#define ColLen1Is20 20 
N#define EndRowNumIs49 49 
N#define TopOuterEna  1 
N#define TopOuterDis  0 
N#define BotOuterEna  1 
N#define BotOuterDis  0 
N#define LefOuterEna  1 
N#define LefOuterDis  0 
N#define RghtOuterEna  1 
N#define RghtOuterDis  0 
N
N
N#endif /* _MSPI__H_ */
L 38 "..\..\Hal\spi\_mspi.h" 2
N
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t BITLEN			:2;			  // Bit Length 							  2    00:8bit, 01:10Bit, 02:12Bit, 03:16Bit
X		volatile uint32_t BITLEN			:2;			  
N		__IO uint32_t DOUTEN			:1;			  // Data Out Enable						  3    1:MOSI Enable, 0:Disable
X		volatile uint32_t DOUTEN			:1;			  
N		__IO uint32_t CPHA				:1;			  // Clock Phase							  4    1:Leading Edge - Setup, Trailing Edge - Sample,	 0: Leading Edge - Sample, Trailing Edge - Setup
X		volatile uint32_t CPHA				:1;			  
N		__IO uint32_t CPOL				:1;			  // Clock Polarity 						  5    1:Leading Edge - Falling, Trailing Edge - Rising,   0:Leading Edge - Rising, Trailing Edge - Falling
X		volatile uint32_t CPOL				:1;			  
N		__IO uint32_t MSTR				:1;			  // Mster/Slave Select 					  6    1:Master, 0:Slave
X		volatile uint32_t MSTR				:1;			  
N		__IO uint32_t DORD              :1;			  // Data Order 							  7    1:LSB First, 0:MSB First (Default)
X		volatile uint32_t DORD              :1;			  
N		__IO uint32_t SPE				:1;			  // SPI Enable 							  8
X		volatile uint32_t SPE				:1;			  
N		__IO uint32_t LBM				:1;			  // LooP Back Mode 						  9    1:LOOP_BACK_MODE, 0:Normal Operation
X		volatile uint32_t LBM				:1;			  
N		__IO uint32_t SSOSEL			:1;			  // SSO Select 							  10   1:External Control SSO Signal, 0:Auto Generation SSO SPI Slave Select
X		volatile uint32_t SSOSEL			:1;			  
N		__IO uint32_t SSOEXT			:1;			  // Master SSO Signal Register Setting 	  11   1:Master Slave Select Disable, 0:Master Slave Select Enable
X		volatile uint32_t SSOEXT			:1;			  
N		__I uint32_t RESERVED0			:5;		  	  // Not Used
X		volatile const uint32_t RESERVED0			:5;		  	  
N		__IO uint32_t CKMAXRATE			:3;			  // Not Used
X		volatile uint32_t CKMAXRATE			:3;			  
N		__I uint32_t RESERVED1			:1; 		  // Not Used
X		volatile const uint32_t RESERVED1			:1; 		  
N		__IO uint32_t CKMAXPRE			:3;			  // Not Used
X		volatile uint32_t CKMAXPRE			:3;			  
N		__I uint32_t RESERVED2			:1; 		  // Not Used
X		volatile const uint32_t RESERVED2			:1; 		  
N		__IO uint32_t SWPRST			:1;			  // APB CLK domain block reset						1:Reset, 0,Release
X		volatile uint32_t SWPRST			:1;			  
N		__IO uint32_t SWHRST			:1;			  // AHB CLK domain block reset						1:Reset, 0,Release
X		volatile uint32_t SWHRST			:1;			  
N		__I uint32_t RESERVED3			:6; 		  // Not Used
X		volatile const uint32_t RESERVED3			:6; 		  
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;				  /// 0x0000 | SPI Control register 					  | 0x00000002
X	volatile uint32_t ulBulk;				  
N
N} __PACKED tMSPI_SCR_t;
X} __attribute__ ((packed)) tMSPI_SCR_t;
N
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t spiTxEna0			:1;
X		volatile uint32_t spiTxEna0			:1;
N		__IO uint32_t spiTxEna1			:1;
X		volatile uint32_t spiTxEna1			:1;
N		__IO uint32_t spiTxEna2			:1;
X		volatile uint32_t spiTxEna2			:1;
N		__IO uint32_t spiTxEna3			:1;
X		volatile uint32_t spiTxEna3			:1;
N		__IO uint32_t spiTxEna4			:1;
X		volatile uint32_t spiTxEna4			:1;
N		__IO uint32_t spiTxEna5         :1;
X		volatile uint32_t spiTxEna5         :1;
N		__I uint32_t RESERVED0			:2;
X		volatile const uint32_t RESERVED0			:2;
N		__IO uint32_t spiRxEna0			:1;
X		volatile uint32_t spiRxEna0			:1;
N		__IO uint32_t spiRxEna1			:1;
X		volatile uint32_t spiRxEna1			:1;
N		__IO uint32_t spiRxEna2			:1;
X		volatile uint32_t spiRxEna2			:1;
N		__IO uint32_t spiRxEna3			:1;
X		volatile uint32_t spiRxEna3			:1;
N		__IO uint32_t spiRxEna4			:1;
X		volatile uint32_t spiRxEna4			:1;
N		__IO uint32_t spiRxEna5			:1;
X		volatile uint32_t spiRxEna5			:1;
N		__I uint32_t RESERVED1			:18;
X		volatile const uint32_t RESERVED1			:18;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tMSPI_SPIENA_t;
X} __attribute__ ((packed)) tMSPI_SPIENA_t;
N
N
Ntypedef struct
N{
N	union {
N
N		__IO uint32_t SCR;				  /// 0x0000 | SPI Control register 					  | 0x00000002
X		volatile uint32_t SCR;				  
N
N		struct {
N			__IO uint32_t BITLEN			:2;			  // Bit Length 							  2    00:8bit, 01:10Bit, 02:12Bit, 03:16Bit
X			volatile uint32_t BITLEN			:2;			  
N			__IO uint32_t DOUTEN			:1;			  // Data Out Enable						  3    1:MOSI Enable, 0:Disable
X			volatile uint32_t DOUTEN			:1;			  
N			__IO uint32_t CPHA				:1;			  // Clock Phase							  4    1:Leading Edge - Setup, Trailing Edge - Sample,	 0: Leading Edge - Sample, Trailing Edge - Setup
X			volatile uint32_t CPHA				:1;			  
N			__IO uint32_t CPOL				:1;			  // Clock Polarity 						  5    1:Leading Edge - Falling, Trailing Edge - Rising,   0:Leading Edge - Rising, Trailing Edge - Falling
X			volatile uint32_t CPOL				:1;			  
N			__IO uint32_t MSTR				:1;			  // Mster/Slave Select 					  6    1:Master, 0:Slave
X			volatile uint32_t MSTR				:1;			  
N			__IO uint32_t DORD              :1;			  // Data Order 							  7    1:LSB First, 0:MSB First (Default)
X			volatile uint32_t DORD              :1;			  
N			__IO uint32_t SPE				:1;			  // SPI Enable 							  8
X			volatile uint32_t SPE				:1;			  
N			__IO uint32_t LBM				:1;			  // LooP Back Mode 						  9    1:LOOP_BACK_MODE, 0:Normal Operation
X			volatile uint32_t LBM				:1;			  
N			__IO uint32_t SSOSEL			:1;			  // SSO Select 							  10   1:External Control SSO Signal, 0:Auto Generation SSO SPI Slave Select
X			volatile uint32_t SSOSEL			:1;			  
N			__IO uint32_t SSOEXT			:1;			  // Master SSO Signal Register Setting 	  11   1:Master Slave Select Disable, 0:Master Slave Select Enable
X			volatile uint32_t SSOEXT			:1;			  
N			__I uint32_t RESERVED0			:5;		  	  // Not Used
X			volatile const uint32_t RESERVED0			:5;		  	  
N			__IO uint32_t CKMAXRATE			:3;			  // Not Used
X			volatile uint32_t CKMAXRATE			:3;			  
N			__I uint32_t RESERVED1			:1; 		  // Not Used
X			volatile const uint32_t RESERVED1			:1; 		  
N			__IO uint32_t CKMAXPRE			:3;			  // Not Used
X			volatile uint32_t CKMAXPRE			:3;			  
N			__I uint32_t RESERVED2			:1; 		  // Not Used
X			volatile const uint32_t RESERVED2			:1; 		  
N			__IO uint32_t SWPRST			:1;			  // APB CLK domain block reset						1:Reset, 0,Release
X			volatile uint32_t SWPRST			:1;			  
N			__IO uint32_t SWHRST			:1;			  // AHB CLK domain block reset						1:Reset, 0,Release
X			volatile uint32_t SWHRST			:1;			  
N			__I uint32_t RESERVED3			:6; 		  // Not Used
X			volatile const uint32_t RESERVED3			:6; 		  
N		} SCR_b;								   /*!< BitSize 		  */
N	};
N
N	__IO uint32_t SDR0;                 /// 0x0004 | SPI0 FIFO Access register                  | 0x00000000
X	volatile uint32_t SDR0;                 
N	__IO uint32_t SSR0;                 /// 0x0008 | SPI0 Status register                       | 0x00000000
X	volatile uint32_t SSR0;                 
N	__IO uint32_t SFIFOCR;              /// 0x000C | FIFO Control register                      | 0x00000000
X	volatile uint32_t SFIFOCR;              
N	__IO uint32_t SINTRSR;              /// 0x0010 | Interrupt Status register                  | 0x30001080
X	volatile uint32_t SINTRSR;              
N	__IO uint32_t SINTRMSSR;            /// 0x0014 | Interrupt Masked Status register           | 0x00000000
X	volatile uint32_t SINTRMSSR;            
N
N	union {
N
N		__IO uint32_t SINTRMSCR;			  /// 0x0018 | Interrupt Mask Control register			  | 0x00000000
X		volatile uint32_t SINTRMSCR;			  
N
N		struct {
N			__IO uint32_t Not_Used				:6;
X			volatile uint32_t Not_Used				:6;
N			__IO uint32_t IntrMemMSCR 			:1;
X			volatile uint32_t IntrMemMSCR 			:1;
N			__IO uint32_t IntrAitWlvMSCR 		:1;
X			volatile uint32_t IntrAitWlvMSCR 		:1;
N			__IO uint32_t IntrAitWlvMSCR1		:1;
X			volatile uint32_t IntrAitWlvMSCR1		:1;
N			__IO uint32_t IntrAitWlvMSCR2		:1;
X			volatile uint32_t IntrAitWlvMSCR2		:1;
N			__IO uint32_t IntrAitWlvMSCR3		:1;
X			volatile uint32_t IntrAitWlvMSCR3		:1;
N		} SINTRMSCR_b;								   /*!< BitSize 		  */
N	};
N
N	__IO uint32_t SINTRENCR;            /// 0x001C | Interrupt Clear register                   | 0x30000000
X	volatile uint32_t SINTRENCR;            
N
N
N
N	__IO uint32_t SFIFORXPTR;           /// 0x0020 | RX FIFO Pointer status register            | 0x00000000
X	volatile uint32_t SFIFORXPTR;           
N	__IO uint32_t SFIFORXDIFFPTR;       /// 0x0024 | RX FIFO Pointer difference status register | 0x00000000
X	volatile uint32_t SFIFORXDIFFPTR;       
N	__IO uint32_t SFIFOTXPTR;           /// 0x0028 | TX FIFO Pointer status register            | 0x00000000
X	volatile uint32_t SFIFOTXPTR;           
N	__IO uint32_t SFIFOTXDIFFPTR;       /// 0x002C | TX FIFO Pointer difference status register | 0x00000000
X	volatile uint32_t SFIFOTXDIFFPTR;       
N	__IO uint32_t SDATACNTTXRX;         /// 0x0030 | TX RX COUNTER status register              | 0x00000000
X	volatile uint32_t SDATACNTTXRX;         
N	__IO uint32_t Reserved1;            /// 0x0034 | Reserved 1                                 | 0x00000000
X	volatile uint32_t Reserved1;            
N	__IO uint32_t Reserved2;            /// 0x0038 | Reserved 2                                 | 0x00000000
X	volatile uint32_t Reserved2;            
N	__IO uint32_t Reserved3;            /// 0x003C | Reserved 3                                 | 0x00000000
X	volatile uint32_t Reserved3;            
N	__IO uint32_t Reserved4;            /// 0x0040 | Reserved 4                                 | 0x00000000
X	volatile uint32_t Reserved4;            
N
N	__IO uint32_t SMISC;                /// 0x0044 | Miscellaneous register                     | 0x00000000
X	volatile uint32_t SMISC;                
N
N	__IO uint32_t Reserved5;            /// 0x0048 | Reserved 5                                 | 0x00000000
X	volatile uint32_t Reserved5;            
N	__IO uint32_t Reserved6;            /// 0x004C | Reserved 6                                 | 0x00000000
X	volatile uint32_t Reserved6;            
N
N	__IO uint32_t Reserved7;            /// 0x0050 | Reserved 7                                 | 0x00000000
X	volatile uint32_t Reserved7;            
N	__IO uint32_t Reserved8;            /// 0x0054 | Reserved 8                                 | 0x00000000
X	volatile uint32_t Reserved8;            
N	__IO uint32_t Reserved9;            /// 0x0058 | Reserved 9                                 | 0x00000000
X	volatile uint32_t Reserved9;            
N	__IO uint32_t Reserved10;           /// 0x005C | Reserved 10                                | 0x00000000
X	volatile uint32_t Reserved10;           
N	__IO uint32_t Reserved11;           /// 0x0060 | Reserved 11                                | 0x00000000
X	volatile uint32_t Reserved11;           
N	__IO uint32_t Reserved12;           /// 0x0064 | Reserved 12                                | 0x00000000
X	volatile uint32_t Reserved12;           
N	__IO uint32_t Reserved13;           /// 0x0068 | Reserved 13                                | 0x00000000
X	volatile uint32_t Reserved13;           
N	__IO uint32_t Reserved14;           /// 0x006C | Reserved 14                                | 0x00000000
X	volatile uint32_t Reserved14;           
N	__IO uint32_t Reserved15;           /// 0x0070 | Reserved 15                                | 0x00000000
X	volatile uint32_t Reserved15;           
N	__IO uint32_t Reserved16;           /// 0x0074 | Reserved 16                                | 0x00000000
X	volatile uint32_t Reserved16;           
N	__IO uint32_t Reserved17;           /// 0x0078 | Reserved 17                                | 0x00000000
X	volatile uint32_t Reserved17;           
N	__IO uint32_t Reserved18;           /// 0x007C | Reserved 18                                | 0x00000000
X	volatile uint32_t Reserved18;           
N	__IO uint32_t Reserved19;           /// 0x0080 | Reserved 19                                | 0x00000030
X	volatile uint32_t Reserved19;           
N	__IO uint32_t SDR1;                 /// 0x0084 | SPI1 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR1;                 
N	__IO uint32_t SDR2;                 /// 0x0088 | SPI2 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR2;                 
N	__IO uint32_t SDR3;                 /// 0x008C | SPI3 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR3;                 
N	__IO uint32_t SDR4;                 /// 0x0090 | SPI4 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR4;                 
N	__IO uint32_t SDR5;                 /// 0x0094 | SPI5 FIFO Access register                  | 0x00000010
X	volatile uint32_t SDR5;                 
N	__IO uint32_t SSR1;                 /// 0x0098 | SPI1 Status register                       | 0x00000010
X	volatile uint32_t SSR1;                 
N	__IO uint32_t SSR2;                 /// 0x009C | SPI2 Status register                       | 0x00000010
X	volatile uint32_t SSR2;                 
N	__IO uint32_t SSR3;                 /// 0x00A0 | SPI3 Status register                       | 0x00000010
X	volatile uint32_t SSR3;                 
N	__IO uint32_t SSR4;                 /// 0x00A4 | SPI4 Status register                       | 0x00000010
X	volatile uint32_t SSR4;                 
N	__IO uint32_t SSR5;                 /// 0x00A8 | SPI5 Status register                       | 0x00000020
X	volatile uint32_t SSR5;                 
N
N	__IO uint32_t SPIENA;               /// 0x00AC | SPI0~5 TX RX Enable register               | 0x00000020
X	volatile uint32_t SPIENA;               
N
N	__IO uint32_t SPITRSZE0;            /// 0x00B0 | SPI0 Transfer Size register                | 0x00000020
X	volatile uint32_t SPITRSZE0;            
N	__IO uint32_t SPITRSZE1;            /// 0x00B4 | SPI1 Transfer Size register                | 0x00000020
X	volatile uint32_t SPITRSZE1;            
N	__IO uint32_t SPITRSZE2;            /// 0x00B8 | SPI2 Transfer Size register                | 0x00000020
X	volatile uint32_t SPITRSZE2;            
N	__IO uint32_t SPITRSZE3;            /// 0x00BC | SPI3 Transfer Size register                | 0x00000018
X	volatile uint32_t SPITRSZE3;            
N	__IO uint32_t SPITRSZE4;            /// 0x00C0 | SPI4 Transfer Size register                | 0x00000018
X	volatile uint32_t SPITRSZE4;            
N	__IO uint32_t SPITRSZE5;            /// 0x00C4 | SPI5 Transfer Size register                | 0x00000018
X	volatile uint32_t SPITRSZE5;            
N	__IO uint32_t SPIINTSEL;            /// 0x00C8 | SPI Interrupt Selection register           | 0x00040000
X	volatile uint32_t SPIINTSEL;            
N
N	union {
N
N		__IO uint32_t SPISTATELEN;		  /// 0x00CC | SPI TIMING LENGTH register				  | 0x0000F000
X		volatile uint32_t SPISTATELEN;		  
N
N		struct {
N			__IO uint32_t PreShftLen			:8;
X			volatile uint32_t PreShftLen			:8;
N			__IO uint32_t TmpIdleLen 			:8;
X			volatile uint32_t TmpIdleLen 			:8;
N			__IO uint32_t PostShftLen 			:8;
X			volatile uint32_t PostShftLen 			:8;
N			__IO uint32_t SnglIdleLen 			:4;
X			volatile uint32_t SnglIdleLen 			:4;
N			__IO uint32_t AitIdleLen			:4;
X			volatile uint32_t AitIdleLen			:4;
N		} SPISTATELEN_b;								   /*!< BitSize 		  */
N	};
N
N
N	union {
N
N		__IO uint32_t SPIMODE;			  /// 0x00D0 | SPI Operation Mode register				  | 0x00000300
X		volatile uint32_t SPIMODE;			  
N
N		struct {
N			__IO uint32_t AitTlpMode			:1;
X			volatile uint32_t AitTlpMode			:1;
N			__IO uint32_t SramFifoMode 			:1;
X			volatile uint32_t SramFifoMode 			:1;
N			__IO uint32_t HwSwMode 				:1;
X			volatile uint32_t HwSwMode 				:1;
N			__IO uint32_t BrstSnglMode 			:1;
X			volatile uint32_t BrstSnglMode 			:1;
N			__IO uint32_t SramDebugMode			:1;
X			volatile uint32_t SramDebugMode			:1;
N			__IO uint32_t SramWrOpt				:1;
X			volatile uint32_t SramWrOpt				:1;
N			__IO uint32_t reserved 				:2;
X			volatile uint32_t reserved 				:2;
N			__IO uint32_t TrsPerRd 				:2;
X			volatile uint32_t TrsPerRd 				:2;
N			__IO uint32_t TrsPerWr 				:2;
X			volatile uint32_t TrsPerWr 				:2;
N			__IO uint32_t PwfeSel				:3;
X			volatile uint32_t PwfeSel				:3;
N			__IO uint32_t CommPwfeSel			:1;
X			volatile uint32_t CommPwfeSel			:1;
N			__IO uint32_t Protocol 				:4;
X			volatile uint32_t Protocol 				:4;
N			__IO uint32_t RdHlfWrdMsbFrst		:1;
X			volatile uint32_t RdHlfWrdMsbFrst		:1;
N			__IO uint32_t WrHlfWrdMsbFrst		:1;
X			volatile uint32_t WrHlfWrdMsbFrst		:1;
N		} SPIMODE_b;								   /*!< BitSize 		  */
N	};
N
N
N
N
N	__IO uint32_t SPISTART;             /// 0x00D4 | SPI Start Command register                 | 0x00000018
X	volatile uint32_t SPISTART;             
N
N	__IO uint32_t SPISTRTWAD01;         /// 0x00D8 | SPI0 SPI1 Memory Write Start Address       | 0x00000018
X	volatile uint32_t SPISTRTWAD01;         
N	__IO uint32_t SPISTRTWAD23;         /// 0x00DC | SPI2 SPI3 Memory Write Start Address       | 0x00000002
X	volatile uint32_t SPISTRTWAD23;         
N	__IO uint32_t SPISTRTWAD45;         /// 0x00E0 | SPI4 SPI5 Memory Write Start Address       | 0x00000005
X	volatile uint32_t SPISTRTWAD45;         
N
N	__IO uint32_t SPISTRTRAD01;         /// 0x00E4 | SPI0 SPI1 Memory Read  Start Address       | 0x00000018
X	volatile uint32_t SPISTRTRAD01;         
N	__IO uint32_t SPISTRTRAD23;         /// 0x00E8 | SPI2 SPI3 Memory Read  Start Address       | 0x00000002
X	volatile uint32_t SPISTRTRAD23;         
N	__IO uint32_t SPISTRTRAD45;         /// 0x00EC | SPI4 SPI5 Memory Read  Start Address       | 0x00000005
X	volatile uint32_t SPISTRTRAD45;         
N
N
N	__IO uint32_t TSPRXLINESALL;        /// 0x00F0 | TSP Total RX LINES Divided by 2            | 0x0000000F
X	volatile uint32_t TSPRXLINESALL;        
N	__IO uint32_t SPIRXLINES01;         /// 0x00F4 | SPI0 SPI1 Allocated RX TOUCH LINES         | 0x00000000
X	volatile uint32_t SPIRXLINES01;         
N	__IO uint32_t SPIRXLINES23;         /// 0x00F8 | SPI2 SPI3 Allocated RX TOUCH LINES         | 0x207F1FFF
X	volatile uint32_t SPIRXLINES23;         
N	__IO uint32_t SPIRXLINES45;         /// 0x00FC | SPI4 SPI5 Allocated RX TOUCH LINES         | 0x55AA55AA
X	volatile uint32_t SPIRXLINES45;         
N
N	union {
N
N		__IO uint32_t SPIPCLKEND; 		  /// 0x00FF | SPI PCLK END parameter for DIV2/3/4/6/8	  | 0x55AA55AA
X		volatile uint32_t SPIPCLKEND; 		  
N
N		struct {
N			__IO uint32_t spiPclkEnd			:4;
X			volatile uint32_t spiPclkEnd			:4;
N			__IO uint32_t spiPclkCnt	 		:4;
X			volatile uint32_t spiPclkCnt	 		:4;
N			__IO uint32_t spiPclkDiv 			:4;
X			volatile uint32_t spiPclkDiv 			:4;
N			__IO uint32_t spiPclkEnd2 			:4;
X			volatile uint32_t spiPclkEnd2 			:4;
N		} SPIPCLKEND_b;								   /*!< BitSize 		  */
N	};
N
N
N	__IO uint32_t SPITSYNCSZE0;         /// 0x0100 | SPI0 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE0;         
N	__IO uint32_t SPITSYNCSZE1;         /// 0x0104 | SPI1 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE1;         
N	__IO uint32_t SPITSYNCSZE2;         /// 0x0108 | SPI2 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE2;         
N	__IO uint32_t SPITSYNCSZE3;         /// 0x010C | SPI3 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE3;         
N	__IO uint32_t SPITSYNCSZE4;         /// 0x0120 | SPI4 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE4;         
N	__IO uint32_t SPITSYNCSZE5;         /// 0x0124 | SPI5 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE5;         
N	__IO uint32_t SPIHCLKCOMMEND;       /// 0x0128 | SPI Ready Singal sampling position         | 0x000000FF
X	volatile uint32_t SPIHCLKCOMMEND;       
N	__IO uint32_t SPIAITTSYNCDONECLR;   /// 0x0128 | SPI TSYNC Done Status Clear Command        | 0x000000FF
X	volatile uint32_t SPIAITTSYNCDONECLR;   
N
N	__IO uint32_t SPISTATESR0;          /// 0x0128 | SPI0 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR0;          
N	__IO uint32_t SPITSYNCCNTSR0;       /// 0x0128 | SPI0 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR0;       
N	__IO uint32_t SPISUBFRCNTSR0;       /// 0x0128 | SPI0 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR0;       
N	__IO uint32_t SPISTATESR1;          /// 0x0128 | SPI1 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR1;          
N	__IO uint32_t SPITSYNCCNTSR1;       /// 0x0128 | SPI1 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR1;       
N	__IO uint32_t SPISUBFRCNTSR1;       /// 0x0128 | SPI1 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR1;       
N	__IO uint32_t SPISTATESR2;          /// 0x0128 | SPI2 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR2;          
N	__IO uint32_t SPITSYNCCNTSR2;       /// 0x0128 | SPI2 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR2;       
N	__IO uint32_t SPISUBFRCNTSR2;       /// 0x0128 | SPI2 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR2;       
N	__IO uint32_t SPISTATESR3;          /// 0x0128 | SPI3 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR3;          
N	__IO uint32_t SPITSYNCCNTSR3;       /// 0x0128 | SPI3 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR3;       
N	__IO uint32_t SPISUBFRCNTSR3;       /// 0x0128 | SPI3 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR3;       
N	__IO uint32_t SPISTATESR4;          /// 0x0128 | SPI4 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR4;          
N	__IO uint32_t SPITSYNCCNTSR4;       /// 0x0128 | SPI4 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR4;       
N	__IO uint32_t SPISUBFRCNTSR4;       /// 0x0128 | SPI4 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR4;       
N	__IO uint32_t SPISTATESR5;          /// 0x0128 | SPI5 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR5;          
N	__IO uint32_t SPITSYNCCNTSR5;       /// 0x0128 | SPI5 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR5;       
N	__IO uint32_t SPISUBFRCNTSR5;       /// 0x0128 | SPI5 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR5;       
N
N	__IO uint32_t SPIAITWLVCR;          /// 0x0128 | SPI AIT Waterlevel Interrupt Control       | 0x000000FF
X	volatile uint32_t SPIAITWLVCR;          
N	__IO uint32_t SPIAITWLV;            /// 0x0128 | SPI AIT Waterlevel Value                   | 0x000000FF
X	volatile uint32_t SPIAITWLV;            
N	
N	__IO uint32_t SPIAITDMYDEL;         /// 0x0128 | SPI AIT Dummy Delete  Mode                 | 0x000000FF
X	volatile uint32_t SPIAITDMYDEL;         
N
N	__IO uint32_t SPIGFCR0;             /// 0x0128 | SPI0 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR0;             
N	__IO uint32_t SPIGFENA0;            /// 0x0128 | SPI0 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA0;            
N	__IO uint32_t SPIGFCR1;             /// 0x0128 | SPI1 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR1;             
N	__IO uint32_t SPIGFENA1;            /// 0x0128 | SPI1 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA1;            
N	__IO uint32_t SPIGFCR2;             /// 0x0128 | SPI2 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR2;             
N	__IO uint32_t SPIGFENA2;            /// 0x0128 | SPI2 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA2;            
N	__IO uint32_t SPIGFCR3;             /// 0x0128 | SPI3 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR3;             
N	__IO uint32_t SPIGFENA3;            /// 0x0128 | SPI3 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA3;            
N	__IO uint32_t SPIGFCR4;             /// 0x0128 | SPI4 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR4;             
N	__IO uint32_t SPIGFENA4;            /// 0x0128 | SPI4 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA4;            
N	__IO uint32_t SPIGFCR5;             /// 0x0128 | SPI5 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR5;             
N	__IO uint32_t SPIGFENA5;            /// 0x0128 | SPI5 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA5;            
N
N	__IO uint32_t SPIPENCR0;            /// 0x0128 | SPI Pen Control0                           | 0x000000FF
X	volatile uint32_t SPIPENCR0;            
N	__IO uint32_t SPIPENCR1;            /// 0x0128 | SPI Pen Control1                           | 0x000000FF
X	volatile uint32_t SPIPENCR1;            
N
N	__IO uint32_t SPIAITWLV1;           /// 0x0128 | SPI AIT Waterlevel1 Value                  | 0x000000FF
X	volatile uint32_t SPIAITWLV1;           
N	__IO uint32_t SPIAITWLV2;           /// 0x0128 | SPI AIT Waterlevel2 Value                  | 0x000000FF
X	volatile uint32_t SPIAITWLV2;           
N	__IO uint32_t SPIAITWLV3;           /// 0x0128 | SPI AIT Waterlevel3 Value                  | 0x000000FF
X	volatile uint32_t SPIAITWLV3;           
N
N
N} MSPI_TypeDef ;
N
N
N#endif /* __MSPI_H_ */
L 285 "..\..\Hal\system\MFTP.h" 2
N#include "_tspi.h"
L 1 "..\..\Hal\spi\_tspi.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _tspi.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __TSPI_H_
N#define __TSPI_H_
N
N
Ntypedef struct {
N                                        /// Offset | Description                                | ResetValue
N    __IO uint32_t SCR;                  /// 0x0000 | SPI Control register                       | 0x00000002
X    volatile uint32_t SCR;                  
N    __IO uint32_t SDR;                  /// 0x0004 | SPI  FIFO Access register                  | 0x00000000
X    volatile uint32_t SDR;                  
N    __IO uint32_t SSR;                  /// 0x0008 | SPI  Status register                       | 0x00000000
X    volatile uint32_t SSR;                  
N    __IO uint32_t SFIFOCR;              /// 0x000C | FIFO Control register                      | 0x00000000
X    volatile uint32_t SFIFOCR;              
N    __IO uint32_t SINTRSR;              /// 0x0010 | Interrupt Status register                  | 0x30001080
X    volatile uint32_t SINTRSR;              
N    __IO uint32_t SINTRMSSR;            /// 0x0014 | Interrupt Masked Status register           | 0x00000000
X    volatile uint32_t SINTRMSSR;            
N    __IO uint32_t SINTRMSCR;            /// 0x0018 | Interrupt Mask Control register            | 0x00000000
X    volatile uint32_t SINTRMSCR;            
N    __IO uint32_t SINTRENCR;            /// 0x001C | Interrupt Clear register                   | 0x30000000
X    volatile uint32_t SINTRENCR;            
N    __IO uint32_t SFIFORXPTR;           /// 0x0020 | RX FIFO Pointer status register            | 0x00000000
X    volatile uint32_t SFIFORXPTR;           
N    __IO uint32_t SFIFORXDIFFPTR;       /// 0x0024 | RX FIFO Pointer difference status register | 0x00000000
X    volatile uint32_t SFIFORXDIFFPTR;       
N    __IO uint32_t SFIFOTXPTR;           /// 0x0028 | TX FIFO Pointer status register            | 0x00000000
X    volatile uint32_t SFIFOTXPTR;           
N    __IO uint32_t SFIFOTXDIFFPTR;       /// 0x002C | TX FIFO Pointer difference status register | 0x00000000
X    volatile uint32_t SFIFOTXDIFFPTR;       
N    __IO uint32_t SDATACNTTXRX;         /// 0x0030 | TX RX COUNTER status register              | 0x00000000
X    volatile uint32_t SDATACNTTXRX;         
N    __IO uint32_t Reserved1;            /// 0x0034 | Reserved 1                                 | 0x00000000
X    volatile uint32_t Reserved1;            
N    __IO uint32_t Reserved2;            /// 0x0038 | Reserved 2                                 | 0x00000000
X    volatile uint32_t Reserved2;            
N    __IO uint32_t Reserved3;            /// 0x003C | Reserved 3                                 | 0x00000000
X    volatile uint32_t Reserved3;            
N    __IO uint32_t Reserved4;            /// 0x0040 | Reserved 4                                 | 0x00000000
X    volatile uint32_t Reserved4;            
N    __IO uint32_t SMISC;                /// 0x0044 | Miscellaneous register                     | 0x00000000
X    volatile uint32_t SMISC;                
N    __IO uint32_t SINTLCTRL;            /// 0x0048 | Intel Control register                     | 0x00000000
X    volatile uint32_t SINTLCTRL;            
N    __IO uint32_t SBDWSTRT;             /// 0x004C | Intel Bulk Data Window Start register      | 0x00000000
X    volatile uint32_t SBDWSTRT;             
N    __IO uint32_t SINTLSTS;             /// 0x0050 | Intel Sensing Status register              | 0x00000000
X    volatile uint32_t SINTLSTS;             
N    __IO uint32_t SINTLFRCH;            /// 0x0054 | Intel Frame Characteristic register        | 0x00000000
X    volatile uint32_t SINTLFRCH;            
N    __IO uint32_t SINTLERR;             /// 0x0058 | Intel Error register                       | 0x00000000
X    volatile uint32_t SINTLERR;             
N    __IO uint32_t SINTLID;              /// 0x005C | Intel Id register                          | 0x00000000
X    volatile uint32_t SINTLID;              
N    __IO uint32_t SINTLDATSZ;           /// 0x0060 | Intel Data Size register                   | 0x00000000
X    volatile uint32_t SINTLDATSZ;           
N    __IO uint32_t SINTLCAP;             /// 0x0064 | Intel Capabilities register                | 0x00000000
X    volatile uint32_t SINTLCAP;             
N    __IO uint32_t SINTLCFG;             /// 0x0068 | Intel Configuration register               | 0x00000000
X    volatile uint32_t SINTLCFG;             
N    __IO uint32_t SINTLCMD;             /// 0x006C | Intel Command register                     | 0x00000000
X    volatile uint32_t SINTLCMD;             
N    __IO uint32_t SINTLPWRMG;           /// 0x0070 | Intel Power Management                     | 0x00000000
X    volatile uint32_t SINTLPWRMG;           
N    __IO uint32_t SINTLVNDID;           /// 0x0074 | Intel Vendor HW ID register                | 0x00000000
X    volatile uint32_t SINTLVNDID;           
N    __IO uint32_t SINTLHWREV;           /// 0x0078 | Intel HW Revision ID register              | 0x00000000
X    volatile uint32_t SINTLHWREV;           
N    __IO uint32_t SINTLFWREV;           /// 0x007C | Intel FW Revision ID register              | 0x00000000
X    volatile uint32_t SINTLFWREV;           
N    __IO uint32_t SINTLCMPREV;          /// 0x0080 | Intel Compatibility Revision register      | 0x00000000
X    volatile uint32_t SINTLCMPREV;          
N    __IO uint32_t Reserved19;           /// 0x0080 | Reserved 19                                | 0x00000030
X    volatile uint32_t Reserved19;           
N    __IO uint32_t Reserved20;           /// 0x0084 | Reserved 20                                | 0x00000030
X    volatile uint32_t Reserved20;           
N    __IO uint32_t Reserved21;           /// 0x0088 | Reserved 21                                | 0x00000030
X    volatile uint32_t Reserved21;           
N    __IO uint32_t Reserved22;           /// 0x008C | Reserved 22                                | 0x00000030
X    volatile uint32_t Reserved22;           
N    __IO uint32_t Reserved23;           /// 0x0090 | Reserved 23                                | 0x00000030
X    volatile uint32_t Reserved23;           
N    __IO uint32_t Reserved24;           /// 0x0094 | Reserved 24                                | 0x00000010
X    volatile uint32_t Reserved24;           
N    __IO uint32_t Reserved25;           /// 0x0098 | Reserved 25                                | 0x00000010
X    volatile uint32_t Reserved25;           
N    __IO uint32_t Reserved26;           /// 0x009C | Reserved 26                                | 0x00000010
X    volatile uint32_t Reserved26;           
N    __IO uint32_t Reserved27;           /// 0x00A0 | Reserved 27                                | 0x00000010
X    volatile uint32_t Reserved27;           
N    __IO uint32_t Reserved28;           /// 0x00A4 | Reserved 28                                | 0x00000010
X    volatile uint32_t Reserved28;           
N    __IO uint32_t Reserved29;           /// 0x00A8 | Reserved 29                                | 0x00000020
X    volatile uint32_t Reserved29;           
N    __IO uint32_t Reserved30;           /// 0x00AC | Reserved 30                                | 0x00000020
X    volatile uint32_t Reserved30;           
N    __IO uint32_t Reserved31;           /// 0x00B0 | Reserved 31                                | 0x00000020
X    volatile uint32_t Reserved31;           
N    __IO uint32_t Reserved32;           /// 0x00B4 | Reserved 32                                | 0x00000020
X    volatile uint32_t Reserved32;           
N    __IO uint32_t Reserved33;           /// 0x00B8 | Reserved 33                                | 0x00000020
X    volatile uint32_t Reserved33;           
N    __IO uint32_t Reserved34;           /// 0x00BC | Reserved 34                                | 0x00000018
X    volatile uint32_t Reserved34;           
N    __IO uint32_t Reserved35;           /// 0x00C0 | Reserved 35                                | 0x00000018
X    volatile uint32_t Reserved35;           
N    __IO uint32_t Reserved36;           /// 0x00C4 | Reserved 36                                | 0x00000018
X    volatile uint32_t Reserved36;           
N    __IO uint32_t Reserved37;           /// 0x00C8 | Reserved 37                                | 0x00040000
X    volatile uint32_t Reserved37;           
N    __IO uint32_t Reserved38;           /// 0x00CC | Reserved 38                                | 0x0000F000
X    volatile uint32_t Reserved38;           
N    __IO uint32_t Reserved39;           /// 0x00D0 | Reserved 39                                | 0x00000300
X    volatile uint32_t Reserved39;           
N    __IO uint32_t Reserved40;           /// 0x00D4 | Reserved 40                                | 0x00000018
X    volatile uint32_t Reserved40;           
N    __IO uint32_t Reserved41;           /// 0x00D8 | Reserved 41                                | 0x00000018
X    volatile uint32_t Reserved41;           
N    __IO uint32_t Reserved42;           /// 0x00DC | Reserved 42                                | 0x00000002
X    volatile uint32_t Reserved42;           
N    __IO uint32_t Reserved43;           /// 0x00E0 | Reserved 43                                | 0x00000005
X    volatile uint32_t Reserved43;           
N    __IO uint32_t Reserved44;           /// 0x00E4 | Reserved 44                                | 0x0000000F
X    volatile uint32_t Reserved44;           
N    __IO uint32_t Reserved45;           /// 0x00E8 | Reserved 45                                | 0x00000000
X    volatile uint32_t Reserved45;           
N    __IO uint32_t Reserved46;           /// 0x00EC | Reserved 46                                | 0x207F1FFF
X    volatile uint32_t Reserved46;           
N    __IO uint32_t Reserved47;           /// 0x00F0 | Reserved 47                                | 0x55AA55AA
X    volatile uint32_t Reserved47;           
N    __IO uint32_t Reserved48;           /// 0x00F4 | Reserved 48                                | 0x55AA55AA
X    volatile uint32_t Reserved48;           
N    __IO uint32_t Reserved49;           /// 0x00F8 | Reserved 49                                | 0x000000FF
X    volatile uint32_t Reserved49;           
N
N} TSPI_TypeDef ;
N
N
N#endif /* __TSPI_H_ */
N
L 286 "..\..\Hal\system\MFTP.h" 2
N#include "_dspA.h"
L 1 "..\..\Hal\dspA\_dspA.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _dspA.h
N * version : 0.1
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __DSPA_H_
N#define __DSPA_H_
N
N
N/* ================================================================================ */
N/* ================                      DSPA                      ================ */
N/* ================================================================================ */
N
Ntypedef struct
N{
N	union
N	{
N		struct
N		{
N			__IO uint32_t SwStr 	: 1;	// Software Start
X			volatile uint32_t SwStr 	: 1;	
N			__IO uint32_t Init  	: 1;	// Initialize
X			volatile uint32_t Init  	: 1;	
N			__I uint32_t RESERVED  	: 30;
X			volatile const uint32_t RESERVED  	: 30;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} HWACC_CTRL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t ItrptEn   : 1;	// Interrupt Enable
X			volatile uint32_t ItrptEn   : 1;	
N			__IO uint32_t ItrptFlag : 1;	// Interrupt Flag(Read), Interrupt Clear by writing 0(write)
X			volatile uint32_t ItrptFlag : 1;	
N			__I uint32_t RESERVED  	: 30;
X			volatile const uint32_t RESERVED  	: 30;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} ITRPT_CTRL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t RowNum  : 8;	// Pannel Row(Pad )
X			volatile uint32_t RowNum  : 8;	
N			__IO uint32_t ColNum  : 8;	// Pannel Column(Pad )
X			volatile uint32_t ColNum  : 8;	
N			__IO uint32_t DataLen : 16;	// Total Data(Pad )
X			volatile uint32_t DataLen : 16;	
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} SIZE_CTRL;
N
N	__IO uint32_t RAW_ADDR;
X	volatile uint32_t RAW_ADDR;
N
N	__IO uint32_t BASE_ADDR;
X	volatile uint32_t BASE_ADDR;
N
N	__IO uint32_t NMLZ_ADDR;
X	volatile uint32_t NMLZ_ADDR;
N
N	__IO uint32_t DEST_ADDR;
X	volatile uint32_t DEST_ADDR;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t PadEn   	: 1;
X			volatile uint32_t PadEn   	: 1;
N			__IO uint32_t RESERVED1	: 3;
X			volatile uint32_t RESERVED1	: 3;
N			__IO uint32_t PadSize	: 4;
X			volatile uint32_t PadSize	: 4;
N			__IO uint32_t RESERVED2	: 8;
X			volatile uint32_t RESERVED2	: 8;
N			__IO uint32_t PadData	: 16;
X			volatile uint32_t PadData	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} PAD_CTRL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t NmlzEn    : 1;
X			volatile uint32_t NmlzEn    : 1;
N			__IO uint32_t RESERVED  : 7;
X			volatile uint32_t RESERVED  : 7;
N			__IO uint32_t NmlzShift : 8;
X			volatile uint32_t NmlzShift : 8;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} NMLZ_CTRL;
N
N	union
N	{
N        struct
N		{
N			__IO uint32_t BitShift	: 8;
X			volatile uint32_t BitShift	: 8;
N			__IO uint32_t RESERVED	: 24;
X			volatile uint32_t RESERVED	: 24;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} BIT_SHIFT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t UpperLimit	: 16;
X			volatile uint32_t UpperLimit	: 16;
N			__IO uint32_t RESERVED		: 16;
X			volatile uint32_t RESERVED		: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} UPR_LIMIT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t LowerLimit	: 16;
X			volatile uint32_t LowerLimit	: 16;
N			__IO uint32_t RESERVED		: 16;
X			volatile uint32_t RESERVED		: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} LWR_LIMIT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t Threshold	: 16;
X			volatile uint32_t Threshold	: 16;
N			__IO uint32_t RESERVED	: 16;
X			volatile uint32_t RESERVED	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} THRESHOLD;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t PlusCellNum	: 16;
X			volatile const uint32_t PlusCellNum	: 16;
N			__I uint32_t RESERVED		: 16;
X			volatile const uint32_t RESERVED		: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} P_CELL_NUM;
N
N	__I uint32_t P_CELL_SUM;
X	volatile const uint32_t P_CELL_SUM;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t PlusMaxVal	: 16;
X			volatile const uint32_t PlusMaxVal	: 16;
N			__I uint32_t RESERVED	: 16;
X			volatile const uint32_t RESERVED	: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} P_MAX_VAL;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t PlusMaxRow	: 8;
X			volatile const uint32_t PlusMaxRow	: 8;
N			__I uint32_t PlusMaxCol	: 8;
X			volatile const uint32_t PlusMaxCol	: 8;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} P_MAX_POS;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t MinusCellNum	: 16;
X			volatile const uint32_t MinusCellNum	: 16;
N			__I uint32_t RESERVED		: 16;
X			volatile const uint32_t RESERVED		: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} M_CELL_NUM;
N
N	__I uint32_t M_CELL_SUM;
X	volatile const uint32_t M_CELL_SUM;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t MinusMaxVal	: 16;
X			volatile const uint32_t MinusMaxVal	: 16;
N			__I uint32_t RESERVED	: 16;
X			volatile const uint32_t RESERVED	: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} M_MAX_VAL;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t MinusMaxRow	: 8;
X			volatile const uint32_t MinusMaxRow	: 8;
N			__I uint32_t MinusMaxCol	: 8;
X			volatile const uint32_t MinusMaxCol	: 8;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} M_MAX_POS;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TouchMinCol	: 8;
X			volatile const uint32_t TouchMinCol	: 8;
N			__I uint32_t TouchMaxCol	: 8;
X			volatile const uint32_t TouchMaxCol	: 8;
N			__I uint32_t TouchMinRow	: 8;
X			volatile const uint32_t TouchMinRow	: 8;
N			__I uint32_t TouchMaxRow	: 8;
X			volatile const uint32_t TouchMaxRow	: 8;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} T_GROUP;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TouchCellNum	: 16;
X			volatile const uint32_t TouchCellNum	: 16;
N			__I uint32_t RESERVED		: 16;
X			volatile const uint32_t RESERVED		: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} T_CELL_NUM;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t PlusEn	: 1;
X			volatile uint32_t PlusEn	: 1;
N			__IO uint32_t MinusEn	: 1;
X			volatile uint32_t MinusEn	: 1;
N			__IO uint32_t RESERVED	: 14;
X			volatile uint32_t RESERVED	: 14;
N			__IO uint32_t PConstant	: 16;
X			volatile uint32_t PConstant	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} PLUS_OPT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t MultEn	: 1;
X			volatile uint32_t MultEn	: 1;
N			__IO uint32_t RESERVED	: 15;
X			volatile uint32_t RESERVED	: 15;
N			__IO uint32_t MConstant	: 16;
X			volatile uint32_t MConstant	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} MULT_OPT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t MasterLock	: 1;
X			volatile uint32_t MasterLock	: 1;
N			__IO uint32_t RESERVED		: 30;
X			volatile uint32_t RESERVED		: 30;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} MASTLOCK;
N
N} tDSPA_CtrlReg_t;
N
N#endif /* __DSPA_H_ */
L 287 "..\..\Hal\system\MFTP.h" 2
N#include "_pwmdrv.h"
L 1 "..\..\Hal\pwmdrv\_pwmdrv.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _pwmdrv.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __PWMDRV_H_
N#define __PWMDRV_H_
N
N#include "_pwmdrv_param.h"
L 1 "..\..\Hal\pwmdrv\_pwmdrv_param.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : mspi_.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __PWMDRV_PARAM_H_
N#define __PWMDRV_PARAM_H_
N
N/*
N * defines
N *
N * */
N
Ntypedef enum {
N	ePWM_PARAM_FINGER = 0,
N	ePWM_PARAM_PEN = 1,
N	ePWM_PARAM_MAX,
N
N} ePwmParamOpMode;
N
N/*
N * typedef
N *
N * */
Ntypedef union
N{
N    struct
N	{
N      __IO uint32_t  HI_ABOVE_NUM       :  6;
X      volatile uint32_t  HI_ABOVE_NUM       :  6;
N      __IO uint32_t  LO_BELOW_NUM       :  6;
X      volatile uint32_t  LO_BELOW_NUM       :  6;
N      __IO uint32_t  FSM_ON_IBE         :  1;
X      volatile uint32_t  FSM_ON_IBE         :  1;
N      __IO uint32_t  FSM_ON_IEV         :  1;
X      volatile uint32_t  FSM_ON_IEV         :  1;
N      __IO uint32_t  FSM_ON_IE          :  1;
X      volatile uint32_t  FSM_ON_IE          :  1;
N      __IO uint32_t  VSYNC_IN_EXT_IBE   :  1;
X      volatile uint32_t  VSYNC_IN_EXT_IBE   :  1;
N      __IO uint32_t  VSYNC_IN_EXT_IEV   :  1;
X      volatile uint32_t  VSYNC_IN_EXT_IEV   :  1;
N      __IO uint32_t  VSYNC_IN_EXT_IE    :  1;
X      volatile uint32_t  VSYNC_IN_EXT_IE    :  1;
N      __IO uint32_t  TSYNC_IN_EXT_IBE   :  1;
X      volatile uint32_t  TSYNC_IN_EXT_IBE   :  1;
N      __IO uint32_t  TSYNC_IN_EXT_IEV   :  1;
X      volatile uint32_t  TSYNC_IN_EXT_IEV   :  1;
N      __IO uint32_t  TSYNC_IN_EXT_IE    :  1;
X      volatile uint32_t  TSYNC_IN_EXT_IE    :  1;
N      __IO uint32_t  TSYNC_OUT_EXT_IBE  :  1;
X      volatile uint32_t  TSYNC_OUT_EXT_IBE  :  1;
N      __IO uint32_t  TSYNC_OUT_EXT_IEV  :  1;
X      volatile uint32_t  TSYNC_OUT_EXT_IEV  :  1;
N      __IO uint32_t  TSYNC_OUT_EXT_IE   :  1;
X      volatile uint32_t  TSYNC_OUT_EXT_IE   :  1;
N      __IO uint32_t  TSYNC_FR_IBE       :  1;
X      volatile uint32_t  TSYNC_FR_IBE       :  1;
N      __IO uint32_t  TSYNC_FR_IEV       :  1;
X      volatile uint32_t  TSYNC_FR_IEV       :  1;
N      __IO uint32_t  TSYNC_FR_IE        :  1;
X      volatile uint32_t  TSYNC_FR_IE        :  1;
N      __IO uint32_t  TSYNC_MNT_IBE      :  1;
X      volatile uint32_t  TSYNC_MNT_IBE      :  1;
N      __IO uint32_t  TSYNC_MNT_IEV      :  1;
X      volatile uint32_t  TSYNC_MNT_IEV      :  1;
N      __IO uint32_t  TSYNC_MNT_IE       :  1;
X      volatile uint32_t  TSYNC_MNT_IE       :  1;
N      __IO uint32_t  RESERVED       	:  2;
X      volatile uint32_t  RESERVED       	:  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_INTR_CFG_t;
X} __attribute__ ((packed)) tPWMDRV_INTR_CFG_t;
N
Ntypedef union
N{
N    struct {
N      __IO uint32_t  BEACON_D0    :  5;
X      volatile uint32_t  BEACON_D0    :  5;
N      __IO uint32_t  BEACON_D1    :  5;
X      volatile uint32_t  BEACON_D1    :  5;
N      __IO uint32_t  BEACON_D2    :  5;
X      volatile uint32_t  BEACON_D2    :  5;
N      __IO uint32_t  BEACON_D3    :  5;
X      volatile uint32_t  BEACON_D3    :  5;
N      __IO uint32_t  BEACON_D4    :  5;
X      volatile uint32_t  BEACON_D4    :  5;
N      __IO uint32_t  BEACON_D5    :  5;
X      volatile uint32_t  BEACON_D5    :  5;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N
N    __IO uint32_t  ulBulk;
X    volatile uint32_t  ulBulk;
N
N} __PACKED tPWMDRV_DSSS_INFO_1_t;
X} __attribute__ ((packed)) tPWMDRV_DSSS_INFO_1_t;
N
N
Ntypedef union
N{
N	struct {
N		__IO uint32_t  DLY_0 :  16;
X		volatile uint32_t  DLY_0 :  16;
N		__IO uint32_t  DLY_1 :  16;
X		volatile uint32_t  DLY_1 :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRLG_t;
X} __attribute__ ((packed)) tPWMDRV_PRLG_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  TX_PRD :  16;
X	      volatile uint32_t  TX_PRD :  16;
N	      __IO uint32_t  TX_LOW :  16;
X	      volatile uint32_t  TX_LOW :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_0_t;
X} __attribute__ ((packed)) tPWMDRV_PRE_0_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  TX_NUM  :  10;
X	      volatile uint32_t  TX_NUM  :  10;
N	      __IO uint32_t  PRE_DLY :  16;
X	      volatile uint32_t  PRE_DLY :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_1_t;
X} __attribute__ ((packed)) tPWMDRV_PRE_1_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DSSS_DLY :  8;
X	      volatile uint32_t  DSSS_DLY :  8;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_2_t;
X} __attribute__ ((packed)) tPWMDRV_PRE_2_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DLY_0_BEACON :  16;
X	      volatile uint32_t  DLY_0_BEACON :  16;
N	      __IO uint32_t  DLY_1        :  16;
X	      volatile uint32_t  DLY_1        :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_EPLG_0_t;
X} __attribute__ ((packed)) tPWMDRV_EPLG_0_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DLY_0_PING_FG_F  :  16;
X	      volatile uint32_t  DLY_0_PING_FG_F  :  16;
N	      __IO uint32_t  DLY_0_PING_FG_L  :  16;
X	      volatile uint32_t  DLY_0_PING_FG_L  :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_EPLG_1_t;
X} __attribute__ ((packed)) tPWMDRV_EPLG_1_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DLY_0_PING_PN_P  :  16;
X	      volatile uint32_t  DLY_0_PING_PN_P  :  16;
N	      __IO uint32_t  DLY_0_PING_PN_D  :  16;
X	      volatile uint32_t  DLY_0_PING_PN_D  :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_EPLG_2_t;
X} __attribute__ ((packed)) tPWMDRV_EPLG_2_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_01     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_01     :  2;    
N	      __IO uint32_t  LHB_02     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_02     :  2;    
N	      __IO uint32_t  LHB_03     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_03     :  2;    
N	      __IO uint32_t  LHB_04     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_04     :  2;    
N	      __IO uint32_t  LHB_05     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_05     :  2;    
N	      __IO uint32_t  LHB_06     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_06     :  2;    
N	      __IO uint32_t  LHB_07     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_07     :  2;    
N	      __IO uint32_t  LHB_08     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_08     :  2;    
N	      __IO uint32_t  LHB_09     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_09     :  2;    
N	      __IO uint32_t  LHB_10     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_10     :  2;    
N	      __IO uint32_t  LHB_11     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_11     :  2;    
N	      __IO uint32_t  LHB_12     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_12     :  2;    
N	      __IO uint32_t  LHB_13     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_13     :  2;    
N	      __IO uint32_t  LHB_14     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_14     :  2;    
N	      __IO uint32_t  LHB_15     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_15     :  2;    
N	      __IO uint32_t  LHB_16     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_16     :  2;    
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_FG_0_t;
X} __attribute__ ((packed)) tPWMDRV_FG_0_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_17     :  2;
X	      volatile uint32_t  LHB_17     :  2;
N	      __IO uint32_t  LHB_18     :  2;
X	      volatile uint32_t  LHB_18     :  2;
N	      __IO uint32_t  LHB_19     :  2;
X	      volatile uint32_t  LHB_19     :  2;
N	      __IO uint32_t  LHB_20     :  2;
X	      volatile uint32_t  LHB_20     :  2;
N	      __IO uint32_t  LHB_21     :  2;
X	      volatile uint32_t  LHB_21     :  2;
N	      __IO uint32_t  LHB_22     :  2;
X	      volatile uint32_t  LHB_22     :  2;
N	      __IO uint32_t  LHB_23     :  2;
X	      volatile uint32_t  LHB_23     :  2;
N	      __IO uint32_t  LHB_24     :  2;
X	      volatile uint32_t  LHB_24     :  2;
N	      __IO uint32_t  LHB_25     :  2;
X	      volatile uint32_t  LHB_25     :  2;
N	      __IO uint32_t  LHB_26     :  2;
X	      volatile uint32_t  LHB_26     :  2;
N	      __IO uint32_t  LHB_27     :  2;
X	      volatile uint32_t  LHB_27     :  2;
N	      __IO uint32_t  LHB_28     :  2;
X	      volatile uint32_t  LHB_28     :  2;
N	      __IO uint32_t  LHB_29     :  2;
X	      volatile uint32_t  LHB_29     :  2;
N	      __IO uint32_t  LHB_30     :  2;
X	      volatile uint32_t  LHB_30     :  2;
N	      __IO uint32_t  LHB_31     :  2;
X	      volatile uint32_t  LHB_31     :  2;
N	      __IO uint32_t  LHB_32     :  2;
X	      volatile uint32_t  LHB_32     :  2;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_FG_1_t;
X} __attribute__ ((packed)) tPWMDRV_FG_1_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_01     :  2;
X	      volatile uint32_t  LHB_01     :  2;
N	      __IO uint32_t  LHB_02     :  2;
X	      volatile uint32_t  LHB_02     :  2;
N	      __IO uint32_t  LHB_03     :  2;
X	      volatile uint32_t  LHB_03     :  2;
N	      __IO uint32_t  LHB_04     :  2;
X	      volatile uint32_t  LHB_04     :  2;
N	      __IO uint32_t  LHB_05     :  2;
X	      volatile uint32_t  LHB_05     :  2;
N	      __IO uint32_t  LHB_06     :  2;
X	      volatile uint32_t  LHB_06     :  2;
N	      __IO uint32_t  LHB_07     :  2;
X	      volatile uint32_t  LHB_07     :  2;
N	      __IO uint32_t  LHB_08     :  2;
X	      volatile uint32_t  LHB_08     :  2;
N	      __IO uint32_t  LHB_09     :  2;
X	      volatile uint32_t  LHB_09     :  2;
N	      __IO uint32_t  LHB_10     :  2;
X	      volatile uint32_t  LHB_10     :  2;
N	      __IO uint32_t  LHB_11     :  2;
X	      volatile uint32_t  LHB_11     :  2;
N	      __IO uint32_t  LHB_12     :  2;
X	      volatile uint32_t  LHB_12     :  2;
N	      __IO uint32_t  LHB_13     :  2;
X	      volatile uint32_t  LHB_13     :  2;
N	      __IO uint32_t  LHB_14     :  2;
X	      volatile uint32_t  LHB_14     :  2;
N	      __IO uint32_t  LHB_15     :  2;
X	      volatile uint32_t  LHB_15     :  2;
N	      __IO uint32_t  LHB_16     :  2;
X	      volatile uint32_t  LHB_16     :  2;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PN_0_t;
X} __attribute__ ((packed)) tPWMDRV_PN_0_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_17     :  2;
X	      volatile uint32_t  LHB_17     :  2;
N	      __IO uint32_t  LHB_18     :  2;
X	      volatile uint32_t  LHB_18     :  2;
N	      __IO uint32_t  LHB_19     :  2;
X	      volatile uint32_t  LHB_19     :  2;
N	      __IO uint32_t  LHB_20     :  2;
X	      volatile uint32_t  LHB_20     :  2;
N	      __IO uint32_t  LHB_21     :  2;
X	      volatile uint32_t  LHB_21     :  2;
N	      __IO uint32_t  LHB_22     :  2;
X	      volatile uint32_t  LHB_22     :  2;
N	      __IO uint32_t  LHB_23     :  2;
X	      volatile uint32_t  LHB_23     :  2;
N	      __IO uint32_t  LHB_24     :  2;
X	      volatile uint32_t  LHB_24     :  2;
N	      __IO uint32_t  LHB_25     :  2;
X	      volatile uint32_t  LHB_25     :  2;
N	      __IO uint32_t  LHB_26     :  2;
X	      volatile uint32_t  LHB_26     :  2;
N	      __IO uint32_t  LHB_27     :  2;
X	      volatile uint32_t  LHB_27     :  2;
N	      __IO uint32_t  LHB_28     :  2;
X	      volatile uint32_t  LHB_28     :  2;
N	      __IO uint32_t  LHB_29     :  2;
X	      volatile uint32_t  LHB_29     :  2;
N	      __IO uint32_t  LHB_30     :  2;
X	      volatile uint32_t  LHB_30     :  2;
N	      __IO uint32_t  LHB_31     :  2;
X	      volatile uint32_t  LHB_31     :  2;
N	      __IO uint32_t  LHB_32     :  2;
X	      volatile uint32_t  LHB_32     :  2;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PN_1_t;
X} __attribute__ ((packed)) tPWMDRV_PN_1_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  TSYNC_MNT_ENA      :  1;
X	      volatile uint32_t  TSYNC_MNT_ENA      :  1;
N	      __IO uint32_t  TSYNC_MNT_CLR      :  1;
X	      volatile uint32_t  TSYNC_MNT_CLR      :  1;
N	      __IO uint32_t  FR_SEL_POINT       :  2;
X	      volatile uint32_t  FR_SEL_POINT       :  2;
N	      __IO uint32_t  FR_TSYNC_PRD       :  16;
X	      volatile uint32_t  FR_TSYNC_PRD       :  16;
N	      __IO uint32_t  FR_TSYNC_NUM       :  6;
X	      volatile uint32_t  FR_TSYNC_NUM       :  6;
N	      __IO uint32_t  SYNC_AUTO_CLR      :  1;
X	      volatile uint32_t  SYNC_AUTO_CLR      :  1;
N	      __IO uint32_t  SEL_ECLK_AUTO      :  1;
X	      volatile uint32_t  SEL_ECLK_AUTO      :  1;
N	      __IO uint32_t  ENA_VSYNC_INIT     :  1;
X	      volatile uint32_t  ENA_VSYNC_INIT     :  1;
N	      __IO uint32_t  ENA_TSYNC_INIT     :  1;
X	      volatile uint32_t  ENA_TSYNC_INIT     :  1;
N	      __IO uint32_t  TSYNC_FREQ_EN_FG_L :  1;
X	      volatile uint32_t  TSYNC_FREQ_EN_FG_L :  1;
N
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_IN_CTRL_t;
X} __attribute__ ((packed)) tPWMDRV_IN_CTRL_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  PWMDRV_ENA         :  1;
X	      volatile uint32_t  PWMDRV_ENA         :  1;
N	      __IO uint32_t  VSYNC_EDGE         :  1;
X	      volatile uint32_t  VSYNC_EDGE         :  1;
N	      __IO uint32_t  TSYNC_EDGE         :  1;
X	      volatile uint32_t  TSYNC_EDGE         :  1;
N	      __IO uint32_t  SEL_EXT_VSYNC      :  1;
X	      volatile uint32_t  SEL_EXT_VSYNC      :  1;
N	      __IO uint32_t  SEL_EXT_TSYNC      :  1;
X	      volatile uint32_t  SEL_EXT_TSYNC      :  1;
N	      __IO uint32_t  SEL_FR_TSYNC       :  1;
X	      volatile uint32_t  SEL_FR_TSYNC       :  1;
N	      __IO uint32_t  UPDATE_VSYNC       :  1;
X	      volatile uint32_t  UPDATE_VSYNC       :  1;
N	      __IO uint32_t  UPDATE_TSYNC       :  1;
X	      volatile uint32_t  UPDATE_TSYNC       :  1;
N	      __IO uint32_t  UPDATE_DBG         :  1;
X	      volatile uint32_t  UPDATE_DBG         :  1;
N	      __IO uint32_t  VSYNC_FREQ_EN      :  1;
X	      volatile uint32_t  VSYNC_FREQ_EN      :  1;
N	      __IO uint32_t  TSYNC_FREQ_EN_FG_F :  1;
X	      volatile uint32_t  TSYNC_FREQ_EN_FG_F :  1;
N	      __IO uint32_t  DSSS_FREQ          :  6;
X	      volatile uint32_t  DSSS_FREQ          :  6;
N	      __IO uint32_t  ENA_PRTX_P0        :  1;
X	      volatile uint32_t  ENA_PRTX_P0        :  1;
N	      __IO uint32_t  ENA_PRTX_D0        :  1;
X	      volatile uint32_t  ENA_PRTX_D0        :  1;
N	      __IO uint32_t  ENA_DSSS_P         :  1;
X	      volatile uint32_t  ENA_DSSS_P         :  1;
N	      __IO uint32_t  ENA_DSSS_D         :  1;
X	      volatile uint32_t  ENA_DSSS_D         :  1;
N	      __IO uint32_t  ENA_PRTX_P1        :  1;
X	      volatile uint32_t  ENA_PRTX_P1        :  1;
N	      __IO uint32_t  ENA_PRTX_D1        :  1;
X	      volatile uint32_t  ENA_PRTX_D1        :  1;
N	      __IO uint32_t  ENA_ACTX_PD        :  1;
X	      volatile uint32_t  ENA_ACTX_PD        :  1;
N	      __IO uint32_t  ENA_ECLK_AUTO      :  1;
X	      volatile uint32_t  ENA_ECLK_AUTO      :  1;
N	      __IO uint32_t  VSYNC_NUM          :  6;
X	      volatile uint32_t  VSYNC_NUM          :  6;
N	      __IO uint32_t  VSYNC_BP           :  1;
X	      volatile uint32_t  VSYNC_BP           :  1;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_GBL_t;
X} __attribute__ ((packed)) tPWMDRV_GBL_t;
N
Ntypedef union
N{
N	struct {
N		__IO uint32_t  DSSS_ENA_T0         :  1;
X		volatile uint32_t  DSSS_ENA_T0         :  1;
N		__IO uint32_t  PRE_ENA_T0          :  1;
X		volatile uint32_t  PRE_ENA_T0          :  1;
N		__IO uint32_t  ACT_ENA_T0          :  1;
X		volatile uint32_t  ACT_ENA_T0          :  1;
N		__IO uint32_t  RESERVED0_T0		   :  1;
X		volatile uint32_t  RESERVED0_T0		   :  1;
N		__IO uint32_t  RESERVED1_T0		   :  1;
X		volatile uint32_t  RESERVED1_T0		   :  1;
N		__IO uint32_t  RESERVED2_T0		   :  1;
X		volatile uint32_t  RESERVED2_T0		   :  1;
N		__IO uint32_t  LFD_TX_ACT_ENA_T0   :  1;
X		volatile uint32_t  LFD_TX_ACT_ENA_T0   :  1;
N		__IO uint32_t  DSSS_ENA_T1         :  1;
X		volatile uint32_t  DSSS_ENA_T1         :  1;
N		__IO uint32_t  PRE_ENA_T1          :  1;
X		volatile uint32_t  PRE_ENA_T1          :  1;
N		__IO uint32_t  ACT_ENA_T1          :  1;
X		volatile uint32_t  ACT_ENA_T1          :  1;
N		__IO uint32_t  RESERVED0_T1		   :  1;
X		volatile uint32_t  RESERVED0_T1		   :  1;
N		__IO uint32_t  RESERVED1_T1		   :  1;
X		volatile uint32_t  RESERVED1_T1		   :  1;
N		__IO uint32_t  RESERVED2_T1		   :  1;
X		volatile uint32_t  RESERVED2_T1		   :  1;
N		__IO uint32_t  LFD_TX_ACT_ENA_T1   :  1;
X		volatile uint32_t  LFD_TX_ACT_ENA_T1   :  1;
N		__IO uint32_t  T_2 				   :  7;
X		volatile uint32_t  T_2 				   :  7;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_ENA_PWM_t;
X} __attribute__ ((packed)) tPWMDRV_ENA_PWM_t;
N/*
N *
N * Sample structure
Ntypedef union
N{
N	struct {
N
N	} __PACKED tBit;
N
N	__IO uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_2_t;
N*/
N#endif /* __PWMDRV_PARAM_H_ */
L 37 "..\..\Hal\pwmdrv\_pwmdrv.h" 2
N/* ================================================================================ */
N/* ================                      PWMDRV                    ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief PWMDRV / PWM TX Generation Configuration Register
N  */
Ntypedef struct {                             /*!< PWMDRV Structure   */
N
N  union {
N    __IO uint32_t  GBL;                      /*!< CFG               */
X    volatile uint32_t  GBL;                       
N
N    struct {
N      __IO uint32_t  PWMDRV_ENA         :  1;    /*!<                   */
X      volatile uint32_t  PWMDRV_ENA         :  1;     
N      __IO uint32_t  VSYNC_EDGE         :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_EDGE         :  1;     
N      __IO uint32_t  TSYNC_EDGE         :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_EDGE         :  1;     
N      __IO uint32_t  SEL_EXT_VSYNC      :  1;    /*!<                   */
X      volatile uint32_t  SEL_EXT_VSYNC      :  1;     
N      __IO uint32_t  SEL_EXT_TSYNC      :  1;    /*!<                   */
X      volatile uint32_t  SEL_EXT_TSYNC      :  1;     
N      __IO uint32_t  SEL_FR_TSYNC       :  1;    /*!<                   */
X      volatile uint32_t  SEL_FR_TSYNC       :  1;     
N      __IO uint32_t  UPDATE_VSYNC       :  1;    /*!<                   */
X      volatile uint32_t  UPDATE_VSYNC       :  1;     
N      __IO uint32_t  UPDATE_TSYNC       :  1;    /*!<                   */
X      volatile uint32_t  UPDATE_TSYNC       :  1;     
N      __IO uint32_t  UPDATE_DBG         :  1;    /*!<                   */
X      volatile uint32_t  UPDATE_DBG         :  1;     
N      __IO uint32_t  VSYNC_FREQ_EN      :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_FREQ_EN      :  1;     
N      __IO uint32_t  TSYNC_FREQ_EN_FG_F :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FREQ_EN_FG_F :  1;     
N      __IO uint32_t  DSSS_FREQ          :  6;    /*!<                   */
X      volatile uint32_t  DSSS_FREQ          :  6;     
N      __IO uint32_t  ENA_PRTX_P0        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_P0        :  1;     
N      __IO uint32_t  ENA_PRTX_D0        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_D0        :  1;     
N      __IO uint32_t  ENA_DSSS_P         :  1;    /*!<                   */
X      volatile uint32_t  ENA_DSSS_P         :  1;     
N      __IO uint32_t  ENA_DSSS_D         :  1;    /*!<                   */
X      volatile uint32_t  ENA_DSSS_D         :  1;     
N      __IO uint32_t  ENA_PRTX_P1        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_P1        :  1;     
N      __IO uint32_t  ENA_PRTX_D1        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_D1        :  1;     
N      __IO uint32_t  ENA_ACTX_PD        :  1;    /*!<                   */
X      volatile uint32_t  ENA_ACTX_PD        :  1;     
N      __IO uint32_t  ENA_ECLK_AUTO      :  1;    /*!<                   */
X      volatile uint32_t  ENA_ECLK_AUTO      :  1;     
N      __IO uint32_t  VSYNC_NUM          :  6;    /*!<                   */
X      volatile uint32_t  VSYNC_NUM          :  6;     
N      __IO uint32_t  VSYNC_BP           :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_BP           :  1;     
N    } GBL_b;                                 /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  FW_CTRL;                /*!< CFG               */
X    volatile uint32_t  FW_CTRL;                 
N
N    struct {
N      __IO uint32_t  PEN_MODE     :  1;    /*!<                   */
X      volatile uint32_t  PEN_MODE     :  1;     
N      __IO uint32_t  VSYNC_IN     :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN     :  1;     
N      __IO uint32_t  TSYNC_IN     :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN     :  1;     
N    } FW_CTRL_b;                           /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  IN_CTRL;                 /*!< CFG               */
X    volatile uint32_t  IN_CTRL;                  
N
N    struct {
N      __IO uint32_t  TSYNC_MNT_ENA      :  1;   /*!<                   */
X      volatile uint32_t  TSYNC_MNT_ENA      :  1;    
N      __IO uint32_t  TSYNC_MNT_CLR      :  1;   /*!<                   */
X      volatile uint32_t  TSYNC_MNT_CLR      :  1;    
N      __IO uint32_t  FR_SEL_POINT       :  2;   /*!<                   */
X      volatile uint32_t  FR_SEL_POINT       :  2;    
N      __IO uint32_t  FR_TSYNC_PRD       :  16;  /*!<                   */
X      volatile uint32_t  FR_TSYNC_PRD       :  16;   
N      __IO uint32_t  FR_TSYNC_NUM       :  6;   /*!<                   */
X      volatile uint32_t  FR_TSYNC_NUM       :  6;    
N      __IO uint32_t  SYNC_AUTO_CLR      :  1;   /*!<                   */
X      volatile uint32_t  SYNC_AUTO_CLR      :  1;    
N      __IO uint32_t  SEL_ECLK_AUTO      :  1;   /*!<                   */
X      volatile uint32_t  SEL_ECLK_AUTO      :  1;    
N      __IO uint32_t  ENA_VSYNC_INIT     :  1;   /*!<                   */
X      volatile uint32_t  ENA_VSYNC_INIT     :  1;    
N      __IO uint32_t  ENA_TSYNC_INIT     :  1;   /*!<                   */
X      volatile uint32_t  ENA_TSYNC_INIT     :  1;    
N      __IO uint32_t  TSYNC_FREQ_EN_FG_L :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FREQ_EN_FG_L :  1;     
N    } IN_CTRL_b;                            /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  TSYNC_LTD;           /*!< CFG               */
X    volatile uint32_t  TSYNC_LTD;            
N
N    struct {
N      __IO uint32_t  HIGH       :  16;  /*!<                   */
X      volatile uint32_t  HIGH       :  16;   
N      __IO uint32_t  LOW        :  16;  /*!<                   */
X      volatile uint32_t  LOW        :  16;   
N    } TSYNC_LTD_b;                      /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  FG_0 ;           /*!< CFG               */
X    volatile uint32_t  FG_0 ;            
N
N    struct {
N      __IO uint32_t  LHB_01     :  2;   /*!<                   */
X      volatile uint32_t  LHB_01     :  2;    
N      __IO uint32_t  LHB_02     :  2;   /*!<                   */
X      volatile uint32_t  LHB_02     :  2;    
N      __IO uint32_t  LHB_03     :  2;   /*!<                   */
X      volatile uint32_t  LHB_03     :  2;    
N      __IO uint32_t  LHB_04     :  2;   /*!<                   */
X      volatile uint32_t  LHB_04     :  2;    
N      __IO uint32_t  LHB_05     :  2;   /*!<                   */
X      volatile uint32_t  LHB_05     :  2;    
N      __IO uint32_t  LHB_06     :  2;   /*!<                   */
X      volatile uint32_t  LHB_06     :  2;    
N      __IO uint32_t  LHB_07     :  2;   /*!<                   */
X      volatile uint32_t  LHB_07     :  2;    
N      __IO uint32_t  LHB_08     :  2;   /*!<                   */
X      volatile uint32_t  LHB_08     :  2;    
N      __IO uint32_t  LHB_09     :  2;   /*!<                   */
X      volatile uint32_t  LHB_09     :  2;    
N      __IO uint32_t  LHB_10     :  2;   /*!<                   */
X      volatile uint32_t  LHB_10     :  2;    
N      __IO uint32_t  LHB_11     :  2;   /*!<                   */
X      volatile uint32_t  LHB_11     :  2;    
N      __IO uint32_t  LHB_12     :  2;   /*!<                   */
X      volatile uint32_t  LHB_12     :  2;    
N      __IO uint32_t  LHB_13     :  2;   /*!<                   */
X      volatile uint32_t  LHB_13     :  2;    
N      __IO uint32_t  LHB_14     :  2;   /*!<                   */
X      volatile uint32_t  LHB_14     :  2;    
N      __IO uint32_t  LHB_15     :  2;   /*!<                   */
X      volatile uint32_t  LHB_15     :  2;    
N      __IO uint32_t  LHB_16     :  2;   /*!<                   */
X      volatile uint32_t  LHB_16     :  2;    
N    } FG_0_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  FG_1 ;           /*!< CFG               */
X    volatile uint32_t  FG_1 ;            
N
N    struct {
N      __IO uint32_t  LHB_17     :  2;   /*!<                   */
X      volatile uint32_t  LHB_17     :  2;    
N      __IO uint32_t  LHB_18     :  2;   /*!<                   */
X      volatile uint32_t  LHB_18     :  2;    
N      __IO uint32_t  LHB_19     :  2;   /*!<                   */
X      volatile uint32_t  LHB_19     :  2;    
N      __IO uint32_t  LHB_20     :  2;   /*!<                   */
X      volatile uint32_t  LHB_20     :  2;    
N      __IO uint32_t  LHB_21     :  2;   /*!<                   */
X      volatile uint32_t  LHB_21     :  2;    
N      __IO uint32_t  LHB_22     :  2;   /*!<                   */
X      volatile uint32_t  LHB_22     :  2;    
N      __IO uint32_t  LHB_23     :  2;   /*!<                   */
X      volatile uint32_t  LHB_23     :  2;    
N      __IO uint32_t  LHB_24     :  2;   /*!<                   */
X      volatile uint32_t  LHB_24     :  2;    
N      __IO uint32_t  LHB_25     :  2;   /*!<                   */
X      volatile uint32_t  LHB_25     :  2;    
N      __IO uint32_t  LHB_26     :  2;   /*!<                   */
X      volatile uint32_t  LHB_26     :  2;    
N      __IO uint32_t  LHB_27     :  2;   /*!<                   */
X      volatile uint32_t  LHB_27     :  2;    
N      __IO uint32_t  LHB_28     :  2;   /*!<                   */
X      volatile uint32_t  LHB_28     :  2;    
N      __IO uint32_t  LHB_29     :  2;   /*!<                   */
X      volatile uint32_t  LHB_29     :  2;    
N      __IO uint32_t  LHB_30     :  2;   /*!<                   */
X      volatile uint32_t  LHB_30     :  2;    
N      __IO uint32_t  LHB_31     :  2;   /*!<                   */
X      volatile uint32_t  LHB_31     :  2;    
N      __IO uint32_t  LHB_32     :  2;   /*!<                   */
X      volatile uint32_t  LHB_32     :  2;    
N    } FG_1_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  PN_0 ;           /*!< CFG               */
X    volatile uint32_t  PN_0 ;            
N
N    struct {
N      __IO uint32_t  LHB_01     :  2;   /*!<                   */
X      volatile uint32_t  LHB_01     :  2;    
N      __IO uint32_t  LHB_02     :  2;   /*!<                   */
X      volatile uint32_t  LHB_02     :  2;    
N      __IO uint32_t  LHB_03     :  2;   /*!<                   */
X      volatile uint32_t  LHB_03     :  2;    
N      __IO uint32_t  LHB_04     :  2;   /*!<                   */
X      volatile uint32_t  LHB_04     :  2;    
N      __IO uint32_t  LHB_05     :  2;   /*!<                   */
X      volatile uint32_t  LHB_05     :  2;    
N      __IO uint32_t  LHB_06     :  2;   /*!<                   */
X      volatile uint32_t  LHB_06     :  2;    
N      __IO uint32_t  LHB_07     :  2;   /*!<                   */
X      volatile uint32_t  LHB_07     :  2;    
N      __IO uint32_t  LHB_08     :  2;   /*!<                   */
X      volatile uint32_t  LHB_08     :  2;    
N      __IO uint32_t  LHB_09     :  2;   /*!<                   */
X      volatile uint32_t  LHB_09     :  2;    
N      __IO uint32_t  LHB_10     :  2;   /*!<                   */
X      volatile uint32_t  LHB_10     :  2;    
N      __IO uint32_t  LHB_11     :  2;   /*!<                   */
X      volatile uint32_t  LHB_11     :  2;    
N      __IO uint32_t  LHB_12     :  2;   /*!<                   */
X      volatile uint32_t  LHB_12     :  2;    
N      __IO uint32_t  LHB_13     :  2;   /*!<                   */
X      volatile uint32_t  LHB_13     :  2;    
N      __IO uint32_t  LHB_14     :  2;   /*!<                   */
X      volatile uint32_t  LHB_14     :  2;    
N      __IO uint32_t  LHB_15     :  2;   /*!<                   */
X      volatile uint32_t  LHB_15     :  2;    
N      __IO uint32_t  LHB_16     :  2;   /*!<                   */
X      volatile uint32_t  LHB_16     :  2;    
N    } PN_0_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  PN_1 ;           /*!< CFG               */
X    volatile uint32_t  PN_1 ;            
N
N    struct {
N      __IO uint32_t  LHB_17     :  2;   /*!<                   */
X      volatile uint32_t  LHB_17     :  2;    
N      __IO uint32_t  LHB_18     :  2;   /*!<                   */
X      volatile uint32_t  LHB_18     :  2;    
N      __IO uint32_t  LHB_19     :  2;   /*!<                   */
X      volatile uint32_t  LHB_19     :  2;    
N      __IO uint32_t  LHB_20     :  2;   /*!<                   */
X      volatile uint32_t  LHB_20     :  2;    
N      __IO uint32_t  LHB_21     :  2;   /*!<                   */
X      volatile uint32_t  LHB_21     :  2;    
N      __IO uint32_t  LHB_22     :  2;   /*!<                   */
X      volatile uint32_t  LHB_22     :  2;    
N      __IO uint32_t  LHB_23     :  2;   /*!<                   */
X      volatile uint32_t  LHB_23     :  2;    
N      __IO uint32_t  LHB_24     :  2;   /*!<                   */
X      volatile uint32_t  LHB_24     :  2;    
N      __IO uint32_t  LHB_25     :  2;   /*!<                   */
X      volatile uint32_t  LHB_25     :  2;    
N      __IO uint32_t  LHB_26     :  2;   /*!<                   */
X      volatile uint32_t  LHB_26     :  2;    
N      __IO uint32_t  LHB_27     :  2;   /*!<                   */
X      volatile uint32_t  LHB_27     :  2;    
N      __IO uint32_t  LHB_28     :  2;   /*!<                   */
X      volatile uint32_t  LHB_28     :  2;    
N      __IO uint32_t  LHB_29     :  2;   /*!<                   */
X      volatile uint32_t  LHB_29     :  2;    
N      __IO uint32_t  LHB_30     :  2;   /*!<                   */
X      volatile uint32_t  LHB_30     :  2;    
N      __IO uint32_t  LHB_31     :  2;   /*!<                   */
X      volatile uint32_t  LHB_31     :  2;    
N      __IO uint32_t  LHB_32     :  2;   /*!<                   */
X      volatile uint32_t  LHB_32     :  2;    
N    } PN_1_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSYNC_FREQ ;       /*!< CFG               */
X    volatile uint32_t  VSYNC_FREQ ;        
N
N    struct {
N      __IO uint32_t  F0_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F0_TSYNC :  6;    
N      __IO uint32_t  F1_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F1_TSYNC :  6;    
N      __IO uint32_t  F2_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F2_TSYNC :  6;    
N      __IO uint32_t  F3_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F3_TSYNC :  6;    
N    } VSYNC_FREQ_b;                   /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSYNC_F1_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F1_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } VSYNC_F1_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F1_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F1_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY :  16;   /*!<                   */
X      volatile uint32_t  DLY :  16;    
N    } VSYNC_F1_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F1_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F1_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } VSYNC_F1_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  VSYNC_F2_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F2_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } VSYNC_F2_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F2_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F2_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY :  16;   /*!<                   */
X      volatile uint32_t  DLY :  16;    
N    } VSYNC_F2_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F2_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F2_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } VSYNC_F2_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  VSYNC_F3_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F3_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } VSYNC_F3_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F3_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F3_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY :  16;   /*!<                   */
X      volatile uint32_t  DLY :  16;    
N    } VSYNC_F3_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F3_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F3_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } VSYNC_F3_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  PRLG ;           /*!< CFG               */
X    volatile uint32_t  PRLG ;            
N
N    struct {
N      __IO uint32_t  DLY_0 :  16;   /*!<                   */
X      volatile uint32_t  DLY_0 :  16;    
N      __IO uint32_t  DLY_1 :  16;   /*!<                   */
X      volatile uint32_t  DLY_1 :  16;    
N    } PRLG_b;                       /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  PRE_0 ;          /*!< CFG               */
X    volatile uint32_t  PRE_0 ;           
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;  /*!<                   */
X      volatile uint32_t  TX_PRD :  16;   
N      __IO uint32_t  TX_LOW :  16;  /*!<                   */
X      volatile uint32_t  TX_LOW :  16;   
N    } PRE_0_b;                      /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PRE_1 ;          /*!< CFG               */
X    volatile uint32_t  PRE_1 ;           
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10; /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;  
N      __IO uint32_t  PRE_DLY :  16; /*!<                   */
X      volatile uint32_t  PRE_DLY :  16;  
N    } PRE_1_b;                      /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PRE_2 ;          /*!< CFG               */
X    volatile uint32_t  PRE_2 ;           
N
N    struct {
N      __IO uint32_t  DSSS_DLY :  8; /*!<                   */
X      volatile uint32_t  DSSS_DLY :  8;  
N    } PRE_2_b;                      /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  EPLG_0 ;               /*!< CFG               */
X    volatile uint32_t  EPLG_0 ;                
N
N    struct {
N      __IO uint32_t  DLY_0_BEACON :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_BEACON :  16;   
N      __IO uint32_t  DLY_1        :  16;  /*!<                   */
X      volatile uint32_t  DLY_1        :  16;   
N    } EPLG_0_b;                           /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  EPLG_1 ;               /*!< CFG               */
X    volatile uint32_t  EPLG_1 ;                
N
N    struct {
N      __IO uint32_t  DLY_0_PING_FG_F  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_FG_F  :  16;   
N      __IO uint32_t  DLY_0_PING_FG_L  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_FG_L  :  16;   
N    } EPLG_1_b;                           /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  EPLG_2 ;               /*!< CFG               */
X    volatile uint32_t  EPLG_2 ;                
N
N    struct {
N      __IO uint32_t  DLY_0_PING_PN_P  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_PN_P  :  16;   
N      __IO uint32_t  DLY_0_PING_PN_D  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_PN_D  :  16;   
N    } EPLG_2_b;                           /*!< BitSize           */
N  };
N
N
N
N//union {
N//  __IO uint32_t  FG_L_ACT_0 ;   /*!< CFG               */
N//
N//  struct {
N//    __IO uint32_t  TX_PRD :  16;    /*!<                   */
N//    __IO uint32_t  TX_LOW :  16;    /*!<                   */
N//  } FG_L_ACT_0_b;               /*!< BitSize           */
N//};
N//
N//union {
N//  __IO uint32_t  FG_L_ACT_1 ;   /*!< CFG               */
N//
N//  struct {
N//    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
N//    __IO uint32_t  DLY     :  16;   /*!<                   */
N//  } FG_L_ACT_1_b;               /*!< BitSize           */
N//};
N//
N//union {
N//  __IO uint32_t  FG_L_ACT_2 ;   /*!< CFG               */
N//
N//  struct {
N//    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
N//  } FG_L_ACT_2_b;               /*!< BitSize           */
N//};
N
N
Nunion {
N  __IO uint32_t  FG_L_F0_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F0_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F0_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F0_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F0_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F0_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F0_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F0_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F0_ACT_2_b;               /*!< BitSize           */
N};
N
N
Nunion {
N  __IO uint32_t  FG_L_F1_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F1_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F1_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F1_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F1_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F1_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F1_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F1_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F1_ACT_2_b;               /*!< BitSize           */
N};
N
N
Nunion {
N  __IO uint32_t  FG_L_F2_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F2_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F2_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F2_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F2_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F2_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F2_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F2_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F2_ACT_2_b;               /*!< BitSize           */
N};
N
N
Nunion {
N  __IO uint32_t  FG_L_F3_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F3_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F3_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F3_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F3_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F3_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F3_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F3_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F3_ACT_2_b;               /*!< BitSize           */
N};
N
N
N
N  union {
N    __IO uint32_t  PN_P_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  PN_P_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } PN_P_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_P_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  PN_P_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } PN_P_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_P_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  PN_P_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } PN_P_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  PN_D_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  PN_D_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } PN_D_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_D_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  PN_D_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } PN_D_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_D_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  PN_D_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } PN_D_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N
N  union {
N    __IO uint32_t  FG_F_F0_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F0_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F0_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F0_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F0_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } FG_F_F0_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F0_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F0_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F0_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  FG_F_F1_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F1_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F1_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F1_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F1_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } FG_F_F1_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F1_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F1_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F1_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  FG_F_F2_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F2_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F2_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F2_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F2_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } FG_F_F2_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F2_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F2_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F2_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  FG_F_F3_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F3_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F3_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F3_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F3_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM :  10;    
N      __IO uint32_t  DLY    :  16;   /*!<                   */
X      volatile uint32_t  DLY    :  16;    
N    } FG_F_F3_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F3_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F3_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F3_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSWT_SET;          /*!< CFG               */
X    volatile uint32_t  VSWT_SET;           
N
N    struct {
N      __IO uint32_t  INT_0  :  4;     /*!<                   */
X      volatile uint32_t  INT_0  :  4;      
N      __IO uint32_t  INT_1  :  4;     /*!<                   */
X      volatile uint32_t  INT_1  :  4;      
N      __IO uint32_t  INT_2  :  4;     /*!<                   */
X      volatile uint32_t  INT_2  :  4;      
N      __IO uint32_t  INT_3  :  4;     /*!<                   */
X      volatile uint32_t  INT_3  :  4;      
N    } VSWT_SET_b;                     /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  DSSS_INFO_0  ;           /*!< CFG               */
X    volatile uint32_t  DSSS_INFO_0  ;            
N
N    struct {
N      __IO uint32_t  PING_FG     :  5;     /*!<                   */
X      volatile uint32_t  PING_FG     :  5;      
N      __IO uint32_t  PING_PNPOS  :  5;     /*!<                   */
X      volatile uint32_t  PING_PNPOS  :  5;      
N      __IO uint32_t  PING_PNDAT  :  5;     /*!<                   */
X      volatile uint32_t  PING_PNDAT  :  5;      
N    } DSSS_INFO_0_b;                        /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  DSSS_INFO_1  ;           /*!< CFG               */
X    volatile uint32_t  DSSS_INFO_1  ;            
N
N    struct {
N      __IO uint32_t  BEACON_D0    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D0    :  5;      
N      __IO uint32_t  BEACON_D1    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D1    :  5;      
N      __IO uint32_t  BEACON_D2    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D2    :  5;      
N      __IO uint32_t  BEACON_D3    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D3    :  5;      
N      __IO uint32_t  BEACON_D4    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D4    :  5;      
N      __IO uint32_t  BEACON_D5    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D5    :  5;      
N    } DSSS_INFO_1_b;                        /*!< BitSize           */
N  };
N
N
N  __IO uint32_t  DSSS_CODE_P_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_P_0  ;  
N  __IO uint32_t  DSSS_CODE_P_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_P_1  ;  
N
N  __IO uint32_t  DSSS_CODE_0_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_0_0  ;  
N  __IO uint32_t  DSSS_CODE_0_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_0_1  ;  
N
N  __IO uint32_t  DSSS_CODE_1_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_1_0  ;  
N  __IO uint32_t  DSSS_CODE_1_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_1_1  ;  
N
N  __IO uint32_t  DSSS_CODE_2_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_2_0  ;  
N  __IO uint32_t  DSSS_CODE_2_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_2_1  ;  
N
N  __IO uint32_t  DSSS_CODE_3_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_3_0  ;  
N  __IO uint32_t  DSSS_CODE_3_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_3_1  ;  
N
N  __IO uint32_t  DSSS_CODE_4_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_4_0  ;  
N  __IO uint32_t  DSSS_CODE_4_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_4_1  ;  
N
N  __IO uint32_t  DSSS_CODE_5_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_5_0  ;  
N  __IO uint32_t  DSSS_CODE_5_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_5_1  ;  
N
N  __IO uint32_t  DSSS_CODE_6_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_6_0  ;  
N  __IO uint32_t  DSSS_CODE_6_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_6_1  ;  
N
N  __IO uint32_t  DSSS_CODE_7_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_7_0  ;  
N  __IO uint32_t  DSSS_CODE_7_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_7_1  ;  
N
N
N  union {
N    __IO uint32_t  ENA_PWM_0 ;     /*!< CFG               */
X    volatile uint32_t  ENA_PWM_0 ;      
N
N    struct {
N      __IO uint32_t  T_0 :  7;     /*!<                   */
X      volatile uint32_t  T_0 :  7;      
N      __IO uint32_t  T_1 :  7;     /*!<                   */
X      volatile uint32_t  T_1 :  7;      
N      __IO uint32_t  T_2 :  7;     /*!<                   */
X      volatile uint32_t  T_2 :  7;      
N    } ENA_PWM_0_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  ENA_PWM_1 ;     /*!< CFG               */
X    volatile uint32_t  ENA_PWM_1 ;      
N
N    struct {
N      __IO uint32_t  T_3 :  7;     /*!<                   */
X      volatile uint32_t  T_3 :  7;      
N      __IO uint32_t  T_4 :  7;     /*!<                   */
X      volatile uint32_t  T_4 :  7;      
N    } ENA_PWM_1_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INV_PWM_0 ;     /*!< CFG               */
X    volatile uint32_t  INV_PWM_0 ;      
N
N    struct {
N      __IO uint32_t  T_0 :  7;     /*!<                   */
X      volatile uint32_t  T_0 :  7;      
N      __IO uint32_t  T_1 :  7;     /*!<                   */
X      volatile uint32_t  T_1 :  7;      
N      __IO uint32_t  T_2 :  7;     /*!<                   */
X      volatile uint32_t  T_2 :  7;      
N    } INV_PWM_0_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INV_PWM_1 ;     /*!< CFG               */
X    volatile uint32_t  INV_PWM_1 ;      
N
N    struct {
N      __IO uint32_t  T_3 :  7;     /*!<                   */
X      volatile uint32_t  T_3 :  7;      
N      __IO uint32_t  T_4 :  7;     /*!<                   */
X      volatile uint32_t  T_4 :  7;      
N    } INV_PWM_1_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSWT_CFG_0 ;           /*!< CFG               */
X    volatile uint32_t  VSWT_CFG_0 ;            
N
N    struct {
N      __IO uint32_t  SEL_VSWT_0     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_0     : 4;   
N      __IO uint32_t  SEL_VSWT_1     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_1     : 4;   
N      __IO uint32_t  SEL_VSWT_2     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_2     : 4;   
N      __IO uint32_t  SEL_VSWT_3     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_3     : 4;   
N      __IO uint32_t  SEL_0_pwm_tx   : 3;  /*!<                   */
X      volatile uint32_t  SEL_0_pwm_tx   : 3;   
N      __IO uint32_t  SEL_0_pwm_data : 3;  /*!<                   */
X      volatile uint32_t  SEL_0_pwm_data : 3;   
N      __IO uint32_t  SEL_0_pwm_gate : 3;  /*!<                   */
X      volatile uint32_t  SEL_0_pwm_gate : 3;   
N      __IO uint32_t  SEL_1_pwm_tx   : 2;  /*!<                   */
X      volatile uint32_t  SEL_1_pwm_tx   : 2;   
N      __IO uint32_t  SEL_1_pwm_data : 2;  /*!<                   */
X      volatile uint32_t  SEL_1_pwm_data : 2;   
N      __IO uint32_t  SEL_1_pwm_gate : 2;  /*!<                   */
X      volatile uint32_t  SEL_1_pwm_gate : 2;   
N    } VSWT_CFG_0_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSWT_CFG_1 ;               /*!< CFG               */
X    volatile uint32_t  VSWT_CFG_1 ;                
N
N    struct {
N      __IO uint32_t  SEL_TSYNC_INV    : 1;    /*!<                   */
X      volatile uint32_t  SEL_TSYNC_INV    : 1;     
N      __IO uint32_t  SEL_TSYNC_OUT    : 2;    /*!<                   */
X      volatile uint32_t  SEL_TSYNC_OUT    : 2;     
N      __IO uint32_t  DLY_SEL_PWM_PRE  : 3;    /*!<                   */
X      volatile uint32_t  DLY_SEL_PWM_PRE  : 3;     
N      __IO uint32_t  DLY_SEL_PWM_ACT  : 3;    /*!<                   */
X      volatile uint32_t  DLY_SEL_PWM_ACT  : 3;     
N      __IO uint32_t  DLY_ENA_PWM_TX   : 1;    /*!<                   */
X      volatile uint32_t  DLY_ENA_PWM_TX   : 1;     
N      __IO uint32_t  DLY_ENA_PWM_DATA : 1;    /*!<                   */
X      volatile uint32_t  DLY_ENA_PWM_DATA : 1;     
N      __IO uint32_t  DLY_ENA_PWM_GATE : 1;    /*!<                   */
X      volatile uint32_t  DLY_ENA_PWM_GATE : 1;     
N      __IO uint32_t  DLY_BP_PRE_TX    : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PRE_TX    : 1;     
N      __IO uint32_t  DLY_BP_PRE_DATA  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PRE_DATA  : 1;     
N      __IO uint32_t  DLY_BP_PRE_GATE  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PRE_GATE  : 1;     
N      __IO uint32_t  DLY_BP_PWM_TX    : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PWM_TX    : 1;     
N      __IO uint32_t  DLY_BP_PWM_DATA  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PWM_DATA  : 1;     
N      __IO uint32_t  DLY_BP_PWM_GATE  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PWM_GATE  : 1;     
N      __IO uint32_t  DLY_INV_PWM_TX   : 1;    /*!<                   */
X      volatile uint32_t  DLY_INV_PWM_TX   : 1;     
N      __IO uint32_t  DLY_INV_PWM_DATA : 1;    /*!<                   */
X      volatile uint32_t  DLY_INV_PWM_DATA : 1;     
N      __IO uint32_t  DLY_INV_PWM_GATE : 1;    /*!<                   */
X      volatile uint32_t  DLY_INV_PWM_GATE : 1;     
N    } VSWT_CFG_1_b;                           /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  DLY_PWM_CFG_0  ;  /*!< CFG               */
X    volatile uint32_t  DLY_PWM_CFG_0  ;   
N
N    struct {
N      __IO uint32_t  TX   :  16;     /*!<                   */
X      volatile uint32_t  TX   :  16;      
N      __IO uint32_t  DATA :  16;     /*!<                   */
X      volatile uint32_t  DATA :  16;      
N    } DLY_PWM_CFG_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  DLY_PWM_CFG_1  ;  /*!< CFG               */
X    volatile uint32_t  DLY_PWM_CFG_1  ;   
N
N    struct {
N      __IO uint32_t  GATE :  16;     /*!<                   */
X      volatile uint32_t  GATE :  16;      
N    } DLY_PWM_CFG_1_b;               /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  WFE_CFG_0  ;               /*!< CFG               */
X    volatile uint32_t  WFE_CFG_0  ;                
N
N    struct {
N      __IO uint32_t  ENA  :  6;    /*!<                   */
X      volatile uint32_t  ENA  :  6;     
N      __IO uint32_t  SEL  :  6;    /*!<                   */
X      volatile uint32_t  SEL  :  6;     
N      __IO uint32_t  PUL  :  6;    /*!<                   */
X      volatile uint32_t  PUL  :  6;     
N      __IO uint32_t  DBG  :  6;    /*!<                   */
X      volatile uint32_t  DBG  :  6;     
N      __IO uint32_t  DRV  :  6;    /*!<                   */
X      volatile uint32_t  DRV  :  6;     
N    } WFE_CFG_0_b;                          /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  WFE_CFG_1  ;               /*!< CFG               */
X    volatile uint32_t  WFE_CFG_1  ;                
N
N    struct {
N      __IO uint32_t  DLY  :  6;    /*!<                   */
X      volatile uint32_t  DLY  :  6;     
N      __IO uint32_t  smpl :  8;    /*!<                   */
X      volatile uint32_t  smpl :  8;     
N    } WFE_CFG_1_b;                          /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INTR_CFG ;                  /*!< CFG               */
X    volatile uint32_t  INTR_CFG ;                   
N
N    struct {
N      __IO uint32_t  HI_ABOVE_NUM       :  6;    /*!<                   */
X      volatile uint32_t  HI_ABOVE_NUM       :  6;     
N      __IO uint32_t  LO_BELOW_NUM       :  6;    /*!<                   */
X      volatile uint32_t  LO_BELOW_NUM       :  6;     
N      __IO uint32_t  FSM_ON_IBE         :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON_IBE         :  1;     
N      __IO uint32_t  FSM_ON_IEV         :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON_IEV         :  1;     
N      __IO uint32_t  FSM_ON_IE          :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON_IE          :  1;     
N      __IO uint32_t  VSYNC_IN_EXT_IBE   :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT_IBE   :  1;     
N      __IO uint32_t  VSYNC_IN_EXT_IEV   :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT_IEV   :  1;     
N      __IO uint32_t  VSYNC_IN_EXT_IE    :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT_IE    :  1;     
N      __IO uint32_t  TSYNC_IN_EXT_IBE   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT_IBE   :  1;     
N      __IO uint32_t  TSYNC_IN_EXT_IEV   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT_IEV   :  1;     
N      __IO uint32_t  TSYNC_IN_EXT_IE    :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT_IE    :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT_IBE  :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT_IBE  :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT_IEV  :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT_IEV  :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT_IE   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT_IE   :  1;     
N      __IO uint32_t  TSYNC_FR_IBE       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR_IBE       :  1;     
N      __IO uint32_t  TSYNC_FR_IEV       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR_IEV       :  1;     
N      __IO uint32_t  TSYNC_FR_IE        :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR_IE        :  1;     
N      __IO uint32_t  TSYNC_MNT_IBE      :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT_IBE      :  1;     
N      __IO uint32_t  TSYNC_MNT_IEV      :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT_IEV      :  1;     
N      __IO uint32_t  TSYNC_MNT_IE       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT_IE       :  1;     
N    } INTR_CFG_b;                              /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INTR_CLR ;                /*!< CFG               */
X    volatile uint32_t  INTR_CLR ;                 
N
N    struct {
N      __IO uint32_t  FSM_ON         :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON         :  1;     
N      __IO uint32_t  VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT   :  1;     
N      __IO uint32_t  TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT   :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT  :  1;     
N      __IO uint32_t  TSYNC_FR       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR       :  1;     
N      __IO uint32_t  TSYNC_MNT      :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT      :  1;     
N    } INTR_CLR_b;                            /*!< BitSize           */
N  };
N
N
N  union {
N    __I  uint32_t  INTR_ST ;                    /*!< CFG               */
X    volatile const  uint32_t  INTR_ST ;                     
N
N    struct {
N      __I uint32_t  MIS_FSM_ON         :  1;    /*!<                   */
X      volatile const uint32_t  MIS_FSM_ON         :  1;     
N      __I uint32_t  MIS_VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  MIS_VSYNC_IN_EXT   :  1;     
N      __I uint32_t  MIS_TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_IN_EXT   :  1;     
N      __I uint32_t  MIS_TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_OUT_EXT  :  1;     
N      __I uint32_t  MIS_TSYNC_FR       :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_FR       :  1;     
N      __I uint32_t  MIS_TSYNC_MNT      :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_MNT      :  1;     
N      __I uint32_t  RIS_FSM_ON         :  1;    /*!<                   */
X      volatile const uint32_t  RIS_FSM_ON         :  1;     
N      __I uint32_t  RIS_VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  RIS_VSYNC_IN_EXT   :  1;     
N      __I uint32_t  RIS_TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_IN_EXT   :  1;     
N      __I uint32_t  RIS_TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_OUT_EXT  :  1;     
N      __I uint32_t  RIS_TSYNC_FR       :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_FR       :  1;     
N      __I uint32_t  RIS_TSYNC_MNT      :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_MNT      :  1;     
N      __I uint32_t  FSM_ON         :  1;    /*!<                   */
X      volatile const uint32_t  FSM_ON         :  1;     
N      __I uint32_t  VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  VSYNC_IN_EXT   :  1;     
N      __I uint32_t  TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_IN_EXT   :  1;     
N      __I uint32_t  TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_OUT_EXT  :  1;     
N      __I uint32_t  TSYNC_FR       :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_FR       :  1;     
N      __I uint32_t  TSYNC_MNT      :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_MNT      :  1;     
N    } INTR_ST_b;                                /*!< BitSize           */
N  };
N
N	union {
N	  __IO	uint32_t  DSSS_CFG ;
X	  volatile	uint32_t  DSSS_CFG ;
N
N	  struct {
N		__IO uint32_t  beacon_en		 :	1;
X		volatile uint32_t  beacon_en		 :	1;
N		__IO uint32_t  ping_en			 :	1;
X		volatile uint32_t  ping_en			 :	1;
N		__IO uint32_t  dsss_sel 		 :	1;
X		volatile uint32_t  dsss_sel 		 :	1;
N	  } DSSS_CFG_b;
N	};
N
N	__IO  uint32_t	USI_CHIP_LEN ;
X	volatile  uint32_t	USI_CHIP_LEN ;
N
N	union {
N	  __IO	uint32_t  USI_CODE_LEN ;
X	  volatile	uint32_t  USI_CODE_LEN ;
N
N	  struct {
N		__IO uint32_t  beacon			 :	6;
X		volatile uint32_t  beacon			 :	6;
N		__IO uint32_t  finger			 :	6;
X		volatile uint32_t  finger			 :	6;
N		__IO uint32_t  penpos			 :	6;
X		volatile uint32_t  penpos			 :	6;
N		__IO uint32_t  pendat			 :	6;
X		volatile uint32_t  pendat			 :	6;
N	  } USI_CODE_LEN_b;
N	};
N
N	__IO  uint32_t	USI_DSSS_CHIP0 ;
X	volatile  uint32_t	USI_DSSS_CHIP0 ;
N	__IO  uint32_t	USI_DSSS_CHIP1 ;
X	volatile  uint32_t	USI_DSSS_CHIP1 ;
N	__IO  uint32_t	USI_BEACON_CODE0 ;
X	volatile  uint32_t	USI_BEACON_CODE0 ;
N	__IO  uint32_t	USI_BEACON_CODE1 ;
X	volatile  uint32_t	USI_BEACON_CODE1 ;
N
N
N	union {
N	  __IO	uint32_t  USI_PING_CODE ;
X	  volatile	uint32_t  USI_PING_CODE ;
N
N	  struct {
N		__IO uint32_t  ping_finger		 :	8;
X		volatile uint32_t  ping_finger		 :	8;
N		__IO uint32_t  ping_penpos		 :	8;
X		volatile uint32_t  ping_penpos		 :	8;
N		__IO uint32_t  ping_pendat		 :	8;
X		volatile uint32_t  ping_pendat		 :	8;
N	  } USI_PING_CODE_b;
N	};
N
N
N} PWMDRV_TypeDef;
N
N
N#endif /* __PWMDRV_H_ */
L 288 "..\..\Hal\system\MFTP.h" 2
N#include "_dsp.h"
L 1 "..\..\Hal\dspB\_dsp.h" 1
N#ifndef _DSP_H_
N#define _DSP_H_
N
N
Ntypedef union
N{
N    struct {
N        unsigned    XSIZE0:                    8;
N        unsigned    XSIZE1:                    8;
N        unsigned    XSIZE2:                    8;
N        unsigned    XSIZE3:                    8;
N    } b;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TDSP_DMA_XSIZE;
N
Ntypedef union
N{
N    struct {
N        unsigned    YSIZE0:                    8;
N        unsigned    YSIZE1:                    8;
N        unsigned    YSIZE2:                    8;
N        unsigned    YSIZE3:                    8;
N    } b;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TDSP_DMA_YSIZE;
N
N
Ntypedef struct
N{
N    __IO uint32_t                    TDSP_REGA0;                     //0x0000
X    volatile uint32_t                    TDSP_REGA0;                     
N    __IO uint32_t                    TDSP_REGA1;                     //0x0001
X    volatile uint32_t                    TDSP_REGA1;                     
N    __IO uint32_t                    TDSP_REGA2;                     //0x0002
X    volatile uint32_t                    TDSP_REGA2;                     
N    __IO uint32_t                    TDSP_REGA3;                     //0x0003
X    volatile uint32_t                    TDSP_REGA3;                     
N    __IO uint32_t                    TDSP_REGA4;                     //0x0004
X    volatile uint32_t                    TDSP_REGA4;                     
N    __IO uint32_t                    TDSP_REGA5;                     //0x0005
X    volatile uint32_t                    TDSP_REGA5;                     
N    __IO uint32_t                    TDSP_REGA6;                     //0x0006
X    volatile uint32_t                    TDSP_REGA6;                     
N    __IO uint32_t                    TDSP_REGA7;                     //0x0007
X    volatile uint32_t                    TDSP_REGA7;                     
N    __IO uint32_t                    TDSP_REGB0;                     //0x0008
X    volatile uint32_t                    TDSP_REGB0;                     
N    __IO uint32_t                    TDSP_REGB1;                     //0x0009
X    volatile uint32_t                    TDSP_REGB1;                     
N    __IO uint32_t                    TDSP_REGB2;                     //0x000A
X    volatile uint32_t                    TDSP_REGB2;                     
N    __IO uint32_t                    TDSP_REGB3;                     //0x000B
X    volatile uint32_t                    TDSP_REGB3;                     
N    __IO uint32_t                    TDSP_REGB4;                     //0x000C
X    volatile uint32_t                    TDSP_REGB4;                     
N    __IO uint32_t                    TDSP_REGB5;                     //0x000D
X    volatile uint32_t                    TDSP_REGB5;                     
N    __IO uint32_t                    TDSP_REGB6;                     //0x000E
X    volatile uint32_t                    TDSP_REGB6;                     
N    __IO uint32_t                    TDSP_REGB7;                     //0x000F
X    volatile uint32_t                    TDSP_REGB7;                     
N    __IO uint32_t                    TDSP_REGC0;                     //0x0010
X    volatile uint32_t                    TDSP_REGC0;                     
N    __IO uint32_t                    TDSP_REGC1;                     //0x0011
X    volatile uint32_t                    TDSP_REGC1;                     
N    __IO uint32_t                    TDSP_REGC2;                     //0x0012
X    volatile uint32_t                    TDSP_REGC2;                     
N    __IO uint32_t                    TDSP_REGC3;                     //0x0013
X    volatile uint32_t                    TDSP_REGC3;                     
N    __IO uint32_t                    TDSP_REGC4;                     //0x0014
X    volatile uint32_t                    TDSP_REGC4;                     
N    __IO uint32_t                    TDSP_REGC5;                     //0x0015
X    volatile uint32_t                    TDSP_REGC5;                     
N    __IO uint32_t                    TDSP_REGC6;                     //0x0016
X    volatile uint32_t                    TDSP_REGC6;                     
N    __IO uint32_t                    TDSP_REGC7;                     //0x0017
X    volatile uint32_t                    TDSP_REGC7;                     
N    __IO uint32_t                    TDSP_RESERVED00;                //0x0018
X    volatile uint32_t                    TDSP_RESERVED00;                
N    __IO uint32_t                    TDSP_RESERVED01;                //0x0019
X    volatile uint32_t                    TDSP_RESERVED01;                
N    __IO uint32_t                    TDSP_RESERVED02;                //0x001A
X    volatile uint32_t                    TDSP_RESERVED02;                
N    __IO uint32_t                    TDSP_RESERVED03;                //0x001B
X    volatile uint32_t                    TDSP_RESERVED03;                
N    __IO uint32_t                    TDSP_RESERVED04;                //0x001C
X    volatile uint32_t                    TDSP_RESERVED04;                
N    __IO uint32_t                    TDSP_RESERVED05;                //0x001D
X    volatile uint32_t                    TDSP_RESERVED05;                
N    __IO uint32_t                    TDSP_RESERVED06;                //0x001E
X    volatile uint32_t                    TDSP_RESERVED06;                
N    __IO uint32_t                    TDSP_RESERVED07;                //0x001F
X    volatile uint32_t                    TDSP_RESERVED07;                
N    __I  uint32_t                    TDSP_RESERVED07_1;              //0x0020
X    volatile const  uint32_t                    TDSP_RESERVED07_1;              
N    __IO uint32_t                    TDSP_RESERVED07_2;              //0x0021
X    volatile uint32_t                    TDSP_RESERVED07_2;              
N    __IO uint32_t                    TDSP_RESERVED08;                //0x0022
X    volatile uint32_t                    TDSP_RESERVED08;                
N    __IO uint32_t                    TDSP_RESERVED09;                //0x0023
X    volatile uint32_t                    TDSP_RESERVED09;                
N    __IO uint32_t                    TDSP_RESERVED10;                //0x0024
X    volatile uint32_t                    TDSP_RESERVED10;                
N    __IO uint32_t                    TDSP_RESERVED11;                //0x0025
X    volatile uint32_t                    TDSP_RESERVED11;                
N    __IO uint32_t                    TDSP_RESERVED12;                //0x0026
X    volatile uint32_t                    TDSP_RESERVED12;                
N    __IO uint32_t                    TDSP_RESERVED13;                //0x0027
X    volatile uint32_t                    TDSP_RESERVED13;                
N    __IO uint32_t                    TDSP_RESERVED14;                //0x0028
X    volatile uint32_t                    TDSP_RESERVED14;                
N    __IO uint32_t                    TDSP_RESERVED15;                //0x0029
X    volatile uint32_t                    TDSP_RESERVED15;                
N    __IO uint32_t                    TDSP_RESERVED16;                //0x002A
X    volatile uint32_t                    TDSP_RESERVED16;                
N    __IO uint32_t                    TDSP_RESERVED17;                //0x002B
X    volatile uint32_t                    TDSP_RESERVED17;                
N    __IO uint32_t                    TDSP_RESERVED18;                //0x002C
X    volatile uint32_t                    TDSP_RESERVED18;                
N    __IO uint32_t                    TDSP_RESERVED19;                //0x002D
X    volatile uint32_t                    TDSP_RESERVED19;                
N    __IO uint32_t                    TDSP_RESERVED20;                //0x002E
X    volatile uint32_t                    TDSP_RESERVED20;                
N    __IO uint32_t                    TDSP_RESERVED21;                //0x002F
X    volatile uint32_t                    TDSP_RESERVED21;                
N    __IO uint32_t                    TDSP_RESERVED22;                //0x0030
X    volatile uint32_t                    TDSP_RESERVED22;                
N    __IO uint32_t                    TDSP_RESERVED23;                //0x0031
X    volatile uint32_t                    TDSP_RESERVED23;                
N    __IO uint32_t                    TDSP_RESERVED24;                //0x0032
X    volatile uint32_t                    TDSP_RESERVED24;                
N    __IO uint32_t                    TDSP_RESERVED25;                //0x0033
X    volatile uint32_t                    TDSP_RESERVED25;                
N    __IO uint32_t                    TDSP_RESERVED26;                //0x0034
X    volatile uint32_t                    TDSP_RESERVED26;                
N    __IO uint32_t                    TDSP_RESERVED27;                //0x0035
X    volatile uint32_t                    TDSP_RESERVED27;                
N    __IO uint32_t                    TDSP_RESERVED28;                //0x0036
X    volatile uint32_t                    TDSP_RESERVED28;                
N    __IO uint32_t                    TDSP_RESERVED29;                //0x0037
X    volatile uint32_t                    TDSP_RESERVED29;                
N    __IO uint32_t                    TDSP_RESERVED30;                //0x0038
X    volatile uint32_t                    TDSP_RESERVED30;                
N    __IO uint32_t                    TDSP_RESERVED31;                //0x0039
X    volatile uint32_t                    TDSP_RESERVED31;                
N    __IO uint32_t                    TDSP_RESERVED32;                //0x003A
X    volatile uint32_t                    TDSP_RESERVED32;                
N    __IO uint32_t                    TDSP_RESERVED33;                //0x003B
X    volatile uint32_t                    TDSP_RESERVED33;                
N    __IO uint32_t                    TDSP_RESERVED34;                //0x003C
X    volatile uint32_t                    TDSP_RESERVED34;                
N    __IO uint32_t                    TDSP_RESERVED35;                //0x003D
X    volatile uint32_t                    TDSP_RESERVED35;                
N    __IO uint32_t                    TDSP_RESERVED36;                //0x003E
X    volatile uint32_t                    TDSP_RESERVED36;                
N    __IO uint32_t                    TDSP_RESERVED37;                //0x003F
X    volatile uint32_t                    TDSP_RESERVED37;                
N    __IO uint32_t                    TDSP_PC;                        //0x0040
X    volatile uint32_t                    TDSP_PC;                        
N    __I  uint32_t                    TDSP_RESERVED37_1;                //0x0041
X    volatile const  uint32_t                    TDSP_RESERVED37_1;                
N    __IO uint32_t                    TDSP_RESERVED37_2;                //0x0042
X    volatile uint32_t                    TDSP_RESERVED37_2;                
N    __IO uint32_t                    TDSP_RESERVED37_3;                //0x0043
X    volatile uint32_t                    TDSP_RESERVED37_3;                
N    __IO uint32_t                    TDSP_RESERVED37_4;                //0x0044
X    volatile uint32_t                    TDSP_RESERVED37_4;                
N    __IO uint32_t                    TDSP_RESERVED37_5;                //0x0045
X    volatile uint32_t                    TDSP_RESERVED37_5;                
N    __I  uint32_t                    TDSP_RESERVED37_6;                //0x0046
X    volatile const  uint32_t                    TDSP_RESERVED37_6;                
N    __I  uint32_t                    TDSP_RESERVED37_7;                //0x0047
X    volatile const  uint32_t                    TDSP_RESERVED37_7;                
N    __I  uint32_t                    TDSP_RESERVED37_8;                //0x0048
X    volatile const  uint32_t                    TDSP_RESERVED37_8;                
N    __I  uint32_t                    TDSP_BUSY;                      //0x0049
X    volatile const  uint32_t                    TDSP_BUSY;                      
N    __IO uint32_t                    TDSP_CACHE_BASE;                //0x004A
X    volatile uint32_t                    TDSP_CACHE_BASE;                
N    __IO uint32_t                    TDSP_RESERVED37_9;                //0x004B
X    volatile uint32_t                    TDSP_RESERVED37_9;                
N    __IO uint32_t            	     TDSP_RESERVED37_10;                 //0x004C
X    volatile uint32_t            	     TDSP_RESERVED37_10;                 
N    __IO uint32_t            		 TDSP_RESERVED37_11;                 //0x004D
X    volatile uint32_t            		 TDSP_RESERVED37_11;                 
N    __IO uint32_t            		 TDSP_RESERVED37_12;                 //0x004E
X    volatile uint32_t            		 TDSP_RESERVED37_12;                 
N    __IO uint32_t            		 TDSP_RESERVED37_13;                 //0x004F
X    volatile uint32_t            		 TDSP_RESERVED37_13;                 
N    __IO uint32_t           		 TDSP_RESERVED37_14;                //0x0050
X    volatile uint32_t           		 TDSP_RESERVED37_14;                
N    __I  uint32_t           		 TDSP_RESERVED37_15;                //0x0051
X    volatile const  uint32_t           		 TDSP_RESERVED37_15;                
N    __IO uint32_t         			 TDSP_RESERVED37_16;              //0x0052
X    volatile uint32_t         			 TDSP_RESERVED37_16;              
N    __IO uint32_t         			 TDSP_RESERVED37_17;              //0x0053
X    volatile uint32_t         			 TDSP_RESERVED37_17;              
N    __IO uint32_t         			 TDSP_RESERVED37_18;              //0x0054
X    volatile uint32_t         			 TDSP_RESERVED37_18;              
N    __IO uint32_t         			 TDSP_RESERVED37_19;              //0x0055
X    volatile uint32_t         			 TDSP_RESERVED37_19;              
N    __I  uint32_t                    TDSP_RESERVED38;                //0x0056
X    volatile const  uint32_t                    TDSP_RESERVED38;                
N    __IO uint32_t                    TDSP_RESERVED39;                //0x0057
X    volatile uint32_t                    TDSP_RESERVED39;                
N    __IO uint32_t                    TDSP_RESERVED40;                //0x0058
X    volatile uint32_t                    TDSP_RESERVED40;                
N    __IO uint32_t                    TDSP_RESERVED41;                //0x0059
X    volatile uint32_t                    TDSP_RESERVED41;                
N    __IO uint32_t                    TDSP_RESERVED42;                //0x005A
X    volatile uint32_t                    TDSP_RESERVED42;                
N    __IO uint32_t                    TDSP_RESERVED43;                //0x005B
X    volatile uint32_t                    TDSP_RESERVED43;                
N    __IO uint32_t                    TDSP_RESERVED44;                //0x005C
X    volatile uint32_t                    TDSP_RESERVED44;                
N    __IO uint32_t                    TDSP_RESERVED45;                //0x005D
X    volatile uint32_t                    TDSP_RESERVED45;                
N    __IO uint32_t                    TDSP_RESERVED46;                //0x005E
X    volatile uint32_t                    TDSP_RESERVED46;                
N    __IO uint32_t                    TDSP_RESERVED47;                //0x005F
X    volatile uint32_t                    TDSP_RESERVED47;                
N    __IO uint32_t                    TDSP_RESERVED48;                //0x0060
X    volatile uint32_t                    TDSP_RESERVED48;                
N    __IO uint32_t                    TDSP_RESERVED49;                //0x0061
X    volatile uint32_t                    TDSP_RESERVED49;                
N    __IO uint32_t                    TDSP_RESERVED50;                //0x0062
X    volatile uint32_t                    TDSP_RESERVED50;                
N    __IO uint32_t                    TDSP_RESERVED51;                //0x0063
X    volatile uint32_t                    TDSP_RESERVED51;                
N    __IO uint32_t                    TDSP_RESERVED52;                //0x0064
X    volatile uint32_t                    TDSP_RESERVED52;                
N    __IO uint32_t                    TDSP_RESERVED53;                //0x0065
X    volatile uint32_t                    TDSP_RESERVED53;                
N    __IO uint32_t                    TDSP_RESERVED54;                //0x0066
X    volatile uint32_t                    TDSP_RESERVED54;                
N    __IO uint32_t                    TDSP_RESERVED55;                //0x0067
X    volatile uint32_t                    TDSP_RESERVED55;                
N    __IO uint32_t                    TDSP_RESERVED56;                //0x0068
X    volatile uint32_t                    TDSP_RESERVED56;                
N    __IO uint32_t                    TDSP_RESERVED57;                //0x0069
X    volatile uint32_t                    TDSP_RESERVED57;                
N    __IO uint32_t                    TDSP_RESERVED58;                //0x006A
X    volatile uint32_t                    TDSP_RESERVED58;                
N    __IO uint32_t                    TDSP_RESERVED59;                //0x006B
X    volatile uint32_t                    TDSP_RESERVED59;                
N    __IO uint32_t                    TDSP_RESERVED60;                //0x006C
X    volatile uint32_t                    TDSP_RESERVED60;                
N    __IO uint32_t                    TDSP_RESERVED61;                //0x006D
X    volatile uint32_t                    TDSP_RESERVED61;                
N    __IO uint32_t                    TDSP_RESERVED62;                //0x006E
X    volatile uint32_t                    TDSP_RESERVED62;                
N    __IO uint32_t                    TDSP_RESERVED63;                //0x006F
X    volatile uint32_t                    TDSP_RESERVED63;                
N    __IO uint32_t                    TDSP_RESERVED64;                //0x0070
X    volatile uint32_t                    TDSP_RESERVED64;                
N    __IO uint32_t                    TDSP_RESERVED65;                //0x0071
X    volatile uint32_t                    TDSP_RESERVED65;                
N    __IO uint32_t                    TDSP_RESERVED66;                //0x0072
X    volatile uint32_t                    TDSP_RESERVED66;                
N    __IO uint32_t                    TDSP_RESERVED67;                //0x0073
X    volatile uint32_t                    TDSP_RESERVED67;                
N    __IO uint32_t                    TDSP_RESERVED68;                //0x0074
X    volatile uint32_t                    TDSP_RESERVED68;                
N    __IO uint32_t                    TDSP_RESERVED69;                //0x0075
X    volatile uint32_t                    TDSP_RESERVED69;                
N    __IO uint32_t                    TDSP_RESERVED70;                //0x0076
X    volatile uint32_t                    TDSP_RESERVED70;                
N    __IO uint32_t                    TDSP_RESERVED71;                //0x0077
X    volatile uint32_t                    TDSP_RESERVED71;                
N    __IO uint32_t                    TDSP_RESERVED72;                //0x0078
X    volatile uint32_t                    TDSP_RESERVED72;                
N    __IO uint32_t                    TDSP_RESERVED73;                //0x0079
X    volatile uint32_t                    TDSP_RESERVED73;                
N    __IO uint32_t                    TDSP_RESERVED74;                //0x007A
X    volatile uint32_t                    TDSP_RESERVED74;                
N    __IO uint32_t                    TDSP_RESERVED75;                //0x007B
X    volatile uint32_t                    TDSP_RESERVED75;                
N    __IO uint32_t                    TDSP_RESERVED76;                //0x007C
X    volatile uint32_t                    TDSP_RESERVED76;                
N    __IO uint32_t                    TDSP_RESERVED77;                //0x007D
X    volatile uint32_t                    TDSP_RESERVED77;                
N    __IO uint32_t                    TDSP_RESERVED78;                //0x007E
X    volatile uint32_t                    TDSP_RESERVED78;                
N    __IO uint32_t                    TDSP_RESERVED79;                //0x007F
X    volatile uint32_t                    TDSP_RESERVED79;                
N    __IO t_TDSP_DMA_XSIZE            TDSP_DMA_XSIZE;                 //0x0080
X    volatile t_TDSP_DMA_XSIZE            TDSP_DMA_XSIZE;                 
N    __IO t_TDSP_DMA_YSIZE            TDSP_DMA_YSIZE;                 //0x0081
X    volatile t_TDSP_DMA_YSIZE            TDSP_DMA_YSIZE;                 
N    __IO uint32_t                    TDSP_DMA_ADD;                   //0x0082
X    volatile uint32_t                    TDSP_DMA_ADD;                   
N} DSP_CONTROL_TypeDef;
N
N
N#endif /* _DSP_H_ */
L 289 "..\..\Hal\system\MFTP.h" 2
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group MFTP */
N/** @} */ /* End of group LG Display */
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N#define HW_REG(addr) (*((volatile unsigned long *)(addr)))
N#define READ_MEMORY32(Reg)		(*(__IO uint32_t*)Reg)
N#define READ_MEMORY16(Reg)		(*(__IO uint16_t*)Reg)
N#define READ_MEMORY8(Reg)		(*(__IO uint8_t*)Reg)
N#define WRITE_MEMORY32(reg,value) 	(READ_MEMORY32(reg) = value)
N#define WRITE_MEMORY16(reg,value) 	(READ_MEMORY16(reg) = value)
N#define WRITE_MEMORY8(reg,value)		(READ_MEMORY8(reg) = value)
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N#define READ_REG(REG)         ((REG))
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define __I     volatile const            /*!< defines 'read only' permissions      */
N#define __O     volatile                  /*!< defines 'write only' permissions     */
N#define __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N/* -------------------  Bit Definition ------------------ */
N#define BIT0		((uint32_t)0x0000000000000001) /** Bit 0 select mask */
N#define BIT1		((uint32_t)0x0000000000000002) /** Bit 1 select mask */
N#define BIT2		((uint32_t)0x0000000000000004) /** Bit 2 select mask */
N#define BIT3		((uint32_t)0x0000000000000008) /** Bit 3 select mask */
N#define BIT4		((uint32_t)0x0000000000000010) /** Bit 4 select mask */
N#define BIT5		((uint32_t)0x0000000000000020) /** Bit 5 select mask */
N#define BIT6		((uint32_t)0x0000000000000040) /** Bit 6 select mask */
N#define BIT7		((uint32_t)0x0000000000000080) /** Bit 7 select mask */
N#define BIT8		((uint32_t)0x0000000000000100) /** Bit 8 select mask */
N#define BIT9		((uint32_t)0x0000000000000200) /** Bit 9 select mask */
N#define BIT10		((uint32_t)0x0000000000000400) /** Bit 10 select mask */
N#define BIT11		((uint32_t)0x0000000000000800) /** Bit 11 select mask */
N#define BIT12		((uint32_t)0x0000000000001000) /** Bit 12 select mask */
N#define BIT13		((uint32_t)0x0000000000002000) /** Bit 13 select mask */
N#define BIT14		((uint32_t)0x0000000000004000) /** Bit 14 select mask */
N#define BIT15		((uint32_t)0x0000000000008000) /** Bit 15 select mask */
N#define BIT16		((uint32_t)0x0000000000010000) /** Bit 16 select mask */
N#define BIT17		((uint32_t)0x0000000000020000) /** Bit 17 select mask */
N#define BIT18		((uint32_t)0x0000000000040000) /** Bit 18 select mask */
N#define BIT19		((uint32_t)0x0000000000080000) /** Bit 19 select mask */
N#define BIT20		((uint32_t)0x0000000000100000) /** Bit 20 select mask */
N#define BIT21		((uint32_t)0x0000000000200000) /** Bit 21 select mask */
N#define BIT22		((uint32_t)0x0000000000400000) /** Bit 22 select mask */
N#define BIT23		((uint32_t)0x0000000000800000) /** Bit 23 select mask */
N#define BIT24		((uint32_t)0x0000000001000000) /** Bit 24 select mask */
N#define BIT25		((uint32_t)0x0000000002000000) /** Bit 25 select mask */
N#define BIT26		((uint32_t)0x0000000004000000) /** Bit 26 select mask */
N#define BIT27		((uint32_t)0x0000000008000000) /** Bit 27 select mask */
N#define BIT28		((uint32_t)0x0000000010000000) /** Bit 28 select mask */
N#define BIT29		((uint32_t)0x0000000020000000) /** Bit 29 select mask */
N#define BIT30		((uint32_t)0x0000000040000000) /** Bit 30 select mask */
N#define BIT31		((uint32_t)0x0000000080000000) /** Bit 31 select mask */
N#define BIT32		((uint64_t)0x0000000100000000) /** Bit 32 select mask */
N#define BIT33		((uint64_t)0x0000000200000000) /** Bit 33 select mask */
N#define BIT34		((uint64_t)0x0000000400000000) /** Bit 34 select mask */
N#define BIT35		((uint64_t)0x0000000800000000) /** Bit 35 select mask */
N#define BIT36		((uint64_t)0x0000001000000000) /** Bit 36 select mask */
N#define BIT37		((uint64_t)0x0000002000000000) /** Bit 37 select mask */
N#define BIT38		((uint64_t)0x0000004000000000) /** Bit 38 select mask */
N#define BIT39		((uint64_t)0x0000008000000000) /** Bit 39 select mask */
N#define BIT40		((uint64_t)0x0000010000000000) /** Bit 40 select mask */
N#define BIT41		((uint64_t)0x0000020000000000) /** Bit 41 select mask */
N#define BIT42		((uint64_t)0x0000040000000000) /** Bit 42 select mask */
N#define BIT43		((uint64_t)0x0000080000000000) /** Bit 43 select mask */
N#define BIT44		((uint64_t)0x0000100000000000) /** Bit 44 select mask */
N#define BIT45		((uint64_t)0x0000200000000000) /** Bit 45 select mask */
N#define BIT46		((uint64_t)0x0000400000000000) /** Bit 46 select mask */
N#define BIT(X)		(1<<(X)) /** Bit X select mask */
N#ifndef _BV
N#define _BV( x )            ( 1 << (x) )
N#endif
N#define x_BV( x )           0
N
N
N#define BYTE7(X)    ((X & 0xff00000000000000) >> 56)
N#define BYTE6(X)    ((X & 0x00ff000000000000) >> 48)
N#define BYTE5(X)    ((X & 0x0000ff0000000000) >> 40)
N#define BYTE4(X)    ((X & 0x000000ff00000000) >> 32)
N#define BYTE3(X)    ((X & 0x00000000ff000000) >> 24)
N#define BYTE2(X)    ((X & 0x0000000000ff0000) >> 16)
N#define BYTE1(X)    ((X & 0x000000000000ff00) >> 8)
N#define BYTE0(X)    ((X & 0x00000000000000ff) >> 0)
N
N#define SHORT0(X)   ((X & 0x000000000000FFFF) >>  0)
N#define SHORT1(X)   ((X & 0x00000000FFFF0000) >>  16)
N#define SHORT2(X)   ((X & 0x0000FFFF00000000) >>  32)
N#define SHORT3(X)   ((X & 0xFFFF000000000000) >>  48)
N
N#define WORD0(X)    ((X & 0x00000000FFFFFFFF) >>  0)
N#define WORD1(X)    ((X & 0xFFFFFFFF00000000) >> 32)
N
N#ifndef signof
N#define signof(expr)       ((typeof(expr)) -1 < ((typeof(expr)) 0))
N#endif /* signof */
N
N#define GET_ARRAY_(x)       (sizeof(x)/sizeof(*(x)))
N#define _countof(_Array)     sizeof(_Array) / sizeof(_Array[0])
N
N#define offsetof(st, m) ((size_t)&(((st *)0)->m))
N
N#define _PSTR(x)            #x
N#define PSTR(x)             _PSTR(x)
N
Ntypedef enum  {RESET = 0, SET = 1}         	FlagStatus, ITStatus;
Ntypedef enum  {DISABLE = 0, ENABLE = 1}  	FunctionalState;
Ntypedef enum  {ERROR = 0, SUCCESS = 1}     	ErrorStatus;
Ntypedef enum  {ODD = 0, EVEN = 1}           ParityNum;
N
N
Ntypedef unsigned char BOOLEAN;
Ntypedef unsigned char UINT8;		/* 1 byte */
Ntypedef unsigned short UINT16;		/* 2 bytes */
Ntypedef unsigned int UINT32;		/* 4 bytes */
Ntypedef signed char INT8S;			/* 1 byte */
Ntypedef signed short INT16S;		/* 2 bytes */
Ntypedef signed int INT32S;			/* 4 bytes */
Ntypedef uint8_t bool_t;
N
Ntypedef unsigned char bool_t;
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 418 "..\..\Hal\system\MFTP.h" 2
N#include <stdint.h>
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 420 "..\..\Hal\system\MFTP.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 421 "..\..\Hal\system\MFTP.h" 2
N
N
N#define YES						(0==0)
N#define NO						(1==0)
N
N#define TRUE					(0==0)
N#define FALSE					(1==0)
N
N#define IS_TRUE(X)				((X) != 0)
N#define IS_FALSE(X)				((X) == 0)
N
N#define MSB_2BYTE(x)			(((x)>>8)&0xFF)
N#define LSB_2BYTE(x)			((x)&0xFF)
N
N
N
N
N#define Infinite_loop()	while(TRUE){}
N
N/* -------------------  Other User Definition ------------------ */
N
N#ifndef NULL
S#define NULL                ((void *)0)
N#endif
N
N#define MSB(x)              (((x)>>8) & 0xFF)
N#define LSB(x)              ((x) & 0xFF)
N#define MSB1(x)       (((x)>>24)&0xFF)
N#define MSB2(x)       (((x)>>16)&0xFF)
N#define LSB1(x)       (((x)>>8)&0xFF)
N#define LSB2(x)       ((x)&0xFF)
N
N#ifndef MAX
N#define MAX( x, y )         ( ( ( x ) > ( y ) ) ? ( x ) : ( y ) )
N#endif
N
N#ifndef MIN
N#define MIN( x, y )         ( ( ( x ) < ( y ) ) ? ( x ) : ( y ) )
N#endif
N
N#ifndef QUOT
N#define QUOT( x, y )        ( ( ( x ) + ( y / 2 ) ) / ( y ) )
N#endif
N
N#ifndef MOD
N#define MOD( x, y )         ( ( ( x )+( y ) )%( y ) )
N#endif
N
N#ifndef ABS
N#define ABS( x )            (( ( x ) >= 0 )? (x) : -(x))
N#endif
N
N/** @} */ /* End of group Exported_macro */
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* _MFTP_H_ */
L 38 "..\..\Env\env_def.h" 2
N#include "env_defines.h"
L 1 "..\..\Env\env_defines.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_defines.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N#ifndef _ENV_DEFINES_H_
N#define _ENV_DEFINES_H_
N
N#include "boot_info.h"
L 1 "..\..\Boot\boot_info.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : boot_info.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _BOOT_INFO_H_
N#define _BOOT_INFO_H_
N
N// USB Model  BOOT VID, PID  .
N// I2C Model  BOOT VID, PID APP   
N#define BOOT_VID 				(0x29BD)
N#define BOOT_PID				(0x5357)
N#define BOOT_VER				(0x0303)
N
N
Ntypedef struct
N{
N	uint16_t usBootVer;
N	uint16_t usBootMemSize;
N	uint16_t usBootVID;
N	uint16_t usBootPID;
N
N} tBootGenInfo_t;
N
Ntypedef struct
N{
N	uint16_t usBootVer;
N	uint16_t usBootMemSize;
N	uint16_t usBootVID;
N	uint16_t usBootPID;
N	uint32_t usCRCValue;
N
N} tBootTailInfo_t;
N
N
N#endif /* _BOOT_INFO_H_ */
L 38 "..\..\Env\env_defines.h" 2
N
N//#define _USE_APP_LGD_LIB_
N
N#if defined(USE_BOOTLOADER_8KB)
X#if 0L
S	#define	VECTOR_BASE	0x00002000
N#elif defined(USE_BOOTLOADER_16KB)
X#elif 1L
N	#define	VECTOR_BASE	0x00004000
N#else
S	#define	VECTOR_BASE	0x00000000
N#endif
N
N
N#define MODULE_DEF_L						(1)
N#define MODULE_DEF_S_1						(2)
N#define MODULE_DEF_B_1						(3)
N#define USED_ONLY_KEIL_DEBUG				(YES)
N#define USED_MODULE_DEF						(MODULE_DEF_L)
N
N#define PWMDRV_FREQUENCY_50K				(1)
N#define PWMDRV_FREQUENCY_91K				(2)
N#define PWMDRV_FREQUENCY_133K				(3)
N#define PWMDRV_FREQUENCY_150K				(4)
N#define PWMDRV_FREQUENCY_200K				(5)
N
N#define PLL_OUT_CLOCK_96MHz					(1)
N#define PLL_OUT_CLOCK_90MHz					(2)
N#define PLL_OUT_CLOCK_45MHz					(3)
N#define PLL_OUT_CLOCK_37p5MHz				(4)
N#define PLL_OUT_CLOCK_31p5MHz				(5)
N
N#define MSPI_CLOCK_DIV_2					(1)
N#define MSPI_CLOCK_DIV_3					(2)
N
N#include "env_model_L/env_model.h"
L 1 "..\..\Env\env_model_L/env_model.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  env_model.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_MODEL_H_
N#define _ENV_MODEL_H_
N
N/*
N * Library Define
N */
N#define LGD_TEST_LIBRARY_VERSION			(0x0001)
N#define USED_PEN_MODE_OPERATION				(NO)
N#define USED_INIT_PEN_MODE					(NO && USED_PEN_MODE_OPERATION)
N#define USED_POOR_PANEL_COLLINE_DISABLE     (NO)
N#define USED_130K_MAINFREQ					(NO) // if define USED_130K_MAINFREQ, USED_IDLE_MODE_CONTROL off.
N#define USED_ONLY_IDLE_MODE					(NO)
N#define USED_SW92400_OLD_SRIC_PROTOCOL		(YES)
N
N
N#define USED_MNT_USB_CUSTOM_PROTOCOL		(NO)
N
N
N#if 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S
S
S
S
S
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S
S
S
S
S
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(1)
N#elif 1
N
N// LX98405 Settting --> Must!! - ECLK Driving Strength - 1
N#define MSPI_DRIVING_STRANGTH_CSN_0			(1)
N#define MSPI_DRIVING_STRANGTH_CSN_1			(1)
N#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
N#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)//0//1
N#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
N#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)//0//1
N
N#define ECLK_DRIVING_STRENGTH_0		(1)
N#define ECLK_DRIVING_STRENGTH_1		(1)
N#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S
S
S
S
S
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S
N#endif
N
N
N
N
N
N
N
N#define UNIQUE_VID 						(0x1FD2)
N
N#define USED_NEW_TCON_BOARD				(NO)
N#define USED_FINGER_ONLY				(YES)
N#define USED_SRIC_CHANNEL_PAD_OFF		(NO)
N#define USED_FORCE_S3_MODE_OPER			(NO)
N
N#if defined(USE_BOOTLOADER_CODE)
X#if 0L
S#define USED_GPIO_TEST_HANDSHAKE		(NO)
N#else /* USE_BOOTLOADER_CODE */
N#define USED_GPIO_TEST_HANDSHAKE		(NO)
N#endif /* USE_BOOTLOADER_CODE */
N
N#if defined(USE_BOOTLOADER_8KB)
X#if 0L
S	#define FW_SIZE			(120*1024)
N#elif defined(USE_BOOTLOADER_16KB)
X#elif 1L
N	#define FW_SIZE			(112*1024)
N	#define FW_CRC_SIZE		(108*1024)
N#else
S	#define FW_SIZE			(128*1024)
N#endif
N
N#define USED_IDLE_MODE_CONTROL						(NO)
N#define USED_IDLE_NI_SENSING_MUX_NUM				(1)
N#define USED_TSYNC2_INPUT_CONTROL					(YES)
N//#define USED_ECLK_SOURCE_TIMERCLK					(NO)
N#define USED_ECLK_ON_OFF_CONTROL					(YES)
N#define ECLK_ON_OFF_CONTROL_START_CNT_THD			(10)
N#define USED_ECLK_ON_OFF_CONTROL_DISABLE_DATAREAD	(YES & USED_ECLK_ON_OFF_CONTROL)
N#define USED_NORMAL_NI_SENSING						(NO)
N#define USED_AFE_BIAS_CURRENT_DOWN					(NO)
N#define USED_MCU_IDLE_LOW_PWR_CONTROL				(NO)
N#define USED_PLL_LOCKED_DEFENSE_CODE				(YES)
N#define USED_REFERENCE_INIT_IDLE_MODE_ENTER			(YES)
N#define USED_LAST_MUX_NODELAY						(NO)
N
N//#if (CUSTOMER == MODEL_LGD_SW97400B)
N#define INTERPOLATION_VER1_En								(NO)
N#define INTERPOLATION_VER2_En								(NO)
N#define INTERPOLATION_VER3_En								(NO)
N#define SKIP_FRAME_NUM_ON_IDLE_MODE							(1)
N#define USED_FRAME_SKIP_IDLE_MODE_CONTROL					(YES)
N#define USED_LPWG_MODE_CONTROL								(NO)//(YES)
N#define LGD_ERROR_FRAME_PROCESS_EN							(NO)
N#define USED_TPIC_MUXEN_ON_OFF_CONTROL						(YES)
N#define USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM					(YES & USED_TPIC_MUXEN_ON_OFF_CONTROL)
N#define TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD				(10)
N#define USED_TPIC_MUXEN_ON_OFF_CONTROL_DISABLE_DATAREAD		(YES & USED_TPIC_MUXEN_ON_OFF_CONTROL)
N
N#define MODE_SMT
N#define REPORT_INTERPOLATION
N
N#define PWMDRV_USED_FREQUENCY						(PWMDRV_FREQUENCY_91K)
N#define PLL_OUT_CLOCK_SPEED							(PLL_OUT_CLOCK_90MHz)
N#define BIAS_ON_OFF_CTRL_INIT_FRAME_NUM				(5)
N#define USED_DUMMY_PWM_DISABLE						(NO)
N#define USED_OPERATION_STAND_ALONE					(NO)
N#define USED_OPERATION_STAND_ALONE_DISPLAY_ON		(NO)
N#define USED_AFE_SRIC_SSU_CONTROL					(NO) // <<<<<
N#define PMIC_MUXEN_CONTROL_CASE_1					(1)
N#define PMIC_MUXEN_CONTROL_CASE_2					(2)
N#define PMIC_MUXEN_CONTROL_CASE						(PMIC_MUXEN_CONTROL_CASE_1)
N
N#define USED_SHARP_SPECIFIC_PROTOCOL				(NO)
N#define USED_MOBILE_I2C_PROTOCOL					(NO)
N
N#define USED_TEST_OPERATION_ENABLE					(NO)
N
N#define USED_S3_MODE_FUNCTION						(NO && (!USED_PEN_MODE_OPERATION))
N#define USED_LPWG_MCU_SLEEP							(NO && (!USED_PEN_MODE_OPERATION))
N#define USED_S3_ALL_MUX_SHORT						(NO)
N/*
N *  define
N */
N#define USED_ONLY_BOE_TEST_EQU						(NO)
N#define USED_WINDOW_10_QE_BOE						(NO)
N#define USED_SPEED_MESURE							(NO)
N#define USED_NEW_CONFIG_PARAMETER					(YES)
N#define USED_SRIC_RTC_VAL							(YES)  // RTC : Run Time Config
N
N#define SWIP_QUEUE_MODE 				(2)
N#define SWIP_QUEUE_SIZE 				(7)
N//#define SHORT_COMPENSATION 			(1)
N#define SHORT_NUM 						(10)
N
N
N/* Define for Model Customer Dependency */
N#define MODEL_LGD_SW92400				(1)
N#define MODEL_LGD_SW97400B				(2)
N#define MODEL_LGD_LX98405				(3)
N
N#define CUSTOMER   						(MODEL_LGD_LX98405)
N
N#include "../env_model_L/customer/DEFAULT/information.h"
L 1 "..\..\Env\env_model_L/../env_model_L/customer/DEFAULT/information.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  information.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _INFORMATION_H_
N#define _INFORMATION_H_
N
N
N/********************************************************************************
N *                              Customer : DEFAULT                              *
N ********************************************************************************/
N#define CORE_VERSION				(0x0009)
N#define APP_VERSION					(0x0009)
N#define PARA_VERSION				(0x0000)
N#define I2C_ADDRESS					(0x28)		// (LG : 0x34, Lenovo : 0x20)
N#define HID_DESCRIPTOR_ADDRESS		(0x0020)	// (LG  0x0000, Lenovo  0x0020)
N#define UNIQUE_APP_PID 				(0xD101)	// (LGD 27.0" MNT)
N
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S#define I2C_X_RESOLUTION			(1920)
S#define I2C_Y_RESOLUTION			(1080)
S
N#else /* USED_MOBILE_I2C_PROTOCOL */
N#define I2C_X_RESOLUTION			(32768)
N#define I2C_Y_RESOLUTION			(32768)
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#define MODE_WDT				// WDT Mode Apply
N
N#if !defined(USE_BOOTLOADER_CODE)
X#if !0L
N//#define DC_BASE
N#if USED_FINGER_ONLY
X#if ((0==0))
N#define FINGER_ONLY
N#endif /* USED_FINGER_ONLY */
N//#define MODE_I2C
N#define ADD_TOUCH
N//#define ADD_PEN
N#endif /* USE_BOOTLOADER_CODE */
N
N#define ADD_CUSTOM
N#define USB_SELECTIVE_SUSPEND
N//#define I2C_SELECTIVE_SUSPEND
N
N#define ABNORMAL_RAWDATA_CNT_THD					(10)
N#define ABNORMAL_RAWDATA_FRAME_THD					(5)
N#define USED_ESD_RECOVERY_CODE						(NO)
N
N#define DEBOUNCE_FRAME_NUM							(10)
N#define ABNORMAL_DELTA_PLUS_THD					    (300)
N#define ABNORMAL_DELTA_PLUS_CNT_THD					(3)
N#define ABNORMAL_DELTA_MINUS_THD				    (-30)
N#define ABNORMAL_DELTA_FRAME_THD       			    (100)
N#define ABNORMAL_DELTA_THD_FOR_RECAL				(20)
N#define ABNORMAL_DELTA_CHECK_FRAME_NUM				(2)
N#define USED_RF_NOISE_RECOVERY_CODE					(NO)
N
N#define ABNORMAL_TSYNC_FALLING_TIME_CHECK		(YES)
N
N#define USED_SPLIT_MERGE_RELIABILITY 				(NO)
N#define USED_DRUM_ALGO 								(NO)
N#define VECTOR_PREDICTION_EN						(NO)
N#define FAST_SPLIT									(NO)
N#define BIG_FINGER_EDGE_EXPAND_ALGO_EN				(NO)
N#define WinCertAssistance_En						(NO)
N#define ADAPTIVE_SEEDBASE							(NO)
N#define LABEL_FAST_EN								(NO)
N#define SMOOTH_PASTORG_INTER_EN						(NO)
N#define USED_ALGORITHM_FOR_MNT						(NO)
N#define MULTI_EDGE_COEF_EN							(NO)
N#define BIG_FINGER_EDGE_ACC_TEST_ALGO_EN 			(NO)
N#define USED_DO_NOT_FINGER_TOUCH_REPORT				(NO)
N#define PEN_FINGER_1TOUCH_REPORT					(NO)
N#define FINGER_LF_VER1_EN							(NO)
N#define FINGER_LF_VER2_EN							(NO)
N#define FINGER_LF_VER4_EN							(NO)
N#define PalmCandidateTouchCut_EN					(NO)
N#define PalmDrawingOn_En							(NO)
N#define USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE		(NO)
N#define FINGER_Latency_Test_ByFW					(NO)
N#define CPI_TEST_EN									(NO)
N#define PHONE_NOISE_CNT_MAX							(5)
N#define PHONE_NOISE_RESET_CNT_MAX					(300)
N#define NORMALIZE_DELTA_EN							(YES)
N#define ID_MAPPING_CHANGE							(NO)
N#define REMOVE_EDGE_EN								(NO)
N#define FAST_LF_EN									(NO)
N#define USED_NOISE_HOPPING_FREQ						(NO)
N#define PALM_VER1_EN								(NO)
N#define FingerGlobalCoordiY_2Region_Set				(NO)
N#endif /* _INFORMATION_H_ */
L 331 "..\..\Env\env_model_L/env_model.h" 2
N
N
N#define ACCESS_MATRIX(_p, _col_, _r, _c)    (*((_p)+(_col_)*(_r)+(_c)))
N#define POW(a)                              (a)
N#define SQRT(a)								algorithm_calc_sqrt(POW(a))
N
N#define SECTION_NAME_LEN_               	(8)
N#define CUSTOM_INFO_                    	(10)
N#define CUSTOM_PATH_NAME_LEN_           	(32)
N#define PUBLIC_PATH_NAME_LEN_           	(32)
N
N#define MAX_TOUCH_                      	(10)
N#define MAX_KEY_                        	(4)
N#define PAD_                            	(1)
N
N#define ROW_MAX								(48)
N#define COL_MAX								(96)
N//#define NI_FRAME_NUM						(2)
N#define NI_ROW_MAX							(USED_IDLE_NI_SENSING_MUX_NUM*4) // (12)
N
N#define PEN_COORD_ROW_MAX					(5)//(8)
N#define PEN_COORD_COL_MAX					(80)//(84)
N#define PEN_DATA_ROW_MAX					(PEN_COORD_ROW_MAX*4)
N
N#define MUX_RANGE_SIZE	    				(2)
N#define MAX_MUX_SIZE						(10)//(8)
N#define MAX_MUX_HALF						(MAX_MUX_SIZE>>1)
N#define MUX_MAX_ROW							(((ROW_MAX - MAX_MUX_SIZE + 1)>>1)<<1)
N
N
N/***************************************************************************************************************************************
N * platform_env.h
N ***************************************************************************************************************************************/
N#define _DV_SAMPLE_
N
N#define SPI_DMY_LEN     				(2)  // ADDR + CMD LX98405
N#define SRIC_PROTOCOL_RESET_COUNT   	(7)
N#define READ_ALIGNED_BUF    			(0x0800) // 0800
N
N#define R0_ALIGNED_COL_LEN  			(12)
N#define R0_ALIGNED_ROW_LEN  			(5)
N#define R0_COL_LEN          			(6)
N#define R1_COL_LEN          			(6)
N#define R0_ROW_LEN          			(5)
N#define R1_ROW_LEN          			(5)
N#define SM_COL_LEN          			(12)
N
N#define MSPI_NUM                		(4)
N#define SRIC_NUM                		(4)
N
N#define SM_NUM                  		(1)
N
N#define FINGER_MUX_NUM              	(10)
N#define FINGER_SENSING_MUX_NUM_1LHB		(9)
N#define FINGER_NI_MUX_NUM           	(3)
N#define FINGER_IDLE_NI_MUX_NUM          (USED_IDLE_NI_SENSING_MUX_NUM)
N#define FINGER_FULLFRAME_TSYNC_NUM		(FINGER_MUX_NUM / FINGER_MUX_NUM_1LHB)
N#if USED_NORMAL_NI_SENSING
X#if ((1==0))
S#define FINGER_FULL_FRAME_MUX_NUM		(FINGER_MUX_NUM + FINGER_NI_MUX_NUM)
N#else /* USED_NORMAL_NI_SENSING */
N#define FINGER_FULL_FRAME_MUX_NUM		(FINGER_MUX_NUM)
N#endif /* USED_NORMAL_NI_SENSING */
N#define MSPI_ROW_MAX_MUX				(10)//(16)
N
N#define FINGERPEN_MUX_NUM           	(4)
N
N// choigs
N#define SZ_MSPIBUF_REGISTER     			(SPI_DMY_LEN + 2)  // LX98405
N//#define SZ_MSPIBUF_MUXDATA      			(SPI_DMY_LEN + ((R0_ALIGNED_COL_LEN * R0_ROW_LEN)*2))
N#define SZ_MSPIBUF_MUXDATA      			(SPI_DMY_LEN + (R0_ALIGNED_COL_LEN * R0_ROW_LEN)*2)
N
N#define SZ_MSPIBUF_FINGER_FULL_FRAME    	(SZ_MSPIBUF_MUXDATA * FINGER_FULL_FRAME_MUX_NUM)
N#define SZ_MSPIBUF_FINGER_IDLE_FULL_FRAME   (SZ_MSPIBUF_MUXDATA * FINGER_IDLE_NI_MUX_NUM)
N#define SZ_MSPIBUF_FINGERPEN_FRAME      	(SZ_MSPIBUF_MUXDATA * FINGERPEN_MUX_NUM)
N
N#define PIN_MSPI_SSN_0					(PIN_GPA00)
N#define PIN_MSPI_SCLK_0					(PIN_GPA01)
N#define PIN_MSPI_MOSI_0					(PIN_GPA02)
N#define PIN_MSPI_MISO_0					(PIN_GPA03)
N#define PIN_MSPI_SSN_1					(PIN_GPA04)
N#define PIN_MSPI_SCLK_1					(PIN_GPA05)
N#define PIN_MSPI_MOSI_1					(PIN_GPA06)
N#define PIN_MSPI_MISO_1					(PIN_GPA07)
N#define PIN_MSPI_SSN_2					(PIN_GPA08)
N#define PIN_MSPI_SCLK_2					(PIN_GPA09)
N#define PIN_MSPI_MOSI_2					(PIN_GPA10)
N#define PIN_MSPI_MISO_2					(PIN_GPA11)
N#define PIN_MSPI_SSN_3					(PIN_GPA12)
N#define PIN_MSPI_SCLK_3					(PIN_GPA13)
N#define PIN_MSPI_MOSI_3					(PIN_GPA14)
N#define PIN_MSPI_MISO_3					(PIN_GPA15)
N#define PIN_MSPI_SSN_4					(PIN_GPA16)
N#define PIN_MSPI_SCLK_4					(PIN_GPA17)
N#define PIN_MSPI_MOSI_4					(PIN_GPA18)
N#define PIN_MSPI_MISO_4					(PIN_GPA19)
N#define PIN_MSPI_SSN_5					(PIN_GPA20)
N#define PIN_MSPI_SCLK_5					(PIN_GPA21)
N#define PIN_MSPI_MOSI_5					(PIN_GPA22)
N#define PIN_MSPI_MISO_5					(PIN_GPA23)
N
N
N#define VSYNC_HIGH             			(GPIO->tGPIO_DATA_0.tBit.GPA26)
N#define TSYNC_HIGH             			(GPIO->tGPIO_DATA_0.tBit.GPA27)
N
N
N#endif /* _ENV_MODEL_H_ */
L 72 "..\..\Env\env_defines.h" 2
N
N#define USED_MUX_SENSING_REVERSE		(NO)
N
N#if USED_SPEED_MESURE
X#if ((1==0))
S#define USED_SPEED_MESURE_TOUCHNUM			(10)
N#endif /* USED_SPEED_MESURE */
N
N
N#if (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz)
X#if (((2)) == (1))
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_3) // 16M
N#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_90MHz)
X#elif (((2)) == (2))
N#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_3) // 15M
N#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_45MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_2) // 11.3M
S#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_37p5MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_2) // 9.4M
S#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_31p5MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_2) // 7.9M
S#else /* (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz) */
S#define PLL_OUT_CLOCK_SPEED					(PLL_OUT_CLOCK_90MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_3) // 15M
N#endif /* (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz) */
N
N
N#if USED_OPERATION_STAND_ALONE
X#if ((1==0))
S#define USED_ONE_VSYNC_ONE_FRAME			(YES)
S
S#define USED_NOT_USE_ALL_AFE_OFF			(NO)
S#define USED_LPWG_CROSS_AFE_OFF				(NO)
S#define USED_LREDGE_AFE_OFF					(NO)
S#define USED_PLL_OUT_CLK_CONFIG				(YES)
S#define VSYNC_ONE_FRAME_RATE_HZ				(20)
S#define VSYNC_ONE_FRAME_TIME_usec			(1000000/VSYNC_ONE_FRAME_RATE_HZ)
S#define TSYNC_ONE_FRAME_RATE_HZ				(70)//(80)
S#define TSYNC_ONE_FRAME_TIME_usec			(1000000/TSYNC_ONE_FRAME_RATE_HZ)
S#define TSYNC_LHB_NUM						(16)
S#define TSYNC_PRIOD							(TSYNC_ONE_FRAME_TIME_usec/TSYNC_LHB_NUM)
N#else /* USED_OPERATION_STAND_ALONE */
N#define USED_ONE_VSYNC_ONE_FRAME			(NO)
N#define USED_NOT_USE_ALL_AFE_OFF			(NO)
N#define USED_LPWG_CROSS_AFE_OFF				(NO)
N#define USED_PLL_OUT_CLK_CONFIG				(NO)
N#endif /* USED_OPERATION_STAND_ALONE */
N
N#define USED_SRIC_REG_MSPI_CHECK			(NO)
N
N
N#define DEFAULT_X_RESOLUTION				(32768)
N#define DEFAULT_Y_RESOLUTION				(32768)
N
N/***************************************************************************************************************************************
N * typedef enum
N ***************************************************************************************************************************************/
Ntypedef enum
N{
N	PCS_NONE,
N    PCS_ACTIVE,
N    PCS_IDLE,
N    PCS_LIMIT,
N} __PACKED ePowerConsumptionState_t;
X} __attribute__ ((packed)) ePowerConsumptionState_t;
N
Ntypedef enum
N{
N    OM_NORMAL,
N    OM_NOISE,
N    OM_DIAG,
N    OM_LIMIT
N} __PACKED eOperMode_t; //TODO:  !
X} __attribute__ ((packed)) eOperMode_t; 
N
Ntypedef enum
N{
N	FULL_MODE = 0,
N	LOCAL_MODE,					// 1
N	LOCAL_FINGER_MODE,			// 2
N	LOCAL_HOVER_MODE,			// 3
N	LOCAL_SEARCH_MODE,			// 4
N} __PACKED eSensingMode_t;
X} __attribute__ ((packed)) eSensingMode_t;
N
Ntypedef enum
N{
N	PEN_COORD_INIT = 1,			// 1
N	PEN_LINE_FILTER,			// 2
N	PEN_LABELING,				// 3
N	DSP_MARKBOUNDARY1,			// 4
N	DSP_MARKBOUNDARY2,			// 5
N	PEN_LABEL_EDGE_EXPAND,		// 6
N	PEN_COORDINATE,				// 7
N	PEN_SMOOTHING,				// 8
N	PEN_POST_PROCESS,			// 9
N	PEN_UPDATE_POST_INFO,		// 10
N} __PACKED eDSPBMode_t;
X} __attribute__ ((packed)) eDSPBMode_t;
N
N/***************************************************************************************************************************************
N * typedef structure
N ***************************************************************************************************************************************/
N//typedef struct
N//{
N//    int iRow_;
N//    int iCol_;
N//    int iRamCol_;
N//    int iScreenNode_;
N//    int iKey_;
N//    int iMaxTouch_;
N//    bool_t bSwapXY;
N//    bool_t bFlipX;
N//
N//} tMemConf_t;
N
N/***************************************************************************************************************************************
N * Variables
N ***************************************************************************************************************************************/
N//extern tMemConf_t *ptMemConf;
N//extern tMemConf_t* ptMemLocalConf;
Nextern volatile uint8_t* pucBuf;
N
N
N
N#define waitTsyncHigh()							while(TSYNC_HIGH == 0)
N#define waitTsyncLow()							while(TSYNC_HIGH != 0)
N#define waitTsyncRising() \
N	do{ \
N		waitTsyncLow(); \
N		waitTsyncHigh(); \
N	}while(0)
X#define waitTsyncRising() 	do{ 		waitTsyncLow(); 		waitTsyncHigh(); 	}while(0)
N
N#define waitTsyncFalling() \
N	do{ \
N		waitTsyncHigh(); \
N		waitTsyncLow(); \
N	}while(0)
X#define waitTsyncFalling() 	do{ 		waitTsyncHigh(); 		waitTsyncLow(); 	}while(0)
N
N#define waitVsyncHigh()							while(VSYNC_HIGH == 0)
N#define waitVsyncLow()							while(VSYNC_HIGH != 0)
N#define waitVsyncRising() \
N	do{ \
N		waitVsyncLow(); \
N		waitVsyncHigh(); \
N	}while(0)
X#define waitVsyncRising() 	do{ 		waitVsyncLow(); 		waitVsyncHigh(); 	}while(0)
N
N#define waitVsyncFalling() \
N	do { \
N		waitVsyncHigh(); \
N		waitVsyncLow(); \
N	}while(0)
X#define waitVsyncFalling() 	do { 		waitVsyncHigh(); 		waitVsyncLow(); 	}while(0)
N
N#if USED_SW92400_OLD_SRIC_PROTOCOL
X#if ((0==0))
N//typedef struct
N//{
N//    uint16_t Addr       ;
N//    uint16_t reserved0  ;
N//
N//    union
N//    {
N//        struct
N//        {
N//            uint16_t reserved1  : 14;
N//            uint16_t nBulk      : 1;
N//            uint16_t nWrite     : 1;
N//        } tBit;
N//        uint16_t Command;
N//    };
N//    uint16_t reserved2 ;
N//
N//    uint16_t Data;
N//    uint16_t reserved3;
N//} MSPI_RegWriteBuf_TypeDef;
N
N// // LX98405 New - Choigs
Ntypedef struct
N{
N    uint16_t Addr       ;
N    uint16_t reserved0  ;
N
N    union
N    {
N        struct
N        {
N            uint16_t Dummy : 3;
N            uint16_t Burst_Len : 7;
N            uint16_t ReadFormat : 2;
N            uint16_t reserved1 : 1;
N            uint16_t DualRxEn : 1;
N            uint16_t ChkSum : 1;
N            uint16_t RW : 1;
N        } tBit;
N        uint16_t Command;
N    };
N    uint16_t reserved2 ;
N
N    uint16_t Data_M;
N    uint16_t reserved3 ;
N		
N    uint16_t Data_L;
N    uint16_t reserved4 ;
N		
N} MSPI_RegWriteBuf_TypeDef;
N
N// // LX98405 New - Choigs
Ntypedef struct
N{
N	uint16_t Data1;
N	uint16_t reserved0  ;
N	uint16_t Data2;
N	uint16_t reserved1  ;
N} MSPI_RegReadBuf_TypeDef;
N
N
N
N//typedef struct
N//{
N//    union
N//    {
N//        uint16_t Addr       ;
N//        uint16_t Readback   ;
N//    };
N//    uint16_t reserved0  ;
N//
N//    uint16_t reserved1  : 14;
N//    uint16_t nBulk      : 1;
N//    uint16_t nWrite     : 1;
N//    uint16_t reserved2 ;
N//
N//    uint32_t Data[32];
N//}MSPI_SensingBuf_TypeDef;
N
N//typedef struct
N//{
N//    uint16_t Addr       ;
N//    uint16_t reserved0  ;
N//
N//    union{
N//        struct
N//        {
N//            uint16_t reserved1  : 14;
N//            uint16_t nBulk      : 1;
N//            uint16_t nWrite     : 1;
N//        } tBit;
N//        uint16_t Command;
N//    };
N//    uint16_t reserved2 ;
N//
N//    uint16_t Data[SZ_MSPIBUF_MUXDATA*2];
N//}MSPI_ReadCommand_TypeDef;
N
N// // LX98405 New - Choigs
Ntypedef struct
N{
N    uint16_t Addr       ;
N    uint16_t reserved0  ;
N
N    union{
N        struct
N        {
N				
N            uint16_t Dummy : 3;
N            uint16_t Burst_Len : 7;
N            uint16_t ReadFormat : 2;
N            uint16_t Reserve : 1;
N            uint16_t DualRxEn : 1;
N            uint16_t ChkSum : 1;
N            uint16_t RW : 1;
N
N        } tBit;
N        uint16_t Command;
N    };
N    uint16_t reserved2 ;
N
N    uint16_t Data[SZ_MSPIBUF_MUXDATA*2];
X    uint16_t Data[((2) + ((12) * (5))*2)*2];
N}MSPI_ReadCommand_TypeDef;
N
N
Ntypedef struct _MSPI_RAWDATA_
N{
N    uint16_t Dummy[2];
N    uint16_t Data[SM_NUM][R0_ALIGNED_ROW_LEN][SM_COL_LEN*2];
X    uint16_t Data[(1)][(5)][(12)*2];
N}MSPI_Rawdata_Typedef;
N
Ntypedef struct MSPI_Buffer
N{
N	MSPI_RegWriteBuf_TypeDef SricRegWriteBuffer[MSPI_NUM];
X	MSPI_RegWriteBuf_TypeDef SricRegWriteBuffer[(4)];
N	MSPI_RegReadBuf_TypeDef SricRegReadBuffer[MSPI_NUM];
X	MSPI_RegReadBuf_TypeDef SricRegReadBuffer[(4)];
N    uint32_t ulDummy[512];
N    MSPI_ReadCommand_TypeDef ReadCommand[MSPI_NUM];
X    MSPI_ReadCommand_TypeDef ReadCommand[(4)];
N    MSPI_Rawdata_Typedef Rawdata[MSPI_NUM][MSPI_ROW_MAX_MUX];
X    MSPI_Rawdata_Typedef Rawdata[(4)][(10)];
N    MSPI_Rawdata_Typedef PenRawdata[MSPI_NUM][FINGERPEN_MUX_NUM];
X    MSPI_Rawdata_Typedef PenRawdata[(4)][(4)];
N}MSPI_Buffer_TypeDef;
N
N
N
N#else /* USED_SW92400_OLD_SRIC_PROTOCOL */
Stypedef struct _MSPI_RegisterBuf
S{
S    uint16_t Addr       ;
S    uint16_t reserved0  ;
S
S    union
S    {
S        struct
S        {
S            uint16_t reserved1  : 14;
S            uint16_t nBulk      : 1;
S            uint16_t nWrite     : 1;
S        } bulkwrite_b;
S        uint16_t Command;
S    };
S    uint16_t reserved2 ;
S
S    uint16_t Data;
S    uint16_t reserved3;
S} MSPI_RegisterBuf_TypeDef;
S
S
Stypedef struct _MSPI_SensingBuf
S{
S    union
S    {
S        uint16_t Addr       ;
S        uint16_t Readback   ;
S    };
S    uint16_t reserved0  ;
S
S    uint16_t reserved1  : 14;
S    uint16_t nBulk      : 1;
S    uint16_t nWrite     : 1;
S    uint16_t reserved2 ;
S
S    uint32_t Data[32];
S}MSPI_SensingBuf_TypeDef;
S
Stypedef struct _ReadCommand_Buf_
S{
S    uint16_t Addr       ;
S    uint16_t reserved0  ;
S
S    union{
S        struct
S        {
S            uint16_t reserved1  : 14;
S            uint16_t nBulk      : 1;
S            uint16_t nWrite     : 1;
S        } bulkwrite_b;
S        uint16_t Command;
S    };
S    uint16_t reserved2 ;
S
S    uint16_t Data[SZ_MSPIBUF_MUXDATA*2];
S}MSPI_ReadCommand_TypeDef;
S
Stypedef struct _MSPI_RAWDATA_
S{
S    uint32_t Dummy;
S    uint16_t Data[SM_NUM][R0_ALIGNED_ROW_LEN][SM_COL_LEN*2];
S}MSPI_Rawdata_Typedef;
S
Stypedef struct MSPI_Buffer
S{
S    MSPI_RegisterBuf_TypeDef SricBuffer[2][MSPI_NUM];
S    MSPI_SensingBuf_TypeDef DataBuffer[2][MSPI_NUM];
S    MSPI_ReadCommand_TypeDef ReadCommand[MSPI_NUM];
S    MSPI_Rawdata_Typedef Rawdata[MSPI_NUM][MSPI_ROW_MAX_MUX];
S    MSPI_Rawdata_Typedef PenRawdata[MSPI_NUM][FINGERPEN_MUX_NUM];
S}MSPI_Buffer_TypeDef;
N#endif /* USED_SW92400_OLD_SRIC_PROTOCOL */
N
N
Ntypedef enum {
N	_FREQ_UNKNOWN_ = 0,
N	_FREQ_91k_ = 1,
N	_FREQ_110k_ = 2,
N	_FREQ_130k_ = 3,
N	_FREQ_133k_ = 4,
N	_FREQ_174k_ = 5,
N	_FREQ_182k_ = 6,
N	_FREQ_190k_ = 7,
N	_FREQ_200k_ = 8
N} eSENSING_FREQ_t;
N
Nextern volatile MSPI_Buffer_TypeDef*  SBuf;
N#define FRAME_MEMORY		((volatile void								*)BASE_MSPI_SRAM    )
N#define MSPI_BUF			((volatile MSPI_Buffer_TypeDef              *)BASE_MSPI_SRAM    )
N
N#define __inline__
N
N#endif /* _ENV_DEFINES_H_ */
L 39 "..\..\Env\env_def.h" 2
N#include "env_types.h"
L 1 "..\..\Env\env_types.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_types.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N#ifndef _ENV_TYPES_H_
N#define _ENV_TYPES_H_
N
Ntypedef union
N{
N    uint8_t STRING[8];
N    uint16_t HALFWORD[4];
N    uint32_t WORD[2];
N    uint64_t LONG;
N} u8byteString_t;
N
Ntypedef union
N{
N    uint32_t WORD;
N    uint16_t HALFWORD[2];
N    uint8_t BYTE[4];
N} uTypes32_t;
N
Ntypedef union
N{
N    uint64_t LONG;
N    uint32_t WORD[2];
N    uint16_t HALFWORD[4];
N    uint8_t BYTE[8];
N} uTypes64_t;
N
Ntypedef struct
N{
N    int8_t rs;
N    int8_t re;
N    int8_t cs;
N    int8_t ce;
N} __PACKED tRect_t;
X} __attribute__ ((packed)) tRect_t;
N
Ntypedef struct
N{
N    int8_t c;
N    int8_t r;
N} __PACKED tCell_t;
X} __attribute__ ((packed)) tCell_t;
N
Ntypedef struct
N{
N    uint8_t b7Size      : 7;
N    uint8_t b1Sign      : 1;
N} __PACKED tSignedByteDataType_t;
X} __attribute__ ((packed)) tSignedByteDataType_t;
N
N#define datatypeof(expr)    \
N        { .b7Size = sizeof(expr), .b1Sign = 1 }
X#define datatypeof(expr)            { .b7Size = sizeof(expr), .b1Sign = 1 }
N
N
N#endif /* _ENV_TYPES_H_ */
L 40 "..\..\Env\env_def.h" 2
N#include "env_section_defines.h"
L 1 "..\..\Env\env_section_defines.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_section_defines.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_SECTION_DEFINES_H_
N#define _ENV_SECTION_DEFINES_H_
N
N
N/*******************************************************************************
N * Allocate Functions and Variables in specific Section
N *******************************************************************************/
N/*-----------------------------------------------------------------------------*
N *                            Bootloader Used                                  *
N ------------------------------------------------------------------------------*/
N#define __BOOT						__attribute__((section("BOOT")))
N
N///*
N// * Application   Function  Address      .
N// */
N//#define APP_Fncp_APP_APP_RESET		((void *)0x00003079)
N//#define APP_Fncp_APP_APP_PENDSV_IRQ ((void *)0x000030b9)
N//#define APP_Fncp_APP_SYSTICK_IRQ	((void *)0x000030c9)
N//#define APP_Fncp_APP_I2C_IRQ		((void *)0x000030d9)
N//#define APP_Fncp_APP_WDT_IRQ		((void *)0x000030e9)
N//#define APP_Fncp_APP_EXTI0_IRQ		((void *)0x000030f9)
N//#define APP_Fncp_APP_EXIT1_IRQ		((void *)0x00003109)
N//#define APP_Fncp_APP_TIMER_IRQ		((void *)0x00003119)
N//#define APP_Fncp_APP_TSPI_IRQ		((void *)0x00003129)
N//#define APP_Fncp_APP_USB_IRQ		((void *)0x00003139)
N//#define APP_Fncp_APP_PWMDRV_IRQ		((void *)0x00003149)
N//#define APP_Fncp_APP_MSPI_IRQ		((void *)0x00003159)
N//#define APP_Fncp_APP_GPDMA_IRQ		((void *)0x00003169)
N//#define APP_Fncp_APP_DSP_A_IRQ		((void *)0x00003179)
N//#define APP_Fncp_APP_DSP_B_IRQ		((void *)0x00003189)
N//#define APP_Fncp_APP_PLL_IRQ		((void *)0x00003199)
N//#define APP_Fncp_APP_FLITF_IRQ		((void *)0x000031a9)
N
N/*-----------------------------------------------------------------------------*
N *                            Application Used                                 *
N ------------------------------------------------------------------------------*/
N#define __APP						__attribute__((section("APP")))
N
N
N/*-----------------------------------------------------------------------------*
N *                            Common Used                                      *
N ------------------------------------------------------------------------------*/
N#define __DATA_HEAD					__attribute__((section(".data_head")))
N
N
N#endif /* _ENV_SECTION_DEFINES_H_ */
L 41 "..\..\Env\env_def.h" 2
N
N
N#endif /* _ENV_DEF_H_ */
L 38 "..\..\Protocol\protocol_def.h" 2
N
N#include "protocol.h"
L 1 "..\..\Protocol\protocol.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : protocol.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _PROTOCOL_H_
N#define _PROTOCOL_H_
N
N
N//#include <stdint.h>
N//#include "env_model.h"
N
N
Ntypedef enum
N{
N    RS_READY    = 0xA0,
N    RS_NONE     = 0x05,
N    RS_LOG      = 0x77,
N    RS_IMAGE	= 0xAA
N} __PACKED eProtocolReadyStatus_t;
X} __attribute__ ((packed)) eProtocolReadyStatus_t;
N
Ntypedef enum
N{
N    ETT_NONE,
N    ETT_INTERRUPT,
N    ETT_REGISTER
N} eProtocolEventTriggerType_t;
N
N/*
N * Control Registers
N */
N
Ntypedef struct
N{
N    volatile eProtocolReadyStatus_t eReadyStatus;
N    __IO bool_t bEventReady;
X    volatile bool_t bEventReady;
N} __PACKED tProtocolGetter_t;
X} __attribute__ ((packed)) tProtocolGetter_t;
N
N#if USED_MNT_USB_CUSTOM_PROTOCOL
X#if ((1==0))
Stypedef enum
S{
S    M_TOUCH_NORMAL,
S	//M_TOUCH_DIAG,
S    M_TOUCH_DFUP,	//
S    M_TOUCH_DIAG,	//
S    M_PARAMETER,
S    M_TOUCH_LPWG,
S    M_CHECK_DNR,
S    M_CHECK_DRTIME,
S    M_CHECK_IRES,
S    M_CHECK_CM,
S    M_CHECK_STACK,
S    M_CHECK_HOPPING_VALIDITY,
S    M_CHECK_NOISE_SPECTRUM,
S    M_CHECK_RAWDATA_ON_DELAY,
S    M_GET_MAX_INTENSITY_ON_EACH_NODE,
S    M_GET_OVERSAMPLE_BUFFER,
S    M_GET_UNSORTED_OVERSAMPLE_BUFFER,
S    M_WAIT,
S    M_WATCH_DOG_RESET,
S    M_LIMIT
S} __PACKED eProtocolMode_t;
N#else
Ntypedef enum
N{
N    M_TOUCH_NORMAL,
N    M_TOUCH_DIAG,
N    M_TOUCH_DFUP,
N    M_PARAMETER,
N    M_TOUCH_LPWG,
N    M_CHECK_DNR,
N    M_CHECK_DRTIME,
N    M_CHECK_IRES,
N    M_CHECK_CM,
N    M_CHECK_STACK,
N    M_CHECK_HOPPING_VALIDITY,
N    M_CHECK_NOISE_SPECTRUM,
N    M_CHECK_RAWDATA_ON_DELAY,
N    M_GET_MAX_INTENSITY_ON_EACH_NODE,
N    M_GET_OVERSAMPLE_BUFFER,
N    M_GET_UNSORTED_OVERSAMPLE_BUFFER,
N    M_WAIT,
N    M_WATCH_DOG_RESET,
N    M_LIMIT
N} __PACKED eProtocolMode_t;
X} __attribute__ ((packed)) eProtocolMode_t;
N
N#endif
N
N
Ntypedef struct
N{
N    volatile eProtocolMode_t eMode;
N    volatile eProtocolEventTriggerType_t eEventTriggerType;
N    volatile bool_t bRecalibrate;
N    volatile ePowerConsumptionState_t ePowerConsumptionState;
N    volatile uint32_t ulGestureType;
N    volatile bool_t bDisableESDAlert;
N    volatile bool_t bChargerAttached;
N    volatile bool_t bGloveSensingEnable;
N    volatile bool_t bSensingOnWindowEnable;
N    volatile bool_t bPalmRejectionEnable;
N    volatile bool_t bDisableEdgeExpand;		
N    volatile bool_t bEnableHandShake;
N    volatile bool_t bApplyCoordinate;
N} __PACKED tProtocolSetter_t;
X} __attribute__ ((packed)) tProtocolSetter_t;
N
Ntypedef struct
N{
N    const void* pGeneralBuffer;
N    void* pParameterBuffer;
N} __PACKED tProtocolBufferPointers_t;
X} __attribute__ ((packed)) tProtocolBufferPointers_t;
N
Ntypedef struct
N{
N    tProtocolGetter_t* getter;
N    tProtocolSetter_t* setter;
N} __PACKED tProtocolCtrl_t;
X} __attribute__ ((packed)) tProtocolCtrl_t;
N
Nextern tProtocolBufferPointers_t vtProtocolBufferPointers;
Nextern tProtocolCtrl_t tProtocolCtrl;
N
Nextern uint8_t * (*protocol_GetMappedPointer)(uint16_t _addr);
Nextern void (*protocol_ClearInterrupt)(uint16_t _addr);
N
Nextern void protocol_init(void);
N
N
N#endif /* _PROTOCOL_H_ */
L 40 "..\..\Protocol\protocol_def.h" 2
N#if defined(USE_BOOTLOADER_CODE)
X#if 0L
S#include "protocol_swip.h"
S#include "protocol_dfup.h"
N#else /* USE_BOOTLOADER_CODE */
N#include "protocol_swip.h"
L 1 "..\..\Protocol\protocol_swip.h" 1
N/*
N * protocol_swip.h
N *
N *  Created on: 2015. 3. 12.
N *      Author: parkyj2
N */
N
N#ifndef __PROTOCOL_SWIP_H__
N#define __PROTOCOL_SWIP_H__
N
N
N#include "protocol_swip_regmap.h"
L 1 "..\..\Protocol\protocol_swip_regmap.h" 1
N/*
N * mip4d0.h
N *
N *  Created on: 2015. 3. 16.
N *      Author: parkyj2
N */
N
N#ifndef __SWIP_REGMAP_H__
N#define __SWIP_REGMAP_H__
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
S#define SWIP_REG_ADDR_ANDR_BASE_INFO             0x0000
S#define SWIP_REG_ADDR_SPR_CHIP_ID                0x0000
S#define SWIP_REG_ADDR_TC_VERSION                 0x0001
S#define SWIP_REG_ADDR_CHIP_VERSION               0x0002
S#define SWIP_REG_ADDR_TC_PRODUCT_ID              0x0003
N#endif
N
N#define SWIP_REG_ADDR_INFO                       0x0100
N#define SWIP_REG_ADDR_INFO_PANEL                 0x0100
N#define SWIP_REG_ADDR_INFO_SECTION_VERSION       0x0120
N#define SWIP_REG_ADDR_INFO_SECTION_ADDR          0x0130
N#define SWIP_REG_ADDR_INFO_INTEGRITY             0x0140//0x0148//0x0148
N#define SWIP_REG_ADDR_INFO_INTERFACE             0x0150
N#define SWIP_REG_ADDR_INFO_EXTRA                 0x0170
N#define SWIP_REG_ADDR_INFO_TRIMCODE_1            0x01A0
N#define SWIP_REG_ADDR_INFO_TRIMCODE_2            0x01C0
N
N#define SWIP_REG_ADDR_EVENT                      0x0200
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S//#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0200
S//#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
S#define SWIP_REG_ADDR_EVENT_PACKET_FORMAT	     0x0200
S#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0208
S#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x020C
N#else /* USED_MOBILE_I2C_PROTOCOL */
N#define SWIP_REG_ADDR_EVENT_FORMAT               0x0200
N#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0210
N#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
S#define SWIP_REG_ADDR_ANDROID_EVENT              0x0300
S#define SWIP_REG_ADDR_ANDROID_IC_STATUS          0x0300
S#define SWIP_REG_ADDR_ANDROID_TC_STATUS          0x0301
S#define SWIP_REG_ADDR_ANDROID_TOUCH_INFO         0x0302
S#define SWIP_REG_ADDR_ANDROID_PACKET_DATA        0x0303
S
S#define SWIP_REG_ADDR_SPR_CHIP_INFO              0x0400
S#define SWIP_REG_ADDR_SPR_CHIP_TEST              0x0400
S#define SWIP_REG_ADDR_SPR_BOOT_STS               0x0401
S#define SWIP_REG_ADDR_TC_DEVICE_CTL              0x0402
S#define SWIP_REG_ADDR_TC_INTERRUPT_CTL           0x0403
S#define SWIP_REG_ADDR_IME_STATE                  0x0404
S#define SWIP_REG_ADDR_TCI_ENABLE_W               0x0405
S#define SWIP_REG_ADDR_SWIPE_ENABLE_W             0x0406
S#define SWIP_REG_ADDR_SPR_SUBDISP_STS            0x0407
S#define SWIP_REG_ADDR_TC_DRIVE_CTL               0x0408
N#endif
N
N#define SWIP_REG_ADDR_CTRL                       0x0600
N#define SWIP_REG_ADDR_CTRL_GETTER                0x0600
N#define SWIP_REG_ADDR_CTRL_SETTER                0x0610
N
N#define SWIP_REG_ADDR_PARAMETER                  0x0800
N#define SWIP_REG_ADDR_PARAMETER_INFO             0x0800
N//#define SWIP_REG_ADDR_PARAMETER_CONTROL          0x0810
N
N#define SWIP_REG_ADDR_TEST                       0x0A00
N#define SWIP_REG_ADDR_TEST_CM_INFO               0x0A00
N#define SWIP_REG_ADDR_TEST_CM_CONTROL            0x0A10
N#define SWIP_REG_ADDR_TEST_CM_DATA_FORMAT        0x0A20
N
N#define SWIP_REG_ADDR_IMAGE                      0x0C00
N#define SWIP_REG_ADDR_IMAGE_INFO                 0x0C00
N#define SWIP_REG_ADDR_IMAGE_CONTROL              0x0C10
N#define SWIP_REG_ADDR_IMAGE_DATA_FORMAT          0x0C20
N#define SWIP_REG_ADDR_IMAGE_FINGER_NUM           0x0C30
N#define SWIP_REG_ADDR_IMAGE_FINGER_AREA          0x0C31
N
N#define SWIP_REG_ADDR_LOG                        0x1000
N#define SWIP_REG_ADDR_LOG_INFO                   0x1000
N#define SWIP_REG_ADDR_LOG_CONTROL                0x1010
N#define SWIP_REG_ADDR_LOG_DATA_FORMAT            0x1020
N
N#define SWIP_REG_ADDR_SPECIAL_ACTION             0x1200
N#define SWIP_REG_ADDR_CONTROL_FOR_TUNING         0x1200
N#define SWIP_REG_ADDR_PWMDRV_FOR_TUNING          0x1210
N#define SWIP_REG_ADDR_DRIVER_FOR_TUNING          0x1230
N
N#define SWIP_REG_ADDR_FLASH_IAP_CTRL			 0x1400
N#define SWIP_REG_ADDR_FLASH_IAP_CTRL_CMD		 0x1400
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_STATUS	 	 0x1401
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_SIZE		 0x1402
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_ADDR		 0x1404
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_BUFFER		 0x1408
N
N#define SWIP_REG_ADDR_GENERAL_BUFFER             0x2000
N#define SWIP_REG_ADDR_PARAMETER_BUFFER           0x6000
N#define SWIP_REG_ADDR_RESERVED                   0xF000
N
N#endif /* __SWIP_REGMAP_H__ */
L 13 "..\..\Protocol\protocol_swip.h" 2
N#include "protocol_log.h"
L 1 "..\..\Protocol\protocol_log.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  protocol_log.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _PROTOCOL_LOG_H_
N#define _PROTOCOL_LOG_H_
N
N
N/*
N * Log Registers
N */
N#define SWIP_LOG_PROTOCOL_ID                     0x0001
N
Ntypedef enum
N{
N    LT_DIAGNOSIS,
N    LT_PRE_RAWDATA,
N    LT_RAWDATA_TXLESS,
N    LT_RAWDATA,
N    LT_INTENSITY,
N    LT_OVERSAMPLE_BUFFER,
N    LT_REFERENCE,
N    LT_FILTERED_INTENSITY,
N    LT_GROUP,
N    LT_FILTERED_GROUP,
N    LT_DELAY,
N    LT_RECAL_INFO,
N    LT_HOVER_INFO,
N    LT_SPLIT_INFO,
N    LT_MERGE_INFO,
N    LT_COORD_INFO,
N    LT_NOISE_INFO,
N    LT_SCREEN_BENDING_INFO,
N    LT_PALM_INFO,
N    LT_GNDNOISE_INFO,
N    LT_STYLUS_INFO,
N    LT_STYLUS_PALM_REJECT_INFO,
N    LT_CONTACT_THRESHOLD_TUNING,
N    LT_DEBUG,
N    LT_DEBUG2,
N    LT_PENPOS_RAWDATA = 25,
N    LT_PENDATA_RAWDATA = 26,
N    LT_PENPOS_INTENSITY = 27,
N    LT_PENDATA_INTENSITY = 28,
N	LT_NI_RAW			 = 29,
N	LT_NI_INT			 = 30,
N    LT_LIMIT
N} eLogType_t;
N
Ntypedef enum
N{
N    LTR_NONE,
N    LTR_TRIG,
N    LTR_WAIT = 255
N} eLogTriggerType_t; // NOTE : warning
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tLogInfo_t;
X} __attribute__ ((packed)) tLogInfo_t;
N
Ntypedef struct
N{
N    uint32_t ulLogMask;
N//    volatile enum
N//    {
N//        LTR_NONE,
N//        LTR_TRIG,
N//        LTR_WAIT = 255
N//    } __PACKED eTrigger; // NOTE : warning
N     __PACKED volatile eLogTriggerType_t eTrigger;
X     __attribute__ ((packed)) volatile eLogTriggerType_t eTrigger;
N} __PACKED tLogControl_t;
X} __attribute__ ((packed)) tLogControl_t;
N
Ntypedef struct
N{
N    uint8_t ucRow_;
N    uint8_t ucCol_;
N    uint8_t ucBufferCol_;
N    tSignedByteDataType_t tDataType;
N    uint8_t ucLogIndex_;
N    struct
N    {
N        uint8_t b6Rightshift_   :6;
N        uint8_t bBitfieldData   :1;
N        uint8_t bIsRotated      :1;
N    } __PACKED tOptions;
X    } __attribute__ ((packed)) tOptions;
N} __PACKED tLogDataFormat_t;
X} __attribute__ ((packed)) tLogDataFormat_t;
N
Ntypedef struct
N{
N    tLogInfo_t* ptInfo;
N    tLogControl_t* ptControl;
N    const tLogDataFormat_t* ptDataFormat;
N} __PACKED tProtocolLog_t;
X} __attribute__ ((packed)) tProtocolLog_t;
N
N/*
N * Image Registers
N */
N#define LOG_IMAGE_PROTOCOL_ID                   0x0001
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tImageInfo_t;
X} __attribute__ ((packed)) tImageInfo_t;
N
Ntypedef enum
N{
N    IT_NONE = 0,
N    IT_RAW_IMAGE,
N    IT_BASELINE_IMAGE,
N    IT_DELTA_IMAGE,
N    IT_LABEL_IMAGE,
N    IT_FILTERED_DELTA_IMAGE,
N    IT_WAIT = 0xFF
N} __PACKED eImageType_t;
X} __attribute__ ((packed)) eImageType_t;
N
Ntypedef struct
N{
N    volatile eImageType_t eImageType;
N} __PACKED tImageControl_t;
X} __attribute__ ((packed)) tImageControl_t;
N
Ntypedef struct
N{
N    uint8_t ucRow_;
N    uint8_t ucCol_;
N    uint8_t ucBufferCol_;
N    bool_t bIsRotated;
N    uint8_t ucKey_;
N    tSignedByteDataType_t tDataType;
N} __PACKED tImageDataFmt_t;
X} __attribute__ ((packed)) tImageDataFmt_t;
N
Ntypedef struct
N{
N    tImageInfo_t* ptInfo;
N    tImageControl_t* ptCtrl;
N    const tImageDataFmt_t* ptFormat;
N    uint8_t* pucFinger_;
N    tRect_t* ptRect;
N} __PACKED tProtocolImage_t;
X} __attribute__ ((packed)) tProtocolImage_t;
N
N#define protocol_LogCode(LogType, Code)    \
N		protocol_Log((LogType),  \
N			&(const tLogDataFormat_t)   \
N		{   \
N			.ucRow_ = 0,    \
N			.ucLogIndex_ = (Code),    \
N		}, (void*)0)
X#define protocol_LogCode(LogType, Code)    		protocol_Log((LogType),  			&(const tLogDataFormat_t)   		{   			.ucRow_ = 0,    			.ucLogIndex_ = (Code),    		}, (void*)0)
N
N// #define protocol_LogVectorRshift(LogType, datanum, data, Code, shift) \
N// 		protocol_Log((LogType),   \
N//             &(const tLogDataFormat_t)   \
N// 		{   \
N// 			.ucRow_ = 1, \
N// 			.ucCol_ = (datanum), \
N// 			.ucBufferCol_ = 1,    \
N// 			.tDataType = datatypeof((data)[0]),  \
N// 			.ucLogIndex_ = (Code), \
N// 			.tOptions = {.bIsRotated = ptMemConf->bSwapXY, .b6Rightshift_ = (shift)},  \
N// 		}, (void*)(data))
X
N
N//#define protocol_LogVector(LogType, datanum, data, Code) \
N//        protocol_LogVectorRshift(LogType, datanum, data, Code, 0)
X
N
N// #define protocol_LogBit(LogType, datanum, data, iRamCol_, row, Code)\
N//         protocol_Log((LogType),   \
N// 				&(const tLogDataFormat_t)   \
N// 		{   \
N// 			.ucRow_ = 1, \
N// 			.ucCol_ = (datanum), \
N// 			.ucBufferCol_ = 1,    \
N// 			.tDataType = datatypeof(data[0]),  \
N// 			.ucLogIndex_ = (Code), \
N// 			.tOptions = {.bIsRotated = ptMemConf->bSwapXY, .bBitfieldData = YES},  \
N// 		}, (void*)(data))
X
N
N#define _protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, bTranspose) \
N		protocol_Log((LogType),   \
N                &(const tLogDataFormat_t)   \
N        {   \
N            .ucRow_ = (row), \
N            .ucCol_ = (datanum), \
N            .ucBufferCol_ = (iRamCol_),    \
N            .tDataType = datatypeof((data)[0]),  \
N            .ucLogIndex_ = (Code), \
N            .tOptions = {.bIsRotated = bTranspose, .b6Rightshift_ = (Shift_)},  \
N        }, (void*)(data))
X#define _protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, bTranspose) 		protocol_Log((LogType),                   &(const tLogDataFormat_t)           {               .ucRow_ = (row),             .ucCol_ = (datanum),             .ucBufferCol_ = (iRamCol_),                .tDataType = datatypeof((data)[0]),              .ucLogIndex_ = (Code),             .tOptions = {.bIsRotated = bTranspose, .b6Rightshift_ = (Shift_)},          }, (void*)(data))
N
N#define protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, NO)
X#define protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, NO)
N
N#define protocol_LogMatrixTranspose(LogType, datanum, data, iRamCol_, row, Code) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, YES)
X#define protocol_LogMatrixTranspose(LogType, datanum, data, iRamCol_, row, Code) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, YES)
N
N#define protocol_LogMatrixRshift(LogType, datanum, data, iRamCol_, row, Code, Shift_) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, NO)
X#define protocol_LogMatrixRshift(LogType, datanum, data, iRamCol_, row, Code, Shift_) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, NO)
N
N#define protocol_LogMatrixRshiftTranspose(LogType, datanum, data, iRamCol_, row, Code, Shift_) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, YES)
X#define protocol_LogMatrixRshiftTranspose(LogType, datanum, data, iRamCol_, row, Code, Shift_) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, YES)
N
N#define protocol_LogPaddedMatrix(LogType, datanum, data, iRamCol_, row, Code) \
N		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, PAD_, PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
X#define protocol_LogPaddedMatrix(LogType, datanum, data, iRamCol_, row, Code) 		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, PAD_, PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
N
N#define protocol_LogOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) \
N		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_, row_offset, col_offset), iRamCol_, row, Code, 0, NO)
X#define protocol_LogOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) 		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_, row_offset, col_offset), iRamCol_, row, Code, 0, NO)
N
N#define protocol_LogPaddedOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) \
N		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, row_offset + PAD_, col_offset + PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
X#define protocol_LogPaddedOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) 		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, row_offset + PAD_, col_offset + PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
N
N  
N
N 
Ntypedef struct
N{
N uint16_t VALUE[92][2];
N} __PACKED tDRIVERSetting_t;
X} __attribute__ ((packed)) tDRIVERSetting_t;
N 
Ntypedef enum
N{
N    SW9502_REG_ADDR_MDIDLE = 0,     // MdIdle   0
N    SW9502_REG_ADDR_SNRSTR,         // SnrStr   2
N    SW9502_REG_ADDR_MDGNRL,         // MdGnrl   4
N    SW9502_REG_ADDR_AIPADC,         // AipAdc   6
N    SW9502_REG_ADDR_SSUCTRL,        // SsuCtrl  8
N    SW9502_REG_ADDR_TSYNCNUM0,      // TsyncNum0 10
N    SW9502_REG_ADDR_TSYNCNUM1,      // TsyncNum1 12
N    SW9502_REG_ADDR_TSYNCDMY1,      // TsyncDmy1 14
N    SW9502_REG_ADDR_PWMNUM0,        // PwmNum0   16
N    SW9502_REG_ADDR_PWMNUM1,        // PwmNum1   18
N    SW9502_REG_ADDR_CMUXNRM,        // CmuxNrm   20
N    SW9502_REG_ADDR_CMUXNSE,        // CmuxNse   22
N    SW9502_REG_ADDR_COLNUM,         // ColNum    24
N    SW9502_REG_ADDR_ROWNUM,         // RowNum    26
N    SW9502_REG_ADDR_DIGGAIN0,       // DigGain0  28
N    SW9502_REG_ADDR_DIGGAIN1,       // DigGain1  30
N    SW9502_REG_ADDR_NIHMIN0,        // NihMin0   32
N    SW9502_REG_ADDR_NIHMAX0,        // NihMax0   34
N    SW9502_REG_ADDR_NIHMIN1,        // NihMin1   36
N    SW9502_REG_ADDR_NIHMAX1,        // NihMax1   38
N    SW9502_REG_ADDR_NIHMIN2,        // NihMin2   40
N    SW9502_REG_ADDR_NIHMAX2,        // NihMax2   42
N    SW9502_REG_ADDR_NIHMIN3,        // NihMin3   44
N    SW9502_REG_ADDR_NIHMAX3,        // NihMax3   46
N    SW9502_REG_ADDR_NIHRDAT0,       // NihRdat0  48
N    SW9502_REG_ADDR_NIHRDAT1,       // NihRdat1  50
N    SW9502_REG_ADDR_NIHRDAT2,       // NihRdat2  52
N    SW9502_REG_ADDR_NIHRDAT3,       // NihRdat3  54
N    SW9502_REG_ADDR_MDSPCL,         // MdSpcl    56
N    SW9502_REG_ADDR_SHASTR0,        // ShaStr0   58
N    SW9502_REG_ADDR_SHASTR1,        // ShaStr1   60
N    SW9502_REG_ADDR_SHASTR2,        // ShaStr2   62
N    SW9502_REG_ADDR_VCRSTR,         // VcrStr    64
N    SW9502_REG_ADDR_VCRNUM0,        // VcrNum0   66
N    SW9502_REG_ADDR_VCRNUM1,        // VcrNum1   68
N    SW9502_REG_ADDR_VCRNUM2,        // VcrNum2   70
N    SW9502_REG_ADDR_VCRNUM3,        // VcrNum3   72
N    SW9502_REG_ADDR_VCRNUM4,        // VcrNum4   74
N    SW9502_REG_ADDR_VCRNUM5,        // VcrNum5   76
N    SW9502_REG_ADDR_RESERVED0,      // 78
N    SW9502_REG_ADDR_RESERVED1,      // 80
N    SW9502_REG_ADDR_RESERVED2,      // 82
N    SW9502_REG_ADDR_RESERVED3,      // 84
N    SW9502_REG_ADDR_RESERVED4,      // 86
N    SW9502_REG_ADDR_RESERVED5,      // 88
N    SW9502_REG_ADDR_RESERVED6,      // 90
N    SW9502_REG_ADDR_MAX
N} eSW9502_RegMap_t;
N
Ntypedef struct
N{
N uint16_t TSYNC_NUM;
N uint16_t LINE_NUM;
N uint16_t INTV_PERIOD;
N uint16_t OFFSET0_PERIOD;
N uint16_t OFFSET1_PERIOD;
N uint16_t OFFSET2_PERIOD;
N uint16_t PRE_NUM;
N uint16_t PRE_LOW;
N uint16_t PRE_PERIOD;
N uint16_t PRE_ITV_PERIOD;
N uint16_t F0_ACT0_NUM;
N uint16_t F0_ACT1_NUM;
N uint16_t F0_ACT_LOW;
N uint16_t F0_ACT_PERIOD;
N uint16_t F1_ACT_PERIOD;
N uint16_t F1_ACT_LOW;
N uint16_t F2_ACT_PERIOD;
N uint16_t F2_ACT_LOW;
N uint16_t F1_ACT_NUM;
N uint16_t F2_ACT_NUM;
N uint16_t F1_LINE_NUM;
N uint16_t F2_LINE_NUM;
N} __PACKED tPWMDRVSetting_t;
X} __attribute__ ((packed)) tPWMDRVSetting_t;
N
N
Nextern tProtocolImage_t tProtocolImage;
Nextern tProtocolLog_t tProtocolLog;
N
Nextern void protocol_Log(eLogType_t eLogType, const tLogDataFormat_t* _ptDataFormat, const void* _pBuf);
Nextern void protocol_LogImage(eImageType_t _type, const tImageDataFmt_t* _ptDataFormat, uint8_t ucFinger_, tRect_t rect[ucFinger_], const void* _pBuf);
Nextern uint32_t protocol_log_get_mode(void);
Nextern void protocol_log_set_mode(eLogTriggerType_t _m);
N
N
N#endif /* _PROTOCOL_LOG_H_ */
L 14 "..\..\Protocol\protocol_swip.h" 2
N#include "protocol.h"
N
N
N
N/*
N * Information Registers
N */
N#define PRODUCT_NAME_                       16
N#define TEST_DEVICE_READ_PACKED             0x0030//0x0042
N
Ntypedef struct
N{
N    char vcProductName[PRODUCT_NAME_];
X    char vcProductName[16];
N    uint16_t usXResolution;
N    uint16_t usYResolution;
N    uint8_t ucXNode_;
N    uint8_t ucYNode_;
N} __PACKED tSWIPPanel_t;
X} __attribute__ ((packed)) tSWIPPanel_t;
N
Ntypedef struct
N{
N    uint16_t bcdBootVer;
N    uint16_t bcdCoreVer;
N    uint16_t bcdAppVer;
N    uint16_t bcdParaVer;
N} __PACKED tSWIPFirmwareSectionVersion_t;
X} __attribute__ ((packed)) tSWIPFirmwareSectionVersion_t;
N
Ntypedef struct
N{
N    uint8_t ucBootStartAddr;
N    uint8_t ucBootEndAddr;
N    uint8_t ucAppStartAddr;
N    uint8_t ucAppEndAddr;
N    uint8_t ucParamlStartAddr;
N    uint8_t ucParamlEndAddr;
N} __PACKED tSWIPFirmwareSectionAddress_t;
X} __attribute__ ((packed)) tSWIPFirmwareSectionAddress_t;
N
Ntypedef struct
N{
N//	uint32_t ulBootCRC;
N//	uint32_t ulAppCRC;
N//	uint32_t ulParamCRC;
N	uint8_t usCalculateCRC1;
N	uint8_t usCalculateCRC2;
N	uint8_t usCalculateCRC3;
N	uint8_t usCalculateCRC4;
N
N} __PACKED tSWIPFirmwareIntegrity_t;
X} __attribute__ ((packed)) tSWIPFirmwareIntegrity_t;
N
N#define PROTOCOL_NAME_                       8
N
Ntypedef struct
N{
N    char vcProtocolName[PROTOCOL_NAME_];
X    char vcProtocolName[8];
N    uint16_t bcdProtocolVersion;
N	uint16_t I2C_VID;
N	uint16_t I2C_PID;
N} __PACKED tSWIPInterface_t;
X} __attribute__ ((packed)) tSWIPInterface_t;
N
Ntypedef struct
N{
N	uint16_t usPWMTxFrequecy;
N} __PACKED tSWIPExtra_t;
X} __attribute__ ((packed)) tSWIPExtra_t;
N
Ntypedef struct
N{
N	uint16_t ulTrimCode[14];
N	uint32_t ulTrimCRC;
N} __PACKED tSWIPTrimCode_t;
X} __attribute__ ((packed)) tSWIPTrimCode_t;
N
Ntypedef struct
N{
N	tSWIPTrimCode_t tTrimCode_1Set;
N	tSWIPTrimCode_t tTrimCode_2Set;
N} __PACKED tSWIPTrimCodeSet_t;
X} __attribute__ ((packed)) tSWIPTrimCodeSet_t;
N
N/*
N * Event Registers
N */
Ntypedef enum
N{
N    PF_NORMAL = 0,
N    PF_ANGLE_WITHOUT_STRENGTH = 1,
N    PF_SNR_MODE = 2,
N    PF_LIMIT,
N    PF_FOR_SIZEFIX = 0xFFFF,
N} __PACKED eSWIPPacketFormatId_t;
X} __attribute__ ((packed)) eSWIPPacketFormatId_t;
N
Ntypedef struct
N{
N    uint32_t reserved;
N    eSWIPPacketFormatId_t ePacketFormatId;
N    uint8_t ucTouchPacketItemSize;
N} __PACKED tSWIPEventFormat_t;
X} __attribute__ ((packed)) tSWIPEventFormat_t;
N
Ntypedef struct
N{
N    struct
N    {
N        uint8_t b4FingerID :4;
N        uint8_t bPalm :1;
N        uint8_t bHover :1;
N        uint8_t bScreen :1;
N        uint8_t bTouch :1;
N    } __PACKED tInfo;
X    } __attribute__ ((packed)) tInfo;
N    uint8_t ucXHigh;
N    uint8_t ucYHigh;
N    uint8_t ucXLow;
N    uint8_t ucYLow;
N    uint8_t ucWidth;
N    uint16_t usStrength;
N	uint8_t  ucRowStart;
N} __PACKED tSWIPTouchItem00_t;
X} __attribute__ ((packed)) tSWIPTouchItem00_t;
N
Ntypedef struct
N{
N	struct
N	{
N		uint8_t b4FingerID  :4;
N		uint8_t bPalm       :1;
N		uint8_t bHover      :1;
N		uint8_t bScreen     :1;
N		uint8_t bTouch      :1;
N	} __PACKED tInfo;
X	} __attribute__ ((packed)) tInfo;
N	uint8_t ucXHigh;
N	uint8_t ucYHigh;
N	uint8_t ucXLow;
N	uint8_t ucYLow;
N	uint8_t ucWidth;
N	int8_t cAngle;
N	uint8_t ucMajorLength;
N	uint8_t ucMinorLength;
N} __PACKED tSWIPTouchItem01_t;
X} __attribute__ ((packed)) tSWIPTouchItem01_t;
N
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S/*
S * @ TouchItem02
S *
S * SW42102 - Only Use Sharp protocol Format
S *
S * */
Stypedef enum {
S	TOUCH_STATUS_RELEASE = 0,
S	TOUCH_STATUS_PRESS,
S	TOUCH_STATUS_REMAIN,
S	TOUCH_STATUS_MOVE,
S	TOUCH_STATUS_LIMIT
S} eTouchItemInfo;
S
Stypedef enum {
S	TOUCH_TYPE_FINGER = 0,
S	TOUCH_TYPE_GLOVE,
S	TOUCH_TYPE_HOVER,
S	TOUCH_TYPE_PASSIVE_STYLUS,
S	TOUCH_TYPE_ACTIVE_STYLUS,
S	TOUCH_TYPE_ACTIVE_STYLUS_HOVER
S} eTouchItemStatus;
S
Stypedef struct {
S	uint8_t finger;
S	uint8_t glove;
S	uint8_t hover;
S	uint8_t passive_stylus;
S	uint8_t active_stylus;
S	uint8_t active_stylus_hover;
S} tTouchItemType_t;
S
Stypedef struct
S{
S	struct
S	{
S		uint8_t b4FingerID 		:4;
S		uint8_t b1Status		:1;
S		uint8_t b6Type			:6;
S		uint8_t b4Reserved		:5;
S	} __PACKED tInfo;	// 2byte
S    uint8_t ucXHigh;
S    uint8_t ucYHigh;
S    uint8_t ucXLow;
S    uint8_t ucYLow;
S    uint8_t ucWidth;
S    uint16_t usStrength;
S    uint8_t  ucRowStart;
S} __PACKED tSWIPTouchItem02_t;
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N
Ntypedef union
N{
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S	tSWIPTouchItem02_t tItem00;
N#else /* USED_SHARP_SPECIFIC_PROTOCOL */
N	tSWIPTouchItem00_t tItem00;
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N    tSWIPTouchItem01_t tItem01;		
N} uSWIPTouchItem_t;
N
N
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S
S//typedef union
S//{
S//    struct
S//    {
S//        unsigned wakeUpType    :  8;
S//        unsigned touch_cnt     :  5;
S//        unsigned buttonCnt     :  3;
S//        unsigned palmBit       : 16;
S//    } b;
S//} tTouchInfo_t;
S//
S//typedef struct
S//{
S//    unsigned tool_type   : 4;
S//    unsigned event       : 4;
S//    unsigned track_id    : 8;
S//    unsigned x           : 16;
S//    unsigned y           : 16;
S//    unsigned pressure    : 8;
S//    unsigned angle       : 8;
S//    unsigned width_major : 16;
S//    unsigned width_minor : 16;
S//} tTouchData_t;
S
Stypedef struct
S{
S	uint32_t ulDummy[2];
S	struct
S	{
S		unsigned wakeUpType    :  8;
S		unsigned touch_cnt     :  8;
S		unsigned palmBit       : 16;
S	} __PACKED tTouchinfo;
S
S	struct
S	{
S	    unsigned event       : 4;
S	    unsigned tool_type   : 4;
S	    unsigned track_id    : 8;
S	    unsigned x           : 16;
S	    unsigned y           : 16;
S	    unsigned pressure    : 8;
S	    unsigned angle       : 8;
S	    unsigned width_major : 16;
S	    unsigned width_minor : 16;
S	} __PACKED tTouchData[MAX_TOUCH_];
S//    tTouchInfo_t tTouchinfo;
S//    tTouchData_t tTouchData[MAX_TOUCH_];
S	uint8_t   ucContactCnt;
S	uint16_t  RowStart;
S} __PACKED tSWIPPacketInfo_t;
S
N#else /* USED_MOBILE_I2C_PROTOCOL */
Ntypedef struct
N{
N	uint16_t ReportSize;
N	uint8_t  ReportID;
N	
N	struct
N	{
N		uint8_t  Status;
N		uint8_t  ID;
N		uint16_t ucX;
N		uint16_t ucY;
N	} __PACKED tTouchInfo[MAX_TOUCH_];
X	} __attribute__ ((packed)) tTouchInfo[(10)];
N
N	uint8_t   ucContactCnt;
N	uint16_t  RowStart;
N} __PACKED tSWIPPacketInfo_t;
X} __attribute__ ((packed)) tSWIPPacketInfo_t;
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
Stypedef struct
S{
S		unsigned  running_sts        : 5;	
S		unsigned  device_checked_sts : 1;
S		unsigned  code_valid         : 1;
S		unsigned  cfg_valid          : 1;//10
S		unsigned  font_valid         : 1;
S		unsigned  abnormal_sts       : 1;
S		unsigned  esd_error_sts      : 1;
S		unsigned  reserved0          : 2;	
S		unsigned  disp_mode_mismatch : 1;		
S		unsigned  reserved1          : 1;			
S		unsigned  interrupt_sts      : 1;//10	
S		unsigned  interrupt_type     : 4;//10	
S		unsigned  touch_int_en_sts   : 1;
S		unsigned  dwatch_int_en_sts  : 1;			
S		unsigned  tc_drv_valid       : 1;		
S		unsigned  tc_cfg_load_type   : 2;
S		unsigned  dic_disp_sts       : 2;
S		unsigned  model_id_load_flag : 1;
S		unsigned  pt_info_error      : 1;
S		unsigned  reserved2          : 3;
S} __PACKED t_tc_status;
S
S
S	
Stypedef struct
S{
S		unsigned wakeUpType    :  8;
S		unsigned touch_cnt     :  5;
S		unsigned buttonCnt     :  3;
S		unsigned palmBit       : 16;
S} __PACKED tTouchInfo_t;
S
Stypedef struct
S{
S    unsigned tool_type   : 4;
S    unsigned event       : 4;
S    unsigned track_id    : 8;
S    unsigned x           : 16;
S    unsigned y           : 16;
S    unsigned pressure    : 8;
S    unsigned angle       : 8;
S    unsigned width_major : 16;
S    unsigned width_minor : 16;
S} __PACKED tTouchData_t;
S
Stypedef struct
S{    
S    uint32_t       _ic_status;
S  	t_tc_status    _tc_status;		
S    tTouchInfo_t   _info;
S		tTouchData_t   _data[10];
S}tAndroidDevInfo_t;
S
S
Stypedef struct
S{
S    uint32_t*     ic_status;
S    t_tc_status*  tc_status;
S    tTouchInfo_t* info;
S    tTouchData_t* data;
S} __PACKED tReportPacket_t;
S
N#endif
N
N
N//static __inline__ int protocol_swip_GetPacketSize(eSWIPPacketFormatId_t id)
N//{
N//    return ((int [])
N//    {
N//        sizeof(tSWIPTouchItem00_t), sizeof(tSWIPTouchItem01_t)
N//    })[id];
N//}
N
N//static __inline__ int protocol_swip_GetFormattedStr(char* p, eSWIPPacketFormatId_t id)
N//{
N//    // charactor 8.
N//    switch( id )
N//    {
N//        case PF_NORMAL:
N//        {
N//            const char fmt[] = "[%2d]={%4d,%4d,%3d,%4d},";
N//            strcpy(p, fmt);
N//            return 26;
N//        }
N//        case PF_ANGLE_WITHOUT_STRENGTH:
N//        {
N//            const char fmt[] = "[%2d]={%4d,%4d,%3d,%3d,%3d,%3d},";
N//            strcpy(p, fmt);
N//            return 31;
N//        }
N//    }
N//    return 0; //NOTE : warning... 0     !!
N//}
N
N
Ntypedef enum
N{
N    GT_NONE
N} eSWIPGestureType_t;
N
Ntypedef struct
N{
N    enum
N    {
N        NT_NONE = 0,
N        NT_ESD,
N        NT_WAKEUP_GESTURE_DETECTED
N    } eNotificationType;
N    union
N    {
N        struct
N        {
N            uint8_t ucFrameCnt;
N        } __PACKED tESDAlertPacket;
X        } __attribute__ ((packed)) tESDAlertPacket;
N        struct
N        {
N            eSWIPGestureType_t eGestureType;
N        } __PACKED tWakeupGestureAlertPacket;
X        } __attribute__ ((packed)) tWakeupGestureAlertPacket;
N    } __PACKED uData;
X    } __attribute__ ((packed)) uData;
N} __PACKED tSWIPAlertPacket_t;
X} __attribute__ ((packed)) tSWIPAlertPacket_t;
N
N/*
N * Parameter Mode Registers
N */
N#define SWIP_PARAMETER_PROTOCOL_ID               0x0001
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tSWIPParameterInfo_t;
X} __attribute__ ((packed)) tSWIPParameterInfo_t;
N
N/*
N * Cm Test Mode Registers
N */
N#define SWIP_TEST_PROTOCOL_ID                 	0x0001
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tSWIPTestInfo_t;
X} __attribute__ ((packed)) tSWIPTestInfo_t;
N
N#if USED_MNT_USB_CUSTOM_PROTOCOL
X#if ((1==0))
Stypedef enum
S{
S    CTT_RESERVED0	= 0,
S	CTT_RESERVED1	= 1,
S	CTT_ABS			= 2,
S	CTT_JITTER		= 3,
S	CTT_SHORT		= 4,
S	CTT_CRC_CHECK	= 5,
S	CTT_NONE		= 0xFF,
S} __PACKED eSWIPTestType_t;
N#else
Ntypedef enum
N{
N    CTT_RESERVED	= 0,
N    CTT_ABS			= 1,
N	CTT_JITTER		= 2,
N	CTT_ABS_DIFF	= 3,
N	CTT_DC_ABS		= 4,
N	CTT_CRC_CHECK	= 5,
N	CTT_EVENODD_SHORT		= 6,
N	CTT_OPEN_SHORT	= 7,
N	CTT_NONE		= 0xFF,
N} __PACKED eSWIPTestType_t;
X} __attribute__ ((packed)) eSWIPTestType_t;
N#endif
N
Ntypedef struct
N{
N    volatile eSWIPTestType_t eTestType;
N    volatile uint8_t ucABSDiffCount;
N	volatile uint8_t ucABSCount;
N	volatile uint8_t ucDCABSCount;
N	volatile uint8_t ucJitterAVGCount;
N	volatile uint8_t ucJitterMAXCount;
N	volatile uint32_t lCRCValue;
N} __attribute__ ((packed)) tSWIPTestControl_t;
N
Ntypedef struct
N{
N    uint8_t ucRow_;
N    uint8_t ucCol_;
N    uint8_t ucBufferCol_;
N    bool_t bIsRotated;
N    uint8_t ucKey_;
N    tSignedByteDataType_t tDataType;
N} __PACKED tSWIPTestDataFmt_t;
X} __attribute__ ((packed)) tSWIPTestDataFmt_t;
N
Ntypedef struct
N{
N    struct
N    {
N        tSWIPTestInfo_t* ptInfo;
N        tSWIPTestControl_t* ptCtrl;
N        const tSWIPTestDataFmt_t* ptFormat;
N    } __PACKED  tTest;
X    } __attribute__ ((packed))  tTest;
N} __PACKED tSWIPTest_t;
X} __attribute__ ((packed)) tSWIPTest_t;
N
Ntypedef struct
N{
N    bool_t bGNDNoiseStatus;
N    bool_t bLCDNoiseStatus;
N    uint8_t ucOscVal;
N
N    bool_t bReadModuleConfig;
N} __PACKED tSWIPControlForTuning_t;
X} __attribute__ ((packed)) tSWIPControlForTuning_t;
N
Ntypedef struct
N{
N    tSWIPPanel_t* ptPanel;
N    tSWIPFirmwareSectionVersion_t* ptVersion;
N    tSWIPFirmwareSectionAddress_t* ptSectionAddress;
N    tSWIPFirmwareIntegrity_t* ptIntegrity;
N    tSWIPInterface_t* ptInterface;
N    tSWIPExtra_t* ptExtra;
N    tSWIPTrimCodeSet_t* ptTrimCode;
N
N} __PACKED tSWIPInfo_t;
X} __attribute__ ((packed)) tSWIPInfo_t;
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
Stypedef struct  
S{
S		uint8_t minor;
S		uint8_t major:4;
S		uint8_t build:4;
S		uint8_t chip;
S		uint8_t protocol:4;
S		uint8_t rsvd;
S} __PACKED tc_version_t;
S
Stypedef struct  
S{
S		uint16_t boot;
S		uint16_t core;
S} __PACKED chip_version_t;
S
S
Stypedef struct
S{
S    u4byteString_t*    ptSprChipID;
S    tc_version_t*      ptTcVersion;
S    chip_version_t*    ptChipVersion;
S    u8byteString_t*    ptTcProductId;
S} __PACKED tSWIPAndroidBaseInfo_t;
S
Stypedef struct
S{
S    uint32_t*          ptSprChipTest;    //0x400
S		uint32_t* 				 ptSprBootSts;     //0x401
S		uint32_t* 				 ptTcDeviceCtl;    //0x402
S		uint32_t* 				 ptTcInterruptCtl; //0x403
S		uint32_t* 				 ptImeState;       //0x404
S		uint32_t* 				 ptTciEnableW;     //0x405
S		uint32_t* 				 ptSwipeEnableW;   //0x406
S		uint32_t* 				 ptSprSubDispSts;  //0x407
S		uint32_t* 				 ptTcDriveCtl;     //0x408
S} __PACKED tSWIPAndroidSprChipInfo_t;
N#endif
N
N
Ntypedef struct
N{
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S//    tSWIPEventFormat_t* ptEventFormat;
S    tSWIPPacketInfo_t* ptPacketInfo;
N#else /* USED_MOBILE_I2C_PROTOCOL */
N    tSWIPEventFormat_t* ptEventFormat;
N    tSWIPPacketInfo_t* ptPacketInfo;
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N} __PACKED tSWIPEvent_t;
X} __attribute__ ((packed)) tSWIPEvent_t;
N
Ntypedef struct
N{
N    tSWIPControlForTuning_t* ptControlForTuning;
N    tPWMDRVSetting_t*        ptPWMDRVParam;
N    tDRIVERSetting_t*        ptROICParam;
N} __PACKED tSWIPSpecialAction_t;
X} __attribute__ ((packed)) tSWIPSpecialAction_t;
N
Ntypedef struct
N{
N    tSWIPParameterInfo_t* ptInfo;
N} __PACKED tSWIPParameter_t;
X} __attribute__ ((packed)) tSWIPParameter_t;
N
Ntypedef struct
N{
N    uint8_t** ppucBuffer;
N    uint16_t* vusStartAddr;
N    int iSize;
N} __PACKED tSWIPBufferInfo_t;
X} __attribute__ ((packed)) tSWIPBufferInfo_t;
N
Ntypedef struct
N{
N    uint8_t** ppucData;//Pointer of array of pointers.
N    uint8_t* vucStartLAddr;
N    int iSize;
N} __PACKED tSWIPSubsetInfo_t;
X} __attribute__ ((packed)) tSWIPSubsetInfo_t;
N
N/*
N * Interfaces
N */
N
N/* Define Functions */
N
Nextern void protocol_swip_Init(void);
Nextern eProtocolMode_t protocol_swip_GetMode(void);
Nextern void protocol_swip_SetMode(eProtocolMode_t _eMode);
N
Nextern bool_t protocol_swip_GetRecalibrate(void);
Nextern void protocol_swip_SetRecalibrate(bool_t _bRecalibrate);
Nextern ePowerConsumptionState_t protocol_swip_GetPowerConsumptionState(void);
Nextern void protocol_swip_SetPowerConsumptionState(ePowerConsumptionState_t _eState);
Nextern uint32_t protocol_swip_GetGestureType(void);
Nextern void protocol_swip_SetGestureType(uint32_t _ulGestureType);
Nextern bool_t protocol_swip_GetDisableESDAlert(void);
Nextern void protocol_swip_SetDiableESDAlert(bool_t _bVal);
Nextern bool_t protocol_swip_GetChargerAttached(void);
Nextern void protocol_swip_SetChargetAttached(bool_t _bVal);
Nextern bool_t protocol_swip_GetSensingOnWindowEnable(void);
Nextern void protocol_swip_SetSensingOnWindowEnable(bool_t _bVal);
Nextern bool_t protocol_swip_GetGloveSensingEnable(void);
Nextern void protocol_swip_SetGloveSensingEnable(bool_t _bVal);
Nextern bool_t protocol_swip_GetPalmRejectionEnable(void);
Nextern void protocol_swip_SetPalmRejectionEnable(bool_t _bVal);
Nextern bool_t protocol_swip_GetDisableEdgeExpand(void);
Nextern void protocol_swip_SetDisableEdgeExpand(bool_t _bVal);
Nextern uint8_t protocol_swip_GetABSDiffCount(void);
Nextern uint8_t protocol_swip_GetABSCount(void);
Nextern uint8_t protocol_swip_GetDCABSCount(void);
Nextern uint8_t protocol_swip_GetJitterAVGCount(void);
Nextern uint8_t protocol_swip_GetJitterMAXCount(void);
N//extern uint32_t protocol_swip_GetCRCValue(void);
N//extern void protocol_swip_SetCRCValue(uint32_t _lCRCValue);
Nextern void protocol_swip_PendReadyStatus(void);
Nextern void protocol_swip_PendReadyStatusCustom(eProtocolReadyStatus_t data); // NOTE : warning
Nextern void protocol_swip_SetParameterBuffer(void* p);
Nextern void protocol_swip_SetTestType(eSWIPTestType_t _t);
Nextern eSWIPTestType_t protocol_swip_GetTestType(void);
Nextern void protocol_swip_PendTestResult(const tSWIPTestDataFmt_t* _ptDataFormat, const void* _pBuf);
Nextern eSWIPPacketFormatId_t protocol_swip_GetPacketFormatId(void);
Nextern void protocol_swip_InitTouchEventBuffer(void);
Nextern void protocol_swip_PushTouchEvent(const uSWIPTouchItem_t* _kptItem);
Nextern void protocol_swip_SendTouchEvent(void);
Nextern void protocol_swip_SendPenEvent(void);
N#if defined(SUPPORT_ANDROID)
X#if 0L
Sextern void protocol_Android_PushTouchEvent(const uSWIPTouchItem_t* _kptItem);
N#endif
N
Nextern bool_t protocol_swip_GetGNDNoiseHandlingStatus(void);
Nextern void protocol_swip_SetGNDNoiseHandlingStatus(bool_t _bStatus);
Nextern bool_t protocol_swip_GetLCDNoiseHandlingStatus(void);
Nextern void protocol_swip_SetLCDNoiseHandlingStatus(bool_t _bStatus);
Nextern uint8_t protocol_swip_GetOscVal(void);
Nextern void protocol_swip_SetOscVal(uint8_t oscval);
Nextern bool_t protocol_swip_GetReadModuleConfigStatus(void);
Nextern void protocol_swip_SetReadModuleConfigStatus(bool_t _bStatus);
N
Nextern uint8_t* protocol_swip_GetMappedPointer(uint16_t _addr);
Nextern void protocol_swip_ClearInterrupt(uint16_t _addr);
Nextern bool_t protocol_swip_GetEventIntrType(void);
N#if defined(SUPPORT_ANDROID)
X#if 0L
Sextern bool_t protocol_android_SetEventIntrType(void);
Sextern bool_t protocol_android_SetDevCtlSts(void);
N#endif
N#endif /* __PROTOCOL_SWIP_H__ */
L 45 "..\..\Protocol\protocol_def.h" 2
N#include "protocol_dfup.h"
L 1 "..\..\Protocol\protocol_dfup.h" 1
N/*
N * protocol_dfup.h
N *
N *  Created on: 2015. 4. 30.
N *      Author: parkyj2
N */
N
N#ifndef __PROTOCOL_DFUP_H__
N#define __PROTOCOL_DFUP_H__
N
N#include "protocol_dfup_regmap.h"
L 1 "..\..\Protocol\protocol_dfup_regmap.h" 1
N/*
N * mip4d0.h
N *
N *  Created on: 2015. 3. 16.
N *      Author: parkyj2
N */
N
N#ifndef __DFUP_REGMAP_H__
N#define __DFUP_REGMAP_H__
N
N#define SWIP_REG_ADDR_INFO                       0x0100
N#define SWIP_REG_ADDR_INFO_PANEL                 0x0100
N#define SWIP_REG_ADDR_INFO_SECTION_VERSION       0x0120
N#define SWIP_REG_ADDR_INFO_SECTION_ADDR          0x0130
N#define SWIP_REG_ADDR_INFO_INTEGRITY             0x0140
N#define SWIP_REG_ADDR_INFO_INTERFACE             0x0150
N#define SWIP_REG_ADDR_INFO_EXTRA                 0x0170
N#define SWIP_REG_ADDR_INFO_TRIMCODE_1            0x01A0
N#define SWIP_REG_ADDR_INFO_TRIMCODE_2            0x01C0
N
N#define SWIP_REG_ADDR_EVENT                      0x0200
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S//#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0200
S//#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
S#define SWIP_REG_ADDR_EVENT_PACKET_FORMAT	     0x0200
S#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0208
S#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x020C
N#else /* USED_MOBILE_I2C_PROTOCOL */
N#define SWIP_REG_ADDR_EVENT_FORMAT               0x0200
N#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0210
N#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#define DFUP_REG_ADDR_FLASH_CTRL			 	 0x0300
N#define DFUP_REG_ADDR_FLASH_CTRL_CMD			 0x0300
N#define DFUP_REG_ADDR_FLASH_CTRL_STATUS 		 0x0310
N
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL			 0x1400
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_CMD		 0x1400
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_STATUS	 	 0x1401
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_SIZE		 0x1402
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_ADDR		 0x1404
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_BUFFER		 0x1408
N
N#define SWIP_REG_ADDR_CTRL                       0x0600
N#define SWIP_REG_ADDR_CTRL_GETTER                0x0600
N#define SWIP_REG_ADDR_CTRL_SETTER                0x0610
N
N#define SWIP_REG_ADDR_PARAMETER                  0x0800
N#define SWIP_REG_ADDR_PARAMETER_INFO             0x0800
N#define SWIP_REG_ADDR_PARAMETER_CONTROL          0x0810
N
N#define SWIP_REG_ADDR_TEST                       0x0A00
N#define SWIP_REG_ADDR_TEST_CM_INFO               0x0A00
N#define SWIP_REG_ADDR_TEST_CM_CONTROL            0x0A10
N#define SWIP_REG_ADDR_TEST_CM_DATA_FORMAT        0x0A20
N
N#define SWIP_REG_ADDR_IMAGE                      0x0C00
N#define SWIP_REG_ADDR_IMAGE_INFO                 0x0C00
N#define SWIP_REG_ADDR_IMAGE_CONTROL              0x0C10
N#define SWIP_REG_ADDR_IMAGE_DATA_FORMAT          0x0C20
N#define SWIP_REG_ADDR_IMAGE_FINGER_NUM           0x0C30
N#define SWIP_REG_ADDR_IMAGE_FINGER_AREA          0x0C31
N
N#define SWIP_REG_ADDR_LOG                        0x1000
N#define SWIP_REG_ADDR_LOG_INFO                   0x1000
N#define SWIP_REG_ADDR_LOG_CONTROL                0x1010
N#define SWIP_REG_ADDR_LOG_DATA_FORMAT            0x1020
N
N#define SWIP_REG_ADDR_SPECIAL_ACTION             0x1200
N#define SWIP_REG_ADDR_CONTROL_FOR_TUNING         0x1200
N
N#define SWIP_REG_ADDR_GENERAL_BUFFER             0x2000
N#define SWIP_REG_ADDR_PARAMETER_BUFFER           0x6000
N#define SWIP_REG_ADDR_RESERVED                   0xF000
N
N#endif /* __SWIP_REGMAP_H__ */
L 12 "..\..\Protocol\protocol_dfup.h" 2
N
N/*
N * Control Registers
N */
N
N#define PROTOCOL_NAME_                       8
N
Ntypedef struct
N{
N    uint16_t bcdBootVer;
N    uint16_t bcdCoreVer;
N    uint16_t bcdAppVer;
N    uint16_t bcdParaVer;
N} __PACKED tDFUPFirmwareSectionVersion_t;
X} __attribute__ ((packed)) tDFUPFirmwareSectionVersion_t;
N
Ntypedef struct
N{
N    uint8_t ucBootStartAddr;
N    uint8_t ucBootEndAddr;
N    uint8_t ucAppStartAddr;
N    uint8_t ucAppEndAddr;
N    uint8_t ucParamlStartAddr;
N    uint8_t ucParamlEndAddr;
N} __PACKED tDFUPFirmwareSectionAddress_t;
X} __attribute__ ((packed)) tDFUPFirmwareSectionAddress_t;
N
Ntypedef struct
N{
N	uint32_t ulBootCRC;
N	uint32_t ulAppCRC;
N	uint32_t ulParamCRC;
N} __PACKED tDFUPFirmwareIntegrity_t;
X} __attribute__ ((packed)) tDFUPFirmwareIntegrity_t;
N
Ntypedef struct
N{
N    char vcProtocolName[PROTOCOL_NAME_];
X    char vcProtocolName[8];
N    uint16_t bcdProtocolVersion;
N    uint16_t I2C_VID;
N    uint16_t I2C_PID;
N} __PACKED tDFUPInterface_t;
X} __attribute__ ((packed)) tDFUPInterface_t;
N
Ntypedef struct
N{
N	uint16_t ulTrimCode[14];
N	uint32_t ulTrimCRC;
N} __PACKED tDFUPTrimCode_t;
X} __attribute__ ((packed)) tDFUPTrimCode_t;
N
Ntypedef struct
N{
N	tDFUPTrimCode_t tTrimCode_1Set;
N	tDFUPTrimCode_t tTrimCode_2Set;
N} __PACKED tDFUPTrimCodeSet_t;
X} __attribute__ ((packed)) tDFUPTrimCodeSet_t;
N
Ntypedef struct
N{
N	tDFUPFirmwareSectionVersion_t* ptVersion;
N	tDFUPFirmwareSectionAddress_t* ptSectionAddress;
N	tDFUPFirmwareIntegrity_t* ptIntegrity;
N    tDFUPInterface_t* ptInterface;
N    tDFUPTrimCodeSet_t* ptTrimCode;
N} __PACKED tDFUPInfo_t;
X} __attribute__ ((packed)) tDFUPInfo_t;
N
N/*
N * Event Registers
N */
N
Ntypedef struct
N{
N    uint8_t b7Length    :7;
N    uint8_t bAlert      :1;
N} __PACKED tDFUPPacketInfo_t;
X} __attribute__ ((packed)) tDFUPPacketInfo_t;
N
Ntypedef enum
N{
N    DFUP_PF_NORMAL = 0,
N    DFUP_PF_ANGLE_WITHOUT_STRENGTH = 1,
N    DFUP_PF_LIMIT,
N    DFUP_PF_FOR_SIZEFIX = 0xFFFF,
N} __PACKED eDFUPPacketFormatId_t;
X} __attribute__ ((packed)) eDFUPPacketFormatId_t;
N
Ntypedef struct
N{
N    uint32_t reserved;
N    eDFUPPacketFormatId_t ePacketFormatId;
N    uint8_t ucTouchPacketItemSize;
N} __PACKED tDFUPEventFormat_t;
X} __attribute__ ((packed)) tDFUPEventFormat_t;
N
Ntypedef struct
N{
N    tDFUPEventFormat_t* ptEventFormat;
N    tDFUPPacketInfo_t* ptPacketInfo;
N    uint8_t* vucPacketContent;
N} __PACKED tDFUPEvent_t;
X} __attribute__ ((packed)) tDFUPEvent_t;
N
Ntypedef struct
N{
N    uint8_t** ppucBuffer;
N    uint16_t* vusStartAddr;
N    int iSize;
N} __PACKED tDFUPBufferInfo_t;
X} __attribute__ ((packed)) tDFUPBufferInfo_t;
N
Ntypedef struct
N{
N    uint8_t** ppucData;//Pointer of array of pointers.
N    uint8_t* vucStartLAddr;
N    int iSize;
N} __PACKED tDFUPSubsetInfo_t;
X} __attribute__ ((packed)) tDFUPSubsetInfo_t;
N
Nextern void protocol_dfup_Init(void);
Nextern uint8_t* protocol_dfup_GetMappedPointer(uint16_t _addr);
Nextern void protocol_dfup_ClearInterrupt(uint16_t _addr);
Nextern void protocol_dfup_PendReadyStatus(void);
Nextern eProtocolMode_t protocol_dfup_GetMode(void);
N
N#endif /* __PROTOCOL_DFUP_H__ */
L 46 "..\..\Protocol\protocol_def.h" 2
N#endif /* USE_BOOTLOADER_CODE */
N#include "protocol_log.h"
N#include "protocol_conf.h"
L 1 "..\..\Protocol\protocol_conf.h" 1
N/*
N * protocol_conf.h
N *
N *  Created on: 2015. 3. 20.
N *      Author: parkyj2
N */
N
N#ifndef __PROTOCOL_CONF_H__
N#define __PROTOCOL_CONF_H__
N
N#include "protocol.h"
N/*
N * Types
N */
Ntypedef struct
N{
N    eSWIPPacketFormatId_t ePacketFormatId;
N//    int iMaxFinger_;
N} __PACKED tProtocolCommonConf_t;
X} __attribute__ ((packed)) tProtocolCommonConf_t;
N
N//typedef struct
N//{
N//	int t;
N//} __PACKED tProtocolConf_t;
N
Ntypedef struct
N{
N	eProtocolEventTriggerType_t eEventTriggerType;
N	bool_t bEnableHandShake;
N	bool_t bApplyCoordinate;
N	int iEventPacket_;
N} __PACKED tProtocolInfo_t;
X} __attribute__ ((packed)) tProtocolInfo_t;
N
N
N/*
N * Default Methods
N */
Nextern void protocol_SetCommonConfig(const tProtocolCommonConf_t * _p);
Nextern const tProtocolCommonConf_t *protocol_GetCommonConfig(void);
Nextern tProtocolInfo_t *protocol_GetInfo(void);
N
N
N#endif /* __PROTOCOL_CONF_H__ */
L 49 "..\..\Protocol\protocol_def.h" 2
N
N
N#endif /* __PROTOCOL_DEF_H__ */
L 34 "..\..\Protocol\protocol.c" 2
N
N
NtProtocolBufferPointers_t vtProtocolBufferPointers =
N{
N    NULL,//logging  buffer double pointer
X    0,
N    NULL //Image, Test   buffer double pointer.
X    0 
N};
N
NtProtocolGetter_t ktProtocolGetter  =
N{
N	.eReadyStatus = RS_NONE
N};
N
NtProtocolSetter_t ktProtocolSetter  =
N{
N	.eMode                  = M_TOUCH_NORMAL,
N	.eEventTriggerType      = ETT_NONE,
N	.bRecalibrate           = NO,
X	.bRecalibrate           = (1==0),
N	.ePowerConsumptionState = PCS_ACTIVE,
N	.ulGestureType          = 0,
N	.bDisableESDAlert       = NO,
X	.bDisableESDAlert       = (1==0),
N	.bChargerAttached       = NO,
X	.bChargerAttached       = (1==0),
N	.bGloveSensingEnable    = NO,
X	.bGloveSensingEnable    = (1==0),
N	.bSensingOnWindowEnable = NO,
X	.bSensingOnWindowEnable = (1==0),
N	.bPalmRejectionEnable   = NO,
X	.bPalmRejectionEnable   = (1==0),
N	.bDisableEdgeExpand     = NO,
X	.bDisableEdgeExpand     = (1==0),
N	.bEnableHandShake       = NO,
X	.bEnableHandShake       = (1==0),
N	.bApplyCoordinate       = NO,
X	.bApplyCoordinate       = (1==0),
N};
N
NtProtocolCtrl_t tProtocolCtrl  =
N{
N    .getter = &(ktProtocolGetter),
N    .setter = &(ktProtocolSetter)
N};
N
Nvoid (*protocol_Init)(void) ;
Nuint8_t* (*protocol_GetMappedPointer)(uint16_t addr) ;
Nvoid (*protocol_ClearInterrupt)(uint16_t addr) ;
N
N#if !defined(USE_BOOTLOADER_CODE)
X#if !0L
Nextern __IO int dfup;
Xextern volatile int dfup;
N#endif /* USE_BOOTLOADER_CODE */
N
Nvoid protocol_init(void)
N{
N#if !( defined(USE_BOOTLOADER_8KB) || defined(USE_BOOTLOADER_16KB) )
X#if !( 0L || 1L )
S#if defined(_BOOTLOADER)
S		protocol_Init               = &protocol_dfup_Init;
S		protocol_GetMappedPointer   = &protocol_dfup_GetMappedPointer;
S		protocol_ClearInterrupt     = &protocol_dfup_ClearInterrupt;
S#else
S		protocol_Init               = &protocol_swip_Init;
S		protocol_GetMappedPointer   = &protocol_swip_GetMappedPointer;
S		protocol_ClearInterrupt     = &protocol_swip_ClearInterrupt;
S#endif
N#else //USE_BOOTLOADER
N		if (dfup)
N		{
N			protocol_Init 				= &protocol_dfup_Init;
N			protocol_GetMappedPointer 	= &protocol_dfup_GetMappedPointer;
N			protocol_ClearInterrupt 	= &protocol_dfup_ClearInterrupt;
N		}
N		else
N		{
N			protocol_Init 				= &protocol_swip_Init;
N			protocol_GetMappedPointer 	= &protocol_swip_GetMappedPointer;
N			protocol_ClearInterrupt 	= &protocol_swip_ClearInterrupt;
N		}
N#endif
N
N    if( protocol_Init )
N    {
N    	(*protocol_Init)();
N    }
N}
