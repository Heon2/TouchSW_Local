; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\module.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\module.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\module.crf ..\..\Module\module.c]
                          THUMB

                          AREA ||i.GetLocalSensingArea||, CODE, READONLY, ALIGN=2

                  GetLocalSensingArea PROC
;;;53     enum_LOCAL_SENGSING_POSITION LocalSensingPos = LOCAL_0TH_POSITION;
;;;54     enum_LOCAL_SENGSING_POSITION GetLocalSensingArea(void)
000000  4801              LDR      r0,|L1.8|
;;;55     {
;;;56     	return LocalSensingPos;
000002  7800              LDRB     r0,[r0,#0]  ; LocalSensingPos
;;;57     }
000004  4770              BX       lr
;;;58     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.MODULE_Initialize||, CODE, READONLY, ALIGN=2

                  MODULE_Initialize PROC
;;;302    
;;;303    void MODULE_Initialize(void)
000000  b510              PUSH     {r4,lr}
;;;304    {
;;;305    #if USED_NOISE_HOPPING_FREQ	
;;;306    	ptAppInfo = app_GetInfo();
;;;307    	thisCommonConf = app_GetCommonConfig();
;;;308    #endif /* USED_NOISE_HOPPING_FREQ */
;;;309    	thisFixedConf = module_GetFixedConfig();
000002  f7fffffe          BL       module_GetFixedConfig
000006  4904              LDR      r1,|L2.24|
;;;310    
;;;311    #if USED_ESD_RECOVERY_CODE
;;;312    	sptAlgorithmInfo = algorithm_GetInfo();
;;;313    #endif /* USED_ESD_RECOVERY_CODE */
;;;314    
;;;315    	initBoardGPIO();
000008  6088              STR      r0,[r1,#8]  ; thisFixedConf
00000a  f7fffffe          BL       initBoardGPIO
;;;316    	SRIC_Initialize();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      SRIC_Initialize
;;;317    	//initECLK();
;;;318    	//delay_ms(10);
;;;319    
;;;320    #if USED_SPEED_MESURE
;;;321    	{
;;;322    		uint32_t ulIdx, ulRow, ulCol;
;;;323    		uint32_t ulColOffset;
;;;324    		uint32_t ulRowOffset;
;;;325    
;;;326    		_ptModuleCommonConf = module_GetCommonConfig();
;;;327    		ulColOffset = _ptModuleCommonConf->ucScreenCol_ / SPEED_MESURE_COL_DIRECTION_TOUCH_NUM;
;;;328    		ulRowOffset = _ptModuleCommonConf->ucScreenRow_ / SPEED_MESURE_ROW_DIRECTION_TOUCH_NUM;
;;;329    
;;;330    		ulIdx = 0;
;;;331    		for(ulRow = 0; ulRow < SPEED_MESURE_FINGER_TOUCH_ROW_NUM; ulRow++)
;;;332    		{
;;;333    			for(ulCol = 0; ulCol < SPEED_MESURE_FINGER_TOUCH_COL_NUM; ulCol++)
;;;334    			{
;;;335    				mulMesureVectorIndex[ulIdx] = (_ptModuleCommonConf->ucScreenCol_ * ulRow) + ulCol;
;;;336    				ulIdx++;
;;;337    			}
;;;338    		}
;;;339    
;;;340    		for(ulIdx = 0; ulIdx < SPEED_MESURE_FINGER_MAX_TOUCH_NUM; ulIdx++)
;;;341    		{
;;;342    			mulMesureStartPosition[ulIdx] = ((SPEED_MESURE_START_OFFSET + (mulMesureRowIndex[ulIdx]*ulRowOffset))*_ptModuleCommonConf->ucScreenCol_)+(SPEED_MESURE_START_OFFSET + (mulMesureColIndex[ulIdx]*ulColOffset));
;;;343    		}
;;;344    	}
;;;345    #endif /* USED_SPEED_MESURE */
;;;346    }
;;;347    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      ||.data||

                          AREA ||i.SetLocalSensingArea||, CODE, READONLY, ALIGN=2

                  SetLocalSensingArea PROC
;;;58     
;;;59     void SetLocalSensingArea(enum_LOCAL_SENGSING_POSITION area)
000000  4901              LDR      r1,|L3.8|
;;;60     {
;;;61     	LocalSensingPos = area;
000002  7008              STRB     r0,[r1,#0]
;;;62     }
000004  4770              BX       lr
;;;63     
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.hal_clear_LocalType_flag||, CODE, READONLY, ALIGN=2

                  hal_clear_LocalType_flag PROC
;;;105    
;;;106    void hal_clear_LocalType_flag(void)
000000  4901              LDR      r1,|L4.8|
;;;107    {
;;;108    	gLocalTypeFlag = PARTIAL_PEN_BEACON;
000002  2000              MOVS     r0,#0
000004  7088              STRB     r0,[r1,#2]
;;;109    }
000006  4770              BX       lr
;;;110    
                          ENDP

                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.hal_clear_SubState_flag||, CODE, READONLY, ALIGN=2

                  hal_clear_SubState_flag PROC
;;;122    
;;;123    void hal_clear_SubState_flag(void)
000000  4901              LDR      r1,|L5.8|
;;;124    {
;;;125    	gSubStateFlag = TOUCH_NORMAL_OPER_NONCHANGE;
000002  2000              MOVS     r0,#0
000004  70c8              STRB     r0,[r1,#3]
;;;126    }
000006  4770              BX       lr
;;;127    
                          ENDP

                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.hal_clear_irq_flag||, CODE, READONLY, ALIGN=2

                  hal_clear_irq_flag PROC
;;;71     
;;;72     void hal_clear_irq_flag(int _id)
000000  4a01              LDR      r2,|L6.8|
;;;73     {
;;;74     	gbIrqFlag[_id] = 0;
000002  2100              MOVS     r1,#0
000004  5411              STRB     r1,[r2,r0]
;;;75     }
000006  4770              BX       lr
;;;76     
                          ENDP

                  |L6.8|
                          DCD      ||.data||+0x10

                          AREA ||i.hal_clear_overlap_pen||, CODE, READONLY, ALIGN=2

                  hal_clear_overlap_pen PROC
;;;88     
;;;89     void hal_clear_overlap_pen(void)
000000  4901              LDR      r1,|L7.8|
;;;90     {
;;;91     	gucOverlapFPend = 0;
000002  2000              MOVS     r0,#0
000004  7048              STRB     r0,[r1,#1]
;;;92     }
000006  4770              BX       lr
;;;93     
                          ENDP

                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.hal_get_LocalType_flag||, CODE, READONLY, ALIGN=2

                  hal_get_LocalType_flag PROC
;;;110    
;;;111    ePartialSensing_t hal_get_LocalType_flag(void)
000000  4801              LDR      r0,|L8.8|
;;;112    {
;;;113    	return gLocalTypeFlag;
000002  7880              LDRB     r0,[r0,#2]  ; gLocalTypeFlag
;;;114    }
000004  4770              BX       lr
;;;115    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.hal_get_SubState_flag||, CODE, READONLY, ALIGN=2

                  hal_get_SubState_flag PROC
;;;127    
;;;128    eNormalOperSubState_t hal_get_SubState_flag(void)
000000  4801              LDR      r0,|L9.8|
;;;129    {
;;;130    	return gSubStateFlag;
000002  78c0              LDRB     r0,[r0,#3]  ; gSubStateFlag
;;;131    }
000004  4770              BX       lr
;;;132    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      ||.data||

                          AREA ||i.hal_get_irq_flag||, CODE, READONLY, ALIGN=2

                  hal_get_irq_flag PROC
;;;76     
;;;77     bool_t hal_get_irq_flag(int _id)
000000  4901              LDR      r1,|L10.8|
;;;78     {
;;;79     	return gbIrqFlag[_id];
000002  5c08              LDRB     r0,[r1,r0]
;;;80     }
000004  4770              BX       lr
;;;81     
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      ||.data||+0x10

                          AREA ||i.hal_get_overlap_pen||, CODE, READONLY, ALIGN=2

                  hal_get_overlap_pen PROC
;;;93     
;;;94     uint8_t hal_get_overlap_pen(void)
000000  4801              LDR      r0,|L11.8|
;;;95     {
;;;96     	return gucOverlapFPend;
000002  7840              LDRB     r0,[r0,#1]  ; gucOverlapFPend
;;;97     }
000004  4770              BX       lr
;;;98     
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||.data||

                          AREA ||i.hal_set_LocalType_flag||, CODE, READONLY, ALIGN=2

                  hal_set_LocalType_flag PROC
;;;100    
;;;101    void hal_set_LocalType_flag(ePartialSensing_t _id)
000000  4901              LDR      r1,|L12.8|
;;;102    {
;;;103    	gLocalTypeFlag = _id;
000002  7088              STRB     r0,[r1,#2]
;;;104    }
000004  4770              BX       lr
;;;105    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.hal_set_SubState_flag||, CODE, READONLY, ALIGN=2

                  hal_set_SubState_flag PROC
;;;117    
;;;118    void hal_set_SubState_flag(eNormalOperSubState_t _id)
000000  4901              LDR      r1,|L13.8|
;;;119    {
;;;120    	gSubStateFlag = _id;
000002  70c8              STRB     r0,[r1,#3]
;;;121    }
000004  4770              BX       lr
;;;122    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.hal_set_irq_flag||, CODE, READONLY, ALIGN=2

                  hal_set_irq_flag PROC
;;;66     
;;;67     void hal_set_irq_flag(int _id)
000000  4a01              LDR      r2,|L14.8|
;;;68     {
;;;69     	gbIrqFlag[_id] = 1;
000002  2101              MOVS     r1,#1
000004  5411              STRB     r1,[r2,r0]
;;;70     }
000006  4770              BX       lr
;;;71     
                          ENDP

                  |L14.8|
                          DCD      ||.data||+0x10

                          AREA ||i.hal_set_overlap_pen||, CODE, READONLY, ALIGN=2

                  hal_set_overlap_pen PROC
;;;83     
;;;84     void hal_set_overlap_pen(void)
000000  4901              LDR      r1,|L15.8|
;;;85     {
;;;86     	gucOverlapFPend = 1;
000002  2001              MOVS     r0,#1
000004  7048              STRB     r0,[r1,#1]
;;;87     }
000006  4770              BX       lr
;;;88     
                          ENDP

                  |L15.8|
                          DCD      ||.data||

                          AREA ||i.module_Check_LcdOn||, CODE, READONLY, ALIGN=2

                  module_Check_LcdOn PROC
;;;1234   
;;;1235   bool_t module_Check_LcdOn(bool_t bPullDownGPIO)
000000  4906              LDR      r1,|L16.28|
;;;1236   {
000002  b510              PUSH     {r4,lr}
;;;1237   	if(GPIO->tGPIO_DATA_1._GPIO_LCD_ON == 0x0)
000004  6849              LDR      r1,[r1,#4]
000006  f0110f04          TST      r1,#4
;;;1238   	{
;;;1239   		if (bPullDownGPIO)
;;;1240   		{
;;;1241   			Hal_VccOff_State();
;;;1242   		}
;;;1243   		return NO;
;;;1244   	}
;;;1245   
;;;1246   	return YES;
00000a  bf1c              ITT      NE
00000c  2001              MOVNE    r0,#1
;;;1247   }
00000e  bd10              POPNE    {r4,pc}
000010  2800              CMP      r0,#0                 ;1239
000012  bf18              IT       NE                    ;1241
000014  f7fffffe          BLNE     Hal_VccOff_State
000018  2000              MOVS     r0,#0                 ;1243
00001a  bd10              POP      {r4,pc}
;;;1248   
                          ENDP

                  |L16.28|
                          DCD      0x40007000

                          AREA ||i.module_Check_TPEN||, CODE, READONLY, ALIGN=2

                  module_Check_TPEN PROC
;;;1284   
;;;1285   bool_t module_Check_TPEN(void)
000000  4803              LDR      r0,|L17.16|
;;;1286   {
;;;1287   	if(GPIO->tGPIO_DATA_1._GPIO_TP_EN == 0x0)
000002  6840              LDR      r0,[r0,#4]
000004  f4104f00          TST      r0,#0x8000
;;;1288   	{
;;;1289   		return YES;
000008  bf0c              ITE      EQ
00000a  2001              MOVEQ    r0,#1
;;;1290   	}
;;;1291   
;;;1292   	return NO;
00000c  2000              MOVNE    r0,#0
;;;1293   }
00000e  4770              BX       lr
;;;1294   
                          ENDP

                  |L17.16|
                          DCD      0x40007000

                          AREA ||i.module_CmuxOff_Start||, CODE, READONLY, ALIGN=1

                  module_CmuxOff_Start PROC
;;;366    
;;;367    void module_CmuxOff_Start(void)
000000  2001              MOVS     r0,#1
;;;368    {
;;;369    	Hal_sric_start(YES);
000002  f7ffbffe          B.W      Hal_sric_start
;;;370    }
;;;371    
                          ENDP


                          AREA ||i.module_DIag_Start||, CODE, READONLY, ALIGN=1

                  module_DIag_Start PROC
;;;361    
;;;362    void module_DIag_Start(void)
000000  2000              MOVS     r0,#0
;;;363    {
;;;364    	Hal_sric_start(NO);
000002  f7ffbffe          B.W      Hal_sric_start
;;;365    }
;;;366    
                          ENDP


                          AREA ||i.module_Defense_Recovery||, CODE, READONLY, ALIGN=2

                  module_Defense_Recovery PROC
;;;1363   
;;;1364   bool_t module_Defense_Recovery(void)
000000  4805              LDR      r0,|L20.24|
;;;1365   {
;;;1366   	if(GPIO->tGPIO_DATA_1._GPIO_SWDIO == 0x0 && GPIO->tGPIO_DATA_1._GPIO_SWCLK == 0x0)
000002  6841              LDR      r1,[r0,#4]
000004  f0110f40          TST      r1,#0x40
000008  bf05              ITTET    EQ
00000a  6840              LDREQ    r0,[r0,#4]
00000c  f0100f80          TSTEQ    r0,#0x80
;;;1367   	{
;;;1368   		return YES;
;;;1369   	}
;;;1370   	else
;;;1371   	{
;;;1372   		return NO;
000010  2000              MOVNE    r0,#0
000012  2001              MOVEQ    r0,#1                 ;1368
;;;1373   	}
;;;1374   
;;;1375   }
000014  4770              BX       lr
                          ENDP

000016  0000              DCW      0x0000
                  |L20.24|
                          DCD      0x40007000

                          AREA ||i.module_HW_Init||, CODE, READONLY, ALIGN=2

                  module_HW_Init PROC
;;;238    
;;;239    void module_HW_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
000002  f44f577c          MOV      r7,#0x3f00
000006  8838              LDRH     r0,[r7,#0]
000008  f3c02007          UBFX     r0,r0,#8,#8
00000c  2828              CMP      r0,#0x28
;;;240    {
00000e  d024              BEQ      |L21.90|
000010  f44f5178          MOV      r1,#0x3e00
000014  4d54              LDR      r5,|L21.360|
000016  e9d10100          LDRD     r0,r1,[r1,#0]
00001a  f1050418          ADD      r4,r5,#0x18
00001e  e9c50106          STRD     r0,r1,[r5,#0x18]
000022  2628              MOVS     r6,#0x28
000024  7066              STRB     r6,[r4,#1]
000026  f44f5078          MOV      r0,#0x3e00
00002a  6821              LDR      r1,[r4,#0]  ; TMP_INFO
00002c  f7fffffe          BL       FLASH_Write
000030  f44f517a          MOV      r1,#0x3e80
000034  e9d10100          LDRD     r0,r1,[r1,#0]
000038  e9c50106          STRD     r0,r1,[r5,#0x18]
00003c  7066              STRB     r6,[r4,#1]
00003e  f44f507a          MOV      r0,#0x3e80
000042  6821              LDR      r1,[r4,#0]  ; TMP_INFO
000044  f7fffffe          BL       FLASH_Write
000048  e9d70100          LDRD     r0,r1,[r7,#0]
00004c  e9c50106          STRD     r0,r1,[r5,#0x18]
000050  7066              STRB     r6,[r4,#1]
000052  4638              MOV      r0,r7
000054  6821              LDR      r1,[r4,#0]  ; TMP_INFO
000056  f7fffffe          BL       FLASH_Write
                  |L21.90|
;;;241    #if defined(USE_BOOTLOADER_16KB)
;;;242    	module_Slv_addr_change();
;;;243    	module_boot_vidpid_change();
00005a  f7fffffe          BL       module_boot_vidpid_change
00005e  2048              MOVS     r0,#0x48
000060  f7fffffe          BL       SysTick_Initialize
000064  f7fffffe          BL       SCRB_Initialize
000068  f7fffffe          BL       ReMapVectorTableToRam
00006c  f7fffffe          BL       GPIO_Initialize
000070  2501              MOVS     r5,#1
000072  07a8              LSLS     r0,r5,#30
000074  66c5              STR      r5,[r0,#0x6c]
000076  483d              LDR      r0,|L21.364|
000078  f8501fc4          LDR      r1,[r0,#0xc4]!
00007c  f0410108          ORR      r1,r1,#8
000080  6001              STR      r1,[r0,#0]
000082  f7fffffe          BL       USB_DevInit
000086  2040              MOVS     r0,#0x40
000088  f04f21e0          MOV      r1,#0xe000e000
00008c  2400              MOVS     r4,#0
00008e  f8c10100          STR      r0,[r1,#0x100]
000092  1d88              ADDS     r0,r1,#6
000094  f8804400          STRB     r4,[r0,#0x400]
000098  f7fffffe          BL       hal_PendSVHandlerInitialize
00009c  f7fffffe          BL       I2C_Initialize
0000a0  f7fffffe          BL       protocol_init
0000a4  f05f0000          MOVS.W   r0,#0
                  |L21.168|
0000a8  f1005100          ADD      r1,r0,#0x20000000
0000ac  f5013100          ADD      r1,r1,#0x20000
0000b0  600c              STR      r4,[r1,#0]
0000b2  604c              STR      r4,[r1,#4]
0000b4  3008              ADDS     r0,r0,#8
0000b6  f5b04fc0          CMP      r0,#0x6000
0000ba  dbf5              BLT      |L21.168|
;;;244    #endif
;;;245    
;;;246    	
;;;247    	module_System_Init();
;;;248    	module_Protocol_Init();
;;;249    	
;;;250    	module_MspiBuff_Init();
;;;251    	
;;;252    	GPIO->tGPIO_PU_0._GPIO_TSYNC_IN	= 0x0;	// OUTPUT
0000bc  482c              LDR      r0,|L21.368|
0000be  6981              LDR      r1,[r0,#0x18]
0000c0  f0216100          BIC      r1,r1,#0x8000000
0000c4  6181              STR      r1,[r0,#0x18]
;;;253    	GPIO->tGPIO_PU_0._GPIO_VSYNC	= 0x0;	// OUTPUT
0000c6  6981              LDR      r1,[r0,#0x18]
0000c8  f0216180          BIC      r1,r1,#0x4000000
0000cc  6181              STR      r1,[r0,#0x18]
;;;254    	GPIO->tGPIO_PU_1._GPIO_LCD_ON  = 0x0;	// Input
0000ce  69c1              LDR      r1,[r0,#0x1c]
0000d0  f0210104          BIC      r1,r1,#4
0000d4  61c1              STR      r1,[r0,#0x1c]
;;;255    
;;;256    	GPIO->tGPIO_PU_0._GPIO_MSPI_0_MISO = 0x0; // 0:GPIO, 1:MSPI0_MST_MISO
0000d6  6981              LDR      r1,[r0,#0x18]
0000d8  f0210108          BIC      r1,r1,#8
0000dc  6181              STR      r1,[r0,#0x18]
;;;257    	GPIO->tGPIO_PU_0._GPIO_MSPI_1_MISO = 0x0; // 0:GPIO, 1:MSPI1_MST_MISO
0000de  6981              LDR      r1,[r0,#0x18]
0000e0  f0210180          BIC      r1,r1,#0x80
0000e4  6181              STR      r1,[r0,#0x18]
;;;258    	GPIO->tGPIO_PU_0._GPIO_MSPI_2_MISO = 0x0; // 0:GPIO, 1:MSPI2_MST_MISO
0000e6  6981              LDR      r1,[r0,#0x18]
0000e8  f4216100          BIC      r1,r1,#0x800
0000ec  6181              STR      r1,[r0,#0x18]
;;;259    	GPIO->tGPIO_PU_0._GPIO_MSPI_3_MISO = 0x0; // 0:GPIO, 1:MSPI3_MST_MISO
0000ee  6981              LDR      r1,[r0,#0x18]
0000f0  f4214100          BIC      r1,r1,#0x8000
0000f4  6181              STR      r1,[r0,#0x18]
;;;260    	GPIO->tGPIO_PU_0._GPIO_MSPI_4_MISO = 0x0; // 0:GPIO, 1:MSPI4_MST_MISO
0000f6  6981              LDR      r1,[r0,#0x18]
0000f8  f4212100          BIC      r1,r1,#0x80000
0000fc  6181              STR      r1,[r0,#0x18]
;;;261    	GPIO->tGPIO_PU_0._GPIO_MSPI_5_MISO = 0x0; // 0:GPIO, 1:MSPI5_MST_MISO
0000fe  6981              LDR      r1,[r0,#0x18]
000100  f4210100          BIC      r1,r1,#0x800000
000104  6181              STR      r1,[r0,#0x18]
;;;262    	GPIO->tGPIO_AFIO_3._GPIO_TP_INTR = 0x0;
000106  6ec1              LDR      r1,[r0,#0x6c]
000108  f0210103          BIC      r1,r1,#3
00010c  66c1              STR      r1,[r0,#0x6c]
;;;263    	GPIO->tGPIO_DIR_1._GPIO_TP_INTR = 0x1;
00010e  68c1              LDR      r1,[r0,#0xc]
000110  f4413180          ORR      r1,r1,#0x10000
000114  60c1              STR      r1,[r0,#0xc]
;;;264    	GPIO->tGPIO_DATA_1._GPIO_TP_INTR = I2C_GPB10__HIGH;
000116  6841              LDR      r1,[r0,#4]
000118  f4413180          ORR      r1,r1,#0x10000
00011c  6041              STR      r1,[r0,#4]
;;;265    
;;;266    	// SRIC Init control
;;;267    	GPIO->tGPIO_AFIO_1._GPIO_RSTN_0 = 0;
00011e  6e41              LDR      r1,[r0,#0x64]
000120  f0215140          BIC      r1,r1,#0x30000000
000124  6641              STR      r1,[r0,#0x64]
;;;268    	GPIO->tGPIO_DATA_0._GPIO_RSTN_0 = 1;
000126  6801              LDR      r1,[r0,#0]
000128  f0414180          ORR      r1,r1,#0x40000000
00012c  6001              STR      r1,[r0,#0]
;;;269    	GPIO->tGPIO_DIR_0._GPIO_RSTN_0 = 1;
00012e  6881              LDR      r1,[r0,#8]
000130  f0414180          ORR      r1,r1,#0x40000000
000134  6081              STR      r1,[r0,#8]
;;;270    
;;;271    	GPIO->tGPIO_AFIO_1._GPIO_RSTN_1 = 0;
000136  6e41              LDR      r1,[r0,#0x64]
000138  f0214140          BIC      r1,r1,#0xc0000000
00013c  6641              STR      r1,[r0,#0x64]
;;;272    	GPIO->tGPIO_DATA_0._GPIO_RSTN_1 = 1;
00013e  6801              LDR      r1,[r0,#0]
000140  f0414100          ORR      r1,r1,#0x80000000
000144  6001              STR      r1,[r0,#0]
;;;273    	GPIO->tGPIO_DIR_0._GPIO_RSTN_1 = 1;
000146  6881              LDR      r1,[r0,#8]
000148  f0414100          ORR      r1,r1,#0x80000000
00014c  6081              STR      r1,[r0,#8]
;;;274    
;;;275    #if USED_TSYNC2_INPUT_CONTROL
;;;276    	GPIO->tGPIO_PU_1._GPIO_TSYNC2_IN	= 0x0;	// Input
00014e  69c1              LDR      r1,[r0,#0x1c]
000150  f0210120          BIC      r1,r1,#0x20
000154  61c1              STR      r1,[r0,#0x1c]
;;;277    	init_EXIT(PIN_GPA37, EDGE_DETECTION_GPIO, BOTH_EDGE_GPIO, POSITIVE_HIGH_GPIO, ENABLE_GPIO);
000156  2301              MOVS     r3,#1
000158  461a              MOV      r2,r3
00015a  2100              MOVS     r1,#0
00015c  2025              MOVS     r0,#0x25
00015e  9500              STR      r5,[sp,#0]
000160  f7fffffe          BL       init_EXIT
;;;278    #endif /* USED_TSYNC2_INPUT_CONTROL */
;;;279    //	GPIO->tGPIO_DIR_1._GPIO_TP_EN = 1;
;;;280    //	GPIO->tGPIO_DATA_1._GPIO_TP_EN = 0;
;;;281    }
000164  bdf8              POP      {r3-r7,pc}
;;;282    
                          ENDP

000166  0000              DCW      0x0000
                  |L21.360|
                          DCD      ||.data||
                  |L21.364|
                          DCD      0x40030000
                  |L21.368|
                          DCD      0x40007000

                          AREA ||i.module_Init_LcdOn||, CODE, READONLY, ALIGN=2

                  module_Init_LcdOn PROC
;;;1295   #ifdef MODE_SMT
;;;1296   void module_Init_LcdOn(void)
000000  4804              LDR      r0,|L22.20|
;;;1297   {
;;;1298   	GPIO->tGPIO_AFIO_2._GPIO_LCD_ON = 0x0; // GPIO
000002  6e81              LDR      r1,[r0,#0x68]
000004  f0210130          BIC      r1,r1,#0x30
000008  6681              STR      r1,[r0,#0x68]
;;;1299   	GPIO->tGPIO_DIR_1._GPIO_LCD_ON = 0x0;	// Input
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  f0210104          BIC      r1,r1,#4
000010  60c1              STR      r1,[r0,#0xc]
;;;1300   }
000012  4770              BX       lr
;;;1301   
                          ENDP

                  |L22.20|
                          DCD      0x40007000

                          AREA ||i.module_Init_Signal||, CODE, READONLY, ALIGN=2

                  module_Init_Signal PROC
;;;1335   
;;;1336   bool_t module_Init_Signal(void)
000000  480c              LDR      r0,|L23.52|
;;;1337   {
000002  b510              PUSH     {r4,lr}
;;;1338   	if(wdt_init)
000004  7800              LDRB     r0,[r0,#0]  ; wdt_init
000006  2800              CMP      r0,#0
;;;1339   	{
;;;1340   		Hal_WDT_DeInit();
000008  bf18              IT       NE
00000a  f7fffffe          BLNE     Hal_WDT_DeInit
00000e  480a              LDR      r0,|L23.56|
000010  6e81              LDR      r1,[r0,#0x68]
000012  f0210130          BIC      r1,r1,#0x30
000016  6681              STR      r1,[r0,#0x68]
000018  68c1              LDR      r1,[r0,#0xc]
00001a  f0210104          BIC      r1,r1,#4
00001e  60c1              STR      r1,[r0,#0xc]
000020  68c1              LDR      r1,[r0,#0xc]
000022  f4214100          BIC      r1,r1,#0x8000
000026  60c1              STR      r1,[r0,#0xc]
000028  6e81              LDR      r1,[r0,#0x68]
00002a  f0214140          BIC      r1,r1,#0xc0000000
00002e  6681              STR      r1,[r0,#0x68]
;;;1341   	}
;;;1342   
;;;1343   	module_Init_LcdOn();
;;;1344   	module_Init_TPEN();
;;;1345   
;;;1346   //	if(module_Wait_LcdOn())
;;;1347   //	{
;;;1348   //		module_RollBack_Sync();
;;;1349   //		return YES;
;;;1350   //	}
;;;1351   
;;;1352   	return NO;
000030  2000              MOVS     r0,#0
;;;1353   }
000032  bd10              POP      {r4,pc}
;;;1354   
                          ENDP

                  |L23.52|
                          DCD      wdt_init
                  |L23.56|
                          DCD      0x40007000

                          AREA ||i.module_Init_TPEN||, CODE, READONLY, ALIGN=2

                  module_Init_TPEN PROC
;;;1248   
;;;1249   bool_t module_Init_TPEN(void) // NOTE : missing return value
000000  4805              LDR      r0,|L24.24|
;;;1250   {
;;;1251   	GPIO->tGPIO_DIR_1._GPIO_TP_EN = 0x0;	// input
000002  68c1              LDR      r1,[r0,#0xc]
000004  f4214100          BIC      r1,r1,#0x8000
000008  60c1              STR      r1,[r0,#0xc]
;;;1252   	GPIO->tGPIO_AFIO_2._GPIO_TP_EN = 0x0;
00000a  6e81              LDR      r1,[r0,#0x68]
00000c  f0214140          BIC      r1,r1,#0xc0000000
000010  6681              STR      r1,[r0,#0x68]
;;;1253   	return YES;
000012  2001              MOVS     r0,#1
;;;1254   }
000014  4770              BX       lr
;;;1255   
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
                          DCD      0x40007000

                          AREA ||i.module_MspiBuff_Init||, CODE, READONLY, ALIGN=1

                  module_MspiBuff_Init PROC
;;;133    
;;;134    void module_MspiBuff_Init(void)
000000  2000              MOVS     r0,#0
;;;135    {
;;;136    	int i = 0;
000002  4602              MOV      r2,r0
                  |L25.4|
;;;137    
;;;138    	//Initialize MSPI_SRAM
;;;139    	for (i=0;i<0x6000;i+=4)
;;;140    	{
;;;141    		HW_REG(BASE_MSPI_SRAM+i)=0;
000004  f1005100          ADD      r1,r0,#0x20000000
000008  f5013100          ADD      r1,r1,#0x20000
00000c  600a              STR      r2,[r1,#0]
00000e  604a              STR      r2,[r1,#4]
000010  3008              ADDS     r0,r0,#8
000012  f5b04fc0          CMP      r0,#0x6000
000016  dbf5              BLT      |L25.4|
;;;142    	}
;;;143    }
000018  4770              BX       lr
;;;144    
                          ENDP


                          AREA ||i.module_Protocol_Init||, CODE, READONLY, ALIGN=2

                  module_Protocol_Init PROC
;;;156    //extern void protocol_init(void); // NOTE : hal.c�� ����Ǿ� �ִ� �Լ��� �����ϴ� �κп����� ��������� �����ϴ� ������ ��������!!
;;;157    void module_Protocol_Init(void)
000000  2001              MOVS     r0,#1
;;;158    {
000002  b510              PUSH     {r4,lr}
;;;159    	int bSWreset = 0;
;;;160    //	uint8_tAddress = 0; // NOTE : not used!!
;;;161    	SCRB->USB_CTL_UC.ulBulk = 0x01;
000004  0781              LSLS     r1,r0,#30
000006  66c8              STR      r0,[r1,#0x6c]
;;;162    	HW_REG(BASE_USB|0xC4) =  HW_REG(BASE_USB|0xC4)  | BIT3;
000008  480c              LDR      r0,|L26.60|
00000a  f8501fc4          LDR      r1,[r0,#0xc4]!
00000e  f0410108          ORR      r1,r1,#8
000012  6001              STR      r1,[r0,#0]
;;;163    	//delay_ms(530); // NEC�� ���� ����
;;;164    	USB_DevInit();
000014  f7fffffe          BL       USB_DevInit
000018  2140              MOVS     r1,#0x40
00001a  f04f22e0          MOV      r2,#0xe000e000
00001e  2000              MOVS     r0,#0
000020  f8c21100          STR      r1,[r2,#0x100]
000024  1d91              ADDS     r1,r2,#6
000026  f8810400          STRB     r0,[r1,#0x400]
;;;165    
;;;166    	if(bSWreset)
;;;167    	{
;;;168    		mUsbSoftRstSet();
;;;169    		while (wFOTGPeri_Port(0x100) & BIT4);
;;;170    	}
;;;171    
;;;172    	NVIC_EnableIRQ (USB_IRQn);
;;;173    	NVIC_SetPriority(USB_IRQn, USB_IRQn_Priority);
;;;174    
;;;175    	//ETC
;;;176    	hal_PendSVHandlerInitialize();
00002a  f7fffffe          BL       hal_PendSVHandlerInitialize
;;;177    
;;;178    	I2C_Initialize();
00002e  f7fffffe          BL       I2C_Initialize
;;;179    
;;;180    	protocol_init();
000032  e8bd4010          POP      {r4,lr}
000036  f7ffbffe          B.W      protocol_init
;;;181    //	Address = I2C->I2C_DEVICE_ADD_b.I2cId; // NOTE : not used!!
;;;182    }
;;;183    
                          ENDP

00003a  0000              DCW      0x0000
                  |L26.60|
                          DCD      0x40030000

                          AREA ||i.module_RollBack_Sync||, CODE, READONLY, ALIGN=2

                  module_RollBack_Sync PROC
;;;1255   
;;;1256   bool_t module_RollBack_Sync(void) // NOTE : missing return value
000000  480b              LDR      r0,|L27.48|
;;;1257   {
;;;1258   #if USED_OPERATION_STAND_ALONE
;;;1259   	//Tsync In
;;;1260   	GPIO->tGPIO_AFIO_1._GPIO_TSYNC_IN = 0x0; // TSYNC
;;;1261   	GPIO->tGPIO_DIR_0._GPIO_TSYNC_IN = 0x1;  // output
;;;1262   	GPIO->tGPIO_PD_0._GPIO_TSYNC_IN = 0x1;  // output
;;;1263   
;;;1264   	//Vsync In
;;;1265   	GPIO->tGPIO_AFIO_1._GPIO_VSYNC = 0x0; // VSYNC
;;;1266   	GPIO->tGPIO_DIR_0._GPIO_VSYNC = 0x1;  // output
;;;1267   	GPIO->tGPIO_PD_0._GPIO_VSYNC = 0x1;  // output
;;;1268   #else /* USED_OPERATION_STAND_ALONE */
;;;1269   	//Tsync In
;;;1270   	GPIO->tGPIO_AFIO_1._GPIO_TSYNC_IN = 0x1; // TSYNC
000002  6e41              LDR      r1,[r0,#0x64]
000004  f4210140          BIC      r1,r1,#0xc00000
000008  f5010180          ADD      r1,r1,#0x400000
00000c  6641              STR      r1,[r0,#0x64]
;;;1271   	GPIO->tGPIO_DIR_0._GPIO_TSYNC_IN = 0x0;  // input
00000e  6881              LDR      r1,[r0,#8]
000010  f0216100          BIC      r1,r1,#0x8000000
000014  6081              STR      r1,[r0,#8]
;;;1272   
;;;1273   	//Vsync In
;;;1274   #if USED_NEW_TCON_BOARD
;;;1275   	GPIO->tGPIO_AFIO_1._GPIO_VSYNC = 0x0; // VSYNC
;;;1276   	GPIO->tGPIO_DIR_0._GPIO_VSYNC = 0x0;  // input
;;;1277   #else /* USED_NEW_TCON_BOARD */
;;;1278   	GPIO->tGPIO_AFIO_1._GPIO_VSYNC = 0x1; // VSYNC
000016  6e41              LDR      r1,[r0,#0x64]
000018  f4211140          BIC      r1,r1,#0x300000
00001c  f5011180          ADD      r1,r1,#0x100000
000020  6641              STR      r1,[r0,#0x64]
;;;1279   	GPIO->tGPIO_DIR_0._GPIO_VSYNC = 0x0;  // input
000022  6881              LDR      r1,[r0,#8]
000024  f0216180          BIC      r1,r1,#0x4000000
000028  6081              STR      r1,[r0,#8]
;;;1280   #endif /* USED_NEW_TCON_BOARD */
;;;1281   #endif /* USED_OPERATION_STAND_ALONE */
;;;1282   	return YES;
00002a  2001              MOVS     r0,#1
;;;1283   }
00002c  4770              BX       lr
;;;1284   
                          ENDP

00002e  0000              DCW      0x0000
                  |L27.48|
                          DCD      0x40007000

                          AREA ||i.module_Skip_Event||, CODE, READONLY, ALIGN=2

                  module_Skip_Event PROC
;;;1354   
;;;1355   bool_t module_Skip_Event(void)
000000  4803              LDR      r0,|L28.16|
000002  6840              LDR      r0,[r0,#4]
000004  f4104f00          TST      r0,#0x8000
;;;1356   {
;;;1357   	if(module_Check_TPEN())
;;;1358   	{
;;;1359   		return YES;
000008  bf0c              ITE      EQ
00000a  2001              MOVEQ    r0,#1
;;;1360   	}
;;;1361   	return NO;
00000c  2000              MOVNE    r0,#0
;;;1362   }
00000e  4770              BX       lr
;;;1363   
                          ENDP

                  |L28.16|
                          DCD      0x40007000

                          AREA ||i.module_Slv_addr_change||, CODE, READONLY, ALIGN=2

                  module_Slv_addr_change PROC
;;;185    BACKUP_INFO_TypeDef TMP_INFO;
;;;186    void module_Slv_addr_change(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;187    {
;;;188    	
;;;189    	if(BACKUP_BOOT_INFO_3->I2C_BOOT_INFO_b.I2C_SADDR != I2C_ADDRESS)
000004  f44f577c          MOV      r7,#0x3f00
000008  8838              LDRH     r0,[r7,#0]
00000a  f3c02007          UBFX     r0,r0,#8,#8
00000e  2828              CMP      r0,#0x28
;;;190    	{
;;;191    		TMP_INFO = *BACKUP_BOOT_INFO_1;
;;;192    		TMP_INFO.I2C_BOOT_INFO_b.I2C_SADDR = I2C_ADDRESS;
;;;193    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_1->I2C_BOOT_INFO, TMP_INFO.I2C_BOOT_INFO);
;;;194    		
;;;195    		TMP_INFO = *BACKUP_BOOT_INFO_2;
;;;196    		TMP_INFO.I2C_BOOT_INFO_b.I2C_SADDR = I2C_ADDRESS;
;;;197    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_2->I2C_BOOT_INFO, TMP_INFO.I2C_BOOT_INFO);
;;;198    		
;;;199    		TMP_INFO = *BACKUP_BOOT_INFO_3;
;;;200    		TMP_INFO.I2C_BOOT_INFO_b.I2C_SADDR = I2C_ADDRESS;
;;;201    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_3->I2C_BOOT_INFO, TMP_INFO.I2C_BOOT_INFO);
;;;202    	}
;;;203    }
000010  bf08              IT       EQ
000012  e8bd81f0          POPEQ    {r4-r8,pc}
000016  4d14              LDR      r5,|L29.104|
000018  f44f5178          MOV      r1,#0x3e00            ;191
00001c  f1050418          ADD      r4,r5,#0x18           ;192
000020  e9d10100          LDRD     r0,r1,[r1,#0]         ;191
000024  e9c50106          STRD     r0,r1,[r5,#0x18]      ;192
000028  2628              MOVS     r6,#0x28              ;192
00002a  7066              STRB     r6,[r4,#1]            ;192
00002c  f44f5078          MOV      r0,#0x3e00            ;193
000030  6821              LDR      r1,[r4,#0]            ;193  ; TMP_INFO
000032  f7fffffe          BL       FLASH_Write
000036  f44f517a          MOV      r1,#0x3e80            ;195
00003a  e9d10100          LDRD     r0,r1,[r1,#0]         ;195
00003e  e9c50106          STRD     r0,r1,[r5,#0x18]      ;195
000042  7066              STRB     r6,[r4,#1]            ;196
000044  f44f507a          MOV      r0,#0x3e80            ;197
000048  6821              LDR      r1,[r4,#0]            ;197  ; TMP_INFO
00004a  f7fffffe          BL       FLASH_Write
00004e  e9d70100          LDRD     r0,r1,[r7,#0]         ;197
000052  e9c50106          STRD     r0,r1,[r5,#0x18]      ;197
000056  7066              STRB     r6,[r4,#1]            ;200
000058  6821              LDR      r1,[r4,#0]            ;201  ; TMP_INFO
00005a  e8bd41f0          POP      {r4-r8,lr}            ;201
00005e  f44f507c          MOV      r0,#0x3f00            ;201
000062  f7ffbffe          B.W      FLASH_Write
;;;204    void module_boot_vidpid_change(void)
                          ENDP

000066  0000              DCW      0x0000
                  |L29.104|
                          DCD      ||.data||

                          AREA ||i.module_Smt_Mode_Enter||, CODE, READONLY, ALIGN=2

                  module_Smt_Mode_Enter PROC
;;;1312   
;;;1313   void module_Smt_Mode_Enter(void)
000000  480f              LDR      r0,|L30.64|
;;;1314   {
;;;1315   	GPIO->tGPIO_AFIO_1._GPIO_TSYNC_IN = 0x1;
000002  6e41              LDR      r1,[r0,#0x64]
000004  f4210140          BIC      r1,r1,#0xc00000
000008  f5010180          ADD      r1,r1,#0x400000
00000c  6641              STR      r1,[r0,#0x64]
;;;1316   //	GPIO->tGPIO_AFIO_2._GPIO_TSYNC_OUT = 0x1;
;;;1317   
;;;1318   	GPIO->tGPIO_AFIO_1._GPIO_PWM_SRIC = 0x0; // PWM_TX
00000e  6e41              LDR      r1,[r0,#0x64]
000010  f0217140          BIC      r1,r1,#0x3000000
000014  6641              STR      r1,[r0,#0x64]
;;;1319   	GPIO->tGPIO_DIR_0._GPIO_PWM_SRIC  = 0x1;  // output
000016  6881              LDR      r1,[r0,#8]
000018  f0415180          ORR      r1,r1,#0x10000000
00001c  6081              STR      r1,[r0,#8]
;;;1320   	GPIO->tGPIO_DATA_0._GPIO_PWM_SRIC = 0x0;
00001e  6801              LDR      r1,[r0,#0]
000020  f0215180          BIC      r1,r1,#0x10000000
000024  6001              STR      r1,[r0,#0]
;;;1321   #if USED_TEST_OPERATION_ENABLE
;;;1322   	GPIO->tGPIO_AFIO_1._GPIO_PWM_TPIC = 0x0; // LFD
;;;1323   	GPIO->tGPIO_DIR_0._GPIO_PWM_TPIC  = 0x1;  // output
;;;1324   	GPIO->tGPIO_DATA_0._GPIO_PWM_TPIC = 0x0;
;;;1325   #endif
;;;1326   	GPIO->tGPIO_AFIO_3._GPIO_TP_INTR = 0x0;
000026  6ec1              LDR      r1,[r0,#0x6c]
000028  f0210103          BIC      r1,r1,#3
00002c  66c1              STR      r1,[r0,#0x6c]
;;;1327   	GPIO->tGPIO_DIR_1._GPIO_TP_INTR = 0x1;
00002e  68c1              LDR      r1,[r0,#0xc]
000030  f4413180          ORR      r1,r1,#0x10000
000034  60c1              STR      r1,[r0,#0xc]
;;;1328   	GPIO->tGPIO_DATA_1._GPIO_TP_INTR = 0x0;
000036  6841              LDR      r1,[r0,#4]
000038  f4213180          BIC      r1,r1,#0x10000
00003c  6041              STR      r1,[r0,#4]
;;;1329   
;;;1330   //	GPIO->tGPIO_AFIO_2._GPIO_LCD_ON = 0x0;
;;;1331   //	GPIO->tGPIO_DIR_1._GPIO_LCD_ON  = 0x1;
;;;1332   //	GPIO->tGPIO_DATA_1._GPIO_LCD_ON = 0x0;
;;;1333   }
00003e  4770              BX       lr
;;;1334   #endif /* MODE_SMT */
                          ENDP

                  |L30.64|
                          DCD      0x40007000

                          AREA ||i.module_Start||, CODE, READONLY, ALIGN=1

                  module_Start PROC
;;;352    
;;;353    bool_t module_Start(void)
000000  2000              MOVS     r0,#0
;;;354    {
;;;355    	bool_t retVal = YES;
;;;356    
;;;357    	retVal = Hal_sric_start(NO);
000002  f7ffbffe          B.W      Hal_sric_start
;;;358    
;;;359    	return retVal;
;;;360    }
;;;361    
                          ENDP


                          AREA ||i.module_Stop||, CODE, READONLY, ALIGN=1

                  module_Stop PROC
;;;1217   
;;;1218   void module_Stop(void)
000000  4770              BX       lr
;;;1219   {
;;;1220   
;;;1221   }
;;;1222   
                          ENDP


                          AREA ||i.module_System_Init||, CODE, READONLY, ALIGN=1

                  module_System_Init PROC
;;;144    
;;;145    void module_System_Init(void)
000000  b510              PUSH     {r4,lr}
;;;146    {
;;;147    	SysTick_Initialize(TMCU_MAIN_TRIM_CLOCK_SPEED);
000002  2048              MOVS     r0,#0x48
000004  f7fffffe          BL       SysTick_Initialize
;;;148    	SCRB_Initialize();
000008  f7fffffe          BL       SCRB_Initialize
;;;149    	ReMapVectorTableToRam();
00000c  f7fffffe          BL       ReMapVectorTableToRam
;;;150    	GPIO_Initialize();
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      GPIO_Initialize
;;;151    #if USED_LPWG_MODE_CONTROL
;;;152    	HAL_Timer_Init();
;;;153    #endif /* USED_LPWG_MODE_CONTROL */
;;;154    }
;;;155    
                          ENDP


                          AREA ||i.module_Tsync1_SignalBypass||, CODE, READONLY, ALIGN=2

                  module_Tsync1_SignalBypass PROC
;;;1301   
;;;1302   void module_Tsync1_SignalBypass(void)
000000  b510              PUSH     {r4,lr}
;;;1303   {
;;;1304   	delay_us(500);
000002  f44f70fa          MOV      r0,#0x1f4
000006  f7fffffe          BL       delay_us
;;;1305   	GPIO->tGPIO_DATA_0._GPIO_PWM_SRIC = ~GPIO->tGPIO_DATA_0._GPIO_PWM_SRIC;
00000a  4808              LDR      r0,|L34.44|
00000c  6801              LDR      r1,[r0,#0]
00000e  ea6f7211          MVN      r2,r1,LSR #28
000012  6801              LDR      r1,[r0,#0]
000014  f362711c          BFI      r1,r2,#28,#1
000018  6001              STR      r1,[r0,#0]
;;;1306   #if USED_TEST_OPERATION_ENABLE
;;;1307   	GPIO->tGPIO_DATA_0._GPIO_PWM_TPIC = ~GPIO->tGPIO_DATA_0._GPIO_PWM_TPIC;
;;;1308   #endif
;;;1309   	GPIO->tGPIO_DATA_1._GPIO_TP_INTR = ~GPIO->tGPIO_DATA_1._GPIO_TP_INTR;
00001a  6841              LDR      r1,[r0,#4]
00001c  ea6f4211          MVN      r2,r1,LSR #16
000020  6841              LDR      r1,[r0,#4]
000022  f3624110          BFI      r1,r2,#16,#1
000026  6041              STR      r1,[r0,#4]
;;;1310   //	GPIO->tGPIO_DATA_1._GPIO_LCD_ON = ~GPIO->tGPIO_DATA_1._GPIO_LCD_ON;
;;;1311   }
000028  bd10              POP      {r4,pc}
;;;1312   
                          ENDP

00002a  0000              DCW      0x0000
                  |L34.44|
                          DCD      0x40007000

                          AREA ||i.module_Wait_LcdOn||, CODE, READONLY, ALIGN=2

                  module_Wait_LcdOn PROC
;;;1222   
;;;1223   bool_t module_Wait_LcdOn(void)
000000  b510              PUSH     {r4,lr}
;;;1224   {
;;;1225   	while(1)
;;;1226   	{
;;;1227   		if(GPIO->tGPIO_DATA_1._GPIO_LCD_ON == 0x1 || protocol_swip_GetMode() == M_TOUCH_DFUP)
000002  4c05              LDR      r4,|L35.24|
                  |L35.4|
000004  6860              LDR      r0,[r4,#4]
000006  f0100f04          TST      r0,#4
00000a  d103              BNE      |L35.20|
00000c  f7fffffe          BL       protocol_swip_GetMode
000010  2802              CMP      r0,#2
000012  d1f7              BNE      |L35.4|
                  |L35.20|
;;;1228   		{
;;;1229   			break;
;;;1230   		}
;;;1231   	}
;;;1232   	return YES;
000014  2001              MOVS     r0,#1
;;;1233   }
000016  bd10              POP      {r4,pc}
;;;1234   
                          ENDP

                  |L35.24|
                          DCD      0x40007000

                          AREA ||i.module_Watch_Enable||, CODE, READONLY, ALIGN=1

                  module_Watch_Enable PROC
;;;347    
;;;348    void module_Watch_Enable(void)
000000  f7ffbffe          B.W      Hal_WDT_Init
;;;349    {
;;;350    	Hal_WDT_Init();
;;;351    }
;;;352    
                          ENDP


                          AREA ||i.module_boot_vidpid_change||, CODE, READONLY, ALIGN=2

                  module_boot_vidpid_change PROC
;;;203    }
;;;204    void module_boot_vidpid_change(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;205    {
;;;206    	if(BACKUP_BOOT_INFO_3->VID_PID_INFO_b.VID_INFO != UNIQUE_VID/*BOOT_VID*/)
000004  f6437a04          MOV      r10,#0x3f04
;;;207    	{
;;;208    		TMP_INFO = *BACKUP_BOOT_INFO_1;
000008  4c2a              LDR      r4,|L37.180|
00000a  f8ba0000          LDRH     r0,[r10,#0]           ;206
00000e  f64176d2          MOV      r6,#0x1fd2            ;206
000012  b280              UXTH     r0,r0                 ;206
000014  f44f5978          MOV      r9,#0x3e00
;;;209    		TMP_INFO.VID_PID_INFO_b.VID_INFO = UNIQUE_VID/*BOOT_VID*/;
000018  f1040518          ADD      r5,r4,#0x18
;;;210    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_1->VID_PID_INFO, TMP_INFO.VID_PID_INFO);
;;;211    		
;;;212    		TMP_INFO = *BACKUP_BOOT_INFO_2;
00001c  f44f577a          MOV      r7,#0x3e80
;;;213    		TMP_INFO.VID_PID_INFO_b.VID_INFO = UNIQUE_VID/*BOOT_VID*/;
;;;214    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_2->VID_PID_INFO, TMP_INFO.VID_PID_INFO);
;;;215    		
;;;216    		TMP_INFO = *BACKUP_BOOT_INFO_3;
000020  f44f587c          MOV      r8,#0x3f00
000024  42b0              CMP      r0,r6                 ;206
000026  d01c              BEQ      |L37.98|
000028  e9d90100          LDRD     r0,r1,[r9,#0]         ;205
00002c  e9c40106          STRD     r0,r1,[r4,#0x18]      ;205
000030  80ae              STRH     r6,[r5,#4]            ;209
000032  f6436004          MOV      r0,#0x3e04            ;210
000036  6869              LDR      r1,[r5,#4]            ;210  ; TMP_INFO
000038  f7fffffe          BL       FLASH_Write
00003c  e9d70100          LDRD     r0,r1,[r7,#0]         ;210
000040  e9c40106          STRD     r0,r1,[r4,#0x18]      ;210
000044  80ae              STRH     r6,[r5,#4]            ;213
000046  1d38              ADDS     r0,r7,#4              ;214
000048  6869              LDR      r1,[r5,#4]            ;214  ; TMP_INFO
00004a  f7fffffe          BL       FLASH_Write
00004e  e9d80100          LDRD     r0,r1,[r8,#0]         ;214
000052  e9c40106          STRD     r0,r1,[r4,#0x18]      ;214
;;;217    		TMP_INFO.VID_PID_INFO_b.VID_INFO = UNIQUE_VID/*BOOT_VID*/;
000056  80ae              STRH     r6,[r5,#4]
;;;218    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_3->VID_PID_INFO, TMP_INFO.VID_PID_INFO);	
000058  f6437004          MOV      r0,#0x3f04
00005c  6869              LDR      r1,[r5,#4]  ; TMP_INFO
00005e  f7fffffe          BL       FLASH_Write
                  |L37.98|
;;;219    	}
;;;220    
;;;221    	if(BACKUP_BOOT_INFO_3->VID_PID_INFO_b.PID_INFO != UNIQUE_APP_PID/*BOOT_PID*/)
000062  f8da0000          LDR      r0,[r10,#0]
000066  f24d1601          MOV      r6,#0xd101
00006a  ebb64f10          CMP      r6,r0,LSR #16
;;;222    	{
;;;223    		TMP_INFO = *BACKUP_BOOT_INFO_1;
;;;224    		TMP_INFO.VID_PID_INFO_b.PID_INFO = UNIQUE_APP_PID/*BOOT_PID*/;
;;;225    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_1->VID_PID_INFO, TMP_INFO.VID_PID_INFO);
;;;226    		
;;;227    		TMP_INFO = *BACKUP_BOOT_INFO_2;
;;;228    		TMP_INFO.VID_PID_INFO_b.PID_INFO = UNIQUE_APP_PID/*BOOT_PID*/;
;;;229    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_2->VID_PID_INFO, TMP_INFO.VID_PID_INFO);
;;;230    		
;;;231    		TMP_INFO = *BACKUP_BOOT_INFO_3;
;;;232    		TMP_INFO.VID_PID_INFO_b.PID_INFO = UNIQUE_APP_PID/*BOOT_PID*/;
;;;233    		FLASH_Write((uint32_t)&BACKUP_BOOT_INFO_3->VID_PID_INFO, TMP_INFO.VID_PID_INFO);	
;;;234    	}
;;;235    }
00006e  bf08              IT       EQ
000070  e8bd87f0          POPEQ    {r4-r10,pc}
000074  e9d90100          LDRD     r0,r1,[r9,#0]
000078  e9c40106          STRD     r0,r1,[r4,#0x18]
00007c  80ee              STRH     r6,[r5,#6]            ;224
00007e  f6436004          MOV      r0,#0x3e04            ;225
000082  6869              LDR      r1,[r5,#4]            ;225  ; TMP_INFO
000084  f7fffffe          BL       FLASH_Write
000088  e9d70100          LDRD     r0,r1,[r7,#0]         ;225
00008c  e9c40106          STRD     r0,r1,[r4,#0x18]      ;225
000090  80ee              STRH     r6,[r5,#6]            ;228
000092  f6436084          MOV      r0,#0x3e84            ;229
000096  6869              LDR      r1,[r5,#4]            ;229  ; TMP_INFO
000098  f7fffffe          BL       FLASH_Write
00009c  e9d80100          LDRD     r0,r1,[r8,#0]         ;229
0000a0  e9c40106          STRD     r0,r1,[r4,#0x18]      ;229
0000a4  80ee              STRH     r6,[r5,#6]            ;232
0000a6  6869              LDR      r1,[r5,#4]            ;233  ; TMP_INFO
0000a8  e8bd47f0          POP      {r4-r10,lr}           ;233
0000ac  f6437004          MOV      r0,#0x3f04            ;233
0000b0  f7ffbffe          B.W      FLASH_Write
;;;236    #endif /* (USE_BOOTLOADER_16KB) */
                          ENDP

                  |L37.180|
                          DCD      ||.data||

                          AREA ||i.module_data_check||, CODE, READONLY, ALIGN=2

                  module_data_check PROC
;;;522    
;;;523    void module_data_check(uint16_t lPenCoordRawdata)
000000  2200              MOVS     r2,#0
;;;524    {
;;;525      static int ResetFlagCnt = 0;
;;;526    	if(lPenCoordRawdata > 1 )
;;;527    	{
;;;528    		ResetFlagCnt++;
000002  4906              LDR      r1,|L38.28|
000004  2801              CMP      r0,#1                 ;526
;;;529    	}
;;;530    	else
;;;531    	{
;;;532    		ResetFlagCnt = 0;
000006  bf9c              ITT      LS
000008  60ca              STRLS    r2,[r1,#0xc]  ; ResetFlagCnt
;;;533    	}
;;;534    
;;;535    	if(ResetFlagCnt == 8 )
;;;536    	{
;;;537    		ResetFlagCnt = 0;
;;;538    		while(1);
;;;539    	}
;;;540    }
00000a  4770              BXLS     lr
00000c  68c8              LDR      r0,[r1,#0xc]          ;528  ; ResetFlagCnt
00000e  1c40              ADDS     r0,r0,#1              ;528
000010  60c8              STR      r0,[r1,#0xc]          ;535  ; ResetFlagCnt
000012  2808              CMP      r0,#8                 ;535
000014  bf0c              ITE      EQ                    ;537
000016  60ca              STREQ    r2,[r1,#0xc]          ;537  ; ResetFlagCnt
000018  4770              BXNE     lr
                  |L38.26|
00001a  e7fe              B        |L38.26|
;;;541    
                          ENDP

                  |L38.28|
                          DCD      ||.data||

                          AREA ||i.module_read_full_sample_data||, CODE, READONLY, ALIGN=2

                  module_read_full_sample_data PROC
;;;392    #endif /* (USED_NORMAL_NI_SENSING || USED_IDLE_MODE_CONTROL) */
;;;393    void module_read_full_sample_data(void)
000000  b4f8              PUSH     {r3-r7}
;;;394    {
;;;395    	int c, r;
;;;396    	int width = COL_MAX;
;;;397    	int height = ROW_MAX;
;;;398    	volatile unsigned long uiBaseAddr = BASE_MSPI_SRAM;
000002  4814              LDR      r0,|L39.84|
;;;399    #if USED_NORMAL_NI_SENSING
;;;400    	volatile unsigned long uiNi1BaseAddr = BASE_MSPI_SRAM + 0x3E8;
;;;401    #endif /* USED_NORMAL_NI_SENSING */
;;;402    
;;;403    #if USED_ESD_RECOVERY_CODE
;;;404    	uint16_t MinData = 8190;
;;;405    	uint8_t  AbnormalDataIdx = 0;
;;;406    	uint8_t  bAbnormalDataFlag = NO;
;;;407    	sptAlgorithmInfo->usAbnormalRawdataNodeCnt = 0;
;;;408    #endif /* USED_ESD_RECOVERY_CODE */
;;;409    
;;;410    	tHalIntrHandle.ulFrameCnt++;
000004  9000              STR      r0,[sp,#0]
000006  4814              LDR      r0,|L39.88|
000008  69c1              LDR      r1,[r0,#0x1c]  ; tHalIntrHandle
00000a  1c49              ADDS     r1,r1,#1
00000c  61c1              STR      r1,[r0,#0x1c]  ; tHalIntrHandle
;;;411    
;;;412    	for (r = 0; r < height; ++r)
;;;413    	{
;;;414    		for (c = 0; c < width; ++c)
;;;415    		{
;;;416    			HAL_WRITE_RAW_IMAGE(r, c, *((volatile unsigned short * )((thisFixedConf->ulFullSensing_Remap_Table[r][c] + uiBaseAddr))));
00000e  4813              LDR      r0,|L39.92|
000010  4e13              LDR      r6,|L39.96|
000012  2100              MOVS     r1,#0                 ;412
000014  6885              LDR      r5,[r0,#8]  ; thisFixedConf
                  |L39.22|
000016  eb010241          ADD      r2,r1,r1,LSL #1
00001a  2000              MOVS     r0,#0                 ;414
00001c  eb061c82          ADD      r12,r6,r2,LSL #6
000020  eb051382          ADD      r3,r5,r2,LSL #6
                  |L39.36|
000024  eb030240          ADD      r2,r3,r0,LSL #1
000028  9f00              LDR      r7,[sp,#0]
00002a  8814              LDRH     r4,[r2,#0]
00002c  5be7              LDRH     r7,[r4,r7]
00002e  eb0c0440          ADD      r4,r12,r0,LSL #1
000032  f5043480          ADD      r4,r4,#0x10000
000036  f8a47294          STRH     r7,[r4,#0x294]
00003a  8852              LDRH     r2,[r2,#2]
00003c  9f00              LDR      r7,[sp,#0]
00003e  5bd2              LDRH     r2,[r2,r7]
000040  1c80              ADDS     r0,r0,#2
000042  f8a42296          STRH     r2,[r4,#0x296]
000046  2860              CMP      r0,#0x60
000048  dbec              BLT      |L39.36|
00004a  1c49              ADDS     r1,r1,#1
00004c  2930              CMP      r1,#0x30
00004e  dbe2              BLT      |L39.22|
;;;417    
;;;418    			//HAL_WRITE_RAW_IMAGE(r, c, (HAL_READ_RAW_IMAGE(r, c) * 2));
;;;419    
;;;420    #if USED_ESD_RECOVERY_CODE
;;;421    			if(HAL_READ_RAW_IMAGE(r, c) == 4095)
;;;422    			{
;;;423    				if(sptAlgorithmInfo->usAbnormalRawdataFrameCnt1 == 0)
;;;424    				{
;;;425    					if(sptAlgorithmInfo->usAbnormalRawdataNodeCnt < ABNORMAL_RAWDATA_CNT_THD)
;;;426    					{
;;;427    						AbnormalDataXY[sptAlgorithmInfo->usAbnormalRawdataNodeCnt].x = c;
;;;428    						AbnormalDataXY[sptAlgorithmInfo->usAbnormalRawdataNodeCnt].y = r;		
;;;429    						AbnormalDataFlag[sptAlgorithmInfo->usAbnormalRawdataNodeCnt] = YES;
;;;430    					}
;;;431    				}	
;;;432    				sptAlgorithmInfo->usAbnormalRawdataNodeCnt++;
;;;433    			}
;;;434    			if(MinData > HAL_READ_RAW_IMAGE(r, c))
;;;435    			{
;;;436    				MinData = HAL_READ_RAW_IMAGE(r, c);
;;;437    			}
;;;438    #endif /* USED_ESD_RECOVERY_CODE */ 
;;;439    		}
;;;440    	}
;;;441    
;;;442    #if USED_ESD_RECOVERY_CODE
;;;443    	if(sptAlgorithmInfo->usAbnormalRawdataNodeCnt == 0)
;;;444    	{
;;;445    		sptAlgorithmInfo->usAbnormalRawdataFrameCnt1 = 0;
;;;446    	}
;;;447    	else if(sptAlgorithmInfo->usAbnormalRawdataFrameCnt1 == 0)
;;;448    	{
;;;449    		sptAlgorithmInfo->usAbnormalRawdataFrameCnt1++;
;;;450    		sptAlgorithmInfo->usAbnormalRawdataNodeNum = sptAlgorithmInfo->usAbnormalRawdataNodeCnt;
;;;451    	}
;;;452    	else
;;;453    	{
;;;454    		for(AbnormalDataIdx = 0; AbnormalDataIdx < sptAlgorithmInfo->usAbnormalRawdataNodeNum; AbnormalDataIdx++)
;;;455    		{
;;;456    			if(AbnormalDataFlag[AbnormalDataIdx] == YES)
;;;457    			{
;;;458    				if(HAL_READ_RAW_IMAGE(AbnormalDataXY[AbnormalDataIdx].y, AbnormalDataXY[AbnormalDataIdx].x) == 4095)
;;;459    				{
;;;460    					bAbnormalDataFlag = YES;
;;;461    				}
;;;462    				else
;;;463    				{
;;;464    					AbnormalDataFlag[AbnormalDataIdx] = NO;
;;;465    				}
;;;466    			}
;;;467    		}
;;;468    		if(bAbnormalDataFlag == YES)
;;;469    		{
;;;470    			sptAlgorithmInfo->usAbnormalRawdataFrameCnt1++;
;;;471    		}
;;;472    		else
;;;473    		{
;;;474    			sptAlgorithmInfo->usAbnormalRawdataFrameCnt1 = 0;
;;;475    		}
;;;476    	}
;;;477    	
;;;478    	if(MinData < MINRAWDATA_MARGIN)
;;;479    	{
;;;480    		sptAlgorithmInfo->usAbnormalRawdataFrameCnt2++;
;;;481    	}
;;;482    	else
;;;483    	{
;;;484    		sptAlgorithmInfo->usAbnormalRawdataFrameCnt2 = 0;
;;;485    	}
;;;486    #endif /* USED_ESD_RECOVERY_CODE */ 	
;;;487    	
;;;488    #if USED_POOR_PANEL_COLLINE_DISABLE
;;;489    	HAL_WRITE_RAW_IMAGE(39, 0, HAL_READ_RAW_IMAGE(38, 0));
;;;490    #endif /* USED_POOR_PANEL_COLLINE_DISABLE */
;;;491    
;;;492    #if USED_NORMAL_NI_SENSING
;;;493    	height = NI_ROW_MAX;
;;;494    	for (r = 0; r < height; ++r)
;;;495    	{
;;;496    		for (c = 0; c < width; ++c)
;;;497    		{
;;;498    			HAL_NI_WRITE_RAW_IMAGE(r, c, *((volatile unsigned short * )((thisFixedConf->ulFullSensing_Remap_Table[g_vulNiRowIdx[r]][c] + uiNi1BaseAddr))));
;;;499    		}
;;;500    	}
;;;501    #endif /* USED_NORMAL_NI_SENSING */
;;;502    }
000050  bcf8              POP      {r3-r7}
000052  4770              BX       lr
;;;503    
                          ENDP

                  |L39.84|
                          DCD      0x20020000
                  |L39.88|
                          DCD      tHalIntrHandle
                  |L39.92|
                          DCD      ||.data||
                  |L39.96|
                          DCD      FullSharedBuff

                          AREA ||i.module_start_delay||, CODE, READONLY, ALIGN=2

                  module_start_delay PROC
;;;1186   extern __IO bool_t wdt_init;
;;;1187   void module_start_delay(void)
000000  b510              PUSH     {r4,lr}
000002  4c19              LDR      r4,|L40.104|
000004  6860              LDR      r0,[r4,#4]
000006  f0100f04          TST      r0,#4
;;;1188   {
00000a  d118              BNE      |L40.62|
00000c  f7fffffe          BL       Hal_VccOff_State
;;;1189   	int i;	
;;;1190   #if USED_LPWG_MODE_CONTROL
;;;1191   	if(module_Check_LcdOn(NO) == NO)
;;;1192   	{
;;;1193   		delay_ms(100);
;;;1194   		return;
;;;1195   	}
;;;1196   #else
;;;1197   	if(module_Check_LcdOn(YES) == NO)
;;;1198   	{ 
;;;1199   		while(GPIO->tGPIO_DATA_1._GPIO_LCD_ON == 0x0)
000010  6860              LDR      r0,[r4,#4]
000012  f0100f04          TST      r0,#4
000016  d108              BNE      |L40.42|
                  |L40.24|
;;;1200   		{
;;;1201   			__WFI();
000018  bf30              WFI      
;;;1202   			if(protocol_swip_GetMode() == M_TOUCH_DFUP)	break;
00001a  f7fffffe          BL       protocol_swip_GetMode
00001e  2802              CMP      r0,#2
000020  d003              BEQ      |L40.42|
000022  6860              LDR      r0,[r4,#4]
000024  f0100f04          TST      r0,#4
000028  d0f6              BEQ      |L40.24|
                  |L40.42|
;;;1203   		}
;;;1204   		initECLK();
00002a  f7fffffe          BL       initECLK
00002e  68e0              LDR      r0,[r4,#0xc]
000030  f4204000          BIC      r0,r0,#0x8000
000034  60e0              STR      r0,[r4,#0xc]
000036  6ea0              LDR      r0,[r4,#0x68]
000038  f0204040          BIC      r0,r0,#0xc0000000
00003c  66a0              STR      r0,[r4,#0x68]
                  |L40.62|
;;;1205   		module_Init_TPEN();  
;;;1206   	}
;;;1207   #endif /* USED_LPWG_MODE_CONTROL */
;;;1208   
;;;1209   	GPIO->tGPIO_DIR_0._GPIO_VSYNC = 0x0;	// Input
00003e  68a0              LDR      r0,[r4,#8]
000040  f0206080          BIC      r0,r0,#0x4000000
000044  60a0              STR      r0,[r4,#8]
;;;1210   	GPIO->tGPIO_AFIO_1._GPIO_VSYNC = 0x0;	// VSYNC
000046  6e60              LDR      r0,[r4,#0x64]
000048  f4201040          BIC      r0,r0,#0x300000
00004c  6660              STR      r0,[r4,#0x64]
;;;1211   	
;;;1212   	for(i=0; i<10; i++)
00004e  2100              MOVS     r1,#0
                  |L40.80|
;;;1213   	{
;;;1214   		waitVsyncFalling();
000050  6820              LDR      r0,[r4,#0]
000052  f0106f80          TST      r0,#0x4000000
000056  d0fb              BEQ      |L40.80|
                  |L40.88|
000058  6820              LDR      r0,[r4,#0]
00005a  f0106f80          TST      r0,#0x4000000
00005e  d1fb              BNE      |L40.88|
000060  1c49              ADDS     r1,r1,#1
000062  290a              CMP      r1,#0xa
000064  dbf4              BLT      |L40.80|
;;;1215   	}
;;;1216   }
000066  bd10              POP      {r4,pc}
;;;1217   
                          ENDP

                  |L40.104|
                          DCD      0x40007000

                          AREA ||i.module_wait_Vsync_signal||, CODE, READONLY, ALIGN=2

                  module_wait_Vsync_signal PROC
;;;1119   
;;;1120   void module_wait_Vsync_signal(eSensingMode_t _mode, int _waitCnt)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1121   {
;;;1122       int gDiscardFrameCnt = 0;
000004  2500              MOVS     r5,#0
000006  4e46              LDR      r6,|L41.288|
000008  4f46              LDR      r7,|L41.292|
00000a  4688              MOV      r8,r1                 ;1121
00000c  4681              MOV      r9,r0                 ;1121
00000e  462c              MOV      r4,r5                 ;1121
                  |L41.16|
;;;1123   	while(1)
;;;1124   	{
;;;1125   		if(_mode == LOCAL_MODE)
000010  f1b90f01          CMP      r9,#1
000014  bf04              ITT      EQ
000016  4844              LDREQ    r0,|L41.296|
000018  f1a00a10          SUBEQ    r10,r0,#0x10
00001c  d035              BEQ      |L41.138|
00001e  f04f0a01          MOV      r10,#1
000022  f7fffffe          BL       HAL_GetSensingMode
000026  4840              LDR      r0,|L41.296|
000028  4a40              LDR      r2,|L41.300|
00002a  f1a00110          SUB      r1,r0,#0x10
                  |L41.46|
00002e  7843              LDRB     r3,[r0,#1]
000030  2b00              CMP      r3,#0
000032  d042              BEQ      |L41.186|
000034  7044              STRB     r4,[r0,#1]
000036  483e              LDR      r0,|L41.304|
000038  9000              STR      r0,[sp,#0]
00003a  69f8              LDR      r0,[r7,#0x1c]  ; tHalIntrHandle
00003c  1c40              ADDS     r0,r0,#1
00003e  61f8              STR      r0,[r7,#0x1c]  ; tHalIntrHandle
000040  f8d1e008          LDR      lr,[r1,#8]  ; thisFixedConf
000044  2000              MOVS     r0,#0
                  |L41.70|
000046  eb000140          ADD      r1,r0,r0,LSL #1
00004a  2200              MOVS     r2,#0
00004c  eb061a81          ADD      r10,r6,r1,LSL #6
000050  eb0e1c81          ADD      r12,lr,r1,LSL #6
                  |L41.84|
000054  eb0c0142          ADD      r1,r12,r2,LSL #1
000058  f8ddb000          LDR      r11,[sp,#0]
00005c  880b              LDRH     r3,[r1,#0]
00005e  f833b00b          LDRH     r11,[r3,r11]
000062  eb0a0342          ADD      r3,r10,r2,LSL #1
000066  f5033380          ADD      r3,r3,#0x10000
00006a  f8a3b294          STRH     r11,[r3,#0x294]
00006e  8849              LDRH     r1,[r1,#2]
000070  f8ddb000          LDR      r11,[sp,#0]
000074  f831100b          LDRH     r1,[r1,r11]
000078  1c92              ADDS     r2,r2,#2
00007a  f8a31296          STRH     r1,[r3,#0x296]
00007e  2a60              CMP      r2,#0x60
000080  dbe8              BLT      |L41.84|
000082  1c40              ADDS     r0,r0,#1
000084  2830              CMP      r0,#0x30
000086  dbde              BLT      |L41.70|
000088  e02e              B        |L41.232|
                  |L41.138|
00008a  78c1              LDRB     r1,[r0,#3]
00008c  b129              CBZ      r1,|L41.154|
00008e  70c4              STRB     r4,[r0,#3]
000090  f89a0002          LDRB     r0,[r10,#2]  ; gLocalTypeFlag
000094  f88a4002          STRB     r4,[r10,#2]
000098  e00b              B        |L41.178|
                  |L41.154|
00009a  7841              LDRB     r1,[r0,#1]
00009c  2900              CMP      r1,#0
00009e  bf18              IT       NE
0000a0  7044              STRBNE   r4,[r0,#1]
0000a2  f89a1005          LDRB     r1,[r10,#5]  ; sLCheckVCC
0000a6  2900              CMP      r1,#0
0000a8  d1ef              BNE      |L41.138|
0000aa  f7fffffe          BL       Hal_VccOff_State
0000ae  f7fffffe          BL       SensingBufferInit
                  |L41.178|
0000b2  2001              MOVS     r0,#1
0000b4  f88a0005          STRB     r0,[r10,#5]
;;;1126   		{
;;;1127   			module_wait_local_sample_done();
0000b8  e016              B        |L41.232|
                  |L41.186|
0000ba  7883              LDRB     r3,[r0,#2]
0000bc  2b00              CMP      r3,#0
0000be  bf18              IT       NE
0000c0  7084              STRBNE   r4,[r0,#2]
0000c2  78c3              LDRB     r3,[r0,#3]
0000c4  2b00              CMP      r3,#0
0000c6  bf18              IT       NE
0000c8  70c4              STRBNE   r4,[r0,#3]
0000ca  f1ba0f00          CMP      r10,#0
0000ce  d015              BEQ      |L41.252|
0000d0  6853              LDR      r3,[r2,#4]
0000d2  f0130f04          TST      r3,#4
0000d6  bf0c              ITE      EQ
0000d8  f04f0a00          MOVEQ    r10,#0
0000dc  f04f0a01          MOVNE    r10,#1
0000e0  bf30              WFI      
0000e2  790b              LDRB     r3,[r1,#4]  ; RESET_FLAG
0000e4  2b01              CMP      r3,#1
0000e6  d1a2              BNE      |L41.46|
                  |L41.232|
;;;1128   		}
;;;1129   		else
;;;1130   		{
;;;1131   			module_wait_full_sample_done();
;;;1132   		}
;;;1133   
;;;1134   		if(tHalIntrHandle.ulVSyncFlag)
0000e8  68b8              LDR      r0,[r7,#8]  ; tHalIntrHandle
0000ea  2800              CMP      r0,#0
0000ec  d090              BEQ      |L41.16|
;;;1135   		{
;;;1136   			tHalIntrHandle.ulVSyncFlag = 0;
0000ee  60bc              STR      r4,[r7,#8]  ; tHalIntrHandle
;;;1137   
;;;1138   			if(gDiscardFrameCnt == _waitCnt)
0000f0  4545              CMP      r5,r8
0000f2  bf18              IT       NE
0000f4  1c6d              ADDNE    r5,r5,#1
0000f6  d18b              BNE      |L41.16|
;;;1139   			{
;;;1140   				gDiscardFrameCnt = 0;
;;;1141   				break;
;;;1142   			}
;;;1143   			else
;;;1144   			{
;;;1145   				gDiscardFrameCnt++;
;;;1146   			}
;;;1147   		}
;;;1148   	}
;;;1149   }
0000f8  e8bd8ff8          POP      {r3-r11,pc}
                  |L41.252|
0000fc  f7fffffe          BL       MSPI_Set_TLPMODE
000100  2000              MOVS     r0,#0
000102  f7fffffe          BL       MSPI_ITConfig
000106  2000              MOVS     r0,#0
000108  f7fffffe          BL       PWMDRV_ITConfig
00010c  2000              MOVS     r0,#0
00010e  f7fffffe          BL       MSPI_Cmd
000112  2000              MOVS     r0,#0
000114  f7fffffe          BL       PWMDRV_Cmd
000118  f7fffffe          BL       SensingBufferInit
00011c  e7e4              B        |L41.232|
;;;1150   #if USED_NOISE_HOPPING_FREQ	
                          ENDP

00011e  0000              DCW      0x0000
                  |L41.288|
                          DCD      FullSharedBuff
                  |L41.292|
                          DCD      tHalIntrHandle
                  |L41.296|
                          DCD      ||.data||+0x10
                  |L41.300|
                          DCD      0x40007000
                  |L41.304|
                          DCD      0x20020000

                          AREA ||i.module_wait_full_sample_done||, CODE, READONLY, ALIGN=2

                  module_wait_full_sample_done PROC
;;;823    
;;;824    bool_t module_wait_full_sample_done(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;825    {
;;;826    	bool_t sCheckVCC = YES;
000004  2401              MOVS     r4,#1
;;;827    	bool_t bLocalSample = YES;
000006  4625              MOV      r5,r4
;;;828    	eSENSING_MODE_t eSensingMode;
;;;829    	eSensingMode = HAL_GetSensingMode();
000008  f7fffffe          BL       HAL_GetSensingMode
00000c  482e              LDR      r0,|L42.200|
;;;830    
;;;831    	while(YES)
;;;832    	{
;;;833    		if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
;;;834    		{
;;;835    			hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;836    			module_read_full_sample_data();
;;;837    			break;
;;;838    		}
;;;839    
;;;840    		if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE_NI))
;;;841    		{
;;;842    			hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE_NI);
;;;843    		}
;;;844    
;;;845    		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
;;;846    		{
;;;847    			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;848    		}
;;;849    
;;;850    #if USED_LPWG_MODE_CONTROL
;;;851    		if(module_Check_LcdOn(NO) == NO && (IS_ACTIVE_MODE(eSensingMode) || IS_IDLE_MODE(eSensingMode)))
;;;852    		{
;;;853    			NVIC_DisableIRQ(EXTI0_IRQn);
;;;854    			NVIC_DisableIRQ(EXTI1_IRQn);
;;;855    			MSPI_ITConfig(DISABLE);
;;;856    			PWMDRV_ITConfig(DISABLE);
;;;857    			MSPI_Cmd(DISABLE);
;;;858    			PWMDRV_Cmd(DISABLE);
;;;859    
;;;860    			HAL_SetTPICMuxEnControl(NO);
;;;861    			GPIO->tGPIO_DATA_1._GPIO_TPIC_MUX_EN = 0x0;
;;;862    			HAL_SetSensingChangeMode(SM_CHANGE_LPWG_MODE);
;;;863    			
;;;864    			GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x0;
;;;865    			GPIO->tGPIO_DIR_1._GPIO_TSYNC_OUT  = 0x1;
;;;866    			GPIO->tGPIO_AFIO_2._GPIO_TSYNC_OUT = 0x0;
;;;867    
;;;868    			GPIO->tGPIO_DATA_1._GPIO_SLEEP_RST = 0x0;
;;;869    			HAL_Timer_Set_Count_us(TIM_Channel_0, 30000);
;;;870    			HAL_Timer_Enable(TIM_Channel_0, ENABLE);
;;;871    
;;;872    #if (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405)
;;;873    			delay_us(10000);
;;;874    			if(module_Check_LcdOn(NO) == NO)
;;;875    			{
;;;876    				GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x0;
;;;877    				GPIO->tGPIO_DIR_1._GPIO_TSYNC_OUT  = 0x1;
;;;878    				GPIO->tGPIO_AFIO_2._GPIO_TSYNC_OUT = 0x0;
;;;879    				
;;;880    				GPIO->tGPIO_DATA_1._GPIO_SLEEP_RST = 0x0;
;;;881    				HAL_Timer_Set_Count_us(TIM_Channel_0, 30000);
;;;882    				HAL_Timer_Enable(TIM_Channel_0, ENABLE);
;;;883    			}
;;;884    			else
;;;885    			{
;;;886    				HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
;;;887    			}
;;;888    #endif /* (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405) */
;;;889    			return NO;
;;;890    		}
;;;891    		else if(module_Check_LcdOn(NO) == YES && IS_LPWG_MODE(eSensingMode))
;;;892    		{
;;;893    			NVIC_DisableIRQ(EXTI0_IRQn);
;;;894    			NVIC_DisableIRQ(EXTI1_IRQn);
;;;895    			MSPI_ITConfig(DISABLE);
;;;896    			PWMDRV_ITConfig(DISABLE);
;;;897    			MSPI_Cmd(DISABLE);
;;;898    			PWMDRV_Cmd(DISABLE);
;;;899    
;;;900    			HAL_SetTPICMuxEnControl(NO);
;;;901    			GPIO->tGPIO_DATA_1._GPIO_TPIC_MUX_EN = 0x0;
;;;902    			HAL_Timer_Enable(TIM_Channel_0, DISABLE);
;;;903    			HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
;;;904    			return NO;
;;;905    		}
;;;906    #else /* USED_LPWG_MODE_CONTROL */
;;;907    		if(sCheckVCC)
;;;908    		{
;;;909    			if(GPIO->tGPIO_DATA_1._GPIO_LCD_ON == 0x0)
00000e  f8dfc0bc          LDR      r12,|L42.204|
000012  2200              MOVS     r2,#0                 ;829
000014  f1a00310          SUB      r3,r0,#0x10           ;829
                  |L42.24|
000018  7841              LDRB     r1,[r0,#1]            ;829
00001a  b361              CBZ      r1,|L42.118|
00001c  7042              STRB     r2,[r0,#1]            ;833
00001e  482c              LDR      r0,|L42.208|
000020  9000              STR      r0,[sp,#0]            ;833
000022  482c              LDR      r0,|L42.212|
000024  69c1              LDR      r1,[r0,#0x1c]         ;833  ; tHalIntrHandle
000026  1c49              ADDS     r1,r1,#1              ;833
000028  61c1              STR      r1,[r0,#0x1c]         ;833  ; tHalIntrHandle
00002a  4f2b              LDR      r7,|L42.216|
00002c  689e              LDR      r6,[r3,#8]            ;833  ; thisFixedConf
00002e  2000              MOVS     r0,#0                 ;833
                  |L42.48|
000030  eb000240          ADD      r2,r0,r0,LSL #1       ;833
000034  2100              MOVS     r1,#0                 ;833
000036  eb071c82          ADD      r12,r7,r2,LSL #6      ;833
00003a  eb061382          ADD      r3,r6,r2,LSL #6       ;833
00003e  bf00              NOP                            ;833
                  |L42.64|
000040  eb030241          ADD      r2,r3,r1,LSL #1       ;833
000044  f8dd8000          LDR      r8,[sp,#0]            ;833
000048  8814              LDRH     r4,[r2,#0]            ;833
00004a  f8348008          LDRH     r8,[r4,r8]            ;833
00004e  eb0c0441          ADD      r4,r12,r1,LSL #1      ;833
000052  f5043480          ADD      r4,r4,#0x10000        ;833
000056  f8a48294          STRH     r8,[r4,#0x294]        ;833
00005a  8852              LDRH     r2,[r2,#2]            ;833
00005c  f8dd8000          LDR      r8,[sp,#0]            ;833
000060  f8322008          LDRH     r2,[r2,r8]            ;833
000064  1c89              ADDS     r1,r1,#2              ;833
000066  f8a42296          STRH     r2,[r4,#0x296]        ;833
00006a  2960              CMP      r1,#0x60              ;833
00006c  dbe8              BLT      |L42.64|
00006e  1c40              ADDS     r0,r0,#1              ;833
000070  2830              CMP      r0,#0x30              ;833
000072  dbdd              BLT      |L42.48|
000074  e013              B        |L42.158|
                  |L42.118|
000076  7881              LDRB     r1,[r0,#2]            ;833
000078  2900              CMP      r1,#0                 ;840
00007a  bf18              IT       NE                    ;840
00007c  7082              STRBNE   r2,[r0,#2]            ;840
00007e  78c1              LDRB     r1,[r0,#3]            ;840
000080  2900              CMP      r1,#0                 ;845
000082  bf18              IT       NE                    ;845
000084  70c2              STRBNE   r2,[r0,#3]            ;845
000086  b16c              CBZ      r4,|L42.164|
000088  f8dc1004          LDR      r1,[r12,#4]
00008c  f0110f04          TST      r1,#4
;;;910    			{
;;;911    				sCheckVCC = NO;
000090  bf0c              ITE      EQ
000092  2400              MOVEQ    r4,#0
;;;912    			}
;;;913    			else
;;;914    			{
;;;915    				sCheckVCC = YES;
000094  2401              MOVNE    r4,#1
;;;916    			}
;;;917    		}
;;;918    		else
;;;919    		{
;;;920    			bLocalSample = NO;
;;;921    			MSPI_Set_TLPMODE();
;;;922    			MSPI_ITConfig(DISABLE);
;;;923    			PWMDRV_ITConfig(DISABLE);
;;;924    			MSPI_Cmd(DISABLE);
;;;925    			PWMDRV_Cmd(DISABLE);
;;;926    			SensingBufferInit();
;;;927    			break;
;;;928    		}
;;;929    #endif /* USED_LPWG_MODE_CONTROL */
;;;930    
;;;931    #if USED_LPWG_MCU_SLEEP
;;;932    		Hal_WaitSampleDoneSleep();
;;;933    
;;;934    		if(GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT == 1)
;;;935    		{
;;;936    			if(IS_S3_MODE(eSensingMode) &&
;;;937    					IS_IDLE_MODE(eSensingMode) &&
;;;938    					!protocol_swip_GetEventIntrType())
;;;939    			{
;;;940    				Hal_WaitSampleDoneSleep();
;;;941    	//			__WFI();
;;;942    			}
;;;943    		}
;;;944    #else /* USED_LPWG_MCU_SLEEP */
;;;945    		__WFI();
000096  bf30              WFI      
;;;946    #endif /* USED_LPWG_MCU_SLEEP */
;;;947    //		if(FLAG_30Hz==1)
;;;948    //			break;
;;;949    				
;;;950    		if(RESET_FLAG == 1)
000098  7919              LDRB     r1,[r3,#4]  ; RESET_FLAG
00009a  2901              CMP      r1,#1
00009c  d1bc              BNE      |L42.24|
                  |L42.158|
;;;951    			break;
;;;952    //		if(FLAG_30Hz == 0)
;;;953    //			break;
;;;954    	}
;;;955    
;;;956    	return bLocalSample;
00009e  4628              MOV      r0,r5
;;;957    }
0000a0  e8bd83f8          POP      {r3-r9,pc}
                  |L42.164|
0000a4  2500              MOVS     r5,#0                 ;920
0000a6  f7fffffe          BL       MSPI_Set_TLPMODE
0000aa  2000              MOVS     r0,#0                 ;922
0000ac  f7fffffe          BL       MSPI_ITConfig
0000b0  2000              MOVS     r0,#0                 ;923
0000b2  f7fffffe          BL       PWMDRV_ITConfig
0000b6  2000              MOVS     r0,#0                 ;924
0000b8  f7fffffe          BL       MSPI_Cmd
0000bc  2000              MOVS     r0,#0                 ;925
0000be  f7fffffe          BL       PWMDRV_Cmd
0000c2  f7fffffe          BL       SensingBufferInit
0000c6  e7ea              B        |L42.158|
;;;958    
                          ENDP

                  |L42.200|
                          DCD      ||.data||+0x10
                  |L42.204|
                          DCD      0x40007000
                  |L42.208|
                          DCD      0x20020000
                  |L42.212|
                          DCD      tHalIntrHandle
                  |L42.216|
                          DCD      FullSharedBuff

                          AREA ||i.module_wait_local_sample_done||, CODE, READONLY, ALIGN=2

                  module_wait_local_sample_done PROC
;;;1070   
;;;1071   ePartialSensing_t module_wait_local_sample_done(void)
000000  b510              PUSH     {r4,lr}
000002  480c              LDR      r0,|L43.52|
;;;1072   {
000004  2200              MOVS     r2,#0
000006  f1a00410          SUB      r4,r0,#0x10
                  |L43.10|
00000a  78c1              LDRB     r1,[r0,#3]
;;;1073   	static bool_t sLCheckVCC = YES;
;;;1074   	ePartialSensing_t RetVal = PARTIAL_PEN_BEACON;
;;;1075   
;;;1076   	while(YES)
;;;1077   	{
;;;1078   		if(hal_get_irq_flag(IRQ_ID_LOCAL_SAMPLE))
00000c  b119              CBZ      r1,|L43.22|
00000e  70c2              STRB     r2,[r0,#3]
000010  78a0              LDRB     r0,[r4,#2]  ; gLocalTypeFlag
000012  70a2              STRB     r2,[r4,#2]
;;;1079   		{
;;;1080   			hal_clear_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;1081   
;;;1082   			RetVal = hal_get_LocalType_flag();
;;;1083   			hal_clear_LocalType_flag();
;;;1084   			break;
000014  e00b              B        |L43.46|
                  |L43.22|
000016  7841              LDRB     r1,[r0,#1]
;;;1085   		}
;;;1086   
;;;1087   		if(hal_get_irq_flag(IRQ_ID_FULL_SAMPLE))
000018  2900              CMP      r1,#0
00001a  bf18              IT       NE
00001c  7042              STRBNE   r2,[r0,#1]
;;;1088   		{
;;;1089   			hal_clear_irq_flag(IRQ_ID_FULL_SAMPLE);
;;;1090   		}
;;;1091   
;;;1092   		if(sLCheckVCC)
00001e  7961              LDRB     r1,[r4,#5]  ; sLCheckVCC
000020  2900              CMP      r1,#0                 ;1087
000022  d1f2              BNE      |L43.10|
;;;1093   		{
;;;1094   //			if(GPIO->tGPIO_DATA_1._GPIO_LCD_ON == 0x1)
;;;1095   //			{
;;;1096   //				sLCheckVCC = YES;
;;;1097   //			}
;;;1098   //			else
;;;1099   //			{
;;;1100   //				sLCheckVCC = NO;
;;;1101   //			}
;;;1102   //			sLCheckVCC = module_Check_LcdOn();
;;;1103   		}
;;;1104   		else
;;;1105   		{
;;;1106   			Hal_VccOff_State();
000024  f7fffffe          BL       Hal_VccOff_State
;;;1107   			SensingBufferInit();
000028  f7fffffe          BL       SensingBufferInit
;;;1108   			RetVal = PARTIAL_MAX;
00002c  2010              MOVS     r0,#0x10
                  |L43.46|
;;;1109   			break;
;;;1110   		}
;;;1111   	}
;;;1112   
;;;1113   	sLCheckVCC = YES;
00002e  2101              MOVS     r1,#1
000030  7161              STRB     r1,[r4,#5]
;;;1114   
;;;1115   //	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_GET_LOCAL_RAW_IMAGE_PTR(), COL_MAX, 8, 84/*MAX Intensity*/);
;;;1116   //	protocol_LogPaddedMatrix(LT_INTENSITY, COL_MAX, HAL_GET_LOCAL_DELTA_IMAGE_PTR(), COL_MAX, 8, 84/*MAX Intensity*/);
;;;1117   	return RetVal;
;;;1118   }
000032  bd10              POP      {r4,pc}
;;;1119   
                          ENDP

                  |L43.52|
                          DCD      ||.data||+0x10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  tbuf
                          %        600

                          AREA ||area_number.46||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.bss||
                  tbuf1
                          %        1200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ePenPartialIndex
000000  01050607          DCB      0x01,0x05,0x06,0x07
000004  020a0b0c          DCB      0x02,0x0a,0x0b,0x0c
000008  030d0e08          DCB      0x03,0x0d,0x0e,0x08
00000c  09040f            DCB      0x09,0x04,0x0f

                          AREA ||.data||, DATA, ALIGN=2

                  LocalSensingPos
000000  00                DCB      0x00
                  gucOverlapFPend
000001  00                DCB      0x00
                  gLocalTypeFlag
000002  00                DCB      0x00
                  gSubStateFlag
000003  00                DCB      0x00
                  RESET_FLAG
000004  00                DCB      0x00
                  sLCheckVCC
000005  010000            DCB      0x01,0x00,0x00
                  thisFixedConf
                          DCD      0x00000000
                  ResetFlagCnt
                          DCD      0x00000000
                  gbIrqFlag
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  TMP_INFO
                          %        8

                          AREA ||area_number.50||, DATA, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.data||
                  tcnt
                          DCD      0x00000000

                          AREA ||area_number.51||, DATA, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.data||
                  PenCoordIdx
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Module\\module.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_module_c_6c7fd86c____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___8_module_c_6c7fd86c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_module_c_6c7fd86c____REVSH|
#line 402
|__asm___8_module_c_6c7fd86c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_module_c_6c7fd86c____RRX|
#line 587
|__asm___8_module_c_6c7fd86c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
