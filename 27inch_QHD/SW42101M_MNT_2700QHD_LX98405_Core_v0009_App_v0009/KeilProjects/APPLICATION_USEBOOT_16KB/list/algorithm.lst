L 1 "..\..\App\Algorithm\algorithm.c"
N/******************************************************************************************************
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  algorithm.c
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#include "core_def.h"
L 1 "..\..\App\core_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : core_def.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _CORE_DEF_H_
N#define _CORE_DEF_H_
N
N
N#include "hal_def.h"
L 1 "..\..\Hal\hal_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : hal_def.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _HAL_DEF_H_
N#define _HAL_DEF_H_
N
N
N#include "env_def.h"
L 1 "..\..\Env\env_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_def.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_DEF_H_
N#define _ENV_DEF_H_
N
N
N#include "MFTP.h"
L 1 "..\..\Hal\system\MFTP.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : MFTP.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N/** @addtogroup MFTP
N  * @{
N  */
N
N#ifndef _MFTP_H_
N#define _MFTP_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M3 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
N                                                         and No Match                                                          */
N  BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
N                                                         related Fault                                                         */
N  UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* -----------------------  MFTP Specific Interrupt Numbers  ----------------------- */
N  WDT_IRQn                      =   0,              /*!<   0  WatchDog Timer                                              */
N  EXTI0_IRQn                    =   1,              /*!<   1  EXTI0                                                            */
N  EXTI1_IRQn                    =   2,              /*!<   2  EXTI1                                                            */
N  TIMER_IRQn                    =   3,              /*!<   3  TIMER                                                           */
N  I2C_IRQn                      =   4,              /*!<   6  I2C                                                              */
N  TSPI_IRQn                     =   5,              /*!<   8  TSPI                                                        */
N  USB_IRQn                      =   6,              /*!<   5  USB                                                              */
N  PWMDRV_IRQn                   =   7,              /*!<   4  PWMDRV                                                            */
N  MSPI_IRQn                     =   8,              /*!<   9  MSPI                                                        */
N  GPDMA_IRQn                    =   9,              /*!<  10  GPDMA                                                            */
N  DSP_A_IRQn                    =  10,              /*!<  11  DSPA(LGD)                                                            */
N  DSP_B_IRQn                    =  11,              /*!<  11  DSPB(SiW)                                                            */
N  PLL_IRQn                      =  12,              /*!<   7  PLL                                                  */
N  FLITF_IRQn                    =  13               /*!<  12  FLITF                                                            */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the Cortex-M3 Processor and Core Peripherals---------------- */
N#define __CM3_REV                 0x0201            /*!< Cortex-M3 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               3            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include <core_cm3.h>                               /*!< Cortex-M3 processor and core peripherals                              */
L 1 "..\..\Hal\system\CMSIS\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   0xffffffffU
N#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM3_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x03U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __attribute__ ((packed))
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\..\Hal\system\CMSIS\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\Hal\system\CMSIS\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x03U) == 0x04U) || ((0x03U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x03U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x03U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\..\Hal\system\CMSIS\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\..\Hal\system\CMSIS\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "..\..\Hal\system\CMSIS\core_cm3.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201U)                   /* core r2p1 */
X#if (0x0201 < 0x0201U)                    
S#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
S#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
S
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200U))
X#if ((1L) && (0x0201 >= 0x200U))
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N#else
S        uint32_t RESERVED1[1U];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 96 "..\..\Hal\system\MFTP.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#define __BITBAND					__attribute__ ((bitband))
N#define __PACKED                    __attribute__ ((packed))
N#define __ALIGNED4                  __attribute__ ((aligned(4)))
N#define __INTERRUPT                 __attribute__ ((interrupt))
N#define __WEAK                      __attribute__ ((weak))
N#elif defined ( __ICCARM__ )
S#define __NOP           __no_operation                              /*!< no operation intrinsic in IAR Compiler */
S
S#elif defined ( __GNUC__ )
S#define __BITBAND					__attribute__ ((bitband))
S#define __PACKED                    __attribute__ ((packed))
S#define __ALIGNED4                  __attribute__ ((aligned(4)))
S#define __INTERRUPT                 __attribute__ ((interrupt))
S#define __WEAK                      __attribute__ ((weak))
N#endif
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N/*
NCode Memory
NFLASH: 128kB
N0x00000000~0x0001FFFF
N
NCode Memory
NSRAM: 64kB
N0x10000000~0x1000FFFF
N
NSystem Memory
NSRAM: 64kB
N0x20000000~0x2000FFFF
N
NSystem Memory
NSRAM: 32kB
N0x20010000~0x20017FFF
N
NSystem Memory
NSRAM: 32kB
N0x20018000~0x2001FFFF
N
NMSPI Memory
NSRAM: 64kB
N0x20020000~0x2002FFFF
N*/
N
N/* ============================================= */
N/* ===========    F/W & BOOT Size    =========== */
N/* ============================================= */
N#define FLASH_SIZE					( 128 * 1024 )
N
N#define FW_SECTOR_SIZE				( 112 * 1024 )
N#define ECC_SECTOR_SIZE				(   6 * 1024 )
N#define BOOT_SECTOR_SIZE			(  10 * 1024 )
N
N#define FW_CODE_MAX_SIZE			( 108 * 1024 )
N#define ECC_CODE_MAX_SIZE			(   5 * 1024 )
N#define BOOT_CODE_MAX_SIZE			(   9 * 1024 )
N	
N#define ECC_CODE_SIZE				(		   3 )	//   3byte
N#define ECC_BLOCK_SIZE				( 		 256 )	// 256byte
N#define ECC_SPARE_SIZE				( FW_CODE_MAX_SIZE / ECC_BLOCK_SIZE * ECC_CODE_SIZE )
N
N/* ============================================ */
N/* ===========    ECC Memory Map    =========== */
N/* ============================================ */
N#define	BASEADDR_FW					0x00004000UL	
N#define	BASEADDR_FW_CRC				0x0001FC00UL	
N#define	BASEADDR_FW_ECC_1			0x0001F000UL	
N#define	BASEADDR_FW_ECC_2			0x0001F600UL
N#define BASEADDR_BOOT				0x00001800UL
N#define BASEADDR_BOOT_CRC			0x00003F80UL
N#define BASEADDR_BOOT_ECC_1			0x00003C00UL
N#define BASEADDR_BOOT_ECC_2			0x00003D00UL
N#define BASEADDR_BOOT_INFO_1		0x00003E00UL
N#define BASEADDR_BOOT_INFO_2		0x00003E80UL
N#define BASEADDR_BOOT_INFO_3		0x00003F00UL
N
N#define BASEADDR_FW_ERROR			0x000017F4UL
N#define BASEADDR_BOOT_INFO_ERROR	0x000017F0UL
N
N/* ============================================================================================ */
N/* ===================================    ECC Declaration    ================================== */
N/* ============================================================================================ */
N#define BACKUP_FW_CRC				((BACKUP_CRC_TypeDef	*) 		BASEADDR_FW_CRC				)
N#define BACKUP_BOOT_CRC        		((BACKUP_CRC_TypeDef	*) 		BASEADDR_BOOT_CRC			)
N#define BACKUP_BOOT_INFO_1          ((BACKUP_INFO_TypeDef	*) 		BASEADDR_BOOT_INFO_1		)
N#define BACKUP_BOOT_INFO_2         	((BACKUP_INFO_TypeDef	*) 		BASEADDR_BOOT_INFO_2		)
N#define BACKUP_BOOT_INFO_3          ((BACKUP_INFO_TypeDef	*) 		BASEADDR_BOOT_INFO_3		)
N#define BACKUP_BOOT_INFO_ERROR		((BACKUP_INFO_ERROR_TypeDef	*)	BASEADDR_BOOT_INFO_ERROR	)
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N#define BASE_INFO                       0x00020000UL
N
N#define BASE_SRAM1                      0x20000000UL
N#define BASE_SRAM2                      0x20010000UL
N#define BASE_SRAM3                      0x20018000UL
N#define BASE_MSPI_SRAM					0x20020000UL
N
N#define BASE_SCRB                       0x40000000UL
N#define BASE_FLITF                      0x40001000UL
N#define BASE_I2C                        0x40002000UL
N#define BASE_TSPI                       0x40003000UL
N#define BASE_PWMDRV                     0x40004000UL
N#define BASE_MSPI                       0x40005000UL
N#define BASE_TIMER                      0x40006000UL
N#define BASE_GPIO                       0x40007000UL
N#define BASE_UWDT                       0x40008000UL
N#define BASE_HWACC                      0x40009000UL
N#define BASE_SIW						0x4000A000UL
N#define BASE_LWDT                       0x4000B000UL
N
N#define BASE_GPDMA                      0x40020000UL
N#define BASE_USB                        0x40030000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N#define INFO                            ((INFO_TypeDef        *) BASE_INFO  )
N#define SCRB                            ((tSCRB_CtrlReg_t     *) BASE_SCRB  )
N#define FLITF                           ((FLITF_TypeDef       *) BASE_FLITF )
N//#define SYSCFG                          ((tSYSCFG_CtrlReg_t   *) BASE_FLITF )
N#define I2C                             ((tI2C_CtrlReg_t      *) BASE_I2C   )
N#define TSPI                            ((TSPI_TypeDef        *) BASE_TSPI  )
N#define PWMDRV                          ((PWMDRV_TypeDef      *) BASE_PWMDRV)
N#define MSPI                            ((MSPI_TypeDef        *) BASE_MSPI  )
N#define TIMER                           ((tTIMER_CtrlReg_t    *) BASE_TIMER )
N#define GPIO                            ((tGPIO_CtrlReg_t     *) BASE_GPIO)
N#define UWDT                            ((WDT_TypeDef         *) BASE_UWDT  )
N#define LWDT                            ((WDT_TypeDef         *) BASE_LWDT  )
N#define DSPA                            ((tDSPA_CtrlReg_t     *) BASE_HWACC )
N#define DSP_CON                         ((DSP_CONTROL_TypeDef *) BASE_SIW   )
N#define GPDMA                           ((GDMA_TypeDef        *) BASE_GDMA )
N#define USB_HC							((USB_HC_TypeDef      *) BASE_USB  )
N#define USB_OTG							((USB_OTG_TypeDef     *) (BASE_USB+0x80))
N#define USB_GLOBAL						((USB_GLOBAL_TypeDef  *) (BASE_USB+0xC0))
N#define USB_DEVICE						((USB_DEVICE_TypeDef  *) (BASE_USB+0x100))
N
N/* -------------------  Include System Peripheral CMSIS Definition ------------------ */
N#include "../scrb/_scrb.h"
L 1 "..\..\Hal\system\../scrb/_scrb.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _scrb.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __SCRB_H_
N#define __SCRB_H_
N
N
N/* ================================================================================ */
N/* ================                      SCR                       ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  SCR Control Register
N */
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t METAL_REV		: 4;
X		volatile const uint32_t METAL_REV		: 4;
N		__I uint32_t FULL_REV		: 4;
X		volatile const uint32_t FULL_REV		: 4;
N		__I uint32_t CHIP_NAME		: 16;
X		volatile const uint32_t CHIP_NAME		: 16;
N		__I uint32_t reserved		: 8;
X		volatile const uint32_t reserved		: 8;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tDEVICE_ID_t;
N
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t LOCKUP		: 1;
X		volatile const uint32_t LOCKUP		: 1;
N		__I uint32_t HALTED		: 1;
X		volatile const uint32_t HALTED		: 1;
N		__I uint32_t reserved	: 30;
X		volatile const uint32_t reserved	: 30;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tCM3_STATUS_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t RST_STS_CLR	: 1;
X		volatile uint32_t RST_STS_CLR	: 1;
N		__I uint32_t SYSTEM_RST		: 1;
X		volatile const uint32_t SYSTEM_RST		: 1;
N		__I uint32_t WDT_RST		: 1;
X		volatile const uint32_t WDT_RST		: 1;
N		__I uint32_t EXT_RST		: 1;
X		volatile const uint32_t EXT_RST		: 1;
N		__I uint32_t reserved		: 28;
X		volatile const uint32_t reserved		: 28;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tRST_STATUS_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t I2C_BLK		: 1;
X		volatile uint32_t I2C_BLK		: 1;
N		__IO uint32_t I2C_WAKEUP	: 1;
X		volatile uint32_t I2C_WAKEUP	: 1;
N		__IO uint32_t I2C_SLEEP		: 1;
X		volatile uint32_t I2C_SLEEP		: 1;
N		__I uint32_t reserved		: 29;
X		volatile const uint32_t reserved		: 29;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tINTR_I2C_CFG_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t INTR_USR_WDT			: 1;
X		volatile uint32_t INTR_USR_WDT			: 1;
N		__IO uint32_t INTR_EXTI0			: 1;
X		volatile uint32_t INTR_EXTI0			: 1;
N		__IO uint32_t INTR_EXTI1			: 1;
X		volatile uint32_t INTR_EXTI1			: 1;
N		__IO uint32_t INTR_TIMER			: 1;
X		volatile uint32_t INTR_TIMER			: 1;
N		__IO uint32_t INTR_I2C				: 1;
X		volatile uint32_t INTR_I2C				: 1;
N		__IO uint32_t INTR_TSPI				: 1;
X		volatile uint32_t INTR_TSPI				: 1;
N		__IO uint32_t INTR_USB				: 1;
X		volatile uint32_t INTR_USB				: 1;
N		__IO uint32_t INTR_LFDTX			: 1;
X		volatile uint32_t INTR_LFDTX			: 1;
N		__IO uint32_t INTR_MSPI				: 1;
X		volatile uint32_t INTR_MSPI				: 1;
N		__IO uint32_t INTR_GDMA				: 1;
X		volatile uint32_t INTR_GDMA				: 1;
N		__IO uint32_t INTR_DSPA				: 1;
X		volatile uint32_t INTR_DSPA				: 1;
N		__IO uint32_t INTR_DSPB				: 1;
X		volatile uint32_t INTR_DSPB				: 1;
N		__IO uint32_t INTR_PLL				: 1;
X		volatile uint32_t INTR_PLL				: 1;
N		__IO uint32_t INTR_FLITF			: 1;
X		volatile uint32_t INTR_FLITF			: 1;
N		__IO uint32_t INTR_LOCK_WDT			: 1;
X		volatile uint32_t INTR_LOCK_WDT			: 1;
N		__IO uint32_t INTR_I2C_wakeup		: 1;
X		volatile uint32_t INTR_I2C_wakeup		: 1;
N		__IO uint32_t INTR_USB_SUSMPENDM	: 1;
X		volatile uint32_t INTR_USB_SUSMPENDM	: 1;
N		__IO uint32_t INTR_USB_LPMEN		: 1;
X		volatile uint32_t INTR_USB_LPMEN		: 1;
N		__I uint32_t reserved				: 14;
X		volatile const uint32_t reserved				: 14;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tINTR_NMI_CFG_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t TENMS			: 24;
X		volatile uint32_t TENMS			: 24;
N		__IO uint32_t SKEW			: 1;
X		volatile uint32_t SKEW			: 1;
N		__IO uint32_t NOREF			: 1;
X		volatile uint32_t NOREF			: 1;
N		__IO uint32_t SYSTICK_SRC	: 2;
X		volatile uint32_t SYSTICK_SRC	: 2;
N		__I uint32_t reserved		: 4;
X		volatile const uint32_t reserved		: 4;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tSTCALIB_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t r_USB_CLK_ENA		: 1;
X		volatile uint32_t r_USB_CLK_ENA		: 1;
N		__IO uint32_t r_WDT_CLK_ENA		: 1;
X		volatile uint32_t r_WDT_CLK_ENA		: 1;
N		__IO uint32_t r_TIM_CLK_ENA		: 1;
X		volatile uint32_t r_TIM_CLK_ENA		: 1;
N		__IO uint32_t r_LFDTX_CLK_ENA	: 1;
X		volatile uint32_t r_LFDTX_CLK_ENA	: 1;
N		__IO uint32_t r_TSPI_CLK_ENA	: 1;
X		volatile uint32_t r_TSPI_CLK_ENA	: 1;
N		__IO uint32_t r_DSPA_CLK_ENA	: 1;
X		volatile uint32_t r_DSPA_CLK_ENA	: 1;
N		__IO uint32_t r_DSPB_CLK_ENA	: 1;
X		volatile uint32_t r_DSPB_CLK_ENA	: 1;
N		__IO uint32_t r_SRAM1_CLK_ENA	: 1;
X		volatile uint32_t r_SRAM1_CLK_ENA	: 1;
N		__IO uint32_t r_SRAM2_CLK_ENA	: 1;
X		volatile uint32_t r_SRAM2_CLK_ENA	: 1;
N		__IO uint32_t r_SRAM3_CLK_ENA	: 1;
X		volatile uint32_t r_SRAM3_CLK_ENA	: 1;
N		__IO uint32_t r_DMAC_CLK_ENA	: 1;
X		volatile uint32_t r_DMAC_CLK_ENA	: 1;
N		__IO uint32_t r_I2C_CLK_ENA		: 1;
X		volatile uint32_t r_I2C_CLK_ENA		: 1;
N		__IO uint32_t r_FLITF_CLK_ENA	: 1;
X		volatile uint32_t r_FLITF_CLK_ENA	: 1;
N		__IO uint32_t r_GPIO_CLK_ENA	: 1;
X		volatile uint32_t r_GPIO_CLK_ENA	: 1;
N		__I uint32_t reserved			: 2;
X		volatile const uint32_t reserved			: 2;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_RUN0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t r_MSPI01_CLK_ENA	: 1;
X		volatile uint32_t r_MSPI01_CLK_ENA	: 1;
N		__IO uint32_t r_MSPI23_CLK_ENA	: 1;
X		volatile uint32_t r_MSPI23_CLK_ENA	: 1;
N		__IO uint32_t r_MSPI45_CLK_ENA	: 1;
X		volatile uint32_t r_MSPI45_CLK_ENA	: 1;
N		__IO uint32_t r_SIF_CLK_ENA		: 1;
X		volatile uint32_t r_SIF_CLK_ENA		: 1;
N		__IO uint32_t r_SFL_CLK_ENA		: 1;
X		volatile uint32_t r_SFL_CLK_ENA		: 1;
N		__I uint32_t reserved			: 11;
X		volatile const uint32_t reserved			: 11;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_RUN1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t s_USB_CLK_ENA		: 1;
X		volatile uint32_t s_USB_CLK_ENA		: 1;
N		__IO uint32_t s_WDT_CLK_ENA		: 1;
X		volatile uint32_t s_WDT_CLK_ENA		: 1;
N		__IO uint32_t s_TIM_CLK_ENA		: 1;
X		volatile uint32_t s_TIM_CLK_ENA		: 1;
N		__IO uint32_t s_LFDTX_CLK_ENA	: 1;
X		volatile uint32_t s_LFDTX_CLK_ENA	: 1;
N		__IO uint32_t s_TSPI_CLK_ENA	: 1;
X		volatile uint32_t s_TSPI_CLK_ENA	: 1;
N		__IO uint32_t s_DSPA_CLK_ENA	: 1;
X		volatile uint32_t s_DSPA_CLK_ENA	: 1;
N		__IO uint32_t s_DSPB_CLK_ENA	: 1;
X		volatile uint32_t s_DSPB_CLK_ENA	: 1;
N		__IO uint32_t s_SRAM1_CLK_ENA	: 1;
X		volatile uint32_t s_SRAM1_CLK_ENA	: 1;
N		__IO uint32_t s_SRAM2_CLK_ENA	: 1;
X		volatile uint32_t s_SRAM2_CLK_ENA	: 1;
N		__IO uint32_t s_SRAM3_CLK_ENA	: 1;
X		volatile uint32_t s_SRAM3_CLK_ENA	: 1;
N		__IO uint32_t s_DMAC_CLK_ENA	: 1;
X		volatile uint32_t s_DMAC_CLK_ENA	: 1;
N		__IO uint32_t s_I2C_CLK_ENA		: 1;
X		volatile uint32_t s_I2C_CLK_ENA		: 1;
N		__IO uint32_t s_FLITF_CLK_ENA	: 1;
X		volatile uint32_t s_FLITF_CLK_ENA	: 1;
N		__IO uint32_t s_GPIO_CLK_ENA	: 1;
X		volatile uint32_t s_GPIO_CLK_ENA	: 1;
N		__I uint32_t reserved			: 2;
X		volatile const uint32_t reserved			: 2;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_SLP0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t s_MSPI01_CLK_ENA	: 1;
X		volatile uint32_t s_MSPI01_CLK_ENA	: 1;
N		__IO uint32_t s_MSPI23_CLK_ENA	: 1;
X		volatile uint32_t s_MSPI23_CLK_ENA	: 1;
N		__IO uint32_t s_MSPI45_CLK_ENA	: 1;
X		volatile uint32_t s_MSPI45_CLK_ENA	: 1;
N		__IO uint32_t s_SCB_CLK_ENA		: 1;
X		volatile uint32_t s_SCB_CLK_ENA		: 1;
N		__IO uint32_t s_COR_CLK_ENA		: 1;
X		volatile uint32_t s_COR_CLK_ENA		: 1;
N		__IO uint32_t s_SYS_CLK_ENA		: 1;
X		volatile uint32_t s_SYS_CLK_ENA		: 1;
N		__IO uint32_t s_SIF_CLK_ENA		: 1;
X		volatile uint32_t s_SIF_CLK_ENA		: 1;
N		__IO uint32_t s_SFL_CLK_ENA		: 1;
X		volatile uint32_t s_SFL_CLK_ENA		: 1;
N		__I uint32_t reserved			: 8;
X		volatile const uint32_t reserved			: 8;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCK_ENA_SLP1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t USB_RSTN_CTRL		: 1;
X		volatile uint32_t USB_RSTN_CTRL		: 1;
N		__IO uint32_t WDT_RSTN_CTRL		: 1;
X		volatile uint32_t WDT_RSTN_CTRL		: 1;
N		__IO uint32_t TIM_RSTN_CTRL		: 1;
X		volatile uint32_t TIM_RSTN_CTRL		: 1;
N		__IO uint32_t LFDTX_RSTN_CTRL	: 1;
X		volatile uint32_t LFDTX_RSTN_CTRL	: 1;
N		__IO uint32_t TSPI_RSTN_CTRL	: 1;
X		volatile uint32_t TSPI_RSTN_CTRL	: 1;
N		__IO uint32_t DSPA_RSTN_CTRL	: 1;
X		volatile uint32_t DSPA_RSTN_CTRL	: 1;
N		__IO uint32_t DSPB_RSTN_CTRL	: 1;
X		volatile uint32_t DSPB_RSTN_CTRL	: 1;
N		__IO uint32_t I2C_RSTN_CTRL		: 1;
X		volatile uint32_t I2C_RSTN_CTRL		: 1;
N		__IO uint32_t GPIO_RSTN_CTRL	: 1;
X		volatile uint32_t GPIO_RSTN_CTRL	: 1;
N		__IO uint32_t MSPI_RSTN_CTRL	: 1;
X		volatile uint32_t MSPI_RSTN_CTRL	: 1;
N		__IO uint32_t SIF_RSTN_CTRL		: 1;
X		volatile uint32_t SIF_RSTN_CTRL		: 1;
N		__IO uint32_t SFL_RSTN_CTRL		: 1;
X		volatile uint32_t SFL_RSTN_CTRL		: 1;
N		__I uint32_t reserved			: 4;
X		volatile const uint32_t reserved			: 4;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tRST_CTRL_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t DLY_SLP			: 16;
X		volatile uint32_t DLY_SLP			: 16;
N		__IO uint32_t BYPASS_SLP		: 1;
X		volatile uint32_t BYPASS_SLP		: 1;
N		__IO uint32_t PMUENABLE			: 1;
X		volatile uint32_t PMUENABLE			: 1;
N		__I uint32_t reserved			: 14;
X		volatile const uint32_t reserved			: 14;
N//        	__O uint32_t _VECTKEY			: 16; // Write : 0x05FA NOTE :  !!
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tPMU_CONTROL_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t CCLK_SEL			: 2;
X		volatile uint32_t CCLK_SEL			: 2;
N		__IO uint32_t WDCLK_SEL			: 2;
X		volatile uint32_t WDCLK_SEL			: 2;
N		__IO uint32_t TIMCLK_SEL		: 2;
X		volatile uint32_t TIMCLK_SEL		: 2;
N		__IO uint32_t SSCGOUT_SEL		: 1;
X		volatile uint32_t SSCGOUT_SEL		: 1;
N		__IO uint32_t SSCGOUT2X_SEL		: 1;
X		volatile uint32_t SSCGOUT2X_SEL		: 1;
N		__IO uint32_t TOUCHCLK_SEL		: 2;
X		volatile uint32_t TOUCHCLK_SEL		: 2;
N		__IO uint32_t PLLOUT_SEL		: 3;
X		volatile uint32_t PLLOUT_SEL		: 3;
N		__IO uint32_t SSCGIN_SEL		: 1;
X		volatile uint32_t SSCGIN_SEL		: 1;
N		__I uint32_t reserved			: 2;
X		volatile const uint32_t reserved			: 2;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCLK_SRC_SEL_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t HCLK_DIV			: 3;
X		volatile uint32_t HCLK_DIV			: 3;
N		__IO uint32_t PCLK_DIV			: 2;
X		volatile uint32_t PCLK_DIV			: 2;
N		__IO uint32_t TIMCLK_DIV		: 3;
X		volatile uint32_t TIMCLK_DIV		: 3;
N		__IO uint32_t WDTCLK_DIV		: 3;
X		volatile uint32_t WDTCLK_DIV		: 3;
N		__IO uint32_t SSCGIN_DIV		: 2;
X		volatile uint32_t SSCGIN_DIV		: 2;
N		__IO uint32_t TOUCHCLK_DIV		: 3;
X		volatile uint32_t TOUCHCLK_DIV		: 3;
N		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY			: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tCLK_DIV_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t ECLK_SEL		: 4;
X		volatile uint32_t ECLK_SEL		: 4;
N		__IO uint32_t ECLK_DIV1		: 3;
X		volatile uint32_t ECLK_DIV1		: 3;
N		__IO uint32_t ECLK_DIV2		: 2;
X		volatile uint32_t ECLK_DIV2		: 2;
N		__IO uint32_t USBPHY_SEL	: 2;
X		volatile uint32_t USBPHY_SEL	: 2;
N		__I uint32_t reserved		: 5;
X		volatile const uint32_t reserved		: 5;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tECLK_CFG_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t PLL_STBY_I	: 1;	// Powerdown Input : (0)Normal Operation, (1)Powerdown Mode
X		volatile uint32_t PLL_STBY_I	: 1;	
N		__IO uint32_t REFDIV		: 3;	// Reference divider control : M = REFDIV[2:0] + 1, M = {1~8}
X		volatile uint32_t REFDIV		: 3;	
N		__IO uint32_t FBDIV			: 6;	// Feedback divider control : N = FBDIV[5:0], N = {5~50}
X		volatile uint32_t FBDIV			: 6;	
N		__IO uint32_t OUTDIV		: 2;	// Output divider control : O = 2*OUTDIV[1:0], O = {1,2,4,8}
X		volatile uint32_t OUTDIV		: 2;	
N		__I uint32_t reserved		: 4;
X		volatile const uint32_t reserved		: 4;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t RSEL			: 3;
X		volatile uint32_t RSEL			: 3;
N		__IO uint32_t ICPSELA		: 1;
X		volatile uint32_t ICPSELA		: 1;
N		__IO uint32_t ICPSELB		: 1;
X		volatile uint32_t ICPSELB		: 1;
N		__IO uint32_t VCOSETUPSEL	: 1;
X		volatile uint32_t VCOSETUPSEL	: 1;
N		__I uint32_t reserved		: 10;
X		volatile const uint32_t reserved		: 10;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t PLL_IE	: 1;
X		volatile uint32_t PLL_IE	: 1;
N		__IO uint32_t PLL_IEV	: 1;
X		volatile uint32_t PLL_IEV	: 1;
N		__IO uint32_t PLL_IBE	: 1;
X		volatile uint32_t PLL_IBE	: 1;
N		__I uint32_t reserved	: 29;
X		volatile const uint32_t reserved	: 29;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_IC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t PLL_INTC		: 1;
X		volatile uint32_t PLL_INTC		: 1;
N		__I uint32_t PLL_MIS		: 1;
X		volatile const uint32_t PLL_MIS		: 1;
N		__I uint32_t PLL_RIS		: 1;
X		volatile const uint32_t PLL_RIS		: 1;
N		__I uint32_t PLL_LOCKED_O	: 1;
X		volatile const uint32_t PLL_LOCKED_O	: 1;
N		__I uint32_t reserved		: 28;
X		volatile const uint32_t reserved		: 28;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUMC_PLL_IS_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t OSC_PDB_12M	: 1;
X		volatile uint32_t OSC_PDB_12M	: 1;
N		__IO uint32_t OSC_PDB_40K	: 1;
X		volatile uint32_t OSC_PDB_40K	: 1;
N		__I uint32_t reserved		: 14;
X		volatile const uint32_t reserved		: 14;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_OSC_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t IREF_TST		: 1;
X		volatile uint32_t IREF_TST		: 1;
N		__IO uint32_t OSC_TRIM		: 7;
X		volatile uint32_t OSC_TRIM		: 7;
N		__IO uint32_t LOSC_TRIM		: 4;
X		volatile uint32_t LOSC_TRIM		: 4;
N		__I uint32_t reserved		: 4;
X		volatile const uint32_t reserved		: 4;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_OSC_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t CAL_SEL  		:  4;
X		volatile uint32_t CAL_SEL  		:  4;
N		__I uint32_t VSEL_OUT 		:  1;
X		volatile const uint32_t VSEL_OUT 		:  1;
N		__I uint32_t reserved		: 11;
X		volatile const uint32_t reserved		: 11;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_LDO_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t SSCG_PDB		: 1;
X		volatile uint32_t SSCG_PDB		: 1;
N		__IO uint32_t SSCG_EN		: 1;
X		volatile uint32_t SSCG_EN		: 1;
N		__IO uint32_t SSCG_INIT		: 1;
X		volatile uint32_t SSCG_INIT		: 1;
N		__I uint32_t reserved		: 13;
X		volatile const uint32_t reserved		: 13;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_SSC_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t SSCG_MR		: 3;
X		volatile uint32_t SSCG_MR		: 3;
N		__IO uint32_t SSCG_MF		: 2;
X		volatile uint32_t SSCG_MF		: 2;
N		__IO uint32_t SSCG_FRAC_EN	: 1;
X		volatile uint32_t SSCG_FRAC_EN	: 1;
N		__IO uint32_t SSCG_ICP		: 2;
X		volatile uint32_t SSCG_ICP		: 2;
N		__IO uint32_t SSCG_RSEL		: 2;
X		volatile uint32_t SSCG_RSEL		: 2;
N		__IO uint32_t SSCG_KVC		: 1;
X		volatile uint32_t SSCG_KVC		: 1;
N		__I uint32_t reserved		: 5;
X		volatile const uint32_t reserved		: 5;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_SSC_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t SSCG_SEL_NRST	: 1;
X		volatile uint32_t SSCG_SEL_NRST	: 1;
N		__IO uint32_t SSCG_DIG_RSTN	: 1;
X		volatile uint32_t SSCG_DIG_RSTN	: 1;
N		__IO uint32_t SSCG_DIG_TST	: 1;
X		volatile uint32_t SSCG_DIG_TST	: 1;
N		__I uint32_t SSCG_FLAG		: 1;
X		volatile const uint32_t SSCG_FLAG		: 1;
N		__I uint32_t reserved		: 12;
X		volatile const uint32_t reserved		: 12;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_SSC_TC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t ATOP_DUMMY 	: 8;
X		volatile uint32_t ATOP_DUMMY 	: 8;
N		__I uint32_t reserved 		: 8;
X		volatile const uint32_t reserved 		: 8;
N		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
X		volatile uint32_t _VECTKEY		: 16; 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tLGD_ANA_DM_t;
N//    __IO uint32_t LGD_ANA_DM;                     //0x001A
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t VBUSVALID			: 1;
X		volatile uint32_t VBUSVALID			: 1;
N		__IO uint32_t WAKEUP			: 1;
X		volatile uint32_t WAKEUP			: 1;
N		__IO uint32_t L1_WAKEUP			: 1;
X		volatile uint32_t L1_WAKEUP			: 1;
N		__IO uint32_t SEL_VBUSVALID		: 1;
X		volatile uint32_t SEL_VBUSVALID		: 1;
N		__IO uint32_t SEL_WAKEUP		: 1;
X		volatile uint32_t SEL_WAKEUP		: 1;
N		__IO uint32_t SEL_L1_WAKEUP		: 1;
X		volatile uint32_t SEL_L1_WAKEUP		: 1;
N		__I uint32_t reserved			: 26;
X		volatile const uint32_t reserved			: 26;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_CTL_UC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t EXTCTRL_SUSPENDM	: 1;
X		volatile uint32_t EXTCTRL_SUSPENDM	: 1;
N		__IO uint32_t OSCOUTEN			: 1;
X		volatile uint32_t OSCOUTEN			: 1;
N		__IO uint32_t XTLSEL			: 1;
X		volatile uint32_t XTLSEL			: 1;
N		__IO uint32_t PLLALIV			: 1;
X		volatile uint32_t PLLALIV			: 1;
N		__IO uint32_t PONRST			: 1;
X		volatile uint32_t PONRST			: 1;
N		__IO uint32_t OUTCLKSEL			: 1;
X		volatile uint32_t OUTCLKSEL			: 1;
N		__IO uint32_t TA				: 1;
X		volatile uint32_t TA				: 1;
N		__IO uint32_t TB				: 1;
X		volatile uint32_t TB				: 1;
N		__IO uint32_t TC				: 1;
X		volatile uint32_t TC				: 1;
N		__I uint32_t reserved			: 23;
X		volatile const uint32_t reserved			: 23;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_PHY_FC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t USB_SUSM_INTR_EN		: 1;
X		volatile uint32_t USB_SUSM_INTR_EN		: 1;
N		__IO uint32_t USB_SUSM_INTR_POSNEG	: 1;
X		volatile uint32_t USB_SUSM_INTR_POSNEG	: 1;
N		__IO uint32_t USB_SUSM_INTR_BOTH	: 1;
X		volatile uint32_t USB_SUSM_INTR_BOTH	: 1;
N		__IO uint32_t USB_LPM_INTR_EN		: 1;
X		volatile uint32_t USB_LPM_INTR_EN		: 1;
N		__IO uint32_t USB_LPM_INTR_POSNEG	: 1;
X		volatile uint32_t USB_LPM_INTR_POSNEG	: 1;
N		__IO uint32_t USB_LPM_INTR_BOTH		: 1;
X		volatile uint32_t USB_LPM_INTR_BOTH		: 1;
N		__IO uint32_t USB_IP_INTR_EN		: 1;
X		volatile uint32_t USB_IP_INTR_EN		: 1;
N		__IO uint32_t USB_IP_INTR_INV		: 1;
X		volatile uint32_t USB_IP_INTR_INV		: 1;
N		__I uint32_t reserved				: 24;
X		volatile const uint32_t reserved				: 24;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_ITR_IC_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t USB_SUSM_INTC		: 1;
X		volatile uint32_t USB_SUSM_INTC		: 1;
N		__I uint32_t USB_SUSM_MIS		: 1;
X		volatile const uint32_t USB_SUSM_MIS		: 1;
N		__I uint32_t USB_SUSM_RIS		: 1;
X		volatile const uint32_t USB_SUSM_RIS		: 1;
N		__I uint32_t USB_SUSM_RAW		: 1;
X		volatile const uint32_t USB_SUSM_RAW		: 1;
N		__O uint32_t USB_LPM_EN_INTC	: 1;
X		volatile uint32_t USB_LPM_EN_INTC	: 1;
N		__I uint32_t USB_LPM_EN_MIS		: 1;
X		volatile const uint32_t USB_LPM_EN_MIS		: 1;
N		__I uint32_t USB_LPM_EN_RIS		: 1;
X		volatile const uint32_t USB_LPM_EN_RIS		: 1;
N		__I uint32_t USB_LPM_EN_RAW		: 1;
X		volatile const uint32_t USB_LPM_EN_RAW		: 1;
N		__I uint32_t reserved			: 24;
X		volatile const uint32_t reserved			: 24;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tUSB_ITR_IS_t;
N
N//typedef union
N//{
N//	struct
N//	{
N//		__IO uint32_t BEN_TST		: 1;
N//		__IO uint32_t REN_TST		: 1;
N//		__IO uint32_t CEN_TST		: 1;
N//		__IO uint32_t IREF_TST		: 1;
N//		__IO uint32_t IREF_TRIM		: 4;
N//		__IO uint32_t BOFF_TRIM		: 3;
N//		__I uint32_t reserved		: 5;
N//		__O uint32_t _VECTKEY		: 16; // Write : 0x05FA
N//	} tBit;
N//	__IO uint32_t ulBulk;
N//} tMAIN_BIAS_t;
N//
N//typedef union
N//{
N//	struct
N//	{
N//		__IO uint32_t DCTC_AMUX_EN_LV	: 1;
N//		__IO uint32_t DCTC_LV_MUX0		: 4;
N//		__IO uint32_t DCTC_LV_MUX1		: 4;
N//		__I uint32_t reserved			: 7;
N//		__O uint32_t _VECTKEY			: 16; // Write : 0x05FA
N//	} tBit;
N//	__IO uint32_t ulBulk;
N//} tTEST_MUX_t;
N
Ntypedef struct
N{
N	tDEVICE_ID_t DEVICE_ID;
N    __IO uint32_t SYSTEM_INFO;                    //0x0001
X    volatile uint32_t SYSTEM_INFO;                    
N    tCM3_STATUS_t CM3_STATUS;
N    tRST_STATUS_t RST_STATUS;
N    tINTR_I2C_CFG_t INTR_I2C_CFG;
N    tINTR_NMI_CFG_t INTR_NMI_CFG;
N    tSTCALIB_t STCALIB;
N    tCK_ENA_RUN0_t CK_ENA_RUN0;
N    tCK_ENA_RUN1_t CK_ENA_RUN1;
N    tCK_ENA_SLP0_t CK_ENA_SLP0;
N    tCK_ENA_SLP1_t CK_ENA_SLP1;
N    tRST_CTRL_t RST_CTRL;
N    tPMU_CONTROL_t PMU_CONTROL;
N    tCLK_SRC_SEL_t CLK_SRC_SEL;
N    tCLK_DIV_t CLK_DIV;
N    tECLK_CFG_t ECLK_CFG;
N    tUMC_PLL_UC_t UMC_PLL_UC;
N    tUMC_PLL_FC_t UMC_PLL_FC;
N    tUMC_PLL_IC_t UMC_PLL_IC;
N    tUMC_PLL_IS_t UMC_PLL_IS;
N    tLGD_OSC_UC_t LGD_OSC_UC;
N    tLGD_OSC_FC_t LGD_OSC_FC;
N    tLGD_LDO_FC_t LGD_LDO_FC;
N    tLGD_SSC_UC_t LGD_SSC_UC;
N    tLGD_SSC_FC_t LGD_SSC_FC;
N    tLGD_SSC_TC_t LGD_SSC_TC;
N    tLGD_ANA_DM_t LGD_ANA_DM;
N//    __IO uint32_t LGD_ANA_DM;                     //0x001A
N    tUSB_CTL_UC_t USB_CTL_UC;
N    tUSB_PHY_FC_t USB_PHY_FC;
N    tUSB_ITR_IC_t USB_ITR_IC;
N    tUSB_ITR_IS_t USB_ITR_IS;
N//    tMAIN_BIAS_t MAIN_BIAS;
N//    tTEST_MUX_t TEST_MUX;
N	
N} tSCRB_CtrlReg_t;
N
N
N#endif /* __SCRB_H_ */
L 278 "..\..\Hal\system\MFTP.h" 2
N#include "_gpio.h"
L 1 "..\..\Hal\gpio\_gpio.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _gpio.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __GPIO_H_
N#define __GPIO_H_
N
N
N/* ================================================================================ */
N/* ================               GPIO Control Registers           ================ */
N/* ================================================================================ */
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 1;		 
N		__IO uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 1;		 
N		__IO uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 1;		 
N		__IO uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 1;		 
N		__IO uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 1;		 
N		__IO uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 1;		 
N		__IO uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 1;		 
N		__IO uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 1;		 
N		__IO uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 1;		 
N		__IO uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 1;		 
N		__IO uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 1;		 
N		__IO uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 1;		 
N		__IO uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 1;		 
N		__IO uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 1;		 
N		__IO uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 1;		 
N		__IO uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 1;		 
N		__IO uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 1;		 
N		__IO uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 1;		 
N		__IO uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 1;		 
N		__IO uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 1;		 
N		__IO uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 1;		 
N		__IO uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 1;		 
N		__IO uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 1;		 
N		__IO uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 1;		 
N		__IO uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 1;		 
N		__IO uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 1;		 
N		__IO uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 1;		 
N		__IO uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 1;		 
N		__IO uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 1;		 
N		__IO uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 1;		 
N		__IO uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 1;		 
N		__IO uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 1;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_PIN_0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 1;		 
N		__IO uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 1;		 
N		__IO uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 1;		 
N		__IO uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 1;		 
N		__IO uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 1;		 
N		__IO uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 1;		 
N		__IO uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 1;		 
N		__IO uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 1;		 
N		__IO uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 1;		 
N		__IO uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 1;		 
N		__IO uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 1;		 
N		__IO uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 1;		 
N		__IO uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 1;		 
N		__IO uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 1;		 
N		__IO uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 1;		 
N		__IO uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 1;		 
N		__IO uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 1;		 
N		__IO uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 1;		 
N		/*
N		 * Serial Flash SPI Pin
N		 */
N//		__I uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 10;
N		__I uint32_t RESERVED	: 14;
X		volatile const uint32_t RESERVED	: 14;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_PIN_1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 1;		 
N		__IO uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 1;		 
N		__IO uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 1;		 
N		__IO uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 1;		 
N		__IO uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 1;		 
N		__IO uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 1;		 
N		__IO uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 1;		 
N		__IO uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 1;		 
N		__IO uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 1;		 
N		__IO uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 1;		 
N		__IO uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 1;		 
N		__IO uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 1;		 
N		__IO uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 1;		 
N		__IO uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 1;		 
N		__IO uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 1;		 
N		__IO uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 1;		 
N		__IO uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 1;		 
N		__IO uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 1;		 
N		__IO uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 1;		 
N		__IO uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 1;		 
N		__IO uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 1;		 
N		__IO uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 1;		 
N		__IO uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 1;		 
N		__IO uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 1;		 
N		__IO uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 1;		 
N		__IO uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 1;		 
N		__I uint32_t RESERVED	: 6;
X		volatile const uint32_t RESERVED	: 6;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_EXTI_0_IO_t;
N
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile const uint32_t GPA00		: 1;		 
N		__I uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile const uint32_t GPA01		: 1;		 
N		__I uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile const uint32_t GPA02		: 1;		 
N		__I uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile const uint32_t GPA03		: 1;		 
N		__I uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile const uint32_t GPA04		: 1;		 
N		__I uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile const uint32_t GPA05		: 1;		 
N		__I uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile const uint32_t GPA06		: 1;		 
N		__I uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile const uint32_t GPA07		: 1;		 
N		__I uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile const uint32_t GPA08		: 1;		 
N		__I uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile const uint32_t GPA09		: 1;		 
N		__I uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile const uint32_t GPA10		: 1;		 
N		__I uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile const uint32_t GPA11		: 1;		 
N		__I uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile const uint32_t GPA24		: 1;		 
N		__I uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile const uint32_t GPA25		: 1;		 
N		__I uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile const uint32_t GPA26		: 1;		 
N		__I uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile const uint32_t GPA27		: 1;		 
N		__I uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile const uint32_t GPA28		: 1;		 
N		__I uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile const uint32_t GPA29		: 1;		 
N		__I uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile const uint32_t GPA30		: 1;		 
N		__I uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile const uint32_t GPA31		: 1;		 
N		__I uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile const uint32_t GPA32		: 1;		 
N		__I uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile const uint32_t GPA33		: 1;		 
N		__I uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile const uint32_t GPA34		: 1;		 
N		__I uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile const uint32_t GPA35		: 1;		 
N		__I uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile const uint32_t GPA36		: 1;		 
N		__I uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile const uint32_t GPA37		: 1;		 
N		__I uint32_t RESERVED	: 6;
X		volatile const uint32_t RESERVED	: 6;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tGPIO_EXTI_0_I_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t GPA00		: 1;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 1;		 
N		__O uint32_t GPA01		: 1;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 1;		 
N		__O uint32_t GPA02		: 1;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 1;		 
N		__O uint32_t GPA03		: 1;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 1;		 
N		__O uint32_t GPA04		: 1;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 1;		 
N		__O uint32_t GPA05		: 1;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 1;		 
N		__O uint32_t GPA06		: 1;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 1;		 
N		__O uint32_t GPA07		: 1;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 1;		 
N		__O uint32_t GPA08		: 1;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 1;		 
N		__O uint32_t GPA09		: 1;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 1;		 
N		__O uint32_t GPA10		: 1;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 1;		 
N		__O uint32_t GPA11		: 1;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 1;		 
N		__O uint32_t GPA24		: 1;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 1;		 
N		__O uint32_t GPA25		: 1;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 1;		 
N		__O uint32_t GPA26		: 1;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 1;		 
N		__O uint32_t GPA27		: 1;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 1;		 
N		__O uint32_t GPA28		: 1;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 1;		 
N		__O uint32_t GPA29		: 1;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 1;		 
N		__O uint32_t GPA30		: 1;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 1;		 
N		__O uint32_t GPA31		: 1;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 1;		 
N		__O uint32_t GPA32		: 1;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 1;		 
N		__O uint32_t GPA33		: 1;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 1;		 
N		__O uint32_t GPA34		: 1;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 1;		 
N		__O uint32_t GPA35		: 1;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 1;		 
N		__O uint32_t GPA36		: 1;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 1;		 
N		__O uint32_t GPA37		: 1;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 1;		 
N		__I uint32_t RESERVED	: 6;
X		volatile const uint32_t RESERVED	: 6;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tGPIO_EXTI_0_O_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 1;		 
N		__IO uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 1;		 
N		__IO uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 1;		 
N		__IO uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 1;		 
N		__IO uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 1;		 
N		__IO uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 1;		 
N		__IO uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 1;		 
N		__IO uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 1;		 
N		__IO uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 1;		 
N		__IO uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 1;		 
N		__IO uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 1;		 
N		__IO uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 1;		 
N		__IO uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 1;		 
N		__IO uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 1;		 
N		__IO uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 1;		 
N		__IO uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 1;		 
N		__IO uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 1;		 
N		__IO uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 1;		 
N		__IO uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 1;		 
N		__IO uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 1;		 
N		__IO uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 1;		 
N		__IO uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 1;		 
N		__IO uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 1;		 
N		__IO uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 1;		 
N//		__I uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 4;
N		__I uint32_t RESERVED	: 8;
X		volatile const uint32_t RESERVED	: 8;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_EXTI_1_IO_t;
N
Ntypedef union
N{
N	struct
N	{
N		__I uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile const uint32_t GPA12		: 1;		 
N		__I uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile const uint32_t GPA13		: 1;		 
N		__I uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile const uint32_t GPA14		: 1;		 
N		__I uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile const uint32_t GPA15		: 1;		 
N		__I uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile const uint32_t GPA16		: 1;		 
N		__I uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile const uint32_t GPA17		: 1;		 
N		__I uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile const uint32_t GPA18		: 1;		 
N		__I uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile const uint32_t GPA19		: 1;		 
N		__I uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile const uint32_t GPA20		: 1;		 
N		__I uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile const uint32_t GPA21		: 1;		 
N		__I uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile const uint32_t GPA22		: 1;		 
N		__I uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile const uint32_t GPA23		: 1;		 
N		__I uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile const uint32_t GPB00		: 1;		 
N		__I uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile const uint32_t GPB01		: 1;		 
N		__I uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile const uint32_t GPB02		: 1;		 
N		__I uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile const uint32_t GPB03		: 1;		 
N		__I uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile const uint32_t GPB04		: 1;		 
N		__I uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile const uint32_t GPB05		: 1;		 
N		__I uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile const uint32_t GPB06		: 1;		 
N		__I uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile const uint32_t GPB07		: 1;		 
N		__I uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile const uint32_t GPB08		: 1;		 
N		__I uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile const uint32_t GPB09		: 1;		 
N		__I uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile const uint32_t GPB10		: 1;		 
N		__I uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile const uint32_t GPB11		: 1;		 
N//		__I uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 4;
N		__I uint32_t RESERVED	: 8;
X		volatile const uint32_t RESERVED	: 8;
N	} tBit;
N	__I uint32_t ulBulk;
X	volatile const uint32_t ulBulk;
N} tGPIO_EXTI_1_I_t;
N
Ntypedef union
N{
N	struct
N	{
N		__O uint32_t GPA12		: 1;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 1;		 
N		__O uint32_t GPA13		: 1;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 1;		 
N		__O uint32_t GPA14		: 1;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 1;		 
N		__O uint32_t GPA15		: 1;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 1;		 
N		__O uint32_t GPA16		: 1;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 1;		 
N		__O uint32_t GPA17		: 1;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 1;		 
N		__O uint32_t GPA18		: 1;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 1;		 
N		__O uint32_t GPA19		: 1;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 1;		 
N		__O uint32_t GPA20		: 1;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 1;		 
N		__O uint32_t GPA21		: 1;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 1;		 
N		__O uint32_t GPA22		: 1;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 1;		 
N		__O uint32_t GPA23		: 1;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 1;		 
N		__O uint32_t GPB00		: 1;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 1;		 
N		__O uint32_t GPB01		: 1;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 1;		 
N		__O uint32_t GPB02		: 1;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 1;		 
N		__O uint32_t GPB03		: 1;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 1;		 
N		__O uint32_t GPB04		: 1;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 1;		 
N		__O uint32_t GPB05		: 1;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 1;		 
N		__O uint32_t GPB06		: 1;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 1;		 
N		__O uint32_t GPB07		: 1;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 1;		 
N		__O uint32_t GPB08		: 1;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 1;		 
N		__O uint32_t GPB09		: 1;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 1;		 
N		__O uint32_t GPB10		: 1;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 1;		 
N		__O uint32_t GPB11		: 1;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 1;		 
N//		__O uint32_t GPB12		: 1;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 1;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 1;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 1;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 4;
N		__I uint32_t RESERVED	: 8;
X		volatile const uint32_t RESERVED	: 8;
N	} tBit;
N	__O uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_EXTI_1_O_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA00		: 2;		/* GPIOA_00 */
X		volatile uint32_t GPA00		: 2;		 
N		__IO uint32_t GPA01		: 2;		/* GPIOA_01 */
X		volatile uint32_t GPA01		: 2;		 
N		__IO uint32_t GPA02		: 2;		/* GPIOA_02 */
X		volatile uint32_t GPA02		: 2;		 
N		__IO uint32_t GPA03		: 2;		/* GPIOA_03 */
X		volatile uint32_t GPA03		: 2;		 
N		__IO uint32_t GPA04		: 2;		/* GPIOA_04 */
X		volatile uint32_t GPA04		: 2;		 
N		__IO uint32_t GPA05		: 2;		/* GPIOA_05 */
X		volatile uint32_t GPA05		: 2;		 
N		__IO uint32_t GPA06		: 2;		/* GPIOA_06 */
X		volatile uint32_t GPA06		: 2;		 
N		__IO uint32_t GPA07		: 2;		/* GPIOA_07 */
X		volatile uint32_t GPA07		: 2;		 
N		__IO uint32_t GPA08		: 2;		/* GPIOA_08 */
X		volatile uint32_t GPA08		: 2;		 
N		__IO uint32_t GPA09		: 2;		/* GPIOA_09 */
X		volatile uint32_t GPA09		: 2;		 
N		__IO uint32_t GPA10		: 2;		/* GPIOA_10 */
X		volatile uint32_t GPA10		: 2;		 
N		__IO uint32_t GPA11		: 2;		/* GPIOA_11 */
X		volatile uint32_t GPA11		: 2;		 
N		__IO uint32_t GPA12		: 2;		/* GPIOA_12 */
X		volatile uint32_t GPA12		: 2;		 
N		__IO uint32_t GPA13		: 2;		/* GPIOA_13 */
X		volatile uint32_t GPA13		: 2;		 
N		__IO uint32_t GPA14		: 2;		/* GPIOA_14 */
X		volatile uint32_t GPA14		: 2;		 
N		__IO uint32_t GPA15		: 2;		/* GPIOA_15 */
X		volatile uint32_t GPA15		: 2;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_0_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA16		: 2;		/* GPIOA_16 */
X		volatile uint32_t GPA16		: 2;		 
N		__IO uint32_t GPA17		: 2;		/* GPIOA_17 */
X		volatile uint32_t GPA17		: 2;		 
N		__IO uint32_t GPA18		: 2;		/* GPIOA_18 */
X		volatile uint32_t GPA18		: 2;		 
N		__IO uint32_t GPA19		: 2;		/* GPIOA_19 */
X		volatile uint32_t GPA19		: 2;		 
N		__IO uint32_t GPA20		: 2;		/* GPIOA_20 */
X		volatile uint32_t GPA20		: 2;		 
N		__IO uint32_t GPA21		: 2;		/* GPIOA_21 */
X		volatile uint32_t GPA21		: 2;		 
N		__IO uint32_t GPA22		: 2;		/* GPIOA_22 */
X		volatile uint32_t GPA22		: 2;		 
N		__IO uint32_t GPA23		: 2;		/* GPIOA_23 */
X		volatile uint32_t GPA23		: 2;		 
N		__IO uint32_t GPA24		: 2;		/* GPIOA_24 */
X		volatile uint32_t GPA24		: 2;		 
N		__IO uint32_t GPA25		: 2;		/* GPIOA_25 */
X		volatile uint32_t GPA25		: 2;		 
N		__IO uint32_t GPA26		: 2;		/* GPIOA_26 */
X		volatile uint32_t GPA26		: 2;		 
N		__IO uint32_t GPA27		: 2;		/* GPIOA_27 */
X		volatile uint32_t GPA27		: 2;		 
N		__IO uint32_t GPA28		: 2;		/* GPIOA_28 */
X		volatile uint32_t GPA28		: 2;		 
N		__IO uint32_t GPA29		: 2;		/* GPIOA_29 */
X		volatile uint32_t GPA29		: 2;		 
N		__IO uint32_t GPA30		: 2;		/* GPIOA_30 */
X		volatile uint32_t GPA30		: 2;		 
N		__IO uint32_t GPA31		: 2;		/* GPIOA_31 */
X		volatile uint32_t GPA31		: 2;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_1_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPA32		: 2;		/* GPIOA_32 */
X		volatile uint32_t GPA32		: 2;		 
N		__IO uint32_t GPA33		: 2;		/* GPIOA_33 */
X		volatile uint32_t GPA33		: 2;		 
N		__IO uint32_t GPA34		: 2;		/* GPIOA_34 */
X		volatile uint32_t GPA34		: 2;		 
N		__IO uint32_t GPA35		: 2;		/* GPIOA_35 */
X		volatile uint32_t GPA35		: 2;		 
N		__IO uint32_t GPA36		: 2;		/* GPIOA_36 */
X		volatile uint32_t GPA36		: 2;		 
N		__IO uint32_t GPA37		: 2;		/* GPIOA_37 */
X		volatile uint32_t GPA37		: 2;		 
N		__IO uint32_t GPB00		: 2;		/* GPIOB_00 */
X		volatile uint32_t GPB00		: 2;		 
N		__IO uint32_t GPB01		: 2;		/* GPIOB_01 */
X		volatile uint32_t GPB01		: 2;		 
N		__IO uint32_t GPB02		: 2;		/* GPIOB_02 */
X		volatile uint32_t GPB02		: 2;		 
N		__IO uint32_t GPB03		: 2;		/* GPIOB_03 */
X		volatile uint32_t GPB03		: 2;		 
N		__IO uint32_t GPB04		: 2;		/* GPIOB_04 */
X		volatile uint32_t GPB04		: 2;		 
N		__IO uint32_t GPB05		: 2;		/* GPIOB_05 */
X		volatile uint32_t GPB05		: 2;		 
N		__IO uint32_t GPB06		: 2;		/* GPIOB_06 */
X		volatile uint32_t GPB06		: 2;		 
N		__IO uint32_t GPB07		: 2;		/* GPIOB_07 */
X		volatile uint32_t GPB07		: 2;		 
N		__IO uint32_t GPB08		: 2;		/* GPIOB_08 */
X		volatile uint32_t GPB08		: 2;		 
N		__IO uint32_t GPB09		: 2;		/* GPIOB_09 */
X		volatile uint32_t GPB09		: 2;		 
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_2_t;
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t GPB10		: 2;		/* GPIOB_10 */
X		volatile uint32_t GPB10		: 2;		 
N		__IO uint32_t GPB11		: 2;		/* GPIOB_11 */
X		volatile uint32_t GPB11		: 2;		 
N//		__I uint32_t GPB12		: 2;		/* GPIOB_12 */
N//		__I uint32_t GPB13		: 2;		/* GPIOB_13 */
N//		__I uint32_t GPB14		: 2;		/* GPIOB_14 */
N//		__I uint32_t GPB15		: 2;		/* GPIOB_15 */
N//		__I uint32_t RESERVED	: 20;
N		__I uint32_t RESERVED	: 28;
X		volatile const uint32_t RESERVED	: 28;
N	} tBit;
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N} tGPIO_AFIO_3_t;
N
Ntypedef struct
N{
N	/*
N	 * When AFIO is GPIO Mode, observe the external input and control the internal output value
N	 * At Read operation : Observe the external input value
N	 * At Write operation : Control the internal output value (0:Low, 1:High)
N	 */
N	tGPIO_PIN_0_t tGPIO_DATA_0;
N	tGPIO_PIN_1_t tGPIO_DATA_1;
N	/*
N	 * When AFIO is GPIO Mode, configuration the input/output of GPIO Pins
N	 * 0 : Set as Input
N	 * 1 : Set as Output
N	 */
N	tGPIO_PIN_0_t tGPIO_DIR_0;
N	tGPIO_PIN_1_t tGPIO_DIR_1;
N	/*
N	 * Open Drain Control
N	 * 0 : Disable
N	 * 1 : Enable
N	 */
N	tGPIO_PIN_0_t tGPIO_OD_0;
N	tGPIO_PIN_1_t tGPIO_OD_1;
N	/*
N	 * Control the Pull-Up function
N	 * 0 : Disable Pull-Up function
N	 * 1 : Enable Pull-Up function
N	 */
N	tGPIO_PIN_0_t tGPIO_PU_0;
N	tGPIO_PIN_1_t tGPIO_PU_1;
N	/*
N	 * Control the Pull-Down function
N	 * 0 : Disable Pull-Down function
N	 * 1 : Enable Pull-Down function
N	 */
N	tGPIO_PIN_0_t tGPIO_PD_0;
N	tGPIO_PIN_1_t tGPIO_PD_1;
N	/*
N	 * GPIO interrupt Detection control
N	 * 0 : Edge Detection
N	 * 1 : Level Detection
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IS;
N	/*
N	 * GPIO interrupt edge control
N	 * 0 : Single Edge
N	 * 1 : Both Edge
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IBE;
N	/*
N	 * GPIO interrupt direction control
N	 * 0 : Negative Edge / Low Level
N	 * 1 : Positive Edge / High Level
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IEV;
N	/*
N	 * Set the Interrupt operation
N	 * 0 : Disable Interrupt
N	 * 1 : Enable Interrupt
N	 */
N	tGPIO_EXTI_0_IO_t tGPIO_EXTI0_IE;
N	/*
N	 * GPIO raw interrupt status from
N	 */
N	tGPIO_EXTI_0_I_t tGPIO_EXTI0_RIS;
N	/*
N	 * GPIO masked interrupt status from
N	 */
N	tGPIO_EXTI_0_I_t tGPIO_EXTI0_MIS;
N	/*
N	 * GPIO interrupt clear register
N	 */
N	tGPIO_EXTI_0_O_t tGPIO_EXTI0_INTC;
N
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IS;
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IBE;
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IEV;
N	tGPIO_EXTI_1_IO_t tGPIO_EXTI1_IE;
N	tGPIO_EXTI_1_I_t tGPIO_EXTI1_RIS;
N	tGPIO_EXTI_1_I_t tGPIO_EXTI1_MIS;
N	tGPIO_EXTI_1_O_t tGPIO_EXTI1_INTC;
N
N	tGPIO_AFIO_0_t tGPIO_AFIO_0;
N	tGPIO_AFIO_1_t tGPIO_AFIO_1;
N	tGPIO_AFIO_2_t tGPIO_AFIO_2;
N	tGPIO_AFIO_3_t tGPIO_AFIO_3;
N
N	tGPIO_PIN_0_t tGPIO_IE0;
N	tGPIO_PIN_1_t tGPIO_IE1;
N
N	tGPIO_PIN_0_t tGPIO_P2_0;
N	tGPIO_PIN_1_t tGPIO_P2_1;
N
N	tGPIO_PIN_0_t tGPIO_P1_0;
N	tGPIO_PIN_1_t tGPIO_P1_1;
N
N	tGPIO_PIN_0_t tGPIO_SMT_0;
N	tGPIO_PIN_1_t tGPIO_SMT_1;
N
N} tGPIO_CtrlReg_t;
N
N
N#endif /* __GPIO_H_ */
L 279 "..\..\Hal\system\MFTP.h" 2
N#include "_timer.h"
L 1 "..\..\Hal\timer\_timer.h" 1
N
N/****************************************************************************************************//**
N * @file     timer.h
N *
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File for
N *           default TIGER Device Series
N *
N * @version  Vrev.B
N * @date     19. April 2013
N *
N * @note     Generated with SVDConv V2.73b  on Friday, 19.04.2013 19:56:29
N *           from CMSIS SVD File 'LDC1004A_TIGER_svd.xml' Version rev.B,
N *           created on Monday, 08.04.2013 08:30:30, last modified on Friday, 19.04.2013 10:55:20
N *
N * @par      ARM Limited (ARM) is supplying this software for use with Cortex-M
N *           processor based microcontroller, but can be equally used for other
N *           suitable processor architectures. This file can be freely distributed.
N *           Modifications to this file shall be clearly marked.
N *           
N *           THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N *           OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N *           MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N *           ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N *           CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
N *
N *******************************************************************************************************/
N
N
N/* ================================================================================ */
N/* ================                     TIMER                      ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  Flash Control Register
N */
N
N
Nextern uint8_t TMA0_cnt;
Nextern uint8_t TMB0_cnt;
Nextern uint8_t TMA1_cnt;
Nextern uint8_t TMB1_cnt;
N
Nextern uint8_t mode;
N
N
N
N
Ntypedef struct
N{
N    //-----------------------------------
N    //              Timer0
N    //-----------------------------------
N    union {   // 0x00 : Timer0
N	    __IO uint32_t	Timer0_LoadCount_CR;        // Timer0 Load Count CR 
X	    volatile uint32_t	Timer0_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer0_LoadCount      : 32; // Timer0 Load Count 
X          volatile uint32_t Timer0_LoadCount      : 32; 
N      } Timer0_LoadCount_R_b;
N    } ;
N
N    union {   // 0x04 : Timer0
N	    __IO uint32_t	Timer0_CurrentValue_SR;     // Timer0 CurrentValue SR
X	    volatile uint32_t	Timer0_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer0_CurrentValue   : 32; // Timer0 CurrentValue 
X          volatile uint32_t Timer0_CurrentValue   : 32; 
N      } Timer0_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x08 : Timer0
N	    __IO uint32_t	Timer0_CR;                  // Timer0 CR
X	    volatile uint32_t	Timer0_CR;                  
N
N      struct {
N          __IO uint32_t Timer0_En             : 1;  // Timer0 Enable 
X          volatile uint32_t Timer0_En             : 1;  
N          __IO uint32_t Timer0_Mode           : 1;  // Timer0 Mode         
X          volatile uint32_t Timer0_Mode           : 1;  
N          __IO uint32_t Timer0_InterruptMask  : 1;  // Timer0 InterruptMask
X          volatile uint32_t Timer0_InterruptMask  : 1;  
N      } Timer0_CR_b;
N    } ;
N
N    union {   // 0x0C : Timer0
N	    __IO uint32_t	Timer0_EOI_SR;              // Timer0 End of Interrupt SR
X	    volatile uint32_t	Timer0_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer0_EOI            : 1;  // Timer0 EOI 
X          volatile uint32_t Timer0_EOI            : 1;  
N      } Timer0_EOI_SR_b;
N    } ;
N
N    union {   // 0x10 : Timer0
N	    __IO uint32_t	Timer0_Int_SR;              // Timer0 Interrupt SR
X	    volatile uint32_t	Timer0_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer0_Int            : 1;  // Timer0 Interrupt
X          volatile uint32_t Timer0_Int            : 1;  
N      } Timer0_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer1
N    //-----------------------------------
N    union {   // 0x14 : Timer1
N	    __IO uint32_t	Timer1_LoadCount_CR;        // Timer1 Load Count CR 
X	    volatile uint32_t	Timer1_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer1_LoadCount      : 32; // Timer1 Load Count 
X          volatile uint32_t Timer1_LoadCount      : 32; 
N      } Timer1_LoadCount_R_b;
N    } ;
N
N    union {   // 0x18 : Timer1
N	    __IO uint32_t	Timer1_CurrentValue_SR;     // Timer1 CurrentValue SR
X	    volatile uint32_t	Timer1_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer1_CurrentValue   : 32; // Timer1 CurrentValue 
X          volatile uint32_t Timer1_CurrentValue   : 32; 
N      } Timer1_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x1C : Timer1
N	    __IO uint32_t	Timer1_CR;                  // Timer1 CR
X	    volatile uint32_t	Timer1_CR;                  
N
N      struct {
N          __IO uint32_t Timer1_En             : 1;  // Timer1 Enable 
X          volatile uint32_t Timer1_En             : 1;  
N          __IO uint32_t Timer1_Mode           : 1;  // Timer1 Mode         
X          volatile uint32_t Timer1_Mode           : 1;  
N          __IO uint32_t Timer1_InterruptMask  : 1;  // Timer1 InterruptMask
X          volatile uint32_t Timer1_InterruptMask  : 1;  
N      } Timer1_CR_b;
N    } ;
N
N    union {   // 0x20 : Timer1
N	    __IO uint32_t	Timer1_EOI_SR;              // Timer1 End of Interrupt SR
X	    volatile uint32_t	Timer1_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer1_EOI            : 1;  // Timer1 EOI 
X          volatile uint32_t Timer1_EOI            : 1;  
N      } Timer1_EOI_SR_b;
N    } ;
N
N    union {   // 0x24 : Timer1
N	    __IO uint32_t	Timer1_Int_SR;              // Timer1 Interrupt SR
X	    volatile uint32_t	Timer1_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer1_Int            : 1;  // Timer1 Interrupt
X          volatile uint32_t Timer1_Int            : 1;  
N      } Timer1_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer2
N    //-----------------------------------
N    union {   // 0x28 : Timer2
N	    __IO uint32_t	Timer2_LoadCount_CR;        // Timer2 Load Count CR 
X	    volatile uint32_t	Timer2_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer2_LoadCount      : 32; // Timer2 Load Count 
X          volatile uint32_t Timer2_LoadCount      : 32; 
N      } Timer2_LoadCount_R_b;
N    } ;
N
N    union {   // 0x2C : Timer2
N	    __IO uint32_t	Timer2_CurrentValue_SR;     // Timer2 CurrentValue SR
X	    volatile uint32_t	Timer2_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer2_CurrentValue   : 32; // Timer2 CurrentValue 
X          volatile uint32_t Timer2_CurrentValue   : 32; 
N      } Timer2_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x30 : Timer2
N	    __IO uint32_t	Timer2_CR;                  // Timer2 CR
X	    volatile uint32_t	Timer2_CR;                  
N
N      struct {
N          __IO uint32_t Timer2_En             : 1;  // Timer2 Enable 
X          volatile uint32_t Timer2_En             : 1;  
N          __IO uint32_t Timer2_Mode           : 1;  // Timer2 Mode         
X          volatile uint32_t Timer2_Mode           : 1;  
N          __IO uint32_t Timer2_InterruptMask  : 1;  // Timer2 InterruptMask
X          volatile uint32_t Timer2_InterruptMask  : 1;  
N      } Timer2_CR_b;
N    } ;
N
N    union {   // 0x34 : Timer2
N	    __IO uint32_t	Timer2_EOI_SR;              // Timer2 End of Interrupt SR
X	    volatile uint32_t	Timer2_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer2_EOI            : 1;  // Timer2 EOI 
X          volatile uint32_t Timer2_EOI            : 1;  
N      } Timer2_EOI_SR_b;
N    } ;
N
N    union {   // 0x38 : Timer2
N	    __IO uint32_t	Timer2_Int_SR;              // Timer2 Interrupt SR
X	    volatile uint32_t	Timer2_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer2_Int            : 1;  // Timer2 Interrupt
X          volatile uint32_t Timer2_Int            : 1;  
N      } Timer2_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer3
N    //-----------------------------------
N    union {   // 0x3C : Timer3
N	    __IO uint32_t	Timer3_LoadCount_CR;        // Timer3 Load Count CR 
X	    volatile uint32_t	Timer3_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer3_LoadCount      : 32; // Timer3 Load Count 
X          volatile uint32_t Timer3_LoadCount      : 32; 
N      } Timer3_LoadCount_R_b;
N    } ;
N
N    union {   // 0x40 : Timer3
N	    __IO uint32_t	Timer3_CurrentValue_SR;     // Timer3 CurrentValue SR
X	    volatile uint32_t	Timer3_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer3_CurrentValue   : 32; // Timer3 CurrentValue 
X          volatile uint32_t Timer3_CurrentValue   : 32; 
N      } Timer3_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x44 : Timer3
N	    __IO uint32_t	Timer3_CR;                  // Timer3 CR
X	    volatile uint32_t	Timer3_CR;                  
N
N      struct {
N          __IO uint32_t Timer3_En             : 1;  // Timer3 Enable 
X          volatile uint32_t Timer3_En             : 1;  
N          __IO uint32_t Timer3_Mode           : 1;  // Timer3 Mode         
X          volatile uint32_t Timer3_Mode           : 1;  
N          __IO uint32_t Timer3_InterruptMask  : 1;  // Timer3 InterruptMask
X          volatile uint32_t Timer3_InterruptMask  : 1;  
N      } Timer3_CR_b;
N    } ;
N
N    union {   // 0x48 : Timer3
N	    __IO uint32_t	Timer3_EOI_SR;              // Timer3 End of Interrupt SR
X	    volatile uint32_t	Timer3_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer3_EOI            : 1;  // Timer3 EOI 
X          volatile uint32_t Timer3_EOI            : 1;  
N      } Timer3_EOI_SR_b;
N    } ;
N
N    union {   // 0x4C : Timer3
N	    __IO uint32_t	Timer3_Int_SR;              // Timer3 Interrupt SR
X	    volatile uint32_t	Timer3_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer3_Int            : 1;  // Timer3 Interrupt
X          volatile uint32_t Timer3_Int            : 1;  
N      } Timer3_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer4
N    //-----------------------------------
N    union {   // 0x50 : Timer4
N	    __IO uint32_t	Timer4_LoadCount_CR;        // Timer4 Load Count CR 
X	    volatile uint32_t	Timer4_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer4_LoadCount      : 32; // Timer4 Load Count 
X          volatile uint32_t Timer4_LoadCount      : 32; 
N      } Timer4_LoadCount_R_b;
N    } ;
N
N    union {   // 0x54 : Timer4
N	    __IO uint32_t	Timer4_CurrentValue_SR;     // Timer4 CurrentValue SR
X	    volatile uint32_t	Timer4_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer4_CurrentValue   : 32; // Timer4 CurrentValue 
X          volatile uint32_t Timer4_CurrentValue   : 32; 
N      } Timer4_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x58 : Timer4
N	    __IO uint32_t	Timer4_CR;                  // Timer4 CR
X	    volatile uint32_t	Timer4_CR;                  
N
N      struct {
N          __IO uint32_t Timer4_En             : 1;  // Timer4 Enable 
X          volatile uint32_t Timer4_En             : 1;  
N          __IO uint32_t Timer4_Mode           : 1;  // Timer4 Mode         
X          volatile uint32_t Timer4_Mode           : 1;  
N          __IO uint32_t Timer4_InterruptMask  : 1;  // Timer4 InterruptMask
X          volatile uint32_t Timer4_InterruptMask  : 1;  
N      } Timer4_CR_b;
N    } ;
N
N    union {   // 0x5C : Timer4
N	    __IO uint32_t	Timer4_EOI_SR;              // Timer4 End of Interrupt SR
X	    volatile uint32_t	Timer4_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer4_EOI            : 1;  // Timer4 EOI 
X          volatile uint32_t Timer4_EOI            : 1;  
N      } Timer4_EOI_SR_b;
N    } ;
N
N    union {   // 0x60 : Timer4
N	    __IO uint32_t	Timer4_Int_SR;              // Timer4 Interrupt SR
X	    volatile uint32_t	Timer4_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer4_Int            : 1;  // Timer4 Interrupt
X          volatile uint32_t Timer4_Int            : 1;  
N      } Timer4_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer5
N    //-----------------------------------
N    union {   // 0x64 : Timer5
N	    __IO uint32_t	Timer5_LoadCount_CR;        // Timer5 Load Count CR 
X	    volatile uint32_t	Timer5_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer5_LoadCount      : 32; // Timer5 Load Count 
X          volatile uint32_t Timer5_LoadCount      : 32; 
N      } Timer5_LoadCount_R_b;
N    } ;
N
N    union {   // 0x68 : Timer5
N	    __IO uint32_t	Timer5_CurrentValue_SR;     // Timer5 CurrentValue SR
X	    volatile uint32_t	Timer5_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer5_CurrentValue   : 32; // Timer5 CurrentValue 
X          volatile uint32_t Timer5_CurrentValue   : 32; 
N      } Timer5_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x6C : Timer5
N	    __IO uint32_t	Timer5_CR;                  // Timer5 CR
X	    volatile uint32_t	Timer5_CR;                  
N
N      struct {
N          __IO uint32_t Timer5_En             : 1;  // Timer5 Enable 
X          volatile uint32_t Timer5_En             : 1;  
N          __IO uint32_t Timer5_Mode           : 1;  // Timer5 Mode         
X          volatile uint32_t Timer5_Mode           : 1;  
N          __IO uint32_t Timer5_InterruptMask  : 1;  // Timer5 InterruptMask
X          volatile uint32_t Timer5_InterruptMask  : 1;  
N      } Timer5_CR_b;
N    } ;
N
N    union {   // 0x70 : Timer5
N	    __IO uint32_t	Timer5_EOI_SR;              // Timer5 End of Interrupt SR
X	    volatile uint32_t	Timer5_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer5_EOI            : 1;  // Timer5 EOI 
X          volatile uint32_t Timer5_EOI            : 1;  
N      } Timer5_EOI_SR_b;
N    } ;
N
N    union {   // 0x74 : Timer5
N	    __IO uint32_t	Timer5_Int_SR;              // Timer5 Interrupt SR
X	    volatile uint32_t	Timer5_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer5_Int            : 1;  // Timer5 Interrupt
X          volatile uint32_t Timer5_Int            : 1;  
N      } Timer5_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //              Timer6
N    //-----------------------------------
N    union {   // 0x78 : Timer6
N	    __IO uint32_t	Timer6_LoadCount_CR;        // Timer6 Load Count CR 
X	    volatile uint32_t	Timer6_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer6_LoadCount      : 32; // Timer6 Load Count 
X          volatile uint32_t Timer6_LoadCount      : 32; 
N      } Timer6_LoadCount_R_b;
N    } ;
N
N    union {   // 0x7C : Timer6
N	    __IO uint32_t	Timer6_CurrentValue_SR;     // Timer6 CurrentValue SR
X	    volatile uint32_t	Timer6_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer6_CurrentValue   : 32; // Timer6 CurrentValue 
X          volatile uint32_t Timer6_CurrentValue   : 32; 
N      } Timer6_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x80 : Timer6
N	    __IO uint32_t	Timer6_CR;                  // Timer6 CR
X	    volatile uint32_t	Timer6_CR;                  
N
N      struct {
N          __IO uint32_t Timer6_En             : 1;  // Timer6 Enable 
X          volatile uint32_t Timer6_En             : 1;  
N          __IO uint32_t Timer6_Mode           : 1;  // Timer6 Mode         
X          volatile uint32_t Timer6_Mode           : 1;  
N          __IO uint32_t Timer6_InterruptMask  : 1;  // Timer6 InterruptMask
X          volatile uint32_t Timer6_InterruptMask  : 1;  
N      } Timer6_CR_b;
N    } ;
N
N    union {   // 0x84 : Timer6
N	    __IO uint32_t	Timer6_EOI_SR;              // Timer6 End of Interrupt SR
X	    volatile uint32_t	Timer6_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer6_EOI            : 1;  // Timer6 EOI 
X          volatile uint32_t Timer6_EOI            : 1;  
N      } Timer6_EOI_SR_b;
N    } ;
N
N    union {   // 0x88 : Timer6
N	    __IO uint32_t	Timer6_Int_SR;              // Timer6 Interrupt SR
X	    volatile uint32_t	Timer6_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer6_Int            : 1;  // Timer6 Interrupt
X          volatile uint32_t Timer6_Int            : 1;  
N      } Timer6_Int_SR_b;
N    } ;
N
N    
N    //-----------------------------------
N    //              Timer7
N    //-----------------------------------
N    union {   // 0x8C : Timer7
N	    __IO uint32_t	Timer7_LoadCount_CR;        // Timer7 Load Count CR 
X	    volatile uint32_t	Timer7_LoadCount_CR;        
N
N      struct {
N          __IO uint32_t Timer7_LoadCount      : 32; // Timer7 Load Count 
X          volatile uint32_t Timer7_LoadCount      : 32; 
N      } Timer7_LoadCount_R_b;
N    } ;
N
N    union {   // 0x90 : Timer7
N	    __IO uint32_t	Timer7_CurrentValue_SR;     // Timer7 CurrentValue SR
X	    volatile uint32_t	Timer7_CurrentValue_SR;     
N
N      struct {
N          __IO uint32_t Timer7_CurrentValue   : 32; // Timer7 CurrentValue 
X          volatile uint32_t Timer7_CurrentValue   : 32; 
N      } Timer7_CurrentValue_SR_b;
N    } ;
N
N    union {   // 0x94 : Timer7
N	    __IO uint32_t	Timer7_CR;                  // Timer7 CR
X	    volatile uint32_t	Timer7_CR;                  
N
N      struct {
N          __IO uint32_t Timer7_En             : 1;  // Timer7 Enable 
X          volatile uint32_t Timer7_En             : 1;  
N          __IO uint32_t Timer7_Mode           : 1;  // Timer7 Mode         
X          volatile uint32_t Timer7_Mode           : 1;  
N          __IO uint32_t Timer7_InterruptMask  : 1;  // Timer7 InterruptMask
X          volatile uint32_t Timer7_InterruptMask  : 1;  
N      } Timer7_CR_b;
N    } ;
N
N    union {   // 0x98 : Timer7
N	    __IO uint32_t	Timer7_EOI_SR;              // Timer7 End of Interrupt SR
X	    volatile uint32_t	Timer7_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timer7_EOI            : 1;  // Timer7 EOI 
X          volatile uint32_t Timer7_EOI            : 1;  
N      } Timer7_EOI_SR_b;
N    } ;
N
N    union {   // 0x9C : Timer7
N	    __IO uint32_t	Timer7_Int_SR;              // Timer7 Interrupt SR
X	    volatile uint32_t	Timer7_Int_SR;              
N
N      struct {
N          __IO uint32_t Timer7_Int            : 1;  // Timer7 Interrupt
X          volatile uint32_t Timer7_Int            : 1;  
N      } Timer7_Int_SR_b;
N    } ;
N
N
N    //-----------------------------------
N    //    Global Status Register 
N    //-----------------------------------
N    union {   // 0xA0 : Global Status Register 
N	    __IO uint32_t	Timers_Int_SR;              // Timers Interrupt SR
X	    volatile uint32_t	Timers_Int_SR;              
N
N      struct {
N          __IO uint32_t Timers_Int            : 8;  // Timers Interrupt
X          volatile uint32_t Timers_Int            : 8;  
N      } Timers_Int_SR_b;
N    } ;
N
N    union {   // 0xA4 : Global Status Register 
N	    __IO uint32_t	Timers_EOI_SR;              // Timers End of Interrupt SR
X	    volatile uint32_t	Timers_EOI_SR;              
N
N      struct {
N          __IO uint32_t Timers_EOI            : 8;  // Timers EOI
X          volatile uint32_t Timers_EOI            : 8;  
N      } Timers_EOI_SR_b;
N    } ;
N
N    union {   // 0xA8 : Global Status Register 
N	    __IO uint32_t	Timers_RawInt_SR;           // Timers Raw Interrupt SR
X	    volatile uint32_t	Timers_RawInt_SR;           
N
N      struct {
N          __IO uint32_t Timers_RawInt         : 8;  // Timers Raw Interrupt 
X          volatile uint32_t Timers_RawInt         : 8;  
N      } Timers_RawInt_SR_b;
N    } ;
N
N    union {   // 0xAC : Global Status Register 
N	    __IO uint32_t	Timers_Comp_Version_SR;     // Current Verion number of the timers component SR
X	    volatile uint32_t	Timers_Comp_Version_SR;     
N
N      struct {
N          __IO uint32_t Timers_Comp_Version   : 32; // Current Verion number of the timers component 
X          volatile uint32_t Timers_Comp_Version   : 32; 
N      } Timers_Comp_Version_SR_b;
N    } ;
N
N
N}tTIMER_CtrlReg_t;
N
N
N
N
N//typedef struct
N//{
N////// A
N//    union {
N//	    __IO uint32_t	TCLR0A;			     //	 Timer0 A Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0AClr : 1; // Timer0 A Clear 
N//      } TCLR0A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON0A;			     //	 Timer0 A Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0AEn     : 1; // Timer0 A Enable
N//          __IO uint32_t Tm0AIntrEn : 1; // Timer0 A Interrupt Enable
N//          __IO uint32_t Tm0AClkSel : 2; // Timer0 A Clock Select
N//          __IO uint32_t Tm0AMode   : 2; // Timer0 A Mode Select
N//          __IO uint32_t Tm0ASize   : 2; // Timer0 A Counter Size Select
N//      } TCON0A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH0A;			     //	 Timer0 A Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0AWIDTH     : 32; // Timer0 A Period Width
N//      } TWIDTH0A_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD0A;			     //	 Timer0 A Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm0ACntLoad   : 32; // Timer0 A Counting Value
N//      } LOAD0A_b;
N//    } ;
N/////// B
N//    union {
N//	    __IO uint32_t	TCLR0B;			     //	 Timer0 B Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0BClr : 1; // Timer0 B Clear 
N//      } TCLR0B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON0B;			     //	 Timer0 B Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0BEn     : 1; // Timer0 B Enable
N//          __IO uint32_t Tm0BIntrEn : 1; // Timer0 B Interrupt Enable
N//          __IO uint32_t Tm0BClkSel : 2; // Timer0 B Clock Select
N//          __IO uint32_t Tm0BMode   : 2; // Timer0 B Mode Select
N//          __IO uint32_t Tm0BSize   : 2; // Timer0 B Counter Size Select
N//      } TCON0B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH0B;			     //	 Timer0 B Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm0BWIDTH     : 32; // Timer0 B Period Width
N//      } TWIDTH0B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD0B;			     //	 Timer0 B Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm0BCntLoad   : 32; // Timer0 B Counting Value
N//      } LOAD0B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPLOW0;			   //	 Capture0 Low Value
N//
N//      struct {
N//          __I uint32_t CaptureLow   : 32; // Timer  Counting High Value 0
N//      } CAPLOW0_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPHIGH0;			   //	 Capture0 High Value
N//
N//      struct {
N//          __I uint32_t CaptureHigh   : 32; // Timer Counting High Value 0
N//      } CAPHIGH0_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	PWMLOW0;			   //	 PWM Low Value0
N//
N//      struct {
N//          __IO uint32_t PWMLowWidth   : 32; // Timer PWM Low Width Value 0
N//      } PWMLOW0_b;
N//    } ;
N//
N//
N/////// 1
N////// A
N//    union {
N//	    __IO uint32_t	TCLR1A;			     //	 Timer1 A Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1AClr : 1; // Timer1 A Clear 
N//      } TCLR1A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON1A;			     //	 Timer1 A Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1AEn     : 1; // Timer1 A Enable
N//          __IO uint32_t Tm1AIntrEn : 1; // Timer1 A Interrupt Enable
N//          __IO uint32_t Tm1AClkSel : 2; // Timer1 A Clock Select
N//          __IO uint32_t Tm1AMode   : 2; // Timer1 A Mode Select
N//          __IO uint32_t Tm1ASize   : 2; // Timer1 A Counter Size Select
N//      } TCON1A_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH1A;			     //	 Timer1 A Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1AWIDTH     : 32; // Timer1 A Period Width
N//      } TWIDTH1A_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD1A;			     //	 Timer1 A Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm1ACntLoad   : 32; // Timer1 A Counting Value
N//      } LOAD1A_b;
N//    } ;
N/////// B
N//    union {
N//	    __IO uint32_t	TCLR1B;			     //	 Timer1 B Clear Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1BClr : 1; // Timer1 B Clear 
N//      } TCLR1B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TCON1B;			     //	 Timer1 B Control Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1BEn     : 1; // Timer1 B Enable
N//          __IO uint32_t Tm1BIntrEn : 1; // Timer1 B Interrupt Enable
N//          __IO uint32_t Tm1BClkSel : 2; // Timer1 B Clock Select
N//          __IO uint32_t Tm1BMode   : 2; // Timer1 B Mode Select
N//          __IO uint32_t Tm1BSize   : 2; // Timer1 B Counter Size Select
N//      } TCON1B_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	TWIDTH1B;			     //	 Timer1 B Count Width Regiser
N//
N//      struct {
N//          __IO uint32_t Tm1BWIDTH     : 32; // Timer1 B Period Width
N//      } TWIDTH1B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	LOAD1B;			     //	 Timer1 B Count Load Register
N//
N//      struct {
N//          __IO uint32_t Tm1BCntLoad   : 32; // Timer1 B Counting Value
N//      } LOAD1B_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPLOW1;			   //	 Capture1 Low Value
N//
N//      struct {
N//          __IO uint32_t CaptureLow   : 32; // Timer  Counting High Value 1
N//      } CAPLOW1_b;
N//    } ;
N//
N//    union {
N//	    __I uint32_t	CAPHIGH1;			   //	 Capture1 High Value
N//
N//      struct {
N//          __IO uint32_t CaptureHigh   : 32; // Timer Counting High Value 1
N//      } CAPHIGH1_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	PWMLOW1;			   //	 PWM Low Value1
N//
N//      struct {
N//          __IO uint32_t PWMLowWidth   : 32; // Timer PWM Low Width Value 1
N//      } PWMLOW1_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	CONFIG;			     //	 Timer Configuration Register
N//
N//      struct {
N//          __IO uint32_t  Tm0CapMode       : 1; // Timer0 Capture Mode 
N//          __IO uint32_t  Tm0PwmMode       : 1; // Timer0 Pulse Width Modulator Mode 
N//          __IO uint32_t  Tm1CapMode       : 1; // Timer1 Capture Mode 
N//          __IO uint32_t  Tm1PwmMode       : 1; // Timer1 Pulse Width Modulator Mode 
N//          __IO uint32_t  Tm0AIntrAutoClr  : 1; // Timer0 A Interrupt Auto Clear  
N//          __IO uint32_t  Tm0BIntrAutoClr  : 1; // Timer0 B Interrupt Auto Clear 
N//          __IO uint32_t  Tm1AIntrAutoClr  : 1; // Timer1 A Interrupt Auto Clear 
N//          __IO uint32_t  Tm1BIntrAutoClr  : 1; // Timer1 B Interrupt Auto Clear
N//      } CONFIG_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	LRAWINTSTATUS;    //	 Timer Raw Level Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0ARLIS       : 1; // Timer0 A Raw Level Interrupt Status
N//          __IO uint32_t  Tm0BRLIS       : 1; // Timer0 B Raw Leve1 Interrupt Status
N//          __IO uint32_t  Tm1ARLIS       : 1; // Timer1 A Raw Leve1 Interrupt Status
N//          __IO uint32_t  Tm1BRLIS       : 1; // Timer1 B Raw Level Interrupt Status
N//      } RAWLINTSTATUS_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	LINTSTATUS;	        //	 Timer Mask Level Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0AMLIS       : 1; // Timer0 A Mask Level Interrupt Status
N//          __IO uint32_t  Tm0BMLIS       : 1; // Timer0 B Mask Leve1 Interrupt Status
N//          __IO uint32_t  Tm1AMLIS       : 1; // Timer1 A Mask Leve1 Interrupt Status
N//          __IO uint32_t  Tm1BMLIS       : 1; // Timer1 B Mask Level Interrupt Status
N//      } LINTSTATUS_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	INTRMODE;	        //	 Timer Interrupt Mode Edeg : Level
N//
N//      struct {
N//          __IO uint32_t  Tm0AINTRMode         : 1; // Timer0 A Interrupt Detect Mode Select
N//          __IO uint32_t  Tm0BINTRMode         : 1; // Timer0 B Interrupt Detect Mode Select
N//          __IO uint32_t  Tm1AINTRMode         : 1; // Timer1 A Interrupt Detect Mode Select
N//          __IO uint32_t  Tm1BINTRMode         : 1; // Timer1 B Interrupt Detect Mode Select
N//      } INTRMODE_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	RAWEINTSTATUS;    //	 Timer Raw Edge Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0AREIS       : 1; // Timer0 A Raw Edge Interrupt Status
N//          __IO uint32_t  Tm0BREIS       : 1; // Timer0 B Raw Edge Interrupt Status
N//          __IO uint32_t  Tm1AREIS       : 1; // Timer1 A Raw Edge Interrupt Status
N//          __IO uint32_t  Tm1BREIS       : 1; // Timer1 B Raw Edge Interrupt Status
N//      } RAWEINTSTATUS_b;
N//    } ;
N//
N//    union {
N//	    __IO uint32_t	EINTSTATUS;	        //	 Timer Mask Edge Inerrupt Status Register
N//
N//      struct {
N//          __IO uint32_t  Tm0AMEIS       : 1; // Timer0 A Mask Edge Interrupt Status
N//          __IO uint32_t  Tm0BMEIS       : 1; // Timer0 B Mask Edge Interrupt Status
N//          __IO uint32_t  Tm1AMEIS       : 1; // Timer1 A Mask Edge Interrupt Status
N//          __IO uint32_t  Tm1BMEIS       : 1; // Timer1 B Mask Edge Interrupt Status
N//      } EINTSTATUS_b;
N//    } ;
N//       
N//}TIMER_TypeDef;
N
N
N
N
L 280 "..\..\Hal\system\MFTP.h" 2
N#include "_i2c.h"
L 1 "..\..\Hal\i2c\_i2c.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _i2c.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __I2C_H_
N#define __I2C_H_
N
N
N/* ================================================================================ */
N/* ================                      I2C                       ================ */
N/* ================================================================================ */
N
Ntypedef struct
N{
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cId : 7;	// I2C Master/Slave Device Address
X			volatile uint32_t I2cId : 7;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x00
X		volatile uint32_t ulBulk;	  
N	} I2C_DEVICE_ADDR;	// I2C Master/Slave Device Address Register
N
N	union
N	{
N		struct
N		{
N			__O uint32_t I2cSWReset : 1;	// I2C Software Reset
X			volatile uint32_t I2cSWReset : 1;	
N		} tBit;
N		__O uint32_t ulBulk;	  // 0x04
X		volatile uint32_t ulBulk;	  
N	} I2C_SW_RESET;	// I2C Master/Slave Software Reset Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cItrptEn        : 1;	// I2C Interrupt Enable
X			volatile uint32_t I2cItrptEn        : 1;	
N			__IO uint32_t I2cStrItrptEn     : 1;	// I2C Slave Start Interrupt Enable
X			volatile uint32_t I2cStrItrptEn     : 1;	
N			__IO uint32_t I2cStpItrptEn     : 1;	// I2C Stop Interrupt Enable
X			volatile uint32_t I2cStpItrptEn     : 1;	
N			__IO uint32_t I2cAddChkItrptEn  : 1;	// I2C Slave Device Address matched Intrrupt Enable
X			volatile uint32_t I2cAddChkItrptEn  : 1;	
N			__IO uint32_t I2cByteItrptEn    : 1;	// I2C Slave Byte Done Intrrupt Enable
X			volatile uint32_t I2cByteItrptEn    : 1;	
N			__IO uint32_t I2cMstItrptEn     : 1;	// I2C Master Packet Done Interrupt Enable
X			volatile uint32_t I2cMstItrptEn     : 1;	
N			__IO uint32_t I2cIspModeEn      : 1;	// I2C ISP Protocol Entry Mode Enable
X			volatile uint32_t I2cIspModeEn      : 1;	
N			__IO uint32_t I2cTxFifoItrptEn  : 1;	// I2C TX FIFO Interrupt Enable
X			volatile uint32_t I2cTxFifoItrptEn  : 1;	
N			__IO uint32_t I2cRxFifoItrptEn  : 1;	// I2C RX FIFO Interrupt Enable
X			volatile uint32_t I2cRxFifoItrptEn  : 1;	
N			__IO uint32_t I2cSclHoldItrptEn : 1;	// I2C SCL Hold Interrupt Enable
X			volatile uint32_t I2cSclHoldItrptEn : 1;	
N			__IO uint32_t I2cFilterEn       : 1;	// I2C Filter Enable
X			volatile uint32_t I2cFilterEn       : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x08
X		volatile uint32_t ulBulk;	  
N	} I2C_GLB_CR;	// I2C Interrupt Control Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cMstClkDiv : 16;	// I2C Master SCLK Clock Divide Value
X			volatile uint32_t I2cMstClkDiv : 16;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x0C
X		volatile uint32_t ulBulk;	  
N	} I2C_MST_CR1;	// I2C Master Control Register 1
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cMstDataTr	: 8;	// I2C Master Data Transfer
X			volatile uint32_t I2cMstDataTr	: 8;	
N			__IO uint32_t I2cMstStr		: 1;	// I2C Master Start Condition
X			volatile uint32_t I2cMstStr		: 1;	
N			__IO uint32_t I2cMstStop		: 1;	// I2C Master Stop Condition
X			volatile uint32_t I2cMstStop		: 1;	
N			__IO uint32_t I2cMstRcvMode	: 1;	// I2C Master Receive Mode
X			volatile uint32_t I2cMstRcvMode	: 1;	
N			__IO uint32_t I2cMstNackTr	: 1;	// I2C Ack Condition
X			volatile uint32_t I2cMstNackTr	: 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x10
X		volatile uint32_t ulBulk;	  
N	} I2C_MST_CR2;	// I2C Master Control Register 2
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2C_ITRPT       : 1;	// I2C Interrupt Flag
X			volatile uint32_t I2C_ITRPT       : 1;	
N			__I uint32_t IspMode         : 1;	// I2C ISP Mode Status
X			volatile const uint32_t IspMode         : 1;	
N			__I uint32_t Rsvd1           : 1;	// Not Used
X			volatile const uint32_t Rsvd1           : 1;	
N			__I uint32_t I2cSlvRdWrFlag  : 1;	// I2C Slave R/W Condition Status
X			volatile const uint32_t I2cSlvRdWrFlag  : 1;	
N			__I uint32_t I2cSlvAckRcv    : 1;	// I2C Slave Ack Condition
X			volatile const uint32_t I2cSlvAckRcv    : 1;	
N			__I uint32_t I2cPacketEn     : 1;	// I2CMaster packet Status
X			volatile const uint32_t I2cPacketEn     : 1;	
N			__I uint32_t I2cMstAckRcv    : 1;	// I2C Master Received Ack Condition
X			volatile const uint32_t I2cMstAckRcv    : 1;	
N			__I uint32_t Rsvd2           : 1;	// Not Used
X			volatile const uint32_t Rsvd2           : 1;	
N			__I uint32_t I2cMstDataRcv   : 8;	// I2C Master Received Data Status
X			volatile const uint32_t I2cMstDataRcv   : 8;	
N			__I uint32_t I2cItrptState   : 4;	// I2C Interrupt State
X			volatile const uint32_t I2cItrptState   : 4;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x14
X		volatile uint32_t ulBulk;		  
N	} I2C_GLB_SR;	// I2C Global Status Register
N
N	union
N	{
N		struct
N		{
N			__I uint32_t I2cSlvStSR   : 14;	// I2C Slave FSM Status
X			volatile const uint32_t I2cSlvStSR   : 14;	
N		} tBit;
N		__I  uint32_t ulBulk;	  // 0x18
X		volatile const  uint32_t ulBulk;	  
N	} I2C_SLV_ST_SR;	// I2C Slave Status Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t TxFifoInit    : 1;	// I2C TXFIFO WPTR / RPTR Clear
X			volatile uint32_t TxFifoInit    : 1;	
N			__IO uint32_t TxDmaIfEn     : 1;	// I2C DMA I/F TX Enable
X			volatile uint32_t TxDmaIfEn     : 1;	
N			__IO uint32_t TxFifoWmLv    : 5;	// I2C TXFIFO Watermark Level
X			volatile uint32_t TxFifoWmLv    : 5;	
N			__IO uint32_t TxFifoReqSel  : 1;	// TXFIFO Request Selection
X			volatile uint32_t TxFifoReqSel  : 1;	
N			__IO uint32_t RxFifoInit    : 1;	// I2C RXFIFO WPTR / RPTR Clear
X			volatile uint32_t RxFifoInit    : 1;	
N			__IO uint32_t RxDmaIfEn     : 1;	// I2C DMA I/F RX Enable
X			volatile uint32_t RxDmaIfEn     : 1;	
N			__IO uint32_t RxFifoWmLv    : 5;	// I2C RXFIFO Watermark Level
X			volatile uint32_t RxFifoWmLv    : 5;	
N			__IO uint32_t RxFifoReqSel  : 1;	// RXFIFO Request Selection
X			volatile uint32_t RxFifoReqSel  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x1C
X		volatile uint32_t ulBulk;	  
N	}I2C_FIFO_CR;	// I2C FIFO Control Register
N
N	union
N	{
N		struct
N		{
N			__O uint32_t TxFifoData  : 8;	// TXFIFO Data
X			volatile uint32_t TxFifoData  : 8;	
N		} tBit;
N		__O uint32_t ulBulk;  // 0x20
X		volatile uint32_t ulBulk;  
N	} I2C_TXFIFO_DATA;	// I2C TXFIFO Data Register
N
N	union
N	{
N		struct
N		{
N			__I uint32_t RxFifoData  : 8;	// RXFIFO Data
X			volatile const uint32_t RxFifoData  : 8;	
N		} tBit;
N		__I uint32_t ulBulk;  // 0x24
X		volatile const uint32_t ulBulk;  
N	} I2C_RXFIFO_DATA;	// I2C RXFIFO Data Register
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TxFifoEmpty   : 1;	// TXFIFO Empty Flag
X			volatile const uint32_t TxFifoEmpty   : 1;	
N			__I uint32_t TxFifoFull    : 1;	// TXFIFO Full Flag
X			volatile const uint32_t TxFifoFull    : 1;	
N			__I uint32_t TxFifoWmFlag  : 1;	// TXFIFO Watermark Level Flag
X			volatile const uint32_t TxFifoWmFlag  : 1;	
N			__I uint32_t TxFifoWmBlw   : 1;	// TXFIFO Watermark Level Below Flag
X			volatile const uint32_t TxFifoWmBlw   : 1;	
N			__I uint32_t TxWrPtr       : 5;	// TXFIFO Write Pointer
X			volatile const uint32_t TxWrPtr       : 5;	
N			__I uint32_t TxRdPtr       : 5;	// TXFIFO Read Pointer
X			volatile const uint32_t TxRdPtr       : 5;	
N			__I uint32_t Rsvd1         : 2;	// Not Used
X			volatile const uint32_t Rsvd1         : 2;	
N			__I uint32_t RxFifoEmpty   : 1;	// RXFIFO Empty Flag
X			volatile const uint32_t RxFifoEmpty   : 1;	
N			__I uint32_t RxFifoFull    : 1;	// RXFIFO Full Flag
X			volatile const uint32_t RxFifoFull    : 1;	
N			__I uint32_t RxFifoWmFlag  : 1;	// RXFIFO Watermark Level Flag
X			volatile const uint32_t RxFifoWmFlag  : 1;	
N			__I uint32_t RxFifoWmAbv   : 1;	// RXFIFO Watermark Level Above Flag
X			volatile const uint32_t RxFifoWmAbv   : 1;	
N			__I uint32_t RxWrPtr       : 5;	// RXFIFO Write Pointer
X			volatile const uint32_t RxWrPtr       : 5;	
N			__I uint32_t RxRdPtr       : 5;	// RXFIFO Read Pointer
X			volatile const uint32_t RxRdPtr       : 5;	
N			__I uint32_t Rsvd2         : 2;	// Not Used
X			volatile const uint32_t Rsvd2         : 2;	
N		} tBit;
N		__I uint32_t ulBulk;  // 0x28
X		volatile const uint32_t ulBulk;  
N	} I2C_FIFO_SR;	// I2C TXFIFO / RXFIFO Status Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SetPwrRegLSBOn    : 8;	// Power Register LSB for Wakeup Mode
X			volatile uint32_t SetPwrRegLSBOn    : 8;	
N			__IO uint32_t SetPwrRegLSBSleep : 8;	// Power Register LSB for Sleep Mode
X			volatile uint32_t SetPwrRegLSBSleep : 8;	
N			__IO uint32_t SetPwrRegMSB      : 8;	// Register MSB of Power Mode
X			volatile uint32_t SetPwrRegMSB      : 8;	
N			__IO uint32_t SetPwrRegLSBFirst : 1;	// Set I2C protocol, LSB first
X			volatile uint32_t SetPwrRegLSBFirst : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;  // 0x2C
X		volatile uint32_t ulBulk;  
N	} I2C_SET_PWR_REG;	// I2C Set Power Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SetPwrCmdLSB    : 8;	// Command LSB of Power Mode
X			volatile uint32_t SetPwrCmdLSB    : 8;	
N			__IO uint32_t SetPwrCmdMSB    : 8;	// Command MSB of Power mode
X			volatile uint32_t SetPwrCmdMSB    : 8;	
N			__IO uint32_t SetPwrCmdEn     : 1;	// Power Command Enable
X			volatile uint32_t SetPwrCmdEn     : 1;	
N			__IO uint32_t SetPwrLSBFirst  : 1;	// Set I2C Protocol, LB first
X			volatile uint32_t SetPwrLSBFirst  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;  // 0x30
X		volatile uint32_t ulBulk;  
N	} I2C_SET_PWR_CMD;	// I2C Set Power Command Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t WakeUpItrptEn   : 1;	// Wake up Interrupt Enable
X			volatile uint32_t WakeUpItrptEn   : 1;	
N			__IO uint32_t SleepItrptEn    : 1;	// Sleep Interrup Enable
X			volatile uint32_t SleepItrptEn    : 1;	
N			__IO uint32_t WakeUpItrpt     : 1;	// Wake Up Interrupt
X			volatile uint32_t WakeUpItrpt     : 1;	
N			__IO uint32_t SleepItrpt      : 1;	// Sleep Interrupt
X			volatile uint32_t SleepItrpt      : 1;	
N			__I uint32_t PowerState      : 1;	// State of Power Save Mode
X			volatile const uint32_t PowerState      : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;  // 0x34
X		volatile uint32_t ulBulk;  
N	} I2C_SET_PWR_INT;	// I2C Set Power Interrupt Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cDlyVal   : 6;	// Delay after negative edge of SCL
X			volatile uint32_t I2cDlyVal   : 6;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x38
X		volatile uint32_t ulBulk;	  
N	} I2C_DLY_VALUE;	// I2C Delay Value Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cSlvTrLen   : 15;	// I2C Slave Transfer Length
X			volatile uint32_t I2cSlvTrLen   : 15;	
N			__IO uint32_t Rsvd          : 1;	// Not Used
X			volatile uint32_t Rsvd          : 1;	
N			__I uint32_t I2cSlvTrCnt   : 15;	// I2C Slave Transfer Count Value
X			volatile const uint32_t I2cSlvTrCnt   : 15;	
N			__I uint32_t I2cSlvTrDone  : 1;	// I2C Slave Transfer Done Flag
X			volatile const uint32_t I2cSlvTrDone  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x3C
X		volatile uint32_t ulBulk;	  
N	} I2C_SLV_DBG;	// I2C Slave Debugging Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cMstTrLen   : 15;	// I2C Master Transfer Length
X			volatile uint32_t I2cMstTrLen   : 15;	
N			__IO uint32_t Rsvd          : 1;	// Not Used
X			volatile uint32_t Rsvd          : 1;	
N			__I uint32_t I2cMstTrCnt   : 15;	// I2C Master Transfer Count Value
X			volatile const uint32_t I2cMstTrCnt   : 15;	
N			__I uint32_t I2cMstTrDone  : 1;	// I2C Master Transfer Done Flag
X			volatile const uint32_t I2cMstTrDone  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x40
X		volatile uint32_t ulBulk;	  
N	} I2C_MST_DBG;	// I2C Master Debugging Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t TxFifoInit2   : 1;	// TXFIFO WPTR / RPTR Clear
X			volatile uint32_t TxFifoInit2   : 1;	
N			__IO uint32_t TxFifoIntEna2 : 1;	// Interrupt I/F TX Enable
X			volatile uint32_t TxFifoIntEna2 : 1;	
N			__IO uint32_t TxFifoWmLv2   : 5;	// TXFIFO Watermark Level 2
X			volatile uint32_t TxFifoWmLv2   : 5;	
N			__IO uint32_t TxFifoIntSel  : 1;	// TXFIFO Interrupt Selection
X			volatile uint32_t TxFifoIntSel  : 1;	
N			__IO uint32_t RxFifoInit2   : 1;	// RXFIFO WPTR / RPTR Clear
X			volatile uint32_t RxFifoInit2   : 1;	
N			__IO uint32_t RxFifoIntEna2 : 1;	// Interrupt I/F RX Enable
X			volatile uint32_t RxFifoIntEna2 : 1;	
N			__IO uint32_t RxFifoWmLv2   : 5;	// RXFIFO Watermark Level 2
X			volatile uint32_t RxFifoWmLv2   : 5;	
N			__IO uint32_t RxFifoIntSel  : 1;	// RXFIFO Interrupt Selection
X			volatile uint32_t RxFifoIntSel  : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x44
X		volatile uint32_t ulBulk;	  
N	} I2C_FIFO_CR2;	// I2C FIFO Control Register 2
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TxFifoEmpty   : 1;	// TXFIFO Empty Flag
X			volatile const uint32_t TxFifoEmpty   : 1;	
N			__I uint32_t TxFifoFull    : 1;	// TXFIFO Full Flag
X			volatile const uint32_t TxFifoFull    : 1;	
N			__I uint32_t TxFifoWmFlag2 : 1;	// TXFIFO Watermark Level Flag
X			volatile const uint32_t TxFifoWmFlag2 : 1;	
N			__I uint32_t TxFifoWmBlw2  : 1;	// TXFIFO Watermark Level Below Flag
X			volatile const uint32_t TxFifoWmBlw2  : 1;	
N			__I uint32_t TxWrPtr       : 5;	// TXFIFO Write Pointer
X			volatile const uint32_t TxWrPtr       : 5;	
N			__I uint32_t TxRdPtr       : 5;	// TXFIFO Read Pointer
X			volatile const uint32_t TxRdPtr       : 5;	
N			__I uint32_t TxFifoInt     : 1;	// TXFIFO Interrupt
X			volatile const uint32_t TxFifoInt     : 1;	
N			__I uint32_t Rsvd          : 1;	// Not Used
X			volatile const uint32_t Rsvd          : 1;	
N			__I uint32_t RxFifoEmpty   : 1;	// RXFIFO Empty Flag
X			volatile const uint32_t RxFifoEmpty   : 1;	
N			__I uint32_t RxFifoFull    : 1;	// RXFIFO Full Flag
X			volatile const uint32_t RxFifoFull    : 1;	
N			__I uint32_t RxFifoWmFlag2 : 1;	// RXFIFO Watermark Level Flag
X			volatile const uint32_t RxFifoWmFlag2 : 1;	
N			__I uint32_t RxFifoWmAbv2  : 1;	// RXFIFO Watermark Level Above Flag
X			volatile const uint32_t RxFifoWmAbv2  : 1;	
N			__I uint32_t RxWrPtr       : 5;	// RXFIFO Write Pointer
X			volatile const uint32_t RxWrPtr       : 5;	
N			__I uint32_t RxRdPtr       : 5;	// RXFIFO Read Pointer
X			volatile const uint32_t RxRdPtr       : 5;	
N			__I uint32_t RxFifoInt     : 1;	// RXFIFO Interrupt
X			volatile const uint32_t RxFifoInt     : 1;	
N		} tBit;
N		__I uint32_t ulBulk;	  // 0x48
X		volatile const uint32_t ulBulk;	  
N	} I2C_FIFO_SR2;	// I2C TXFIFO / RXFIFO Status Register 2
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cStretchEn  : 1;
X			volatile uint32_t I2cStretchEn  : 1;
N			__IO uint32_t I2cStretchVal : 31;
X			volatile uint32_t I2cStretchVal : 31;
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x4C
X		volatile uint32_t ulBulk;	  
N	} I2C_STRTCH_CR1;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cStretchSel   : 1;
X			volatile uint32_t I2cStretchSel   : 1;
N			__IO uint32_t I2cStretchApp   : 1;
X			volatile uint32_t I2cStretchApp   : 1;
N			__IO uint32_t I2cStretchType  : 1;
X			volatile uint32_t I2cStretchType  : 1;
N		} tBit;
N		__IO uint32_t ulBulk;	  // 0x50
X		volatile uint32_t ulBulk;	  
N	} I2C_STRTCH_CR2;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cSclLowVal  : 32;
X			volatile uint32_t I2cSclLowVal  : 32;
N		} tBit;
N		__I uint32_t ulBulk;	  // 0x54
X		volatile const uint32_t ulBulk;	  
N	} I2C_SCL_VAL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SlpCr     : 1;	// Sleep Enable
X			volatile uint32_t SlpCr     : 1;	
N			__IO uint32_t PrMux     : 1;	// APB Bus RDATA Selection
X			volatile uint32_t PrMux     : 1;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x58
X		volatile uint32_t ulBulk;		  
N	} I2C_SLP_CR; 	// I2C Sleep Control Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t SlpSr		: 1;	// Device Address Check Interrupt
X			volatile uint32_t SlpSr		: 1;	
N			__I uint32_t PclkEna	: 1;	// Normal PCLK Enable
X			volatile const uint32_t PclkEna	: 1;	
N			__I uint32_t PclkCr		: 1;	// SCLK Enable
X			volatile const uint32_t PclkCr		: 1;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x5C
X		volatile uint32_t ulBulk;		  
N	} I2C_SLP_SR;	// I2C Sleep Status Register
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t I2cSclHoldEn		: 1;	// SCL Stretch Function1 Enable
X			volatile uint32_t I2cSclHoldEn		: 1;	
N			__I uint32_t I2cSclHoldStatus	: 1;	// SCL Sretch Status
X			volatile const uint32_t I2cSclHoldStatus	: 1;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x60
X		volatile uint32_t ulBulk;		  
N	} I2C_SCL_HOLD;	// I2C SCL Stretch Control Register
N
N	union 
N	{
N		struct 
N		{
N			__IO uint32_t I2cSclHoldEn2		: 1;	// SCL Stretch Fuction2 Enable
X			volatile uint32_t I2cSclHoldEn2		: 1;	
N			__I uint32_t I2cSclHoldRls		: 1;	// SCL Stretch Status 
X			volatile const uint32_t I2cSclHoldRls		: 1;	
N			__IO uint32_t I2cSclHoldCntEn	: 1;	// SCL Hold Timeout Count Enable
X			volatile uint32_t I2cSclHoldCntEn	: 1;	
N			__I uint32_t I2cSclHoldTOutSt	: 1;	// SCL Hold Timeout Status
X			volatile const uint32_t I2cSclHoldTOutSt	: 1;	
N			__IO uint32_t Rsvd				: 12;	// Not Used
X			volatile uint32_t Rsvd				: 12;	
N			__IO uint32_t I2cSclHoldTOutVal	: 16;	// SCL Hold Timeout Counter Value
X			volatile uint32_t I2cSclHoldTOutVal	: 16;	
N		} tBit;
N		__IO uint32_t ulBulk;		  // 0x64
X		volatile uint32_t ulBulk;		  
N	} I2C_SCL_HOLD2;	// I2C SCL Stretch Control Register 2
N
N	__IO uint32_t Reserved0;	          // 0x68
X	volatile uint32_t Reserved0;	          
N	__IO uint32_t Reserved1;	          // 0x6C
X	volatile uint32_t Reserved1;	          
N	__IO uint32_t Reserved2;	          // 0x70
X	volatile uint32_t Reserved2;	          
N	__IO uint32_t Reserved3;	          // 0x74
X	volatile uint32_t Reserved3;	          
N	__IO uint32_t SLP_I2C_DEVICE_ADDR;  // 0x78
X	volatile uint32_t SLP_I2C_DEVICE_ADDR;  
N	__IO uint32_t SLP_I2C_SW_RESET;	  // 0x7C
X	volatile uint32_t SLP_I2C_SW_RESET;	  
N	__IO uint32_t SLP_I2C_GLB_CR;	      // 0x80
X	volatile uint32_t SLP_I2C_GLB_CR;	      
N	__IO uint32_t SLP_I2C_MST_CR1;	  // 0x84
X	volatile uint32_t SLP_I2C_MST_CR1;	  
N	__IO uint32_t SLP_I2C_MST_CR2;	  // 0x88
X	volatile uint32_t SLP_I2C_MST_CR2;	  
N	__IO uint32_t SLP_I2C_GLB_SR;		  // 0x8C
X	volatile uint32_t SLP_I2C_GLB_SR;		  
N	__I  uint32_t SLP_I2C_SLV_ST_SR;	  // 0x90
X	volatile const  uint32_t SLP_I2C_SLV_ST_SR;	  
N	__IO uint32_t SLP_I2C_FIFO_CR;	  // 0x94
X	volatile uint32_t SLP_I2C_FIFO_CR;	  
N	__IO uint32_t SLP_I2C_TXFIFO_DATA;  // 0x98
X	volatile uint32_t SLP_I2C_TXFIFO_DATA;  
N	__I	 uint32_t SLP_I2C_RXFIFO_DATA;  // 0x9C
X	volatile const	 uint32_t SLP_I2C_RXFIFO_DATA;  
N	__I  uint32_t SLP_I2C_FIFO_SR;	  // 0xA0
X	volatile const  uint32_t SLP_I2C_FIFO_SR;	  
N	__IO uint32_t SLP_I2C_SET_PWR_REG;  // 0xA4
X	volatile uint32_t SLP_I2C_SET_PWR_REG;  
N	__IO uint32_t SLP_I2C_SET_PWR_CMD;  // 0xA8
X	volatile uint32_t SLP_I2C_SET_PWR_CMD;  
N	__IO uint32_t SLP_I2C_SET_PWR_INT;  // 0xAC
X	volatile uint32_t SLP_I2C_SET_PWR_INT;  
N	__IO uint32_t SLP_I2C_DLY_VALUE;	  // 0xB0
X	volatile uint32_t SLP_I2C_DLY_VALUE;	  
N	__IO uint32_t SLP_I2C_SLV_DBG;	  // 0xB4
X	volatile uint32_t SLP_I2C_SLV_DBG;	  
N	__IO uint32_t SLP_I2C_MST_DBG;	  // 0xB8
X	volatile uint32_t SLP_I2C_MST_DBG;	  
N	__IO uint32_t SLP_I2C_FIFO_CR2;	  // 0xBC
X	volatile uint32_t SLP_I2C_FIFO_CR2;	  
N	__IO uint32_t SLP_I2C_FIFO_SR2;	  // 0xC0
X	volatile uint32_t SLP_I2C_FIFO_SR2;	  
N	__IO uint32_t SLP_I2C_STRTCH_CR1;	  // 0xC4
X	volatile uint32_t SLP_I2C_STRTCH_CR1;	  
N	__IO uint32_t SLP_I2C_STRTCH_CR2;	  // 0xC8
X	volatile uint32_t SLP_I2C_STRTCH_CR2;	  
N	__IO uint32_t SLP_I2C_SCL_VAL;	  // 0xCC
X	volatile uint32_t SLP_I2C_SCL_VAL;	  
N	__IO uint32_t SLP_I2C_SCL_HOLD;	  // 0xD0
X	volatile uint32_t SLP_I2C_SCL_HOLD;	  
N	__IO uint32_t SLP_I2C_SCL_HOLD2;	  // 0xD4
X	volatile uint32_t SLP_I2C_SCL_HOLD2;	  
N
N} tI2C_CtrlReg_t;    
N
N#endif /* __I2C_H_ */
L 281 "..\..\Hal\system\MFTP.h" 2
N#include "_dma.h"
L 1 "..\..\Hal\dma\_dma.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _dma.h
N * version : 0.1
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __DMA_H_
N#define __DMA_H_
N
N
Ntypedef struct
N{
N	__IO uint32_t 	SAR;          /*!< 0x?? : SAR : Channel? Source Address Register		*/
X	volatile uint32_t 	SAR;           
N	     uint32_t		xRESERVED0;
N	
N	__IO uint32_t	  DAR;				  /*!< 0x?? : DAR : Channel? Destination Address Register		*/
X	volatile uint32_t	  DAR;				   
N	     uint32_t		xRESERVED1;
N
N	__IO uint32_t	  LLP;				  /*!< 0x?? : LLP	: Channel? Linked List Pointer Register		*/
X	volatile uint32_t	  LLP;				   
N	     uint32_t		xRESERVED2;
N
N	__IO uint64_t	  CTL;				  /*!< 0x?? : CTL	: Channel? Control Register		*/
X	volatile uint64_t	  CTL;				   
N
N	__IO uint32_t	  SSTAT;				/*!< 0x?? : SSTAT	: Channel? Source Status Register	*/
X	volatile uint32_t	  SSTAT;				 
N	     uint32_t		xRESERVED3;
N
N	__IO uint32_t	  DSTAT;				/*!< 0x?? : DSTAT	: Channel? Destination Status Register	*/
X	volatile uint32_t	  DSTAT;				 
N	     uint32_t		xRESERVED4;
N
N	__IO uint32_t	  SSTATAR;			/*!< 0x?? : SSTATAR	: Channel? Source Status Register	*/
X	volatile uint32_t	  SSTATAR;			 
N	     uint32_t		xRESERVED5;
N
N	__IO uint32_t	  DSTATAR;			/*!< 0x?? : DSTATAR	: Channel? Destination Status Address Register	*/
X	volatile uint32_t	  DSTATAR;			 
N	     uint32_t		xRESERVED6;
N
N	__IO uint64_t	  CFG;				  /*!< 0x?? : CFG	: Channel? Configuration Register		*/
X	volatile uint64_t	  CFG;				   
N
N	__IO uint32_t 	SGR;			  	/*!< 0x?? : SGR	: Channel? Source Gather Register		*/
X	volatile uint32_t 	SGR;			  	 
N	     uint32_t		xRESERVED7;
N
N	__IO uint32_t	  DSR;				  /*!< 0x?? : DSR	: Channel? Destination Scatter Register		*/
X	volatile uint32_t	  DSR;				   
N	     uint32_t		xRESERVED8;
N} DMA_Channel_TypeDef, *pDMA_Channel_TypeDef;
N
Ntypedef struct
N{
N	__IO uint32_t	  RawTfr;				      /*!< 0x2C0 : RawTfr : Raw Status for IntTfr Interrupt	*/
X	volatile uint32_t	  RawTfr;				       
N	     uint32_t		RawTfrRsvd;
N	__IO uint32_t	  RawIntBlock;		    /*!< 0x2C8 : RawBlock : Raw Status for IntBlock Interrupt	*/
X	volatile uint32_t	  RawIntBlock;		     
N	     uint32_t		RawBlockRsvd;
N	__IO uint32_t	  RawSrcTran;			    /*!< 0x2D0 : RawSrcTran : Raw Status for IntSrcTran Interrupt	*/
X	volatile uint32_t	  RawSrcTran;			     
N	     uint32_t		RawSrcTranRsvd;
N	__IO uint32_t	  RawDstTran;			    /*!< 0x2D8 : RawDstTran : Raw Status for IntDstTran Interrupt	*/
X	volatile uint32_t	  RawDstTran;			     
N	     uint32_t		RawDstTranRsvd;
N	__IO uint32_t	  RawErr;				      /*!< 0x2E0 : RawErr : Raw Status for IntErr Interrupt	*/
X	volatile uint32_t	  RawErr;				       
N	     uint32_t		RawErrRsvd;
N
N	__I  uint32_t	  StatusTfr;			    /*!< 0x2E8 : StatusTfr : Status for IntTfr Interrupt	*/
X	volatile const  uint32_t	  StatusTfr;			     
N	     uint32_t		StatusTfrRsvd;
N	__I  uint32_t	  StatusBlock;		    /*!< 0x2F0 : StatusBlock : Status for IntBlock Interrupt	*/
X	volatile const  uint32_t	  StatusBlock;		     
N	     uint32_t		StatusBlockRsvd;
N	__I  uint32_t	  StatusSrcTran;		  /*!< 0x2F8 : StatusSrcTran : Status for IntSrcTran Interrupt	*/
X	volatile const  uint32_t	  StatusSrcTran;		   
N	     uint32_t		StatusSrcTranRsvd;
N	__I  uint32_t	  StatusDstTran;		  /*!< 0x300 : StatusDstTran : Status for IntDstTran Interrupt	*/
X	volatile const  uint32_t	  StatusDstTran;		   
N	     uint32_t		StatusDstTranRsvd;
N	__I  uint32_t	  StatusErr;			    /*!< 0x308 : StatusErr : Status for IntErr Interrupt	*/
X	volatile const  uint32_t	  StatusErr;			     
N	     uint32_t		StatusErrRsvd;
N
N	__IO uint32_t	  MaskTfr;			      /*!< 0x310 : MaskTfr : Mask for IntTfr Interrupt	*/
X	volatile uint32_t	  MaskTfr;			       
N	     uint32_t		MaskTfrRsvd;
N	__IO uint32_t	  MaskBlock;			    /*!< 0x318 : MaskBlock : Mask for IntBlock Interrupt	*/
X	volatile uint32_t	  MaskBlock;			     
N	     uint32_t		MaskBlockRsvd;
N	__IO uint32_t	  MaskSrcTran;		    /*!< 0x320 : MaskSrcTran : Mask for IntSrcTran Interrupt	*/
X	volatile uint32_t	  MaskSrcTran;		     
N	     uint32_t		MaskSrcTranRsvd;
N	__IO uint32_t	  MaskDstTran;		    /*!< 0x328 : MaskDstTran : Mask for IntDstTran Interrupt	*/
X	volatile uint32_t	  MaskDstTran;		     
N	     uint32_t		MaskDstTranRsvd;
N	__IO uint32_t	  MaskErr;			      /*!< 0x330 : MaskErr : Mask for IntErr Interrupt	*/
X	volatile uint32_t	  MaskErr;			       
N	     uint32_t		MaskErrRsvd;
N
N	__IO uint32_t	  ClearTfr;			      /*!< 0x338 : ClearTfr : Clear for IntTfr Interrupt	*/
X	volatile uint32_t	  ClearTfr;			       
N	     uint32_t		ClearTfrRsvd;
N	__IO uint32_t	  ClearBlock;			    /*!< 0x340 : ClearBlock : Clear for IntBlock Interrupt	*/
X	volatile uint32_t	  ClearBlock;			     
N	     uint32_t		ClearBlockRsvd;
N	__IO uint32_t	  ClearSrcTran;		    /*!< 0x348 : ClearSrcTran : Clear for IntSrcTran Interrupt	*/
X	volatile uint32_t	  ClearSrcTran;		     
N	     uint32_t		ClearSrcTranRsvd;
N	__IO uint32_t	  ClearDstTran;		    /*!< 0x350 : ClearDstTran : Clear for IntDstTran Interrupt	*/
X	volatile uint32_t	  ClearDstTran;		     
N	     uint32_t		ClearDstTranRsvd;
N	__IO uint32_t	  ClearErr;			      /*!< 0x358 : ClearErr : Clear for IntErr Interrupt	*/
X	volatile uint32_t	  ClearErr;			       
N	     uint32_t		ClearErrRsvd;
N
N	__IO uint64_t	  StatusInt;			    /*!< 0x360 : StatusInt : Status for each interrupt type	*/
X	volatile uint64_t	  StatusInt;			     
N	__IO uint64_t	  ReqSrcReg;			    /*!< 0x368 : ReqSrcReg : Source Software Transaction Request Register	*/
X	volatile uint64_t	  ReqSrcReg;			     
N	__IO uint64_t	  ReqDstReg;			    /*!< 0x370 : ReqDstReg : Destination Software Transaction Request Register	*/
X	volatile uint64_t	  ReqDstReg;			     
N	__IO uint64_t	  SglReqSrcReg;		    /*!< 0x378 : SglReqSrcReg : Single Source Transaction Request Register	*/
X	volatile uint64_t	  SglReqSrcReg;		     
N	__IO uint64_t	  SglReqDstReg;		    /*!< 0x380 : SglReqDstReg : Single Destination Transaction Request Register	*/
X	volatile uint64_t	  SglReqDstReg;		     
N	__IO uint64_t	  LstSrcReg;			    /*!< 0x388 : LstSrcReg : Last Source Transaction Request Register	*/
X	volatile uint64_t	  LstSrcReg;			     
N	__IO uint64_t	  LstDstReg;			    /*!< 0x390 : LstDstReg : Last Destination Transaction Request Register	*/
X	volatile uint64_t	  LstDstReg;			     
N
N	__IO uint32_t	  DmaCfgReg;			    /*!< 0x398 : DmaCfgReg : DMA Configuration Register	*/
X	volatile uint32_t	  DmaCfgReg;			     
N	     uint32_t 	DmaCfgRegReserved;	  
N
N	__IO uint32_t	  ChEnReg;			      /*!< 0x3a0 : ChEnReg : DMA Channel Enable Register	*/
X	volatile uint32_t	  ChEnReg;			       
N	     uint32_t		ChEnRegReserved;
N
N	__IO uint64_t	  DmaIdReg;			      /*!< 0x3a8 : DmaIdReg : DMA ID Register	*/
X	volatile uint64_t	  DmaIdReg;			       
N	__IO uint64_t	  DmaTestReg;			    /*!< 0x3b0 : DmaTestReg : DMA Test Register	*/
X	volatile uint64_t	  DmaTestReg;			     
N
N	__IO uint64_t	  DMA_COMP_PARAMS_4;	/*!< 0x3d8 : DMA_COMP_PARAMS_4 : Component parameter settings for Channel4 and Channel3 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_4;	 
N	__IO uint64_t	  DMA_COMP_PARAMS_3;	/*!< 0x3e0 : DMA_COMP_PARAMS_3 : Component parameter settings for Channel2 and Channel1 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_3;	 
N	__IO uint64_t	  DMA_COMP_PARAMS_2;	/*!< 0x3e8 : DMA_COMP_PARAMS_2 : Component parameter settings 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_2;	 
N	__IO uint64_t	  DMA_COMP_PARAMS_1;	/*!< 0x3f0 : DMA_COMP_PARAMS_1 : Component parameter settings 	*/
X	volatile uint64_t	  DMA_COMP_PARAMS_1;	 
N
N	__IO uint64_t	DmaCompID;			    /*!< 0x3f8 : DMA Component ID Register : Component version register	*/
X	volatile uint64_t	DmaCompID;			     
N} DMA_GLOBAL_TypeDef;
N
N#endif /* __DMA_H_ */
L 282 "..\..\Hal\system\MFTP.h" 2
N#include "../wdgt/_wdgt.h"
L 1 "..\..\Hal\system\../wdgt/_wdgt.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _wdt.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __WDT_H_
N#define __WDT_H_
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  Flash Control Register
N */
N
N
N
Nextern uint8_t cnt;
N
Ntypedef struct
N{
N
N    union {
N	    __IO uint32_t	WDT_CLR;		  // 0x00	WDT Clear				      0x0 
X	    volatile uint32_t	WDT_CLR;		  
N      
N      struct {
N          __IO uint32_t wdtClr : 1; // WDT Clear 
X          volatile uint32_t wdtClr : 1; 
N      } WDT_CLR_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_ACCE;		  // 0x04	WDT Access Control		0x0 
X	    volatile uint32_t	WDT_ACCE;		  
N      
N      struct {
N          __IO uint32_t wdtLock : 1; // WDT Access lock 
X          volatile uint32_t wdtLock : 1; 
N      } WDT_ACCE_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_CON;		  // 0x08	WDT Control Register	0x0000_0007 
X	    volatile uint32_t	WDT_CON;		  
N      
N      struct {
N          __IO uint32_t wdtclksel    : 3; // WDT divided clock source sel
X          volatile uint32_t wdtclksel    : 3; 
N          __IO uint32_t wdten        : 1; // WDT Enable in normal mode 
X          volatile uint32_t wdten        : 1; 
N          __IO uint32_t wdtintren    : 1; // WDT Interrupt Enable  
X          volatile uint32_t wdtintren    : 1; 
N          __IO uint32_t wdtrsten     : 1; // WDT Reset Enable  
X          volatile uint32_t wdtrsten     : 1; 
N          __IO uint32_t wdtreserved  : 2; // WDT reserved
X          volatile uint32_t wdtreserved  : 2; 
N          __I  uint32_t wdtovf       : 1; // WDT count overflow
X          volatile const  uint32_t wdtovf       : 1; 
N          __I  uint32_t wdtintrout   : 1; // WDT interrupt out
X          volatile const  uint32_t wdtintrout   : 1; 
N          __I  uint32_t wdtrstout    : 1; // WDT reset out
X          volatile const  uint32_t wdtrstout    : 1; 
N      } WDT_CON_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_WIDTH;		// 0x0C	WDT Period Value		  0xFFFF_FFFF 
X	    volatile uint32_t	WDT_WIDTH;		
N      
N      struct {
N          __IO uint32_t wdtwidth : 16; // WDT timer period
X          volatile uint32_t wdtwidth : 16; 
N          __I  uint32_t wdttmcnt : 16; // WDT timer count
X          volatile const  uint32_t wdttmcnt : 16; 
N      } WDT_WIDTH_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_RST_DLY;	// 0x10	Reset Delay.			    0xFFFF_FFFF 
X	    volatile uint32_t	WDT_RST_DLY;	
N      
N      struct {
N          __IO uint32_t rstdlywidth : 16; // WDT Reset delay Width 
X          volatile uint32_t rstdlywidth : 16; 
N          __I  uint32_t rstdlycnt   : 16; // WDT Reset delay count
X          volatile const  uint32_t rstdlycnt   : 16; 
N      } WDT_RST_DLY_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_RST_DUR;	// 0x14	Reset Duration			  0x0000_00FF 
X	    volatile uint32_t	WDT_RST_DUR;	
N      
N      struct {
N          __IO uint32_t rstdlywidth : 4; // WDT Reset delay Width 
X          volatile uint32_t rstdlywidth : 4; 
N          __I  uint32_t rstdlycnt   : 4; // WDT Reset delay count
X          volatile const  uint32_t rstdlycnt   : 4; 
N      } WDT_RST_DUR_b;
N    } ;
N
N    union {
N	    __IO uint32_t	WDT_CLR_DLY;
X	    volatile uint32_t	WDT_CLR_DLY;
N      
N      struct {
N          __IO uint32_t rstdlywidth : 8; // WDT Timer Clear delay Width 
X          volatile uint32_t rstdlywidth : 8; 
N          __IO  uint32_t rstdlycnt   : 1; // WDT Timer Clear delay enable
X          volatile  uint32_t rstdlycnt   : 1; 
N      } WDT_CLR_DLY_b;
N    } ;
N
N} WDT_TypeDef;
N
N
N#endif /* __WDT_H_ */
L 283 "..\..\Hal\system\MFTP.h" 2
N#include "_flitf.h"
L 1 "..\..\Hal\flitf\_flitf.h" 1
N
N/****************************************************************************************************//**
N * @file     flitf.h
N *
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File for
N *           default mtlp Device Series
N *
N * @version  Vrev.B
N * @date     19. April 2013
N *
N * @note     
N *
N * @par      ARM Limited (ARM) is supplying this software for use with Cortex-M
N *           processor based microcontroller, but can be equally used for other
N *           suitable processor architectures. This file can be freely distributed.
N *           Modifications to this file shall be clearly marked.
N *           
N *           THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N *           OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N *           MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N *           ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N *           CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
N *
N *******************************************************************************************************/
N
N
N
N/* ================================================================================ */
N/* ================                     FLITF                      ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  FLITF Register Map
N */
N#define FLITFCTRL_COMMAND_FLASH_NONE			(0x00)
N#define FLITFCTRL_COMMAND_FLASH_PAGE_ERASE		(0x01)
N#define FLITFCTRL_COMMAND_FLASH_MASS_ERASE		(0x02)
N#define FLITFCTRL_COMMAND_FLASH_WRITE			(0x03)
N#define FLITFCTRL_COMMAND_FLASH_READ			(0x04)
N#define FLITFCTRL_COMMAND_FLASH_GET_VERIFY		(0x05)
N#define FLITFCTRL_COMMAND_FLASH_ENTER_IAP_MODE	(0x06)
N#define FLITFCTRL_COMMAND_FLASH_EXIT_IAP_MODE	(0x07)
N#define FLITFCTRL_COMMAND_FLASH_4KB_UPDATE_MODE	(0x08)
N
N#define FLASHCTRL_STATUS_NONE					(0x00)
N#define FLASHCTRL_STATUS_SUCCESS				(0x01)
N#define FLASHCTRL_STATUS_PAGE_ERASE_FAILED		(0x02)
N#define FLASHCTRL_STATUS_PAGE_WRITE_FAILED		(0x03)
N#define FLASHCTRL_STATUS_PAFE_READ_FAILED		(0x03)
N
Nextern void hal_flitf_init(void);
Nextern void hal_flitf_process(void);
Nextern void hal_flitf_another_process(void);
N#if defined(USE_BOOTLOADER_16KB)
X#if 1L
Nextern void FLASH_Write(uint32_t addr, uint32_t val);
Nextern uint32_t FLASH_Read(uint32_t addr);
N#endif /* (USE_BOOTLOADER_16KB) */
N
Ntypedef struct
N{
N	uint32_t addr;
N	uint16_t size;
N	volatile uint8_t status;
N	volatile uint8_t cmd;
N} __attribute__ ((packed)) tFlashIAPCmd_t;
N
Ntypedef struct
N{
N	tFlashIAPCmd_t * Ctrl;
N} tFlashIAPPacket_t;
N
Nextern tFlashIAPPacket_t tFlashIAPPacket;
N
N#define FLASH_WRITE_SIZE	128
N#define	DFUP_BUFFER_SIZE	4096
Nextern uint8_t DFUP_BUFFER[DFUP_BUFFER_SIZE];
Xextern uint8_t DFUP_BUFFER[4096];
Ntypedef struct
N{
N	union
N    {	
N       uint32_t FACR;	
N		
N		struct {
N			uint32_t LATENCY				:4;
N            uint32_t RESERVED0			:28;
N        } FACR_b ;
N    };
N
N	
N	uint32_t FKEYR;                  // 0x0004 | FCR register write enable KEY1/KEY2
N	uint32_t FOPTKEYR;               // 0x0008 | Reserved
N	union 
N    {	
N       uint32_t FSR;                    // 0x000C | Status register      
N		
N		struct{
N			uint32_t NVSTR         :1 ; //FSR[ 0]
N			uint32_t RSVD3         :1 ; //FSR[ 1]
N			uint32_t PGERR         :1 ; //FSR[ 2]
N			uint32_t RSVD2         :1 ; //FSR[ 3]
N			uint32_t RSVD1         :1 ; //FSR[ 4]
N			uint32_t EOP           :1 ; //FSR[ 5]
N			uint32_t INT_FLITF     :1 ; //FSR[ 6]
N			uint32_t RSVD0         :1 ; //FSR[ 7]
N			uint32_t key1_ok       :1 ; //FSR[ 8]
N			uint32_t key2_ok       :1 ; //FSR[ 9]
N			uint32_t optkey1_ok    :1 ; //FSR[10]
N			uint32_t optkey2_ok    :1 ; //FSR[11]
N			uint32_t ISP_MODE      :1 ; //FSR[12]
N			uint32_t ISP_REGISTER  :1 ; //FSR[13]
N			uint32_t AHBPATH_EN    :1 ; //FSR[14]
N			uint32_t INFOBLK_LOAD  :1 ; //FSR[15]
N			uint32_t STANDBY       :1 ; //FSR[16]
N			uint32_t WFIC_EN       :1 ; //FSR[17]
N			uint32_t OE            :1 ; //FSR[18]
N			uint32_t CS            :1 ; //FSR[19]
N			uint32_t fsm_wfirgset  :1 ; //FSR[20]
N			uint32_t fsm_rdmd      :1 ; //FSR[21]
N			uint32_t fsm_wrmd      :1 ; //FSR[22]
N			uint32_t fsm_scer      :1 ; //FSR[23]
N			uint32_t fsm_mcer      :1 ; //FSR[24]
N			uint32_t fsm_wfic      :1 ; //FSR[25]
N			uint32_t fsm_isp       :1 ; //FSR[26]
N			uint32_t fsm_ifmd      :1 ; //FSR[27]
N			uint32_t fsm_ifbrd     :1 ; //FSR[28]
N			uint32_t fsm_idle      :1 ; //FSR[29]  
N			uint32_t fsm_bist      :1 ; //FSR[30]
N			uint32_t BIST_MODE     :1 ; //FSR[31] 
N		} FSR_b ;
N	};
N
N	union 
N    {		
N		uint32_t FCR;                    // 0x0010 | Control register             
N		struct{
N			uint32_t PG               :1 ;//FCR[ 0]   program
N			uint32_t PER              :1 ;//FCR[ 1]   page erase 
N			uint32_t MER              :1 ;//FCR[ 2]   macro erase
N			uint32_t READ_             :1 ;//FCR[ 3]   read operation
N			uint32_t RSVD0            :2 ;//FCR[5:4]  
N			uint32_t STRT             :1 ;//FCR[ 6]   operation start 
N			uint32_t LOCK             :1 ;//FCR[ 7]   control register write lock : write '1' is only 
N			uint32_t WFRGSET          :1 ;//FCR[ 8]   WFIC mode register setting mode 
N			uint32_t WFIETEN          :1 ;//FCR[ 9]   WFIC mode Enter Enable
N			uint32_t ERRIE            :1 ;//FCR[10]   error interrupt enable 
N			uint32_t RSVD1            :1 ;//FCR[11]   
N			uint32_t EOPIE            :1 ;//FCR[12]   end of operation interrupt enable
N			uint32_t CS_TIE_LOW       :1 ;//FCR[13]   CS Tie Low
N			uint32_t CS_SLP           :1 ;//FCR[14]   CS Controlled by SLEEP signal
N			uint32_t FCR_CE_OPTEN     :1 ;//FCR[15]   CE option control enable (ONLY use in PT measuring cell current) 
N			uint32_t FCR_CE_OPTVAL    :1 ;//FCR[16]   CE option control value (ONLY use in PT measuring cell current) 
N			uint32_t PRFTEN_FCR       :1 ;//FCR[17]   
N			uint32_t RSVD3            :4 ;//FCR[21:18]   
N			uint32_t OTFLTPG_DIS      :1 ;//FCR[22]    On the fly latency programming disable
N			uint32_t CACHE_EN_FCR     :1 ;//FCR[23]    Cache Enable !!! 
N			uint32_t ALTRDEN_FCR      :1 ;//FCR[24]    Cache Enable !!! 
N			uint32_t RSVD4            :5 ;//FCR[29:25]
N			uint32_t IFMDCGEN         :1 ;//FCR[30]    Mode Change Enable, 0 (default) : Option Byte select, 1: r_FCR register select
N			uint32_t NVSSEL           :1 ;//FCR[31]    NVSTR drive select, 0 : TBIT , 1 : Self Count 
N		} FCR_b ;
N	};
N	
N       uint32_t FAR;                    // 0x0014 | Address register 
N	
N	union 
N    {				
N		uint32_t FCR1;                   // 0x0018 | Control register1 
N		struct{
N			uint32_t FCR1_INF         :1 ;//FCR1[0]     INF signal value 
N			uint32_t FCR1_SAVEN       :1 ;//FCR1[1]     SAVEN signal value 
N			uint32_t FCR1_WRONLY      :1 ;//FCR1[2]     WRONLY signal value 
N			uint32_t FCR1_PROG        :1 ;//FCR1[3]     PROG signal value 
N			uint32_t FCR1_PERASE      :1 ;//FCR1[4]     PERASE signal value 
N			uint32_t FCR1_SERASE      :1 ;//FCR1[5]     SERASE signal value 
N			uint32_t FCR1_SAV_SRCSEL  :1 ;//FCR1[6]     SAV_SRCSEL signal value 
N			uint32_t RSVD0            :1 ;//FCR1[7]   
N			uint32_t FCR1_TM          :4 ;//FCR1[11:8]  TM signal value    
N		} FCR1_b ;
N	};
N	
N	union 
N    {		
N		uint32_t FCR2;                   // 0x001C | Control register2
N		struct{
N			uint32_t FCR2_PGM_BYTE_LEN:5 ;//FCR2[4:0]   Byte & Page program and Page write data length
N			uint32_t RSVD0											:2; //FCR2[6:5]
N			uint32_t FCR2_SFR_WREN    :1 ;//FCR2[5]     SFR or non SFR write selection                
N		} FCR2_b ;
N	};
N
N		uint32_t Reserved0;              // 0x0020 | Reserved 
N		uint32_t Reserved1;              // 0x0024 | Reserved
N		uint32_t FWDRLW;                 // 0x0028 | Write Data Buffer Register0
N		uint32_t FACR1;                  // 0x002C | Access Control Register1
N		uint32_t FRDRLW;                 // 0x0030 | Read Data Buffer Register Low Word
N		uint32_t Reserved3;              // 0x0034 | Reserved
N		uint32_t PGERSR0;                // 0x0038 | Page Erase Status  Register 0 
N		uint32_t PGERSR1;                // 0x003C | Page Erase Status  Register 1
N		uint32_t PGERSR2;                // 0x0040 | Page Erase Status  Register 2 
N		uint32_t PGERSR3;                // 0x0044 | Page Erase Status  Register 3 
N
N	union 
N    {		
N		uint32_t ERRESPCR;               // 0x0048 | Error Response Control Register
N		struct{
N			uint32_t EN_KEY1:1 ;
N			uint32_t EN_KEY2    :1 ;
N			uint32_t EN_OPTKEY1    :1 ;
N			uint32_t EN_OPTKEY2    :1 ;
N			uint32_t EN_LOCK_WR0    :1 ;
N			uint32_t RSVD0            :1 ;
N			uint32_t EN_FAR_DW    :1 ;
N			uint32_t EN_FRDRLW    :1 ;
N		} ERRESPCR_b ;
N	};
N
N		uint32_t ISPMSCR;                // 0x004C | SW ISP Mode config register
N		uint32_t EXTRASCR0;              // 0x0050 | Extra System Configuration 0 
N		uint32_t EXTRASCR1;              // 0x0054 | Extra System Configuration 1 
N		uint32_t EXTRASCR2;              // 0x0058 | Extra System Configuration 2 
N		uint32_t EXTRASCR3;              // 0x005C | Extra System Configuration 3 
N		uint32_t PROTECTION;             // 0x0060 | READ data protection
N		uint32_t PGERSR4;                // 0x0064 | Page Erase Status  Register 4 
N		uint32_t PGERSR5;                // 0x0068 | Page Erase Status  Register 5
N		uint32_t PGERSR6;                // 0x006C | Page Erase Status  Register 6 
N		uint32_t PGERSR7;                // 0x0070 | Page Erase Status  Register 7 
N		uint32_t PGERSR8;                // 0x0074 | Page Erase Status  Register 8 
N		uint32_t PGERSR9;                // 0x0078 | Page Erase Status  Register 9 
N		uint32_t PGERSR10;               // 0x007C | Page Erase Status  Register 10 
N		uint32_t IFBRD_TCNT_END;         // 0x0080 | Flash Control signal timing tuning register
N		uint32_t MCER_TCNT_END;          // 0x0084 | Flash Control signal timing tuning register
N		uint32_t SCER_TCNT_END;          // 0x0088 | Flash Control signal timing tuning register
N		uint32_t WRMD_TCNT_END;          // 0x008C | Flash Control signal timing tuning register
N		uint32_t RDMD_TCNT_END;          // 0x0090 | Flash Control signal timing tuning register
N		uint32_t AE_IFBRD_STR;           // 0x0094 | Flash Control signal timing tuning register
N		uint32_t AE_MCER_STR;            // 0x0098 | Flash Control signal timing tuning register
N		uint32_t AE_SCER_STR;            // 0x009C | Flash Control signal timing tuning register
N		uint32_t AE_WRMD_STR;            // 0x00A0 | Flash Control signal timing tuning register
N		uint32_t AE_RDMD_STR;            // 0x00A4 | Flash Control signal timing tuning register
N		uint32_t AE_IFBRD_END;           // 0x00A8 | Flash Control signal timing tuning register
N		uint32_t AE_MCER_END;            // 0x00AC | Flash Control signal timing tuning register
N		uint32_t AE_SCER_END;            // 0x00B0 | Flash Control signal timing tuning register
N		uint32_t AE_WRMD_END;            // 0x00B4 | Flash Control signal timing tuning register
N		uint32_t AE_RDMD_END;            // 0x00B8 | Flash Control signal timing tuning register
N		uint32_t NVSTR_MCER_STR;         // 0x00BC | Flash Control signal timing tuning register
N		uint32_t NVSTR_SCER_STR;         // 0x00C0 | Flash Control signal timing tuning register
N		uint32_t NVSTR_WRMD_STR;         // 0x00C4 | Flash Control signal timing tuning register
N		uint32_t NVSTR_MCER_LTH;         // 0x00C8 | Flash Control signal timing tuning register
N		uint32_t NVSTR_SCER_LTH;         // 0x00CC | Flash Control signal timing tuning register
N		uint32_t NVSTR_WRMD_LTH;         // 0x00D0 | Flash Control signal timing tuning register
N		uint32_t DOUTVALID_IFBRD;        // 0x00D4 | Flash Control signal timing tuning register
N		uint32_t DOUTVALID_RDMD;         // 0x00D8 | Flash Control signal timing tuning register
N		uint32_t A17_WRMD_STR;           // 0x00DC | Flash Control signal timing tuning register
N		uint32_t A17_WRMD_END;           // 0x00E0 | Flash Control signal timing tuning register
N		uint32_t WFRGST_TCNT_END;        // 0x00E4 | Flash Control signal timing tuning register
N		uint32_t DBGR;                   // 0x00E8 | Flash Debug register
N	union 
N    {
N		uint32_t BCR;                    // 0x00EC | Flash BIST : Page Number
N		struct{
N			uint32_t RSVD0            :5 ;
N			uint32_t NB_PG_NUM:10 ;
N			uint32_t RSVD1            :6 ;
N			uint32_t INFO_PG_NUM    :10 ;
N		} BCR_b ;
N	};
N		uint32_t BWDRLW;                 // 0x00F0 | Flash BIST Data register
N		uint32_t FSM_INIT;               // 0x00F4 | Reserved
N	union 
N    {	
N		uint32_t BSCR;                   // 0x00F8 | Flash BIST Control register
N		struct{
N			uint32_t NERASE_EN            :1 ;
N			uint32_t NERRD_EN:1 ;
N			uint32_t NPG_EN            :1 ;
N			uint32_t NPGRD_EN    :1 ;
N			uint32_t IERASE_EN    :1 ;
N			uint32_t IERRD_EN    :1 ;
N			uint32_t IPG_EN    :1 ;
N			uint32_t IPGRD_EN    :1 ;
N			uint32_t SECTOR_NUM    :1 ;
N		} BSCR_b ;
N	};
N		uint32_t DEVID;                  // 0x00FC | Device ID
N		uint32_t FWDRLW01;               // 0x0100 | Write Data Buffer Register01
N		uint32_t FWDRLW02;               // 0x0104 | Write Data Buffer Register02
N		uint32_t FWDRLW03;               // 0x0108 | Write Data Buffer Register03
N		uint32_t FWDRLW04;               // 0x010C | Write Data Buffer Register04
N		uint32_t FWDRLW05;               // 0x0110 | Write Data Buffer Register05
N		uint32_t FWDRLW06;               // 0x0114 | Write Data Buffer Register06
N		uint32_t FWDRLW07;               // 0x0118 | Write Data Buffer Register07
N		uint32_t FWDRLW08;               // 0x011C | Write Data Buffer Register08
N		uint32_t FWDRLW09;               // 0x0120 | Write Data Buffer Register09
N		uint32_t FWDRLW10;               // 0x0124 | Write Data Buffer Register10
N		uint32_t FWDRLW11;               // 0x0128 | Write Data Buffer Register11
N		uint32_t FWDRLW12;               // 0x012C | Write Data Buffer Register12
N		uint32_t FWDRLW13;               // 0x0130 | Write Data Buffer Register13
N		uint32_t FWDRLW14;               // 0x0134 | Write Data Buffer Register14
N		uint32_t FWDRLW15;               // 0x0138 | Write Data Buffer Register15
N		uint32_t FWDRLW16;               // 0x013C | Write Data Buffer Register16
N		uint32_t FWDRLW17;               // 0x0140 | Write Data Buffer Register17
N		uint32_t FWDRLW18;               // 0x0144 | Write Data Buffer Register18
N		uint32_t FWDRLW19;               // 0x0148 | Write Data Buffer Register19
N		uint32_t FWDRLW20;               // 0x014C | Write Data Buffer Register20
N		uint32_t FWDRLW21;               // 0x0150 | Write Data Buffer Register21
N		uint32_t FWDRLW22;               // 0x0154 | Write Data Buffer Register22
N		uint32_t FWDRLW23;               // 0x0158 | Write Data Buffer Register23
N		uint32_t FWDRLW24;               // 0x015C | Write Data Buffer Register24
N		uint32_t FWDRLW25;               // 0x0160 | Write Data Buffer Register25
N		uint32_t FWDRLW26;               // 0x0164 | Write Data Buffer Register26
N		uint32_t FWDRLW27;               // 0x0168 | Write Data Buffer Register27
N		uint32_t FWDRLW28;               // 0x016C | Write Data Buffer Register28
N		uint32_t FWDRLW29;               // 0x0170 | Write Data Buffer Register29
N		uint32_t FWDRLW30;               // 0x0174 | Write Data Buffer Register30
N		uint32_t FWDRLW31;               // 0x0178 | Write Data Buffer Register31
N		uint32_t PGERSR11;               // 0x017C | Page Erase Status  Register 11
N		uint32_t PGERSR12;               // 0x0180 | Page Erase Status  Register 12
N		uint32_t PGERSR13;               // 0x0184 | Page Erase Status  Register 13
N		uint32_t PGERSR14;               // 0x0188 | Page Erase Status  Register 14
N		uint32_t PGERSR15;               // 0x018C | Page Erase Status  Register 15
N		uint32_t PGERSR16;               // 0x0190 | Page Erase Status  Register 16
N		uint32_t PGERSR17;               // 0x0194 | Page Erase Status  Register 17
N		uint32_t PGERSR18;               // 0x0198 | Page Erase Status  Register 18
N		uint32_t PGERSR19;               // 0x019C | Page Erase Status  Register 19
N		uint32_t PGERSR20;               // 0x01A0 | Page Erase Status  Register 20
N		uint32_t PGERSR21;               // 0x01A4 | Page Erase Status  Register 21
N		uint32_t PGERSR22;               // 0x01A8 | Page Erase Status  Register 22
N		uint32_t PGERSR23;               // 0x01AC | Page Erase Status  Register 23
N		uint32_t PGERSR24;               // 0x01B0 | Page Erase Status  Register 24
N		uint32_t PGERSR25;               // 0x01B4 | Page Erase Status  Register 25
N		uint32_t PGERSR26;               // 0x01B8 | Page Erase Status  Register 26
N		uint32_t PGERSR27;               // 0x01BC | Page Erase Status  Register 27
N		uint32_t PGERSR28;               // 0x01C0 | Page Erase Status  Register 28
N		uint32_t PGERSR29;               // 0x01C4 | Page Erase Status  Register 29
N		uint32_t PGERSR30;               // 0x01C8 | Page Erase Status  Register 30
N		uint32_t PGERSR31;               // 0x01CC | Page Erase Status  Register 31
N} FLITF_TypeDef ;
N
Ntypedef struct
N{
N
N  union {
N    __I  uint32_t  CALIB_OSC  ;       
X    volatile const  uint32_t  CALIB_OSC  ;       
N    
N    struct {
N      __I  uint32_t  R_FINE   :  4;  
X      volatile const  uint32_t  R_FINE   :  4;  
N      __I  uint32_t  R_COARSE :  4;  
X      volatile const  uint32_t  R_COARSE :  4;  
N    } CALIB_OSC_b;                      
N  } ;
N
N
N  union {
N    __I  uint32_t  CALIB_LDO ;       
X    volatile const  uint32_t  CALIB_LDO ;       
N    
N    struct {
N      __I  uint32_t  CAL_SEL :  4;  
X      volatile const  uint32_t  CAL_SEL :  4;  
N    } CALIB_LDO_b;                      
N  } ;
N
N
N} INFO_TypeDef;
N
N//ECCBOOT_v3.00 : CRC Info
Ntypedef struct
N{	
N	uint32_t CRC_1;   
N	uint32_t CRC_2;   
N	
N} BACKUP_CRC_TypeDef;
N
N//ECCBOOT_v3.00 : Back-Up Info
Ntypedef struct
N{	
N	union {
N		uint32_t I2C_BOOT_INFO;
N
N		struct {
N			uint32_t	DUMMY			:  8;
N			uint32_t	I2C_SADDR		:  8;
N			uint32_t	BOOT_VERSION	:  16;
N		} I2C_BOOT_INFO_b;
N	};
N
N	union {
N		uint32_t VID_PID_INFO;
N
N		struct {
N			uint32_t	VID_INFO		:  16;
N			uint32_t	PID_INFO		:  16;
N		} VID_PID_INFO_b;
N	};
N	
N} BACKUP_INFO_TypeDef;
N
N//ECCBOOT_v3.00 : Back-Up Info Error
Ntypedef struct
N{	
N	union {
N		uint32_t BACKUP_INFO_ERROR;
N
N		struct {
N			uint32_t	I2C_INFO_ERROR		:  8;
N			uint32_t	BOOT_VER_ERROR		:  8;
N			uint32_t	VID_INFO_ERROR		:  8;
N			uint32_t	PID_INFO_ERROR		:  8;
N		} BACKUP_INFO_ERROR_b;
N	};
N	
N} BACKUP_INFO_ERROR_TypeDef, *P_BACKUP_INFO_ERROR_TypeDef;
L 284 "..\..\Hal\system\MFTP.h" 2
N#include "_mspi.h"
L 1 "..\..\Hal\spi\_mspi.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _mspi.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __MSPI_H_
N#define __MSPI_H_
N
N
N#include "mspi_.h"
L 1 "..\..\Hal\spi\mspi_.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : mspi_.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MSPI__H_
N#define _MSPI__H_
N
N
N//----------------------------------------------------------------------------------------------
N// SPI CR register setting parameters
N//----------------------------------------------------------------------------------------------
N#define bitLen8			(0)
N#define bitLen10		(1)
N#define bitLen12		(2)
N#define bitLen16		(3)
N#define mosiOutEn		(1)
N#define mosiOutDis		(0)
N#define CphaIs0			(0)
N#define CphaIs1			(1)
N#define CpolIs0			(0)
N#define CpolIs1			(1)
N#define spiMstMode		(1)
N#define spiSlvMode		(0)
N#define LsbFirst		(1)
N#define MsbFirst		(0)
N#define spiEna			(1)
N#define spiDis			(0)
N
N//----------------------------------------------------------------------------------------------
N// SPI FIFO CR register setting parameters
N//----------------------------------------------------------------------------------------------
N#define FifoTxClr		(1)
N#define FifoTxLet		(0)
N#define FifoRxClr		(1)
N#define FifoRxLet		(0)
N#define FifoRxWmLv31	(31)
N#define FifoRxWmLv16	(16)
N#define FifoRxWmLv08	(8)
N#define FifoRxWmLv02	(2)
N#define FifoRxWmLv01	(1)
N#define FifoRxWmLv00	(0)
N#define FifoTxWmLv31	(31)
N#define FifoTxWmLv16	(16)
N#define FifoTxWmLv08 	(8)
N#define FifoTxWmLv02 	(2)
N#define FifoTxWmLv01 	(1)
N#define FifoTxWmLv00 	(0)
N#define FifoTxDmaEna 	(1)
N#define FifoTxDmaDis 	(0)
N#define FifoRxDmaEna 	(1)
N#define FifoRxDmaDis 	(0)
N#define FifoTxErrClr 	(1)
N#define FifoTxErrLet 	(0)
N#define FifoRxErrClr 	(1)
N#define FifoRxErrLet 	(0)
N
N//----------------------------------------------------------------------------------------------
N// SPI Enalbe & Transfer Size register setting parameters
N//----------------------------------------------------------------------------------------------
N#define spi0TxEna 		(1)
N#define spi1TxEna 		(1)
N#define spi2TxEna 		(1)
N#define spi3TxEna 		(1)
N#define spi4TxEna 		(1)
N#define spi5TxEna 		(1)
N
N#define spi0TxDis 		(0)
N#define spi1TxDis 		(0)
N#define spi2TxDis 		(0)
N#define spi3TxDis 		(0)
N#define spi4TxDis 		(0)
N#define spi5TxDis 		(0)
N
N#define spi0RxEna 		(1)
N#define spi1RxEna 		(1)
N#define spi2RxEna 		(1)
N#define spi3RxEna 		(1)
N#define spi4RxEna 		(1)
N#define spi5RxEna 		(1)
N
N#define spi0RxDis 		(0)
N#define spi1RxDis 		(0)
N#define spi2RxDis 		(0)
N#define spi3RxDis 		(0)
N#define spi4RxDis 		(0)
N#define spi5RxDis 		(0)
N
N#define TxEna0 			(1)
N#define TxEna1 			(1)
N#define TxEna2 			(1)
N#define TxEna3 			(1)
N#define TxEna4 			(1)
N#define TxEna5 			(1)
N
N#define TxDis0 			(0)
N#define TxDis1 			(0)
N#define TxDis2 			(0)
N#define TxDis3 			(0)
N#define TxDis4 			(0)
N#define TxDis5 			(0)
N
N#define RxEna0 			(1)
N#define RxEna1 			(1)
N#define RxEna2 			(1)
N#define RxEna3 			(1)
N#define RxEna4 			(1)
N#define RxEna5 			(1)
N
N#define RxDis0 			(0)
N#define RxDis1 			(0)
N#define RxDis2 			(0)
N#define RxDis3 			(0)
N#define RxDis4 			(0)
N#define RxDis5 			(0)
N
N#define spi0TrSze 		(8)
N#define spi1TrSze 		(8)
N#define spi2TrSze 		(8)
N#define spi3TrSze 		(8)
N#define spi4TrSze 		(8)
N#define spi5TrSze 		(8)
N
N//----------------------------------------------------------------------------------------------
N// SPI Each State length setting parameters
N//----------------------------------------------------------------------------------------------
N#define spiPreShftLenIs2  		(2)
N#define spiTmpIdleLenIs2  		(2)
N#define spiPostShftLenIs2 		(2)
N#define spiPostShftLenIs4 		(4)
N#define spiPostShftLenIs5 		(5)
N#define spiPostShftLenIs6 		(6)
N#define spiPostShftLenIs8 		(8)
N#define spiPostShftLenIsF 		(15)
N#define spiSnglIdleLenIs2 		(2)
N#define spiAitIdleLenIs2 		(2)
N#define spiAitIdleLenIs8 		(8)
N#define spiAitIdleLenIs9 		(9)
N
N//----------------------------------------------------------------------------------------------
N// SPI Operation Start Command register setting 
N//----------------------------------------------------------------------------------------------
N#define spiStartAll 			(63)
N#define spiStart0 				(1)
N#define spiStart1 				(2)
N#define spiStart2 				(4)
N#define spiStart3 				(8)
N#define spiStart4 				(16)
N#define spiStart5 				(32)
N
N//----------------------------------------------------------------------------------------------
N// SPI Operation Mode register setting 
N//----------------------------------------------------------------------------------------------
N#define spiTlpMode 				0
N#define spiAitMode 				1
N#define spiFifoMode 0
N#define spiSramMode 1
N#define spiSwMode 0
N#define spiHwMode 1
N#define spiSnglMode 1
N#define spiBrstMode 1
N#define spiSramNormMode 0
N#define spiSramDebugMode 1
N#define spiSramWrDefault 0
N#define spiSramWrOpt 1
N#define spiTrsPerWr0 0
N#define spiTrsPerWr1 1
N#define spiTrsPerWr2 2
N#define spiTrsPerRd0 0
N#define spiTrsPerRd1 1
N#define spiTrsPerRd2 2
N#define spiPwfe0Sel 0
N#define spiPwfe1Sel 1
N#define spiPwfe2Sel 2
N#define spiPwfe3Sel 3
N#define spiPwfe4Sel 4
N#define spiPwfe5Sel 5
N#define spiCommPwfeSel 1
N#define spiEachPwfeSel 0
N#define spiNonProtocol 0
N#define spiTlpProtocol 1
N#define spiHatProtocol 2
N#define spiRdHlfWrdLsbFrst 0
N#define spiRdHlfWrdMsbFrst 1
N#define spiWrHlfWrdLsbFrst 0
N#define spiWrHlfWrdMsbFrst 1
N
N//----------------------------------------------------------------------------------------------
N// SPI example pattern for Optional Write Mode
N//----------------------------------------------------------------------------------------------
N#define spiStrtWAd0 7
N#define spiStrtWAd1 115
N#define spiStrtWAd2 231
N#define spiStrtWAd3 364
N#define spiStrtWAd4 528
N#define spiStrtWAd5 755
N
N#define spiStrtRAd0 1007
N#define spiStrtRAd1 1115
N#define spiStrtRAd2 1231
N#define spiStrtRAd3 1364
N#define spiStrtRAd4 1528
N#define spiStrtRAd5 1755
N
N#define spiStrtDin0 99
N#define spiStrtDin1 55
N#define spiStrtDin2 33
N#define spiStrtDin3 66
N#define spiStrtDin4 1010
N#define spiStrtDin5 1212
N
N//----------------------------------------------------------------------------------------------
N// SPI Interrupt Masking register setting
N//----------------------------------------------------------------------------------------------
N#define IntrAitWlvEna 1
N#define IntrAitWlvDis 0
N#define IntrMemEna 1
N#define IntrMemDis 0
N#define IntrRoriEna 1
N#define IntrRoriDis 0
N#define IntrToriEna 1
N#define IntrToriDis 0
N#define IntrRxuriEna 1
N#define IntrRxuriDis 0
N#define IntrTxuriEna 1
N#define IntrTxuriDis 0
N#define IntrRxiEna 1
N#define IntrRxiDis 0
N#define IntrTxiEna 1
N#define IntrTxiDis 0
N
N//----------------------------------------------------------------------------------------------
N// TLP/HAT SPIS regiser setting             
N//----------------------------------------------------------------------------------------------
N#define SensBase 0
N#define RefrBase 4
N#define CfgrBase 8
N#define TlpWrite 0
N#define TlpRead  1
N#define TlpBulk  0
N#define TlpSngl  1 
N
N#define HatSensBase 0
N#define HatRefrBase 4
N#define HatCfgrBase 8
N#define HatWrite 0
N#define HatRead  1
N#define HatBulk  0
N#define HatSngl  1 
N
N#define TlpAddr0 0 
N#define TlpAddr2 2 
N#define TlpAddr4 4 
N#define TlpAddr6 6 
N
N#define TlpAddr8 8 
N#define TlpAddrA 10 
N#define TlpAddrC 12 
N#define TlpAddrE 14 
N
N#define HatAddr0 0 
N#define HatAddr2 2 
N#define HatAddr4 4 
N#define HatAddr6 6 
N
N#define HatAddr8 8 
N#define HatAddrA 10 
N#define HatAddrC 12 
N#define HatAddrE 14
N
N#define TlpWDat0 0
N
N#define HatWDat0 0
N
N//#define HatIndvl 8'h40
N//#define HatIndvl 8'h41
N
N
N#define spiAitWlvEna 1
N#define spiAitWlvDis 0
N#define spiAitWlvSel0 0
N#define spiAitWlvSel1 1
N#define spiAitWlvSel2 2
N#define spiAitWlvSel3 3
N#define spiAitWlvSel4 4
N#define spiAitWlvSel5 5
N
N#define AitDmyDelEna 1
N#define AitDmyDelDis 0
N
N//----------------------------------------------------------------------------------------------
N// RAIT SPIS regiser setting             
N//----------------------------------------------------------------------------------------------
N#define AlgnLbuf 0
N#define Ait0Lbuf 1
N#define Ait1Lbuf 2
N#define AitCfgr0 3
N#define AitCfgr1 4
N
N#define AitWrite 0
N#define AitRead  1
N#define AitBulk  0
N#define AitSngl  1 
N
N#define AitAddr0 0 
N#define AitAddr2 2 
N#define AitAddr4 4 
N#define AitAddr6 6 
N
N#define MdIdle   0
N#define SnrStr   2
N#define MdGnrl   4
N#define AipAdc   6
N#define SsuCtrl  8
N#define TsyncNum0 10
N#define TsyncNum1 12
N#define TsyncDmy1 14
N#define PwmNum0   16
N#define PwmNum1   18 
N#define CmuxNrm   20 
N#define CmuxNse   22 
N//#define ColNum    24 
N//#define RowNum    26 
N#define DigGain0  28 
N#define DigGain1  30 
N#define NihMin0   32 
N#define NihMax0   34 
N#define NihMin1   36 
N#define NihMax1   38 
N#define NihMin2   40 
N#define NihMax2   42 
N#define NihMin3   44 
N#define NihMax3   46 
N#define NihRdat0  48 
N#define NihRdat1  50 
N#define NihRdat2  52 
N#define NihRdat3  54 
N#define MdSpcl    56 
N#define ShaStr0   58 
N#define ShaStr1   60 
N#define ShaStr2   62 
N#define VcrStr    64 
N#define VcrNum0   66 
N#define VcrNum1   68 
N#define VcrNum2   70 
N#define VcrNum3   72 
N#define VcrNum4   74 
N#define VcrNum5   76 
N
N#define StrTsync0Is0 0 
N#define EndTsync0Is1 1 
N#define StrTsync1Is0 0 
N#define EndTsync1Is1 1 
N#define DmyTsync1Is0 0 
N#define ChMxIntvlIs8 8 
N#define PrePwmNumIs5 5 
N#define SetPwmNumIs1 1 
N#define ActPwmNumIs20 20 
N#define DinPwmNumIs4 4 
N#define StrCmxNumIs0 0 
N#define EndCmxNumIs15 15 
N#define Ni1CmxNumIs8 8 
N#define Ni2CmxNumIs8 8 
N#define StrColNumIs0 0 
N#define EndColNumIs6 6 
N#define EndColNumIs19 19 
N#define ColLen0IsIs7 7 
N#define ColLen1IsIs7 7 
N#define ColLen0Is15 15 
N#define ColLen1Is15 15 
N#define ColLen0Is20 20 
N#define ColLen1Is20 20 
N#define EndRowNumIs49 49 
N#define TopOuterEna  1 
N#define TopOuterDis  0 
N#define BotOuterEna  1 
N#define BotOuterDis  0 
N#define LefOuterEna  1 
N#define LefOuterDis  0 
N#define RghtOuterEna  1 
N#define RghtOuterDis  0 
N
N
N#endif /* _MSPI__H_ */
L 38 "..\..\Hal\spi\_mspi.h" 2
N
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t BITLEN			:2;			  // Bit Length 							  2    00:8bit, 01:10Bit, 02:12Bit, 03:16Bit
X		volatile uint32_t BITLEN			:2;			  
N		__IO uint32_t DOUTEN			:1;			  // Data Out Enable						  3    1:MOSI Enable, 0:Disable
X		volatile uint32_t DOUTEN			:1;			  
N		__IO uint32_t CPHA				:1;			  // Clock Phase							  4    1:Leading Edge - Setup, Trailing Edge - Sample,	 0: Leading Edge - Sample, Trailing Edge - Setup
X		volatile uint32_t CPHA				:1;			  
N		__IO uint32_t CPOL				:1;			  // Clock Polarity 						  5    1:Leading Edge - Falling, Trailing Edge - Rising,   0:Leading Edge - Rising, Trailing Edge - Falling
X		volatile uint32_t CPOL				:1;			  
N		__IO uint32_t MSTR				:1;			  // Mster/Slave Select 					  6    1:Master, 0:Slave
X		volatile uint32_t MSTR				:1;			  
N		__IO uint32_t DORD              :1;			  // Data Order 							  7    1:LSB First, 0:MSB First (Default)
X		volatile uint32_t DORD              :1;			  
N		__IO uint32_t SPE				:1;			  // SPI Enable 							  8
X		volatile uint32_t SPE				:1;			  
N		__IO uint32_t LBM				:1;			  // LooP Back Mode 						  9    1:LOOP_BACK_MODE, 0:Normal Operation
X		volatile uint32_t LBM				:1;			  
N		__IO uint32_t SSOSEL			:1;			  // SSO Select 							  10   1:External Control SSO Signal, 0:Auto Generation SSO SPI Slave Select
X		volatile uint32_t SSOSEL			:1;			  
N		__IO uint32_t SSOEXT			:1;			  // Master SSO Signal Register Setting 	  11   1:Master Slave Select Disable, 0:Master Slave Select Enable
X		volatile uint32_t SSOEXT			:1;			  
N		__I uint32_t RESERVED0			:5;		  	  // Not Used
X		volatile const uint32_t RESERVED0			:5;		  	  
N		__IO uint32_t CKMAXRATE			:3;			  // Not Used
X		volatile uint32_t CKMAXRATE			:3;			  
N		__I uint32_t RESERVED1			:1; 		  // Not Used
X		volatile const uint32_t RESERVED1			:1; 		  
N		__IO uint32_t CKMAXPRE			:3;			  // Not Used
X		volatile uint32_t CKMAXPRE			:3;			  
N		__I uint32_t RESERVED2			:1; 		  // Not Used
X		volatile const uint32_t RESERVED2			:1; 		  
N		__IO uint32_t SWPRST			:1;			  // APB CLK domain block reset						1:Reset, 0,Release
X		volatile uint32_t SWPRST			:1;			  
N		__IO uint32_t SWHRST			:1;			  // AHB CLK domain block reset						1:Reset, 0,Release
X		volatile uint32_t SWHRST			:1;			  
N		__I uint32_t RESERVED3			:6; 		  // Not Used
X		volatile const uint32_t RESERVED3			:6; 		  
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;				  /// 0x0000 | SPI Control register 					  | 0x00000002
X	volatile uint32_t ulBulk;				  
N
N} __PACKED tMSPI_SCR_t;
X} __attribute__ ((packed)) tMSPI_SCR_t;
N
N
Ntypedef union
N{
N	struct
N	{
N		__IO uint32_t spiTxEna0			:1;
X		volatile uint32_t spiTxEna0			:1;
N		__IO uint32_t spiTxEna1			:1;
X		volatile uint32_t spiTxEna1			:1;
N		__IO uint32_t spiTxEna2			:1;
X		volatile uint32_t spiTxEna2			:1;
N		__IO uint32_t spiTxEna3			:1;
X		volatile uint32_t spiTxEna3			:1;
N		__IO uint32_t spiTxEna4			:1;
X		volatile uint32_t spiTxEna4			:1;
N		__IO uint32_t spiTxEna5         :1;
X		volatile uint32_t spiTxEna5         :1;
N		__I uint32_t RESERVED0			:2;
X		volatile const uint32_t RESERVED0			:2;
N		__IO uint32_t spiRxEna0			:1;
X		volatile uint32_t spiRxEna0			:1;
N		__IO uint32_t spiRxEna1			:1;
X		volatile uint32_t spiRxEna1			:1;
N		__IO uint32_t spiRxEna2			:1;
X		volatile uint32_t spiRxEna2			:1;
N		__IO uint32_t spiRxEna3			:1;
X		volatile uint32_t spiRxEna3			:1;
N		__IO uint32_t spiRxEna4			:1;
X		volatile uint32_t spiRxEna4			:1;
N		__IO uint32_t spiRxEna5			:1;
X		volatile uint32_t spiRxEna5			:1;
N		__I uint32_t RESERVED1			:18;
X		volatile const uint32_t RESERVED1			:18;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tMSPI_SPIENA_t;
X} __attribute__ ((packed)) tMSPI_SPIENA_t;
N
N
Ntypedef struct
N{
N	union {
N
N		__IO uint32_t SCR;				  /// 0x0000 | SPI Control register 					  | 0x00000002
X		volatile uint32_t SCR;				  
N
N		struct {
N			__IO uint32_t BITLEN			:2;			  // Bit Length 							  2    00:8bit, 01:10Bit, 02:12Bit, 03:16Bit
X			volatile uint32_t BITLEN			:2;			  
N			__IO uint32_t DOUTEN			:1;			  // Data Out Enable						  3    1:MOSI Enable, 0:Disable
X			volatile uint32_t DOUTEN			:1;			  
N			__IO uint32_t CPHA				:1;			  // Clock Phase							  4    1:Leading Edge - Setup, Trailing Edge - Sample,	 0: Leading Edge - Sample, Trailing Edge - Setup
X			volatile uint32_t CPHA				:1;			  
N			__IO uint32_t CPOL				:1;			  // Clock Polarity 						  5    1:Leading Edge - Falling, Trailing Edge - Rising,   0:Leading Edge - Rising, Trailing Edge - Falling
X			volatile uint32_t CPOL				:1;			  
N			__IO uint32_t MSTR				:1;			  // Mster/Slave Select 					  6    1:Master, 0:Slave
X			volatile uint32_t MSTR				:1;			  
N			__IO uint32_t DORD              :1;			  // Data Order 							  7    1:LSB First, 0:MSB First (Default)
X			volatile uint32_t DORD              :1;			  
N			__IO uint32_t SPE				:1;			  // SPI Enable 							  8
X			volatile uint32_t SPE				:1;			  
N			__IO uint32_t LBM				:1;			  // LooP Back Mode 						  9    1:LOOP_BACK_MODE, 0:Normal Operation
X			volatile uint32_t LBM				:1;			  
N			__IO uint32_t SSOSEL			:1;			  // SSO Select 							  10   1:External Control SSO Signal, 0:Auto Generation SSO SPI Slave Select
X			volatile uint32_t SSOSEL			:1;			  
N			__IO uint32_t SSOEXT			:1;			  // Master SSO Signal Register Setting 	  11   1:Master Slave Select Disable, 0:Master Slave Select Enable
X			volatile uint32_t SSOEXT			:1;			  
N			__I uint32_t RESERVED0			:5;		  	  // Not Used
X			volatile const uint32_t RESERVED0			:5;		  	  
N			__IO uint32_t CKMAXRATE			:3;			  // Not Used
X			volatile uint32_t CKMAXRATE			:3;			  
N			__I uint32_t RESERVED1			:1; 		  // Not Used
X			volatile const uint32_t RESERVED1			:1; 		  
N			__IO uint32_t CKMAXPRE			:3;			  // Not Used
X			volatile uint32_t CKMAXPRE			:3;			  
N			__I uint32_t RESERVED2			:1; 		  // Not Used
X			volatile const uint32_t RESERVED2			:1; 		  
N			__IO uint32_t SWPRST			:1;			  // APB CLK domain block reset						1:Reset, 0,Release
X			volatile uint32_t SWPRST			:1;			  
N			__IO uint32_t SWHRST			:1;			  // AHB CLK domain block reset						1:Reset, 0,Release
X			volatile uint32_t SWHRST			:1;			  
N			__I uint32_t RESERVED3			:6; 		  // Not Used
X			volatile const uint32_t RESERVED3			:6; 		  
N		} SCR_b;								   /*!< BitSize 		  */
N	};
N
N	__IO uint32_t SDR0;                 /// 0x0004 | SPI0 FIFO Access register                  | 0x00000000
X	volatile uint32_t SDR0;                 
N	__IO uint32_t SSR0;                 /// 0x0008 | SPI0 Status register                       | 0x00000000
X	volatile uint32_t SSR0;                 
N	__IO uint32_t SFIFOCR;              /// 0x000C | FIFO Control register                      | 0x00000000
X	volatile uint32_t SFIFOCR;              
N	__IO uint32_t SINTRSR;              /// 0x0010 | Interrupt Status register                  | 0x30001080
X	volatile uint32_t SINTRSR;              
N	__IO uint32_t SINTRMSSR;            /// 0x0014 | Interrupt Masked Status register           | 0x00000000
X	volatile uint32_t SINTRMSSR;            
N
N	union {
N
N		__IO uint32_t SINTRMSCR;			  /// 0x0018 | Interrupt Mask Control register			  | 0x00000000
X		volatile uint32_t SINTRMSCR;			  
N
N		struct {
N			__IO uint32_t Not_Used				:6;
X			volatile uint32_t Not_Used				:6;
N			__IO uint32_t IntrMemMSCR 			:1;
X			volatile uint32_t IntrMemMSCR 			:1;
N			__IO uint32_t IntrAitWlvMSCR 		:1;
X			volatile uint32_t IntrAitWlvMSCR 		:1;
N			__IO uint32_t IntrAitWlvMSCR1		:1;
X			volatile uint32_t IntrAitWlvMSCR1		:1;
N			__IO uint32_t IntrAitWlvMSCR2		:1;
X			volatile uint32_t IntrAitWlvMSCR2		:1;
N			__IO uint32_t IntrAitWlvMSCR3		:1;
X			volatile uint32_t IntrAitWlvMSCR3		:1;
N		} SINTRMSCR_b;								   /*!< BitSize 		  */
N	};
N
N	__IO uint32_t SINTRENCR;            /// 0x001C | Interrupt Clear register                   | 0x30000000
X	volatile uint32_t SINTRENCR;            
N
N
N
N	__IO uint32_t SFIFORXPTR;           /// 0x0020 | RX FIFO Pointer status register            | 0x00000000
X	volatile uint32_t SFIFORXPTR;           
N	__IO uint32_t SFIFORXDIFFPTR;       /// 0x0024 | RX FIFO Pointer difference status register | 0x00000000
X	volatile uint32_t SFIFORXDIFFPTR;       
N	__IO uint32_t SFIFOTXPTR;           /// 0x0028 | TX FIFO Pointer status register            | 0x00000000
X	volatile uint32_t SFIFOTXPTR;           
N	__IO uint32_t SFIFOTXDIFFPTR;       /// 0x002C | TX FIFO Pointer difference status register | 0x00000000
X	volatile uint32_t SFIFOTXDIFFPTR;       
N	__IO uint32_t SDATACNTTXRX;         /// 0x0030 | TX RX COUNTER status register              | 0x00000000
X	volatile uint32_t SDATACNTTXRX;         
N	__IO uint32_t Reserved1;            /// 0x0034 | Reserved 1                                 | 0x00000000
X	volatile uint32_t Reserved1;            
N	__IO uint32_t Reserved2;            /// 0x0038 | Reserved 2                                 | 0x00000000
X	volatile uint32_t Reserved2;            
N	__IO uint32_t Reserved3;            /// 0x003C | Reserved 3                                 | 0x00000000
X	volatile uint32_t Reserved3;            
N	__IO uint32_t Reserved4;            /// 0x0040 | Reserved 4                                 | 0x00000000
X	volatile uint32_t Reserved4;            
N
N	__IO uint32_t SMISC;                /// 0x0044 | Miscellaneous register                     | 0x00000000
X	volatile uint32_t SMISC;                
N
N	__IO uint32_t Reserved5;            /// 0x0048 | Reserved 5                                 | 0x00000000
X	volatile uint32_t Reserved5;            
N	__IO uint32_t Reserved6;            /// 0x004C | Reserved 6                                 | 0x00000000
X	volatile uint32_t Reserved6;            
N
N	__IO uint32_t Reserved7;            /// 0x0050 | Reserved 7                                 | 0x00000000
X	volatile uint32_t Reserved7;            
N	__IO uint32_t Reserved8;            /// 0x0054 | Reserved 8                                 | 0x00000000
X	volatile uint32_t Reserved8;            
N	__IO uint32_t Reserved9;            /// 0x0058 | Reserved 9                                 | 0x00000000
X	volatile uint32_t Reserved9;            
N	__IO uint32_t Reserved10;           /// 0x005C | Reserved 10                                | 0x00000000
X	volatile uint32_t Reserved10;           
N	__IO uint32_t Reserved11;           /// 0x0060 | Reserved 11                                | 0x00000000
X	volatile uint32_t Reserved11;           
N	__IO uint32_t Reserved12;           /// 0x0064 | Reserved 12                                | 0x00000000
X	volatile uint32_t Reserved12;           
N	__IO uint32_t Reserved13;           /// 0x0068 | Reserved 13                                | 0x00000000
X	volatile uint32_t Reserved13;           
N	__IO uint32_t Reserved14;           /// 0x006C | Reserved 14                                | 0x00000000
X	volatile uint32_t Reserved14;           
N	__IO uint32_t Reserved15;           /// 0x0070 | Reserved 15                                | 0x00000000
X	volatile uint32_t Reserved15;           
N	__IO uint32_t Reserved16;           /// 0x0074 | Reserved 16                                | 0x00000000
X	volatile uint32_t Reserved16;           
N	__IO uint32_t Reserved17;           /// 0x0078 | Reserved 17                                | 0x00000000
X	volatile uint32_t Reserved17;           
N	__IO uint32_t Reserved18;           /// 0x007C | Reserved 18                                | 0x00000000
X	volatile uint32_t Reserved18;           
N	__IO uint32_t Reserved19;           /// 0x0080 | Reserved 19                                | 0x00000030
X	volatile uint32_t Reserved19;           
N	__IO uint32_t SDR1;                 /// 0x0084 | SPI1 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR1;                 
N	__IO uint32_t SDR2;                 /// 0x0088 | SPI2 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR2;                 
N	__IO uint32_t SDR3;                 /// 0x008C | SPI3 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR3;                 
N	__IO uint32_t SDR4;                 /// 0x0090 | SPI4 FIFO Access register                  | 0x00000030
X	volatile uint32_t SDR4;                 
N	__IO uint32_t SDR5;                 /// 0x0094 | SPI5 FIFO Access register                  | 0x00000010
X	volatile uint32_t SDR5;                 
N	__IO uint32_t SSR1;                 /// 0x0098 | SPI1 Status register                       | 0x00000010
X	volatile uint32_t SSR1;                 
N	__IO uint32_t SSR2;                 /// 0x009C | SPI2 Status register                       | 0x00000010
X	volatile uint32_t SSR2;                 
N	__IO uint32_t SSR3;                 /// 0x00A0 | SPI3 Status register                       | 0x00000010
X	volatile uint32_t SSR3;                 
N	__IO uint32_t SSR4;                 /// 0x00A4 | SPI4 Status register                       | 0x00000010
X	volatile uint32_t SSR4;                 
N	__IO uint32_t SSR5;                 /// 0x00A8 | SPI5 Status register                       | 0x00000020
X	volatile uint32_t SSR5;                 
N
N	__IO uint32_t SPIENA;               /// 0x00AC | SPI0~5 TX RX Enable register               | 0x00000020
X	volatile uint32_t SPIENA;               
N
N	__IO uint32_t SPITRSZE0;            /// 0x00B0 | SPI0 Transfer Size register                | 0x00000020
X	volatile uint32_t SPITRSZE0;            
N	__IO uint32_t SPITRSZE1;            /// 0x00B4 | SPI1 Transfer Size register                | 0x00000020
X	volatile uint32_t SPITRSZE1;            
N	__IO uint32_t SPITRSZE2;            /// 0x00B8 | SPI2 Transfer Size register                | 0x00000020
X	volatile uint32_t SPITRSZE2;            
N	__IO uint32_t SPITRSZE3;            /// 0x00BC | SPI3 Transfer Size register                | 0x00000018
X	volatile uint32_t SPITRSZE3;            
N	__IO uint32_t SPITRSZE4;            /// 0x00C0 | SPI4 Transfer Size register                | 0x00000018
X	volatile uint32_t SPITRSZE4;            
N	__IO uint32_t SPITRSZE5;            /// 0x00C4 | SPI5 Transfer Size register                | 0x00000018
X	volatile uint32_t SPITRSZE5;            
N	__IO uint32_t SPIINTSEL;            /// 0x00C8 | SPI Interrupt Selection register           | 0x00040000
X	volatile uint32_t SPIINTSEL;            
N
N	union {
N
N		__IO uint32_t SPISTATELEN;		  /// 0x00CC | SPI TIMING LENGTH register				  | 0x0000F000
X		volatile uint32_t SPISTATELEN;		  
N
N		struct {
N			__IO uint32_t PreShftLen			:8;
X			volatile uint32_t PreShftLen			:8;
N			__IO uint32_t TmpIdleLen 			:8;
X			volatile uint32_t TmpIdleLen 			:8;
N			__IO uint32_t PostShftLen 			:8;
X			volatile uint32_t PostShftLen 			:8;
N			__IO uint32_t SnglIdleLen 			:4;
X			volatile uint32_t SnglIdleLen 			:4;
N			__IO uint32_t AitIdleLen			:4;
X			volatile uint32_t AitIdleLen			:4;
N		} SPISTATELEN_b;								   /*!< BitSize 		  */
N	};
N
N
N	union {
N
N		__IO uint32_t SPIMODE;			  /// 0x00D0 | SPI Operation Mode register				  | 0x00000300
X		volatile uint32_t SPIMODE;			  
N
N		struct {
N			__IO uint32_t AitTlpMode			:1;
X			volatile uint32_t AitTlpMode			:1;
N			__IO uint32_t SramFifoMode 			:1;
X			volatile uint32_t SramFifoMode 			:1;
N			__IO uint32_t HwSwMode 				:1;
X			volatile uint32_t HwSwMode 				:1;
N			__IO uint32_t BrstSnglMode 			:1;
X			volatile uint32_t BrstSnglMode 			:1;
N			__IO uint32_t SramDebugMode			:1;
X			volatile uint32_t SramDebugMode			:1;
N			__IO uint32_t SramWrOpt				:1;
X			volatile uint32_t SramWrOpt				:1;
N			__IO uint32_t reserved 				:2;
X			volatile uint32_t reserved 				:2;
N			__IO uint32_t TrsPerRd 				:2;
X			volatile uint32_t TrsPerRd 				:2;
N			__IO uint32_t TrsPerWr 				:2;
X			volatile uint32_t TrsPerWr 				:2;
N			__IO uint32_t PwfeSel				:3;
X			volatile uint32_t PwfeSel				:3;
N			__IO uint32_t CommPwfeSel			:1;
X			volatile uint32_t CommPwfeSel			:1;
N			__IO uint32_t Protocol 				:4;
X			volatile uint32_t Protocol 				:4;
N			__IO uint32_t RdHlfWrdMsbFrst		:1;
X			volatile uint32_t RdHlfWrdMsbFrst		:1;
N			__IO uint32_t WrHlfWrdMsbFrst		:1;
X			volatile uint32_t WrHlfWrdMsbFrst		:1;
N		} SPIMODE_b;								   /*!< BitSize 		  */
N	};
N
N
N
N
N	__IO uint32_t SPISTART;             /// 0x00D4 | SPI Start Command register                 | 0x00000018
X	volatile uint32_t SPISTART;             
N
N	__IO uint32_t SPISTRTWAD01;         /// 0x00D8 | SPI0 SPI1 Memory Write Start Address       | 0x00000018
X	volatile uint32_t SPISTRTWAD01;         
N	__IO uint32_t SPISTRTWAD23;         /// 0x00DC | SPI2 SPI3 Memory Write Start Address       | 0x00000002
X	volatile uint32_t SPISTRTWAD23;         
N	__IO uint32_t SPISTRTWAD45;         /// 0x00E0 | SPI4 SPI5 Memory Write Start Address       | 0x00000005
X	volatile uint32_t SPISTRTWAD45;         
N
N	__IO uint32_t SPISTRTRAD01;         /// 0x00E4 | SPI0 SPI1 Memory Read  Start Address       | 0x00000018
X	volatile uint32_t SPISTRTRAD01;         
N	__IO uint32_t SPISTRTRAD23;         /// 0x00E8 | SPI2 SPI3 Memory Read  Start Address       | 0x00000002
X	volatile uint32_t SPISTRTRAD23;         
N	__IO uint32_t SPISTRTRAD45;         /// 0x00EC | SPI4 SPI5 Memory Read  Start Address       | 0x00000005
X	volatile uint32_t SPISTRTRAD45;         
N
N
N	__IO uint32_t TSPRXLINESALL;        /// 0x00F0 | TSP Total RX LINES Divided by 2            | 0x0000000F
X	volatile uint32_t TSPRXLINESALL;        
N	__IO uint32_t SPIRXLINES01;         /// 0x00F4 | SPI0 SPI1 Allocated RX TOUCH LINES         | 0x00000000
X	volatile uint32_t SPIRXLINES01;         
N	__IO uint32_t SPIRXLINES23;         /// 0x00F8 | SPI2 SPI3 Allocated RX TOUCH LINES         | 0x207F1FFF
X	volatile uint32_t SPIRXLINES23;         
N	__IO uint32_t SPIRXLINES45;         /// 0x00FC | SPI4 SPI5 Allocated RX TOUCH LINES         | 0x55AA55AA
X	volatile uint32_t SPIRXLINES45;         
N
N	union {
N
N		__IO uint32_t SPIPCLKEND; 		  /// 0x00FF | SPI PCLK END parameter for DIV2/3/4/6/8	  | 0x55AA55AA
X		volatile uint32_t SPIPCLKEND; 		  
N
N		struct {
N			__IO uint32_t spiPclkEnd			:4;
X			volatile uint32_t spiPclkEnd			:4;
N			__IO uint32_t spiPclkCnt	 		:4;
X			volatile uint32_t spiPclkCnt	 		:4;
N			__IO uint32_t spiPclkDiv 			:4;
X			volatile uint32_t spiPclkDiv 			:4;
N			__IO uint32_t spiPclkEnd2 			:4;
X			volatile uint32_t spiPclkEnd2 			:4;
N		} SPIPCLKEND_b;								   /*!< BitSize 		  */
N	};
N
N
N	__IO uint32_t SPITSYNCSZE0;         /// 0x0100 | SPI0 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE0;         
N	__IO uint32_t SPITSYNCSZE1;         /// 0x0104 | SPI1 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE1;         
N	__IO uint32_t SPITSYNCSZE2;         /// 0x0108 | SPI2 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE2;         
N	__IO uint32_t SPITSYNCSZE3;         /// 0x010C | SPI3 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE3;         
N	__IO uint32_t SPITSYNCSZE4;         /// 0x0120 | SPI4 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE4;         
N	__IO uint32_t SPITSYNCSZE5;         /// 0x0124 | SPI5 Transfer Size per 1 Tsync frame       | 0x000000FF
X	volatile uint32_t SPITSYNCSZE5;         
N	__IO uint32_t SPIHCLKCOMMEND;       /// 0x0128 | SPI Ready Singal sampling position         | 0x000000FF
X	volatile uint32_t SPIHCLKCOMMEND;       
N	__IO uint32_t SPIAITTSYNCDONECLR;   /// 0x0128 | SPI TSYNC Done Status Clear Command        | 0x000000FF
X	volatile uint32_t SPIAITTSYNCDONECLR;   
N
N	__IO uint32_t SPISTATESR0;          /// 0x0128 | SPI0 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR0;          
N	__IO uint32_t SPITSYNCCNTSR0;       /// 0x0128 | SPI0 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR0;       
N	__IO uint32_t SPISUBFRCNTSR0;       /// 0x0128 | SPI0 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR0;       
N	__IO uint32_t SPISTATESR1;          /// 0x0128 | SPI1 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR1;          
N	__IO uint32_t SPITSYNCCNTSR1;       /// 0x0128 | SPI1 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR1;       
N	__IO uint32_t SPISUBFRCNTSR1;       /// 0x0128 | SPI1 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR1;       
N	__IO uint32_t SPISTATESR2;          /// 0x0128 | SPI2 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR2;          
N	__IO uint32_t SPITSYNCCNTSR2;       /// 0x0128 | SPI2 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR2;       
N	__IO uint32_t SPISUBFRCNTSR2;       /// 0x0128 | SPI2 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR2;       
N	__IO uint32_t SPISTATESR3;          /// 0x0128 | SPI3 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR3;          
N	__IO uint32_t SPITSYNCCNTSR3;       /// 0x0128 | SPI3 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR3;       
N	__IO uint32_t SPISUBFRCNTSR3;       /// 0x0128 | SPI3 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR3;       
N	__IO uint32_t SPISTATESR4;          /// 0x0128 | SPI4 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR4;          
N	__IO uint32_t SPITSYNCCNTSR4;       /// 0x0128 | SPI4 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR4;       
N	__IO uint32_t SPISUBFRCNTSR4;       /// 0x0128 | SPI4 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR4;       
N	__IO uint32_t SPISTATESR5;          /// 0x0128 | SPI5 Status Register                       | 0x000000FF
X	volatile uint32_t SPISTATESR5;          
N	__IO uint32_t SPITSYNCCNTSR5;       /// 0x0128 | SPI5 Tsync Couter Monitoring               | 0x000000FF
X	volatile uint32_t SPITSYNCCNTSR5;       
N	__IO uint32_t SPISUBFRCNTSR5;       /// 0x0128 | SPI5 Sub frame Counter Monitoring          | 0x000000FF
X	volatile uint32_t SPISUBFRCNTSR5;       
N
N	__IO uint32_t SPIAITWLVCR;          /// 0x0128 | SPI AIT Waterlevel Interrupt Control       | 0x000000FF
X	volatile uint32_t SPIAITWLVCR;          
N	__IO uint32_t SPIAITWLV;            /// 0x0128 | SPI AIT Waterlevel Value                   | 0x000000FF
X	volatile uint32_t SPIAITWLV;            
N	
N	__IO uint32_t SPIAITDMYDEL;         /// 0x0128 | SPI AIT Dummy Delete  Mode                 | 0x000000FF
X	volatile uint32_t SPIAITDMYDEL;         
N
N	__IO uint32_t SPIGFCR0;             /// 0x0128 | SPI0 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR0;             
N	__IO uint32_t SPIGFENA0;            /// 0x0128 | SPI0 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA0;            
N	__IO uint32_t SPIGFCR1;             /// 0x0128 | SPI1 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR1;             
N	__IO uint32_t SPIGFENA1;            /// 0x0128 | SPI1 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA1;            
N	__IO uint32_t SPIGFCR2;             /// 0x0128 | SPI2 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR2;             
N	__IO uint32_t SPIGFENA2;            /// 0x0128 | SPI2 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA2;            
N	__IO uint32_t SPIGFCR3;             /// 0x0128 | SPI3 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR3;             
N	__IO uint32_t SPIGFENA3;            /// 0x0128 | SPI3 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA3;            
N	__IO uint32_t SPIGFCR4;             /// 0x0128 | SPI4 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR4;             
N	__IO uint32_t SPIGFENA4;            /// 0x0128 | SPI4 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA4;            
N	__IO uint32_t SPIGFCR5;             /// 0x0128 | SPI5 GlitchFilter Control                  | 0x000000FF
X	volatile uint32_t SPIGFCR5;             
N	__IO uint32_t SPIGFENA5;            /// 0x0128 | SPI5 GlitchFilter Bit Enable               | 0x000000FF
X	volatile uint32_t SPIGFENA5;            
N
N	__IO uint32_t SPIPENCR0;            /// 0x0128 | SPI Pen Control0                           | 0x000000FF
X	volatile uint32_t SPIPENCR0;            
N	__IO uint32_t SPIPENCR1;            /// 0x0128 | SPI Pen Control1                           | 0x000000FF
X	volatile uint32_t SPIPENCR1;            
N
N	__IO uint32_t SPIAITWLV1;           /// 0x0128 | SPI AIT Waterlevel1 Value                  | 0x000000FF
X	volatile uint32_t SPIAITWLV1;           
N	__IO uint32_t SPIAITWLV2;           /// 0x0128 | SPI AIT Waterlevel2 Value                  | 0x000000FF
X	volatile uint32_t SPIAITWLV2;           
N	__IO uint32_t SPIAITWLV3;           /// 0x0128 | SPI AIT Waterlevel3 Value                  | 0x000000FF
X	volatile uint32_t SPIAITWLV3;           
N
N
N} MSPI_TypeDef ;
N
N
N#endif /* __MSPI_H_ */
L 285 "..\..\Hal\system\MFTP.h" 2
N#include "_tspi.h"
L 1 "..\..\Hal\spi\_tspi.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _tspi.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __TSPI_H_
N#define __TSPI_H_
N
N
Ntypedef struct {
N                                        /// Offset | Description                                | ResetValue
N    __IO uint32_t SCR;                  /// 0x0000 | SPI Control register                       | 0x00000002
X    volatile uint32_t SCR;                  
N    __IO uint32_t SDR;                  /// 0x0004 | SPI  FIFO Access register                  | 0x00000000
X    volatile uint32_t SDR;                  
N    __IO uint32_t SSR;                  /// 0x0008 | SPI  Status register                       | 0x00000000
X    volatile uint32_t SSR;                  
N    __IO uint32_t SFIFOCR;              /// 0x000C | FIFO Control register                      | 0x00000000
X    volatile uint32_t SFIFOCR;              
N    __IO uint32_t SINTRSR;              /// 0x0010 | Interrupt Status register                  | 0x30001080
X    volatile uint32_t SINTRSR;              
N    __IO uint32_t SINTRMSSR;            /// 0x0014 | Interrupt Masked Status register           | 0x00000000
X    volatile uint32_t SINTRMSSR;            
N    __IO uint32_t SINTRMSCR;            /// 0x0018 | Interrupt Mask Control register            | 0x00000000
X    volatile uint32_t SINTRMSCR;            
N    __IO uint32_t SINTRENCR;            /// 0x001C | Interrupt Clear register                   | 0x30000000
X    volatile uint32_t SINTRENCR;            
N    __IO uint32_t SFIFORXPTR;           /// 0x0020 | RX FIFO Pointer status register            | 0x00000000
X    volatile uint32_t SFIFORXPTR;           
N    __IO uint32_t SFIFORXDIFFPTR;       /// 0x0024 | RX FIFO Pointer difference status register | 0x00000000
X    volatile uint32_t SFIFORXDIFFPTR;       
N    __IO uint32_t SFIFOTXPTR;           /// 0x0028 | TX FIFO Pointer status register            | 0x00000000
X    volatile uint32_t SFIFOTXPTR;           
N    __IO uint32_t SFIFOTXDIFFPTR;       /// 0x002C | TX FIFO Pointer difference status register | 0x00000000
X    volatile uint32_t SFIFOTXDIFFPTR;       
N    __IO uint32_t SDATACNTTXRX;         /// 0x0030 | TX RX COUNTER status register              | 0x00000000
X    volatile uint32_t SDATACNTTXRX;         
N    __IO uint32_t Reserved1;            /// 0x0034 | Reserved 1                                 | 0x00000000
X    volatile uint32_t Reserved1;            
N    __IO uint32_t Reserved2;            /// 0x0038 | Reserved 2                                 | 0x00000000
X    volatile uint32_t Reserved2;            
N    __IO uint32_t Reserved3;            /// 0x003C | Reserved 3                                 | 0x00000000
X    volatile uint32_t Reserved3;            
N    __IO uint32_t Reserved4;            /// 0x0040 | Reserved 4                                 | 0x00000000
X    volatile uint32_t Reserved4;            
N    __IO uint32_t SMISC;                /// 0x0044 | Miscellaneous register                     | 0x00000000
X    volatile uint32_t SMISC;                
N    __IO uint32_t SINTLCTRL;            /// 0x0048 | Intel Control register                     | 0x00000000
X    volatile uint32_t SINTLCTRL;            
N    __IO uint32_t SBDWSTRT;             /// 0x004C | Intel Bulk Data Window Start register      | 0x00000000
X    volatile uint32_t SBDWSTRT;             
N    __IO uint32_t SINTLSTS;             /// 0x0050 | Intel Sensing Status register              | 0x00000000
X    volatile uint32_t SINTLSTS;             
N    __IO uint32_t SINTLFRCH;            /// 0x0054 | Intel Frame Characteristic register        | 0x00000000
X    volatile uint32_t SINTLFRCH;            
N    __IO uint32_t SINTLERR;             /// 0x0058 | Intel Error register                       | 0x00000000
X    volatile uint32_t SINTLERR;             
N    __IO uint32_t SINTLID;              /// 0x005C | Intel Id register                          | 0x00000000
X    volatile uint32_t SINTLID;              
N    __IO uint32_t SINTLDATSZ;           /// 0x0060 | Intel Data Size register                   | 0x00000000
X    volatile uint32_t SINTLDATSZ;           
N    __IO uint32_t SINTLCAP;             /// 0x0064 | Intel Capabilities register                | 0x00000000
X    volatile uint32_t SINTLCAP;             
N    __IO uint32_t SINTLCFG;             /// 0x0068 | Intel Configuration register               | 0x00000000
X    volatile uint32_t SINTLCFG;             
N    __IO uint32_t SINTLCMD;             /// 0x006C | Intel Command register                     | 0x00000000
X    volatile uint32_t SINTLCMD;             
N    __IO uint32_t SINTLPWRMG;           /// 0x0070 | Intel Power Management                     | 0x00000000
X    volatile uint32_t SINTLPWRMG;           
N    __IO uint32_t SINTLVNDID;           /// 0x0074 | Intel Vendor HW ID register                | 0x00000000
X    volatile uint32_t SINTLVNDID;           
N    __IO uint32_t SINTLHWREV;           /// 0x0078 | Intel HW Revision ID register              | 0x00000000
X    volatile uint32_t SINTLHWREV;           
N    __IO uint32_t SINTLFWREV;           /// 0x007C | Intel FW Revision ID register              | 0x00000000
X    volatile uint32_t SINTLFWREV;           
N    __IO uint32_t SINTLCMPREV;          /// 0x0080 | Intel Compatibility Revision register      | 0x00000000
X    volatile uint32_t SINTLCMPREV;          
N    __IO uint32_t Reserved19;           /// 0x0080 | Reserved 19                                | 0x00000030
X    volatile uint32_t Reserved19;           
N    __IO uint32_t Reserved20;           /// 0x0084 | Reserved 20                                | 0x00000030
X    volatile uint32_t Reserved20;           
N    __IO uint32_t Reserved21;           /// 0x0088 | Reserved 21                                | 0x00000030
X    volatile uint32_t Reserved21;           
N    __IO uint32_t Reserved22;           /// 0x008C | Reserved 22                                | 0x00000030
X    volatile uint32_t Reserved22;           
N    __IO uint32_t Reserved23;           /// 0x0090 | Reserved 23                                | 0x00000030
X    volatile uint32_t Reserved23;           
N    __IO uint32_t Reserved24;           /// 0x0094 | Reserved 24                                | 0x00000010
X    volatile uint32_t Reserved24;           
N    __IO uint32_t Reserved25;           /// 0x0098 | Reserved 25                                | 0x00000010
X    volatile uint32_t Reserved25;           
N    __IO uint32_t Reserved26;           /// 0x009C | Reserved 26                                | 0x00000010
X    volatile uint32_t Reserved26;           
N    __IO uint32_t Reserved27;           /// 0x00A0 | Reserved 27                                | 0x00000010
X    volatile uint32_t Reserved27;           
N    __IO uint32_t Reserved28;           /// 0x00A4 | Reserved 28                                | 0x00000010
X    volatile uint32_t Reserved28;           
N    __IO uint32_t Reserved29;           /// 0x00A8 | Reserved 29                                | 0x00000020
X    volatile uint32_t Reserved29;           
N    __IO uint32_t Reserved30;           /// 0x00AC | Reserved 30                                | 0x00000020
X    volatile uint32_t Reserved30;           
N    __IO uint32_t Reserved31;           /// 0x00B0 | Reserved 31                                | 0x00000020
X    volatile uint32_t Reserved31;           
N    __IO uint32_t Reserved32;           /// 0x00B4 | Reserved 32                                | 0x00000020
X    volatile uint32_t Reserved32;           
N    __IO uint32_t Reserved33;           /// 0x00B8 | Reserved 33                                | 0x00000020
X    volatile uint32_t Reserved33;           
N    __IO uint32_t Reserved34;           /// 0x00BC | Reserved 34                                | 0x00000018
X    volatile uint32_t Reserved34;           
N    __IO uint32_t Reserved35;           /// 0x00C0 | Reserved 35                                | 0x00000018
X    volatile uint32_t Reserved35;           
N    __IO uint32_t Reserved36;           /// 0x00C4 | Reserved 36                                | 0x00000018
X    volatile uint32_t Reserved36;           
N    __IO uint32_t Reserved37;           /// 0x00C8 | Reserved 37                                | 0x00040000
X    volatile uint32_t Reserved37;           
N    __IO uint32_t Reserved38;           /// 0x00CC | Reserved 38                                | 0x0000F000
X    volatile uint32_t Reserved38;           
N    __IO uint32_t Reserved39;           /// 0x00D0 | Reserved 39                                | 0x00000300
X    volatile uint32_t Reserved39;           
N    __IO uint32_t Reserved40;           /// 0x00D4 | Reserved 40                                | 0x00000018
X    volatile uint32_t Reserved40;           
N    __IO uint32_t Reserved41;           /// 0x00D8 | Reserved 41                                | 0x00000018
X    volatile uint32_t Reserved41;           
N    __IO uint32_t Reserved42;           /// 0x00DC | Reserved 42                                | 0x00000002
X    volatile uint32_t Reserved42;           
N    __IO uint32_t Reserved43;           /// 0x00E0 | Reserved 43                                | 0x00000005
X    volatile uint32_t Reserved43;           
N    __IO uint32_t Reserved44;           /// 0x00E4 | Reserved 44                                | 0x0000000F
X    volatile uint32_t Reserved44;           
N    __IO uint32_t Reserved45;           /// 0x00E8 | Reserved 45                                | 0x00000000
X    volatile uint32_t Reserved45;           
N    __IO uint32_t Reserved46;           /// 0x00EC | Reserved 46                                | 0x207F1FFF
X    volatile uint32_t Reserved46;           
N    __IO uint32_t Reserved47;           /// 0x00F0 | Reserved 47                                | 0x55AA55AA
X    volatile uint32_t Reserved47;           
N    __IO uint32_t Reserved48;           /// 0x00F4 | Reserved 48                                | 0x55AA55AA
X    volatile uint32_t Reserved48;           
N    __IO uint32_t Reserved49;           /// 0x00F8 | Reserved 49                                | 0x000000FF
X    volatile uint32_t Reserved49;           
N
N} TSPI_TypeDef ;
N
N
N#endif /* __TSPI_H_ */
N
L 286 "..\..\Hal\system\MFTP.h" 2
N#include "_dspA.h"
L 1 "..\..\Hal\dspA\_dspA.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _dspA.h
N * version : 0.1
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __DSPA_H_
N#define __DSPA_H_
N
N
N/* ================================================================================ */
N/* ================                      DSPA                      ================ */
N/* ================================================================================ */
N
Ntypedef struct
N{
N	union
N	{
N		struct
N		{
N			__IO uint32_t SwStr 	: 1;	// Software Start
X			volatile uint32_t SwStr 	: 1;	
N			__IO uint32_t Init  	: 1;	// Initialize
X			volatile uint32_t Init  	: 1;	
N			__I uint32_t RESERVED  	: 30;
X			volatile const uint32_t RESERVED  	: 30;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} HWACC_CTRL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t ItrptEn   : 1;	// Interrupt Enable
X			volatile uint32_t ItrptEn   : 1;	
N			__IO uint32_t ItrptFlag : 1;	// Interrupt Flag(Read), Interrupt Clear by writing 0(write)
X			volatile uint32_t ItrptFlag : 1;	
N			__I uint32_t RESERVED  	: 30;
X			volatile const uint32_t RESERVED  	: 30;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} ITRPT_CTRL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t RowNum  : 8;	// Pannel Row(Pad )
X			volatile uint32_t RowNum  : 8;	
N			__IO uint32_t ColNum  : 8;	// Pannel Column(Pad )
X			volatile uint32_t ColNum  : 8;	
N			__IO uint32_t DataLen : 16;	// Total Data(Pad )
X			volatile uint32_t DataLen : 16;	
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} SIZE_CTRL;
N
N	__IO uint32_t RAW_ADDR;
X	volatile uint32_t RAW_ADDR;
N
N	__IO uint32_t BASE_ADDR;
X	volatile uint32_t BASE_ADDR;
N
N	__IO uint32_t NMLZ_ADDR;
X	volatile uint32_t NMLZ_ADDR;
N
N	__IO uint32_t DEST_ADDR;
X	volatile uint32_t DEST_ADDR;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t PadEn   	: 1;
X			volatile uint32_t PadEn   	: 1;
N			__IO uint32_t RESERVED1	: 3;
X			volatile uint32_t RESERVED1	: 3;
N			__IO uint32_t PadSize	: 4;
X			volatile uint32_t PadSize	: 4;
N			__IO uint32_t RESERVED2	: 8;
X			volatile uint32_t RESERVED2	: 8;
N			__IO uint32_t PadData	: 16;
X			volatile uint32_t PadData	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} PAD_CTRL;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t NmlzEn    : 1;
X			volatile uint32_t NmlzEn    : 1;
N			__IO uint32_t RESERVED  : 7;
X			volatile uint32_t RESERVED  : 7;
N			__IO uint32_t NmlzShift : 8;
X			volatile uint32_t NmlzShift : 8;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} NMLZ_CTRL;
N
N	union
N	{
N        struct
N		{
N			__IO uint32_t BitShift	: 8;
X			volatile uint32_t BitShift	: 8;
N			__IO uint32_t RESERVED	: 24;
X			volatile uint32_t RESERVED	: 24;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} BIT_SHIFT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t UpperLimit	: 16;
X			volatile uint32_t UpperLimit	: 16;
N			__IO uint32_t RESERVED		: 16;
X			volatile uint32_t RESERVED		: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} UPR_LIMIT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t LowerLimit	: 16;
X			volatile uint32_t LowerLimit	: 16;
N			__IO uint32_t RESERVED		: 16;
X			volatile uint32_t RESERVED		: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} LWR_LIMIT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t Threshold	: 16;
X			volatile uint32_t Threshold	: 16;
N			__IO uint32_t RESERVED	: 16;
X			volatile uint32_t RESERVED	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} THRESHOLD;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t PlusCellNum	: 16;
X			volatile const uint32_t PlusCellNum	: 16;
N			__I uint32_t RESERVED		: 16;
X			volatile const uint32_t RESERVED		: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} P_CELL_NUM;
N
N	__I uint32_t P_CELL_SUM;
X	volatile const uint32_t P_CELL_SUM;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t PlusMaxVal	: 16;
X			volatile const uint32_t PlusMaxVal	: 16;
N			__I uint32_t RESERVED	: 16;
X			volatile const uint32_t RESERVED	: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} P_MAX_VAL;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t PlusMaxRow	: 8;
X			volatile const uint32_t PlusMaxRow	: 8;
N			__I uint32_t PlusMaxCol	: 8;
X			volatile const uint32_t PlusMaxCol	: 8;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} P_MAX_POS;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t MinusCellNum	: 16;
X			volatile const uint32_t MinusCellNum	: 16;
N			__I uint32_t RESERVED		: 16;
X			volatile const uint32_t RESERVED		: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} M_CELL_NUM;
N
N	__I uint32_t M_CELL_SUM;
X	volatile const uint32_t M_CELL_SUM;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t MinusMaxVal	: 16;
X			volatile const uint32_t MinusMaxVal	: 16;
N			__I uint32_t RESERVED	: 16;
X			volatile const uint32_t RESERVED	: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} M_MAX_VAL;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t MinusMaxRow	: 8;
X			volatile const uint32_t MinusMaxRow	: 8;
N			__I uint32_t MinusMaxCol	: 8;
X			volatile const uint32_t MinusMaxCol	: 8;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} M_MAX_POS;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TouchMinCol	: 8;
X			volatile const uint32_t TouchMinCol	: 8;
N			__I uint32_t TouchMaxCol	: 8;
X			volatile const uint32_t TouchMaxCol	: 8;
N			__I uint32_t TouchMinRow	: 8;
X			volatile const uint32_t TouchMinRow	: 8;
N			__I uint32_t TouchMaxRow	: 8;
X			volatile const uint32_t TouchMaxRow	: 8;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} T_GROUP;
N
N	union
N	{
N		struct
N		{
N			__I uint32_t TouchCellNum	: 16;
X			volatile const uint32_t TouchCellNum	: 16;
N			__I uint32_t RESERVED		: 16;
X			volatile const uint32_t RESERVED		: 16;
N		} tBit;
N		__I uint32_t ulBulk;
X		volatile const uint32_t ulBulk;
N	} T_CELL_NUM;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t PlusEn	: 1;
X			volatile uint32_t PlusEn	: 1;
N			__IO uint32_t MinusEn	: 1;
X			volatile uint32_t MinusEn	: 1;
N			__IO uint32_t RESERVED	: 14;
X			volatile uint32_t RESERVED	: 14;
N			__IO uint32_t PConstant	: 16;
X			volatile uint32_t PConstant	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} PLUS_OPT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t MultEn	: 1;
X			volatile uint32_t MultEn	: 1;
N			__IO uint32_t RESERVED	: 15;
X			volatile uint32_t RESERVED	: 15;
N			__IO uint32_t MConstant	: 16;
X			volatile uint32_t MConstant	: 16;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} MULT_OPT;
N
N	union
N	{
N		struct
N		{
N			__IO uint32_t MasterLock	: 1;
X			volatile uint32_t MasterLock	: 1;
N			__IO uint32_t RESERVED		: 30;
X			volatile uint32_t RESERVED		: 30;
N		} tBit;
N		__IO uint32_t ulBulk;
X		volatile uint32_t ulBulk;
N	} MASTLOCK;
N
N} tDSPA_CtrlReg_t;
N
N#endif /* __DSPA_H_ */
L 287 "..\..\Hal\system\MFTP.h" 2
N#include "_pwmdrv.h"
L 1 "..\..\Hal\pwmdrv\_pwmdrv.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _pwmdrv.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __PWMDRV_H_
N#define __PWMDRV_H_
N
N#include "_pwmdrv_param.h"
L 1 "..\..\Hal\pwmdrv\_pwmdrv_param.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : mspi_.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __PWMDRV_PARAM_H_
N#define __PWMDRV_PARAM_H_
N
N/*
N * defines
N *
N * */
N
Ntypedef enum {
N	ePWM_PARAM_FINGER = 0,
N	ePWM_PARAM_PEN = 1,
N	ePWM_PARAM_MAX,
N
N} ePwmParamOpMode;
N
N/*
N * typedef
N *
N * */
Ntypedef union
N{
N    struct
N	{
N      __IO uint32_t  HI_ABOVE_NUM       :  6;
X      volatile uint32_t  HI_ABOVE_NUM       :  6;
N      __IO uint32_t  LO_BELOW_NUM       :  6;
X      volatile uint32_t  LO_BELOW_NUM       :  6;
N      __IO uint32_t  FSM_ON_IBE         :  1;
X      volatile uint32_t  FSM_ON_IBE         :  1;
N      __IO uint32_t  FSM_ON_IEV         :  1;
X      volatile uint32_t  FSM_ON_IEV         :  1;
N      __IO uint32_t  FSM_ON_IE          :  1;
X      volatile uint32_t  FSM_ON_IE          :  1;
N      __IO uint32_t  VSYNC_IN_EXT_IBE   :  1;
X      volatile uint32_t  VSYNC_IN_EXT_IBE   :  1;
N      __IO uint32_t  VSYNC_IN_EXT_IEV   :  1;
X      volatile uint32_t  VSYNC_IN_EXT_IEV   :  1;
N      __IO uint32_t  VSYNC_IN_EXT_IE    :  1;
X      volatile uint32_t  VSYNC_IN_EXT_IE    :  1;
N      __IO uint32_t  TSYNC_IN_EXT_IBE   :  1;
X      volatile uint32_t  TSYNC_IN_EXT_IBE   :  1;
N      __IO uint32_t  TSYNC_IN_EXT_IEV   :  1;
X      volatile uint32_t  TSYNC_IN_EXT_IEV   :  1;
N      __IO uint32_t  TSYNC_IN_EXT_IE    :  1;
X      volatile uint32_t  TSYNC_IN_EXT_IE    :  1;
N      __IO uint32_t  TSYNC_OUT_EXT_IBE  :  1;
X      volatile uint32_t  TSYNC_OUT_EXT_IBE  :  1;
N      __IO uint32_t  TSYNC_OUT_EXT_IEV  :  1;
X      volatile uint32_t  TSYNC_OUT_EXT_IEV  :  1;
N      __IO uint32_t  TSYNC_OUT_EXT_IE   :  1;
X      volatile uint32_t  TSYNC_OUT_EXT_IE   :  1;
N      __IO uint32_t  TSYNC_FR_IBE       :  1;
X      volatile uint32_t  TSYNC_FR_IBE       :  1;
N      __IO uint32_t  TSYNC_FR_IEV       :  1;
X      volatile uint32_t  TSYNC_FR_IEV       :  1;
N      __IO uint32_t  TSYNC_FR_IE        :  1;
X      volatile uint32_t  TSYNC_FR_IE        :  1;
N      __IO uint32_t  TSYNC_MNT_IBE      :  1;
X      volatile uint32_t  TSYNC_MNT_IBE      :  1;
N      __IO uint32_t  TSYNC_MNT_IEV      :  1;
X      volatile uint32_t  TSYNC_MNT_IEV      :  1;
N      __IO uint32_t  TSYNC_MNT_IE       :  1;
X      volatile uint32_t  TSYNC_MNT_IE       :  1;
N      __IO uint32_t  RESERVED       	:  2;
X      volatile uint32_t  RESERVED       	:  2;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N
N    __IO uint32_t ulBulk;
X    volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_INTR_CFG_t;
X} __attribute__ ((packed)) tPWMDRV_INTR_CFG_t;
N
Ntypedef union
N{
N    struct {
N      __IO uint32_t  BEACON_D0    :  5;
X      volatile uint32_t  BEACON_D0    :  5;
N      __IO uint32_t  BEACON_D1    :  5;
X      volatile uint32_t  BEACON_D1    :  5;
N      __IO uint32_t  BEACON_D2    :  5;
X      volatile uint32_t  BEACON_D2    :  5;
N      __IO uint32_t  BEACON_D3    :  5;
X      volatile uint32_t  BEACON_D3    :  5;
N      __IO uint32_t  BEACON_D4    :  5;
X      volatile uint32_t  BEACON_D4    :  5;
N      __IO uint32_t  BEACON_D5    :  5;
X      volatile uint32_t  BEACON_D5    :  5;
N    } __PACKED tBit;
X    } __attribute__ ((packed)) tBit;
N
N    __IO uint32_t  ulBulk;
X    volatile uint32_t  ulBulk;
N
N} __PACKED tPWMDRV_DSSS_INFO_1_t;
X} __attribute__ ((packed)) tPWMDRV_DSSS_INFO_1_t;
N
N
Ntypedef union
N{
N	struct {
N		__IO uint32_t  DLY_0 :  16;
X		volatile uint32_t  DLY_0 :  16;
N		__IO uint32_t  DLY_1 :  16;
X		volatile uint32_t  DLY_1 :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRLG_t;
X} __attribute__ ((packed)) tPWMDRV_PRLG_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  TX_PRD :  16;
X	      volatile uint32_t  TX_PRD :  16;
N	      __IO uint32_t  TX_LOW :  16;
X	      volatile uint32_t  TX_LOW :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_0_t;
X} __attribute__ ((packed)) tPWMDRV_PRE_0_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  TX_NUM  :  10;
X	      volatile uint32_t  TX_NUM  :  10;
N	      __IO uint32_t  PRE_DLY :  16;
X	      volatile uint32_t  PRE_DLY :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_1_t;
X} __attribute__ ((packed)) tPWMDRV_PRE_1_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DSSS_DLY :  8;
X	      volatile uint32_t  DSSS_DLY :  8;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_2_t;
X} __attribute__ ((packed)) tPWMDRV_PRE_2_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DLY_0_BEACON :  16;
X	      volatile uint32_t  DLY_0_BEACON :  16;
N	      __IO uint32_t  DLY_1        :  16;
X	      volatile uint32_t  DLY_1        :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_EPLG_0_t;
X} __attribute__ ((packed)) tPWMDRV_EPLG_0_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DLY_0_PING_FG_F  :  16;
X	      volatile uint32_t  DLY_0_PING_FG_F  :  16;
N	      __IO uint32_t  DLY_0_PING_FG_L  :  16;
X	      volatile uint32_t  DLY_0_PING_FG_L  :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_EPLG_1_t;
X} __attribute__ ((packed)) tPWMDRV_EPLG_1_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  DLY_0_PING_PN_P  :  16;
X	      volatile uint32_t  DLY_0_PING_PN_P  :  16;
N	      __IO uint32_t  DLY_0_PING_PN_D  :  16;
X	      volatile uint32_t  DLY_0_PING_PN_D  :  16;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_EPLG_2_t;
X} __attribute__ ((packed)) tPWMDRV_EPLG_2_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_01     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_01     :  2;    
N	      __IO uint32_t  LHB_02     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_02     :  2;    
N	      __IO uint32_t  LHB_03     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_03     :  2;    
N	      __IO uint32_t  LHB_04     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_04     :  2;    
N	      __IO uint32_t  LHB_05     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_05     :  2;    
N	      __IO uint32_t  LHB_06     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_06     :  2;    
N	      __IO uint32_t  LHB_07     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_07     :  2;    
N	      __IO uint32_t  LHB_08     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_08     :  2;    
N	      __IO uint32_t  LHB_09     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_09     :  2;    
N	      __IO uint32_t  LHB_10     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_10     :  2;    
N	      __IO uint32_t  LHB_11     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_11     :  2;    
N	      __IO uint32_t  LHB_12     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_12     :  2;    
N	      __IO uint32_t  LHB_13     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_13     :  2;    
N	      __IO uint32_t  LHB_14     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_14     :  2;    
N	      __IO uint32_t  LHB_15     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_15     :  2;    
N	      __IO uint32_t  LHB_16     :  2;   /*!<                   */
X	      volatile uint32_t  LHB_16     :  2;    
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_FG_0_t;
X} __attribute__ ((packed)) tPWMDRV_FG_0_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_17     :  2;
X	      volatile uint32_t  LHB_17     :  2;
N	      __IO uint32_t  LHB_18     :  2;
X	      volatile uint32_t  LHB_18     :  2;
N	      __IO uint32_t  LHB_19     :  2;
X	      volatile uint32_t  LHB_19     :  2;
N	      __IO uint32_t  LHB_20     :  2;
X	      volatile uint32_t  LHB_20     :  2;
N	      __IO uint32_t  LHB_21     :  2;
X	      volatile uint32_t  LHB_21     :  2;
N	      __IO uint32_t  LHB_22     :  2;
X	      volatile uint32_t  LHB_22     :  2;
N	      __IO uint32_t  LHB_23     :  2;
X	      volatile uint32_t  LHB_23     :  2;
N	      __IO uint32_t  LHB_24     :  2;
X	      volatile uint32_t  LHB_24     :  2;
N	      __IO uint32_t  LHB_25     :  2;
X	      volatile uint32_t  LHB_25     :  2;
N	      __IO uint32_t  LHB_26     :  2;
X	      volatile uint32_t  LHB_26     :  2;
N	      __IO uint32_t  LHB_27     :  2;
X	      volatile uint32_t  LHB_27     :  2;
N	      __IO uint32_t  LHB_28     :  2;
X	      volatile uint32_t  LHB_28     :  2;
N	      __IO uint32_t  LHB_29     :  2;
X	      volatile uint32_t  LHB_29     :  2;
N	      __IO uint32_t  LHB_30     :  2;
X	      volatile uint32_t  LHB_30     :  2;
N	      __IO uint32_t  LHB_31     :  2;
X	      volatile uint32_t  LHB_31     :  2;
N	      __IO uint32_t  LHB_32     :  2;
X	      volatile uint32_t  LHB_32     :  2;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_FG_1_t;
X} __attribute__ ((packed)) tPWMDRV_FG_1_t;
N
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_01     :  2;
X	      volatile uint32_t  LHB_01     :  2;
N	      __IO uint32_t  LHB_02     :  2;
X	      volatile uint32_t  LHB_02     :  2;
N	      __IO uint32_t  LHB_03     :  2;
X	      volatile uint32_t  LHB_03     :  2;
N	      __IO uint32_t  LHB_04     :  2;
X	      volatile uint32_t  LHB_04     :  2;
N	      __IO uint32_t  LHB_05     :  2;
X	      volatile uint32_t  LHB_05     :  2;
N	      __IO uint32_t  LHB_06     :  2;
X	      volatile uint32_t  LHB_06     :  2;
N	      __IO uint32_t  LHB_07     :  2;
X	      volatile uint32_t  LHB_07     :  2;
N	      __IO uint32_t  LHB_08     :  2;
X	      volatile uint32_t  LHB_08     :  2;
N	      __IO uint32_t  LHB_09     :  2;
X	      volatile uint32_t  LHB_09     :  2;
N	      __IO uint32_t  LHB_10     :  2;
X	      volatile uint32_t  LHB_10     :  2;
N	      __IO uint32_t  LHB_11     :  2;
X	      volatile uint32_t  LHB_11     :  2;
N	      __IO uint32_t  LHB_12     :  2;
X	      volatile uint32_t  LHB_12     :  2;
N	      __IO uint32_t  LHB_13     :  2;
X	      volatile uint32_t  LHB_13     :  2;
N	      __IO uint32_t  LHB_14     :  2;
X	      volatile uint32_t  LHB_14     :  2;
N	      __IO uint32_t  LHB_15     :  2;
X	      volatile uint32_t  LHB_15     :  2;
N	      __IO uint32_t  LHB_16     :  2;
X	      volatile uint32_t  LHB_16     :  2;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PN_0_t;
X} __attribute__ ((packed)) tPWMDRV_PN_0_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  LHB_17     :  2;
X	      volatile uint32_t  LHB_17     :  2;
N	      __IO uint32_t  LHB_18     :  2;
X	      volatile uint32_t  LHB_18     :  2;
N	      __IO uint32_t  LHB_19     :  2;
X	      volatile uint32_t  LHB_19     :  2;
N	      __IO uint32_t  LHB_20     :  2;
X	      volatile uint32_t  LHB_20     :  2;
N	      __IO uint32_t  LHB_21     :  2;
X	      volatile uint32_t  LHB_21     :  2;
N	      __IO uint32_t  LHB_22     :  2;
X	      volatile uint32_t  LHB_22     :  2;
N	      __IO uint32_t  LHB_23     :  2;
X	      volatile uint32_t  LHB_23     :  2;
N	      __IO uint32_t  LHB_24     :  2;
X	      volatile uint32_t  LHB_24     :  2;
N	      __IO uint32_t  LHB_25     :  2;
X	      volatile uint32_t  LHB_25     :  2;
N	      __IO uint32_t  LHB_26     :  2;
X	      volatile uint32_t  LHB_26     :  2;
N	      __IO uint32_t  LHB_27     :  2;
X	      volatile uint32_t  LHB_27     :  2;
N	      __IO uint32_t  LHB_28     :  2;
X	      volatile uint32_t  LHB_28     :  2;
N	      __IO uint32_t  LHB_29     :  2;
X	      volatile uint32_t  LHB_29     :  2;
N	      __IO uint32_t  LHB_30     :  2;
X	      volatile uint32_t  LHB_30     :  2;
N	      __IO uint32_t  LHB_31     :  2;
X	      volatile uint32_t  LHB_31     :  2;
N	      __IO uint32_t  LHB_32     :  2;
X	      volatile uint32_t  LHB_32     :  2;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PN_1_t;
X} __attribute__ ((packed)) tPWMDRV_PN_1_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  TSYNC_MNT_ENA      :  1;
X	      volatile uint32_t  TSYNC_MNT_ENA      :  1;
N	      __IO uint32_t  TSYNC_MNT_CLR      :  1;
X	      volatile uint32_t  TSYNC_MNT_CLR      :  1;
N	      __IO uint32_t  FR_SEL_POINT       :  2;
X	      volatile uint32_t  FR_SEL_POINT       :  2;
N	      __IO uint32_t  FR_TSYNC_PRD       :  16;
X	      volatile uint32_t  FR_TSYNC_PRD       :  16;
N	      __IO uint32_t  FR_TSYNC_NUM       :  6;
X	      volatile uint32_t  FR_TSYNC_NUM       :  6;
N	      __IO uint32_t  SYNC_AUTO_CLR      :  1;
X	      volatile uint32_t  SYNC_AUTO_CLR      :  1;
N	      __IO uint32_t  SEL_ECLK_AUTO      :  1;
X	      volatile uint32_t  SEL_ECLK_AUTO      :  1;
N	      __IO uint32_t  ENA_VSYNC_INIT     :  1;
X	      volatile uint32_t  ENA_VSYNC_INIT     :  1;
N	      __IO uint32_t  ENA_TSYNC_INIT     :  1;
X	      volatile uint32_t  ENA_TSYNC_INIT     :  1;
N	      __IO uint32_t  TSYNC_FREQ_EN_FG_L :  1;
X	      volatile uint32_t  TSYNC_FREQ_EN_FG_L :  1;
N
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_IN_CTRL_t;
X} __attribute__ ((packed)) tPWMDRV_IN_CTRL_t;
N
Ntypedef union
N{
N	struct {
N	      __IO uint32_t  PWMDRV_ENA         :  1;
X	      volatile uint32_t  PWMDRV_ENA         :  1;
N	      __IO uint32_t  VSYNC_EDGE         :  1;
X	      volatile uint32_t  VSYNC_EDGE         :  1;
N	      __IO uint32_t  TSYNC_EDGE         :  1;
X	      volatile uint32_t  TSYNC_EDGE         :  1;
N	      __IO uint32_t  SEL_EXT_VSYNC      :  1;
X	      volatile uint32_t  SEL_EXT_VSYNC      :  1;
N	      __IO uint32_t  SEL_EXT_TSYNC      :  1;
X	      volatile uint32_t  SEL_EXT_TSYNC      :  1;
N	      __IO uint32_t  SEL_FR_TSYNC       :  1;
X	      volatile uint32_t  SEL_FR_TSYNC       :  1;
N	      __IO uint32_t  UPDATE_VSYNC       :  1;
X	      volatile uint32_t  UPDATE_VSYNC       :  1;
N	      __IO uint32_t  UPDATE_TSYNC       :  1;
X	      volatile uint32_t  UPDATE_TSYNC       :  1;
N	      __IO uint32_t  UPDATE_DBG         :  1;
X	      volatile uint32_t  UPDATE_DBG         :  1;
N	      __IO uint32_t  VSYNC_FREQ_EN      :  1;
X	      volatile uint32_t  VSYNC_FREQ_EN      :  1;
N	      __IO uint32_t  TSYNC_FREQ_EN_FG_F :  1;
X	      volatile uint32_t  TSYNC_FREQ_EN_FG_F :  1;
N	      __IO uint32_t  DSSS_FREQ          :  6;
X	      volatile uint32_t  DSSS_FREQ          :  6;
N	      __IO uint32_t  ENA_PRTX_P0        :  1;
X	      volatile uint32_t  ENA_PRTX_P0        :  1;
N	      __IO uint32_t  ENA_PRTX_D0        :  1;
X	      volatile uint32_t  ENA_PRTX_D0        :  1;
N	      __IO uint32_t  ENA_DSSS_P         :  1;
X	      volatile uint32_t  ENA_DSSS_P         :  1;
N	      __IO uint32_t  ENA_DSSS_D         :  1;
X	      volatile uint32_t  ENA_DSSS_D         :  1;
N	      __IO uint32_t  ENA_PRTX_P1        :  1;
X	      volatile uint32_t  ENA_PRTX_P1        :  1;
N	      __IO uint32_t  ENA_PRTX_D1        :  1;
X	      volatile uint32_t  ENA_PRTX_D1        :  1;
N	      __IO uint32_t  ENA_ACTX_PD        :  1;
X	      volatile uint32_t  ENA_ACTX_PD        :  1;
N	      __IO uint32_t  ENA_ECLK_AUTO      :  1;
X	      volatile uint32_t  ENA_ECLK_AUTO      :  1;
N	      __IO uint32_t  VSYNC_NUM          :  6;
X	      volatile uint32_t  VSYNC_NUM          :  6;
N	      __IO uint32_t  VSYNC_BP           :  1;
X	      volatile uint32_t  VSYNC_BP           :  1;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_GBL_t;
X} __attribute__ ((packed)) tPWMDRV_GBL_t;
N
Ntypedef union
N{
N	struct {
N		__IO uint32_t  DSSS_ENA_T0         :  1;
X		volatile uint32_t  DSSS_ENA_T0         :  1;
N		__IO uint32_t  PRE_ENA_T0          :  1;
X		volatile uint32_t  PRE_ENA_T0          :  1;
N		__IO uint32_t  ACT_ENA_T0          :  1;
X		volatile uint32_t  ACT_ENA_T0          :  1;
N		__IO uint32_t  RESERVED0_T0		   :  1;
X		volatile uint32_t  RESERVED0_T0		   :  1;
N		__IO uint32_t  RESERVED1_T0		   :  1;
X		volatile uint32_t  RESERVED1_T0		   :  1;
N		__IO uint32_t  RESERVED2_T0		   :  1;
X		volatile uint32_t  RESERVED2_T0		   :  1;
N		__IO uint32_t  LFD_TX_ACT_ENA_T0   :  1;
X		volatile uint32_t  LFD_TX_ACT_ENA_T0   :  1;
N		__IO uint32_t  DSSS_ENA_T1         :  1;
X		volatile uint32_t  DSSS_ENA_T1         :  1;
N		__IO uint32_t  PRE_ENA_T1          :  1;
X		volatile uint32_t  PRE_ENA_T1          :  1;
N		__IO uint32_t  ACT_ENA_T1          :  1;
X		volatile uint32_t  ACT_ENA_T1          :  1;
N		__IO uint32_t  RESERVED0_T1		   :  1;
X		volatile uint32_t  RESERVED0_T1		   :  1;
N		__IO uint32_t  RESERVED1_T1		   :  1;
X		volatile uint32_t  RESERVED1_T1		   :  1;
N		__IO uint32_t  RESERVED2_T1		   :  1;
X		volatile uint32_t  RESERVED2_T1		   :  1;
N		__IO uint32_t  LFD_TX_ACT_ENA_T1   :  1;
X		volatile uint32_t  LFD_TX_ACT_ENA_T1   :  1;
N		__IO uint32_t  T_2 				   :  7;
X		volatile uint32_t  T_2 				   :  7;
N	} __PACKED tBit;
X	} __attribute__ ((packed)) tBit;
N
N	__IO uint32_t ulBulk;
X	volatile uint32_t ulBulk;
N
N} __PACKED tPWMDRV_ENA_PWM_t;
X} __attribute__ ((packed)) tPWMDRV_ENA_PWM_t;
N/*
N *
N * Sample structure
Ntypedef union
N{
N	struct {
N
N	} __PACKED tBit;
N
N	__IO uint32_t ulBulk;
N
N} __PACKED tPWMDRV_PRE_2_t;
N*/
N#endif /* __PWMDRV_PARAM_H_ */
L 37 "..\..\Hal\pwmdrv\_pwmdrv.h" 2
N/* ================================================================================ */
N/* ================                      PWMDRV                    ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief PWMDRV / PWM TX Generation Configuration Register
N  */
Ntypedef struct {                             /*!< PWMDRV Structure   */
N
N  union {
N    __IO uint32_t  GBL;                      /*!< CFG               */
X    volatile uint32_t  GBL;                       
N
N    struct {
N      __IO uint32_t  PWMDRV_ENA         :  1;    /*!<                   */
X      volatile uint32_t  PWMDRV_ENA         :  1;     
N      __IO uint32_t  VSYNC_EDGE         :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_EDGE         :  1;     
N      __IO uint32_t  TSYNC_EDGE         :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_EDGE         :  1;     
N      __IO uint32_t  SEL_EXT_VSYNC      :  1;    /*!<                   */
X      volatile uint32_t  SEL_EXT_VSYNC      :  1;     
N      __IO uint32_t  SEL_EXT_TSYNC      :  1;    /*!<                   */
X      volatile uint32_t  SEL_EXT_TSYNC      :  1;     
N      __IO uint32_t  SEL_FR_TSYNC       :  1;    /*!<                   */
X      volatile uint32_t  SEL_FR_TSYNC       :  1;     
N      __IO uint32_t  UPDATE_VSYNC       :  1;    /*!<                   */
X      volatile uint32_t  UPDATE_VSYNC       :  1;     
N      __IO uint32_t  UPDATE_TSYNC       :  1;    /*!<                   */
X      volatile uint32_t  UPDATE_TSYNC       :  1;     
N      __IO uint32_t  UPDATE_DBG         :  1;    /*!<                   */
X      volatile uint32_t  UPDATE_DBG         :  1;     
N      __IO uint32_t  VSYNC_FREQ_EN      :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_FREQ_EN      :  1;     
N      __IO uint32_t  TSYNC_FREQ_EN_FG_F :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FREQ_EN_FG_F :  1;     
N      __IO uint32_t  DSSS_FREQ          :  6;    /*!<                   */
X      volatile uint32_t  DSSS_FREQ          :  6;     
N      __IO uint32_t  ENA_PRTX_P0        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_P0        :  1;     
N      __IO uint32_t  ENA_PRTX_D0        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_D0        :  1;     
N      __IO uint32_t  ENA_DSSS_P         :  1;    /*!<                   */
X      volatile uint32_t  ENA_DSSS_P         :  1;     
N      __IO uint32_t  ENA_DSSS_D         :  1;    /*!<                   */
X      volatile uint32_t  ENA_DSSS_D         :  1;     
N      __IO uint32_t  ENA_PRTX_P1        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_P1        :  1;     
N      __IO uint32_t  ENA_PRTX_D1        :  1;    /*!<                   */
X      volatile uint32_t  ENA_PRTX_D1        :  1;     
N      __IO uint32_t  ENA_ACTX_PD        :  1;    /*!<                   */
X      volatile uint32_t  ENA_ACTX_PD        :  1;     
N      __IO uint32_t  ENA_ECLK_AUTO      :  1;    /*!<                   */
X      volatile uint32_t  ENA_ECLK_AUTO      :  1;     
N      __IO uint32_t  VSYNC_NUM          :  6;    /*!<                   */
X      volatile uint32_t  VSYNC_NUM          :  6;     
N      __IO uint32_t  VSYNC_BP           :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_BP           :  1;     
N    } GBL_b;                                 /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  FW_CTRL;                /*!< CFG               */
X    volatile uint32_t  FW_CTRL;                 
N
N    struct {
N      __IO uint32_t  PEN_MODE     :  1;    /*!<                   */
X      volatile uint32_t  PEN_MODE     :  1;     
N      __IO uint32_t  VSYNC_IN     :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN     :  1;     
N      __IO uint32_t  TSYNC_IN     :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN     :  1;     
N    } FW_CTRL_b;                           /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  IN_CTRL;                 /*!< CFG               */
X    volatile uint32_t  IN_CTRL;                  
N
N    struct {
N      __IO uint32_t  TSYNC_MNT_ENA      :  1;   /*!<                   */
X      volatile uint32_t  TSYNC_MNT_ENA      :  1;    
N      __IO uint32_t  TSYNC_MNT_CLR      :  1;   /*!<                   */
X      volatile uint32_t  TSYNC_MNT_CLR      :  1;    
N      __IO uint32_t  FR_SEL_POINT       :  2;   /*!<                   */
X      volatile uint32_t  FR_SEL_POINT       :  2;    
N      __IO uint32_t  FR_TSYNC_PRD       :  16;  /*!<                   */
X      volatile uint32_t  FR_TSYNC_PRD       :  16;   
N      __IO uint32_t  FR_TSYNC_NUM       :  6;   /*!<                   */
X      volatile uint32_t  FR_TSYNC_NUM       :  6;    
N      __IO uint32_t  SYNC_AUTO_CLR      :  1;   /*!<                   */
X      volatile uint32_t  SYNC_AUTO_CLR      :  1;    
N      __IO uint32_t  SEL_ECLK_AUTO      :  1;   /*!<                   */
X      volatile uint32_t  SEL_ECLK_AUTO      :  1;    
N      __IO uint32_t  ENA_VSYNC_INIT     :  1;   /*!<                   */
X      volatile uint32_t  ENA_VSYNC_INIT     :  1;    
N      __IO uint32_t  ENA_TSYNC_INIT     :  1;   /*!<                   */
X      volatile uint32_t  ENA_TSYNC_INIT     :  1;    
N      __IO uint32_t  TSYNC_FREQ_EN_FG_L :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FREQ_EN_FG_L :  1;     
N    } IN_CTRL_b;                            /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  TSYNC_LTD;           /*!< CFG               */
X    volatile uint32_t  TSYNC_LTD;            
N
N    struct {
N      __IO uint32_t  HIGH       :  16;  /*!<                   */
X      volatile uint32_t  HIGH       :  16;   
N      __IO uint32_t  LOW        :  16;  /*!<                   */
X      volatile uint32_t  LOW        :  16;   
N    } TSYNC_LTD_b;                      /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  FG_0 ;           /*!< CFG               */
X    volatile uint32_t  FG_0 ;            
N
N    struct {
N      __IO uint32_t  LHB_01     :  2;   /*!<                   */
X      volatile uint32_t  LHB_01     :  2;    
N      __IO uint32_t  LHB_02     :  2;   /*!<                   */
X      volatile uint32_t  LHB_02     :  2;    
N      __IO uint32_t  LHB_03     :  2;   /*!<                   */
X      volatile uint32_t  LHB_03     :  2;    
N      __IO uint32_t  LHB_04     :  2;   /*!<                   */
X      volatile uint32_t  LHB_04     :  2;    
N      __IO uint32_t  LHB_05     :  2;   /*!<                   */
X      volatile uint32_t  LHB_05     :  2;    
N      __IO uint32_t  LHB_06     :  2;   /*!<                   */
X      volatile uint32_t  LHB_06     :  2;    
N      __IO uint32_t  LHB_07     :  2;   /*!<                   */
X      volatile uint32_t  LHB_07     :  2;    
N      __IO uint32_t  LHB_08     :  2;   /*!<                   */
X      volatile uint32_t  LHB_08     :  2;    
N      __IO uint32_t  LHB_09     :  2;   /*!<                   */
X      volatile uint32_t  LHB_09     :  2;    
N      __IO uint32_t  LHB_10     :  2;   /*!<                   */
X      volatile uint32_t  LHB_10     :  2;    
N      __IO uint32_t  LHB_11     :  2;   /*!<                   */
X      volatile uint32_t  LHB_11     :  2;    
N      __IO uint32_t  LHB_12     :  2;   /*!<                   */
X      volatile uint32_t  LHB_12     :  2;    
N      __IO uint32_t  LHB_13     :  2;   /*!<                   */
X      volatile uint32_t  LHB_13     :  2;    
N      __IO uint32_t  LHB_14     :  2;   /*!<                   */
X      volatile uint32_t  LHB_14     :  2;    
N      __IO uint32_t  LHB_15     :  2;   /*!<                   */
X      volatile uint32_t  LHB_15     :  2;    
N      __IO uint32_t  LHB_16     :  2;   /*!<                   */
X      volatile uint32_t  LHB_16     :  2;    
N    } FG_0_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  FG_1 ;           /*!< CFG               */
X    volatile uint32_t  FG_1 ;            
N
N    struct {
N      __IO uint32_t  LHB_17     :  2;   /*!<                   */
X      volatile uint32_t  LHB_17     :  2;    
N      __IO uint32_t  LHB_18     :  2;   /*!<                   */
X      volatile uint32_t  LHB_18     :  2;    
N      __IO uint32_t  LHB_19     :  2;   /*!<                   */
X      volatile uint32_t  LHB_19     :  2;    
N      __IO uint32_t  LHB_20     :  2;   /*!<                   */
X      volatile uint32_t  LHB_20     :  2;    
N      __IO uint32_t  LHB_21     :  2;   /*!<                   */
X      volatile uint32_t  LHB_21     :  2;    
N      __IO uint32_t  LHB_22     :  2;   /*!<                   */
X      volatile uint32_t  LHB_22     :  2;    
N      __IO uint32_t  LHB_23     :  2;   /*!<                   */
X      volatile uint32_t  LHB_23     :  2;    
N      __IO uint32_t  LHB_24     :  2;   /*!<                   */
X      volatile uint32_t  LHB_24     :  2;    
N      __IO uint32_t  LHB_25     :  2;   /*!<                   */
X      volatile uint32_t  LHB_25     :  2;    
N      __IO uint32_t  LHB_26     :  2;   /*!<                   */
X      volatile uint32_t  LHB_26     :  2;    
N      __IO uint32_t  LHB_27     :  2;   /*!<                   */
X      volatile uint32_t  LHB_27     :  2;    
N      __IO uint32_t  LHB_28     :  2;   /*!<                   */
X      volatile uint32_t  LHB_28     :  2;    
N      __IO uint32_t  LHB_29     :  2;   /*!<                   */
X      volatile uint32_t  LHB_29     :  2;    
N      __IO uint32_t  LHB_30     :  2;   /*!<                   */
X      volatile uint32_t  LHB_30     :  2;    
N      __IO uint32_t  LHB_31     :  2;   /*!<                   */
X      volatile uint32_t  LHB_31     :  2;    
N      __IO uint32_t  LHB_32     :  2;   /*!<                   */
X      volatile uint32_t  LHB_32     :  2;    
N    } FG_1_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  PN_0 ;           /*!< CFG               */
X    volatile uint32_t  PN_0 ;            
N
N    struct {
N      __IO uint32_t  LHB_01     :  2;   /*!<                   */
X      volatile uint32_t  LHB_01     :  2;    
N      __IO uint32_t  LHB_02     :  2;   /*!<                   */
X      volatile uint32_t  LHB_02     :  2;    
N      __IO uint32_t  LHB_03     :  2;   /*!<                   */
X      volatile uint32_t  LHB_03     :  2;    
N      __IO uint32_t  LHB_04     :  2;   /*!<                   */
X      volatile uint32_t  LHB_04     :  2;    
N      __IO uint32_t  LHB_05     :  2;   /*!<                   */
X      volatile uint32_t  LHB_05     :  2;    
N      __IO uint32_t  LHB_06     :  2;   /*!<                   */
X      volatile uint32_t  LHB_06     :  2;    
N      __IO uint32_t  LHB_07     :  2;   /*!<                   */
X      volatile uint32_t  LHB_07     :  2;    
N      __IO uint32_t  LHB_08     :  2;   /*!<                   */
X      volatile uint32_t  LHB_08     :  2;    
N      __IO uint32_t  LHB_09     :  2;   /*!<                   */
X      volatile uint32_t  LHB_09     :  2;    
N      __IO uint32_t  LHB_10     :  2;   /*!<                   */
X      volatile uint32_t  LHB_10     :  2;    
N      __IO uint32_t  LHB_11     :  2;   /*!<                   */
X      volatile uint32_t  LHB_11     :  2;    
N      __IO uint32_t  LHB_12     :  2;   /*!<                   */
X      volatile uint32_t  LHB_12     :  2;    
N      __IO uint32_t  LHB_13     :  2;   /*!<                   */
X      volatile uint32_t  LHB_13     :  2;    
N      __IO uint32_t  LHB_14     :  2;   /*!<                   */
X      volatile uint32_t  LHB_14     :  2;    
N      __IO uint32_t  LHB_15     :  2;   /*!<                   */
X      volatile uint32_t  LHB_15     :  2;    
N      __IO uint32_t  LHB_16     :  2;   /*!<                   */
X      volatile uint32_t  LHB_16     :  2;    
N    } PN_0_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  PN_1 ;           /*!< CFG               */
X    volatile uint32_t  PN_1 ;            
N
N    struct {
N      __IO uint32_t  LHB_17     :  2;   /*!<                   */
X      volatile uint32_t  LHB_17     :  2;    
N      __IO uint32_t  LHB_18     :  2;   /*!<                   */
X      volatile uint32_t  LHB_18     :  2;    
N      __IO uint32_t  LHB_19     :  2;   /*!<                   */
X      volatile uint32_t  LHB_19     :  2;    
N      __IO uint32_t  LHB_20     :  2;   /*!<                   */
X      volatile uint32_t  LHB_20     :  2;    
N      __IO uint32_t  LHB_21     :  2;   /*!<                   */
X      volatile uint32_t  LHB_21     :  2;    
N      __IO uint32_t  LHB_22     :  2;   /*!<                   */
X      volatile uint32_t  LHB_22     :  2;    
N      __IO uint32_t  LHB_23     :  2;   /*!<                   */
X      volatile uint32_t  LHB_23     :  2;    
N      __IO uint32_t  LHB_24     :  2;   /*!<                   */
X      volatile uint32_t  LHB_24     :  2;    
N      __IO uint32_t  LHB_25     :  2;   /*!<                   */
X      volatile uint32_t  LHB_25     :  2;    
N      __IO uint32_t  LHB_26     :  2;   /*!<                   */
X      volatile uint32_t  LHB_26     :  2;    
N      __IO uint32_t  LHB_27     :  2;   /*!<                   */
X      volatile uint32_t  LHB_27     :  2;    
N      __IO uint32_t  LHB_28     :  2;   /*!<                   */
X      volatile uint32_t  LHB_28     :  2;    
N      __IO uint32_t  LHB_29     :  2;   /*!<                   */
X      volatile uint32_t  LHB_29     :  2;    
N      __IO uint32_t  LHB_30     :  2;   /*!<                   */
X      volatile uint32_t  LHB_30     :  2;    
N      __IO uint32_t  LHB_31     :  2;   /*!<                   */
X      volatile uint32_t  LHB_31     :  2;    
N      __IO uint32_t  LHB_32     :  2;   /*!<                   */
X      volatile uint32_t  LHB_32     :  2;    
N    } PN_1_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSYNC_FREQ ;       /*!< CFG               */
X    volatile uint32_t  VSYNC_FREQ ;        
N
N    struct {
N      __IO uint32_t  F0_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F0_TSYNC :  6;    
N      __IO uint32_t  F1_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F1_TSYNC :  6;    
N      __IO uint32_t  F2_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F2_TSYNC :  6;    
N      __IO uint32_t  F3_TSYNC :  6;   /*!<                   */
X      volatile uint32_t  F3_TSYNC :  6;    
N    } VSYNC_FREQ_b;                   /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSYNC_F1_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F1_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } VSYNC_F1_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F1_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F1_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY :  16;   /*!<                   */
X      volatile uint32_t  DLY :  16;    
N    } VSYNC_F1_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F1_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F1_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } VSYNC_F1_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  VSYNC_F2_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F2_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } VSYNC_F2_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F2_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F2_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY :  16;   /*!<                   */
X      volatile uint32_t  DLY :  16;    
N    } VSYNC_F2_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F2_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F2_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } VSYNC_F2_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  VSYNC_F3_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F3_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } VSYNC_F3_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F3_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F3_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY :  16;   /*!<                   */
X      volatile uint32_t  DLY :  16;    
N    } VSYNC_F3_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  VSYNC_F3_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  VSYNC_F3_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } VSYNC_F3_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  PRLG ;           /*!< CFG               */
X    volatile uint32_t  PRLG ;            
N
N    struct {
N      __IO uint32_t  DLY_0 :  16;   /*!<                   */
X      volatile uint32_t  DLY_0 :  16;    
N      __IO uint32_t  DLY_1 :  16;   /*!<                   */
X      volatile uint32_t  DLY_1 :  16;    
N    } PRLG_b;                       /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  PRE_0 ;          /*!< CFG               */
X    volatile uint32_t  PRE_0 ;           
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;  /*!<                   */
X      volatile uint32_t  TX_PRD :  16;   
N      __IO uint32_t  TX_LOW :  16;  /*!<                   */
X      volatile uint32_t  TX_LOW :  16;   
N    } PRE_0_b;                      /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PRE_1 ;          /*!< CFG               */
X    volatile uint32_t  PRE_1 ;           
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10; /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;  
N      __IO uint32_t  PRE_DLY :  16; /*!<                   */
X      volatile uint32_t  PRE_DLY :  16;  
N    } PRE_1_b;                      /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PRE_2 ;          /*!< CFG               */
X    volatile uint32_t  PRE_2 ;           
N
N    struct {
N      __IO uint32_t  DSSS_DLY :  8; /*!<                   */
X      volatile uint32_t  DSSS_DLY :  8;  
N    } PRE_2_b;                      /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  EPLG_0 ;               /*!< CFG               */
X    volatile uint32_t  EPLG_0 ;                
N
N    struct {
N      __IO uint32_t  DLY_0_BEACON :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_BEACON :  16;   
N      __IO uint32_t  DLY_1        :  16;  /*!<                   */
X      volatile uint32_t  DLY_1        :  16;   
N    } EPLG_0_b;                           /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  EPLG_1 ;               /*!< CFG               */
X    volatile uint32_t  EPLG_1 ;                
N
N    struct {
N      __IO uint32_t  DLY_0_PING_FG_F  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_FG_F  :  16;   
N      __IO uint32_t  DLY_0_PING_FG_L  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_FG_L  :  16;   
N    } EPLG_1_b;                           /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  EPLG_2 ;               /*!< CFG               */
X    volatile uint32_t  EPLG_2 ;                
N
N    struct {
N      __IO uint32_t  DLY_0_PING_PN_P  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_PN_P  :  16;   
N      __IO uint32_t  DLY_0_PING_PN_D  :  16;  /*!<                   */
X      volatile uint32_t  DLY_0_PING_PN_D  :  16;   
N    } EPLG_2_b;                           /*!< BitSize           */
N  };
N
N
N
N//union {
N//  __IO uint32_t  FG_L_ACT_0 ;   /*!< CFG               */
N//
N//  struct {
N//    __IO uint32_t  TX_PRD :  16;    /*!<                   */
N//    __IO uint32_t  TX_LOW :  16;    /*!<                   */
N//  } FG_L_ACT_0_b;               /*!< BitSize           */
N//};
N//
N//union {
N//  __IO uint32_t  FG_L_ACT_1 ;   /*!< CFG               */
N//
N//  struct {
N//    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
N//    __IO uint32_t  DLY     :  16;   /*!<                   */
N//  } FG_L_ACT_1_b;               /*!< BitSize           */
N//};
N//
N//union {
N//  __IO uint32_t  FG_L_ACT_2 ;   /*!< CFG               */
N//
N//  struct {
N//    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
N//  } FG_L_ACT_2_b;               /*!< BitSize           */
N//};
N
N
Nunion {
N  __IO uint32_t  FG_L_F0_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F0_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F0_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F0_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F0_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F0_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F0_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F0_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F0_ACT_2_b;               /*!< BitSize           */
N};
N
N
Nunion {
N  __IO uint32_t  FG_L_F1_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F1_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F1_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F1_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F1_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F1_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F1_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F1_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F1_ACT_2_b;               /*!< BitSize           */
N};
N
N
Nunion {
N  __IO uint32_t  FG_L_F2_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F2_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F2_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F2_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F2_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F2_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F2_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F2_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F2_ACT_2_b;               /*!< BitSize           */
N};
N
N
Nunion {
N  __IO uint32_t  FG_L_F3_ACT_0 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F3_ACT_0 ;    
N
N  struct {
N    __IO uint32_t  TX_PRD :  16;    /*!<                   */
X    volatile uint32_t  TX_PRD :  16;     
N    __IO uint32_t  TX_LOW :  16;    /*!<                   */
X    volatile uint32_t  TX_LOW :  16;     
N  } FG_L_F3_ACT_0_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F3_ACT_1 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F3_ACT_1 ;    
N
N  struct {
N    __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X    volatile uint32_t  TX_NUM  :  10;    
N    __IO uint32_t  DLY     :  16;   /*!<                   */
X    volatile uint32_t  DLY     :  16;    
N  } FG_L_F3_ACT_1_b;               /*!< BitSize           */
N};
N
Nunion {
N  __IO uint32_t  FG_L_F3_ACT_2 ;   /*!< CFG               */
X  volatile uint32_t  FG_L_F3_ACT_2 ;    
N
N  struct {
N    __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X    volatile uint32_t  LINE_NUM :  8;    
N  } FG_L_F3_ACT_2_b;               /*!< BitSize           */
N};
N
N
N
N  union {
N    __IO uint32_t  PN_P_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  PN_P_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } PN_P_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_P_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  PN_P_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } PN_P_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_P_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  PN_P_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } PN_P_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  PN_D_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  PN_D_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } PN_D_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_D_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  PN_D_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } PN_D_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  PN_D_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  PN_D_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } PN_D_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N
N  union {
N    __IO uint32_t  FG_F_F0_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F0_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F0_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F0_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F0_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } FG_F_F0_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F0_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F0_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F0_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  FG_F_F1_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F1_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F1_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F1_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F1_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } FG_F_F1_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F1_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F1_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F1_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  FG_F_F2_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F2_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F2_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F2_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F2_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM  :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM  :  10;    
N      __IO uint32_t  DLY     :  16;   /*!<                   */
X      volatile uint32_t  DLY     :  16;    
N    } FG_F_F2_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F2_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F2_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F2_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  FG_F_F3_ACT_0 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F3_ACT_0 ;    
N
N    struct {
N      __IO uint32_t  TX_PRD :  16;    /*!<                   */
X      volatile uint32_t  TX_PRD :  16;     
N      __IO uint32_t  TX_LOW :  16;    /*!<                   */
X      volatile uint32_t  TX_LOW :  16;     
N    } FG_F_F3_ACT_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F3_ACT_1 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F3_ACT_1 ;    
N
N    struct {
N      __IO uint32_t  TX_NUM :  10;   /*!<                   */
X      volatile uint32_t  TX_NUM :  10;    
N      __IO uint32_t  DLY    :  16;   /*!<                   */
X      volatile uint32_t  DLY    :  16;    
N    } FG_F_F3_ACT_1_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  FG_F_F3_ACT_2 ;   /*!< CFG               */
X    volatile uint32_t  FG_F_F3_ACT_2 ;    
N
N    struct {
N      __IO uint32_t  LINE_NUM :  8;   /*!<                   */
X      volatile uint32_t  LINE_NUM :  8;    
N    } FG_F_F3_ACT_2_b;               /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSWT_SET;          /*!< CFG               */
X    volatile uint32_t  VSWT_SET;           
N
N    struct {
N      __IO uint32_t  INT_0  :  4;     /*!<                   */
X      volatile uint32_t  INT_0  :  4;      
N      __IO uint32_t  INT_1  :  4;     /*!<                   */
X      volatile uint32_t  INT_1  :  4;      
N      __IO uint32_t  INT_2  :  4;     /*!<                   */
X      volatile uint32_t  INT_2  :  4;      
N      __IO uint32_t  INT_3  :  4;     /*!<                   */
X      volatile uint32_t  INT_3  :  4;      
N    } VSWT_SET_b;                     /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  DSSS_INFO_0  ;           /*!< CFG               */
X    volatile uint32_t  DSSS_INFO_0  ;            
N
N    struct {
N      __IO uint32_t  PING_FG     :  5;     /*!<                   */
X      volatile uint32_t  PING_FG     :  5;      
N      __IO uint32_t  PING_PNPOS  :  5;     /*!<                   */
X      volatile uint32_t  PING_PNPOS  :  5;      
N      __IO uint32_t  PING_PNDAT  :  5;     /*!<                   */
X      volatile uint32_t  PING_PNDAT  :  5;      
N    } DSSS_INFO_0_b;                        /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  DSSS_INFO_1  ;           /*!< CFG               */
X    volatile uint32_t  DSSS_INFO_1  ;            
N
N    struct {
N      __IO uint32_t  BEACON_D0    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D0    :  5;      
N      __IO uint32_t  BEACON_D1    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D1    :  5;      
N      __IO uint32_t  BEACON_D2    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D2    :  5;      
N      __IO uint32_t  BEACON_D3    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D3    :  5;      
N      __IO uint32_t  BEACON_D4    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D4    :  5;      
N      __IO uint32_t  BEACON_D5    :  5;     /*!<                   */
X      volatile uint32_t  BEACON_D5    :  5;      
N    } DSSS_INFO_1_b;                        /*!< BitSize           */
N  };
N
N
N  __IO uint32_t  DSSS_CODE_P_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_P_0  ;  
N  __IO uint32_t  DSSS_CODE_P_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_P_1  ;  
N
N  __IO uint32_t  DSSS_CODE_0_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_0_0  ;  
N  __IO uint32_t  DSSS_CODE_0_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_0_1  ;  
N
N  __IO uint32_t  DSSS_CODE_1_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_1_0  ;  
N  __IO uint32_t  DSSS_CODE_1_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_1_1  ;  
N
N  __IO uint32_t  DSSS_CODE_2_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_2_0  ;  
N  __IO uint32_t  DSSS_CODE_2_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_2_1  ;  
N
N  __IO uint32_t  DSSS_CODE_3_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_3_0  ;  
N  __IO uint32_t  DSSS_CODE_3_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_3_1  ;  
N
N  __IO uint32_t  DSSS_CODE_4_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_4_0  ;  
N  __IO uint32_t  DSSS_CODE_4_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_4_1  ;  
N
N  __IO uint32_t  DSSS_CODE_5_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_5_0  ;  
N  __IO uint32_t  DSSS_CODE_5_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_5_1  ;  
N
N  __IO uint32_t  DSSS_CODE_6_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_6_0  ;  
N  __IO uint32_t  DSSS_CODE_6_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_6_1  ;  
N
N  __IO uint32_t  DSSS_CODE_7_0  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_7_0  ;  
N  __IO uint32_t  DSSS_CODE_7_1  ; /*!< CFG               */
X  volatile uint32_t  DSSS_CODE_7_1  ;  
N
N
N  union {
N    __IO uint32_t  ENA_PWM_0 ;     /*!< CFG               */
X    volatile uint32_t  ENA_PWM_0 ;      
N
N    struct {
N      __IO uint32_t  T_0 :  7;     /*!<                   */
X      volatile uint32_t  T_0 :  7;      
N      __IO uint32_t  T_1 :  7;     /*!<                   */
X      volatile uint32_t  T_1 :  7;      
N      __IO uint32_t  T_2 :  7;     /*!<                   */
X      volatile uint32_t  T_2 :  7;      
N    } ENA_PWM_0_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  ENA_PWM_1 ;     /*!< CFG               */
X    volatile uint32_t  ENA_PWM_1 ;      
N
N    struct {
N      __IO uint32_t  T_3 :  7;     /*!<                   */
X      volatile uint32_t  T_3 :  7;      
N      __IO uint32_t  T_4 :  7;     /*!<                   */
X      volatile uint32_t  T_4 :  7;      
N    } ENA_PWM_1_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INV_PWM_0 ;     /*!< CFG               */
X    volatile uint32_t  INV_PWM_0 ;      
N
N    struct {
N      __IO uint32_t  T_0 :  7;     /*!<                   */
X      volatile uint32_t  T_0 :  7;      
N      __IO uint32_t  T_1 :  7;     /*!<                   */
X      volatile uint32_t  T_1 :  7;      
N      __IO uint32_t  T_2 :  7;     /*!<                   */
X      volatile uint32_t  T_2 :  7;      
N    } INV_PWM_0_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INV_PWM_1 ;     /*!< CFG               */
X    volatile uint32_t  INV_PWM_1 ;      
N
N    struct {
N      __IO uint32_t  T_3 :  7;     /*!<                   */
X      volatile uint32_t  T_3 :  7;      
N      __IO uint32_t  T_4 :  7;     /*!<                   */
X      volatile uint32_t  T_4 :  7;      
N    } INV_PWM_1_b ;                /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSWT_CFG_0 ;           /*!< CFG               */
X    volatile uint32_t  VSWT_CFG_0 ;            
N
N    struct {
N      __IO uint32_t  SEL_VSWT_0     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_0     : 4;   
N      __IO uint32_t  SEL_VSWT_1     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_1     : 4;   
N      __IO uint32_t  SEL_VSWT_2     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_2     : 4;   
N      __IO uint32_t  SEL_VSWT_3     : 4;  /*!<                   */
X      volatile uint32_t  SEL_VSWT_3     : 4;   
N      __IO uint32_t  SEL_0_pwm_tx   : 3;  /*!<                   */
X      volatile uint32_t  SEL_0_pwm_tx   : 3;   
N      __IO uint32_t  SEL_0_pwm_data : 3;  /*!<                   */
X      volatile uint32_t  SEL_0_pwm_data : 3;   
N      __IO uint32_t  SEL_0_pwm_gate : 3;  /*!<                   */
X      volatile uint32_t  SEL_0_pwm_gate : 3;   
N      __IO uint32_t  SEL_1_pwm_tx   : 2;  /*!<                   */
X      volatile uint32_t  SEL_1_pwm_tx   : 2;   
N      __IO uint32_t  SEL_1_pwm_data : 2;  /*!<                   */
X      volatile uint32_t  SEL_1_pwm_data : 2;   
N      __IO uint32_t  SEL_1_pwm_gate : 2;  /*!<                   */
X      volatile uint32_t  SEL_1_pwm_gate : 2;   
N    } VSWT_CFG_0_b;                       /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  VSWT_CFG_1 ;               /*!< CFG               */
X    volatile uint32_t  VSWT_CFG_1 ;                
N
N    struct {
N      __IO uint32_t  SEL_TSYNC_INV    : 1;    /*!<                   */
X      volatile uint32_t  SEL_TSYNC_INV    : 1;     
N      __IO uint32_t  SEL_TSYNC_OUT    : 2;    /*!<                   */
X      volatile uint32_t  SEL_TSYNC_OUT    : 2;     
N      __IO uint32_t  DLY_SEL_PWM_PRE  : 3;    /*!<                   */
X      volatile uint32_t  DLY_SEL_PWM_PRE  : 3;     
N      __IO uint32_t  DLY_SEL_PWM_ACT  : 3;    /*!<                   */
X      volatile uint32_t  DLY_SEL_PWM_ACT  : 3;     
N      __IO uint32_t  DLY_ENA_PWM_TX   : 1;    /*!<                   */
X      volatile uint32_t  DLY_ENA_PWM_TX   : 1;     
N      __IO uint32_t  DLY_ENA_PWM_DATA : 1;    /*!<                   */
X      volatile uint32_t  DLY_ENA_PWM_DATA : 1;     
N      __IO uint32_t  DLY_ENA_PWM_GATE : 1;    /*!<                   */
X      volatile uint32_t  DLY_ENA_PWM_GATE : 1;     
N      __IO uint32_t  DLY_BP_PRE_TX    : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PRE_TX    : 1;     
N      __IO uint32_t  DLY_BP_PRE_DATA  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PRE_DATA  : 1;     
N      __IO uint32_t  DLY_BP_PRE_GATE  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PRE_GATE  : 1;     
N      __IO uint32_t  DLY_BP_PWM_TX    : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PWM_TX    : 1;     
N      __IO uint32_t  DLY_BP_PWM_DATA  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PWM_DATA  : 1;     
N      __IO uint32_t  DLY_BP_PWM_GATE  : 1;    /*!<                   */
X      volatile uint32_t  DLY_BP_PWM_GATE  : 1;     
N      __IO uint32_t  DLY_INV_PWM_TX   : 1;    /*!<                   */
X      volatile uint32_t  DLY_INV_PWM_TX   : 1;     
N      __IO uint32_t  DLY_INV_PWM_DATA : 1;    /*!<                   */
X      volatile uint32_t  DLY_INV_PWM_DATA : 1;     
N      __IO uint32_t  DLY_INV_PWM_GATE : 1;    /*!<                   */
X      volatile uint32_t  DLY_INV_PWM_GATE : 1;     
N    } VSWT_CFG_1_b;                           /*!< BitSize           */
N  };
N
N
N
N  union {
N    __IO uint32_t  DLY_PWM_CFG_0  ;  /*!< CFG               */
X    volatile uint32_t  DLY_PWM_CFG_0  ;   
N
N    struct {
N      __IO uint32_t  TX   :  16;     /*!<                   */
X      volatile uint32_t  TX   :  16;      
N      __IO uint32_t  DATA :  16;     /*!<                   */
X      volatile uint32_t  DATA :  16;      
N    } DLY_PWM_CFG_0_b;               /*!< BitSize           */
N  };
N
N  union {
N    __IO uint32_t  DLY_PWM_CFG_1  ;  /*!< CFG               */
X    volatile uint32_t  DLY_PWM_CFG_1  ;   
N
N    struct {
N      __IO uint32_t  GATE :  16;     /*!<                   */
X      volatile uint32_t  GATE :  16;      
N    } DLY_PWM_CFG_1_b;               /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  WFE_CFG_0  ;               /*!< CFG               */
X    volatile uint32_t  WFE_CFG_0  ;                
N
N    struct {
N      __IO uint32_t  ENA  :  6;    /*!<                   */
X      volatile uint32_t  ENA  :  6;     
N      __IO uint32_t  SEL  :  6;    /*!<                   */
X      volatile uint32_t  SEL  :  6;     
N      __IO uint32_t  PUL  :  6;    /*!<                   */
X      volatile uint32_t  PUL  :  6;     
N      __IO uint32_t  DBG  :  6;    /*!<                   */
X      volatile uint32_t  DBG  :  6;     
N      __IO uint32_t  DRV  :  6;    /*!<                   */
X      volatile uint32_t  DRV  :  6;     
N    } WFE_CFG_0_b;                          /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  WFE_CFG_1  ;               /*!< CFG               */
X    volatile uint32_t  WFE_CFG_1  ;                
N
N    struct {
N      __IO uint32_t  DLY  :  6;    /*!<                   */
X      volatile uint32_t  DLY  :  6;     
N      __IO uint32_t  smpl :  8;    /*!<                   */
X      volatile uint32_t  smpl :  8;     
N    } WFE_CFG_1_b;                          /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INTR_CFG ;                  /*!< CFG               */
X    volatile uint32_t  INTR_CFG ;                   
N
N    struct {
N      __IO uint32_t  HI_ABOVE_NUM       :  6;    /*!<                   */
X      volatile uint32_t  HI_ABOVE_NUM       :  6;     
N      __IO uint32_t  LO_BELOW_NUM       :  6;    /*!<                   */
X      volatile uint32_t  LO_BELOW_NUM       :  6;     
N      __IO uint32_t  FSM_ON_IBE         :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON_IBE         :  1;     
N      __IO uint32_t  FSM_ON_IEV         :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON_IEV         :  1;     
N      __IO uint32_t  FSM_ON_IE          :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON_IE          :  1;     
N      __IO uint32_t  VSYNC_IN_EXT_IBE   :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT_IBE   :  1;     
N      __IO uint32_t  VSYNC_IN_EXT_IEV   :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT_IEV   :  1;     
N      __IO uint32_t  VSYNC_IN_EXT_IE    :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT_IE    :  1;     
N      __IO uint32_t  TSYNC_IN_EXT_IBE   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT_IBE   :  1;     
N      __IO uint32_t  TSYNC_IN_EXT_IEV   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT_IEV   :  1;     
N      __IO uint32_t  TSYNC_IN_EXT_IE    :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT_IE    :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT_IBE  :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT_IBE  :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT_IEV  :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT_IEV  :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT_IE   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT_IE   :  1;     
N      __IO uint32_t  TSYNC_FR_IBE       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR_IBE       :  1;     
N      __IO uint32_t  TSYNC_FR_IEV       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR_IEV       :  1;     
N      __IO uint32_t  TSYNC_FR_IE        :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR_IE        :  1;     
N      __IO uint32_t  TSYNC_MNT_IBE      :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT_IBE      :  1;     
N      __IO uint32_t  TSYNC_MNT_IEV      :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT_IEV      :  1;     
N      __IO uint32_t  TSYNC_MNT_IE       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT_IE       :  1;     
N    } INTR_CFG_b;                              /*!< BitSize           */
N  };
N
N
N  union {
N    __IO uint32_t  INTR_CLR ;                /*!< CFG               */
X    volatile uint32_t  INTR_CLR ;                 
N
N    struct {
N      __IO uint32_t  FSM_ON         :  1;    /*!<                   */
X      volatile uint32_t  FSM_ON         :  1;     
N      __IO uint32_t  VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile uint32_t  VSYNC_IN_EXT   :  1;     
N      __IO uint32_t  TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_IN_EXT   :  1;     
N      __IO uint32_t  TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_OUT_EXT  :  1;     
N      __IO uint32_t  TSYNC_FR       :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_FR       :  1;     
N      __IO uint32_t  TSYNC_MNT      :  1;    /*!<                   */
X      volatile uint32_t  TSYNC_MNT      :  1;     
N    } INTR_CLR_b;                            /*!< BitSize           */
N  };
N
N
N  union {
N    __I  uint32_t  INTR_ST ;                    /*!< CFG               */
X    volatile const  uint32_t  INTR_ST ;                     
N
N    struct {
N      __I uint32_t  MIS_FSM_ON         :  1;    /*!<                   */
X      volatile const uint32_t  MIS_FSM_ON         :  1;     
N      __I uint32_t  MIS_VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  MIS_VSYNC_IN_EXT   :  1;     
N      __I uint32_t  MIS_TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_IN_EXT   :  1;     
N      __I uint32_t  MIS_TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_OUT_EXT  :  1;     
N      __I uint32_t  MIS_TSYNC_FR       :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_FR       :  1;     
N      __I uint32_t  MIS_TSYNC_MNT      :  1;    /*!<                   */
X      volatile const uint32_t  MIS_TSYNC_MNT      :  1;     
N      __I uint32_t  RIS_FSM_ON         :  1;    /*!<                   */
X      volatile const uint32_t  RIS_FSM_ON         :  1;     
N      __I uint32_t  RIS_VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  RIS_VSYNC_IN_EXT   :  1;     
N      __I uint32_t  RIS_TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_IN_EXT   :  1;     
N      __I uint32_t  RIS_TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_OUT_EXT  :  1;     
N      __I uint32_t  RIS_TSYNC_FR       :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_FR       :  1;     
N      __I uint32_t  RIS_TSYNC_MNT      :  1;    /*!<                   */
X      volatile const uint32_t  RIS_TSYNC_MNT      :  1;     
N      __I uint32_t  FSM_ON         :  1;    /*!<                   */
X      volatile const uint32_t  FSM_ON         :  1;     
N      __I uint32_t  VSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  VSYNC_IN_EXT   :  1;     
N      __I uint32_t  TSYNC_IN_EXT   :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_IN_EXT   :  1;     
N      __I uint32_t  TSYNC_OUT_EXT  :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_OUT_EXT  :  1;     
N      __I uint32_t  TSYNC_FR       :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_FR       :  1;     
N      __I uint32_t  TSYNC_MNT      :  1;    /*!<                   */
X      volatile const uint32_t  TSYNC_MNT      :  1;     
N    } INTR_ST_b;                                /*!< BitSize           */
N  };
N
N	union {
N	  __IO	uint32_t  DSSS_CFG ;
X	  volatile	uint32_t  DSSS_CFG ;
N
N	  struct {
N		__IO uint32_t  beacon_en		 :	1;
X		volatile uint32_t  beacon_en		 :	1;
N		__IO uint32_t  ping_en			 :	1;
X		volatile uint32_t  ping_en			 :	1;
N		__IO uint32_t  dsss_sel 		 :	1;
X		volatile uint32_t  dsss_sel 		 :	1;
N	  } DSSS_CFG_b;
N	};
N
N	__IO  uint32_t	USI_CHIP_LEN ;
X	volatile  uint32_t	USI_CHIP_LEN ;
N
N	union {
N	  __IO	uint32_t  USI_CODE_LEN ;
X	  volatile	uint32_t  USI_CODE_LEN ;
N
N	  struct {
N		__IO uint32_t  beacon			 :	6;
X		volatile uint32_t  beacon			 :	6;
N		__IO uint32_t  finger			 :	6;
X		volatile uint32_t  finger			 :	6;
N		__IO uint32_t  penpos			 :	6;
X		volatile uint32_t  penpos			 :	6;
N		__IO uint32_t  pendat			 :	6;
X		volatile uint32_t  pendat			 :	6;
N	  } USI_CODE_LEN_b;
N	};
N
N	__IO  uint32_t	USI_DSSS_CHIP0 ;
X	volatile  uint32_t	USI_DSSS_CHIP0 ;
N	__IO  uint32_t	USI_DSSS_CHIP1 ;
X	volatile  uint32_t	USI_DSSS_CHIP1 ;
N	__IO  uint32_t	USI_BEACON_CODE0 ;
X	volatile  uint32_t	USI_BEACON_CODE0 ;
N	__IO  uint32_t	USI_BEACON_CODE1 ;
X	volatile  uint32_t	USI_BEACON_CODE1 ;
N
N
N	union {
N	  __IO	uint32_t  USI_PING_CODE ;
X	  volatile	uint32_t  USI_PING_CODE ;
N
N	  struct {
N		__IO uint32_t  ping_finger		 :	8;
X		volatile uint32_t  ping_finger		 :	8;
N		__IO uint32_t  ping_penpos		 :	8;
X		volatile uint32_t  ping_penpos		 :	8;
N		__IO uint32_t  ping_pendat		 :	8;
X		volatile uint32_t  ping_pendat		 :	8;
N	  } USI_PING_CODE_b;
N	};
N
N
N} PWMDRV_TypeDef;
N
N
N#endif /* __PWMDRV_H_ */
L 288 "..\..\Hal\system\MFTP.h" 2
N#include "_dsp.h"
L 1 "..\..\Hal\dspB\_dsp.h" 1
N#ifndef _DSP_H_
N#define _DSP_H_
N
N
Ntypedef union
N{
N    struct {
N        unsigned    XSIZE0:                    8;
N        unsigned    XSIZE1:                    8;
N        unsigned    XSIZE2:                    8;
N        unsigned    XSIZE3:                    8;
N    } b;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TDSP_DMA_XSIZE;
N
Ntypedef union
N{
N    struct {
N        unsigned    YSIZE0:                    8;
N        unsigned    YSIZE1:                    8;
N        unsigned    YSIZE2:                    8;
N        unsigned    YSIZE3:                    8;
N    } b;
N    __IO uint32_t w;
X    volatile uint32_t w;
N} t_TDSP_DMA_YSIZE;
N
N
Ntypedef struct
N{
N    __IO uint32_t                    TDSP_REGA0;                     //0x0000
X    volatile uint32_t                    TDSP_REGA0;                     
N    __IO uint32_t                    TDSP_REGA1;                     //0x0001
X    volatile uint32_t                    TDSP_REGA1;                     
N    __IO uint32_t                    TDSP_REGA2;                     //0x0002
X    volatile uint32_t                    TDSP_REGA2;                     
N    __IO uint32_t                    TDSP_REGA3;                     //0x0003
X    volatile uint32_t                    TDSP_REGA3;                     
N    __IO uint32_t                    TDSP_REGA4;                     //0x0004
X    volatile uint32_t                    TDSP_REGA4;                     
N    __IO uint32_t                    TDSP_REGA5;                     //0x0005
X    volatile uint32_t                    TDSP_REGA5;                     
N    __IO uint32_t                    TDSP_REGA6;                     //0x0006
X    volatile uint32_t                    TDSP_REGA6;                     
N    __IO uint32_t                    TDSP_REGA7;                     //0x0007
X    volatile uint32_t                    TDSP_REGA7;                     
N    __IO uint32_t                    TDSP_REGB0;                     //0x0008
X    volatile uint32_t                    TDSP_REGB0;                     
N    __IO uint32_t                    TDSP_REGB1;                     //0x0009
X    volatile uint32_t                    TDSP_REGB1;                     
N    __IO uint32_t                    TDSP_REGB2;                     //0x000A
X    volatile uint32_t                    TDSP_REGB2;                     
N    __IO uint32_t                    TDSP_REGB3;                     //0x000B
X    volatile uint32_t                    TDSP_REGB3;                     
N    __IO uint32_t                    TDSP_REGB4;                     //0x000C
X    volatile uint32_t                    TDSP_REGB4;                     
N    __IO uint32_t                    TDSP_REGB5;                     //0x000D
X    volatile uint32_t                    TDSP_REGB5;                     
N    __IO uint32_t                    TDSP_REGB6;                     //0x000E
X    volatile uint32_t                    TDSP_REGB6;                     
N    __IO uint32_t                    TDSP_REGB7;                     //0x000F
X    volatile uint32_t                    TDSP_REGB7;                     
N    __IO uint32_t                    TDSP_REGC0;                     //0x0010
X    volatile uint32_t                    TDSP_REGC0;                     
N    __IO uint32_t                    TDSP_REGC1;                     //0x0011
X    volatile uint32_t                    TDSP_REGC1;                     
N    __IO uint32_t                    TDSP_REGC2;                     //0x0012
X    volatile uint32_t                    TDSP_REGC2;                     
N    __IO uint32_t                    TDSP_REGC3;                     //0x0013
X    volatile uint32_t                    TDSP_REGC3;                     
N    __IO uint32_t                    TDSP_REGC4;                     //0x0014
X    volatile uint32_t                    TDSP_REGC4;                     
N    __IO uint32_t                    TDSP_REGC5;                     //0x0015
X    volatile uint32_t                    TDSP_REGC5;                     
N    __IO uint32_t                    TDSP_REGC6;                     //0x0016
X    volatile uint32_t                    TDSP_REGC6;                     
N    __IO uint32_t                    TDSP_REGC7;                     //0x0017
X    volatile uint32_t                    TDSP_REGC7;                     
N    __IO uint32_t                    TDSP_RESERVED00;                //0x0018
X    volatile uint32_t                    TDSP_RESERVED00;                
N    __IO uint32_t                    TDSP_RESERVED01;                //0x0019
X    volatile uint32_t                    TDSP_RESERVED01;                
N    __IO uint32_t                    TDSP_RESERVED02;                //0x001A
X    volatile uint32_t                    TDSP_RESERVED02;                
N    __IO uint32_t                    TDSP_RESERVED03;                //0x001B
X    volatile uint32_t                    TDSP_RESERVED03;                
N    __IO uint32_t                    TDSP_RESERVED04;                //0x001C
X    volatile uint32_t                    TDSP_RESERVED04;                
N    __IO uint32_t                    TDSP_RESERVED05;                //0x001D
X    volatile uint32_t                    TDSP_RESERVED05;                
N    __IO uint32_t                    TDSP_RESERVED06;                //0x001E
X    volatile uint32_t                    TDSP_RESERVED06;                
N    __IO uint32_t                    TDSP_RESERVED07;                //0x001F
X    volatile uint32_t                    TDSP_RESERVED07;                
N    __I  uint32_t                    TDSP_RESERVED07_1;              //0x0020
X    volatile const  uint32_t                    TDSP_RESERVED07_1;              
N    __IO uint32_t                    TDSP_RESERVED07_2;              //0x0021
X    volatile uint32_t                    TDSP_RESERVED07_2;              
N    __IO uint32_t                    TDSP_RESERVED08;                //0x0022
X    volatile uint32_t                    TDSP_RESERVED08;                
N    __IO uint32_t                    TDSP_RESERVED09;                //0x0023
X    volatile uint32_t                    TDSP_RESERVED09;                
N    __IO uint32_t                    TDSP_RESERVED10;                //0x0024
X    volatile uint32_t                    TDSP_RESERVED10;                
N    __IO uint32_t                    TDSP_RESERVED11;                //0x0025
X    volatile uint32_t                    TDSP_RESERVED11;                
N    __IO uint32_t                    TDSP_RESERVED12;                //0x0026
X    volatile uint32_t                    TDSP_RESERVED12;                
N    __IO uint32_t                    TDSP_RESERVED13;                //0x0027
X    volatile uint32_t                    TDSP_RESERVED13;                
N    __IO uint32_t                    TDSP_RESERVED14;                //0x0028
X    volatile uint32_t                    TDSP_RESERVED14;                
N    __IO uint32_t                    TDSP_RESERVED15;                //0x0029
X    volatile uint32_t                    TDSP_RESERVED15;                
N    __IO uint32_t                    TDSP_RESERVED16;                //0x002A
X    volatile uint32_t                    TDSP_RESERVED16;                
N    __IO uint32_t                    TDSP_RESERVED17;                //0x002B
X    volatile uint32_t                    TDSP_RESERVED17;                
N    __IO uint32_t                    TDSP_RESERVED18;                //0x002C
X    volatile uint32_t                    TDSP_RESERVED18;                
N    __IO uint32_t                    TDSP_RESERVED19;                //0x002D
X    volatile uint32_t                    TDSP_RESERVED19;                
N    __IO uint32_t                    TDSP_RESERVED20;                //0x002E
X    volatile uint32_t                    TDSP_RESERVED20;                
N    __IO uint32_t                    TDSP_RESERVED21;                //0x002F
X    volatile uint32_t                    TDSP_RESERVED21;                
N    __IO uint32_t                    TDSP_RESERVED22;                //0x0030
X    volatile uint32_t                    TDSP_RESERVED22;                
N    __IO uint32_t                    TDSP_RESERVED23;                //0x0031
X    volatile uint32_t                    TDSP_RESERVED23;                
N    __IO uint32_t                    TDSP_RESERVED24;                //0x0032
X    volatile uint32_t                    TDSP_RESERVED24;                
N    __IO uint32_t                    TDSP_RESERVED25;                //0x0033
X    volatile uint32_t                    TDSP_RESERVED25;                
N    __IO uint32_t                    TDSP_RESERVED26;                //0x0034
X    volatile uint32_t                    TDSP_RESERVED26;                
N    __IO uint32_t                    TDSP_RESERVED27;                //0x0035
X    volatile uint32_t                    TDSP_RESERVED27;                
N    __IO uint32_t                    TDSP_RESERVED28;                //0x0036
X    volatile uint32_t                    TDSP_RESERVED28;                
N    __IO uint32_t                    TDSP_RESERVED29;                //0x0037
X    volatile uint32_t                    TDSP_RESERVED29;                
N    __IO uint32_t                    TDSP_RESERVED30;                //0x0038
X    volatile uint32_t                    TDSP_RESERVED30;                
N    __IO uint32_t                    TDSP_RESERVED31;                //0x0039
X    volatile uint32_t                    TDSP_RESERVED31;                
N    __IO uint32_t                    TDSP_RESERVED32;                //0x003A
X    volatile uint32_t                    TDSP_RESERVED32;                
N    __IO uint32_t                    TDSP_RESERVED33;                //0x003B
X    volatile uint32_t                    TDSP_RESERVED33;                
N    __IO uint32_t                    TDSP_RESERVED34;                //0x003C
X    volatile uint32_t                    TDSP_RESERVED34;                
N    __IO uint32_t                    TDSP_RESERVED35;                //0x003D
X    volatile uint32_t                    TDSP_RESERVED35;                
N    __IO uint32_t                    TDSP_RESERVED36;                //0x003E
X    volatile uint32_t                    TDSP_RESERVED36;                
N    __IO uint32_t                    TDSP_RESERVED37;                //0x003F
X    volatile uint32_t                    TDSP_RESERVED37;                
N    __IO uint32_t                    TDSP_PC;                        //0x0040
X    volatile uint32_t                    TDSP_PC;                        
N    __I  uint32_t                    TDSP_RESERVED37_1;                //0x0041
X    volatile const  uint32_t                    TDSP_RESERVED37_1;                
N    __IO uint32_t                    TDSP_RESERVED37_2;                //0x0042
X    volatile uint32_t                    TDSP_RESERVED37_2;                
N    __IO uint32_t                    TDSP_RESERVED37_3;                //0x0043
X    volatile uint32_t                    TDSP_RESERVED37_3;                
N    __IO uint32_t                    TDSP_RESERVED37_4;                //0x0044
X    volatile uint32_t                    TDSP_RESERVED37_4;                
N    __IO uint32_t                    TDSP_RESERVED37_5;                //0x0045
X    volatile uint32_t                    TDSP_RESERVED37_5;                
N    __I  uint32_t                    TDSP_RESERVED37_6;                //0x0046
X    volatile const  uint32_t                    TDSP_RESERVED37_6;                
N    __I  uint32_t                    TDSP_RESERVED37_7;                //0x0047
X    volatile const  uint32_t                    TDSP_RESERVED37_7;                
N    __I  uint32_t                    TDSP_RESERVED37_8;                //0x0048
X    volatile const  uint32_t                    TDSP_RESERVED37_8;                
N    __I  uint32_t                    TDSP_BUSY;                      //0x0049
X    volatile const  uint32_t                    TDSP_BUSY;                      
N    __IO uint32_t                    TDSP_CACHE_BASE;                //0x004A
X    volatile uint32_t                    TDSP_CACHE_BASE;                
N    __IO uint32_t                    TDSP_RESERVED37_9;                //0x004B
X    volatile uint32_t                    TDSP_RESERVED37_9;                
N    __IO uint32_t            	     TDSP_RESERVED37_10;                 //0x004C
X    volatile uint32_t            	     TDSP_RESERVED37_10;                 
N    __IO uint32_t            		 TDSP_RESERVED37_11;                 //0x004D
X    volatile uint32_t            		 TDSP_RESERVED37_11;                 
N    __IO uint32_t            		 TDSP_RESERVED37_12;                 //0x004E
X    volatile uint32_t            		 TDSP_RESERVED37_12;                 
N    __IO uint32_t            		 TDSP_RESERVED37_13;                 //0x004F
X    volatile uint32_t            		 TDSP_RESERVED37_13;                 
N    __IO uint32_t           		 TDSP_RESERVED37_14;                //0x0050
X    volatile uint32_t           		 TDSP_RESERVED37_14;                
N    __I  uint32_t           		 TDSP_RESERVED37_15;                //0x0051
X    volatile const  uint32_t           		 TDSP_RESERVED37_15;                
N    __IO uint32_t         			 TDSP_RESERVED37_16;              //0x0052
X    volatile uint32_t         			 TDSP_RESERVED37_16;              
N    __IO uint32_t         			 TDSP_RESERVED37_17;              //0x0053
X    volatile uint32_t         			 TDSP_RESERVED37_17;              
N    __IO uint32_t         			 TDSP_RESERVED37_18;              //0x0054
X    volatile uint32_t         			 TDSP_RESERVED37_18;              
N    __IO uint32_t         			 TDSP_RESERVED37_19;              //0x0055
X    volatile uint32_t         			 TDSP_RESERVED37_19;              
N    __I  uint32_t                    TDSP_RESERVED38;                //0x0056
X    volatile const  uint32_t                    TDSP_RESERVED38;                
N    __IO uint32_t                    TDSP_RESERVED39;                //0x0057
X    volatile uint32_t                    TDSP_RESERVED39;                
N    __IO uint32_t                    TDSP_RESERVED40;                //0x0058
X    volatile uint32_t                    TDSP_RESERVED40;                
N    __IO uint32_t                    TDSP_RESERVED41;                //0x0059
X    volatile uint32_t                    TDSP_RESERVED41;                
N    __IO uint32_t                    TDSP_RESERVED42;                //0x005A
X    volatile uint32_t                    TDSP_RESERVED42;                
N    __IO uint32_t                    TDSP_RESERVED43;                //0x005B
X    volatile uint32_t                    TDSP_RESERVED43;                
N    __IO uint32_t                    TDSP_RESERVED44;                //0x005C
X    volatile uint32_t                    TDSP_RESERVED44;                
N    __IO uint32_t                    TDSP_RESERVED45;                //0x005D
X    volatile uint32_t                    TDSP_RESERVED45;                
N    __IO uint32_t                    TDSP_RESERVED46;                //0x005E
X    volatile uint32_t                    TDSP_RESERVED46;                
N    __IO uint32_t                    TDSP_RESERVED47;                //0x005F
X    volatile uint32_t                    TDSP_RESERVED47;                
N    __IO uint32_t                    TDSP_RESERVED48;                //0x0060
X    volatile uint32_t                    TDSP_RESERVED48;                
N    __IO uint32_t                    TDSP_RESERVED49;                //0x0061
X    volatile uint32_t                    TDSP_RESERVED49;                
N    __IO uint32_t                    TDSP_RESERVED50;                //0x0062
X    volatile uint32_t                    TDSP_RESERVED50;                
N    __IO uint32_t                    TDSP_RESERVED51;                //0x0063
X    volatile uint32_t                    TDSP_RESERVED51;                
N    __IO uint32_t                    TDSP_RESERVED52;                //0x0064
X    volatile uint32_t                    TDSP_RESERVED52;                
N    __IO uint32_t                    TDSP_RESERVED53;                //0x0065
X    volatile uint32_t                    TDSP_RESERVED53;                
N    __IO uint32_t                    TDSP_RESERVED54;                //0x0066
X    volatile uint32_t                    TDSP_RESERVED54;                
N    __IO uint32_t                    TDSP_RESERVED55;                //0x0067
X    volatile uint32_t                    TDSP_RESERVED55;                
N    __IO uint32_t                    TDSP_RESERVED56;                //0x0068
X    volatile uint32_t                    TDSP_RESERVED56;                
N    __IO uint32_t                    TDSP_RESERVED57;                //0x0069
X    volatile uint32_t                    TDSP_RESERVED57;                
N    __IO uint32_t                    TDSP_RESERVED58;                //0x006A
X    volatile uint32_t                    TDSP_RESERVED58;                
N    __IO uint32_t                    TDSP_RESERVED59;                //0x006B
X    volatile uint32_t                    TDSP_RESERVED59;                
N    __IO uint32_t                    TDSP_RESERVED60;                //0x006C
X    volatile uint32_t                    TDSP_RESERVED60;                
N    __IO uint32_t                    TDSP_RESERVED61;                //0x006D
X    volatile uint32_t                    TDSP_RESERVED61;                
N    __IO uint32_t                    TDSP_RESERVED62;                //0x006E
X    volatile uint32_t                    TDSP_RESERVED62;                
N    __IO uint32_t                    TDSP_RESERVED63;                //0x006F
X    volatile uint32_t                    TDSP_RESERVED63;                
N    __IO uint32_t                    TDSP_RESERVED64;                //0x0070
X    volatile uint32_t                    TDSP_RESERVED64;                
N    __IO uint32_t                    TDSP_RESERVED65;                //0x0071
X    volatile uint32_t                    TDSP_RESERVED65;                
N    __IO uint32_t                    TDSP_RESERVED66;                //0x0072
X    volatile uint32_t                    TDSP_RESERVED66;                
N    __IO uint32_t                    TDSP_RESERVED67;                //0x0073
X    volatile uint32_t                    TDSP_RESERVED67;                
N    __IO uint32_t                    TDSP_RESERVED68;                //0x0074
X    volatile uint32_t                    TDSP_RESERVED68;                
N    __IO uint32_t                    TDSP_RESERVED69;                //0x0075
X    volatile uint32_t                    TDSP_RESERVED69;                
N    __IO uint32_t                    TDSP_RESERVED70;                //0x0076
X    volatile uint32_t                    TDSP_RESERVED70;                
N    __IO uint32_t                    TDSP_RESERVED71;                //0x0077
X    volatile uint32_t                    TDSP_RESERVED71;                
N    __IO uint32_t                    TDSP_RESERVED72;                //0x0078
X    volatile uint32_t                    TDSP_RESERVED72;                
N    __IO uint32_t                    TDSP_RESERVED73;                //0x0079
X    volatile uint32_t                    TDSP_RESERVED73;                
N    __IO uint32_t                    TDSP_RESERVED74;                //0x007A
X    volatile uint32_t                    TDSP_RESERVED74;                
N    __IO uint32_t                    TDSP_RESERVED75;                //0x007B
X    volatile uint32_t                    TDSP_RESERVED75;                
N    __IO uint32_t                    TDSP_RESERVED76;                //0x007C
X    volatile uint32_t                    TDSP_RESERVED76;                
N    __IO uint32_t                    TDSP_RESERVED77;                //0x007D
X    volatile uint32_t                    TDSP_RESERVED77;                
N    __IO uint32_t                    TDSP_RESERVED78;                //0x007E
X    volatile uint32_t                    TDSP_RESERVED78;                
N    __IO uint32_t                    TDSP_RESERVED79;                //0x007F
X    volatile uint32_t                    TDSP_RESERVED79;                
N    __IO t_TDSP_DMA_XSIZE            TDSP_DMA_XSIZE;                 //0x0080
X    volatile t_TDSP_DMA_XSIZE            TDSP_DMA_XSIZE;                 
N    __IO t_TDSP_DMA_YSIZE            TDSP_DMA_YSIZE;                 //0x0081
X    volatile t_TDSP_DMA_YSIZE            TDSP_DMA_YSIZE;                 
N    __IO uint32_t                    TDSP_DMA_ADD;                   //0x0082
X    volatile uint32_t                    TDSP_DMA_ADD;                   
N} DSP_CONTROL_TypeDef;
N
N
N#endif /* _DSP_H_ */
L 289 "..\..\Hal\system\MFTP.h" 2
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group MFTP */
N/** @} */ /* End of group LG Display */
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N#define HW_REG(addr) (*((volatile unsigned long *)(addr)))
N#define READ_MEMORY32(Reg)		(*(__IO uint32_t*)Reg)
N#define READ_MEMORY16(Reg)		(*(__IO uint16_t*)Reg)
N#define READ_MEMORY8(Reg)		(*(__IO uint8_t*)Reg)
N#define WRITE_MEMORY32(reg,value) 	(READ_MEMORY32(reg) = value)
N#define WRITE_MEMORY16(reg,value) 	(READ_MEMORY16(reg) = value)
N#define WRITE_MEMORY8(reg,value)		(READ_MEMORY8(reg) = value)
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N#define READ_REG(REG)         ((REG))
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define __I     volatile const            /*!< defines 'read only' permissions      */
N#define __O     volatile                  /*!< defines 'write only' permissions     */
N#define __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N/* -------------------  Bit Definition ------------------ */
N#define BIT0		((uint32_t)0x0000000000000001) /** Bit 0 select mask */
N#define BIT1		((uint32_t)0x0000000000000002) /** Bit 1 select mask */
N#define BIT2		((uint32_t)0x0000000000000004) /** Bit 2 select mask */
N#define BIT3		((uint32_t)0x0000000000000008) /** Bit 3 select mask */
N#define BIT4		((uint32_t)0x0000000000000010) /** Bit 4 select mask */
N#define BIT5		((uint32_t)0x0000000000000020) /** Bit 5 select mask */
N#define BIT6		((uint32_t)0x0000000000000040) /** Bit 6 select mask */
N#define BIT7		((uint32_t)0x0000000000000080) /** Bit 7 select mask */
N#define BIT8		((uint32_t)0x0000000000000100) /** Bit 8 select mask */
N#define BIT9		((uint32_t)0x0000000000000200) /** Bit 9 select mask */
N#define BIT10		((uint32_t)0x0000000000000400) /** Bit 10 select mask */
N#define BIT11		((uint32_t)0x0000000000000800) /** Bit 11 select mask */
N#define BIT12		((uint32_t)0x0000000000001000) /** Bit 12 select mask */
N#define BIT13		((uint32_t)0x0000000000002000) /** Bit 13 select mask */
N#define BIT14		((uint32_t)0x0000000000004000) /** Bit 14 select mask */
N#define BIT15		((uint32_t)0x0000000000008000) /** Bit 15 select mask */
N#define BIT16		((uint32_t)0x0000000000010000) /** Bit 16 select mask */
N#define BIT17		((uint32_t)0x0000000000020000) /** Bit 17 select mask */
N#define BIT18		((uint32_t)0x0000000000040000) /** Bit 18 select mask */
N#define BIT19		((uint32_t)0x0000000000080000) /** Bit 19 select mask */
N#define BIT20		((uint32_t)0x0000000000100000) /** Bit 20 select mask */
N#define BIT21		((uint32_t)0x0000000000200000) /** Bit 21 select mask */
N#define BIT22		((uint32_t)0x0000000000400000) /** Bit 22 select mask */
N#define BIT23		((uint32_t)0x0000000000800000) /** Bit 23 select mask */
N#define BIT24		((uint32_t)0x0000000001000000) /** Bit 24 select mask */
N#define BIT25		((uint32_t)0x0000000002000000) /** Bit 25 select mask */
N#define BIT26		((uint32_t)0x0000000004000000) /** Bit 26 select mask */
N#define BIT27		((uint32_t)0x0000000008000000) /** Bit 27 select mask */
N#define BIT28		((uint32_t)0x0000000010000000) /** Bit 28 select mask */
N#define BIT29		((uint32_t)0x0000000020000000) /** Bit 29 select mask */
N#define BIT30		((uint32_t)0x0000000040000000) /** Bit 30 select mask */
N#define BIT31		((uint32_t)0x0000000080000000) /** Bit 31 select mask */
N#define BIT32		((uint64_t)0x0000000100000000) /** Bit 32 select mask */
N#define BIT33		((uint64_t)0x0000000200000000) /** Bit 33 select mask */
N#define BIT34		((uint64_t)0x0000000400000000) /** Bit 34 select mask */
N#define BIT35		((uint64_t)0x0000000800000000) /** Bit 35 select mask */
N#define BIT36		((uint64_t)0x0000001000000000) /** Bit 36 select mask */
N#define BIT37		((uint64_t)0x0000002000000000) /** Bit 37 select mask */
N#define BIT38		((uint64_t)0x0000004000000000) /** Bit 38 select mask */
N#define BIT39		((uint64_t)0x0000008000000000) /** Bit 39 select mask */
N#define BIT40		((uint64_t)0x0000010000000000) /** Bit 40 select mask */
N#define BIT41		((uint64_t)0x0000020000000000) /** Bit 41 select mask */
N#define BIT42		((uint64_t)0x0000040000000000) /** Bit 42 select mask */
N#define BIT43		((uint64_t)0x0000080000000000) /** Bit 43 select mask */
N#define BIT44		((uint64_t)0x0000100000000000) /** Bit 44 select mask */
N#define BIT45		((uint64_t)0x0000200000000000) /** Bit 45 select mask */
N#define BIT46		((uint64_t)0x0000400000000000) /** Bit 46 select mask */
N#define BIT(X)		(1<<(X)) /** Bit X select mask */
N#ifndef _BV
N#define _BV( x )            ( 1 << (x) )
N#endif
N#define x_BV( x )           0
N
N
N#define BYTE7(X)    ((X & 0xff00000000000000) >> 56)
N#define BYTE6(X)    ((X & 0x00ff000000000000) >> 48)
N#define BYTE5(X)    ((X & 0x0000ff0000000000) >> 40)
N#define BYTE4(X)    ((X & 0x000000ff00000000) >> 32)
N#define BYTE3(X)    ((X & 0x00000000ff000000) >> 24)
N#define BYTE2(X)    ((X & 0x0000000000ff0000) >> 16)
N#define BYTE1(X)    ((X & 0x000000000000ff00) >> 8)
N#define BYTE0(X)    ((X & 0x00000000000000ff) >> 0)
N
N#define SHORT0(X)   ((X & 0x000000000000FFFF) >>  0)
N#define SHORT1(X)   ((X & 0x00000000FFFF0000) >>  16)
N#define SHORT2(X)   ((X & 0x0000FFFF00000000) >>  32)
N#define SHORT3(X)   ((X & 0xFFFF000000000000) >>  48)
N
N#define WORD0(X)    ((X & 0x00000000FFFFFFFF) >>  0)
N#define WORD1(X)    ((X & 0xFFFFFFFF00000000) >> 32)
N
N#ifndef signof
N#define signof(expr)       ((typeof(expr)) -1 < ((typeof(expr)) 0))
N#endif /* signof */
N
N#define GET_ARRAY_(x)       (sizeof(x)/sizeof(*(x)))
N#define _countof(_Array)     sizeof(_Array) / sizeof(_Array[0])
N
N#define offsetof(st, m) ((size_t)&(((st *)0)->m))
N
N#define _PSTR(x)            #x
N#define PSTR(x)             _PSTR(x)
N
Ntypedef enum  {RESET = 0, SET = 1}         	FlagStatus, ITStatus;
Ntypedef enum  {DISABLE = 0, ENABLE = 1}  	FunctionalState;
Ntypedef enum  {ERROR = 0, SUCCESS = 1}     	ErrorStatus;
Ntypedef enum  {ODD = 0, EVEN = 1}           ParityNum;
N
N
Ntypedef unsigned char BOOLEAN;
Ntypedef unsigned char UINT8;		/* 1 byte */
Ntypedef unsigned short UINT16;		/* 2 bytes */
Ntypedef unsigned int UINT32;		/* 4 bytes */
Ntypedef signed char INT8S;			/* 1 byte */
Ntypedef signed short INT16S;		/* 2 bytes */
Ntypedef signed int INT32S;			/* 4 bytes */
Ntypedef uint8_t bool_t;
N
Ntypedef unsigned char bool_t;
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 418 "..\..\Hal\system\MFTP.h" 2
N#include <stdint.h>
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 1L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
N      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 420 "..\..\Hal\system\MFTP.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 421 "..\..\Hal\system\MFTP.h" 2
N
N
N#define YES						(0==0)
N#define NO						(1==0)
N
N#define TRUE					(0==0)
N#define FALSE					(1==0)
N
N#define IS_TRUE(X)				((X) != 0)
N#define IS_FALSE(X)				((X) == 0)
N
N#define MSB_2BYTE(x)			(((x)>>8)&0xFF)
N#define LSB_2BYTE(x)			((x)&0xFF)
N
N
N
N
N#define Infinite_loop()	while(TRUE){}
N
N/* -------------------  Other User Definition ------------------ */
N
N#ifndef NULL
S#define NULL                ((void *)0)
N#endif
N
N#define MSB(x)              (((x)>>8) & 0xFF)
N#define LSB(x)              ((x) & 0xFF)
N#define MSB1(x)       (((x)>>24)&0xFF)
N#define MSB2(x)       (((x)>>16)&0xFF)
N#define LSB1(x)       (((x)>>8)&0xFF)
N#define LSB2(x)       ((x)&0xFF)
N
N#ifndef MAX
N#define MAX( x, y )         ( ( ( x ) > ( y ) ) ? ( x ) : ( y ) )
N#endif
N
N#ifndef MIN
N#define MIN( x, y )         ( ( ( x ) < ( y ) ) ? ( x ) : ( y ) )
N#endif
N
N#ifndef QUOT
N#define QUOT( x, y )        ( ( ( x ) + ( y / 2 ) ) / ( y ) )
N#endif
N
N#ifndef MOD
N#define MOD( x, y )         ( ( ( x )+( y ) )%( y ) )
N#endif
N
N#ifndef ABS
N#define ABS( x )            (( ( x ) >= 0 )? (x) : -(x))
N#endif
N
N/** @} */ /* End of group Exported_macro */
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* _MFTP_H_ */
L 38 "..\..\Env\env_def.h" 2
N#include "env_defines.h"
L 1 "..\..\Env\env_defines.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_defines.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N#ifndef _ENV_DEFINES_H_
N#define _ENV_DEFINES_H_
N
N#include "boot_info.h"
L 1 "..\..\Boot\boot_info.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : boot_info.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _BOOT_INFO_H_
N#define _BOOT_INFO_H_
N
N// USB Model  BOOT VID, PID  .
N// I2C Model  BOOT VID, PID APP   
N#define BOOT_VID 				(0x29BD)
N#define BOOT_PID				(0x5357)
N#define BOOT_VER				(0x0303)
N
N
Ntypedef struct
N{
N	uint16_t usBootVer;
N	uint16_t usBootMemSize;
N	uint16_t usBootVID;
N	uint16_t usBootPID;
N
N} tBootGenInfo_t;
N
Ntypedef struct
N{
N	uint16_t usBootVer;
N	uint16_t usBootMemSize;
N	uint16_t usBootVID;
N	uint16_t usBootPID;
N	uint32_t usCRCValue;
N
N} tBootTailInfo_t;
N
N
N#endif /* _BOOT_INFO_H_ */
L 38 "..\..\Env\env_defines.h" 2
N
N//#define _USE_APP_LGD_LIB_
N
N#if defined(USE_BOOTLOADER_8KB)
X#if 0L
S	#define	VECTOR_BASE	0x00002000
N#elif defined(USE_BOOTLOADER_16KB)
X#elif 1L
N	#define	VECTOR_BASE	0x00004000
N#else
S	#define	VECTOR_BASE	0x00000000
N#endif
N
N
N#define MODULE_DEF_L						(1)
N#define MODULE_DEF_S_1						(2)
N#define MODULE_DEF_B_1						(3)
N#define USED_ONLY_KEIL_DEBUG				(YES)
N#define USED_MODULE_DEF						(MODULE_DEF_L)
N
N#define PWMDRV_FREQUENCY_50K				(1)
N#define PWMDRV_FREQUENCY_91K				(2)
N#define PWMDRV_FREQUENCY_133K				(3)
N#define PWMDRV_FREQUENCY_150K				(4)
N#define PWMDRV_FREQUENCY_200K				(5)
N
N#define PLL_OUT_CLOCK_96MHz					(1)
N#define PLL_OUT_CLOCK_90MHz					(2)
N#define PLL_OUT_CLOCK_45MHz					(3)
N#define PLL_OUT_CLOCK_37p5MHz				(4)
N#define PLL_OUT_CLOCK_31p5MHz				(5)
N
N#define MSPI_CLOCK_DIV_2					(1)
N#define MSPI_CLOCK_DIV_3					(2)
N
N#include "env_model_L/env_model.h"
L 1 "..\..\Env\env_model_L/env_model.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  env_model.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_MODEL_H_
N#define _ENV_MODEL_H_
N
N/*
N * Library Define
N */
N#define LGD_TEST_LIBRARY_VERSION			(0x0001)
N#define USED_PEN_MODE_OPERATION				(NO)
N#define USED_INIT_PEN_MODE					(NO && USED_PEN_MODE_OPERATION)
N#define USED_POOR_PANEL_COLLINE_DISABLE     (NO)
N#define USED_130K_MAINFREQ					(NO) // if define USED_130K_MAINFREQ, USED_IDLE_MODE_CONTROL off.
N#define USED_ONLY_IDLE_MODE					(NO)
N#define USED_SW92400_OLD_SRIC_PROTOCOL		(YES)
N
N
N#define USED_MNT_USB_CUSTOM_PROTOCOL		(NO)
N
N
N#if 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S
S
S
S
S
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(0)
S
S
S
S
S
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(1)
N#elif 1
N
N// LX98405 Settting --> Must!! - ECLK Driving Strength - 1
N#define MSPI_DRIVING_STRANGTH_CSN_0			(1)
N#define MSPI_DRIVING_STRANGTH_CSN_1			(1)
N#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
N#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)//0//1
N#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
N#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)//0//1
N
N#define ECLK_DRIVING_STRENGTH_0		(1)
N#define ECLK_DRIVING_STRENGTH_1		(1)
N#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(0)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S
S
S
S
S
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(0)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(0)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S#elif 0
S#define MSPI_DRIVING_STRANGTH_CSN_0			(0)
S#define MSPI_DRIVING_STRANGTH_CSN_1			(0)
S#define MSPI_DRIVING_STRANGTH_SCLK_0		(1)
S#define MSPI_DRIVING_STRANGTH_SCLK_1		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_0		(1)
S#define MSPI_DRIVING_STRANGTH_MOSI_1		(1)
S
S#define ECLK_DRIVING_STRENGTH_0		(1)
S#define ECLK_DRIVING_STRENGTH_1		(1)
S
N#endif
N
N
N
N
N
N
N
N#define UNIQUE_VID 						(0x1FD2)
N
N#define USED_NEW_TCON_BOARD				(NO)
N#define USED_FINGER_ONLY				(YES)
N#define USED_SRIC_CHANNEL_PAD_OFF		(NO)
N#define USED_FORCE_S3_MODE_OPER			(NO)
N
N#if defined(USE_BOOTLOADER_CODE)
X#if 0L
S#define USED_GPIO_TEST_HANDSHAKE		(NO)
N#else /* USE_BOOTLOADER_CODE */
N#define USED_GPIO_TEST_HANDSHAKE		(NO)
N#endif /* USE_BOOTLOADER_CODE */
N
N#if defined(USE_BOOTLOADER_8KB)
X#if 0L
S	#define FW_SIZE			(120*1024)
N#elif defined(USE_BOOTLOADER_16KB)
X#elif 1L
N	#define FW_SIZE			(112*1024)
N	#define FW_CRC_SIZE		(108*1024)
N#else
S	#define FW_SIZE			(128*1024)
N#endif
N
N#define USED_IDLE_MODE_CONTROL						(NO)
N#define USED_IDLE_NI_SENSING_MUX_NUM				(1)
N#define USED_TSYNC2_INPUT_CONTROL					(YES)
N//#define USED_ECLK_SOURCE_TIMERCLK					(NO)
N#define USED_ECLK_ON_OFF_CONTROL					(YES)
N#define ECLK_ON_OFF_CONTROL_START_CNT_THD			(10)
N#define USED_ECLK_ON_OFF_CONTROL_DISABLE_DATAREAD	(YES & USED_ECLK_ON_OFF_CONTROL)
N#define USED_NORMAL_NI_SENSING						(NO)
N#define USED_AFE_BIAS_CURRENT_DOWN					(NO)
N#define USED_MCU_IDLE_LOW_PWR_CONTROL				(NO)
N#define USED_PLL_LOCKED_DEFENSE_CODE				(YES)
N#define USED_REFERENCE_INIT_IDLE_MODE_ENTER			(YES)
N#define USED_LAST_MUX_NODELAY						(NO)
N
N//#if (CUSTOMER == MODEL_LGD_SW97400B)
N#define INTERPOLATION_VER1_En								(NO)
N#define INTERPOLATION_VER2_En								(NO)
N#define INTERPOLATION_VER3_En								(NO)
N#define SKIP_FRAME_NUM_ON_IDLE_MODE							(1)
N#define USED_FRAME_SKIP_IDLE_MODE_CONTROL					(YES)
N#define USED_LPWG_MODE_CONTROL								(NO)//(YES)
N#define LGD_ERROR_FRAME_PROCESS_EN							(NO)
N#define USED_TPIC_MUXEN_ON_OFF_CONTROL						(YES)
N#define USED_TPIC_MUXEN_OFF_TIMING_LAST_PWM					(YES & USED_TPIC_MUXEN_ON_OFF_CONTROL)
N#define TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD				(10)
N#define USED_TPIC_MUXEN_ON_OFF_CONTROL_DISABLE_DATAREAD		(YES & USED_TPIC_MUXEN_ON_OFF_CONTROL)
N
N#define MODE_SMT
N#define REPORT_INTERPOLATION
N
N#define PWMDRV_USED_FREQUENCY						(PWMDRV_FREQUENCY_91K)
N#define PLL_OUT_CLOCK_SPEED							(PLL_OUT_CLOCK_90MHz)
N#define BIAS_ON_OFF_CTRL_INIT_FRAME_NUM				(5)
N#define USED_DUMMY_PWM_DISABLE						(NO)
N#define USED_OPERATION_STAND_ALONE					(NO)
N#define USED_OPERATION_STAND_ALONE_DISPLAY_ON		(NO)
N#define USED_AFE_SRIC_SSU_CONTROL					(NO) // <<<<<
N#define PMIC_MUXEN_CONTROL_CASE_1					(1)
N#define PMIC_MUXEN_CONTROL_CASE_2					(2)
N#define PMIC_MUXEN_CONTROL_CASE						(PMIC_MUXEN_CONTROL_CASE_1)
N
N#define USED_SHARP_SPECIFIC_PROTOCOL				(NO)
N#define USED_MOBILE_I2C_PROTOCOL					(NO)
N
N#define USED_TEST_OPERATION_ENABLE					(NO)
N
N#define USED_S3_MODE_FUNCTION						(NO && (!USED_PEN_MODE_OPERATION))
N#define USED_LPWG_MCU_SLEEP							(NO && (!USED_PEN_MODE_OPERATION))
N#define USED_S3_ALL_MUX_SHORT						(NO)
N/*
N *  define
N */
N#define USED_ONLY_BOE_TEST_EQU						(NO)
N#define USED_WINDOW_10_QE_BOE						(NO)
N#define USED_SPEED_MESURE							(NO)
N#define USED_NEW_CONFIG_PARAMETER					(YES)
N#define USED_SRIC_RTC_VAL							(YES)  // RTC : Run Time Config
N
N#define SWIP_QUEUE_MODE 				(2)
N#define SWIP_QUEUE_SIZE 				(7)
N//#define SHORT_COMPENSATION 			(1)
N#define SHORT_NUM 						(10)
N
N
N/* Define for Model Customer Dependency */
N#define MODEL_LGD_SW92400				(1)
N#define MODEL_LGD_SW97400B				(2)
N#define MODEL_LGD_LX98405				(3)
N
N#define CUSTOMER   						(MODEL_LGD_LX98405)
N
N#include "../env_model_L/customer/DEFAULT/information.h"
L 1 "..\..\Env\env_model_L/../env_model_L/customer/DEFAULT/information.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  information.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _INFORMATION_H_
N#define _INFORMATION_H_
N
N
N/********************************************************************************
N *                              Customer : DEFAULT                              *
N ********************************************************************************/
N#define CORE_VERSION				(0x0009)
N#define APP_VERSION					(0x0009)
N#define PARA_VERSION				(0x0000)
N#define I2C_ADDRESS					(0x28)		// (LG : 0x34, Lenovo : 0x20)
N#define HID_DESCRIPTOR_ADDRESS		(0x0020)	// (LG  0x0000, Lenovo  0x0020)
N#define UNIQUE_APP_PID 				(0xD101)	// (LGD 27.0" MNT)
N
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S#define I2C_X_RESOLUTION			(1920)
S#define I2C_Y_RESOLUTION			(1080)
S
N#else /* USED_MOBILE_I2C_PROTOCOL */
N#define I2C_X_RESOLUTION			(32768)
N#define I2C_Y_RESOLUTION			(32768)
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#define MODE_WDT				// WDT Mode Apply
N
N#if !defined(USE_BOOTLOADER_CODE)
X#if !0L
N//#define DC_BASE
N#if USED_FINGER_ONLY
X#if ((0==0))
N#define FINGER_ONLY
N#endif /* USED_FINGER_ONLY */
N//#define MODE_I2C
N#define ADD_TOUCH
N//#define ADD_PEN
N#endif /* USE_BOOTLOADER_CODE */
N
N#define ADD_CUSTOM
N#define USB_SELECTIVE_SUSPEND
N//#define I2C_SELECTIVE_SUSPEND
N
N#define ABNORMAL_RAWDATA_CNT_THD					(10)
N#define ABNORMAL_RAWDATA_FRAME_THD					(5)
N#define USED_ESD_RECOVERY_CODE						(NO)
N
N#define DEBOUNCE_FRAME_NUM							(10)
N#define ABNORMAL_DELTA_PLUS_THD					    (300)
N#define ABNORMAL_DELTA_PLUS_CNT_THD					(3)
N#define ABNORMAL_DELTA_MINUS_THD				    (-30)
N#define ABNORMAL_DELTA_FRAME_THD       			    (100)
N#define ABNORMAL_DELTA_THD_FOR_RECAL				(20)
N#define ABNORMAL_DELTA_CHECK_FRAME_NUM				(2)
N#define USED_RF_NOISE_RECOVERY_CODE					(NO)
N
N#define ABNORMAL_TSYNC_FALLING_TIME_CHECK		(YES)
N
N#define USED_SPLIT_MERGE_RELIABILITY 				(NO)
N#define USED_DRUM_ALGO 								(NO)
N#define VECTOR_PREDICTION_EN						(NO)
N#define FAST_SPLIT									(NO)
N#define BIG_FINGER_EDGE_EXPAND_ALGO_EN				(NO)
N#define WinCertAssistance_En						(NO)
N#define ADAPTIVE_SEEDBASE							(NO)
N#define LABEL_FAST_EN								(NO)
N#define SMOOTH_PASTORG_INTER_EN						(NO)
N#define USED_ALGORITHM_FOR_MNT						(NO)
N#define MULTI_EDGE_COEF_EN							(NO)
N#define BIG_FINGER_EDGE_ACC_TEST_ALGO_EN 			(NO)
N#define USED_DO_NOT_FINGER_TOUCH_REPORT				(NO)
N#define PEN_FINGER_1TOUCH_REPORT					(NO)
N#define FINGER_LF_VER1_EN							(NO)
N#define FINGER_LF_VER2_EN							(NO)
N#define FINGER_LF_VER4_EN							(NO)
N#define PalmCandidateTouchCut_EN					(NO)
N#define PalmDrawingOn_En							(NO)
N#define USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE		(NO)
N#define FINGER_Latency_Test_ByFW					(NO)
N#define CPI_TEST_EN									(NO)
N#define PHONE_NOISE_CNT_MAX							(5)
N#define PHONE_NOISE_RESET_CNT_MAX					(300)
N#define NORMALIZE_DELTA_EN							(YES)
N#define ID_MAPPING_CHANGE							(NO)
N#define REMOVE_EDGE_EN								(NO)
N#define FAST_LF_EN									(NO)
N#define USED_NOISE_HOPPING_FREQ						(NO)
N#define PALM_VER1_EN								(NO)
N#define FingerGlobalCoordiY_2Region_Set				(NO)
N#endif /* _INFORMATION_H_ */
L 331 "..\..\Env\env_model_L/env_model.h" 2
N
N
N#define ACCESS_MATRIX(_p, _col_, _r, _c)    (*((_p)+(_col_)*(_r)+(_c)))
N#define POW(a)                              (a)
N#define SQRT(a)								algorithm_calc_sqrt(POW(a))
N
N#define SECTION_NAME_LEN_               	(8)
N#define CUSTOM_INFO_                    	(10)
N#define CUSTOM_PATH_NAME_LEN_           	(32)
N#define PUBLIC_PATH_NAME_LEN_           	(32)
N
N#define MAX_TOUCH_                      	(10)
N#define MAX_KEY_                        	(4)
N#define PAD_                            	(1)
N
N#define ROW_MAX								(48)
N#define COL_MAX								(96)
N//#define NI_FRAME_NUM						(2)
N#define NI_ROW_MAX							(USED_IDLE_NI_SENSING_MUX_NUM*4) // (12)
N
N#define PEN_COORD_ROW_MAX					(5)//(8)
N#define PEN_COORD_COL_MAX					(80)//(84)
N#define PEN_DATA_ROW_MAX					(PEN_COORD_ROW_MAX*4)
N
N#define MUX_RANGE_SIZE	    				(2)
N#define MAX_MUX_SIZE						(10)//(8)
N#define MAX_MUX_HALF						(MAX_MUX_SIZE>>1)
N#define MUX_MAX_ROW							(((ROW_MAX - MAX_MUX_SIZE + 1)>>1)<<1)
N
N
N/***************************************************************************************************************************************
N * platform_env.h
N ***************************************************************************************************************************************/
N#define _DV_SAMPLE_
N
N#define SPI_DMY_LEN     				(2)  // ADDR + CMD LX98405
N#define SRIC_PROTOCOL_RESET_COUNT   	(7)
N#define READ_ALIGNED_BUF    			(0x0800) // 0800
N
N#define R0_ALIGNED_COL_LEN  			(12)
N#define R0_ALIGNED_ROW_LEN  			(5)
N#define R0_COL_LEN          			(6)
N#define R1_COL_LEN          			(6)
N#define R0_ROW_LEN          			(5)
N#define R1_ROW_LEN          			(5)
N#define SM_COL_LEN          			(12)
N
N#define MSPI_NUM                		(4)
N#define SRIC_NUM                		(4)
N
N#define SM_NUM                  		(1)
N
N#define FINGER_MUX_NUM              	(10)
N#define FINGER_SENSING_MUX_NUM_1LHB		(9)
N#define FINGER_NI_MUX_NUM           	(3)
N#define FINGER_IDLE_NI_MUX_NUM          (USED_IDLE_NI_SENSING_MUX_NUM)
N#define FINGER_FULLFRAME_TSYNC_NUM		(FINGER_MUX_NUM / FINGER_MUX_NUM_1LHB)
N#if USED_NORMAL_NI_SENSING
X#if ((1==0))
S#define FINGER_FULL_FRAME_MUX_NUM		(FINGER_MUX_NUM + FINGER_NI_MUX_NUM)
N#else /* USED_NORMAL_NI_SENSING */
N#define FINGER_FULL_FRAME_MUX_NUM		(FINGER_MUX_NUM)
N#endif /* USED_NORMAL_NI_SENSING */
N#define MSPI_ROW_MAX_MUX				(10)//(16)
N
N#define FINGERPEN_MUX_NUM           	(4)
N
N// choigs
N#define SZ_MSPIBUF_REGISTER     			(SPI_DMY_LEN + 2)  // LX98405
N//#define SZ_MSPIBUF_MUXDATA      			(SPI_DMY_LEN + ((R0_ALIGNED_COL_LEN * R0_ROW_LEN)*2))
N#define SZ_MSPIBUF_MUXDATA      			(SPI_DMY_LEN + (R0_ALIGNED_COL_LEN * R0_ROW_LEN)*2)
N
N#define SZ_MSPIBUF_FINGER_FULL_FRAME    	(SZ_MSPIBUF_MUXDATA * FINGER_FULL_FRAME_MUX_NUM)
N#define SZ_MSPIBUF_FINGER_IDLE_FULL_FRAME   (SZ_MSPIBUF_MUXDATA * FINGER_IDLE_NI_MUX_NUM)
N#define SZ_MSPIBUF_FINGERPEN_FRAME      	(SZ_MSPIBUF_MUXDATA * FINGERPEN_MUX_NUM)
N
N#define PIN_MSPI_SSN_0					(PIN_GPA00)
N#define PIN_MSPI_SCLK_0					(PIN_GPA01)
N#define PIN_MSPI_MOSI_0					(PIN_GPA02)
N#define PIN_MSPI_MISO_0					(PIN_GPA03)
N#define PIN_MSPI_SSN_1					(PIN_GPA04)
N#define PIN_MSPI_SCLK_1					(PIN_GPA05)
N#define PIN_MSPI_MOSI_1					(PIN_GPA06)
N#define PIN_MSPI_MISO_1					(PIN_GPA07)
N#define PIN_MSPI_SSN_2					(PIN_GPA08)
N#define PIN_MSPI_SCLK_2					(PIN_GPA09)
N#define PIN_MSPI_MOSI_2					(PIN_GPA10)
N#define PIN_MSPI_MISO_2					(PIN_GPA11)
N#define PIN_MSPI_SSN_3					(PIN_GPA12)
N#define PIN_MSPI_SCLK_3					(PIN_GPA13)
N#define PIN_MSPI_MOSI_3					(PIN_GPA14)
N#define PIN_MSPI_MISO_3					(PIN_GPA15)
N#define PIN_MSPI_SSN_4					(PIN_GPA16)
N#define PIN_MSPI_SCLK_4					(PIN_GPA17)
N#define PIN_MSPI_MOSI_4					(PIN_GPA18)
N#define PIN_MSPI_MISO_4					(PIN_GPA19)
N#define PIN_MSPI_SSN_5					(PIN_GPA20)
N#define PIN_MSPI_SCLK_5					(PIN_GPA21)
N#define PIN_MSPI_MOSI_5					(PIN_GPA22)
N#define PIN_MSPI_MISO_5					(PIN_GPA23)
N
N
N#define VSYNC_HIGH             			(GPIO->tGPIO_DATA_0.tBit.GPA26)
N#define TSYNC_HIGH             			(GPIO->tGPIO_DATA_0.tBit.GPA27)
N
N
N#endif /* _ENV_MODEL_H_ */
L 72 "..\..\Env\env_defines.h" 2
N
N#define USED_MUX_SENSING_REVERSE		(NO)
N
N#if USED_SPEED_MESURE
X#if ((1==0))
S#define USED_SPEED_MESURE_TOUCHNUM			(10)
N#endif /* USED_SPEED_MESURE */
N
N
N#if (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz)
X#if (((2)) == (1))
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_3) // 16M
N#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_90MHz)
X#elif (((2)) == (2))
N#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_3) // 15M
N#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_45MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_2) // 11.3M
S#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_37p5MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_2) // 9.4M
S#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_31p5MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_2) // 7.9M
S#else /* (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz) */
S#define PLL_OUT_CLOCK_SPEED					(PLL_OUT_CLOCK_90MHz)
S#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_3) // 15M
N#endif /* (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz) */
N
N
N#if USED_OPERATION_STAND_ALONE
X#if ((1==0))
S#define USED_ONE_VSYNC_ONE_FRAME			(YES)
S
S#define USED_NOT_USE_ALL_AFE_OFF			(NO)
S#define USED_LPWG_CROSS_AFE_OFF				(NO)
S#define USED_LREDGE_AFE_OFF					(NO)
S#define USED_PLL_OUT_CLK_CONFIG				(YES)
S#define VSYNC_ONE_FRAME_RATE_HZ				(20)
S#define VSYNC_ONE_FRAME_TIME_usec			(1000000/VSYNC_ONE_FRAME_RATE_HZ)
S#define TSYNC_ONE_FRAME_RATE_HZ				(70)//(80)
S#define TSYNC_ONE_FRAME_TIME_usec			(1000000/TSYNC_ONE_FRAME_RATE_HZ)
S#define TSYNC_LHB_NUM						(16)
S#define TSYNC_PRIOD							(TSYNC_ONE_FRAME_TIME_usec/TSYNC_LHB_NUM)
N#else /* USED_OPERATION_STAND_ALONE */
N#define USED_ONE_VSYNC_ONE_FRAME			(NO)
N#define USED_NOT_USE_ALL_AFE_OFF			(NO)
N#define USED_LPWG_CROSS_AFE_OFF				(NO)
N#define USED_PLL_OUT_CLK_CONFIG				(NO)
N#endif /* USED_OPERATION_STAND_ALONE */
N
N#define USED_SRIC_REG_MSPI_CHECK			(NO)
N
N
N#define DEFAULT_X_RESOLUTION				(32768)
N#define DEFAULT_Y_RESOLUTION				(32768)
N
N/***************************************************************************************************************************************
N * typedef enum
N ***************************************************************************************************************************************/
Ntypedef enum
N{
N	PCS_NONE,
N    PCS_ACTIVE,
N    PCS_IDLE,
N    PCS_LIMIT,
N} __PACKED ePowerConsumptionState_t;
X} __attribute__ ((packed)) ePowerConsumptionState_t;
N
Ntypedef enum
N{
N    OM_NORMAL,
N    OM_NOISE,
N    OM_DIAG,
N    OM_LIMIT
N} __PACKED eOperMode_t; //TODO:  !
X} __attribute__ ((packed)) eOperMode_t; 
N
Ntypedef enum
N{
N	FULL_MODE = 0,
N	LOCAL_MODE,					// 1
N	LOCAL_FINGER_MODE,			// 2
N	LOCAL_HOVER_MODE,			// 3
N	LOCAL_SEARCH_MODE,			// 4
N} __PACKED eSensingMode_t;
X} __attribute__ ((packed)) eSensingMode_t;
N
Ntypedef enum
N{
N	PEN_COORD_INIT = 1,			// 1
N	PEN_LINE_FILTER,			// 2
N	PEN_LABELING,				// 3
N	DSP_MARKBOUNDARY1,			// 4
N	DSP_MARKBOUNDARY2,			// 5
N	PEN_LABEL_EDGE_EXPAND,		// 6
N	PEN_COORDINATE,				// 7
N	PEN_SMOOTHING,				// 8
N	PEN_POST_PROCESS,			// 9
N	PEN_UPDATE_POST_INFO,		// 10
N} __PACKED eDSPBMode_t;
X} __attribute__ ((packed)) eDSPBMode_t;
N
N/***************************************************************************************************************************************
N * typedef structure
N ***************************************************************************************************************************************/
N//typedef struct
N//{
N//    int iRow_;
N//    int iCol_;
N//    int iRamCol_;
N//    int iScreenNode_;
N//    int iKey_;
N//    int iMaxTouch_;
N//    bool_t bSwapXY;
N//    bool_t bFlipX;
N//
N//} tMemConf_t;
N
N/***************************************************************************************************************************************
N * Variables
N ***************************************************************************************************************************************/
N//extern tMemConf_t *ptMemConf;
N//extern tMemConf_t* ptMemLocalConf;
Nextern volatile uint8_t* pucBuf;
N
N
N
N#define waitTsyncHigh()							while(TSYNC_HIGH == 0)
N#define waitTsyncLow()							while(TSYNC_HIGH != 0)
N#define waitTsyncRising() \
N	do{ \
N		waitTsyncLow(); \
N		waitTsyncHigh(); \
N	}while(0)
X#define waitTsyncRising() 	do{ 		waitTsyncLow(); 		waitTsyncHigh(); 	}while(0)
N
N#define waitTsyncFalling() \
N	do{ \
N		waitTsyncHigh(); \
N		waitTsyncLow(); \
N	}while(0)
X#define waitTsyncFalling() 	do{ 		waitTsyncHigh(); 		waitTsyncLow(); 	}while(0)
N
N#define waitVsyncHigh()							while(VSYNC_HIGH == 0)
N#define waitVsyncLow()							while(VSYNC_HIGH != 0)
N#define waitVsyncRising() \
N	do{ \
N		waitVsyncLow(); \
N		waitVsyncHigh(); \
N	}while(0)
X#define waitVsyncRising() 	do{ 		waitVsyncLow(); 		waitVsyncHigh(); 	}while(0)
N
N#define waitVsyncFalling() \
N	do { \
N		waitVsyncHigh(); \
N		waitVsyncLow(); \
N	}while(0)
X#define waitVsyncFalling() 	do { 		waitVsyncHigh(); 		waitVsyncLow(); 	}while(0)
N
N#if USED_SW92400_OLD_SRIC_PROTOCOL
X#if ((0==0))
N//typedef struct
N//{
N//    uint16_t Addr       ;
N//    uint16_t reserved0  ;
N//
N//    union
N//    {
N//        struct
N//        {
N//            uint16_t reserved1  : 14;
N//            uint16_t nBulk      : 1;
N//            uint16_t nWrite     : 1;
N//        } tBit;
N//        uint16_t Command;
N//    };
N//    uint16_t reserved2 ;
N//
N//    uint16_t Data;
N//    uint16_t reserved3;
N//} MSPI_RegWriteBuf_TypeDef;
N
N// // LX98405 New - Choigs
Ntypedef struct
N{
N    uint16_t Addr       ;
N    uint16_t reserved0  ;
N
N    union
N    {
N        struct
N        {
N            uint16_t Dummy : 3;
N            uint16_t Burst_Len : 7;
N            uint16_t ReadFormat : 2;
N            uint16_t reserved1 : 1;
N            uint16_t DualRxEn : 1;
N            uint16_t ChkSum : 1;
N            uint16_t RW : 1;
N        } tBit;
N        uint16_t Command;
N    };
N    uint16_t reserved2 ;
N
N    uint16_t Data_M;
N    uint16_t reserved3 ;
N		
N    uint16_t Data_L;
N    uint16_t reserved4 ;
N		
N} MSPI_RegWriteBuf_TypeDef;
N
N// // LX98405 New - Choigs
Ntypedef struct
N{
N	uint16_t Data1;
N	uint16_t reserved0  ;
N	uint16_t Data2;
N	uint16_t reserved1  ;
N} MSPI_RegReadBuf_TypeDef;
N
N
N
N//typedef struct
N//{
N//    union
N//    {
N//        uint16_t Addr       ;
N//        uint16_t Readback   ;
N//    };
N//    uint16_t reserved0  ;
N//
N//    uint16_t reserved1  : 14;
N//    uint16_t nBulk      : 1;
N//    uint16_t nWrite     : 1;
N//    uint16_t reserved2 ;
N//
N//    uint32_t Data[32];
N//}MSPI_SensingBuf_TypeDef;
N
N//typedef struct
N//{
N//    uint16_t Addr       ;
N//    uint16_t reserved0  ;
N//
N//    union{
N//        struct
N//        {
N//            uint16_t reserved1  : 14;
N//            uint16_t nBulk      : 1;
N//            uint16_t nWrite     : 1;
N//        } tBit;
N//        uint16_t Command;
N//    };
N//    uint16_t reserved2 ;
N//
N//    uint16_t Data[SZ_MSPIBUF_MUXDATA*2];
N//}MSPI_ReadCommand_TypeDef;
N
N// // LX98405 New - Choigs
Ntypedef struct
N{
N    uint16_t Addr       ;
N    uint16_t reserved0  ;
N
N    union{
N        struct
N        {
N				
N            uint16_t Dummy : 3;
N            uint16_t Burst_Len : 7;
N            uint16_t ReadFormat : 2;
N            uint16_t Reserve : 1;
N            uint16_t DualRxEn : 1;
N            uint16_t ChkSum : 1;
N            uint16_t RW : 1;
N
N        } tBit;
N        uint16_t Command;
N    };
N    uint16_t reserved2 ;
N
N    uint16_t Data[SZ_MSPIBUF_MUXDATA*2];
X    uint16_t Data[((2) + ((12) * (5))*2)*2];
N}MSPI_ReadCommand_TypeDef;
N
N
Ntypedef struct _MSPI_RAWDATA_
N{
N    uint16_t Dummy[2];
N    uint16_t Data[SM_NUM][R0_ALIGNED_ROW_LEN][SM_COL_LEN*2];
X    uint16_t Data[(1)][(5)][(12)*2];
N}MSPI_Rawdata_Typedef;
N
Ntypedef struct MSPI_Buffer
N{
N	MSPI_RegWriteBuf_TypeDef SricRegWriteBuffer[MSPI_NUM];
X	MSPI_RegWriteBuf_TypeDef SricRegWriteBuffer[(4)];
N	MSPI_RegReadBuf_TypeDef SricRegReadBuffer[MSPI_NUM];
X	MSPI_RegReadBuf_TypeDef SricRegReadBuffer[(4)];
N    uint32_t ulDummy[512];
N    MSPI_ReadCommand_TypeDef ReadCommand[MSPI_NUM];
X    MSPI_ReadCommand_TypeDef ReadCommand[(4)];
N    MSPI_Rawdata_Typedef Rawdata[MSPI_NUM][MSPI_ROW_MAX_MUX];
X    MSPI_Rawdata_Typedef Rawdata[(4)][(10)];
N    MSPI_Rawdata_Typedef PenRawdata[MSPI_NUM][FINGERPEN_MUX_NUM];
X    MSPI_Rawdata_Typedef PenRawdata[(4)][(4)];
N}MSPI_Buffer_TypeDef;
N
N
N
N#else /* USED_SW92400_OLD_SRIC_PROTOCOL */
Stypedef struct _MSPI_RegisterBuf
S{
S    uint16_t Addr       ;
S    uint16_t reserved0  ;
S
S    union
S    {
S        struct
S        {
S            uint16_t reserved1  : 14;
S            uint16_t nBulk      : 1;
S            uint16_t nWrite     : 1;
S        } bulkwrite_b;
S        uint16_t Command;
S    };
S    uint16_t reserved2 ;
S
S    uint16_t Data;
S    uint16_t reserved3;
S} MSPI_RegisterBuf_TypeDef;
S
S
Stypedef struct _MSPI_SensingBuf
S{
S    union
S    {
S        uint16_t Addr       ;
S        uint16_t Readback   ;
S    };
S    uint16_t reserved0  ;
S
S    uint16_t reserved1  : 14;
S    uint16_t nBulk      : 1;
S    uint16_t nWrite     : 1;
S    uint16_t reserved2 ;
S
S    uint32_t Data[32];
S}MSPI_SensingBuf_TypeDef;
S
Stypedef struct _ReadCommand_Buf_
S{
S    uint16_t Addr       ;
S    uint16_t reserved0  ;
S
S    union{
S        struct
S        {
S            uint16_t reserved1  : 14;
S            uint16_t nBulk      : 1;
S            uint16_t nWrite     : 1;
S        } bulkwrite_b;
S        uint16_t Command;
S    };
S    uint16_t reserved2 ;
S
S    uint16_t Data[SZ_MSPIBUF_MUXDATA*2];
S}MSPI_ReadCommand_TypeDef;
S
Stypedef struct _MSPI_RAWDATA_
S{
S    uint32_t Dummy;
S    uint16_t Data[SM_NUM][R0_ALIGNED_ROW_LEN][SM_COL_LEN*2];
S}MSPI_Rawdata_Typedef;
S
Stypedef struct MSPI_Buffer
S{
S    MSPI_RegisterBuf_TypeDef SricBuffer[2][MSPI_NUM];
S    MSPI_SensingBuf_TypeDef DataBuffer[2][MSPI_NUM];
S    MSPI_ReadCommand_TypeDef ReadCommand[MSPI_NUM];
S    MSPI_Rawdata_Typedef Rawdata[MSPI_NUM][MSPI_ROW_MAX_MUX];
S    MSPI_Rawdata_Typedef PenRawdata[MSPI_NUM][FINGERPEN_MUX_NUM];
S}MSPI_Buffer_TypeDef;
N#endif /* USED_SW92400_OLD_SRIC_PROTOCOL */
N
N
Ntypedef enum {
N	_FREQ_UNKNOWN_ = 0,
N	_FREQ_91k_ = 1,
N	_FREQ_110k_ = 2,
N	_FREQ_130k_ = 3,
N	_FREQ_133k_ = 4,
N	_FREQ_174k_ = 5,
N	_FREQ_182k_ = 6,
N	_FREQ_190k_ = 7,
N	_FREQ_200k_ = 8
N} eSENSING_FREQ_t;
N
Nextern volatile MSPI_Buffer_TypeDef*  SBuf;
N#define FRAME_MEMORY		((volatile void								*)BASE_MSPI_SRAM    )
N#define MSPI_BUF			((volatile MSPI_Buffer_TypeDef              *)BASE_MSPI_SRAM    )
N
N#define __inline__
N
N#endif /* _ENV_DEFINES_H_ */
L 39 "..\..\Env\env_def.h" 2
N#include "env_types.h"
L 1 "..\..\Env\env_types.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_types.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N#ifndef _ENV_TYPES_H_
N#define _ENV_TYPES_H_
N
Ntypedef union
N{
N    uint8_t STRING[8];
N    uint16_t HALFWORD[4];
N    uint32_t WORD[2];
N    uint64_t LONG;
N} u8byteString_t;
N
Ntypedef union
N{
N    uint32_t WORD;
N    uint16_t HALFWORD[2];
N    uint8_t BYTE[4];
N} uTypes32_t;
N
Ntypedef union
N{
N    uint64_t LONG;
N    uint32_t WORD[2];
N    uint16_t HALFWORD[4];
N    uint8_t BYTE[8];
N} uTypes64_t;
N
Ntypedef struct
N{
N    int8_t rs;
N    int8_t re;
N    int8_t cs;
N    int8_t ce;
N} __PACKED tRect_t;
X} __attribute__ ((packed)) tRect_t;
N
Ntypedef struct
N{
N    int8_t c;
N    int8_t r;
N} __PACKED tCell_t;
X} __attribute__ ((packed)) tCell_t;
N
Ntypedef struct
N{
N    uint8_t b7Size      : 7;
N    uint8_t b1Sign      : 1;
N} __PACKED tSignedByteDataType_t;
X} __attribute__ ((packed)) tSignedByteDataType_t;
N
N#define datatypeof(expr)    \
N        { .b7Size = sizeof(expr), .b1Sign = 1 }
X#define datatypeof(expr)            { .b7Size = sizeof(expr), .b1Sign = 1 }
N
N
N#endif /* _ENV_TYPES_H_ */
L 40 "..\..\Env\env_def.h" 2
N#include "env_section_defines.h"
L 1 "..\..\Env\env_section_defines.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : env_section_defines.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _ENV_SECTION_DEFINES_H_
N#define _ENV_SECTION_DEFINES_H_
N
N
N/*******************************************************************************
N * Allocate Functions and Variables in specific Section
N *******************************************************************************/
N/*-----------------------------------------------------------------------------*
N *                            Bootloader Used                                  *
N ------------------------------------------------------------------------------*/
N#define __BOOT						__attribute__((section("BOOT")))
N
N///*
N// * Application   Function  Address      .
N// */
N//#define APP_Fncp_APP_APP_RESET		((void *)0x00003079)
N//#define APP_Fncp_APP_APP_PENDSV_IRQ ((void *)0x000030b9)
N//#define APP_Fncp_APP_SYSTICK_IRQ	((void *)0x000030c9)
N//#define APP_Fncp_APP_I2C_IRQ		((void *)0x000030d9)
N//#define APP_Fncp_APP_WDT_IRQ		((void *)0x000030e9)
N//#define APP_Fncp_APP_EXTI0_IRQ		((void *)0x000030f9)
N//#define APP_Fncp_APP_EXIT1_IRQ		((void *)0x00003109)
N//#define APP_Fncp_APP_TIMER_IRQ		((void *)0x00003119)
N//#define APP_Fncp_APP_TSPI_IRQ		((void *)0x00003129)
N//#define APP_Fncp_APP_USB_IRQ		((void *)0x00003139)
N//#define APP_Fncp_APP_PWMDRV_IRQ		((void *)0x00003149)
N//#define APP_Fncp_APP_MSPI_IRQ		((void *)0x00003159)
N//#define APP_Fncp_APP_GPDMA_IRQ		((void *)0x00003169)
N//#define APP_Fncp_APP_DSP_A_IRQ		((void *)0x00003179)
N//#define APP_Fncp_APP_DSP_B_IRQ		((void *)0x00003189)
N//#define APP_Fncp_APP_PLL_IRQ		((void *)0x00003199)
N//#define APP_Fncp_APP_FLITF_IRQ		((void *)0x000031a9)
N
N/*-----------------------------------------------------------------------------*
N *                            Application Used                                 *
N ------------------------------------------------------------------------------*/
N#define __APP						__attribute__((section("APP")))
N
N
N/*-----------------------------------------------------------------------------*
N *                            Common Used                                      *
N ------------------------------------------------------------------------------*/
N#define __DATA_HEAD					__attribute__((section(".data_head")))
N
N
N#endif /* _ENV_SECTION_DEFINES_H_ */
L 41 "..\..\Env\env_def.h" 2
N
N
N#endif /* _ENV_DEF_H_ */
L 38 "..\..\Hal\hal_def.h" 2
N
N#include "Hal_types.h"
L 1 "..\..\Hal\Hal_types.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : hal_types.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _HAL_TYPES_H_
N#define _HAL_TYPES_H_
N
N
Ntypedef enum
N{
N	/*
N	 * Sub Sensing Mode
N	 */
N	SM_CHECK_ACTIVE = 0x1,
N	SM_CHECK_ACTIVE_FRQ_MAIN = 0x2, // Main Frequency
N	SM_CHECK_ACTIVE_FRQ_HOP1 = 0x4, // Hopping 1 Frequency
N	SM_CHECK_ACTIVE_FRQ_HOP2 = 0x8, // Hopping 2 Frequency
N	SM_CHECK_IDLE = 0x100,
N#if USED_LPWG_MODE_CONTROL
X#if ((1==0))
S	SM_CHECK_LPWG = 0x200,
N#endif /* USED_LPWG_MODE_CONTROL */
N	/*
N	 * Main Sensing Mode
N	 */
N	SM_CHECK_S3_MODE = 0x800,
N	SM_S3_ACTIVE_MODE = (SM_CHECK_ACTIVE | SM_CHECK_S3_MODE),
N	SM_S3_IDLE_MODE = (SM_CHECK_IDLE | SM_CHECK_S3_MODE),
N
N	SM_CHECK_FINGER_ONLY_MODE = 0x1000,
N	SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE = (SM_CHECK_ACTIVE | SM_CHECK_ACTIVE_FRQ_MAIN | SM_CHECK_FINGER_ONLY_MODE),
N	SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE = (SM_CHECK_ACTIVE | SM_CHECK_ACTIVE_FRQ_HOP1 | SM_CHECK_FINGER_ONLY_MODE),
N	SM_FINGER_ONLY_ACTIVE_FRQ_HOP2_MODE = (SM_CHECK_ACTIVE | SM_CHECK_ACTIVE_FRQ_HOP2 | SM_CHECK_FINGER_ONLY_MODE),
N	SM_FINGER_ONLY_IDLE_MODE = (SM_CHECK_IDLE | SM_CHECK_FINGER_ONLY_MODE),
N#if USED_LPWG_MODE_CONTROL
X#if ((1==0))
S	SM_FINGER_ONLY_LPWG_MODE = (SM_CHECK_LPWG | SM_CHECK_FINGER_ONLY_MODE),
N#endif /* USED_LPWG_MODE_CONTROL */
N
N	SM_CHECK_FINGER_PEN_SEARCH_MODE = 0x2000,
N	SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE = (SM_CHECK_ACTIVE | SM_CHECK_ACTIVE_FRQ_MAIN | SM_CHECK_FINGER_PEN_SEARCH_MODE),
N	SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP1_MODE = (SM_CHECK_ACTIVE | SM_CHECK_ACTIVE_FRQ_HOP1 | SM_CHECK_FINGER_PEN_SEARCH_MODE),
N	SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_HOP2_MODE = (SM_CHECK_ACTIVE | SM_CHECK_ACTIVE_FRQ_HOP2 | SM_CHECK_FINGER_PEN_SEARCH_MODE),
N	SM_FINGER_PEN_SEARCH_IDLE_MODE = (SM_CHECK_IDLE | SM_CHECK_FINGER_PEN_SEARCH_MODE),
N
N	SM_CHECK_FINGER_PEN_MODE = 0x4000,
N	SM_CHECK_FINGER_PEN_HOVER_MODE = 0x8000,
N	SM_FINGER_PEN_ACTIVE_MODE = (SM_CHECK_ACTIVE | SM_CHECK_FINGER_PEN_MODE),
N	SM_FINGER_PEN_IDLE_MODE = (SM_CHECK_IDLE | SM_CHECK_FINGER_PEN_MODE),
N	SM_FINGER_PEN_HOVER_ACTIVE_MODE = (SM_CHECK_ACTIVE | SM_CHECK_FINGER_PEN_MODE | SM_CHECK_FINGER_PEN_HOVER_MODE),
N	SM_FINGER_PEN_HOVER_IDLE_MODE = (SM_CHECK_IDLE | SM_CHECK_FINGER_PEN_MODE | SM_CHECK_FINGER_PEN_HOVER_MODE),
N
N	SM_SENSING_MODE_LIMIT = 0xFFFF
N
N} eSENSING_MODE_t;
N
Ntypedef enum
N{
N	SM_CHANGE_COMPLETE,
N	SM_CHANGE_IDLE_MODE,
N#if USED_LPWG_MODE_CONTROL
X#if ((1==0))
S	SM_CHANGE_LPWG_MODE,
N#endif /* USED_LPWG_MODE_CONTROL */
N	SM_CHANGE_ACTIVE_FRQ_MAIN_MODE,
N	SM_CHANGE_ACTIVE_FRQ_HOP1_MODE,
N	SM_CHANGE_ACTIVE_FRQ_HOP2_MODE,
N//	SM_CHANGE_ACTIVE_MODE,
N//	SM_CHANGE_S3_MODE,
N	SM_CHANGE_FINGER_ONLY_MODE,
N	SM_CHANGE_FINGER_PEN_SEARCH_MODE,
N	SM_CHANGE_FINGER_PEN_MODE,
N
N	SM_CHANGE_SENSING_MODE_LIMIT = 0xFF
N
N} eSENSING_CHANGE_MODE_t;
N
N#define IS_S3_MODE(m)						(m & SM_CHECK_S3_MODE)					/* All Mode */
N#define IS_FINGER_ONLY_MODE(m)				(m & SM_CHECK_FINGER_ONLY_MODE)			/* All Mode */
N#define IS_FINGER_PEN_SEARCH_MODE(m)		(m & SM_CHECK_FINGER_PEN_SEARCH_MODE)	/* All Mode */
N#define IS_FINGER_PEN_MODE(m)				(m & SM_CHECK_FINGER_PEN_MODE)			/* Partial Mode */
N#define IS_FINGER_PEN_MODE_HOVER(m)			(m & SM_CHECK_FINGER_PEN_HOVER_MODE)	/* Partial Mode */
N
N#define IS_ACTIVE_MODE(m)					(m & SM_CHECK_ACTIVE)
N#define IS_ACTIVE_MODE_FRQ_MAIN(m)			(m & SM_CHECK_ACTIVE_FRQ_MAIN)
N#define IS_ACTIVE_MODE_FRQ_HOP1(m)			(m & SM_CHECK_ACTIVE_FRQ_HOP1)
N#define IS_ACTIVE_MODE_FRQ_HOP2(m)			(m & SM_CHECK_ACTIVE_FRQ_HOP2)
N#define IS_IDLE_MODE(m)						(m & SM_CHECK_IDLE)
N#if USED_LPWG_MODE_CONTROL
X#if ((1==0))
S#define IS_LPWG_MODE(m)						(m & SM_CHECK_LPWG)
N#endif /* USED_LPWG_MODE_CONTROL */
N
Ntypedef enum
N{
N	MSPI_OP_MODE_EVERY_MUX,
N	MSPI_OP_MODE_EVERY_FRAME,
N
N} eMSPIOperationMode_t;
N
Ntypedef enum
N{
N	BASELINE_TYPE_FULL,
N	BASELINE_TYPE_NI
N
N} eBaseImageType_t;
N
Ntypedef enum
N{
N	NORMAL_OPER = 0,
N	IDLE_READY,
N	IDLE_OPER,
N	IDLE_END
N
N} eIdleState_t;
N
Ntypedef struct
N{
N	/*
N	 * MSPI
N	 */
N	__IO uint32_t ulMSPIIntrCnt;
X	volatile uint32_t ulMSPIIntrCnt;
N	__IO uint32_t ulMSPIDone;
X	volatile uint32_t ulMSPIDone;
N
N	/*
N	 * PWM
N	 */
N	__IO uint32_t ulVSyncFlag;
X	volatile uint32_t ulVSyncFlag;
N	__IO uint32_t ulTSyncInBothEdgeCnt;
X	volatile uint32_t ulTSyncInBothEdgeCnt;
N	__IO uint32_t ulTSyncInFallingCnt;
X	volatile uint32_t ulTSyncInFallingCnt;
N	__IO uint32_t ulTSyncInRisingCnt;
X	volatile uint32_t ulTSyncInRisingCnt;
N
N	/*
N	 * Timer
N	 */
N
N	/*
N	 * GPIO
N	 */
N
N	/*
N	 * Frame
N	 */
N	__IO uint32_t ulInitFirstFrame;
X	volatile uint32_t ulInitFirstFrame;
N	__IO uint32_t ulFrameCnt;
X	volatile uint32_t ulFrameCnt;
N	__IO uint32_t ulErrorFrame;
X	volatile uint32_t ulErrorFrame;
N
N} tHalInterruptHandle_t;
N
N
N
N
N#endif /* _HAL_TYPES_H_ */
L 40 "..\..\Hal\hal_def.h" 2
N#include "module_types.h" // 
L 1 "..\..\Module\module_types.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : module_types.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MODULE_TYPES_H_
N#define _MODULE_TYPES_H_
N
N
Ntypedef enum
N{
N	IRQ_ID_PWMDRV = 0,
N	IRQ_ID_FULL_SAMPLE,
N	IRQ_ID_FULL_SAMPLE_NI,
N	IRQ_ID_LOCAL_SAMPLE,
N	IRQ_ID_TIMER_0,
N	IRQ_ID_TIMER_123,
N	IRQ_ID_HWACC,
N	IRQ_ID_FLITF,
N	IRQ_ID_MAX
N} eIrqId_t;
N
Ntypedef enum
N{
N	PARTIAL_PEN_BEACON = 0,
N	PARTIAL_PEN_COORD1,
N	PARTIAL_PEN_COORD2,
N	PARTIAL_PEN_COORD3,
N	PARTIAL_PEN_COORD4,
N	PARTIAL_PEN_DATA1,
N	PARTIAL_PEN_DATA2,
N	PARTIAL_PEN_DATA3,
N	PARTIAL_PEN_DATA4,
N	PARTIAL_PEN_DATA5,
N	PARTIAL_FINGER1,
N	PARTIAL_FINGER2,
N	PARTIAL_FINGER3,
N	PARTIAL_FINGER4,
N	PARTIAL_FINGER5,
N	PARTIAL_FINGER6,
N	PARTIAL_MAX,
N} ePartialSensing_t;
N
N#endif /* _MODULE_TYPES_H_ */
L 41 "..\..\Hal\hal_def.h" 2
N#include "hal_fnc.h"
L 1 "..\..\Hal\hal_fnc.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : hal_fnc.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _HAL_FNC_H_
N#define _HAL_FNC_H_
N
N
Nextern void (*Fncp_PendSV_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_PendSV_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_Systick_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_Systick_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_I2C_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_I2C_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_WDT_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_WDT_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_EXTI0_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_EXTI0_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_EXTI1_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_EXTI1_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_TIMER_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_TIMER_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_TSPI_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_TSPI_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_USB_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_USB_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_PWMDRV_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_PWMDRV_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_MSPI_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_MSPI_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_GPDMA_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_GPDMA_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_DSP_A_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_DSP_A_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_DSP_B_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_DSP_B_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_PLL_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_PLL_IRQHandler)(void) __attribute__((section(".data_head")));
Nextern void (*Fncp_FLITF_IRQHandler)(void) __DATA_HEAD;
Xextern void (*Fncp_FLITF_IRQHandler)(void) __attribute__((section(".data_head")));
N
N
N#endif /* _HAL_FNC_H_ */
L 42 "..\..\Hal\hal_def.h" 2
N
N#include "dma.h"
L 1 "..\..\Hal\dma\dma.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : dma.h
N * version : 0.1
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _DMA_H_
N#define _DMA_H_
N
N
N#define MAX_DMA_CHANNELS			1
N#define DMA_BASE				    ((uint32_t)BASE_GPDMA)
N#define DMA_Channel0_BASE		(DMA_BASE + 0x0000)
N
N#define DMA_Global_BASE		  (DMA_BASE + 0x02C0)
N#define DMA_Channel0			  ((DMA_Channel_TypeDef*)DMA_Channel0_BASE)
N#define DMA_Global				  ((DMA_GLOBAL_TypeDef*)DMA_Global_BASE)
N
N
N
N//CTLx
N#define  DMA_INTERRUPT_Enable                    ((uint64_t)0x0000000000000001)
N#define  DMA_DestinationTransferWidth_8bit       ((uint8_t)0x0)
N#define  DMA_DestinationTransferWidth_16bit      ((uint8_t)0x1)
N#define  DMA_DestinationTransferWidth_32bit      ((uint8_t)0x2)
N#define  DMA_DestinationTransferWidth_64bit      ((uint8_t)0x3)
N#define  DMA_DestinationTransferWidth_128bit     ((uint8_t)0x4)
N#define  DMA_DestinationTransferWidth_256bit     ((uint8_t)0x5)
N
N
N#define  DMA_SourceTransferWidth_8bit            ((uint8_t)0x0)
N#define  DMA_SourceTransferWidth_16bit           ((uint8_t)0x1)
N#define  DMA_SourceTransferWidth_32bit           ((uint8_t)0x2)
N#define  DMA_SourceTransferWidth_64bit           ((uint8_t)0x3)
N#define  DMA_SourceTransferWidth_128bit          ((uint8_t)0x4)
N#define  DMA_SourceTransferWidth_256bit          ((uint8_t)0x5)
N
N#define	DMA_DestinationAddress_Increment				((uint8_t)0x00) //  <<7
N#define	DMA_DestinationAddress_Decrement				((uint8_t)0x01) //  <<7
N#define	DMA_DestinationAddress_NoChange					((uint8_t)0x02) //  <<7
N
N#define	DMA_SourceAddress_Increment							((uint8_t)0x00) //  <<9
N#define	DMA_SourceAddress_Decrement							((uint8_t)0x01) //  <<9
N#define	DMA_SourceAddress_NoChange							((uint8_t)0x02) //  <<9
N
N
N#define	DMA_DestinationBurstTransLength_1				((uint8_t)0x00) //  <<11
N#define	DMA_DestinationBurstTransLength_4				((uint8_t)0x01) //  <<11
N#define	DMA_DestinationBurstTransLength_8				((uint8_t)0x02) //  <<11
N#define	DMA_DestinationBurstTransLength_16			((uint8_t)0x03) //  <<11
N#define	DMA_DestinationBurstTransLength_32			((uint8_t)0x04) //  <<11
N#define	DMA_DestinationBurstTransLength_64			((uint8_t)0x05) //  <<11
N#define	DMA_DestinationBurstTransLength_128			((uint8_t)0x06) //  <<11
N#define	DMA_DestinationBurstTransLength_256			((uint8_t)0x07) //  <<11
N
N#define	DMA_SourceBurstTransLength_1						((uint8_t)0x00) //  <<14
N#define	DMA_SourceBurstTransLength_4						((uint8_t)0x01) //  <<14            
N#define	DMA_SourceBurstTransLength_8						((uint8_t)0x02) //  <<14
N#define	DMA_SourceBurstTransLength_16						((uint8_t)0x03) //  <<14
N#define	DMA_SourceBurstTransLength_32						((uint8_t)0x04) //  <<14
N#define	DMA_SourceBurstTransLength_64						((uint8_t)0x05) //  <<14
N#define	DMA_SourceBurstTransLength_128					((uint8_t)0x06) //  <<14
N#define	DMA_SourceBurstTransLength_256					((uint8_t)0x07) //  <<14
N
N#define	DMA_SourceGatherDisable								  ((uint8_t)0x00) //  <<17
N#define	DMA_SourceGatherEnable								  ((uint8_t)0x01) //  <<17
N#define	DMA_DestinationScatterDisable						((uint8_t)0x00) //  <<18
N#define	DMA_DestinationScatterEnable						((uint8_t)0x01) //  <<18
N
N#define	DMA_DataTransferDir_M2M								  ((uint8_t)0x00) //  <<20
N#define	DMA_DataTransferDir_M2P								  ((uint8_t)0x01) //  <<20
N#define	DMA_DataTransferDir_P2M								  ((uint8_t)0x02) //  <<20
N#define	DMA_DataTransferDir_P2P								  ((uint8_t)0x03) //  <<20
N
N#define	DMA_DestinationAHBBus_Master1						((uint8_t)0x00) //  <<23
N#define	DMA_DestinationAHBBus_Master2						((uint8_t)0x01) //  <<23
N#define	DMA_DestinationAHBBus_Master3						((uint8_t)0x02) //  <<23
N#define	DMA_DestinationAHBBus_Master4						((uint8_t)0x03) //  <<23
N
N#define	DMA_SourceAHBBus_Master1							  ((uint8_t)0x00) //  <<25
N#define	DMA_SourceAHBBus_Master2							  ((uint8_t)0x01) //  <<25
N#define	DMA_SourceAHBBus_Master3							  ((uint8_t)0x02) //  <<25
N#define	DMA_SourceAHBBus_Master4							  ((uint8_t)0x03) //  <<25
N
N#define	DMA_DestinationLLPDisable						    ((uint8_t)0x00) //  <<27
N#define	DMA_DestinationLLPEnable						    ((uint8_t)0x01) //  <<27
N
N#define	DMA_SourceLLPDisable								    ((uint8_t)0x00) //  <<28
N#define	DMA_SourceLLPEnable								      ((uint8_t)0x01) //  <<28
N
N#define	CTLx_CLEAR_Mask										      ((uint64_t)0xFFFFF000F80E0001)
N#define	DMA_BLOCK_TS_Mask									      ((uint64_t)0x00000FFF00000000)
N
N//CFGx
N#define	DMA_PRIORITY_Level_0								    ((uint8_t)0x07) //  <<5     highest priority
N#define	DMA_PRIORITY_Level_1								    ((uint8_t)0x06) //  <<5             
N#define	DMA_PRIORITY_Level_2								    ((uint8_t)0x05) //  <<5
N#define	DMA_PRIORITY_Level_3								    ((uint8_t)0x04) //  <<5
N#define	DMA_PRIORITY_Level_4								    ((uint8_t)0x03) //  <<5
N#define	DMA_PRIORITY_Level_5								    ((uint8_t)0x02) //  <<5
N#define	DMA_PRIORITY_Level_6								    ((uint8_t)0x01) //  <<5
N#define	DMA_PRIORITY_Level_7								    ((uint8_t)0x00) //  <<5     lowest
N
N#define	DMA_DestinationSoftwareHandShaking		  ((uint8_t)0x01) //  <<10
N#define	DMA_DestinationHardwareHandShaking			((uint8_t)0x00) //  <<10
N
N#define	DMA_SourceSoftwareHandShaking						((uint8_t)0x01) //  <<11
N#define	DMA_SourceHardwareHandShaking						((uint8_t)0x00) //  <<11
N
N#define	DMA_SourceReloadDisable								  ((uint8_t)0x00) //  <<30
N#define	DMA_SourceReloadEnable								  ((uint8_t)0x01) //  <<30
N
N#define	DMA_DestinationReloadDisable						((uint8_t)0x00) //  <<31
N#define	DMA_DestinationReloadEnable						  ((uint8_t)0x01) //  <<31
N
N#define	DMA_DestinationStateUpdateDisable       ((uint8_t)0x00) //  <<37
N#define	DMA_DestinationStateUpdateEnable				((uint8_t)0x01) //  <<37
N
N#define	DMA_SourceStateUpdateDisable						((uint8_t)0x00) //  <<38
N#define	DMA_SourceStateUpdateEnable							((uint8_t)0x01) //  <<38
N
N#define	DMA_DMADoneDisable						          ((uint8_t)0x00) //  <<44
N#define	DMA_DMADoneEnable							          ((uint8_t)0x01) //  <<44
N
N/////////////////////////////////
N// change by hnkim             //
N/////////////////////////////////
N#define	DMA_SOURCE_PERI_I2CTX								    ((uint8_t)0x00) //  <<39
N#define	DMA_SOURCE_PERI_I2CRX								    ((uint8_t)0x01) //  <<39
N#define	DMA_SOURCE_PERI_TSPITX							    ((uint8_t)0x02) //  <<39
N#define	DMA_SOURCE_PERI_TSPIRX							    ((uint8_t)0x03) //  <<39
N#define	DMA_SOURCE_PERI_NONE								    ((uint8_t)0x04) //  <<39
N
N#define	DMA_DESTINATION_PERI_I2CTX							((uint8_t)0x00) //  <<43
N#define	DMA_DESTINATION_PERI_I2CRX							((uint8_t)0x01) //  <<43
N#define	DMA_DESTINATION_PERI_TSPITX							((uint8_t)0x02) //  <<43
N#define	DMA_DESTINATION_PERI_TSPIRX							((uint8_t)0x03) //  <<43
N#define	DMA_DESTINATION_PERI_NONE							  ((uint8_t)0x04) //  <<43
N
N
N#define	CFGx_Mask											          ((uint64_t)0xFFFF807F3FFFF31F)
N
N//DmaCfgReg
N#define	DMA_GlobalChannel_Enable							  ((uint32_t)0x00000001)
N
N  /////////////////////////////////
N  //ChEnReg // change by hnkim   //
N  /////////////////////////////////
N  #define  DMA_CH0_Flag                            ((uint16_t)0x0001)
N//#define  DMA_CH1_Flag                            ((uint16_t)0x0002)
N//#define  DMA_CH2_Flag                            ((uint16_t)0x0003)
N  #define  DMA_Channel_Mask                        ((uint16_t)0x0007)
N
N//ClearBlock, ClearDstTran,ClearErr,ClearSrcTran,ClearTfr
N#define	TYPE_TRANFER_COMPLETE								    ((uint16_t)0x0001)
N#define	TYPE_BLOCK_COMPLETE									    ((uint16_t)0x0002)
N#define	TYPE_SOURCE_TRANSACTION_COMPLETE				((uint16_t)0x0004)
N#define	TYPE_DESTINATION_TRANSACTION_COMPLETE		((uint16_t)0x0008)
N#define	TYPE_ERROR_OCCUR									      ((uint16_t)0x0010)
N
N//StatusInt
N#define	STATUS_OCCUR_Error									    ((uint16_t)0x0010)
N#define	STATUS_OCCUR_DesTran								    ((uint16_t)0x0008)
N#define	STATUS_OCCUR_SrcTran								    ((uint16_t)0x0004)
N#define	STATUS_OCCUR_Block									    ((uint16_t)0x0002)
N#define	STATUS_OCCUR_Tfr									      ((uint16_t)0x0001)
N
N#define	    SatatusInt_Mask									    ((uint16_t)0x001F)
N
Ntypedef struct
N{
N	uint32_t	DMA_SRCBaseAddr;							      //Source Address of DMA tarnsfer        "SARx"  
N	uint32_t	DMA_DSTBaseAddr;							      //Destination address of DMA transfer   "DARx"
N
N// CTL
N	uint8_t		DMA_DSTTransBusWidth;						    //Destination Transfer Bus Width   "CTLx[3:1]"
N	uint8_t		DMA_SRCTransBusWidth;						    //Source    Transfer Bus Width     "CTLx[6:4]" 
N
N	uint8_t		DMA_DSTAddInc;								      //Destination Address Increment     "CTLx[8:7]" //  << 7
N	uint8_t		DMA_SRCAddInc;								      //Source Address Increment          "CTLx[10:9]"//  <<9
N
N	uint8_t		DMA_DSTBurstTransactionRequest;			//DMA Request"CTLx[13:11]"   //  <<11
N	uint8_t		DMA_SRCBurstTransactionRequest;			//DMA Request"CTLx[16:14]"   //  <<14
N
N  uint8_t		DMA_SrcGatherEn;						        //Source Gather En    "CTLx[17]"   //  <<17
N  uint8_t		DMA_DstScatterEn;						        //Destination Scatter En    "CTLx[18]" //  <<18
N  
N  uint8_t		DMA_SrcDestDirection;						    //Transfer Type and Flow Control    "CTLx[22:20]" //  <<20
N	uint16_t	RESERVED0;
N
N	uint8_t   DMA_DSTMasterBusSel;						    //Destination Master Bus Select     "CTLx[24:23]" //  <<23
N	uint8_t   DMA_SRCMasterBusSel;						    //Source Master Bus Select          "CTLx[26:25]" //  <<25
N	uint16_t  RESERVED1;
N
N  uint8_t		DMA_DstLLPEn;						            //Destination LLP En    "CTLx[27]"
N  uint8_t		DMA_SrcLLPEn;						            //Source LLP En    "CTLx[28]"                 
N
N	uint64_t  DMA_BufferSize;                     //  (<<32)-1
N  uint8_t		DMA_LLPDone;						            //LLP Done    "CTLx[44]"                           
N    
N//  CFGx
N	uint8_t   DMA_ChannelPriority;						   //Channel Priority                                     //  <<5
N	uint8_t   DMA_DSTHandShakingSel;				     //Destination Software or Hardware Handshaking Select  //  <<10
N	uint8_t   DMA_SRCHandShakingSel;					   //Source Software or Hardware Handshaking Select       //  <<11
N	uint8_t   RESERVED2;                              
N
N  uint8_t		DMA_SrcReloadEn;						       //Source Reload En    "CFGx[30]"
N  uint8_t		DMA_DstReloadEn;						       //Destination Reload En    "CFGx[31]"
N
N  uint64_t	DMA_DstUPDEn;						           //Destination State Update En    "CFGx[37]"
N  uint64_t	DMA_SrcUPDEn;						           //Source State Update En    "CFGx[38]"
N
N	uint64_t  DMA_SRCHardwarePeriSel;					   //Source peripheral  hardware handshaking interface     //  <<39
N	uint64_t  DMA_DSTHardwarePeriSel;				     //Destination peripheral hardware handshaking interface //  <<43
N} DMA_InitTypeDef;
N
N
N
N  void DMA_SETUP (void);
N
N
N
N//----------------------------------------------------------------------
N/**@brief DMA ?? ?? ??? 
N  @param DMA_CHx : DMA_CH? ?? Pointer
N  @param DMA_InitStruct  : DMA? ?? ???? ?? ? Wirte 
N**///----------------------------------------------------------------------    
N  //void DMA_Init (DMA_Channel_TypeDef* DMA_CHx, DMA_InitTypeDef* DMA_InitStruct);
N  void DMA_Init (DMA_Channel_TypeDef* DMA_CHx);
N// ssung start
N//void DMA_SetDestinationStatusReg(DMA_Channel_TypeDef* DMA_CHx,uint32_t reg);
N//void DMA_SetDestinationStatusAddr(DMA_Channel_TypeDef* DMA_CHx,uint32_t addr);
N//void DMA_SetDestinationLLIAddr(DMA_Channel_TypeDef* DMA_CHx,uint32_t addr);
N//void DMA_SetDestinationBaseAddr(DMA_Channel_TypeDef* DMA_CHx,uint32_t addr);
N//void DMA_SetBlockTransferSize(DMA_Channel_TypeDef* DMA_CHx,uint64_t size);
N  // ssjung end
N
N//----------------------------------------------------------------------
N/**@brief DMA_Cmd DMA? ?? Channel? ?? ? Enalbe
N  @param DMA_ch : DMA_CH ??
N  @param NewState  : DMA Enable Flag
N**///----------------------------------------------------------------------    
N//void DMA_Cmd(uint32_t DMA_ch,FunctionalState NewState);
N  void DMA_Cmd(uint32_t DMA_ch,uint32_t DMA_chen);
N
N//----------------------------------------------------------------------
N/**@brief DMA_Global_Channel_Enable ? ?? Channel? ?? Flag
N  @param NewState  : DMA_Global_Channel Flag
N**///----------------------------------------------------------------------    
N  void DMA_Global_Channel_Enable(FunctionalState NewState);
N  // ssjung remove
N//FlagStatus DMA_GetLastStatus(uint32_t DMA_FLAG);
N
N//----------------------------------------------------------------------
N/**@brief DMA_Clear ??? ?? Flag
N  @param FlagType  : Flag
N  @param NewState  : DMA Channel ?
N**///----------------------------------------------------------------------    
N  void DMA_ClearFlag(uint16_t FlagType,uint16_t DMA_ch);
N
N//----------------------------------------------------------------------
N/**@brief DMA_ITMaskTfrConfig ??? ?? Flag
N  @param DMA_ch  : DMA Channel ?
N  @param NewState  : Reset ??
N**///----------------------------------------------------------------------    
N  void DMA_ITMaskTfrConfig(uint16_t DMA_ch,FlagStatus NewState);
N  // ssjung remove
N//void DMA_ITMaskErrConfig(uint16_t DMA_ch,FlagStatus NewState);
N//----------------------------------------------------------------------
N/**@brief DMA_ITConfig DMA Interrupt Enable ?? ?? Function
N  @param DMA_ch  : DMA_CHx? ?? pointer ?
N  @param NewState  : enable or disable
N**///----------------------------------------------------------------------    
N  void DMA_ITConfig(__IO DMA_Channel_TypeDef* DMA_CHx, FunctionalState NewState);
X  void DMA_ITConfig(volatile DMA_Channel_TypeDef* DMA_CHx, FunctionalState NewState);
N
N
N  // ssjung add
N//  uint16_t DMA_Channel_Select(DMA_Channel_TypeDef* DMAx);
N  // ssjung add
N  void DMA_Transfer(DMA_Channel_TypeDef* DMA_CHx, uint64_t SRCADDR, uint64_t DESADDR, uint64_t BufferSize);
N
N
N  DMA_Channel_TypeDef* DMA_GetNonBusyChannel(void);
N  uint64_t DMA_GetDmaComponentID(void);
N  uint16_t DMA_GetITStatus(void);
N  uint16_t DMA_GetRawTfr(void);
N  uint16_t DMA_GetRawErr(void);
N  uint16_t DMA_GetRawIntBlock(void);
N  uint16_t DMA_GetRawSrcTran(void);
N  uint16_t DMA_GetRawDstTran(void);
N
N//uint64_t DMA_ChannelxLLPData(DMA_Channel_TypeDef* DMA_CHx);
N
N
N
N#endif /* _DMA_H_ */
L 44 "..\..\Hal\hal_def.h" 2
N#include "dspA.h"
L 1 "..\..\Hal\dspA\dspA.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : DSPA.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _DSPA_H_
N#define _DSPA_H_
N
N
Ntypedef struct
N{
N	uint32_t ulPanelRowNum;
N	uint32_t ulPanelColNum;
N	uint32_t ulPanelDataNumIncludePad;
N	uint32_t ulRawDataBufAddr;
N	uint32_t ulBaselineBufAddr;
N	uint32_t ulNomalizeBufAddr;
N	uint32_t ulIntensityBufAddr;
N
N	uint32_t ulPadEn;
N	uint32_t ulPadSize;
N	uint32_t ulPadData;
N
N	uint32_t ulNormalizeEn;
N	uint32_t ulNormalizeShiftLevel;
N	uint32_t ulIntensityBitShiftLevel;
N
N	uint32_t ulPositiveThreshold;
N	int32_t lNegativeThreshold;
N	uint32_t ulGroupThreshold;
N
N} tDSPAOpHandleInfo_t;
N
Ntypedef struct
N{
N	uint32_t ulPositiveCellNum; // +  Cell
N	uint32_t ulPositiveCellTotalSum; // +  Cell Data
N	uint16_t usPositiveMaxData; // +  Max
N	uint32_t ulPositiveMaxData_RowIdx; // +  Max Row
N	uint32_t ulPositiveMaxData_ColIdx; // +  Max Column
N
N	uint32_t ulNegativeCellNum; // -  Cell
N	int32_t lNegativeCellTotalSum; // -  Cell Data 
N	int16_t sNegativeMaxData; // -  Max
N	uint32_t ulNegativeMaxData_RowIdx; // -  Max Row
N	uint32_t ulNegativeMaxData_ColIdx; // -  Max Column
N
N	uint32_t ulTouchAreaRow_sTdx; // Touch  Group Min Row
N	uint32_t ulTouchAreaRow_eIdx; // Touch  Group Max Row
N	uint32_t ulTouchAreaCol_sIdx; // Touch  Group Min Column
N	uint32_t ulTouchAreaCol_eIdx; // Touch  Group Max Column
N	uint32_t ulTouchAreaCellNum; // Touch   Cell
N
N} tDSPAOutPutInfo_t;
N
Nextern void DSPA_Initialize(tDSPAOpHandleInfo_t * ptHandle);
Nextern void DSPA_Start(uint32_t bIsWaitIrq, tDSPAOutPutInfo_t * ptOutPutInfo);
Nextern void DSPA_WaitForIrq(tDSPAOutPutInfo_t * ptOutPutInfo);
N
N#endif /* _DSPA_H_ */
L 45 "..\..\Hal\hal_def.h" 2
N#if !defined(USE_BOOTLOADER_CODE)
X#if !0L
N#include "DSP_B.h"
L 1 "..\..\Hal\dspB\DSP_B.h" 1
N/********************************************************************************
N  @file     DSP_B.h
N  @brief    Touch DSP H/W OpCode
N *******************************************************************************/
N
N/********************************************************************************
N  @mainpage TDSP_HW Ver.2.0
N  @section intro INTRODUCTION
N      This file include touch DSP Ver.2.0 library. All library functions operate
N      at SW3704 H/W platform.
N  @section createinfo AUTHOR
N      - 2012/02/01 by J.H.Kim
N  @section modifyinfo REVISION HISTORY
N      - 2013/02/20 by S.Y.Kim : modified to improve readability       
N  *******************************************************************************/
N
N#ifndef DSP_B_H_
N#define DSP_B_H_
N
N
N#include "algorithm_def.h"
L 1 "..\..\App\Algorithm\algorithm_def.h" 1
N/*
N * algorithm_def.h
N *
N *  Created on: 2015. 3. 19.
N *      Author: parkyj2
N */
N
N#ifndef __ALGORITHM_DEF_H__
N#define __ALGORITHM_DEF_H__
N
N
N#include "env_def.h"
N#include "memory_pool.h"
L 1 "..\..\Hal\memory_pool.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : memory_pool.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MEMORY_POOL_H_
N#define _MEMORY_POOL_H_
N
N
N/********************************************************************************************/
N/*                                 Local Shared Memory union                                */
N/********************************************************************************************/
N
Ntypedef struct
N{
N	uint16_t MatrixU16_PenCoordRawdata		[PEN_COORD_ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_PenCoordRawdata		[(5)][(96)];
N	uint16_t MatrixU16_PenBase				[ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_PenBase				[(48)][(96)];
N	int16_t  MatrixS16_PenDelta				[PEN_COORD_ROW_MAX + 2*PAD_][COL_MAX + 2*PAD_];
X	int16_t  MatrixS16_PenDelta				[(5) + 2*(1)][(96) + 2*(1)];
N	/*
N	 * TODO : MSB/LSB Concept
N	 */
N	uint16_t MatrixU8_PenDataRawdata		[PEN_DATA_ROW_MAX/2][COL_MAX];
X	uint16_t MatrixU8_PenDataRawdata		[((5)*4)/2][(96)];
N	uint16_t MatrixU8_PenDataBase			[PEN_DATA_ROW_MAX/2][COL_MAX];
X	uint16_t MatrixU8_PenDataBase			[((5)*4)/2][(96)];
N//	uint8_t MatrixU8_PenDataRawdata		[PEN_DATA_ROW_MAX][COL_MAX;
N//	uint8_t MatrixU8_PenDataBase			[(ROW_MAX+1)>>1][COL_MAX];
N
N	uint8_t  MatrixU08_PenLabel				[PEN_COORD_ROW_MAX + 2*PAD_][COL_MAX + 2*PAD_];
X	uint8_t  MatrixU08_PenLabel				[(5) + 2*(1)][(96) + 2*(1)];
N} tLocalFrameBuf_t;
N
N/********************************************************************************************/
N/*                                 Full Shared Memory union                                 */
N/********************************************************************************************/
Ntypedef union
N{
N	uint16_t MatrixU16_FullfingerRaw  	 	[ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_FullfingerRaw  	 	[(48)][(96)];
N} tFullSharedBuf_t;
N
Ntypedef struct
N{
N	uint16_t MatrixU16_FullfingerBase		[ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_FullfingerBase		[(48)][(96)];
N	uint16_t MatrixU16_FullfingerBase_HOPP1	[ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_FullfingerBase_HOPP1	[(48)][(96)];
N	uint16_t MatrixU16_FullfingerBase_HOPP2	[ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_FullfingerBase_HOPP2	[(48)][(96)];
N	uint32_t MatrixU32_1             		[ROW_MAX + 2*PAD_][COL_MAX + 2*PAD_];
X	uint32_t MatrixU32_1             		[(48) + 2*(1)][(96) + 2*(1)];
N	union {
N		int16_t  MatrixS16_FingerDelta   		[ROW_MAX + 2*PAD_][COL_MAX + 2*PAD_];
X		int16_t  MatrixS16_FingerDelta   		[(48) + 2*(1)][(96) + 2*(1)];
N		int16_t  MatrixS16_FingerDelta_NoPad   	[ROW_MAX][COL_MAX];
X		int16_t  MatrixS16_FingerDelta_NoPad   	[(48)][(96)];
N	};
N
N	uint8_t  MatrixU08_FullModeLabel 		[ROW_MAX + 2*PAD_][COL_MAX + 2*PAD_];
X	uint8_t  MatrixU08_FullModeLabel 		[(48) + 2*(1)][(96) + 2*(1)];
N
N	uint16_t MatrixU16_NoiseIndexRawData 	[NI_ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_NoiseIndexRawData 	[((1)*4)][(96)];
N	uint16_t MatrixU16_NoiseIndexDelta		[NI_ROW_MAX + 2*PAD_][COL_MAX + 2*PAD_];
X	uint16_t MatrixU16_NoiseIndexDelta		[((1)*4) + 2*(1)][(96) + 2*(1)];
N	uint16_t MatrixU16_NoiseIndexBase		[NI_ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_NoiseIndexBase		[((1)*4)][(96)];
N	uint16_t MatrixU16_NoiseIndexBase_HOPP1	[NI_ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_NoiseIndexBase_HOPP1	[((1)*4)][(96)];
N	uint16_t MatrixU16_NoiseIndexBase_HOPP2	[NI_ROW_MAX][COL_MAX];
X	uint16_t MatrixU16_NoiseIndexBase_HOPP2	[((1)*4)][(96)];
N
N	tFullSharedBuf_t FULLBUF;
N} tFullFrameBuf_t;
N
N/********************************************************************************************/
N/*                                  Extern Buffer                                           */
N/********************************************************************************************/
N//Local Buffer
N#define LOCALRAWIMAGE					LocalSharedBuff.MatrixU16_PenCoordRawdata
N#define LOCALDATARAW					LocalSharedBuff.MatrixU8_PenDataRawdata
N#define LOCALBASELINE					LocalSharedBuff.MatrixU16_PenBase
N#define LOCALDELTAIMAGE					LocalSharedBuff.MatrixS16_PenDelta
N#define LOCALLABELIMAGE					LocalSharedBuff.MatrixU08_PenLabel
N#define LOCALDATABASELINE				LocalSharedBuff.MatrixU8_PenDataBase
N
N//Full Finger Buffer
N#define COMMONIMAGE						FullSharedBuff.MatrixU32_1
N#define RAWIMAGE						FullSharedBuff.FULLBUF.MatrixU16_FullfingerRaw
N#define BASELINEIMAGE					FullSharedBuff.MatrixU16_FullfingerBase
N#define BASELINEIMAGE_HOPP1				FullSharedBuff.MatrixU16_FullfingerBase_HOPP1
N#define BASELINEIMAGE_HOPP2				FullSharedBuff.MatrixU16_FullfingerBase_HOPP2
N#define DELTAIMAGE						FullSharedBuff.MatrixS16_FingerDelta
N#define DELTAIMAGE_NOPAD				FullSharedBuff.MatrixS16_FingerDelta_NoPad
N
N
N
N#define LABELIMAGE						FullSharedBuff.MatrixU08_FullModeLabel
N
N#define LOCALFINGERRAWIMAGE				FullSharedBuff.FULLBUF.MatrixU16_FullfingerRaw
N#define LOCALFINGERDELTAIMAGE			FullSharedBuff.MatrixS16_FingerDelta
N#define LOCALFINGERBASELINEIMAGE  		FullSharedBuff.MatrixU16_FullfingerBase
N
N#define NI_RAWIMAGE						FullSharedBuff.MatrixU16_NoiseIndexRawData
N#define NI_DELTAIMAGE   				FullSharedBuff.MatrixU16_NoiseIndexDelta
N#define NI_BASELINEIMAGE				FullSharedBuff.MatrixU16_NoiseIndexBase
N#define NI_BASELINEIMAGE_HOPP1			FullSharedBuff.MatrixU16_NoiseIndexBase_HOPP1
N#define NI_BASELINEIMAGE_HOPP2			FullSharedBuff.MatrixU16_NoiseIndexBase_HOPP2
N
N/********************************************************************************************/
N/*                                  Extern Buffer                                           */
N/********************************************************************************************/
Nextern tLocalFrameBuf_t LocalSharedBuff;
Nextern tFullFrameBuf_t FullSharedBuff;
N
N/********************************************************************************************/
N/*                                        TEMP                                              */
N/********************************************************************************************/
Nextern int16_t  MatrixS16_fullHover[ROW_MAX + 2*PAD_][COL_MAX + 2*PAD_];
Xextern int16_t  MatrixS16_fullHover[(48) + 2*(1)][(96) + 2*(1)];
N#define FULLHOVERIMAGE	MatrixS16_fullHover
N
N/********************************************************************************************/
N/*                              Local Pen Coordinate Buffer                                 */
N/********************************************************************************************/
N#define HAL_WRITE_LOCAL_RAW_IMAGE(r, c, data)			LOCALRAWIMAGE[r][c] = data
N#define HAL_READ_LOCAL_RAW_IMAGE(r, c)					LOCALRAWIMAGE[r][c]
N#define HAL_GET_LOCAL_RAW_IMAGE_PTR()        			(uint16_t *)LOCALRAWIMAGE
N#define HAL_GET_LOCAL_RAW_IMAGE_SIZE()       			(sizeof(uint16_t)*PEN_COORD_ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_LOCAL_BASELINE_IMAGE(r, c, data)		LOCALBASELINE[r][c] = data
N#define HAL_READ_LOCAL_BASELINE_IMAGE(r, c)				LOCALBASELINE[r][c]
N#define HAL_GET_LOCAL_BASELINE_IMAGE_PTR()				(uint16_t *)LOCALBASELINE
N
N#define HAL_WRITE_LOCAL_DELTA_IMAGE(r, c, data)			LOCALDELTAIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_LOCAL_DELTA_IMAGE(r, c)				LOCALDELTAIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_LOCAL_DELTA_IMAGE_PTR()					(int16_t *)LOCALDELTAIMAGE
N#define HAL_GET_LOCAL_DELTA_IMAGE_SIZE()       			(sizeof(int16_t)*(PEN_COORD_ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N#define HAL_WRITE_LOCAL_SEARCH_IMAGE(r, c, data)		FULLHOVERIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_LOCAL_SEARCH_IMAGE(r, c)				FULLHOVERIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_LOCAL_SEARCH_IMAGE_PTR()				(int16_t *)FULLHOVERIMAGE
N#define HAL_GET_LOCAL_SEARCH_IMAGE_SIZE()       		(sizeof(uint16_t)*(ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N/********************************************************************************************/
N/*                          		   Local Data Buffer.                        		            */
N/********************************************************************************************/
N#define HAL_WRITE_LOCAL_DATA_RAW_IMAGE(r, c, data)			LOCALDATARAW[r][c] = data
N#define HAL_READ_LOCAL_DATA_RAW_IMAGE(r, c)					LOCALDATARAW[r][c]
N#define HAL_GET_LOCAL_DATA_RAW_IMAGE_PTR()					(uint16_t *)LOCALDATARAW
N#define HAL_GET_LOCAL_DATA_RAW_IMAGE_SIZE()       			(sizeof(uint8_t)*PEN_DATA_ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_LOCAL_DATA_BASELINE_IMAGE(r, c, data)		LOCALDATABASELINE[r][c] = data
N#define HAL_READ_LOCAL_DATA_BASELINE_IMAGE(r, c)			LOCALDATABASELINE[r][c]
N#define HAL_GET_LOCAL_DATA_BASELINE_IMAGE_PTR()         	(uint16_t *)LOCALDATABASELINE
N
N
N/********************************************************************************************/
N/*                          		   Local Finger Buffer.                      		            */
N/********************************************************************************************/
N#define HAL_WRITE_LOCAL_FINGER_RAW_IMAGE(r, c, data)		LOCALFINGERRAWIMAGE[r][c] = data
N#define HAL_READ_LOCAL_FINGER_RAW_IMAGE(r, c)				LOCALFINGERRAWIMAGE[r][c]
N#define HAL_GET_LOCAL_FINGER_RAW_IMAGE_PTR()				(uint16_t *)LOCALFINGERRAWIMAGE
N
N#define HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE(r, c, data)	LOCALFINGERBASELINEIMAGE[r][c] = data
N#define HAL_READ_LOCAL_FINGER_BASELINE_IMAGE(r, c)			LOCALFINGERBASELINEIMAGE[r][c]
N#define HAL_GET_LOCAL_FINGER_BASELINE_IMAGE_PTR()			(uint16_t *)LOCALFINGERBASELINEIMAGE
N
N#define HAL_WRITE_LOCAL_FINGER_DELTA_IMAGE(r, c, data)		LOCALFINGERDELTAIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_LOCAL_FINGER_DELTA_IMAGE(r, c)				LOCALFINGERDELTAIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_LOCAL_FINGER_DELTA_IMAGE_PTR()				(int16_t *)LOCALFINGERDELTAIMAGE
N
N/********************************************************************************************/
N/*                          		   Local etc.                                           */
N/********************************************************************************************/
N#define HAL_WRITE_LOCAL_LABEL_IMAGE(r, c, data)				LOCALLABELIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_LOCAL_LABEL_IMAGE(r, c)					LOCALLABELIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_LOCAL_LABEL_IMAGE_PTR()						(uint8_t *)LOCALLABELIMAGE
N#define HAL_GET_LOCAL_LABEL_IMAGE_SIZE()					(sizeof(int16_t)*(PEN_COORD_ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N
N/********************************************************************************************/
N/*                          		   FULL Sensing                                         */
N/********************************************************************************************/
N#define HAL_WRITE_RAW_IMAGE(r, c, data)					RAWIMAGE[r][c] = data
N#define HAL_READ_RAW_IMAGE(r, c)						RAWIMAGE[r][c]
N#define HAL_GET_RAW_IMAGE_PTR()            				(uint16_t *)RAWIMAGE
N#define HAL_GET_RAW_IMAGE_SIZE()           				(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_COMMON_IMAGE(r, c, data)				COMMONIMAGE[r][c] = data
N#define HAL_READ_COMMON_IMAGE(r, c)						COMMONIMAGE[r][c]
N#define HAL_GET_COMMON_IMAGE_PTR()            			(uint32_t **)COMMONIMAGE
N#define HAL_GET_COMMON_IMAGE_SIZE()           			(sizeof(uint32_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_BASELINE_IMAGE(r, c, data)			BASELINEIMAGE[r][c] = data
N#define HAL_READ_BASELINE_IMAGE(r, c)					BASELINEIMAGE[r][c]
N#define HAL_GET_BASELINE_IMAGE_PTR()            		(uint16_t *)BASELINEIMAGE
N#define HAL_GET_BASELINE_IMAGE_SIZE()           		(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_HOPP1_BASELINE_IMAGE(r, c, data)		BASELINEIMAGE_HOPP1[r][c] = data
N#define HAL_READ_HOPP1_BASELINE_IMAGE(r, c)				BASELINEIMAGE_HOPP1[r][c]
N#define HAL_GET_HOPP1_BASELINE_IMAGE_PTR()				(uint16_t *)BASELINEIMAGE_HOPP1
N#define HAL_GET_HOPP1_BASELINE_IMAGE_SIZE()				(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_HOPP2_BASELINE_IMAGE(r, c, data)		BASELINEIMAGE_HOPP2[r][c] = data
N#define HAL_READ_HOPP2_BASELINE_IMAGE(r, c)				BASELINEIMAGE_HOPP2[r][c]
N#define HAL_GET_HOPP2_BASELINE_IMAGE_PTR()				(uint16_t *)BASELINEIMAGE_HOPP2
N#define HAL_GET_HOPP2_BASELINE_IMAGE_SIZE()				(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_DELTA_IMAGE(r, c, data)				DELTAIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_DELTA_IMAGE(r, c)						DELTAIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_DELTA_IMAGE_PTR()               		(int16_t *)DELTAIMAGE
N#define HAL_GET_DELTA_IMAGE_SIZE()              		(sizeof(int16_t)*(ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N#define HAL_WRITE_DELTA_NOPAD_IMAGE(r, c, data)			DELTAIMAGE_NOPAD[r][c] = data
N#define HAL_READ_DELTA_NOPAD_IMAGE(r, c)				DELTAIMAGE_NOPAD[r][c]
N#define HAL_GET_DELTA_NOPAD_IMAGE_PTR()               	(int16_t *)DELTAIMAGE_NOPAD
N#define HAL_GET_DELTA_NOPAD_IMAGE_SIZE()              	(sizeof(int16_t)*(ROW_MAX)*(COL_MAX))
N
N#define HAL_WRITE_LABEL_IMAGE(r, c, data)				LABELIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_LABEL_IMAGE(r, c)						LABELIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_LABEL_IMAGE_PTR()              	 		(uint8_t *)LABELIMAGE
N#define HAL_GET_LABEL_IMAGE_SIZE()              		(sizeof(uint8_t)*(ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N#define HAL_WRITE_LABEL_LINKLIST_IMAGE(r, c, data)		COMMONIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_LABEL_LINKLIST_IMAGE(r, c)				COMMONIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_LABEL_LINKLIST_IMAGE_PTR()          	(uint32_t *)COMMONIMAGE
N#define HAL_GET_LABEL_LINKLIST_IMAGE_SIZE()         	(sizeof(uint32_t)*(ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N#define HAL_GET_LABEL_LINKLIST_NODE_PTR(r, c)			((uint32_t *)&COMMONIMAGE[r + PAD_][c + PAD_])
N
N#define HAL_WRITE_CONFLICT_LABEL_IMAGE(r, c, data)		COMMONIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_CONFLICT_LABEL_IMAGE(r, c)				COMMONIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_CONFLICT_LABEL_IMAGE_PTR()          	(uint32_t *)COMMONIMAGE
N#define HAL_GET_CONFLICT_LABEL_IMAGE_SIZE()         	(sizeof(uint32_t)*(ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N// use in Diagnostic Mode
N#define HAL_WRITE_ACCUM_RAW_IMAGE(r, c, data)			COMMONIMAGE[r][c] = data
N#define HAL_READ_ACCUM_RAW_IMAGE(r, c)					COMMONIMAGE[r][c]
N#define HAL_GET_ACCUM_RAW_IMAGE_PTR()           		(uint32_t *)COMMONIMAGE
N#define HAL_GET_ACCUM_RAW_IMAGE_SIZE()          		(sizeof(uint32_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_MIN_RAW_IMAGE(r, c, data)				BASELINEIMAGE[r][c] = data
N#define HAL_READ_MIN_RAW_IMAGE(r, c)					BASELINEIMAGE[r][c]
N#define HAL_GET_MIN_RAW_IMAGE_PTR()            			(uint16_t *)BASELINEIMAGE
N#define HAL_GET_MIN_RAW_IMAGE_SIZE()           			(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_FHOVER_IMAGE(r, c, data)				FULLHOVERIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_READ_FHOVER_IMAGE(r, c)						FULLHOVERIMAGE[r + PAD_][c + PAD_]
N#define HAL_GET_FHOVER_IMAGE_PTR()            			(int16_t *)FULLHOVERIMAGE
N
N
N/********************************************************************************************/
N/*                          		   Noise Index Data Buffer.                              			    */
N/********************************************************************************************/
N
N#define HAL_NI_WRITE_RAW_IMAGE(r, c, data)				NI_RAWIMAGE[r][c] = data
N#define HAL_NI_READ_RAW_IMAGE(r, c)						NI_RAWIMAGE[r][c]
N#define HAL_NI_GET_RAW_IMAGE_PTR()						(uint16_t *)NI_RAWIMAGE
N#define HAL_NI_GET_RAW_IMAGE_SIZE()						(sizeof(uint16_t)*NI_ROW_MAX*COL_MAX)
N
N#define HAL_NI_WRITE_DELTA_IMAGE(r, c, data)			NI_DELTAIMAGE[r + PAD_][c + PAD_] = data
N#define HAL_NI_READ_DELTA_IMAGE(r, c)					NI_DELTAIMAGE[r + PAD_][c + PAD_]
N#define HAL_NI_GET_DELTA_IMAGE_PTR()               		(int16_t *)NI_DELTAIMAGE
N#define HAL_NI_GET_DELTA_IMAGE_SIZE()              		(sizeof(int16_t)*(NI_ROW_MAX+2*PAD_)*(COL_MAX+2*PAD_))
N
N#define HAL_NI_WRITE_BASELINE_IMAGE(r, c, data)			NI_BASELINEIMAGE[r][c] = data
N#define HAL_NI_READ_BASELINE_IMAGE(r, c)				NI_BASELINEIMAGE[r][c]
N#define HAL_NI_GET_BASELINE_IMAGE_PTR()					(uint16_t *)NI_BASELINEIMAGE
N#define HAL_NI_GET_BASELINE_IMAGE_SIZE()           		(sizeof(uint16_t)*NI_ROW_MAX*COL_MAX)
N
N#define HAL_NI_WRITE_HOP1_BASELINE_IMAGE(r, c, data)	NI_BASELINEIMAGE_HOPP1[r][c] = data
N#define HAL_NI_READ_HOP1_BASELINE_IMAGE(r, c)			NI_BASELINEIMAGE_HOPP1[r][c]
N#define HAL_NI_GET_HOP1_BASELINE_IMAGE_PTR()			(uint16_t *)NI_BASELINEIMAGE_HOPP1
N#define HAL_NI_GET_HOP1_BASELINE_IMAGE_SIZE()           (sizeof(uint16_t)*NI_ROW_MAX*COL_MAX)
N
N#define HAL_NI_WRITE_HOP2_BASELINE_IMAGE(r, c, data)	NI_BASELINEIMAGE_HOPP2[r][c] = data
N#define HAL_NI_READ_HOP2_BASELINE_IMAGE(r, c)			NI_BASELINEIMAGE_HOPP2[r][c]
N#define HAL_NI_GET_HOP2_BASELINE_IMAGE_PTR()			(uint16_t *)NI_BASELINEIMAGE_HOPP2
N#define HAL_NI_GET_HOP2_BASELINE_IMAGE_SIZE()           (sizeof(uint16_t)*NI_ROW_MAX*COL_MAX)
N
N/********************************************************************************************/
N/*                          		   Diagnostic Sensing                                         */
N/********************************************************************************************/
N
N#define HAL_WRITE_ABS_DIFF_IMAGE(r, c, data)			BASELINEIMAGE[r][c] = data
N#define HAL_READ_ABS_DIFF_IMAGE(r, c)					BASELINEIMAGE[r][c]
N#define HAL_GET_ABS_DIFF_IMAGE_PTR()            		(uint16_t *)BASELINEIMAGE
N#define HAL_GET_ABS_DIFF_IMAGE_SIZE()           		sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_ABS_IMAGE(r, c, data)					BASELINEIMAGE[r][c] = data
N#define HAL_READ_ABS_IMAGE(r, c)						BASELINEIMAGE[r][c]
N#define HAL_GET_ABS_IMAGE_PTR()            				(uint16_t *)BASELINEIMAGE
N#define HAL_GET_ABS_IMAGE_SIZE()           				(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_DC_ABS_IMAGE(r, c, data)				BASELINEIMAGE[r][c] = data
N#define HAL_READ_DC_ABS_IMAGE(r, c)						BASELINEIMAGE[r][c]
N#define HAL_GET_DC_ABS_IMAGE_PTR()            			(uint16_t *)BASELINEIMAGE
N#define HAL_GET_DC_ABS_IMAGE_SIZE()           			(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_OS_IMAGE(r, c, data)					BASELINEIMAGE[r][c] = data
N#define HAL_READ_OS_IMAGE(r, c)							BASELINEIMAGE[r][c]
N#define HAL_GET_OS_IMAGE_PTR()            				(uint16_t *)BASELINEIMAGE
N#define HAL_GET_OS_IMAGE_SIZE()           				(sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N//#define HAL_WRITE_OPEN_1_IMAGE(r, c, data)			BASELINEIMAGE[r][c] = data
N//#define HAL_READ_OPEN_1_IMAGE(r, c)					BASELINEIMAGE[r][c]
N//#define HAL_GET_OPEN_1_IMAGE_PTR()            		(uint16_t *)BASELINEIMAGE
N//#define HAL_GET_OPEN_1_IMAGE_SIZE()           		sizeof(uint16_t)*ROW_MAX*COL_MAX)
N//
N//#define HAL_WRITE_OPEN_2_IMAGE(r, c, data)			BASELINEIMAGE_HOPP1[r][c] = data
N//#define HAL_READ_OPEN_2_IMAGE(r, c)					BASELINEIMAGE_HOPP1[r][c]
N//#define HAL_GET_OPEN_2_IMAGE_PTR()            		(uint16_t *)BASELINEIMAGE_HOPP1
N//#define HAL_GET_OPEN_2_IMAGE_SIZE()           		sizeof(uint16_t)*ROW_MAX*COL_MAX)
N//
N//#define HAL_WRITE_SHORT_IMAGE(r, c, data)				BASELINEIMAGE[r][c] = data
N//#define HAL_READ_SHORT_IMAGE(r, c)					BASELINEIMAGE[r][c]
N//#define HAL_GET_SHORT_IMAGE_PTR()            			(uint16_t *)BASELINEIMAGE
N//#define HAL_GET_SHORT_IMAGE_SIZE()           			sizeof(uint16_t)*ROW_MAX*COL_MAX)
N
N#define HAL_WRITE_JITTER_IMAGE(r, c, data)				DELTAIMAGE_NOPAD[r][c] = data
N#define HAL_READ_JITTER_IMAGE(r, c)						DELTAIMAGE_NOPAD[r][c]
N#define HAL_GET_JITTER_IMAGE_PTR()            			(int16_t *)DELTAIMAGE_NOPAD
N#define HAL_GET_JITTER_IMAGE_SIZE()						(sizeof(int16_t)*(ROW_MAX)*(COL_MAX))
N
N
N#endif /* _MEMORY_POOL_H_ */
L 14 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm_define.h"
L 1 "..\..\App\Algorithm\algorithm_define.h" 1
N/*
N * algorithm_define.h
N *
N *  Created on: 2015. 5. 11.
N *      Author: parkyj2
N */
N
N#ifndef __ALGORITHM_DEFINE_H__
N#define __ALGORITHM_DEFINE_H__
N
N//#define MAX_TOUCH_                      10
N//#define MAX_KEY_                        4
N
N#define POSBUF_                         10
N#define POSBUF_MARGIN                   6 //30
N#define LABEL_MARGIN					40
N#define LOOSE_POSBUF_                   (POSBUF_ + POSBUF_MARGIN) //!It must be a even #!
N#define LABEL_BOUNDARY_MARKER           (LOOSE_POSBUF_ + 2)
N#define LABEL_CONFLICT_MARKER           63
N
N#define NOISE_DETECTION_FRAME_NUM		20
N
N
N////////////////////////////big finger
N#define NON_LABEL       0
N#define NON_OVERLAP     1
N#define OVERLAP_LABEL   2
N
N#define NON_FINGER      0
N#define BIG_FINGER      1
N#define NORMAL_FINGER   2
N
N#define oCNT    0
N#define oFLAG   1
N
N#define XMIN    0
N#define XMAX    1
N#define YMIN    2
N#define YMAX    3
N
N#define VERIFICATION_FRAME 15
N#define BIG_CHECK_FRAME		5
N
N#define SEN_CONT_CNT 10
N
N#define MINRAWDATA_MARGIN 10
N
N
N#endif /* __ALGORITHM_DEFINE_H__ */
L 15 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm_types.h"
L 1 "..\..\App\Algorithm\algorithm_types.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : algorithm_types.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N
N#ifndef _ALGORITHM_TYPES_H_
N#define _ALGORITHM_TYPES_H_
N
N#define POS_BOOST_SHIFT_                (8)
N#define UNIT_DIST                       _BV(POS_BOOST_SHIFT_)
N
N//#define MAX_CONTACT_THD                 10
N
Ntypedef struct
N{
N    int32_t x;
N    int32_t y;
N} __PACKED tXY_t;
X} __attribute__ ((packed)) tXY_t;
N
Ntypedef struct
N{
N    uint8_t sFinger_;
N    tXY_t tXY[LOOSE_POSBUF_];
X    tXY_t tXY[(10 + 6)];
N    uint16_t vusS[LOOSE_POSBUF_];
X    uint16_t vusS[(10 + 6)];
N    uint16_t vusR[LOOSE_POSBUF_];
X    uint16_t vusR[(10 + 6)];
N    tRect_t rect[LOOSE_POSBUF_];
X    tRect_t rect[(10 + 6)];
N    uint16_t MaxDelta[LOOSE_POSBUF_];
X    uint16_t MaxDelta[(10 + 6)];
N} __PACKED tTempPos_t;
X} __attribute__ ((packed)) tTempPos_t;
N
Ntypedef struct
N{
N    uint8_t sFinger_;
N    tXY_t tXY[POSBUF_];
X    tXY_t tXY[10];
N    uint16_t vusS[POSBUF_];
X    uint16_t vusS[10];
N    uint16_t vusR[POSBUF_];
X    uint16_t vusR[10];
N} __PACKED tPastPos_t;
X} __attribute__ ((packed)) tPastPos_t;
N
Ntypedef struct
N{
N    uint8_t sFinger_;
N    tXY_t tXY[POSBUF_];
X    tXY_t tXY[10];
N    uint16_t vusS[POSBUF_];
X    uint16_t vusS[10];
N    uint16_t vusR[POSBUF_];
X    uint16_t vusR[10];
N} __PACKED tPastSentPos_t;
X} __attribute__ ((packed)) tPastSentPos_t;
N
Ntypedef struct
N{
N    uint8_t sFinger_;
N    tXY_t tXY[POSBUF_];
X    tXY_t tXY[10];
N} __PACKED tPredictPos_t;
X} __attribute__ ((packed)) tPredictPos_t;
N
Ntypedef struct
N{
N    uint8_t sFinger_;
N    tXY_t tXY[POSBUF_];
X    tXY_t tXY[10];
N    uint16_t vusS[POSBUF_];
X    uint16_t vusS[10];
N    uint16_t vusR[POSBUF_];
X    uint16_t vusR[10];
N    tRect_t rect[POSBUF_];
X    tRect_t rect[10];
N    uint16_t MaxDelta[POSBUF_];	
X    uint16_t MaxDelta[10];	
N#if (PalmCandidateTouchCut_EN == YES)
X#if (((1==0)) == (0==0))
S	tCell_t MaxPos[POSBUF_];
N#endif /* (PalmCandidateTouchCut_EN == YES) */	
N	uint16_t vusW[POSBUF_];
X	uint16_t vusW[10];
N    uint16_t vusH[POSBUF_];
X    uint16_t vusH[10];
N	
N		uint32_t uiDistance_All[POSBUF_];
X		uint32_t uiDistance_All[10];
N//		uint32_t uiDistance_P2P[POSBUF_];
N} __PACKED tPos_t;
X} __attribute__ ((packed)) tPos_t;
N
Ntypedef struct
N{
N    uint8_t sKey_;
N    int8_t cSingleKeyIdx;
N    uint16_t vusS[MAX_KEY_];
X    uint16_t vusS[(4)];
N} __PACKED tKey_t;
X} __attribute__ ((packed)) tKey_t;
N
N#endif /* __ALGORITHM_TYPES_H__ */
L 16 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm_baseline.h"
L 1 "..\..\App\Algorithm\Baseline\algorithm_baseline.h" 1
N/*
N * algorithm_baseline.h
N *
N *  Created on: 2015. 5. 6.
N *      Author: parkyj2
N */
N
N#ifndef __ALGORITHM_BASELINE_H__
N#define __ALGORITHM_BASELINE_H__
N
Ntypedef struct
N{
N	int8_t cNormalizeDelta;
N	bool_t bDSP_A;
N	uint8_t ucDiscardFrameNum;
N	uint8_t ucInitialFrameNum;
N    uint16_t usIIRCoef;
N
N    int16_t  sBlockPosThd;
N    int16_t  sBlockNegThd;
N
N    int16_t  sAccumPosSumThd;
N    int16_t  sAccumNegSumThd;
N    int16_t  sIdle_BlockPosThd;
N    int16_t  sIdle_BlockNegThd;
N    int16_t  sIdle_SeedThd;
N    int16_t  sIdle_PosTotalSumThd;
N    int16_t  sIdle_NegTotalSumThd;
N
N    int32_t  iRecalCond1_PosSum_Thd;
N    int32_t  iRecalCond1_AccSum_Thd;
N    int32_t  iRecalCond2_AccSum_Thd;
N    uint8_t  ucRecalCond1_WaitCnt;
N    uint8_t  ucRecalCond2_WaitCnt;	
N	bool_t   bFingerBaseTracking;
N	bool_t	 bFullFingerBaseTracking;
N} __PACKED tAlgorithmBaseLineConf_t;
X} __attribute__ ((packed)) tAlgorithmBaseLineConf_t;
N
Ntypedef struct
N{
N	uint8_t  ucLineFilter;
N	int16_t  sLineFilterUpLimit;
N	int16_t  sLineFilterLowLimit;
N	uint8_t  ucLineFilterColOffset;
N	uint8_t  ucMinDeltaTh;
N	int16_t  sLineFilterUpLimit_Idle;
N	int16_t  sLineFilterLowLimit_Idle;
N    uint8_t  ucFilterMaxRow;
N    uint8_t  ucFilterMaxCol;
N    uint8_t  ucFilterLocalRow;
N    uint8_t  ucFilterLocalCol;
N
N    uint8_t  ucFilterLocal_Min_Thd;
N    uint8_t  ucFilterLocal_Max_Thd;
N} __PACKED tAlgorithmSensingFilterConf_t;
X} __attribute__ ((packed)) tAlgorithmSensingFilterConf_t;
N
Ntypedef struct
N{
N	tRect_t     tValidRect;            			//  0, 0, 0
N    uint32_t    iGroupedCellCnt;       			//  4, 2, 1
N    int32_t     iMaxStrength;          			//  8, 4, 2
N    uint8_t     ucCoordiRowStart;      			// 12, 6, 3
N    uint8_t     ucCoordiColumnStart;  	 		// 13
N    uint16_t    usPenCalRangeThr;        		// 14, 7
N    uint8_t     ucRowCellMax;           		// 16, 8, 4
N    uint8_t     ucColumnCellMax;      	 		// 17
N    uint8_t     ucCurrentColumnStart;   		// 18, 9
N    uint8_t     ucCurrentColumnEnd;    		  // 19
N	
N    int iPosCnt;
N    int iPosSum;
N    int iNegCnt;
N    int iNegSum;
N
N    int iMinStrength;
N    tCell_t tMaxCellPos;						// 40,20,10
N	tCell_t tMinCellPos;						// 42,21,
N	
N	int16_t sPrevMaxDelta2;
N} __PACKED tOrigDeltaInfo_t;
X} __attribute__ ((packed)) tOrigDeltaInfo_t;
N
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
Stypedef struct
S{
S	uint32_t ulMaxNodeColIndex;
S	uint32_t ulMaxNodeRowIndex;
S	uint32_t ulMinNodeColIndex;
S	uint32_t ulMinNodeRowIndex;
S	int16_t sMaxStrength;
S	int16_t sMinStrength;
S
S	int16_t sPrevMaxStrength;
S	int16_t sPrevMinStrength;
S
S	int16_t sColumStrengthTotalSum;
S
S	bool_t bIsSendResumeSignal;
S
S} __PACKED tIdleDeltaInfo_t;
N#endif /* #if USED_IDLE_MODE_CONTROL */
N
Nextern void algorithm_baseline_init(void);
Nextern void algorithm_baseline_init_param(void);
Nextern void algorithm_baseline_init_FingerPoint(void);
Nextern void algorithm_baseline_tracking_initial(void);
N#if (USED_IDLE_MODE_CONTROL && !USED_NORMAL_NI_SENSING)
X#if (((1==0)) && !((1==0)))
Sextern void algorithm_baseline_tracking_initial_idle(bool_t bIsSkip);
N#endif /* (USED_IDLE_MODE_CONTROL && !USED_NORMAL_NI_SENSING) */
Nextern void algorithm_baseline_tracking_continuous(uint8_t mode);
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
Sextern void algorithm_baseline_tracking_continuous_idle(void);
N#endif /* USED_IDLE_MODE_CONTROL */
Nextern void algorithm_baseline_tracking_continuous_local_finger(void);
Nextern bool_t algorithm_baseline_calculate_delta(int mode);
Nextern bool_t algorithm_baseline_calculate_delta_localFinger(int mode);
N#if USED_NORMAL_NI_SENSING
X#if ((1==0))
Sextern void algorithm_baseline_calculate_delta_ni(void);
N#endif /* USED_NORMAL_NI_SENSING */
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
Sextern void algorithm_baseline_calculate_delta_idle(void);
N#endif /* USED_IDLE_MODE_CONTROL */
N//extern bool_t algorithm_baseline_calculate_delta_DSP(int mode);
N//extern void algorithm_baseline_extract_max_delta(void); //NOTE : warning!!
Nextern bool_t algorithm_local_baseline_calculate_delta(int mode);
Nextern bool_t abnormal_rawdata_temp(bool_t SET);
Nextern bool_t abnormal_rawdata_detection_for_hopping(bool_t SET); //NOTE : warning!!
Nextern void algorithm_baseline_calculate_mux_range(int r, int c);
N
N#endif /* __ALGORITHM_BASELINE_H__ */
L 17 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm_label.h"
L 1 "..\..\App\Algorithm\Label\algorithm_label.h" 1
N/*
N * algorithm_label.h
N *
N *  Created on: 2015. 5. 6.
N *      Author: parkyj2
N */
N
N#ifndef __ALGORITHM_LABEL_H__
N#define __ALGORITHM_LABEL_H__
N
Ntypedef struct
N{
N	uint16_t usSeedBase;
N	uint8_t  ucSeedSlope;
N	uint8_t  ucLabelNoiseThd;
N	bool_t   bExpand;
N	bool_t   bSplitSearchDirc_4_On;
N	uint16_t usSmallNodeCnt;
N	uint16_t usMediumNodeCnt;
N	uint8_t  ucMergeSmallThdPer;
N	uint8_t  ucMergeMediumThdPer;
N	uint8_t  ucMergeSmallDiagThdPer;
N	uint8_t  ucMergeMediumDiagThdPer;
N
N	uint16_t usLocalSeedBase;
N	uint8_t  ucLocalSeedSlope;
N	uint16_t usLocalSmallNodeCnt;
N	uint16_t usLocalMediumNodeCnt;
N	uint8_t  ucLocalMergeSmallThdPer;
N	uint8_t  ucLocalMergeMediumThdPer;
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	uint16_t usLabelPeakValleyDiffTh;
S	uint16_t usLabelPeakDiffTh;
S	uint16_t usMergeLabelSizeTh;
N#endif /* USED_NOISE_HOPPING_FREQ */
N} __PACKED tAlgorithmLabelConf_t;
X} __attribute__ ((packed)) tAlgorithmLabelConf_t;
N
Ntypedef union
N{
N	struct
N	{
N		uint32_t BF       : LOOSE_POSBUF_;
X		uint32_t BF       : (10 + 6);
N		uint32_t NUM      : 8;
N		uint32_t Reserved : 7;
N		uint32_t SET      : 1;
N	} __PACKED tInfo;
X	} __attribute__ ((packed)) tInfo;
N
N	uint32_t ulValue;
N} __PACKED tConflictInfo_t;
X} __attribute__ ((packed)) tConflictInfo_t;
N
Ntypedef struct
N{
N	int8_t   cId;
N	tRect_t  tRect;
N	uint16_t usCellNum;
N	int16_t sMaxCellVal;
N	tCell_t  tMaxCell;
N	tXY_t    tCoord;
N	uint32_t ulStrength;
N	uint32_t ulExtStrength;
N
N	tConflictInfo_t tConflictInfo;
N
N	uint32_t * ptListHead;
N	uint32_t * ptListTail;
N} __PACKED tLabelTable_t;
X} __attribute__ ((packed)) tLabelTable_t;
N
N#define BOUNDARY_4_SEARCH_DIRECTION		4
N#define BOUNDARY_8_SEARCH_DIRECTION		8
N
Ntypedef struct
N{
N	uint8_t Num;
N	tCell_t Table[BOUNDARY_4_SEARCH_DIRECTION];
X	tCell_t Table[4];
N} __PACKED t4SearchInfo_t;
X} __attribute__ ((packed)) t4SearchInfo_t;
N
Ntypedef struct
N{
N	uint8_t Num;
N	tCell_t Table[BOUNDARY_8_SEARCH_DIRECTION];
X	tCell_t Table[8];
N} __PACKED t8SearchInfo_t;
X} __attribute__ ((packed)) t8SearchInfo_t;
N
Ntypedef struct
N{
N	uint8_t	ucNum;
N	tLabelTable_t tTable[LOOSE_POSBUF_];
X	tLabelTable_t tTable[(10 + 6)];
N	uint8_t ucValidNum;
N	tRect_t tValidRect[LOOSE_POSBUF_];
X	tRect_t tValidRect[(10 + 6)];
N	tCell_t tValidMaxPos[LOOSE_POSBUF_];
X	tCell_t tValidMaxPos[(10 + 6)];
N	int16_t sValidMaxVal[LOOSE_POSBUF_];
X	int16_t sValidMaxVal[(10 + 6)];
N	uint16_t usValidCellCnt[LOOSE_POSBUF_];
X	uint16_t usValidCellCnt[(10 + 6)];
N	uint8_t PalmTouchDownCnt;
N	int32_t LabelSplitCnt;
N//	int32_t LabelNearbyCnt;
N	int16_t LabelSplitMergeCnt;
N	int32_t LabelSplitFrmCnt;
N	uint16_t uValidLabelNum;
N	int32_t iMergeThdPer;
N	uint8_t ucPalmCnt;
N} __PACKED tLabelInfo_t;
X} __attribute__ ((packed)) tLabelInfo_t;
N
Ntypedef struct
N{
N    int16_t     cId;             						  //  0, 0, 0
N    tRect_t     tValidRect;       						//  2, 1, 0
N    uint16_t    usValidCellCnt;   						//  6, 3, 0
N    int16_t     sValidMaxVal;     						//  8, 4, 2
N    tCell_t     tValidMaxPos;     						// 10, 5, 0
N    tXY_t       tCoord;           						// 12, 6, 3
N    uint32_t    ulStrength;       						// 20, 10, 5
N    uint32_t    ulExtStrength;   						  // 24, 12, 6
N} __PACKED tPenLabelInfo_t;    // 28, 14, 7
X} __attribute__ ((packed)) tPenLabelInfo_t;    
N
N#define LABEL_INFO_SIZE    sizeof(tPenLabelInfo_t)
N	
Nextern void algorithm_label_init(void);
Nextern void algorithm_label_process(int mode);
N
N#endif /* __ALGORITHM_LABEL_H__ */
L 18 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm_coord.h"
L 1 "..\..\App\Algorithm\Coord\algorithm_coord.h" 1
N/*
N * algorithm_coord.h
N *
N *  Created on: 2015. 5. 11.
N *      Author: parkyj2
N */
N
N#ifndef ALGORITHM_COORD_H_
N#define ALGORITHM_COORD_H_
N
N#define COORD_HISTORY_NUM		5
N
N#define PAST_COORD_HISTORY_NUM	19
N
N////////////////////////LBJ_CHECK//////////////////////////
N//#define DSP_SMOOTH_GRADIENT	1   		//Gradient  smoothing     ,  smoothing 
N//#define RATE_UP_EN 1		    		//Pen Frame Rate Up Sampling 240 -> 360Hz       (latancy) 
N//#define TILT_ON 1		    			//Tilt  /    PARTIAL_PEN_COORD2 scan  
N
N#ifdef TILT_ON
S#define DSP_SMOOTH_PASTPOS	1 
S#define TILT_SMOOTHING	1
S#define TILT_AREA_FILTER	1
S#define Pen2ReportMethod	1 //0 : All Original, 1 : Pen2 Prediction, 2 : Smoothing of Pen2 prediction, 3 : Pen2 Skip (180hz) 
N#else
N#ifndef COVER_GLASS_USE
N#define DSP_SMOOTH_PASTPOS	1 			//original or past   moving averaging     past 
N#endif
N#endif
N
N#define PenFingerSameLineNoiseException 1
N////////////////////////LBJ_CHECK//////////////////////////
N
Ntypedef struct
N{
N	uint16_t usDistThdMovingToStationary;
N	uint16_t usDistThdStationaryToMoving;
N	uint32_t lMoveSmoothingLevel;
N#if (VECTOR_PREDICTION_EN == YES)
X#if (((1==0)) == (0==0))
S	uint8_t ucVectorPredictionCoef;
N#endif
N#if (INTERPOLATION_VER1_En == YES || INTERPOLATION_VER2_En == YES ||INTERPOLATION_VER3_En == YES)
X#if (((1==0)) == (0==0) || ((1==0)) == (0==0) ||((1==0)) == (0==0))
S	uint8_t	ucFullFingerInterpolation_On;
S	int16_t sInterpolationWeight;
N#endif
N	uint8_t ucFirstMoveEventTHD;
N	uint8_t ucMoveEventTHD;
N	int16_t sFingerGlobalCoordiXResolutionOffset;
N	int16_t sFingerGlobalCoordiYResolutionOffset;
N	int16_t sFingerGlobalCoordiOffsetX;
N	int16_t sFingerGlobalCoordiOffsetY;
N#if (FingerGlobalCoordiY_2Region_Set == YES)
X#if (((1==0)) == (0==0))
S	int16_t sFingerGlobalCoordiY_2Region_boundary;
S	int16_t sFingerGlobalCoordiYResolutionOffset1;
S	int16_t sFingerGlobalCoordiOffsetY1;
N#endif
N#if (SMOOTH_PASTORG_INTER_EN == YES)
X#if (((1==0)) == (0==0))
S	uint8_t ucSmoothPastOrgInter;
N#endif
N	int16_t  cDisSmoothOffset;
N	bool_t bFingerMeanSmoothing;
N#if (USED_DRUM_ALGO == YES)
X#if (((1==0)) == (0==0))
S	uint16_t usDrumTestDist;
N#endif
N	uint8_t ucWinCertAssistance;
N	uint8_t ucWinCertModeDebCnt;
N	uint8_t ucWinCertModeVectorPredictionCoef;
N	uint8_t ucTouchCountMax;
N	uint8_t ucMaxExtendFrameNum;
N	uint16_t usFirstDrawingThd;
N	uint8_t ucFirstDrawingCellCnt;
N	bool_t bSwapXY;
N	bool_t bFlipX;
N} __PACKED tAlgorithmCoordConf_t;
X} __attribute__ ((packed)) tAlgorithmCoordConf_t;
N
Ntypedef struct
N{
N	uint8_t  ucDynamicTrackingDistanceMode;
N	uint8_t  ucFastDrawingMode;
N	uint16_t usMoveDistanceThd;
N	uint16_t usFirstMoveDistanceThd;
N	uint32_t lLargeTouchOnThd;
N	uint8_t	ucLargeTouchOnDebCnt;
N	uint32_t lMediumTouchOnThd;
N	uint8_t	ucMediumTouchOnDebCnt;
N	uint32_t lSmallTouchOnThd;
N	uint8_t	ucSmallTouchOnDebCnt;
N	bool_t  bEdgeDebCntUp;
N	int16_t sFirstTouchOnMaxCellVal;
N	uint32_t lTouchOffThd;
N	uint8_t  ucMultifingerFirstTouchThDownOffset;
N	uint32_t usCenterMatchDistanceThd;
N	int16_t sFirstTouchEnable1Touch;
N	int16_t sFirstTouchEnable2Touch;
N	int16_t sFirstTouchEnable3Touch;
N	int16_t sFirstTouchEnable4Touch;
N	int16_t sFirstTouchEnable5Touch;
N	uint8_t ucDebCntInner;
N	uint8_t ucDebCntEdge;
N} __PACKED tAlgorithmCoordTrackingConf_t;
X} __attribute__ ((packed)) tAlgorithmCoordTrackingConf_t;
N
Ntypedef struct
N{
N	bool_t  bExpectClipping_Finger_On;
N	int8_t  cEdgeSmoothing_Finger_On;
N#if (REMOVE_EDGE_EN == YES)
X#if (((1==0)) == (0==0))
S	bool_t	bRemoveEdge;
S	uint16_t usRemoveEdgeXdistThd;
S	uint16_t usRemoveEdgeYdistThd;
S	bool_t  bUsetRealPastSentPos1;
S	uint8_t  ucRemoveEdgeVer;
N#endif
N	uint16_t usPostProcessEdgeTH;
N	uint8_t ucPostProcessDisTH;
N	uint8_t ucPostProcessExpendDiv;
N	int8_t cPostProcessEndMargin;
N	bool_t bPostProcessInterpolationMode;
N	uint16_t usOutInDrawEdgeTh;
N	uint8_t ucOutInDrawDisTh;
N	bool_t bUseNewCippingCond;
N} __PACKED tAlgorithmCoordEdgeConf_t;
X} __attribute__ ((packed)) tAlgorithmCoordEdgeConf_t;
N
Ntypedef struct
N{
N#if (MULTI_EDGE_COEF_EN == YES)
X#if (((1==0)) == (0==0))
S	bool_t bUseMultiEdgeCoef;
S	uint16_t usSmallTouchMaxDeltaThd;
S	uint8_t ucSmallTouchCellCntThd;
S	uint8_t ucSmallTouchHeightThd;
S	uint8_t ucSmallTouchWidthThd;
N#endif
N	uint8_t ucLeftEdgeExpand;
N    uint8_t ucRightEdgeExpand;
N    uint8_t ucTopEdgeExpand;
N    uint8_t ucBottomEdgeExpand;	
N#if (MULTI_EDGE_COEF_EN == YES)
X#if (((1==0)) == (0==0))
S	uint8_t ucLeftEdgeExpand_small;
S    uint8_t ucRightEdgeExpand_small;
S    uint8_t ucTopEdgeExpand_small;
S    uint8_t ucBottomEdgeExpand_small;
S	uint8_t ucLeftEdgeExpand_medium;
S    uint8_t ucRightEdgeExpand_medium;
S    uint8_t ucTopEdgeExpand_medium;
S    uint8_t ucBottomEdgeExpand_medium;
N#endif
N	int16_t sXExpandStartOffset;
N	int16_t sYExpandStartOffset;
N	uint16_t usLabelEdgeExpandMode;
N	uint16_t usLeftEdgeExpand_Offset;
N	uint16_t usRightEdgeExpand_Offset;
N	uint16_t usTopEdgeExpand_Offset;
N	uint16_t usBottomEdgeExpand_Offset;
N	uint16_t usLeftEdgeExpand_Scale;
N	uint16_t usRightEdgeExpand_Scale;
N	uint16_t usTopEdgeExpand_Scale;
N	uint16_t usBottomEdgeExpand_Scale;
N#if (BIG_FINGER_EDGE_EXPAND_ALGO_EN == YES)
X#if (((1==0)) == (0==0))
S	uint16_t usLeftEdgeExpand_MaxD;
S	uint16_t usRightEdgeExpand_MaxD;
S	uint16_t usTopEdgeExpand_MaxD;
S	uint16_t usBottomEdgeExpand_MaxD;
S	uint16_t usBigFingerEdgeExpandParam1;
S	uint16_t usBigFingerEdgeExpandParam2;
S	uint16_t usBigFingerEdgeExpandParam3;
N#endif
N#if (BIG_FINGER_EDGE_ACC_TEST_ALGO_EN == YES)
X#if (((1==0)) == (0==0))
S	uint8_t  ucEdgeReportDelayCnt;
S	uint16_t usBigFingerEdgeTest_MoveEventTHD_X;
S	uint16_t usBigFingerEdgeTest_MoveEventTHD_Y;
S	uint16_t usBigFingerEdgeTestClippingTop		;	
S	uint16_t usBigFingerEdgeTestClippingBottom	;	
S	uint16_t usBigFingerEdgeTestClippingLeft	;	
S	uint16_t usBigFingerEdgeTestClippingRight	;	
S	bool_t   bFingerCornerTestClippingOn;
N#endif
N	bool_t bDoNotExpandPos;
N} __PACKED tAlgorithmdEdgeExpandConf_t;
X} __attribute__ ((packed)) tAlgorithmdEdgeExpandConf_t;
N
Ntypedef struct
N{
N	uint8_t ucPalmDetectionOn;
N	uint16_t usPalmLevel;
N#if (PalmFirstDetectionShift == YES)
X#if (PalmFirstDetectionShift == (0==0))
S	uint8_t ucPalmLevelShift;
N#endif
N	uint8_t ucPalm_PALM_CONNECT_DIST;
N	uint8_t ucPalm_PALM_REGION_UPDATE_PERIOD;
N	uint8_t ucPalm_TOUCHDOWNFRAMEMAX;
N	uint8_t ucPalm_TOUCHDOWNSLOPETHRESHOLD;
N	uint8_t ucPalm_IGNOREFRAMENUM;
N	uint8_t ucPalm_KEEPPALMREGIONFRAME;
N#if (PalmDrawingOn_En == YES)
X#if (((1==0)) == (0==0))
S	uint8_t ucPalmDrawingOn;
N#endif
N	bool_t bPalm_WholeTouchRemove;
N#if (PalmCandidateTouchCut_EN == YES)
X#if (((1==0)) == (0==0))
S	uint16_t usPalmCandiStdTh;
S	uint8_t ucPalmCandiShapeMatchingTh;
S	uint8_t ucPalmCandiDeltaTh;
S	uint8_t ucPalmCandiShapeMatchingLearning;
N#endif
N} __PACKED tAlgorithmPalmConf_t;
X} __attribute__ ((packed)) tAlgorithmPalmConf_t;
N
Ntypedef struct
N{
N	// Coord Buffer define
N	tTempPos_t     tTempPos;
N	tPos_t         tPos;
N	tPredictPos_t  tFirstPos;
N	tPredictPos_t  tPredictPos;
N	tPredictPos_t  tAvgPos;
N	tPastPos_t     tPastPos[5];
N//	tPastPos_t     tOrgPosHist[COORD_HISTORY_NUM];
N	tPos_t         tOrgPos;
N	tPastPos_t     tOrgPastPos[5];
N	tPastSentPos_t tPastSentPos;
N	tPastSentPos_t tRealPastSentPos;
N	tPastSentPos_t tRealPastSentPos1;
N
N	int32_t slScaledMoveDistThd;
N	uint8_t	ucIdMappedCnt[POSBUF_];
X	uint8_t	ucIdMappedCnt[10];
N
N	int8_t cScreenDebCnt[POSBUF_];
X	int8_t cScreenDebCnt[10];
N	int8_t cScreenTouchOffDebCnt[POSBUF_];
X	int8_t cScreenTouchOffDebCnt[10];
N
N	bool_t ucPostProcessRun[POSBUF_];	// 1 : First Coordinate, 2 : Last Coordinate
X	bool_t ucPostProcessRun[10];	
N
N	int8_t cRemap[LOOSE_POSBUF_];
X	int8_t cRemap[(10 + 6)];
N	int32_t lPrevDist[POSBUF_];
X	int32_t lPrevDist[10];
N	bool_t bFirstLongDistanceMoved[POSBUF_];
X	bool_t bFirstLongDistanceMoved[10];
N
N	int iXOffset;
N	int iYOffset;
N	int iInternalXRes;
N	int iInternalYRes;
N
N	int iXExpandStart;
N	int iYExpandStart;
N
N	int iXEdgeStart;
N	int iYEdgeStart;
N
N	tKey_t tKey;
N//	tKey_t tPastKey;
N	tKey_t tPastSentKey;
N
N//	int8_t cKeyDebCnt[MAX_KEY_];
N//	int8_t cKeyTouchOffDebCnt[MAX_KEY_];
N	
N	bool_t bIsMoving[POSBUF_];
X	bool_t bIsMoving[10];
N	int8_t cIsbefor[POSBUF_];
X	int8_t cIsbefor[10];
N	tXY_t iStopPos[POSBUF_];
X	tXY_t iStopPos[10];
N	uint16_t RealMaxDelta[LOOSE_POSBUF_];
X	uint16_t RealMaxDelta[(10 + 6)];
N	uint16_t PrevRealMaxDelta[LOOSE_POSBUF_];
X	uint16_t PrevRealMaxDelta[(10 + 6)];
N	uint8_t VirtualEndCount[POSBUF_];
X	uint8_t VirtualEndCount[10];
N	uint8_t DrawingFlag[LOOSE_POSBUF_];
X	uint8_t DrawingFlag[(10 + 6)];
N	uint8_t ucEdgeExpandCoef[LOOSE_POSBUF_];
X	uint8_t ucEdgeExpandCoef[(10 + 6)];
N#if (REMOVE_EDGE_EN == YES)
X#if (((1==0)) == (0==0))
S	bool_t bRemoveEdge[LOOSE_POSBUF_];
N#endif
N#if (INTERPOLATION_VER1_En == YES || INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES)
X#if (((1==0)) == (0==0) || ((1==0)) == (0==0) || ((1==0)) == (0==0))
S	bool_t bInterpolation_On;
N#endif
N} __PACKED tCoordInfo_t;
X} __attribute__ ((packed)) tCoordInfo_t;
N
Ntypedef struct
N{
N    int16_t rs;
N    int16_t re;
N    int16_t cs;
N    int16_t ce;
N} __PACKED tRect16_t;
X} __attribute__ ((packed)) tRect16_t;
N
Ntypedef struct
N{
N    tXY_t       tXY;              				//  0,  0,  0
N    uint16_t    vusS;            				//  8,  4,  2
N    uint16_t    vusR;            				// 10,  5,
N    tRect16_t   rect;           				// 12,  6,  3
N    uint16_t    MaxDelta;         				// 20, 10,  5
N    int16_t     reserved;						// 22, 11,
N} __PACKED tPenPos_t;      		// 24, 12,  6
X} __attribute__ ((packed)) tPenPos_t;      		
N
Ntypedef struct
N{
N    tXY_t       tXY;             				//  0,  0,  0
N    uint16_t    vusS;            				//  8,  4,  2
N    uint16_t    vusR;            				// 10,  5,
N} __PACKED tPenSimplePos_t;		// 12,  6,  3
X} __attribute__ ((packed)) tPenSimplePos_t;		
N
Ntypedef struct
N{
N	tPenPos_t       tPos;            			//  0,  0,  0
N	tXY_t           tFirstPos;        			// 24, 12,  6
N	tXY_t           tAvgPos;          			// 32, 16,  8
N	tPenSimplePos_t tPastPos[2];				// 40, 20, 10
N	tPenPos_t       tOrgPos;        			// 64, 32, 16 
N	tPenSimplePos_t tOrgPastPos[2]; 			// 88, 44, 22
N	tPenSimplePos_t tPastSentPos;    			// 112, 56, 28
N	uint8_t         ucIdMappedCnt;   			// 124, 62, 31
N	uint8_t         ucPostProcessRun;			// 125,
N	uint8_t bFirstLongDistanceMoved; 			// 126, 63,
N	uint8_t			ucReserved;					// 127,
N	tPenSimplePos_t tPastPos2;					// 128, 64, 32
N	tPenSimplePos_t tOrgPastPos2;				// 140, 70, 35
N	tXY_t tPastPosHist[23];						// 152, 76, 38
N} __PACKED tPenCoordInfo_t;    	// 344, 172, 84	
X} __attribute__ ((packed)) tPenCoordInfo_t;    	
N
Ntypedef struct
N{
N	uint16_t top_th;							//  0,  0,  0
N	uint8_t top_mul;							//  2,  1,
N	uint8_t top_SR;								//  3,
N	uint16_t bottom_th;							//  4,  2,  1
N	uint8_t bottom_mul;							//  6,  3,
N	uint8_t bottom_SR;							//  7,
N	uint16_t left_th;							//  8,  4,  2
N	uint8_t left_mul;							// 10,  5,
N	uint8_t left_SR;							// 11,
N	uint16_t right_th;							// 12,  6,  3
N	uint8_t right_mul;							// 14,  7,
N	uint8_t right_SR;							// 15,
N	uint16_t top_hover_th;						// 16,  8,  4
N	uint8_t top_hover_mul;						// 18,  9,
N	uint8_t top_hover_SR;						// 19,
N	uint16_t bottom_hover_th;					// 20, 10,  5
N	uint8_t bottom_hover_mul;					// 22, 11,
N	uint8_t bottom_hover_SR;					// 23,
N	uint16_t left_hover_th;						// 24, 12,  6
N	uint8_t left_hover_mul;						// 26, 13,
N	uint8_t left_hover_SR;						// 27,
N	uint16_t right_hover_th;					// 28, 14,  7
N	uint8_t right_hover_mul;					// 30, 15,
N	uint8_t right_hover_SR;						// 31,
N	uint8_t side_mul_val;						// 32, 16,  8
N	uint8_t edge_mul_val;						// 33
N	int8_t odd_set_mul_val;						// 34, 17
N	int8_t even_set_mul_val;					// 35
N	uint8_t hover_side_mul_val;					// 36, 18,  9
N} __PACKED tEdgePen_t;			// 37
X} __attribute__ ((packed)) tEdgePen_t;			
N
Ntypedef struct
N{									//8bit  //32bit
N	int32_t TILT_sx;						//0
N	int32_t TILT_sy;						//1
N	int32_t TILT_distance;					//2
N	int32_t TILT_theta;						//3
N	int32_t TILT_H;							//4
N	int32_t HID_TILT_X;						//5
N	int32_t HID_TILT_Y;						//6
N	int32_t HID_TWIST;						//7
N	int32_t HID_AZIMUTH;					//8
N	int32_t HID_ALTITUDE;					//9
N	int32_t PastAzimuth;					//10
N	int32_t PastAltitude;					//11
N	tXY_t	Smooth_PastTilt;				//12
N	tXY_t	Area_PastTilt;					//14
N	int8_t 	TiltUpDownST_x;			//64	//16
N	int8_t 	TiltUpDownST_y;			//65
N}__attribute__ ((packed))tHidTiltInfo_t;
N
Ntypedef struct
N{
N	uint8_t th0;								
N	int8_t top_mul0;							
N	uint8_t top_SR0;									
N	uint8_t top_size_th;						
N	uint8_t top_apply_th;						
N	int8_t bottom_mul0;							
N	uint8_t bottom_SR0;							
N	uint8_t bottom_size_th;						
N	uint8_t bottom_apply_th;					
N	int8_t left_mul0;							
N	uint8_t left_SR0;							
N	uint8_t left_size_th;						
N	uint8_t left_apply_th;						
N	int8_t right_mul0;							
N	uint8_t right_SR0;							
N	uint8_t right_size_th;						
N	uint8_t right_apply_th;							
N	uint16_t top_max_sum;
N	uint16_t bottom_max_sum;
N	uint16_t left_max_sum;
N	uint16_t right_max_sum;
N	uint16_t top_max_sum_corner;
N	uint16_t bottom_max_sum_corner;
N	uint16_t left_max_sum_corner;
N	uint16_t right_max_sum_corner;
N	uint16_t top_max_sum_Big;
N	uint16_t bottom_max_sum_Big;
N	uint16_t left_max_sum_Big;
N	uint16_t right_max_sum_Big;
N	uint8_t  corner_size_th;
N}__attribute__ ((packed))tAlgorithmParaEdgeConf_t;		
N
Nextern tXY_t tPastPosHist[PAST_COORD_HISTORY_NUM];					 
Xextern tXY_t tPastPosHist[19];					 
N
N#define COORD_INFO_SIZE    sizeof(tPenCoordInfo_t)
N	
Nextern void algorithm_coord_init(void);
Nextern void algorithm_coord_init_param(void);
Nextern void algorithm_coord_initialise_pos_buffer(void);
N//extern void algorithm_coord_compensation(int mode);
Nextern void algorithm_coord_process(int mode);
Nextern void algorithm_coord_modify_pos(tXY_t* pos);
Nextern int32_t algorithm_coord_calc_distance(tXY_t pos1, tXY_t pos2);
Nextern int32_t algorithm_coord_calc_comp_distance(tXY_t pos1, tXY_t pos2, tXY_t comp);
Nextern void alogorithm_coord_modify_pos(tXY_t* old_pos,tXY_t* pos, int index);
Nextern void algorithm_coord_UpdatePosHistoryInfo(void);
Nextern void algorithm_coord_interpolation(uint8_t ver);
Nextern void algorithm_coord_interpolation_v02(uint8_t ver);
N
N#endif /* ALGORITHM_COORD_H_ */
L 19 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm_noise.h"
L 1 "..\..\App\Algorithm\Noise\algorithm_noise.h" 1
N/*
N * algorithm_noise.h
N *
N *  Created on: 2015. 6. 17.
N *      Author: parkyj2
N */
N
N#ifndef __ALGORITHM_NOISE_H__
N#define __ALGORITHM_NOISE_H__
N
Ntypedef struct
N{
N	uint8_t  	ucNoiseDetectionMode;
N	uint8_t  	ucDiscardFrameNum;
N	uint8_t  	ucCellCntThd;
N	uint8_t  	ucHoppingThd;
N	uint16_t 	usRawDataThd;
N	int16_t  	sDeltaDataThd;
N	uint8_t 	ucErrorFrameProcess;
N	uint8_t 	ucHoppingMoveDistanceThd;
N	uint8_t 	ucNoiseDetectMaxType;
N	bool_t 		bInitAddHoppingThd;
N	uint8_t 	ucNoiseStartThd;
N	uint8_t 	ucNoiseStartCntThd;
N} __PACKED tAlgorithmNoiseConf_t;
X} __attribute__ ((packed)) tAlgorithmNoiseConf_t;
N
Ntypedef struct
N{
N	uint8_t  ucInitFCnt;
N	uint8_t  ucFCnt;
N	uint8_t  ucBCnt;
N	uint8_t  ucPrevFinger;
N	uint8_t  ucPrevHoppingMode;
N	uint16_t usPrevMaxVal;
N	uint32_t ulSumMaxDiff;
N	uint16_t usMaxValBuf[NOISE_DETECTION_FRAME_NUM];
X	uint16_t usMaxValBuf[20];
N	uint8_t  ucTouchNumBuf[NOISE_DETECTION_FRAME_NUM];
X	uint8_t  ucTouchNumBuf[20];
N	uint8_t  ucNoiseFrameCnt;	
N	bool_t   ucSetHoppingReady;
N	uint8_t  ucDebug;
N	uint8_t  NoiseFlag;
N	uint16_t usPrevMaxVal_NI;
N	uint16_t niMaxStrength;
N	uint32_t ulSumMaxDiff_NI;
N	uint16_t usMaxValBuf_NI[NOISE_DETECTION_FRAME_NUM];
X	uint16_t usMaxValBuf_NI[20];
N	bool_t 	 bDetectStart;
N	uint8_t  ucTouchOffCnt;
N} __PACKED tNoiseInfo_t;
X} __attribute__ ((packed)) tNoiseInfo_t;
N
Ntypedef enum
N{
N    NOISE_NONE,
N    NOISE_FREQ_HOPPING,
N    NOISE_PARAM_RESETTING
N} __PACKED eNoiseStatus_t;
X} __attribute__ ((packed)) eNoiseStatus_t;
N
Ntypedef enum {
N	FREQ_UNKNOWN = 0,
N	FREQ_MAIN    = 1,
N	FREQ_HOPP1	 = 2,
N	FREQ_HOPP2	 = 3,
N} __PACKED eSelectFREQ;
X} __attribute__ ((packed)) eSelectFREQ;
N
N//typedef enum
N//{
N//    ALGORITHM_NORMAL = 0,
N//    ALGORITHM_NOISE,
N//    ALGORITHM_LIMIT
N//} __PACKED eChangeAlgorithmMode_t;
N
Ntypedef enum
N{
N    FREQ_HOPPING_NONE,
N    FREQ_HOPPING_CHANGED
N} __PACKED eHoppingStatus_t;
X} __attribute__ ((packed)) eHoppingStatus_t;
N
Nextern void algorithm_noise_init(void);
Nextern void algorithm_noise_process(eSENSING_MODE_t eSensingMode);
Nextern bool_t algorithm_noise_detect(void);
Nextern bool_t algorithm_Check_FreqHopping(void);
N
N#endif /* __ALGORITHM_NOISE_H__ */
L 20 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm_conf.h"
L 1 "..\..\App\Algorithm\algorithm_conf.h" 1
N/*
N * algorithm_conf.h
N *
N *  Created on: 2015. 3. 19.
N *      Author: parkyj2
N */
N
N#ifndef __ALGORITHM_CONF_H__
N#define __ALGORITHM_CONF_H__
N
N/*
N * Types
N */
Ntypedef struct
N{
N	uint8_t ucMaxTouch_;
N	uint8_t ucLabelSearchDir;
N    int iXResolution;
N    int iYResolution;
N    int iXEdgeNum;
N    int iXEdgeDen;
N    int iYEdgeNum;
N    int iYEdgeDen;
N    uint8_t ucLeftEdgeExpand_local;
N    uint8_t ucRightEdgeExpand_local;
N    uint8_t ucTopEdgeExpand_local;
N    uint8_t ucBottomEdgeExpand_local;
N	
N    uint8_t ucXClipping;
N    uint8_t ucYClipping;
N	uint8_t ucClippingLeft;
N	uint8_t ucClippingRight;
N	uint8_t ucClippingTop;
N	uint8_t ucClippingBottom;
N    uint16_t usPanelXSizeInDmm;
N    uint16_t usPanelYSizeInDmm;
N	
N    __ALIGNED4 tEdgePen_t tEdgePenSetVal;
X    __attribute__ ((aligned(4))) tEdgePen_t tEdgePenSetVal;
N
N} __PACKED tAlgorithmCommonConf_t;
X} __attribute__ ((packed)) tAlgorithmCommonConf_t;
N
N
Ntypedef struct
N{
N	tAlgorithmBaseLineConf_t 									BaseLine;	
N	tAlgorithmSensingFilterConf_t								SensingFilter;
N	tAlgorithmLabelConf_t 										Label;
N	tAlgorithmCoordConf_t 										Coord;
N	tAlgorithmCoordTrackingConf_t 								CoordTracking;
N	tAlgorithmCoordEdgeConf_t 									CoordEdge;
N	tAlgorithmdEdgeExpandConf_t 								EdgeExpand;
N	__attribute__ ((aligned(4)))tAlgorithmParaEdgeConf_t ParaEdgeSetVal;
N	
N#if (USED_NOISE_HOPPING_FREQ || LGD_ERROR_FRAME_PROCESS_EN)
X#if (((1==0)) || ((1==0)))
S	tAlgorithmNoiseConf_t Noise;
N#endif /* (USED_NOISE_HOPPING_FREQ || LGD_ERROR_FRAME_PROCESS_EN) */
N
N	tAlgorithmPalmConf_t Palm;
N
N//	uint8_t ucValidRadiusRatio;
N//	int iValidStrengthRatio;
N
N	uint16_t usIdleTouchThd;
N} __PACKED tAlgorithmModeConf_t;
X} __attribute__ ((packed)) tAlgorithmModeConf_t;
N
Ntypedef struct
N{
N	uint8_t ucCoordiRowStart;
N	uint8_t ucCoordiColumnStart;
N	uint8_t ucCurrentColumnStart;
N	uint8_t ucCurrentColumnEnd;
N
N	uint8_t ucHover_cnt;
N	bool_t bPenContact;
N	bool_t bPrevPenContact;
N} __PACKED tPenInfo_t;
X} __attribute__ ((packed)) tPenInfo_t;
N
Ntypedef struct
N{
N//	uint8_t ucCol;
N//	uint8_t ucRow;
N//
N//	uint8_t ucTxLessCol;
N//	uint8_t ucTxLessRow;
N//
N//	uint8_t ucScreenCol;
N//	uint8_t ucScreenRow;
N
N	// baseline tracking
N	bool_t bBlockTracking;
N
N    bool_t bIsRecalCond;
N    bool_t bIsRecalCond2;
N    int iRecalCondCnt;
N    int iRecalCond2Cnt;
N
N#if USED_ESD_RECOVERY_CODE
X#if ((1==0))
S	uint16_t usAbnormalRawdataNodeCnt;		// Count node that raw data is 4095
S	uint16_t usAbnormalRawdataNodeNum;		// Number of node that raw data is 4095
S	uint16_t usAbnormalRawdataFrameCnt1;	// Check node that raw data is 4095
S	uint16_t usAbnormalRawdataFrameCnt2;	// Check node that raw data is less than MINRAWDATA_MARGIN
N#endif /* USED_ESD_RECOVERY_CODE */ 
N
N#if USED_RF_NOISE_RECOVERY_CODE
X#if ((1==0))
S	uint16_t usDebounceFrmaeCnt;			// Count frame for debounce touch
S	uint16_t usAbnormalDeltaNodeCnt;		// Count node that delta data is greater than ABNORMAL_DELTA_PLUS_CNT_THD 
S	uint16_t usAbnormalDeltaFrameCnt1;		// Check node that delta data is greater than ABNORMAL_DELTA_PLUS_CNT_THD or less than ABNORMAL_DELTA_MINUS_CNT_THD
S	uint16_t usAbnormalDeltaFrameCnt2;		// Check node that delta data is greater than ABNORMAL_DELTA_THD_FOR_RECAL
N#endif /* USED_RF_NOISE_RECOVERY_CODE */
N
N//    bool_t bDropStatus;
N//    bool_t bRecalFlag;
N
N//    bool_t bDoNotExpandPos;
N
N    // feature info of delta Orig. Image
N    tOrigDeltaInfo_t tDelta;
N    // Label Variable List
N    tLabelInfo_t tLabel;
N
N    tCoordInfo_t tCoord;
N
N    __ALIGNED4 tOrigDeltaInfo_t tDelta_local;
X    __attribute__ ((aligned(4))) tOrigDeltaInfo_t tDelta_local;
N    __ALIGNED4 tPenLabelInfo_t tLabel_local_dsp;
X    __attribute__ ((aligned(4))) tPenLabelInfo_t tLabel_local_dsp;
N    __ALIGNED4 tPenCoordInfo_t tCoord_local_dsp;
X    __attribute__ ((aligned(4))) tPenCoordInfo_t tCoord_local_dsp;
N
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
S    __ALIGNED4 tIdleDeltaInfo_t tIdleDeltaInfo;
N#endif /* #if USED_IDLE_MODE_CONTROL */
N		
N    tLabelInfo_t tLabel_local;
N    tCoordInfo_t tCoord_local;
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S    tNoiseInfo_t tNoise;
S	int UnstableStateFrm;
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N    bool_t bIsPalm;
N    bool_t bWasPalm;
N    bool_t bIsHover;
N    bool_t bIsGloveTouch;
N
N    bool_t bTouchExpect;
N    bool_t bTouchChecked;
N
N    /*
N     * Local Sensing Setting
N     */
N
N    bool_t bTouchExpect_local;	
N    bool_t bLocal_sensing;
N	
N	tPenInfo_t tPenInfo;
N	
N	bool_t bDiagMode;
N	
N	int16_t sLFingerMinVal;
N	tCell_t tLFingerMinCell;
N
N#if (SWIP_QUEUE_MODE)
X#if ((2))
N	uint8_t QueueRear;
N	uint8_t QueueFront;
N	bool_t bQueueStart;
N	__IO bool_t bTouchOffFlag;
X	volatile bool_t bTouchOffFlag;
N#endif
N
N#if (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL)
X#if (((1==0)) || ((0==0)))
N	uint32_t ulIdleModeEnterFrameCntTHD;
N	uint32_t ulIdleModeEnterCheckCount;
N#endif /* (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL) */
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	uint32_t ulHopFrqIdleModeFrameCntTHD;
S	uint32_t ulHoppMainRollbackCheckCount;
S	uint32_t ulHoppMainRollbackFrameCntTHD;
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N	int8_t WinCertMode;
N	uint8_t DrawingDirection;
N	tXY_t DrawingVector;
N	uint16_t WinCertTrackingDist;
N//	uint16_t TouchNumCnt;
N	int16_t TouchFrmCnt;
N	
N	bool_t bNewVersionPalm;	
N	bool_t bLineFilterRepeatCheck;
N	
N	uint16_t PhoneNoiseFrmCnt;
N	uint8_t PhoneNoiseDebEnable;
N
N} tAlgorithmInfo_t;
N
N/*
N * Default Methods
N */
Nextern void algorithm_SetCommonConfig(const tAlgorithmCommonConf_t * _p);
Nextern const tAlgorithmCommonConf_t *algorithm_GetCommonConfig(void);
Nextern void algorithm_SetModeConfig(const tAlgorithmModeConf_t * _p);
Nextern const tAlgorithmModeConf_t *algorithm_GetModeConfig(void);
Nextern tAlgorithmInfo_t *algorithm_GetInfo(void);
N
N#endif /* __ALGORITHM_CONF_H__ */
L 21 "..\..\App\Algorithm\algorithm_def.h" 2
N#include "algorithm.h"
L 1 "..\..\App\Algorithm\algorithm.h" 1
N/*
N * algorithm.h
N *
N *  Created on: 2015. 5. 6.
N *      Author: parkyj2
N */
N
N#ifndef __ALGORITHM_H__
N#define __ALGORITHM_H__
N
N#ifdef TILT_ON
S//#define GetAngleLookUpHighResolution 1
N#endif
N
N//#define LocalMode_DSP_B_code_Enable 1
N
N//#define FAST_SPLIT
N
Nextern void algorithm_init(void); // NOTE : spelling Modify!!
Nextern void algorithm_init_param(void);
N#if LGD_ERROR_FRAME_PROCESS_EN
X#if ((1==0))
Sextern bool_t LGD_error_frame_process(void);
N#endif
N#if (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL)
X#if (((1==0)) || ((0==0)))
Nextern bool_t algorithm_CheckFingerIdleModeControl(void);
N#endif /* (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL) */
N#if USED_NORMAL_NI_SENSING
X#if ((1==0))
Sextern bool_t algorithm_process_ni(void);
N#endif /* USED_NORMAL_NI_SENSING */
Nextern bool_t algorithm_process(uint8_t mode);
N#if USED_MNT_S3_MODE_FUNCTION
Sbool_t algorithm_process_S3(void);
N#endif /* USED_MNT_S3_MODE_FUNCTION */
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
Sextern bool_t algorithm_process_Idle(void);
N#endif /* USED_IDLE_MODE_CONTROL */
Nextern bool_t algorithm_process_LocalFinger(void);
Nextern void algorithm_local_process(int mode);
Nextern int32_t algorithm_calc_sqrt(int32_t d);
N
N#ifdef GetAngleLookUpHighResolution
Sextern int32_t algorithm_calc_angle_inter_2points_HighResolution(int diff_x, int diff_y);
N#else
Nextern int32_t algorithm_calc_angle_inter_2points(int diff_x, int diff_y);
N#endif
N
N#if USED_ESD_RECOVERY_CODE
X#if ((1==0))
Sextern bool_t algorithm_check_abnormal_rawdata(void);
N#endif /* USED_ESD_RECOVERY_CODE */ 
N
N#if USED_RF_NOISE_RECOVERY_CODE
X#if ((1==0))
Sextern bool_t algorithm_check_abnormal_deltadata(void);
N#endif /* USED_RF_NOISE_RECOVERY_CODE */
N
N#if 1 // O0    include    data  .. .c 
N#ifdef GetAngleLookUpHighResolution
Sextern int32_t ArcTanLookUp[1001];
N#else
Nextern int16_t sucArcTanLookUpTable[101];
N#endif
N
N#ifdef COVER_GLASS_USE
Sextern int8_t ArcSinLookUpTable[128];
N#else
Nextern int8_t ArcSinLookUpTable[128];
N#endif
N
Nextern int8_t CosLookUpTable[114];
N#else /* #if 1 */
S#ifdef GetAngleLookUpHighResolution
Sstatic int32_t ArcTanLookUp[1001]      =
S{
S0,57, 114, 171, 229, 286, 343, 401, 458, 515, 572, 630, 687, 744, 802, 859, 916, 973, 1031, 1088, 1145,
S1203, 1260, 1317, 1374, 1432, 1489, 1546, 1603, 1661, 1718, 1775, 1832, 1890, 1947, 2004, 2061, 2119, 2176, 2233,
S2290, 2347, 2405, 2462, 2519, 2576, 2633, 2690, 2748, 2805, 2862, 2919, 2976, 3033, 3091, 3148, 3205, 3262, 3319,
S3376, 3433, 3490, 3547, 3604, 3661, 3719, 3776, 3833, 3890, 3947, 4004, 4061, 4118, 4175, 4232, 4289, 4346, 4403,
S4460, 4517, 4573, 4630, 4687, 4744, 4801, 4858, 4915, 4972, 5029, 5085, 5142, 5199, 5256, 5313, 5370, 5426, 5483,
S5540, 5597, 5653, 5710, 5767, 5824, 5880, 5937, 5994, 6050, 6107, 6164, 6220, 6277, 6333, 6390, 6447, 6503, 6560,
S6616, 6673, 6729, 6786, 6842, 6899, 6955, 7012, 7068, 7125, 7181, 7237, 7294, 7350, 7406, 7463, 7519, 7575, 7632,
S7688, 7744, 7801, 7857, 7913, 7969, 8025, 8082, 8138, 8194, 8250, 8306, 8362, 8418, 8474, 8530, 8586, 8642, 8698,
S8754, 8810, 8866, 8922, 8978, 9034, 9090, 9146, 9202, 9257, 9313, 9369, 9425, 9480, 9536, 9592, 9648, 9703, 9759,
S9815, 9870, 9926, 9981, 10037, 10092, 10148, 10204, 10259, 10314, 10370, 10425, 10481, 10536, 10592, 10647, 10702, 10758, 10813,
S10868, 10923, 10979, 11034, 11089, 11144, 11199, 11254, 11309, 11365, 11420, 11475, 11530, 11585, 11640, 11695, 11750, 11804, 11859,
S11914, 11969, 12024, 12079, 12133, 12188, 12243, 12298, 12352, 12407, 12462, 12516, 12571, 12625, 12680, 12734, 12789, 12843, 12898,
S12952, 13007, 13061, 13115, 13170, 13224, 13278, 13333, 13387, 13441, 13495, 13549, 13604, 13658, 13712, 13766, 13820, 13874, 13928,
S13982, 14036, 14090, 14144, 14197, 14251, 14305, 14359, 14413, 14466, 14520, 14574, 14627, 14681, 14735, 14788, 14842, 14895, 14949,
S15002, 15056, 15109, 15163, 15216, 15269, 15323, 15376, 15429, 15482, 15535, 15589, 15642, 15695, 15748, 15801, 15854, 15907, 15960,
S16013, 16066, 16119, 16172, 16225, 16277, 16330, 16383, 16436, 16488, 16541, 16594, 16646, 16699, 16751, 16804, 16856, 16909, 16961,
S17014, 17066, 17118, 17171, 17223, 17275, 17327, 17380, 17432, 17484, 17536, 17588, 17640, 17692, 17744, 17796, 17848, 17900, 17952,
S18004, 18056, 18107, 18159, 18211, 18262, 18314, 18366, 18417, 18469, 18520, 18572, 18623, 18675, 18726, 18778, 18829, 18880, 18932,
S18983, 19034, 19085, 19136, 19187, 19239, 19290, 19341, 19392, 19443, 19494, 19544, 19595, 19646, 19697, 19748, 19798, 19849, 19900,
S19950, 20001, 20052, 20102, 20153, 20203, 20254, 20304, 20354, 20405, 20455, 20505, 20556, 20606, 20656, 20706, 20756, 20806, 20856,
S20906, 20956, 21006, 21056, 21106, 21156, 21206, 21256, 21305, 21355, 21405, 21454, 21504, 21554, 21603, 21653, 21702, 21752, 21801,
S21850, 21900, 21949, 21998, 22047, 22097, 22146, 22195, 22244, 22293, 22342, 22391, 22440, 22489, 22538, 22587, 22636, 22684, 22733,
S22782, 22831, 22879, 22928, 22976, 23025, 23074, 23122, 23170, 23219, 23267, 23316, 23364, 23412, 23460, 23509, 23557, 23605, 23653,
S23701, 23749, 23797, 23845, 23893, 23941, 23989, 24036, 24084, 24132, 24180, 24227, 24275, 24323, 24370, 24418, 24465, 24513, 24560,
S24607, 24655, 24702, 24749, 24796, 24844, 24891, 24938, 24985, 25032, 25079, 25126, 25173, 25220, 25267, 25314, 25361, 25407, 25454,
S25501, 25547, 25594, 25641, 25687, 25734, 25780, 25827, 25873, 25919, 25966, 26012, 26058, 26104, 26151, 26197, 26243, 26289, 26335,
S26381, 26427, 26473, 26519, 26565, 26610, 26656, 26702, 26748, 26793, 26839, 26885, 26930, 26976, 27021, 27067, 27112, 27157, 27203,
S27248, 27293, 27339, 27384, 27429, 27474, 27519, 27564, 27609, 27654, 27699, 27744, 27789, 27834, 27878, 27923, 27968, 28013, 28057,
S28102, 28146, 28191, 28235, 28280, 28324, 28369, 28413, 28457, 28502, 28546, 28590, 28634, 28678, 28722, 28766, 28810, 28854, 28898,
S28942, 28986, 29030, 29074, 29117, 29161, 29205, 29248, 29292, 29336, 29379, 29423, 29466, 29509, 29553, 29596, 29639, 29683, 29726,
S29769, 29812, 29855, 29898, 29941, 29984, 30027, 30070, 30113, 30156, 30199, 30242, 30284, 30327, 30370, 30412, 30455, 30498, 30540,
S30583, 30625, 30667, 30710, 30752, 30794, 30837, 30879, 30921, 30963, 31005, 31047, 31090, 31132, 31173, 31215, 31257, 31299, 31341,
S31383, 31424, 31466, 31508, 31549, 31591, 31633, 31674, 31716, 31757, 31798, 31840, 31881, 31922, 31964, 32005, 32046, 32087, 32128,
S32169, 32210, 32251, 32292, 32333, 32374, 32415, 32456, 32497, 32537, 32578, 32619, 32659, 32700, 32741, 32781, 32822, 32862, 32902,
S32943, 32983, 33023, 33064, 33104, 33144, 33184, 33224, 33264, 33304, 33344, 33384, 33424, 33464, 33504, 33544, 33584, 33623, 33663,
S33703, 33742, 33782, 33822, 33861, 33901, 33940, 33980, 34019, 34058, 34098, 34137, 34176, 34215, 34254, 34294, 34333, 34372, 34411,
S34450, 34489, 34528, 34566, 34605, 34644, 34683, 34722, 34760, 34799, 34837, 34876, 34915, 34953, 34992, 35030, 35068, 35107, 35145,
S35183, 35222, 35260, 35298, 35336, 35374, 35412, 35450, 35488, 35526, 35564, 35602, 35640, 35678, 35716, 35753, 35791, 35829, 35866,
S35904, 35942, 35979, 36017, 36054, 36092, 36129, 36166, 36204, 36241, 36278, 36315, 36353, 36390, 36427, 36464, 36501, 36538, 36575,
S36612, 36649, 36686, 36722, 36759, 36796, 36833, 36869, 36906, 36943, 36979, 37016, 37052, 37089, 37125, 37162, 37198, 37234, 37271,
S37307, 37343, 37379, 37416, 37452, 37488, 37524, 37560, 37596, 37632, 37668, 37704, 37739, 37775, 37811, 37847, 37882, 37918, 37954,
S37989, 38025, 38060, 38096, 38131, 38167, 38202, 38238, 38273, 38308, 38344, 38379, 38414, 38449, 38484, 38519, 38554, 38589, 38624,
S38659, 38694, 38729, 38764, 38799, 38834, 38868, 38903, 38938, 38972, 39007, 39042, 39076, 39111, 39145, 39180, 39214, 39248, 39283,
S39317, 39351, 39386, 39420, 39454, 39488, 39522, 39556, 39590, 39624, 39658, 39692, 39726, 39760, 39794, 39828, 39861, 39895, 39929,
S39963, 39996, 40030, 40063, 40097, 40130, 40164, 40197, 40231, 40264, 40297, 40331, 40364, 40397, 40431, 40464, 40497, 40530, 40563,
S40596, 40629, 40662, 40695, 40728, 40761, 40794, 40827, 40859, 40892, 40925, 40958, 40990, 41023, 41055, 41088, 41121, 41153, 41185,
S41218, 41250, 41283, 41315, 41347, 41380, 41412, 41444, 41476, 41508, 41540, 41573, 41605, 41637, 41669, 41701, 41733, 41764, 41796,
S41828, 41860, 41892, 41923, 41955, 41987, 42018, 42050, 42082, 42113, 42145, 42176, 42208, 42239, 42270, 42302, 42333, 42364, 42396,
S42427, 42458, 42489, 42520, 42551, 42583, 42614, 42645, 42676, 42707, 42737, 42768, 42799, 42830, 42861, 42892, 42922, 42953, 42984,
S43014, 43045, 43076, 43106, 43137, 43167, 43198, 43228, 43258, 43289, 43319, 43350, 43380, 43410, 43440, 43470, 43501, 43531, 43561,
S43591, 43621, 43651, 43681, 43711, 43741, 43771, 43801, 43830, 43860, 43890, 43920, 43949, 43979, 44009, 44038, 44068, 44098, 44127,
S44157, 44186, 44216, 44245, 44274, 44304, 44333, 44362, 44392, 44421, 44450, 44479, 44508, 44537, 44567, 44596, 44625, 44654, 44683,
S44712, 44741, 44769, 44798, 44827, 44856, 44885, 44913, 44942, 44971, 45000,
S};
S#else
Sstatic int16_t sucArcTanLookUpTable[101]      =
S{
S0,
S57,115,172,229,286,343,400,457,514,571,
S628,684,741,797,853,909,965,1020,1076,1131,
S1186,1241,1295,1350,1404,1457,1511,1564,1617,1670,
S1722,1774,1826,1878,1929,1980,2030,2081,2131,2180,
S2229,2278,2327,2375,2423,2470,2517,2564,2610,2657,
S2702,2747,2792,2837,2881,2925,2968,3011,3054,3096,
S3138,3180,3221,3262,3302,3342,3382,3422,3461,3499,
S3537,3575,3613,3650,3687,3723,3760,3795,3831,3866,
S3901,3935,3969,4003,4036,4070,4102,4135,4167,4199,
S4230,4261,4292,4323,4353,4383,4413,4442,4471,4500,
S};
S#endif
S
S#ifdef COVER_GLASS_USE
Sstatic int8_t ArcSinLookUpTable[128]  =
S{
S0,
S1,2,2,3,4,5,6,7,7,8,
S9,10,10,11,12,13,14,15,16,16,
S17,17,18,19,20,21,22,23,24,25,
S26,27,28,29,30,31,32,33,34,35,
S36,37,38,38,39,40,41,42,43,44,
S45,45,46,47,48,49,50,51,51,52,
S53,54,56,57,58,60,61,62,64,65,
S67,68,70,72,74,76,78,80,82,85,
S87,90,92,95,97,100,102,105,107,109,
S111,112,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113
S};
S#else
Sstatic int8_t ArcSinLookUpTable[128] = {
S0,
S1,2,3,3,4,5,6,7,8,9,
S10,11,12,13,14,15,16,17,18,19,
S20,21,22,23,24,25,26,27,28,29,
S30,31,32,33,34,35,36,37,38,40,
S41,42,43,44,45,46,47,47,48,49,
S51,52,53,54,55,56,57,59,60,61,
S62,64,65,67,68,70,72,73,75,76,
S78,79,81,82,84,86,88,90,92,93,
S96,98,100,103,104,105,107,109,111,113,
S113,113,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113
S};
S#endif
S
Sstatic int8_t CosLookUpTable[114]  =
S{
S	100,
S	100,100,100,100,100,100,100,100,100,100,
S	99,99,99,99,99,99,99,98,98,98,
S	98,98,97,97,97,97,96,96,96,96,
S	95,95,95,94,94,94,93,93,92,92,
S	92,91,91,90,90,90,89,89,88,88,
S	87,87,86,86,85,85,84,84,83,83,
S	82,81,81,80,80,79,78,78,77,76,
S	76,75,75,74,73,72,72,71,70,70,
S	69,68,67,67,66,65,64,64,63,62,
S	61,61,60,59,58,57,57,56,55,54,
S	53,52,51,51,50,49,48,47,46,45,
S	44,44,43
S};
N#endif /* #if 1 */
N
N#endif /* __ALGORITHM_H__ */
L 22 "..\..\App\Algorithm\algorithm_def.h" 2
N
N#endif /* __ALGORITHM_DEF_H__ */
L 22 "..\..\Hal\dspB\DSP_B.h" 2
N
N
N#define REGA0                       0x00
N#define REGA1                       0x01
N#define REGA2                       0x02
N#define REGA3                       0x03
N#define REGA4                       0x04
N#define REGA5                       0x05
N#define REGA6                       0x06
N#define REGA7                       0x07
N#define REGB0                       0x08
N#define REGB1                       0x09
N#define REGB2                       0x0A
N#define REGB3                       0x0B
N#define REGB4                       0x0C
N#define REGB5                       0x0D
N#define REGB6                       0x0E
N#define REGB7                       0x0F
N#define REGC0                       0x10
N#define REGC1                       0x11
N#define REGC2                       0x12
N#define REGC3                       0x13
N#define REGC4                       0x14
N#define REGC5                       0x15
N#define REGC6                       0x16
N#define REGC7                       0x17
N#define MEM00                       0x20
N#define CNT0                        0x21
N#define CNT1                        0x22
N#define CNT2                        0x23
N#define CH0FLT00                    0x30
N#define CH0FLT01                    0x31
N#define CH0FLT02                    0x32
N#define CH0FLT03                    0x33
N#define CH0FLT04                    0x34
N#define CH0FLT05                    0x35
N#define CH0FLT06                    0x36
N#define CH0FLT07                    0x37
N#define CH0FLT08                    0x38
N#define CH1FLT                      0x39
N#define CH2FLT                      0x3A
N#define CH3FLT                      0x3B    
N#define CONST_VAL(x)                (0x80 | x)
N#define DUMMY                       0xFF
N
N// rdma, wdma data type
N#define DM_32BIT                    0x0
N#define DM_16BIT                    0x1
N#define DM_8BIT                     0x2
N#define DM_4BIT                     0x3
N#define DM_1BIT                     0x4
N
N// data type
N#define DT_8BIT                     0x0
N#define DT_16BIT                    0x1
N#define DT_32BIT                    0x2
N#define DT_4BIT                     0x3
N#define DT_1BIT                     0x4
N
N// sign
N#define DT_UNSIGNED                 0x0
N#define DT_SIGNED                   0x1
N
N// burst size
N#define BS_1BURST                   0x0
N#define BS_4BURST                   0x1
N#define BS_8BURST                   0x2
N
N// filter type
N#define FT_1X1                      0x0
N#define FT_3X3                      0x1
N
N// position selection type
N#define PS_REG                      0x0
N#define PS_VAL                      0x1
N#define PS_INX                      0x2
N
N// read, write
N#define READ                        0x0
N#define WRITE                       0x1
N
N// branch condition
N#define AL                          0x0
N#define EQ                          0x1
N#define NE                          0x2
N#define GE                          0x3
N#define GT                          0x4
N#define LE                          0x5
N#define LT                          0x6
N#define GES                         0x7
N#define GTS                         0x8
N#define LES                         0x9
N#define LTS                         0xA
N
N// branch direction
N#define DOWN                        0x0
N#define UP                          0x1
N
N// branch line count
N#define LINE_CNT(x)                 (x << 2)
N
N// clear mask
N#define CLR_WDMA0                   0x2
N#define CLR_RDMA0                   0x1
N
N// loop sel
N#define LOOP_LT                     0x0
N#define LOOP_LE                     0x1
N
N#define LOOP_REGC0                  0x0
N#define LOOP_REGC1                  0x1
N#define LOOP_REGC2                  0x2
N#define LOOP_SOURCE                 0x3
N
N#define NOP()                                       0x00000000
N#define ADD(s0, s1, d)                              ((0x01 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define SUB(s0, s1, d)                              ((0x03 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define MUL(s0, s1, d)                              ((0x04 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define DIV(s0, s1, d)                              ((0x06 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define SRL(s0, s1, d)                              ((0x07 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define SLL(s0, s1, d)                              ((0x08 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define AND(s0, s1, d)                              ((0x0A << 24) | (s0 << 16) | (s1 << 8) | d)
N#define OR(s0, s1, d)                               ((0x0B << 24) | (s0 << 16) | (s1 << 8) | d)
N#define XOR(s0, s1, d)                              ((0x0C << 24) | (s0 << 16) | (s1 << 8) | d)
N#define NOT(s0, d)                                  ((0x0D << 24) | (s0 << 16) | d)
N#define MOV(s0, d)                                  ((0x0E << 24) | (s0 << 16) | d)
N#define CMP(s0, s1)                                 ((0x0F << 24) | (s0 << 16) | (s1 << 8) | DUMMY)
N#define ADDS(s0, s1, d)                             ((0x10 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define SUBS(s0, s1, d)                             ((0x11 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define MULS(s0, s1, d)                             ((0x12 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define DIVS(s0, s1, d)                             ((0x14 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define SRLS(s0, s1, d)                             ((0x15 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define SLLS(s0, s1, d)                             ((0x16 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define CMPS(s0, s1)                                ((0x18 << 24) | (s0 << 16) | (s1 << 8) | DUMMY)
N#define MRGB(s0, s1, d)                             ((0x19 << 24) | (s0 << 16) | (s1 << 8) | d)
N#define MRGS(s0, s1, d)                             ((0x1A << 24) | (s0 << 16) | (s1 << 8) | d)
N#define _MIN(s0, s1, d)                              ((0x1B << 24) | (s0 << 16) | (s1 << 8) | d)
N#define _MAX(s0, s1, d)                              ((0x1C << 24) | (s0 << 16) | (s1 << 8) | d)
N#define CABS(s0, s1)                                ((0x1D << 24) | (s0 << 16) | (s1 << 8) | DUMMY)
N#define SLOOP0(st, ed, sel, cs)                     ((0x20 << 24) | (st << 16) | (ed << 8) | (sel<<2) | cs)
N#define ELOOP0()                                    ((0x21 << 24))
N#define SLOOP1(st, ed, sel, cs)                     ((0x22 << 24) | (st << 16) | (ed << 8) | (sel<<2) | cs)
N#define ELOOP1()                                    ((0x23 << 24))
N#define SLOOP2(st, ed, sel, cs)                     ((0x24 << 24) | (st << 16) | (ed << 8) | (sel<<2) | cs)
N#define ELOOP2()                                    ((0x25 << 24))
N#define BR(addr, cond)                              ((0x26 << 24) | (addr << 8) | cond)
N#define BRC(addr, dir, cond)                        ((0x27 << 24) | (addr << 8) | (dir<<4) | cond)
N#define BL(addr, cond)                              ((0x28 << 24) | (addr << 8) | cond)
N#define BLC(addr, dir, cond)                        ((0x29 << 24) | (addr << 8) | (dir<<4) | cond)
N#define RDMAC0(addr, sign, dr, bst, bit)            ((0x2A << 24) | (addr << (dr ? 8 : 16)) | (sign<<6) | (dr<<5) | (bst<<3) | bit)
N#define WDMAC0(addr, sign, dr, bst, bit)            ((0x2B << 24) | (addr << (dr ? 8 : 16)) | (sign<<6) | (dr<<5) | (bst<<3) | bit)
N#define SDMA0(addr, dr, size)                       ((0x2C << 24) | (addr << (dr ? 8 : 16)) | (dr<<5) | size)
N#define SDMA1(addr, dr, size)                       ((0x2D << 24) | (addr << (dr ? 8 : 16)) | (dr<<5) | size)
N#define SDMA2(addr, dr, size)                       ((0x2E << 24) | (addr << (dr ? 8 : 16)) | (dr<<5) | size)
N#define SDMA3(addr, dr, size)                       ((0x2F << 24) | (addr << (dr ? 8 : 16)) | (dr<<5) | size)
N#define SRW0(x, y, flt, wr, psel, sign, bit)        ((0x30 << 24) | (x<<16) | (y<<8) | (flt<<7) | (psel<<5) | (sign<<4) | (wr<<3) | bit)
N#define SRW1(x, y, flt, wr, psel, sign, bit)        ((0x31 << 24) | (x<<16) | (y<<8) | (flt<<7) | (psel<<5) | (sign<<4) | (wr<<3) | bit)
N#define SRW2(x, y, flt, wr, psel, sign, bit)        ((0x32 << 24) | (x<<16) | (y<<8) | (flt<<7) | (psel<<5) | (sign<<4) | (wr<<3) | bit)
N#define SRW3(x, y, flt, wr, psel, sign, bit)        ((0x33 << 24) | (x<<16) | (y<<8) | (flt<<7) | (psel<<5) | (sign<<4) | (wr<<3) | bit)
N#define RET(type)                                   ((0x34 << 24) | type)
N#define WCNT(cnt)                                   ((0x35 << 24) | (cnt<<8))
N#define WUNT()                                      ((0x36 << 24))
N#define END()                                       ((0x37 << 24))
N#define CLR(mask)                                   ((0x38 << 24) | mask)
N#define CONST(val, d)                               ((0x39 << 24) | (val<<8) | d)
N
N// size set
N#define DMA_SIZE0                                   0
N#define DMA_SIZE1                                   1
N#define DMA_SIZE2                                   2
N#define DMA_SIZE3                                   3
N
N#define DSP_SIZE_CLEAR(addr, size_num)              ((addr) &= (uint32_t)(~(((uint32_t)0xff) << ((size_num)<<3)))); // NOTE :   signed  .  unsigned   warning   .
N#define DSP_SIZE_SET(addr, size_num, set_val)       ((addr) |= (uint32_t)(((uint32_t)(set_val)) << ((size_num)<<3))); // NOTE :   signed  .  unsigned   warning   .
N
N#define	REG32P	*(volatile unsigned int*)
N#define	REG16P	*(volatile unsigned short*)
N
Nuint8_t TMH_Labeling (
N    int16_t   *pSrc,          /**< input data buffer pointer */
N    uint8_t   *pMap,          /**< output map data buffer pointer */
N    uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N    uint8_t   bStride,        /**< stride */
N    int     nThreshold,     /**< threshold */
N    short   *pEqTbl         /**< equality table */
N);
N
Nuint8_t TMH_Labeling_v2 (
N    int16_t   *pSrc,          /**< input data buffer pointer */
N    uint8_t   *pMap,          /**< output map data buffer pointer */
N    uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N    uint8_t   bStride,        /**< stride */
N    int     nThreshold,     /**< threshold */
N    short   *pEqTbl        /**< equality table */
N);
Nvoid TMH_WaterLabelExtension(
N    int16_t   *pSrc,          /**< input data buffer pointer */
N    uint8_t   *pMap,          /**< output map data buffer pointer */
N    uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N    uint8_t   bStride,        /**< stride */
N    int     w_thres,     /**< threshold */
N    uint8_t bLabel_num,
N    uint8_t bExtend_size
N);
Nvoid TMH_PreWater(
N    int16_t   *pSrc,          /**< input data buffer pointer */
N    uint8_t   *pMap,          /**< output map data buffer pointer */
N    uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N    uint8_t   bStride,        /**< stride */
N    int     w_thres,     /**< threshold */
N    uint8_t bLabel_num,
N    uint8_t bExtend_size
N);
Nvoid TMH_PreWater_v10(
N    int16_t   *pSrc,          /**< input data buffer pointer */
N    uint8_t   *pMap,          /**< output map data buffer pointer */
N    uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N    uint8_t   bStride,        /**< stride */
N    int     p_th,     /**< threshold */
N    int     m_th,
N    uint8_t bLabel_num,
N    uint8_t bExtend_size
N);
Nvoid TMH_PartialAccum_v3 (
N    short   *pSrc,          /**< input data buffer pointer */
N    short   *pDst,          /**< output data buffer pointer */
N    uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N    uint8_t   bStride,        /**< stride */
N	uint8_t		*map,			/**< map */
N    char    bThre           /**< threshold */
N);
N
Nvoid TMH_DC_Remove (
N    short   *pSrc,          /**< input data buffer pointer */
N    short   *pDst,          /**< output data buffer pointer */
N    uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N    uint8_t   bStride,        /**< stride */
N    uint8_t   bDC_LevSft,     /**< DC level shift */
N    uint8_t   bWeightSft      /**< weight shift */
N);
N
Nvoid TMH_CompenForAKS(
N	short   *pSrc,          /**< input data buffer pointer */
N	short   *pDst,          /**< output data buffer pointer */
N	uint8_t   bWidth,         /**< width */
N    uint8_t   bHeight,        /**< height */
N	uint8_t   bStride,        /**< stride */
N	short   bThre
N);
N
Nuint16_t TMH_1cell_noise_remove(
N    int16_t		*pSrc,			/**< input data buffer pointer */
N    int16_t		*pDst,			/**< output data buffer pointer */
N    uint8_t	bWidth,			/**< width */
N    uint8_t	bHeight,		/**< height */
N    uint8_t	bStride,		/**< stride */
N	uint16_t	bChkThr,		/**< check threshold */
N	uint16_t	bAbsThr,		/**< Absolute threshold */
N	uint16_t	bOriThr,		/**< Original threshold */
N	uint16_t	bSameThr,		/**< SameValue threshold */
N	uint16_t	bCentThr		/**< CneterValue threshold */
N);
N
Nvoid TMH_PenCoordinate(tPenCoordInfo_t *pTCoordInfo, tPenLabelInfo_t *pTLabelInfo, tEdgePen_t *pTEdgePen, int mode);
Nvoid TMH_PenLabeling (
N    int16_t             *pSrc,          /**< input data buffer pointer */
N    uint8_t           *pMap,          /**< output map data buffer pointer */
N    tPenLabelInfo_t *pTLabelInfo,   /**< output label info buffer pointer */
N    int             nLabelInfoSize, /**< label info size */
N    int             nStart_r,       /**< start row */
N    int             nEnd_r,         /**< end row */
N    int             nStart_c,       /**< start column */
N    int             nEnd_c,         /**< end column */
N    int             nThreshold,     /**< threshold */
N    uint8_t         ucPadSize       /**< pad size */
N);
N    
Nvoid TMH_MarkBoundary (
N    uint8_t        *pLabel,         //< input Label buffer pointer 
N    int16_t        *pDelta,         //< input Delta buffer pointer
N    int32_t         nStart_r,       //< start row 
N    int32_t         nEnd_r,         //< end row 
N    int32_t         nStart_c,       //< start column 
N    int32_t         nEnd_c,         //< end column 
N    int32_t         nTable_num,     //< 4data or 8data
N    tPenLabelInfo_t *tTable,        //< Output tTable Structure pointer
N    int32_t         Boundary,
N    uint8_t	        ucPad_size
N);
N    
Nvoid TMH_PenCalDelta (
N    uint16_t        *pRawImg,       /**< input raw data buffer pointer */
N    uint16_t        *pBaseImg,      /**< input base data buffer pointer */
N    uint8_t         *pNormalTbl,    /**< input normalize look-up table data buffer pointer */
N    int16_t         *pDeltaImg,     /**< output delta data buffer pointer */
N    tOrigDeltaInfo_t *pPenDeltaInfo, /**< output pen delta info buffer pointer */
N    int             nCurrRowStart,  /**< start current row */
N    int             nCurrColStart,  /**< start current column */
N    int             nWidth,         /**< width */
N    int             nHeight,        /**< height */
N    bool_t            bNormalize,     /**< normalize flag */
N    uint8_t         ucOvrShift,     /**< delta OvrShift */
N    uint16_t        uint8_tSeedBase,     /**< label seed base threshold */
N    uint8_t         ucMuxRowSize,   /**< mux row size */
N    uint8_t         ucPadSize       /**< pad size */
N);
N
Nvoid TMH_PenCoordInitialize(tPenCoordInfo_t *pTCoordInfo, tOrigDeltaInfo_t *pPenDeltaInfo);
Nvoid TMH_PenUpdatePostHistoryInfo(tPenCoordInfo_t *pTCoordInfo);
Nvoid algorithm_local_dsp_process(int index, ePartialSensing_t RetVal, int mode);
Nvoid algorithm_hover_full_search(void);
Nbool_t algorithm_mode_change_check(void);
Nvoid algorithm_hover_accum_process(void);
Nvoid algorithm_hover_accum_move(void);
Nbool_t algorithm_local_baseline_tracking_initial(void);
Nvoid algorithm_data_local_process(ePartialSensing_t RetVal);
Nvoid alogorithm_coord_modify_pos_local(tXY_t* pos);
N
N
N// warning  
Nvoid algorithm_coord_init_local_DSP(void);
N
N/*
N * NOTE : define  !!
N */
Nextern void algorithm_init_local(void);
Nextern void init_DSP_B(void);
Nextern void Clear_DSP_B_Intr(void);
N
N// NOTE : DSP_B_code.c        extern 
Nextern void algorithm_local_init(void);
Nextern void algorithm_local_baseline_init(void);
Nextern void algorithm_baseline_calculate_local_mux_range(int r, int c);
Nextern void algorithm_coord_init_local(void);
N
N
N#endif /* DSP_B_H_ */
N
N/*
N * NOTE :      ?
N */
N//Extern 
N//extern void algorithm_init_local(void);
N//extern void init_DSP_B(void);
N//extern void Clear_DSP_B_Intr(void);
L 47 "..\..\Hal\hal_def.h" 2
N#endif /* !defined(USE_BOOTLOADER_CODE) */
N#include "SiWApp_DSP_B.h"
L 1 "..\..\Hal\dspB\SiWApp_DSP_B.h" 1
N/**
N ******************************************************************************
N * @file    SiWApp_tdsp.h
N * @author  Touch Team, Silicon Works Co., Ltd.
N * @version V1.0
N * @date    2016/06/17
N * @description   
N ******************************************************************************       
N */
N
N#ifndef _SW3711_TDSP2_H_
N#define _SW3711_TDSP2_H_
N
N#define TDSP_BASE_ADDR           0x4000A000
N
N/*
N ******************************************************************************
N * Peripheral Group 'TDSP'  Structure 
N ******************************************************************************
N */
N 
N/*
N ******************************************************************************
N * TDSP2 Controller Peripheral Group Function Definitions
N ******************************************************************************
N */		  
N
N#define REG_TDSP2_A0	 		(REG32P(TDSP_BASE_ADDR + 0x00))
N#define REG_TDSP2_A1	 		(REG32P(TDSP_BASE_ADDR + 0x04))
N#define REG_TDSP2_A2	 		(REG32P(TDSP_BASE_ADDR + 0x08))
N#define REG_TDSP2_A3	 		(REG32P(TDSP_BASE_ADDR + 0x0C))
N#define REG_TDSP2_A4	 		(REG32P(TDSP_BASE_ADDR + 0x10))
N#define REG_TDSP2_A5	 		(REG32P(TDSP_BASE_ADDR + 0x14))
N#define REG_TDSP2_A6	 		(REG32P(TDSP_BASE_ADDR + 0x18))
N#define REG_TDSP2_A7	 		(REG32P(TDSP_BASE_ADDR + 0x1C))
N
N#define REG_TDSP2_B0	 		(REG32P(TDSP_BASE_ADDR + 0x20))
N#define REG_TDSP2_B1	 		(REG32P(TDSP_BASE_ADDR + 0x24))
N#define REG_TDSP2_B2	 		(REG32P(TDSP_BASE_ADDR + 0x28))
N#define REG_TDSP2_B3	 		(REG32P(TDSP_BASE_ADDR + 0x2C))
N#define REG_TDSP2_B4	 		(REG32P(TDSP_BASE_ADDR + 0x30))
N#define REG_TDSP2_B5	 		(REG32P(TDSP_BASE_ADDR + 0x34))
N#define REG_TDSP2_B6	 		(REG32P(TDSP_BASE_ADDR + 0x38))					
N#define REG_TDSP2_B7	 		(REG32P(TDSP_BASE_ADDR + 0x3C))
N
N#define REG_TDSP2_C0	 		(REG32P(TDSP_BASE_ADDR + 0x40))
N#define REG_TDSP2_C1	 		(REG32P(TDSP_BASE_ADDR + 0x44))
N#define REG_TDSP2_C2	 		(REG32P(TDSP_BASE_ADDR + 0x48))
N#define REG_TDSP2_C3	 		(REG32P(TDSP_BASE_ADDR + 0x4C))
N#define REG_TDSP2_C4	 		(REG32P(TDSP_BASE_ADDR + 0x50))
N#define REG_TDSP2_C5	 		(REG32P(TDSP_BASE_ADDR + 0x54))
N#define REG_TDSP2_C6	 		(REG32P(TDSP_BASE_ADDR + 0x58))
N#define REG_TDSP2_C7	 		(REG32P(TDSP_BASE_ADDR + 0x5C))
N
N#define REG_TDSP2_PC	 		(REG32P(TDSP_BASE_ADDR + 0x100))
N#define REG_TDSP2_BUSY	 		(REG32P(TDSP_BASE_ADDR + 0x124))
N#define REG_TDSP2_OPCODE_BASEADDR	(REG32P(TDSP_BASE_ADDR + 0x128))
N#define REG_TDSP2_INTERRUPT		(REG32P(TDSP_BASE_ADDR + 0x138))
N
N#define REG_TDSP2_XSIZE 		(REG32P(TDSP_BASE_ADDR + 0x200))
N#define REG_TDSP2_YSIZE 		(REG32P(TDSP_BASE_ADDR + 0x204))
N#define REG_TDSP2_DMA_BASEADDR	(REG32P(TDSP_BASE_ADDR + 0x208))
N
N#endif  /* _SW3711_TDSP2_H_ */
N
L 49 "..\..\Hal\hal_def.h" 2
N#include "gpio.h"
L 1 "..\..\Hal\gpio\gpio.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : gpio.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _GPIO_H_
N#define _GPIO_H_
N
N
Ntypedef enum
N{
N	Input					  	= 0x00,
N	Output						= 0x01,
N	PullupIn					= 0x02
N} GpIoconValue_TypeDef;
N
N/**
N * @brief  GPIO Mode Configure Register : Setting Values
N */
Ntypedef enum
N{
N    GPIO_Mode0_GPIO	= 0x00,		/// GPIO0 Mode
N    GPIO_Mode1_AF1	= 0x01,		/// Alternate Function 1 Mode
N    GPIO_Mode2_AF2	= 0x02,		/// Alternate Function 2 Mode
N    GPIO_Mode3_AF3	= 0x03,		/// Alternate Function 3 Mode
N} GpModeValue_TypeDef;
N
N/**
N * @brief  
N */
Ntypedef struct
N{
N	uint64_t				  GPIO_Pin;
N    GpModeValue_TypeDef		  GPIO_Mode;
N	GpIoconValue_TypeDef	  GPIO_Config;
N} GPIO_InitTypeDef;
N
N/**
N * @brief External Interrupt Initial Params
N */
Ntypedef struct
N{
N	uint64_t				    GPIO_Pin;
N    uint8_t                     LevelDetection;
N    uint8_t                     BothEdge;
N    uint8_t                     PositivePolarity;
N    uint8_t                     EnableInterrupt;
N} EXIT_Typedef;
N    
N
N#define LEVEL_DETECTION_GPIO		(1)
N#define EDGE_DETECTION_GPIO			(0)
N#define BOTH_EDGE_GPIO				(1)
N#define SINGLE_EDGE_GPIO			(0)
N#define POSITIVE_HIGH_GPIO			(1)
N#define NEGATIVE_LOW_GPIO			(0)
N#define ENABLE_GPIO					(1)
N#define DISABLE_GPIO				(0)
N
N
N/**
N  * @brief  Bit_SET and Bit_RESET enumeration
N  */
Ntypedef enum
N{
N    Bit_RESET = 0,
N    Bit_SET
N}
NBitAction;
N/**
N  * @brief  Bit_HIGHT and Bit_LOW enumeration
N  */
Ntypedef enum
N{
N    LOW = 0,
N    HIGH = 1
N}EnumBit;
N
Ntypedef enum
N{
N	PIN_GPA00	=	0	,
N	PIN_GPA01	=	1	,
N	PIN_GPA02	=	2	,
N	PIN_GPA03	=	3	,
N	PIN_GPA04	=	4	,
N	PIN_GPA05	=	5	,
N	PIN_GPA06	=	6	,
N	PIN_GPA07	=	7	,
N	PIN_GPA08	=	8	,
N	PIN_GPA09	=	9	,
N	PIN_GPA10	=	10	,
N	PIN_GPA11	=	11	,
N	PIN_GPA12	=	12	,
N	PIN_GPA13	=	13	,
N	PIN_GPA14	=	14	,
N	PIN_GPA15	=	15	,
N	PIN_GPA16	=	16	,
N	PIN_GPA17	=	17	,
N	PIN_GPA18	=	18	,
N	PIN_GPA19	=	19	,
N	PIN_GPA20	=	20	,
N	PIN_GPA21	=	21	,
N	PIN_GPA22	=	22	,
N	PIN_GPA23	=	23	,
N	PIN_GPA24	=	24	,
N	PIN_GPA25	=	25	,
N	PIN_GPA26	=	26	,
N	PIN_GPA27	=	27	,
N	PIN_GPA28	=	28	,
N	PIN_GPA29	=	29	,
N	PIN_GPA30	=	30	,
N	PIN_GPA31	=	31	,
N	PIN_GPA32	=	32	,
N	PIN_GPA33	=	33	,
N	PIN_GPA34	=	34	,
N	PIN_GPA35	=	35	,
N	PIN_GPA36	=	36	,
N	PIN_GPA37	=	37	,
N	PIN_GPB00	=	38	,
N	PIN_GPB01	=	39	,
N	PIN_GPB02	=	40	,
N	PIN_GPB03	=	41	,
N	PIN_GPB04	=	42	,
N	PIN_GPB05	=	43	,
N	PIN_GPB06	=	44	,
N	PIN_GPB07	=	45	,
N	PIN_GPB08	=	46	,
N	PIN_GPB09	=	47	,
N	PIN_GPB10	=	48	,
N	PIN_GPB11	=	49	,
N	PIN_GPB12	=	50	,
N	PIN_GPB13	=	51	,
N	PIN_GPB14	=	52	,
N	PIN_GPB15	=	53
N
N}EnumGPIO;
N
N#include "gpio_define.h"
L 1 "..\..\Hal\gpio\gpio_define.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : gpio_define.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _GPIO_DEFINE_H_
N#define _GPIO_DEFINE_H_
N
N
N#define _GPIO_MSPI_0_CSN			tBit.GPA00
N#define _GPIO_MSPI_0_SCLK			tBit.GPA01
N#define _GPIO_MSPI_0_MOSI			tBit.GPA02
N#define _GPIO_MSPI_0_MISO			tBit.GPA03
N
N#define _GPIO_MSPI_1_CSN			tBit.GPA04
N#define _GPIO_MSPI_1_SCLK			tBit.GPA05
N#define _GPIO_MSPI_1_MOSI			tBit.GPA06
N#define _GPIO_MSPI_1_MISO			tBit.GPA07
N
N#define _GPIO_MSPI_2_CSN			tBit.GPA08
N#define _GPIO_MSPI_2_SCLK			tBit.GPA09
N#define _GPIO_MSPI_2_MOSI			tBit.GPA10
N#define _GPIO_MSPI_2_MISO			tBit.GPA11
N
N#define _GPIO_MSPI_3_CSN			tBit.GPA12
N#define _GPIO_MSPI_3_SCLK			tBit.GPA13
N#define _GPIO_MSPI_3_MOSI			tBit.GPA14
N#define _GPIO_MSPI_3_MISO			tBit.GPA15
N
N#define _GPIO_MSPI_4_CSN			tBit.GPA16
N#define _GPIO_MSPI_4_SCLK			tBit.GPA17
N#define _GPIO_MSPI_4_MOSI			tBit.GPA18
N#define _GPIO_MSPI_4_MISO			tBit.GPA19
N
N#define _GPIO_MSPI_5_CSN			tBit.GPA20
N#define _GPIO_MSPI_5_SCLK			tBit.GPA21
N#define _GPIO_MSPI_5_MOSI			tBit.GPA22
N#define _GPIO_MSPI_5_MISO			tBit.GPA23
N
N#define _GPIO_VSYNC					tBit.GPA26
N#define _GPIO_TSYNC_IN				tBit.GPA27
N#define _GPIO_TSYNC2_IN				tBit.GPA37
N#define _GPIO_TSYNC_OUT				tBit.GPA35
N#define _GPIO_PWM_SRIC				tBit.GPA28
N//#define _GPIO_PWM_TPIC				tBit.GPA29
N#define _GPIO_PWM_GATE				tBit.GPA29
N//#define _GPIO_RSTN_SRIC				tBit.GPA33
N#define _GPIO_LCD_ON				tBit.GPA34
N#define _GPIO_TP_EN					tBit.GPB09
N#define _GPIO_TP_INTR				tBit.GPB10
N#define _GPIO_TPIC_MUX_EN			tBit.GPA36
N#define _GPIO_ECLK_0				tBit.GPA24
N#define _GPIO_ECLK_1				tBit.GPA25
N#define _GPIO_SWDIO					tBit.GPB00
N#define _GPIO_SWCLK					tBit.GPB01
N#define _GPIO_RSTN_0				tBit.GPA30
N#define _GPIO_RSTN_1				tBit.GPA31
N
N#define _GPIO_VTSP18				tBit.GPA32
N
N#define _GPIO_DEBUG_B5				tBit.GPB05
N#define _GPIO_SLEEP_RST				tBit.GPB08
N
N//#define _GPIO_VSWT0					tBit.GPA33
N#define _GPIO_TOGGLE				tBit.GPA33
N
N
N
N#define GPIO_MSPI_0_CSN				(PIN_GPA00)
N#define GPIO_MSPI_0_CLK				(PIN_GPA01)
N#define GPIO_MSPI_0_MOSI			(PIN_GPA02)
N#define GPIO_MSPI_0_MISO			(PIN_GPA03)
N#define GPIO_MSPI_1_CSN				(PIN_GPA04)
N#define GPIO_MSPI_1_CLK				(PIN_GPA05)
N#define GPIO_MSPI_1_MOSI			(PIN_GPA06)
N#define GPIO_MSPI_1_MISO			(PIN_GPA07)
N#define GPIO_MSPI_2_CSN				(PIN_GPA08)
N#define GPIO_MSPI_2_CLK				(PIN_GPA09)
N#define GPIO_MSPI_2_MOSI			(PIN_GPA10)
N#define GPIO_MSPI_2_MISO			(PIN_GPA11)
N#define GPIO_MSPI_3_CSN				(PIN_GPA12)
N#define GPIO_MSPI_3_CLK				(PIN_GPA13)
N#define GPIO_MSPI_3_MOSI			(PIN_GPA14)
N#define GPIO_MSPI_3_MISO			(PIN_GPA15)
N#define GPIO_MSPI_4_CSN				(PIN_GPA16)
N#define GPIO_MSPI_4_CLK				(PIN_GPA17)
N#define GPIO_MSPI_4_MOSI			(PIN_GPA18)
N#define GPIO_MSPI_4_MISO			(PIN_GPA19)
N#define GPIO_MSPI_5_CSN				(PIN_GPA20)
N#define GPIO_MSPI_5_CLK				(PIN_GPA21)
N#define GPIO_MSPI_5_MOSI			(PIN_GPA22)
N#define GPIO_MSPI_5_MISO			(PIN_GPA23)
N#define GPIO_ECLK_0					(PIN_GPA24)
N#define GPIO_ECLK_1					(PIN_GPA25)
N#define GPIO_GPIOA1					(PIN_GPA25)
N#define GPIO_VSYNC					(PIN_GPA26)
N#define GPIO_TSYNC_IN				(PIN_GPA27)
N#define GPIO_PWM_TX					(PIN_GPA28)
N#define GPIO_PWM_DATA				(PIN_GPA29)
N#define GPIO_PWM_GATE				(PIN_GPA30)
N#define GPIO_VSWT2					(PIN_GPA31)
N#define GPIO_GPIOA2					(PIN_GPA31)
N#define GPIO_VSWT3					(PIN_GPA32)
N#define GPIO_GPIOA3					(PIN_GPA32)
N#define GPIO_VSWT0					(PIN_GPA33)
N#define GPIO_RSTN_SRIC				(PIN_GPA33)
N#define GPIO_VSWT1					(PIN_GPA34)
N#define GPIO_LCD_ON					(PIN_GPA34)
N#define GPIO_TSYNC_OUT				(PIN_GPA35)
N#define GPIO_I2C_M_SCL				(PIN_GPA36)
N#define GPIO_I2C_M_SDA				(PIN_GPA37)
N#define GPIO_SWDIO					(PIN_GPB00)
N#define GPIO_SWCLK					(PIN_GPB01)
N#define GPIO_I2C_S_SCL				(PIN_GPB02)
N#define GPIO_I2C_S_SDA				(PIN_GPB03)
N#define GPIO_TSPI_CSN				(PIN_GPB04)
N#define GPIO_TSPI_CLK				(PIN_GPB05)
N#define GPIO_TSPI_MOSI				(PIN_GPB06)
N#define GPIO_TSPI_MISO				(PIN_GPB07)
N#define GPIO_TSPI_INTR				(PIN_GPB08)
N#define GPIO_TP_EN					(PIN_GPB09)
N#define GPIO_GPIOB1					(PIN_GPB09)
N#define GPIO_TP_INTR				(PIN_GPB10)
N#define GPIO_GPIOB3					(PIN_GPB10)
N#define GPIO_SWV					(PIN_GPB11)
N#define GPIO_GPIOB2					(PIN_GPB11)
N#define GPIO_SFLASH_CLK				(PIN_GPB12)
N#define GPIO_SFLASH_CSN				(PIN_GPB13)
N#define GPIO_SFLASH_MISO			(PIN_GPB14)
N#define GPIO_SFLASH_MOSI			(PIN_GPB15)
N
N
N#endif /* _GPIO_DEFINE_H_ */
L 166 "..\..\Hal\gpio\gpio.h" 2
N
N#define GPIO_Bit_0		((uint32_t)0x0000000000000001) /** Pin 0 select mask */
N#define GPIO_Bit_1		((uint32_t)0x0000000000000002) /** Pin 1 select mask */
N#define GPIO_Bit_2		((uint32_t)0x0000000000000004) /** Pin 2 select mask */
N#define GPIO_Bit_3		((uint32_t)0x0000000000000008) /** Pin 3 select mask */
N#define GPIO_Bit_4		((uint32_t)0x0000000000000010) /** Pin 4 select mask */
N#define GPIO_Bit_5		((uint32_t)0x0000000000000020) /** Pin 5 select mask */
N#define GPIO_Bit_6		((uint32_t)0x0000000000000040) /** Pin 6 select mask */
N#define GPIO_Bit_7		((uint32_t)0x0000000000000080) /** Pin 7 select mask */
N#define GPIO_Bit_8		((uint32_t)0x0000000000000100) /** Pin 8 select mask */
N#define GPIO_Bit_9		((uint32_t)0x0000000000000200) /** Pin 9 select mask */
N#define GPIO_Bit_10		((uint32_t)0x0000000000000400) /** Pin 10 select mask */
N#define GPIO_Bit_11		((uint32_t)0x0000000000000800) /** Pin 11 select mask */
N#define GPIO_Bit_12		((uint32_t)0x0000000000001000) /** Pin 12 select mask */
N#define GPIO_Bit_13		((uint32_t)0x0000000000002000) /** Pin 13 select mask */
N#define GPIO_Bit_14		((uint32_t)0x0000000000004000) /** Pin 14 select mask */
N#define GPIO_Bit_15		((uint32_t)0x0000000000008000) /** Pin 15 select mask */
N#define GPIO_Bit_16		((uint32_t)0x0000000000010000) /** Pin 16 select mask */
N#define GPIO_Bit_17		((uint32_t)0x0000000000020000) /** Pin 17 select mask */
N#define GPIO_Bit_18		((uint32_t)0x0000000000040000) /** Pin 18 select mask */
N#define GPIO_Bit_19		((uint32_t)0x0000000000080000) /** Pin 19 select mask */
N#define GPIO_Bit_20		((uint32_t)0x0000000000100000) /** Pin 20 select mask */
N#define GPIO_Bit_21		((uint32_t)0x0000000000200000) /** Pin 21 select mask */
N#define GPIO_Bit_22		((uint32_t)0x0000000000400000) /** Pin 22 select mask */
N#define GPIO_Bit_23		((uint32_t)0x0000000000800000) /** Pin 23 select mask */
N#define GPIO_Bit_24		((uint32_t)0x0000000001000000) /** Pin 24 select mask */
N#define GPIO_Bit_25		((uint32_t)0x0000000002000000) /** Pin 25 select mask */
N#define GPIO_Bit_26		((uint32_t)0x0000000004000000) /** Pin 26 select mask */
N#define GPIO_Bit_27		((uint32_t)0x0000000008000000) /** Pin 27 select mask */
N#define GPIO_Bit_28		((uint32_t)0x0000000010000000) /** Pin 28 select mask */
N#define GPIO_Bit_29		((uint32_t)0x0000000020000000) /** Pin 29 select mask */
N#define GPIO_Bit_30		((uint32_t)0x0000000040000000) /** Pin 30 select mask */
N#define GPIO_Bit_31		((uint32_t)0x0000000080000000) /** Pin 31 select mask */
N
N#define GPIO_Bit_32		((uint64_t)0x0000000100000000) /** Pin 32 select mask */
N#define GPIO_Bit_33		((uint64_t)0x0000000200000000) /** Pin 33 select mask */
N#define GPIO_Bit_34		((uint64_t)0x0000000400000000) /** Pin 34 select mask */
N#define GPIO_Bit_35		((uint64_t)0x0000000800000000) /** Pin 35 select mask */
N#define GPIO_Bit_36		((uint64_t)0x0000001000000000) /** Pin 36 select mask */
N#define GPIO_Bit_37		((uint64_t)0x0000002000000000) /** Pin 37 select mask */
N#define GPIO_Bit_38		((uint64_t)0x0000004000000000) /** Pin 38 select mask */
N#define GPIO_Bit_39		((uint64_t)0x0000008000000000) /** Pin 39 select mask */
N#define GPIO_Bit_40		((uint64_t)0x0000010000000000) /** Pin 40 select mask */
N#define GPIO_Bit_41		((uint64_t)0x0000020000000000) /** Pin 41 select mask */
N#define GPIO_Bit_42		((uint64_t)0x0000040000000000) /** Pin 42 select mask */
N#define GPIO_Bit_43		((uint64_t)0x0000080000000000) /** Pin 43 select mask */
N#define GPIO_Bit_44		((uint64_t)0x0000100000000000) /** Pin 44 select mask */
N#define GPIO_Bit_45		((uint64_t)0x0000200000000000) /** Pin 45 select mask */
N#define GPIO_Bit_46		((uint64_t)0x0000400000000000) /** Pin 46 select mask */
N
N
N#define Set_GPB11(val)			(GPIO->tGPIO_DATA_1.tBit.GPB11 = val)
N#define Set_GPA36(val)			(GPIO->tGPIO_DATA_1.tBit.GPA36 = val)
N#define Set_GPA37(val)			(GPIO->tGPIO_DATA_1.tBit.GPA37 = val)
N
N#define T_GPB11()			(GPIO->tGPIO_DATA_1.tBit.GPB11 ^= 1)
N#define T_GPA36()			(GPIO->tGPIO_DATA_1.tBit.GPA36 ^= 1)
N#define T_GPA37()			(GPIO->tGPIO_DATA_1.tBit.GPA37 ^= 1)
N
N#define F_GPB09() \
N	do { \
N		(GPIO->tGPIO_DATA_1.tBit.GPB09 = 1); \
N		(GPIO->tGPIO_DATA_1.tBit.GPB09 = 0); \
N	} while(0)
X#define F_GPB09() 	do { 		(GPIO->tGPIO_DATA_1.tBit.GPB09 = 1); 		(GPIO->tGPIO_DATA_1.tBit.GPB09 = 0); 	} while(0)
N
N#define F_GPB10() \
N	do { \
N		(GPIO->tGPIO_DATA_1.tBit.GPB10 = 1); \
N		(GPIO->tGPIO_DATA_1.tBit.GPB10 = 0); \
N	} while(0)
X#define F_GPB10() 	do { 		(GPIO->tGPIO_DATA_1.tBit.GPB10 = 1); 		(GPIO->tGPIO_DATA_1.tBit.GPB10 = 0); 	} while(0)
N
N#define F_GPB11() \
N	do { \
N		(GPIO->tGPIO_DATA_1.tBit.GPB11 = 1); \
N		(GPIO->tGPIO_DATA_1.tBit.GPB11 = 0); \
N	} while(0)
X#define F_GPB11() 	do { 		(GPIO->tGPIO_DATA_1.tBit.GPB11 = 1); 		(GPIO->tGPIO_DATA_1.tBit.GPB11 = 0); 	} while(0)
N
N#define F_GPB36() \
N	do { \
N		(GPIO->tGPIO_DATA_1.tBit.GPB36 = 1); \
N		(GPIO->tGPIO_DATA_1.tBit.GPB36 = 0); \
N	} while(0)
X#define F_GPB36() 	do { 		(GPIO->tGPIO_DATA_1.tBit.GPB36 = 1); 		(GPIO->tGPIO_DATA_1.tBit.GPB36 = 0); 	} while(0)
N
N#define F_GPB37() \
N	do { \
N		(GPIO->tGPIO_DATA_1.tBit.GPB37 = 1); \
N		(GPIO->tGPIO_DATA_1.tBit.GPB37 = 0); \
N	}while(0)
X#define F_GPB37() 	do { 		(GPIO->tGPIO_DATA_1.tBit.GPB37 = 1); 		(GPIO->tGPIO_DATA_1.tBit.GPB37 = 0); 	}while(0)
N
N
Nextern void GPIO_Initialize(void);
N//extern void GPIO_SetConfiguration();
N
N
Nvoid init_EXITs(EXIT_Typedef* EXIT_InitStruct);
Nvoid writeBitToGPIO(EnumGPIO pin, EnumBit val);
Nvoid initGPIOs(GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid initGPIO(EnumGPIO pin, GpModeValue_TypeDef GPIO_Mode,GpIoconValue_TypeDef GPIO_Config);
Nvoid init_EXIT(EnumGPIO pin, uint8_t LevelDetection, uint8_t BothEdge, uint8_t PositivePolarity, uint8_t EnableInterrupt);
N
N#if USED_GPIO_TEST_HANDSHAKE
X#if ((1==0))
Sextern void _____TEST_GPB09_HandShake(uint32_t ulNum, uint32_t ulusecDelay);
N#else /* USED_GPIO_TEST_HANDSHAKE */
N#define _____TEST_GPB09_HandShake(a, b)
N#endif /* USED_GPIO_TEST_HANDSHAKE */
N
N
N#endif /* _GPIO_H_ */
L 50 "..\..\Hal\hal_def.h" 2
N#include "i2c.h"
L 1 "..\..\Hal\i2c\i2c.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : gdma.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _I2C_H_
N#define _I2C_H_
N
N
Nextern void I2C_Initialize(void);
Nextern void I2C_DeInitialize(void);
Nextern uint8_t CheckI2CReady(void);
N
N
N#endif /* _I2C_H_ */
N
L 51 "..\..\Hal\hal_def.h" 2
N#include "pwmdrv.h"
L 1 "..\..\Hal\pwmdrv\pwmdrv.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : pwmdrv.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _PWMDRV_H_
N#define _PWMDRV_H_
N
N
N
N#if USED_FINGER_ONLY
X#if ((0==0))
N#include "LGD\parameter_pwm_finger.h"
L 1 "..\..\Parameter\LGD\parameter_pwm_finger.h" 1
N/****************************************************************************************************/ /**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : parameter_pwm_finger.h
N * created on : 18. 9. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *	 notice, this list of conditions and the following disclaimer.
N *	 - Redistributions in binary form must reproduce the above copyright
N *	 notice, this list of conditions and the following disclaimer in the
N *	 documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *	 to endorse or promote products derived from this software without
N *	 specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _CUSTOM_PWM_FINGER_H_
N#define _CUSTOM_PWM_FINGER_H_
N
N
N#define PWMDRV_DEF_FW_CTRL_PEN_MODE			(0)
N#define PWMDRV_DEF_DSSS_CFG_BEACON_EN		(0)
N#define PWMDRV_DEF_DSSS_CFG_PING_EN			(0)
N
N#define PWMDRV_DEF_PRE_0_TX_PRD_usec		(91)
N//#define PWMDRV_DEF_PRE_0_TX_LOW				(0)
N//#define PWMDRV_DEF_PRE_1_TX_NUM				(0)
N#define PWMDRV_DEF_PRE_1_PRE_DLY			(0)
N#define PWMDRV_DEF_PRE_2_DSSS_DLY_12MCNT	(0)
N
N#define PWMDRV_DEF_GBL_ENA_PRTX_P0			(0)
N#define PWMDRV_DEF_GBL_ENA_PRTX_D0			(0)
N#define PWMDRV_DEF_GBL_ENA_DSSS_P			(0)
N#define PWMDRV_DEF_GBL_ENA_DSSS_D			(0)
N#define PWMDRV_DEF_GBL_ENA_PRTX_P1			(0)
N#define PWMDRV_DEF_GBL_ENA_PRTX_D1			(0)
N#define PWMDRV_DEF_GBL_ENA_ACTX_PD			(1)
N
N#define PWMDRV_DEF_ENA_PWM_0_T_0_DSSS		(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_0_PRE		(1)
N#define PWMDRV_DEF_ENA_PWM_0_T_0_ACT		(1)
N#define PWMDRV_DEF_ENA_PWM_0_T_0_PRE_LFD_0	(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_0_PRE_LFD_1	(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_0_ACT_LFD_0	(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_0_ACT_LFD_1	(1)
N
N#define PWMDRV_DEF_ENA_PWM_0_T_1_DSSS		(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_1_PRE		(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_1_ACT		(1)
N#define PWMDRV_DEF_ENA_PWM_0_T_1_PRE_LFD_0	(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_1_PRE_LFD_1	(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_1_ACT_LFD_0	(0)
N#define PWMDRV_DEF_ENA_PWM_0_T_1_ACT_LFD_1	(1)
N
N#if (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_91K)
X#if (((2)) == (2))
N#define PWMDRV_DEF_FG_F_F0_ACT_PRD_KHz		(100)
N#elif (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_133K)
S#define PWMDRV_DEF_FG_F_F0_ACT_PRD_KHz		(133)
S#elif (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_150K)
S#define PWMDRV_DEF_FG_F_F0_ACT_PRD_KHz		(150)
S#else /* (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_200K) */
S#define PWMDRV_DEF_FG_F_F0_ACT_PRD_KHz		(200)
N#endif /* (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_91K) */
N
N#if (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_91K)
X#if (((2)) == (2))
N#if USED_PLL_OUT_CLK_CONFIG
X#if ((1==0))
S		#if (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz) // MSPI 16M
S		#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(0)//(0) //BOE 35
S		#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(0)//(0) //BOE 35
S	#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_90MHz) // MSPI 15M
S		#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(0)//(0) //BOE 35
S		#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(0)//(0) //BOE 35
S	#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_45MHz) // MSPI 11.3M
S		#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(30)//(0) //BOE 35
S		#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(100)//(0) //BOE 35 11.3M
S	#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_37p5MHz) // MSPI 9.4M
S		#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(40)//(0) //BOE 35
S		#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(120)//(0) //BOE 35.4M
S	#elif (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_31p5MHz) // MSPI 7.9M
S		#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(50)//(0) //BOE 35
S		#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(160)//(0) //BOE 35
S	#else /* (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz) */ // MSPI 15M
S		#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(0)//(0) //BOE 35
S		#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(0)//(0) //BOE 35
S		#define MSPI_CLOCK_DIV						(MSPI_CLOCK_DIV_3) // 15M
S	#endif /* (PLL_OUT_CLOCK_SPEED == PLL_OUT_CLOCK_96MHz) */
N#else /* USED_PLL_OUT_CLK_CONFIG */
N		#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(0)//(0) //BOE 35
N		#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(0)//(0) //BOE 35
N#endif /* USED_PLL_OUT_CLK_CONFIG */
N#elif (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_133K)
S#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(0) //BOE 35
S#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(0)//(0) //BOE 35
S#elif (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_150K)
S#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(0) //BOE 35
S#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(0)//(0) //BOE 35
S#else /* (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_200K) */
S#define PWMDRV_DEF_FG_F_F0_ACT_DLY_usec		(30) //BOE 35
S#define PWMDRV_DEF_FG_F_F1_END_DLY_usec		(0)//(0) //BOE 35
N#endif /* (PWMDRV_USED_FREQUENCY == PWMDRV_FREQUENCY_91K) */
N
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N//#define PWMDRV_DEF_
N
N
N#endif /* _CUSTOM_PWM_FINGER_H_ */
L 40 "..\..\Hal\pwmdrv\pwmdrv.h" 2
N#else /* USED_FINGER_ONLY */
S#include "LGD\parameter_pwm_pen.h"
N#endif /* USED_FINGER_ONLY */
N
N
N
N#define PWM_FINGER_MODE				(0)
N#define PWM_PEN_MODE				(1)
N#define PWM_DEFAULT_SET				PWM_FINGER_MODE
N
N#define TSYNC_LHB					(1)
N
N#define INTR_CFG_SINGLE_EDGE 		(0)
N#define INTR_CFG_BOTH_EDGE 			(1)
N#define INTR_CFG_FALLING_EDGE 		(0)
N#define INTR_CFG_RISING_EDGE 		(1)
N#define INTR_CFG_DISABLE 			(0)
N#define INTR_CFG_ENABLE 			(1)
N
N#define PWM_FINGER 					(0x0)
N#define PWM_PEN_POSITON				(0x1)
N#define PWM_PEN_DATA 				(0x2)
N#define PWM_BEACON      			(0x3)
N
N#define ENA_DSSS					(0x01)
N#define ENA_PRE						(0x02)
N#define ENA_ACT						(0x04)
N#define ENA_PRE_LFD0				(0x08)
N#define ENA_PRE_LFD1				(0x10)
N#define ENA_ACT_LFD0				(0x20)
N#define ENA_ACT_LFD1				(0x40)
N
N#define PWMDRV_DSSS_CODE_0			(0x00)
N#define PWMDRV_DSSS_CODE_1			(0x01)
N#define PWMDRV_DSSS_CODE_2			(0x02)
N#define PWMDRV_DSSS_CODE_3			(0x03)
N#define PWMDRV_DSSS_CODE_4			(0x04)
N#define PWMDRV_DSSS_CODE_5			(0x05)
N#define PWMDRV_DSSS_CODE_6			(0x06)
N#define PWMDRV_DSSS_CODE_7			(0x07)
N#define PWMDRV_DSSS_CODE_8			(0x08)
N#define PWMDRV_DSSS_CODE_9			(0x09)
N#define PWMDRV_DSSS_CODE_A			(0x0A)
N#define PWMDRV_DSSS_CODE_B			(0x0B)
N#define PWMDRV_DSSS_CODE_C			(0x0C)
N#define PWMDRV_DSSS_CODE_D			(0x0D)
N#define PWMDRV_DSSS_CODE_E			(0x0E)
N#define PWMDRV_DSSS_CODE_F			(0x0F)
N#define PWMDRV_DSSS_CODE_P			(0x10)
N#define PWMDRV_DSSS_CODE_N			(0x18)
N
N#define PWM_PEN_POSITON 			(0x1)
N#define PWM_PEN_DATA 				(0x2)
N#define PWM_BEACON      			(0x3)
N
N#define Touch_CLK 					(12E+6)								// 12MHz
N#define PWM_us(val)					((val == 0) ? 0 : (((Touch_CLK/1E+6)*(val))-3))			// unit us
N//#define PWM_KHz(val)				((Touch_CLK/1000)/(val))
N#define PWM_Full_PRD_KHz(val)		((val == 0) ? 0 : ((12000 / val)-2))
N#define PWM_Half_PRD_KHz(val)		((val == 0) ? 0 : ((6000 / val)-2))
N
N#define us_to_cnt_at_12MHz(val) 	(val*12)
N#define ms_to_cnt_at_12MHz(val) 	(val*12*1000)
N#define kHz_to_cnt_at_12MHz(val) 	(12000/val)
N
N#define LHB1		1
N#define LHB2		2
N#define LHB3		3
N#define LHB4		4
N#define LHB5		5
N#define LHB6		6
N#define LHB7		7
N#define LHB8		8
N#define LHB9		9
N#define LHB10		10
N#define LHB11		11
N#define LHB12		12
N#define LHB13		13
N#define LHB14		14
N#define LHB15		15
N#define LHB16		16
N
N
N
Nvoid PWMDRV_PRE(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t PRE_DLY, uint16_t DSSS_DLY);
Nvoid PWMDRV_FG_F_F0_ACT(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t DLY, uint16_t LINE_NUM);
Nvoid PWMDRV_FG_F_F1_ACT(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t DLY, uint16_t LINE_NUM);
Nvoid PWMDRV_FG_F_F2_ACT(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t DLY, uint16_t LINE_NUM);
Nvoid PWMDRV_FG_F_F3_ACT(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t DLY, uint16_t LINE_NUM);
Nvoid PWMDRV_FG_L_F0_ACT(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t DLY, uint16_t LINE_NUM);
Nvoid PWMDRV_PN_P_ACT(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t DLY, uint16_t LINE_NUM);
Nvoid PWMDRV_PN_D_ACT(uint16_t TX_PRD, uint16_t TX_LOW, uint16_t TX_NUM, uint16_t DLY, uint16_t LINE_NUM);
N/************************************************************/
Nextern void PWMDRV_Initialize(void);
Nextern void PWMDRV_Init(eSENSING_MODE_t eSensingMode);
Nextern void PWMDRV_GPIO_Init(eSENSING_MODE_t eSensingMode);
Nextern void PWMDRV_Cmd(FunctionalState NewState);
Nextern void PWMDRV_ITConfig(FunctionalState NewState);
N/************************************************************/
Nextern void PWMDRV_SectionEnable(eSENSING_MODE_t mode);
Nextern void PWMDRV_Set_DSSS(void);
Nextern void PWMDRV_Set_VSWT(void);
Nextern void PWMDRV_Set_Pulse_Config(eSENSING_MODE_t eSensingMode);
Nextern void PWMDRV_Set_Mode(eSENSING_MODE_t mode);
N
N
N#endif /* _PWMDRV_H_ */
L 52 "..\..\Hal\hal_def.h" 2
N#include "scrb/scrb.h"
L 1 "..\..\Hal\scrb/scrb.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : scrb.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _SCRB_H_
N#define _SCRB_H_
N
N
N#define SCB_VECTKEY_VALUE  				(0x05FA)
N#define SCB_VECTKEY       				(SCB_VECTKEY_VALUE << 16)
N
N#define TMCU_MAIN_NOTRIM_CLOCK_SPEED	(12)
N#define TMCU_MAIN_TRIM_CLOCK_SPEED		(72)//(90)
N
N
Ntypedef enum
N{
N	CLK_ENA_USB = 0,
N	CLK_ENA_WDT = 1,
N	CLK_ENA_TIM = 2,
N	CLK_ENA_PWMDRV = 3,
N	CLK_ENA_TSPI = 4,
N	CLK_ENA_DSPA = 5,
N	CLK_ENA_DSPB = 6,
N	CLK_ENA_SRAM1 = 7,
N	CLK_ENA_SRAM2 = 8,
N	CLK_ENA_SRAM3 = 9,
N	CLK_ENA_DMAC = 10,
N	CLK_ENA_I2C = 11,
N	CLK_ENA_FLITF = 12,
N	CLK_ENA_GPIO = 13,
N
N	CLK_ENA_MSPI01 = 14,
N	CLK_ENA_MSPI23 = 15,
N	CLK_ENA_MSPI45 = 16,
N	CLK_ENA_SIF = 17,
N	CLK_ENA_SFL = 18,
N
N} eCLK_ENA_BLOCK_t;
N
Nextern void SCRB_Initialize(void);
N
N#endif /* _SCRB_H_ */
L 53 "..\..\Hal\hal_def.h" 2
N#include "mspi.h"
L 1 "..\..\Hal\spi\mspi.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : mspi.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MSPI_H_
N#define _MSPI_H_
N
N
N#if USED_FINGER_ONLY
X#if ((0==0))
N#include "LGD\parameter_mspi_finger.h"
L 1 "..\..\Parameter\LGD\parameter_mspi_finger.h" 1
N/****************************************************************************************************/ /**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : parameter_mspi_finger.h
N * created on : 18. 9. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *	 notice, this list of conditions and the following disclaimer.
N *	 - Redistributions in binary form must reproduce the above copyright
N *	 notice, this list of conditions and the following disclaimer in the
N *	 documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *	 to endorse or promote products derived from this software without
N *	 specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _CUSTOM_MSPI_FINGER_H_
N#define _CUSTOM_MSPI_FINGER_H_
N
N
N#define MSPI_GPIO_SRIC0_EN			(YES)
N#define MSPI_GPIO_SRIC1_EN			(YES)
N#define MSPI_GPIO_SRIC2_EN			(YES)
N#define MSPI_GPIO_SRIC3_EN			(YES)
N#define MSPI_GPIO_SRIC4_EN			(YES)
N#define MSPI_GPIO_SRIC5_EN			(YES)
N
N
N#endif /* _CUSTOM_MSPI_FINGER_H_ */
L 39 "..\..\Hal\spi\mspi.h" 2
N#else /* USED_FINGER_ONLY */
S#include "LGD\parameter_mspi_pen.h"
N#endif /* USED_FINGER_ONLY */
N
N
N//----------------------------------------------------------------------------------------------
N// MSPI Macro
N//----------------------------------------------------------------------------------------------
N#define SPI_SYSTEM_CLOCK							((uint32_t)20000000)
N#define MSPI_MEM_INDEX(ADDR)                        ((((uint32_t)ADDR) - BASE_MSPI_SRAM)>>2)
N#define MSPI_MEM_MSB(ADDR)                        (((((uint32_t)ADDR) - BASE_MSPI_SRAM)>>2))<<16
N#define MSPI_MEM_LSB(ADDR)                        ((((uint32_t)ADDR) - BASE_MSPI_SRAM)>>2)
N
N#define INTR_MEM_ENA            					BIT6
N#define INTR_AIT_WLV_ENA        					BIT8
N
N#define SPI_nSS_Auto                                ENABLE
N#define SPI_nSS_ExternalTrigger                     DISABLE
N
N#define SPI_nSS_Ext_Disable                         ENABLE
N#define SPI_nSS_Ext_Enable                          DISABLE
N
N#define TX_FIFO_IT                              	0x00000001
N#define RX_FIFO_IT                              	0x00000002
N#define RX_FIFO_OVERUN_IT                       	0x00000004
N
N#define SPISR_BUSY                              	0x00000001
N#define SPISR_TxFifoEmpty                       	0x00000002
N#define SPISR_TxFifoNotFull                     	0x00000004
N#define SPISR_TxFifoUnderWaterlevel             	0x00000008
N#define SPISR_RxFifoEmpty                       	0x00000020
N#define SPISR_RxFifoNotFull                     	0x00000040
N#define SPISR_RxFifoUnderWaterlevel             	0x00000080
N#define SPISR_RxOverRun                         	0x00000100
N
N#define SCLK_IS_PCLK_DIV2							(NO)
N#define SCLK_IS_PCLK_DIV4							(NO)
N#define SCLK_IS_PCLK_DIV6							(YES)
N#define SCLK_IS_PCLK_DIV8							(NO)
N
N#define HCLKCOMMEND_DIV2        (0x13)
N#define HCLKCOMMEND_DIV3        (0x13)
N#define HCLKCOMMEND_DIV4        (0x43)
N#define HCLKCOMMEND_DIV6        (0x63)
N#define HCLKCOMMEND_DIV8        (0x83)
N
N#define PCLKEND_DIV2            (0x2212)
N#define PCLKEND_DIV3            (0x3323)
N#define PCLKEND_DIV4            (0x4434)
N#define PCLKEND_DIV6            (0x4656)
N#define PCLKEND_DIV8            (0x6878)
N
N#define MSPI0_SEL               (BIT(0)|BIT(8))
N#define MSPI1_SEL               (BIT(1)|BIT(9))
N#define MSPI2_SEL               (BIT(2)|BIT(10))
N#define MSPI3_SEL               (BIT(3)|BIT(11))
N#define MSPI4_SEL               (BIT(4)|BIT(12))
N#define MSPI5_SEL               (BIT(5)|BIT(13))
N
N#define MSPI_RX_EN_0			(BIT(8))
N#define MSPI_RX_EN_1			(BIT(9))
N#define MSPI_RX_EN_2			(BIT(10))
N#define MSPI_RX_EN_3			(BIT(11))
N#define MSPI_RX_EN_4			(BIT(12))
N#define MSPI_RX_EN_5			(BIT(13))
N
N#define MSPI_READ               BIT15
N#define MSPI_WRITE              (0)
N#define MSPI_SINGLE             BIT14
N#define MSPI_BURST              (0)
N
N#define IDX_SEND                (0)
N#define IDX_READ                (1)
N
N#define MSPI0					(0)
N#define MSPI1					(1)
N#define MSPI2					(2)
N#define MSPI3					(3)
N#define MSPI4					(4)
N#define MSPI5					(5)
N
N// LX98405 New
Ntypedef enum {
N
N	MSPI_READ_NONE,
N	MSPI_READ_SM0,
N	MSPI_READ_SM1,
N
N} eROIC_Read_Option_t;
N
N
N
Ntypedef enum {
N	LOCAL_0TH_POSITION=0,
N	LOCAL_2ND_POSITION=2,
N	LOCAL_4TH_POSITION=4,
N	LOCAL_6TH_POSITION=6,
N	LOCAL_8TH_POSITION=8,
N	LOCAL_10TH_POSITION=10,
N	LOCAL_12TH_POSITION=12,
N	LOCAL_14TH_POSITION=14,
N	LOCAL_16TH_POSITION=16,
N	LOCAL_18TH_POSITION=18,
N	LOCAL_20TH_POSITION=20,
N	LOCAL_22ND_POSITION=22,
N	LOCAL_24TH_POSITION=24,
N	LOCAL_26TH_POSITION=26,
N	LOCAL_28TH_POSITION=28,
N	LOCAL_30TH_POSITION=30,
N	LOCAL_32ND_POSITION=32,
N	LOCAL_34TH_POSITION=34,
N	LOCAL_36TH_POSITION=36,
N	LOCAL_38TH_POSITION=38,
N	LOCAL_40TH_POSITION=40
N} enum_LOCAL_SENGSING_POSITION;
N
N
Nvoid MSPI_Initialize(void);
Nvoid MSPI_Reset(void);
Nvoid MSPI_Set_TLPMODE(void);
Nvoid MSPI_Set_AITMODE(eSENSING_MODE_t eSensingMode);
Nvoid MSPI_Set_GLF(int divisor) ;
Nvoid MSPI_Set_CLK(int divisor);
Nvoid MSPI_ITConfig(FunctionalState NewState);
Nvoid MSPI_Cmd(FunctionalState NewState);
Nvoid MSPI_IntCLR(void);
N
N
N// LX98405 New ----------------------------------------------------------------------------
Nvoid MSPI_RegisterRead( uint32_t Addr, volatile uint32_t *ReadBuf,eROIC_Read_Option_t eOption);
Nvoid MSPI_RegisterAllSricWrite (uint32_t Addr, uint32_t value);
Nvoid MSPI_RegisterWrite( uint32_t Addr, uint32_t value,eROIC_Read_Option_t eOption);
N
N#if (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405)
X#if (((3)) == (2) || ((3)) == (3))
Nvoid MSPI_RegisterWriteBuf( uint32_t Addr, uint32_t *WriteBuf,eROIC_Read_Option_t eOption);
N#endif /* (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405) */
Nvoid MSPI_EachRegisterWrite( uint32_t Addr, uint32_t * pvalue, eROIC_Read_Option_t eOption);
N
N//----------------------------------------------------------------------------------------
N
N
N
Nvoid MSPI_CommandWrite( uint32_t write_control, uint32_t pen_mode, uint16_t local_position);
N
Nvoid MSPI_Set_BUFSIZE_FingerPenMode(int index);
N#if (!USED_FINGER_ONLY)
X#if (!((0==0)))
Svoid MSPI_Set_BUFSIZE_FingerMode(int index);
N#endif /* (!USED_FINGER_ONLY) */
Nvoid MSPI_Set_BUFAddress_FingerMode(int index);
N
N
Nvoid MSPI_Single_Write(uint8_t ch, uint16_t Addr, uint16_t value);
Nuint16_t MSPI_Single_Read(uint8_t ch, uint16_t Addr);
N
N
N
N
N/*******************************************************************/
Nvoid MSPI_Set_FingerMode(void);
Nvoid MSPI_GPIO_Init(void);
N
N
N#endif /* _MSPI_H_ */
L 54 "..\..\Hal\hal_def.h" 2
N#include "tspi.h"
L 1 "..\..\Hal\spi\tspi.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : tspi.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _TSPI_H_
N#define _TSPI_H_
N
N
N//#define SPI_SYSTEM_CLOCK							    ((uint32_t)20000000)
N
N#define SPI_DataBit_8bit							    0x00
N#define SPI_DataBit_10bit							    0x01
N#define SPI_DataBit_12bit							    0x02
N#define SPI_DataBit_16bit							    0x03
N
N#define SPI_MOSI_Enable                         	    ENABLE
N#define SPI_MOSI_Disable                        	    DISABLE
N
N#define LeadingEdge_Setup_TrailingEdge_Sample		    ENABLE
N#define LeadingEdge_Sample_TrailingEdge_Setup		    DISABLE
N
N#define LeadingEdge_Falling_TrailingEdge_Rising		    ENABLE
N#define LeadingEdge_Rising_TrailingEdge_Falling		    DISABLE
N
N#define SPI_Master									    ENABLE
N#define SPI_Slave									    DISABLE
N
N#define SPI_LSB										    ENABLE
N#define SPI_MSB										    DISABLE
N
N#define SPI_LOOP_BACK_Enable						    ENABLE
N#define SPI_LOOP_BACK_Disable						    DISABLE
N
N#define TX_FIFO_IT                              	    0x00000001
N#define RX_FIFO_IT                              	    0x00000002
N#define RX_FIFO_OVERUN_IT                       	    0x00000004
N
N#define SPI_TX_DMA_Enable                               BIT12
N#define SPI_RX_DMA_Enable                               BIT13
N#define SPI_TX_DMA_Disable                              0x00000003
N#define SPI_RX_DMA_Disable                              0x00000004
N
N#define SPI_DMA_SIZE                                	64
N#define SPI_IT_ENABLE
N#define SPI_DMA_ENABLE
N
N#define SPISR_BUSY                                      0x00000001
N#define SPISR_TxFifoEmpty                               0x00000002
N#define SPISR_TxFifoNotFull                             0x00000004
N#define SPISR_TxFifoOverWaterlevel                      0x00000008
N#define SPISR_TxFifoOverflow                            0x00000010
N#define SPISR_TxFifoUnderrun                            0x00000020
N        
N#define SPISR_RxFifoNotEmpty                            0x00000040
N#define SPISR_RxFifoFull                                0x00000080
N#define SPISR_RxFifoOverWaterlevel                      0x00000100
N#define SPISR_RxFifoOverflow                            0x00000200
N#define SPISR_RxFifoUnderrun                            0x00000400
N        
N#define SPIINTERRUPT_TXFIFO                             0x00000001
N#define SPIINTERRUPT_RXFIFO                             0x00000002
N#define SPIINTERRUPT_TXUNDERRUN                         0x00000004
N#define SPIINTERRUPT_RXUNDERRUN                         0x00000008
N#define SPIINTERRUPT_TXOVERRUN                          0x00000010
N#define SPIINTERRUPT_RXOVERRUN                          0x00000020
N        
N#define SPI_TXFIFO_CLEAR                                0x00000001
N#define SPI_RXFIFO_CLEAR                                0x00000002
N        
N#define PIN_TSPI_SLV_SSN                                GPIO_Pin_4
N#define PIN_TSPI_SLV_SCLK                               GPIO_Pin_5
N#define PIN_TSPI_SLV_MOSI                               GPIO_Pin_6
N#define PIN_TSPI_SLV_MISO                               GPIO_Pin_7
N
Ntypedef struct
N{
N    volatile int bRunning;
N    volatile int bIsSlotData;
N    volatile int bSampleDone;
N} tTSPI_status_t;
N
Nextern tTSPI_status_t MSPI_Status;
Nextern tTSPI_status_t TSPI_Status;
N
Nextern void init_tspi(void);
N
Nextern void TSPI_MasterDataSend(uint16_t data);
Nextern uint16_t TSPI_ReceiveData(void);
N
Nextern void TSPI_MasterBufferSendBytes(volatile uint8_t* buffer, uint8_t Sz);
Nextern void TSPI_MasterBufferReadBytes(volatile uint8_t* buffer, uint8_t Sz);
Nextern void TSPI_MasterBufferRead2Bytes(volatile uint16_t* buffer, uint8_t Sz);
Nextern void TSPI_DmaChannelInit(uint8_t Mode, volatile uint16_t* pDMAbuffer, uint16_t DMAbufferSize);
N
N
N
N// SPICR Reg Typedef
Ntypedef union
N{
N    uint32_t pReg;
N    struct
N    {
N        uint32_t BITLEN:2;                  // Bit Length                               2    00:8bit, 01:10Bit, 02:12Bit, 03:16Bit
N        uint32_t DOUTEN:1;                  // Data Out Enable                          3    1:MOSI Enable, 0:Disable
N        uint32_t CPHA:1;                    // Clock Phase                              4    1:Leading Edge - Setup, Trailing Edge - Sample,   0: Leading Edge - Sample, Trailing Edge - Setup
N        uint32_t CPOL:1;                    // Clock Polarity                           5    1:Leading Edge - Falling, Trailing Edge - Rising,   0:Leading Edge - Rising, Trailing Edge - Falling
N        uint32_t MSTR:1;                    // Mster/Slave Select                       6    1:Master, 0:Slave
N        uint32_t DORD:1;                    // Data Order                               7    1:LSB First, 0:MSB First (Default)
N        uint32_t SPE:1;                     // SPI Enable                               8
N        uint32_t LBM:1;                     // LooP Back Mode                           9    1:LOOP_BACK_MODE, 0:Normal Operation
N        uint32_t SSOSEL:1;                  // SSO Select                               10   1:External Control SSO Signal, 0:Auto Generation SSO SPI Slave Select
N        uint32_t SSOEXT:1;                  // Master SSO Signal Register Setting       11   1:Master Slave Select Disable, 0:Master Slave Select Enable
N        uint32_t NOT_USED1:5;               // Not Used                                 12     Not Used
N        uint32_t SPR:3;                     // SPI Baud Rate Select Bit                 17   SPI SCLK Frequency Control at Master Mode
N        uint32_t NOT_USED2:1;               // Not Used                                 20     Not Used
N        uint32_t SPPR:3;                    // SPI Baud Rate Pre-selection Bits         21   SPI SCLK Frequency Control at Master Mode
N        uint32_t NOT_USED3:9;               // Not Used                                 24     Not Used
N    } Reg;
N} TSPI_SPICR_TypeDef;
N
N// SPIDR Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct{
N		// TX
N		uint32_t DR 		:16;		// Data Register,				1	Transmit /Receive FIFO
N		uint32_t NOT_USED   :16;        // Not Used                    24     Not Used
N	}Reg;
N} TSPI_SPIDR_TypeDef;    
N    
N// SPISR Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct{
N		// TX
N		uint32_t BUSY		:1;		// Busy Flag,				1	1:transmitting and/or receiving or FIFO empty
N		uint32_t TFE		:1;		// Tx FIFO Empty Status		2	1:Tx FIFO empty, 0:Tx FIFO not empty
N		uint32_t TNF		:1;		// Tx FIFO Full Status		3	1:Tx FIFO is not full, 0:Tx FIFO is full
N		uint32_t TWMLF		:1;		// Tx FIFO Water L. Full	4	1:Tx FIFO >= Tx Water Level,   0:Tx FIFO < Tx Water Level
N		uint32_t TFOF		:1;		// Tx FIFO Over Flow Status	5	1:Tx FIFO is Overflow,	0:Tx FIFO is not OverFlow
N		uint32_t TFUR		:1;		// Tx FIFO Under Run		6	1:Tx FIFO is UnderRun	0:Tx FIFO is not UnderRun
N
N		// RX
N		uint32_t RNE		:1;		// Rx FIFO Empty Status		6	1:Rx FIFO empty, 0:Rx FIFO not empty
N		uint32_t RFF		:1;		// Rx FIFO Full Status		7	1:Rx FIFO is full, 0:Rx FIFO is not full
N		uint32_t RWMLF		:1;		// Rx FIFO Water L. Full	8	1:Rx FIFO >= Rx Water Level,	0:Rx FIFO < Rx Water Level
N		uint32_t RFOF		:1;		// Rx FIFO Over Flow Status	9	1:Rx FIFO is OverFlow	0: Rx FIFO is not OverFlow
N		uint32_t RFUR		:1;		// Rx FIFO Under Run		10	1:Rx FIFO is UnderRun	0: Rx FIFO is not UnderRun
N		uint32_t NOT_USED	:22;	//							32  
N	}Reg;
N} TSPI_SPISR_TypeDef;
N
N// SPIFIFOCR Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct{
N		uint32_t TXFCLR		:1;		// Tx FIFO CLR,					1	1:Clear (Autoclear), 2:Normal OP
N		uint32_t RXFCLR		:1;		// Rx FIFO CLR,					2   1:Clear (Autoclear), 2:Normal OP
N		uint32_t TXFWML		:5;		// Tx FIFO Water Mark Level,	7
N		uint32_t RXFWML		:5;		// RX FIFO Water Mark Level,	12
N		uint32_t DMATE		:1;		// DMA Tx Enable,				13
N		uint32_t DMARE		:1;		// DMA Rx Enable,				14
N		uint32_t TXFECLR	:1;		// TX FIFO Error Clear,			15
N		uint32_t RXFECLR	:1;		// RX FIFO Error Clear,			16
N		uint32_t NOT_USED	:16;	//								32
N	}Reg;
N} TSPI_SPIFIFOCR_TypeDef;
N
N// SPIINTRSR Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct{
N		uint32_t TXIS		  :1;		// Tx FIFO Interrupt State,				    1
N		uint32_t RXIS		  :1;		// Rx FIFO Interrupt State,				    2
N    uint32_t TXURIS		:1;		// TX FIFO UnderRun Interrupt State,	    3
N    uint32_t RXURIS		:1;		// RX FIFO UnderRun Interrupt State,	    4
N		uint32_t TORIS		:1;		// TX FIFO Receive Overrun Interrupt State, 5
N    uint32_t RORIS		:1;		// RX FIFO Receive Overrun Interrupt State, 6
N		uint32_t NOT_USED	:26;	//	    									
N	}Reg;
N} TSPI_SPIINTRSR_TypeDef;
N
N// SPIINTRENCR Reg Typedef -> SPIINTRENCR Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct{
N		uint32_t TXIE		:1;		// Tx FIFO Interrupt Enable,			        1
N		uint32_t RXIE		:1;		// Rx FIFO Interrupt Enable,			        2
N		uint32_t TXURIE		:1;		// Tx FIFO UnderRun Interrupt Enable,	        3
N		uint32_t RXURIE		:1;		// Rx FIFO UnderRun Interrupt Enable,	        4
N		uint32_t TORIE		:1;		// Tx FIFO Receive OverRun Interrupt Enable,	5
N		uint32_t RORIE		:1;		// Rx FIFO Receive OverRun Interrupt Enable,	6
N		uint32_t NOT_USED	:26;	//											
N	}Reg;
N} TSPI_SPIINTRENCR_TypeDef; 
N
N// SPIINTRCLR Reg Typedef -> SPIINTRCLR Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct{
N		uint32_t ICLR		:1;		// SPI Interrupt Clear  			        1
N		uint32_t NOT_USED	:31;	//											
N	}Reg;
N} TSPI_SPIINTRCLR_TypeDef; 
N
N// SPIMISC Reg Typedef -> SPIMISC Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct{
N		uint32_t SPIMISC		:1;		// SPI MISC Register  			        1
N		uint32_t NOT_USED	    :31;	//											
N	}Reg;
N} TSPI_SPIMISC_TypeDef; 
N
N// SPIINTRMSCR Reg Typedef
Ntypedef union
N{
N	uint32_t pReg;
N	struct
N	{
N		uint32_t TXI:1;                     // Tx FIFO Interrupt Enable,          1
N		uint32_t RXI:1;                     // Rx FIFO Interrupt Enable,          2
N		uint32_t RORI:1;                    // Rx OverRun Interrupt Enable        3
N		uint32_t NOT_USED:29;               //                                    32
N	} Reg;
N} TSPI_INTMSCR_TypeDef;
N
N
Ntypedef struct
N{
N	uint32_t	SPI_DataBit;
N	uint32_t	SPI_DataOut;
N	uint32_t	SPI_CPhase;
N	uint32_t	SPI_CPolority;
N	uint32_t	SPI_Mode;
N	uint32_t	SPI_FirstBitOrder;
N	uint32_t	SPI_LPBack;
N	uint32_t	SPI_BaudRate;
N	uint32_t	SPI_TxWaterLevel;
N	uint32_t	SPI_RxWaterLevel;
N} TSPI_InitTypeDef;
N
N
N#endif /* _TSPI_H_ */
L 55 "..\..\Hal\hal_def.h" 2
N#include "systick.h"
L 1 "..\..\Hal\timer\systick.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : systick.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _SYSTICK_H_
N#define _SYSTICK_H_
N
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N	
N/**
N  * @}
N  */
N#define SYSTIC_TYPE							uint64_t
N
N#define SYSTICK_MASK						(0x0000FFFF)
N#define SYSTICK_MAXCOUNT					(0x0000FFFF+1)
N#define SYSTICK_MAX_HIGHT_RANK_COUNT		(0xFFFFFFFF)
N#define SYSTICK_MAX_LONG_COUNT				(SYSTICK_MASK + SYSTICK_MAX_HIGHT_RANK_COUNT)//(0xFFFFFFFFFFFFFF)
N#define getSysTick()            			((SysTick->VAL)&SYSTICK_MASK)
N#define getLongSysTick()            		(((uint64_t)_systick_high_rank_count_<<16)|(uint64_t)((SysTick->VAL)&SYSTICK_MASK))
N#define getUSfromTick(tick)					(tick/(_core_clock_))
N#define getMSfromTick(tick)					(tick/(1000*_core_clock_-1))
N#define getElapsedUS(start)					getUSfromTick(getElapsedLongSYSTICK(start))
N
N#define delay_usec(t)		delay_us(t)
N#define delay_msec(t)		delay_ms(t)
N
Nvolatile extern uint32_t _systick_high_rank_count_;
Nvolatile extern uint32_t _core_clock_;
N
Nvoid SysTick_Initialize(uint32_t clk);
Nvoid SysTick_DeInitialize(void);
Nuint32_t getElapsedSYSTICK2(uint32_t start,uint32_t end);
Nuint32_t getElapsedSYSTICK(uint32_t start);
Nuint64_t getElapsedLongSYSTICK(uint64_t start);
Nuint64_t getElapsedTime_us(uint64_t start_tick);
Nvoid delay_us_useSystick(uint32_t time);
Nvoid delay_ms_useSystick(uint32_t time);
Nvoid delay_systick(uint32_t tick_count);
Nvoid delay_us(uint32_t time);
Nvoid delay_ms(uint32_t time);
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* _SYSTICK_H_ */
L 56 "..\..\Hal\hal_def.h" 2
N#include "timer.h"
L 1 "..\..\Hal\timer\timer.h" 1
N
N/****************************************************************************************************//**
N * @file     timer.h
N *
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File for
N *           default MTLP Device Series
N *
N * @version  Vrev.B
N * @date     19. April 2013
N *
N * @note     
N *           
N *           
N * @par      ARM Limited (ARM) is supplying this software for use with Cortex-M
N *           processor based microcontroller, but can be equally used for other
N *           suitable processor architectures. This file can be freely distributed.
N *           Modifications to this file shall be clearly marked.
N *           
N *           THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N *           OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N *           MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N *           ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N *           CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
N *
N *******************************************************************************************************/
N
N
N/* ================================================================================ */
N/* ================                     TIMER                      ================ */
N/* ================================================================================ */
N
N/**
N * @Brief  Flash Control Register
N */
N
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
Nextern uint8_t TMA0_cnt;
Nextern uint8_t TMB0_cnt;
Nextern uint8_t TMA1_cnt;
Nextern uint8_t TMB1_cnt;
N
Nextern uint8_t mode;
N	 
N//////////////////////////////
N
N#define	TIM_MAX_CNT_VAL						0xFFFFFFFF
N
N
N
N#define	TIMER_CLOCK_MASK					0xFC
N
N#define	TIM_EN_Set                 			0x01
N#define	TIM_EN_Reset            		  	0xFE
N
N#define	TIM_Mode_Run                 		0x00
N#define	TIM_Mode_Count                 		0x01
N
N#define	TIM_INT_Mask					    0x04
N#define	TIM_INT_Not_Mask			        0xFB
N//#define	TIM_PWM_Enable				        ((uint8_t)0x02)
N//#define	TIM_PWM_Disable				        ((uint8_t)0xFD)
N
N//#define	TIM_CAPTURE_Enable			        ((uint8_t)0x01)
N//#define	TIM_CAPTURE_Disable			        ((uint8_t)0xFE)
N
N//#define	TIM_INT_Set					        ((uint8_t)0x02)
N//#define	TIM_INT_Reset				        ((uint8_t)0xFD)
N
N
N//#define	TIM_MODE_FreeRunning		        ((uint8_t)0x00)
N//#define	TIM_MODE_Count		    	      	((uint8_t)0x10)
N
N#define	TIM_INT_Mask_DISABLE    	      	0x00
N#define	TIM_INT_Mask_EN		    	      	0x01
N
N#define OBSERVE_TIM_Init(ch)				HAL_Observe_Timer_Init(ch)
N#define OBSERVE_TIM_CLR(ch)                HAL_Observe_Timer_Clear(ch)
N#define OBSERVE_TIM_START(ch)                HAL_Observe_Timer_Start(ch)
N#define OBSERVE_TIM_END(ch)              HAL_Observe_Timer_Disable(ch)
N
N
N
Ntypedef enum
N{
N	TIM_Channel_0 = 0x00,
N	TIM_Channel_1 = 0x01,
N	TIM_Channel_2 = 0x02,
N	TIM_Channel_3 = 0x03,
N	TIM_Channel_4 = 0x04,
N	TIM_Channel_5 = 0x05,
N	TIM_Channel_6 = 0x06,
N	TIM_Channel_7 = 0x07
N}TIM_Channel;
N
Ntypedef struct
N{
N	uint8_t TIM_Mode;   			
N	uint8_t TIM_Int_Mask;
N	TIM_Channel TIM_Channel;
N	uint32_t TIM_Count;
N} TIM_TimeBaseInitTypeDef;       
N
N
N//////////////////////////////	 
Nextern void TIM_DeInit(TIM_Channel TIMx_Chanel);
Nvoid TIM_TimeBaseInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nextern void TIM_Cmd(TIM_Channel TIMx_Chanel, FunctionalState NewState);
Nextern void TIM_ITConfig(TIM_Channel TIMx_Chanel, FunctionalState NewState);
Nextern void TIM_SetCounter(TIM_Channel TIMx_Chanel, uint32_t Counter);
Nextern void TIM_CtrlCaptureInput(FunctionalState NewState) ;
Nextern void TIM_GetCounter(TIM_Channel TIMx_Chanel);
Nextern void TIM_GetITStatus(TIM_Channel TIMx_Chanel);
N
N
Nextern uint32_t TIM_EOIStatus(void);
Nextern void HAL_Timer_Init(void);
Nextern void HAL_Timer_Clear(void);
Nextern void HAL_Timer_Start(void);
Nextern void HAL_Timer_Get_Counter(void);
Nextern void HAL_Observe_Timer_Init(TIM_Channel TIMx_Chanel);
Nextern void HAL_Observe_Timer_Clear(TIM_Channel TIMx_Chanel);
Nextern uint32_t HAL_Observe_Timer_Disable(TIM_Channel TIMx_Chanel);
Nextern void HAL_Observe_Timer_Start(TIM_Channel TIMx_Chanel);
N
Nextern void HAL_Timer_Enable(TIM_Channel TIM_Channel_Idx, FunctionalState En);
Nextern void HAL_Timer_Set_Count_us(TIM_Channel TIM_Channel_Idx, uint32_t Count);
N
N#ifdef __cplusplus
S}
N#endif
N#endif
N
N
N
N
N
L 57 "..\..\Hal\hal_def.h" 2
N#include "wdgt.h"
L 1 "..\..\Hal\wdgt\wdgt.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : wdgt.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _WDGT_H_
N#define	_WDGT_H_
N
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N//#include "MFTP.h"
N
N
N#define	WDGT_Clear					      ((uint16_t)0x0001)
N
N#define	WDGT_AccessMask			    	((uint16_t)0x0001)
N
N#define	WDGT_CLOCK_PCLKDIVIDED2		((uint16_t)0x0000)
N#define	WDGT_CLOCK_PCLKDIVIDED4		((uint16_t)0x0001)
N#define	WDGT_CLOCK_PCLKDIVIDED8		((uint16_t)0x0002)
N#define	WDGT_CLOCK_PCLKDIVIDED16	((uint16_t)0x0003)
N#define	WDGT_CLOCK_PCLKDIVIDED32	((uint16_t)0x0004)
N#define	WDGT_CLOCK_PCLKDIVIDED64	((uint16_t)0x0005)
N#define	WDGT_CLOCK_PCLKDIVIDED128	((uint16_t)0x0006)
N#define	WDGT_CLOCK_PCLKDIVIDED256	((uint16_t)0x0007)
N
N#define	WDGT_CLOCK_MASK				    ((uint16_t)0x0007)
N
N#define	WDGT_WDGT_DisableMask		  ((uint16_t)0xFFF7)
N#define	WDGT_WDGT_Enable			    ((uint16_t)0x0008)
N 
N#define	WDGT_INT_DisableMask		  ((uint16_t)0xFFEF)
N#define	WDGT_INT_Enable				    ((uint16_t)0x0010)
N
N#define	WDGT_RESET_DisableMask	  ((uint16_t)0xFFDF)
N#define	WDGT_RESET_Enable			    ((uint16_t)0x0020)
N
N#define	WDGT_OVERFLOW_Status		  ((uint16_t)0x0040)
N#define	WDGT_INTERRUPT_Status		  ((uint16_t)0x0080)
N
N#define	WDGT_RESET_Status			    ((uint16_t)0x0100)
N
N#define	WDGT_ACCEDSS_KEY			    ((uint16_t)0xACCE)
N
N
N
N
N//#define	Peripheral_UsrWdgtClr_ADDRESS			0x40008000
N
N//#define	UsrWdgtClr_Band_Offset					(Peripheral_UsrWdgtClr_ADDRESS - PERI_BIT_BAND_Base)
N//#define UsrWdgt_Clr_Offset						0
N//#define	USRWDGT_CLR								(*(__IO uint32_t *)(PERI_BIT_BAND_AliasBase+ (UsrWdgtClr_Band_Offset * 32) + (UsrWdgt_Clr_Offset * 4)))
N
N//#define	Peripheral_LockUpWdgtClr_ADDRESS		0x40013000
N
N//#define	LockUpWdgtClr_Band_Offset				(Peripheral_LockUpWdgtClr_ADDRESS - PERI_BIT_BAND_Base)
N//#define	LockUpWdgt_Clr_Offset					0
N//#define	LWDT_CLR							  	(*(__IO uint32_t *)(PERI_BIT_BAND_AliasBase+ (LockUpWdgtClr_Band_Offset * 32) + (LockUpWdgt_Clr_Offset * 4)))
N
N
N#define START_DOG()             Hal_Kick_DOG()
N#define KICK_DOG()              Hal_Kick_DOG()
N#define FREE_DOG()              Hal_Release_DOG()
N
Ntypedef struct
N{
N	uint16_t WDGT_Prescaler;					//000 DIV2, 001 DIV4, 010 DIV8, 011 DIV16, 100 DIV32, 101 DIV64, 110 DIV128, 111 DIV256	
N	uint16_t WDGT_Count;						  // Wdgt value
N	uint16_t WDGT_ResetDelayCount;
N	uint16_t WDGT_ResetCount;					// Max 15
N	
N	//uint16_t WDGT_IRQChannelCmd;
N	uint16_t WDGT_RSTIRQChannelCmd;
N} WDGTS_InitTypeDef;								//Lock Up Watch Dog 
N
Nvoid WDGT_Init(WDT_TypeDef* WDGTx);
Nvoid WDGT_DeInit(WDT_TypeDef* WDGTx);
N
Nvoid WDGT_SetConfig(WDT_TypeDef* WDGTx, WDGTS_InitTypeDef* WDGT_InitStructure);
N
Nvoid WDGT_SetCLR(WDT_TypeDef* WDGTx);
Nvoid WDGT_SetLock(WDT_TypeDef* WDGTx);
Nvoid WDGT_ITConfig(WDT_TypeDef* WDGTx, FunctionalState NewFunction);
Nvoid WDGT_Cmd(WDT_TypeDef* WDGTx, FunctionalState NewFunction);
Nuint16_t WDGT_GetAccessRegStatus(WDT_TypeDef* WDGTx);
N//void Hal_WDT_Config(void); // NOTE : not used!!
Nextern void Hal_Kick_DOG(void);
Nextern void Hal_Release_DOG(void);
Nextern void Hal_WDT_Init(void);
Nextern void Hal_WDT_DeInit(void);
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _WDGT_H_ */
L 58 "..\..\Hal\hal_def.h" 2
N#include "misc.h"
L 1 "..\..\Hal\misc\misc.h" 1
N#ifndef MISC_H
N#define MISC_H
N
N#define uDELAY(usec)  udelay(usec)
N#define mDELAY(msec)  uDELAY(msec * 1000)
N
Nvoid udelay (uint32_t usec);
Nvoid ReMapVectorTableToRam(void);
Nvoid NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
N
N#endif	/* MISC_H */
L 59 "..\..\Hal\hal_def.h" 2
N#include "FOTG200_peripheral.h"
L 1 "..\..\Hal\usb\FWOTG210_F000\OTG_peripheral\FOTG200_peripheral.h" 1
N#ifndef _FOTG200_PERIPHERAL_H_
N#define _FOTG200_PERIPHERAL_H_
N
N#include "env_def.h"
N#include "systick.h"
N#include "SIW42101_Version.h"
L 1 "..\..\Hal\usb\FWOTG210_F000\OTG_peripheral\SIW42101_Version.h" 1
N#ifndef _SIW42101_VERSION_H_
N#define _SIW42101_VERSION_H_
N
N
N#define USB_BCDDEVICE__MAJOR 		0x00000001
N#define USB_BCDDEVICE__MINOR 		0x00000000
N#define USB_BCDDEVICE__BUILD 		0x00000001
N#define I2C__MAJOR 			0x00000001
N#define I2C__MINOR 			0x00000000
N#define I2C__BUILD 			0x00000002
N
N
N#endif /* _SIW42101_VERSION_H_ */
L 7 "..\..\Hal\usb\FWOTG210_F000\OTG_peripheral\FOTG200_peripheral.h" 2
N
N
N	//#define IRQ_FOTG200 					40	//27
N	#define FOTG200_BASE_ADDRESS			BASE_USB
N//========== 1.Define Data Type  =========================================================================================
N//	typedef unsigned char BOOLEAN;
N//	typedef unsigned char uint8_t;		/* 1 byte */
N//	typedef unsigned short uint16_t;		/* 2 bytes */
N//	typedef unsigned int uint32_t;		/* 4 bytes */
N//	typedef unsigned long long UINT64;  /* 8 bytes */
N//	typedef signed char int8_t;			/* 1 byte */
N//	typedef signed short int16_t;		/* 2 bytes */
N//	typedef signed int int32_t;			/* 4 bytes */
N	
N	#define MESS_ERROR		(0x01 << 0)
N	#define MESS_WARNING	(0x01 << 1)
N	#define MESS_INFO		(0x01 << 2)
N
N	// Macro
N	#define bFOTGPeri_Port(bOffset)		*((volatile uint8_t*) ( FOTG200_BASE_ADDRESS | (bOffset)))
N	#define hwFOTGPeri_Port(bOffset)	*((volatile uint16_t *) ( FOTG200_BASE_ADDRESS | (bOffset)))
N	#define wFOTGPeri_Port(bOffset)		*((volatile uint32_t *) ( FOTG200_BASE_ADDRESS | (bOffset)))
N
N	// Remote Wakeup
N	#define REMOTE_WAKEUP_ADDR				0x4000006CUL
N	#define REMOTE_WAKEUP_Port(bOffset)		*((volatile uint8_t*) ( REMOTE_WAKEUP_ADDR | (bOffset)))
N	#define mUsbRemoteWakeUpST()			(REMOTE_WAKEUP_Port(0x00) & BIT1)
N	#define mUsbRemoteWakeUpSet_1()			(REMOTE_WAKEUP_Port(0x00) |= BIT1)
N	#define mUsbRemoteWakeUpSet_0()			(REMOTE_WAKEUP_Port(0x00) &= ~BIT1)
N
N	#define mUsbRemoteWakeUpSet_SEL_WAKEUP()			(REMOTE_WAKEUP_Port(0x00) &= ~BIT4)
N	#define mUsbRemoteWakeUpST_BIT4()			(REMOTE_WAKEUP_Port(0x00) & BIT4)
N
N	// Mask of LPM L1
N	#define mUsbL1IntEn()					(wFOTGPeri_Port(0x33C) &= ~BIT0)
N	#define mUsbL1IntDis()					(wFOTGPeri_Port(0x33C) |= BIT0)
N
N	// Interrupt LPM
N	#define mUsbL1IntST()					(wFOTGPeri_Port(0x338) & BIT0)
N	#define mUsbL1IntClr()					(wFOTGPeri_Port(0x338) |= BIT0)
N	#define mUsbLPMCap()					(wFOTGPeri_Port(0x334) & BIT0)
N	
N
N	#define mUsbIntPolarityLow()	(wFOTGPeri_Port(0xC4) &= ~BIT3)
N	#define mUsbIntPolarityHigh()	(wFOTGPeri_Port(0xC4) & BIT3)
N
N	// Main control register(0x100)
N	#define mUsbRmWkupST()			(wFOTGPeri_Port(0x100) & BIT0)
N	#define mUsbRmWkupSet()		    (wFOTGPeri_Port(0x100) |= BIT0)
N	#define mUsbRmWkupClr()			(wFOTGPeri_Port(0x100) &= ~BIT0)
N	
N	#define mUsbTstHalfSpeedEn()	(wFOTGPeri_Port(0x100) |= BIT1)
N	#define mUsbTstHalfSpeedDis()	(wFOTGPeri_Port(0x100) &= ~BIT1)
N
N	#define mUsbGlobIntEnRd()		(wFOTGPeri_Port(0x100) & BIT2)
N	#define mUsbGlobIntEnSet()		(wFOTGPeri_Port(0x100) |= BIT2)
N	#define mUsbGlobIntDis()		(wFOTGPeri_Port(0x100) &= ~BIT2)
N	
N	#define mUsbGoSuspend()			(wFOTGPeri_Port(0x100) |=  BIT3)
N	#define mUsbClearSuspend()		(wFOTGPeri_Port(0x100) &=  ~BIT3)
N	
N	#define mUsbSoftRstStatus()		(wFOTGPeri_Port(0x100) &  BIT4)	
N	#define mUsbSoftRstSet()		(wFOTGPeri_Port(0x100) |=  BIT4)
N	#define mUsbSoftRstClr()		(wFOTGPeri_Port(0x100) &= ~BIT4)
N
N	#define mUsbChipEnSet()			(wFOTGPeri_Port(0x100) |= BIT5)
N	
N	#define mUsbOTGHighSpeedST()	(wFOTGPeri_Port(0x100) & BIT6)
N	#define mUsbOTGDevFS()			(wFOTGPeri_Port(0x100) |= BIT9)	
N	#define mUsbOTGDevHS()			(wFOTGPeri_Port(0x100) &= ~BIT9)
N
N
N	#define mUsbLPMEn()				(wFOTGPeri_Port(0x100) |= BIT25)
N	#define mUsbLPMDis()			(wFOTGPeri_Port(0x100) &= ~BIT25)
N
N	#define mUsbLPMAck()			(wFOTGPeri_Port(0x100) |= BIT26)
N	#define mUsbLPMNyet()			(wFOTGPeri_Port(0x100) &= ~BIT25)
N
N	// Device address register(0x104)
N	#define mUsbDevAddrSet(Value)	(wFOTGPeri_Port(0x104) = (uint32_t)Value)
N	#define mUsbCfgST()				(wFOTGPeri_Port(0x104) & BIT7)
N	#define mUsbCfgSet()			(wFOTGPeri_Port(0x104) |= BIT7)
N	#define mUsbCfgClr()			(wFOTGPeri_Port(0x104) &= ~BIT7)
N	
N	// old DMA ///////////////////////
N    #define mUsbDMARst()            { (wFOTGPeri_Port(0x1c8) = 0); (wFOTGPeri_Port(0x1c8) = BIT3); }	
N    // VDMA //////////////////////////
N    #define mUsbCXDMARst()          (wFOTGPeri_Port(0x300) = 0)    
N    #define mUsbEXDMARst(i)         (wFOTGPeri_Port(0x308+i*8) = 0)  
N        
N                         //(wFOTGPeri_Port(0x100) |= BIT8)
N    #define mUsbFIFOClr(fifo_num)   (wFOTGPeri_Port(0x1b0+fifo_num*4) |= BIT12)
N
N	// Test register(0x108)
N	#define mUsbClrAllFIFOSet()		(wFOTGPeri_Port(0x108) |= BIT0)
N	#define mUsbClrAllFIFOClr()		(wFOTGPeri_Port(0x108) &= ~BIT0)
N
N	// SOF Frame Number register(0x10C)
N	#define mUsbFrameNo()			(uint16_t)(wFOTGPeri_Port(0x10C) & 0x7FF)
N	#define mUsbMicroFrameNo()		(uint8_t)((wFOTGPeri_Port(0x10C) & 0x3800)>>11)
N
N	// SOF Mask register(0x110)
N	#define mUsbSOFMaskHS()		    (wFOTGPeri_Port(0x110) = 0x44c)
N	#define mUsbSOFMaskFS()		    (wFOTGPeri_Port(0x110) = 0x2710)
N
N	// PHY Test Mode Selector register(0x114)
N	#define mUsbTsMdWr(item)		(wFOTGPeri_Port(0x114) = (uint32_t)item)
N	#define mUsbUnPLGClr()			(wFOTGPeri_Port(0x114) &= ~BIT0)
N	#define mUsbUnPLGSet()			(wFOTGPeri_Port(0x114) |= BIT0)
N	// Vendor Specific IO Control register(0x118)
N
N	// Cx configuration and status register(0x11C)
N
N	// Cx configuration and FIFO Empty Status register(0x120)
N	#define mUsbEP0DoneSet()		(wFOTGPeri_Port(0x120) |= BIT0)
N	#define mUsbTsPkDoneSet()		(wFOTGPeri_Port(0x120) |= BIT1)
N	#define mUsbEP0StallSet()		(wFOTGPeri_Port(0x120) |= BIT2)
N	#define mUsbCxFClr()			(wFOTGPeri_Port(0x120) |= BIT3)
N
N	#define mUsbCxFFull()			(wFOTGPeri_Port(0x120) & BIT4)
N	#define mUsbCxFEmpty()			(wFOTGPeri_Port(0x120) & BIT5)
N	#define mUsbCxFByteCnt()		(uint8_t)((wFOTGPeri_Port(0x120) & 0x7F000000)>>24)
N	
N	// IDLE Counter register(0x124)
N	#define mUsbIdleCnt(time)		(wFOTGPeri_Port(0x124) = (uint32_t)time)
N
N	// Mask of interrupt group(0x130)
N	#define mUsbIntGrp0Dis()		(wFOTGPeri_Port(0x130) |= BIT0)
N	#define mUsbIntGrp1Dis()		(wFOTGPeri_Port(0x130) |= BIT1)
N	#define mUsbIntGrp2Dis()		(wFOTGPeri_Port(0x130) |= BIT2)
N	#define mUsbIntGrp3Dis()		(wFOTGPeri_Port(0x130) |= BIT3)  //VDMA
N
N	#define mUsbIntGroupMaskRd()	(wFOTGPeri_Port(0x130))
N	
N	// Mask of interrupt source group 0(0x134)
N	#define mUsbIntEP0SetupDis()	(wFOTGPeri_Port(0x134) |= BIT0)
N	#define mUsbIntEP0InDis()		(wFOTGPeri_Port(0x134) |= BIT1)
N	#define mUsbIntEP0OutDis()		(wFOTGPeri_Port(0x134) |= BIT2)
N	#define mUsbIntEP0EndDis()		(wFOTGPeri_Port(0x134) |= BIT3)
N	#define mUsbIntEP0FailDis()		(wFOTGPeri_Port(0x134) |= BIT4)
N
N	#define mUsbIntEP0SetupEn()		(wFOTGPeri_Port(0x134) &= ~(BIT0))
N	#define mUsbIntEP0InEn()			(wFOTGPeri_Port(0x134) &= ~(BIT1))
N	#define mUsbIntEP0OutEn()		(wFOTGPeri_Port(0x134) &= ~(BIT2))
N	#define mUsbIntEP0EndEn()		(wFOTGPeri_Port(0x134) &= ~(BIT3))
N	#define mUsbIntEP0FailEn()		(wFOTGPeri_Port(0x134) &= ~(BIT4))
N
N	#define mUsbIntSrc0MaskRd()		(wFOTGPeri_Port(0x134))
N	
N	// Mask of interrupt source group 1(0x138)
N	#define mUsbIntFIFO0_3OUTDis()	(wFOTGPeri_Port(0x138) |= 0xFF)
N	#define mUsbIntFIFO0_3INDis()	(wFOTGPeri_Port(0x138) |= 0xF0000)
N	
N	#define mUsbIntF0OUTEn()		(wFOTGPeri_Port(0x138) &= ~(BIT1 | BIT0))	
N	#define mUsbIntF0OUTDis()		(wFOTGPeri_Port(0x138) |= (BIT1 | BIT0))	
N	#define mUsbIntF1OUTEn()		(wFOTGPeri_Port(0x138) &= ~(BIT3 | BIT2))
N	#define mUsbIntF1OUTDis()		(wFOTGPeri_Port(0x138) |= (BIT3 | BIT2))
N	#define mUsbIntF2OUTEn()		(wFOTGPeri_Port(0x138) &= ~(BIT5 | BIT4))
N	#define mUsbIntF2OUTDis()		(wFOTGPeri_Port(0x138) |= (BIT5 | BIT4))
N	#define mUsbIntF0INEn()			(wFOTGPeri_Port(0x138) &= ~BIT16)
N	#define mUsbIntF0INDis()		(wFOTGPeri_Port(0x138) |= BIT16)
N	#define mUsbIntF3OUTEn()		(wFOTGPeri_Port(0x138) &= ~(BIT7 | BIT6))
N	#define mUsbIntF3OUTDis()		(wFOTGPeri_Port(0x138) |= (BIT7 | BIT6))
N
N	#define mUsbIntF0INEn()			(wFOTGPeri_Port(0x138) &= ~BIT16)
N	#define mUsbIntF0INDis()		(wFOTGPeri_Port(0x138) |= BIT16)
N	#define mUsbIntF1INEn()			(wFOTGPeri_Port(0x138) &= ~BIT17)
N	#define mUsbIntF1INDis()		(wFOTGPeri_Port(0x138) |= BIT17)
N	#define mUsbIntF2INEn()			(wFOTGPeri_Port(0x138) &= ~BIT18)
N	#define mUsbIntF2INDis()		(wFOTGPeri_Port(0x138) |= BIT18)
N	#define mUsbIntF3INEn()			(wFOTGPeri_Port(0x138) &= ~BIT19)
N	#define mUsbIntF3INDis()		(wFOTGPeri_Port(0x138) |= BIT19)
N
N
N	#define mUsbIntSrc1MaskRd()		(wFOTGPeri_Port(0x138))
N	
N	// Mask of interrupt source group 2(DMA int mask)(0x13C)
N	#define mUsbIntSuspDis()		(wFOTGPeri_Port(0x13C) |= BIT1)		
N	#define mUsbIntDmaErrDis()		(wFOTGPeri_Port(0x13C) |= BIT8)
N	#define mUsbIntDmaFinishDis()	(wFOTGPeri_Port(0x13C) |= BIT7)
N	#define mUsbIntWakebyVbusDis()	(wFOTGPeri_Port(0x13C) |= BIT10)
N	#define mUsbIntDevIdleDis()	    (wFOTGPeri_Port(0x13C) |= BIT9)	
N
N	#define mUsbIntSuspEn()			(wFOTGPeri_Port(0x13C) &= ~(BIT1))		
N	#define mUsbIntDmaErrEn()		(wFOTGPeri_Port(0x13C) &= ~(BIT8))
N	#define mUsbIntDmaFinishEn()	(wFOTGPeri_Port(0x13C) &= ~(BIT7))
N	#define mUsbIntWakebyVbusEn()	(wFOTGPeri_Port(0x13C) &= ~(BIT10))	
N	#define mUsbIntDevIdleEn()	    (wFOTGPeri_Port(0x13C) &= ~(BIT9))		
N
N	#define mUsbIntSrc2MaskRd()		(wFOTGPeri_Port(0x13C))
N
N    // VDMA ////////////////////////////////////////////////////////////	
N	#define mUsbEXIntDmaErrDis(i)	 (wFOTGPeri_Port(0x32C) |= (BIT17<<i))
N	#define mUsbEXIntDmaFinishDis(i) (wFOTGPeri_Port(0x32C) |= (BIT1<<i))
N	#define mUsbCXIntDmaErrDis()	 (wFOTGPeri_Port(0x32C) |= BIT16)
N	#define mUsbCXIntDmaFinishDis()	 (wFOTGPeri_Port(0x32C) |= BIT0)
N		
N	#define mUsbEXIntDmaErrEn(i)	 (wFOTGPeri_Port(0x32C) &= ~(BIT17<<i))
N	#define mUsbEXIntDmaFinishEn(i)	 (wFOTGPeri_Port(0x32C) &= ~(BIT1<<i))
N	#define mUsbCXIntDmaErrEn()		 (wFOTGPeri_Port(0x32C) &= ~(BIT16))
N	#define mUsbCXIntDmaFinishEn()	 (wFOTGPeri_Port(0x32C) &= ~(BIT0))		
N
N	#define mUsbIntSrc3MaskRd()		(wFOTGPeri_Port(0x32C))    
N    //////////////////////////////////////////////////////////////////
N
N	// Interrupt group (0x140)
N	#define mUsbIntGroupRegRd()		(wFOTGPeri_Port(0x140))
N	#define mUsbIntGroupRegSet(wValue)	(wFOTGPeri_Port(0x140) |= wValue)
N	
N	// Interrupt source group 0(0x144)
N	#define mUsbIntSrc0Rd()			(wFOTGPeri_Port(0x144))	
N#if 1	
N	#define mUsbIntEP0AbortClr()		(wFOTGPeri_Port(0x144) = BIT5)	
N#else	
S	#define mUsbIntEP0AbortClr()		(wFOTGPeri_Port(0x144) &= ~(BIT5))		
N#endif	
N	#define mUsbIntSrc0Clr()			(wFOTGPeri_Port(0x144) = 0)
N	#define mUsbIntSrc0Set(wValue)	(wFOTGPeri_Port(0x144) |= wValue)
N	
N	// Interrupt source group 1(0x148)
N	#define mUsbIntSrc1Rd()			(wFOTGPeri_Port(0x148))
N	#define mUsbIntSrc1Set(wValue)	(wFOTGPeri_Port(0x148) |= wValue)
N	
N	// Interrupt source group 2(0x14C)
N	#define mUsbIntSrc2Rd()			(wFOTGPeri_Port(0x14C))
N	#define mUsbIntSrc2Set(wValue)	(wFOTGPeri_Port(0x14C) |= wValue)
N
N#if 0	
S	#define mUsbIntBusRstClr()		(wFOTGPeri_Port(0x14C) &= ~BIT0)		
S	#define mUsbIntSuspClr()			(wFOTGPeri_Port(0x14C) &= ~BIT1)		
S	#define mUsbIntResmClr()			(wFOTGPeri_Port(0x14C) &= ~BIT2)		
S	#define mUsbIntIsoSeqErrClr()		(wFOTGPeri_Port(0x14C) &= ~BIT3)			
S	#define mUsbIntIsoSeqAbortClr()	(wFOTGPeri_Port(0x14C) &= ~BIT4)			
S	#define mUsbIntTX0ByteClr()		(wFOTGPeri_Port(0x14C) &= ~BIT5)			
S	#define mUsbIntRX0ByteClr()		(wFOTGPeri_Port(0x14C) &= ~BIT6)			
S	#define mUsbIntDmaFinishClr()	(wFOTGPeri_Port(0x14C) &= ~BIT7)			
S	#define mUsbIntDmaErrClr()		(wFOTGPeri_Port(0x14C) &= ~BIT8)			
S	#define mUsbIntDmaFinishRd()	(wFOTGPeri_Port(0x14C) &BIT7)			
S
S	#define mUsbIntDmaFinish()		(wFOTGPeri_Port(0x14C) & BIT7)			
S	#define mUsbIntDmaErr()			(wFOTGPeri_Port(0x14C) & BIT8)			
N#else
N	#define mUsbIntBusRstClr()		(wFOTGPeri_Port(0x14C) = BIT0)		
N	#define mUsbIntSuspClr()			(wFOTGPeri_Port(0x14C) = BIT1)		
N	#define mUsbIntResmClr()			(wFOTGPeri_Port(0x14C) = BIT2)		
N	#define mUsbIntIsoSeqErrClr()		(wFOTGPeri_Port(0x14C) = BIT3)			
N	#define mUsbIntIsoSeqAbortClr()	(wFOTGPeri_Port(0x14C) = BIT4)			
N	#define mUsbIntTX0ByteClr()		(wFOTGPeri_Port(0x14C) = BIT5)			
N	#define mUsbIntRX0ByteClr()		(wFOTGPeri_Port(0x14C) = BIT6)			
N	#define mUsbIntDmaFinishClr()	(wFOTGPeri_Port(0x14C) = BIT7)			
N	#define mUsbIntDmaErrClr()		(wFOTGPeri_Port(0x14C) = BIT8)			
N	#define mUsbIntDmaFinishRd()	(wFOTGPeri_Port(0x14C) &BIT7)			
N
N	#define mUsbIntDmaFinish()		(wFOTGPeri_Port(0x14C) & BIT7)			
N	#define mUsbIntDmaErr()			(wFOTGPeri_Port(0x14C) & BIT8)		
N#endif
N
N	// VDMA ////////////////////////////////////////////////////////	
N	// Interrupt source group 3(0x328)
N	#define mUsbIntSrc3Rd()			(wFOTGPeri_Port(0x328))
N	#define mUsbIntSrc3Set(wValue)	(wFOTGPeri_Port(0x328) |= wValue)
N			
N	#define mUsbCXDmaFinishClr()	(wFOTGPeri_Port(0x328) = BIT0)			
N	#define mUsbCXDmaFinishRd()	    (wFOTGPeri_Port(0x328) & BIT0)	
N	#define mUsbCXDmaErrClr()		(wFOTGPeri_Port(0x328) = BIT16)							
N	#define mUsbCXDmaErrRd()		(wFOTGPeri_Port(0x328) & BIT16)		
N	
N	#define mUsbEXDmaFinishClr(i)	(wFOTGPeri_Port(0x328) = (BIT1<<i))			
N	#define mUsbEXDmaFinishRd(i)	(wFOTGPeri_Port(0x328) & (BIT1<<i))
N	#define mUsbEXDmaErrClr(i)		(wFOTGPeri_Port(0x328) = (BIT17<<i))					
N	#define mUsbEXDmaErrRd(i)		(wFOTGPeri_Port(0x328) & (BIT17<<i))	
N		
N    ////////////////////////////////////////////////////////////////		
N	
N	// Rx 0 byte packet register(0x150)
N	#define mUsbIntRX0ByteRd()		(uint8_t)(wFOTGPeri_Port(0x150))
N	#define mUsbIntRX0ByteSetClr(set)		(wFOTGPeri_Port(0x150) &= ~((uint32_t)set))
N	
N	// Tx 0 byte packet register(0x154)
N	#define mUsbIntTX0ByteRd()		(uint8_t)(wFOTGPeri_Port(0x154))
N	#define mUsbIntTX0ByteSetClr(data)		(wFOTGPeri_Port(0x154) &= ~((uint32_t)data))
N
N	// ISO sequential Error/Abort register(0x158)
N	#define mUsbIntIsoSeqErrRd()		(uint8_t)((wFOTGPeri_Port(0x158) & 0xff0000)>>16)
N	#define mUsbIntIsoSeqErrSetClr(data)		(wFOTGPeri_Port(0x158) &= ~(((uint32_t)data)<<16))
N
N	#define mUsbIntIsoSeqAbortRd()	(uint8_t)(wFOTGPeri_Port(0x158) & 0xff)
N	#define mUsbIntIsoSeqAbortSetClr(data)	(wFOTGPeri_Port(0x158) &= ~((uint32_t)data))
N
N	// IN Endpoint MaxPacketSize register(0x160,0x164,...,0x17C)
N	#define mUsbEPinHighBandSet(EPn, dir , size )	(wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) &= ~(BIT14 |BIT13));  (wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) |= ((((uint8_t)(size >> 11)+1) << 13)*(1 - dir)) )
N	#define mUsbEPMxPtSz(EPn, dir, size)		(wFOTGPeri_Port(0x160 + (dir * 0x20) + ((EPn - 1) << 2)) = (uint16_t)(size))
N	#define mUsbEPMxPtSzClr(EPn, dir)			(wFOTGPeri_Port(0x160 + (dir * 0x20) + ((EPn - 1) << 2)) = 0)
N
N	#define mUsbEPinMxPtSz(EPn)		(wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) & 0x7ff)
N	#define mUsbEPinStallST(EPn)		((wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) & BIT11) >> 11)
N	#define mUsbEPinStallClr(EPn)		(wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) &= ~BIT11)
N	#define mUsbEPinStallSet(EPn)		(wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) |=  BIT11)
N	#define mUsbEPinRsTgClr(EPn)		(wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) &= ~BIT12)
N	#define mUsbEPinRsTgSet(EPn)	(wFOTGPeri_Port(0x160 + ((EPn - 1) << 2)) |=  BIT12)
N
N	// OUT Endpoint MaxPacketSize register(0x180,0x164,...,0x19C)
N	#define mUsbEPoutMxPtSz(EPn)	((wFOTGPeri_Port(0x180 + ((EPn - 1) << 2))) & 0x7ff)
N	#define mUsbEPoutStallST(EPn)	((wFOTGPeri_Port(0x180 + ((EPn - 1) << 2)) & BIT11) >> 11)
N	#define mUsbEPoutStallClr(EPn)	(wFOTGPeri_Port(0x180 + ((EPn - 1) << 2)) &= ~BIT11)
N	#define mUsbEPoutStallSet(EPn)	(wFOTGPeri_Port(0x180 + ((EPn - 1) << 2)) |=  BIT11)
N	#define mUsbEPoutRsTgClr(EPn)	(wFOTGPeri_Port(0x180 + ((EPn - 1) << 2)) &= ~BIT12)
N	#define mUsbEPoutRsTgSet(EPn)	(wFOTGPeri_Port(0x180 + ((EPn - 1) << 2)) |=  BIT12)
N
N	// Endpoint & FIFO Configuration
N	// Endpoint 1~4 Map register(0x1a0), Endpoint 5~8 Map register(0x1a4)
N	#define mUsbEPMap(EPn, MAP)	(bFOTGPeri_Port(0x1a0 + (EPn-1)) = MAP)
N	#define mUsbEPMapRd(EPn)		(bFOTGPeri_Port(0x1a0+ (EPn-1)))
N	#define mUsbEPMapAllClr()		(wFOTGPeri_Port(0x1a0) = 0);(wFOTGPeri_Port(0x1a4) = 0)
N	
N	// FIFO Map register(0x1a8)
N	#define mUsbFIFOMap(FIFOn, MAP)	(bFOTGPeri_Port(0x1a8 + FIFOn) = MAP)
N	#define mUsbFIFOMapRd(FIFOn)		(bFOTGPeri_Port(0x1a8 + FIFOn))
N	#define mUsbFIFOMapAllClr()			(wFOTGPeri_Port(0x1a8) = 0)
N	
N	// FIFO Configuration register(0x1ac)
N	#define mUsbFIFOConfig(FIFOn, CONFIG)	(bFOTGPeri_Port(0x1ac + FIFOn) = CONFIG)
N	#define mUsbFIFOConfigRd(FIFOn)			(bFOTGPeri_Port(0x1ac + FIFOn))
N	#define mUsbFIFOConfigAllClr()		(bFOTGPeri_Port(0x1ac) = 0)
N	#define FIFOEnBit					0x20
N
N	// FIFO byte count register(0x1b0)
N	#define mUsbFIFOOutByteCount(fifo_num)	(((wFOTGPeri_Port(0x1b0+fifo_num*4)&0x7ff)))
N	//#define mUsbFIFODone(fifo_num)			(wFOTGPeri_Port(0x1b0+fifo_num*4) |= BIT11)
N    #define mUsbFIFOReset(fifo_num)			(wFOTGPeri_Port(0x1b0+fifo_num*4) |= BIT12)
N
N/////// old DMA method ///////////////////////////////////////////////////////
N//////////////////////////////////////////////////////////////////////////////
N	// DMA target FIFO register(0x1c0)
N	#define FOTG200_DMA2FIFO_Non 		0
N	#define FOTG200_DMA2FIFO0 			BIT0
N	#define FOTG200_DMA2FIFO1 			BIT1
N	#define FOTG200_DMA2FIFO2 			BIT2
N	#define FOTG200_DMA2FIFO3 			BIT3
N	#define FOTG200_DMA2CxFIFO 		    BIT4
N	
N	#define mUsbDMA2FIFOSel(sel)		(wFOTGPeri_Port(0x1c0) = sel)
N	#define mUsbDMA2FIFORd()			(wFOTGPeri_Port(0x1c0))
N	
N	// DMA parameter set 1 (0x1c8)	
N	#define mUsbDmaConfig(len,Dir)		(wFOTGPeri_Port(0x1c8) = (((uint32_t)len)<<8)|((1-Dir)<<1))
N	//#define mUsbDmaLenRd()				((wFOTGPeri_Port(0x1c8) & 0x1fff0000) >> 8)
N    #define mUsbDmaLenRd()				((wFOTGPeri_Port(0x1c8) & 0x00FFFFFF00) >> 8)	
N	#define mUsbDmaConfigRd()			(wFOTGPeri_Port(0x1c8))
N	#define mUsbDmaConfigSet(set)		(wFOTGPeri_Port(0x1c8) = set)
N	
N	#define mUsbDmaStart()				(wFOTGPeri_Port(0x1c8) |= BIT0)
N	#define mUsbDmaStop()				(wFOTGPeri_Port(0x1c8) &= ~BIT0)
N
N	// DMA parameter set 2 (0x1cc)	
N	#define mUsbDmaAddr(addr)			(wFOTGPeri_Port(0x1cc) = addr)
N	#define mUsbDmaAddrRd()			(wFOTGPeri_Port(0x1cc))
N	
N	// 8 byte command data port(0x1d0)
N	#define mUsbEP0CmdDataRdDWord()	(wFOTGPeri_Port(0x1d0))
N///////////////////////////////////////////////////////////////////////////////////
N
N/////// new VDMA method ///////////////////////////////////////////////////////
N//////////////////////////////////////////////////////////////////////////////
N	#define mUsbVDMAEnable()		    (wFOTGPeri_Port(0x330) = 1)
N	#define mUsbVDMADisable()		    (wFOTGPeri_Port(0x330) = 0)
N		
N	// CX FIFO DMA	
N	#define mUsbCXDmaConfig(len,Dir)	(wFOTGPeri_Port(0x300) = (((uint32_t)len)<<8)|((1-Dir)<<1))
N    #define mUsbCXDmaLenRd()			((wFOTGPeri_Port(0x300) & 0x1FFFF00) >> 8)   	
N	#define mUsbCXDmaConfigRd()			(wFOTGPeri_Port(0x300))
N	#define mUsbCXDmaConfigSet(set)		(wFOTGPeri_Port(0x300) = set)
N	
N	#define mUsbCXDmaStart()			(wFOTGPeri_Port(0x300) |= BIT0)
N	#define mUsbCXDmaStop()				(wFOTGPeri_Port(0x300) &= ~BIT0)
N
N	// CX FIFO DMA parameter set 2 	
N	#define mUsbCXDmaAddr(addr)			(wFOTGPeri_Port(0x304) = addr)
N	#define mUsbCXDmaAddrRd()			(wFOTGPeri_Port(0x304))
N	
N    // F0-F3 FIFO DMA
N	#define mUsbEXDmaConfig(i,len,Dir)	(wFOTGPeri_Port(0x308+i*8) = (((uint32_t)len)<<8)|((1-Dir)<<1))
N    #define mUsbEXDmaLenRd(i)			((wFOTGPeri_Port(0x308+i*8) & 0x1FFFF00) >> 8)   	
N	#define mUsbEXDmaConfigRd(i)		(wFOTGPeri_Port(0x308+i*8))
N	#define mUsbEXDmaConfigSet(i,set)	(wFOTGPeri_Port(0x308+i*8) = set)
N	
N	#define mUsbEXDmaStart(i)			(wFOTGPeri_Port(0x308+i*8) |= BIT0)
N	#define mUsbEXDmaStop(i)			(wFOTGPeri_Port(0x308+i*8) &= ~BIT0)
N	
N	#define mUsbEXDmaAbort(i)	        (wFOTGPeri_Port(0x308+i*8) |= BIT3)
N	#define mUsbEXDmaRdAbort(i)	        (wFOTGPeri_Port(0x308+i*8) & BIT3)
N	
N	// F0-F3 FIFO DMA parameter set 2 	
N	#define mUsbEXDmaAddr(i,addr)		(wFOTGPeri_Port(0x30C+i*8) = addr)
N	#define mUsbEXDmaAddrRd(i)			(wFOTGPeri_Port(0x30C+i*8))
N	
N	
N	// Endpoint or FIFO direction define
N	#define DIRECTION_IN		0
N	#define DIRECTION_OUT		1
N
N	// Max. Packet Size define
N	#define MX_PA_SZ_8			8
N	#define MX_PA_SZ_16			16
N	#define MX_PA_SZ_32			32
N	#define MX_PA_SZ_64			64
N	#define MX_PA_SZ_128		128
N	#define MX_PA_SZ_256		256
N	#define MX_PA_SZ_512		512
N	#define MX_PA_SZ_1024		1024
N
N	// Endpoint number define
N	#define EP0					0x00
N	#define EP1					0x01
N	#define EP2					0x02
N	#define EP3					0x03
N	#define EP4					0x04
N	#define EP5					0x05
N	#define EP6					0x06
N	#define EP7					0x07
N	#define EP8					0x08
N	#define EP9					0x09
N	#define EP10				0x10
N	#define EP11				0x11
N	#define EP12				0x12
N	#define EP13				0x13
N	#define EP14				0x14
N	#define EP15				0x15
N
N///////////////////////////////////////////////////////////////////////////////////	
N	
N
N#pragma pack(1)
N
N
N//
N// I2C
N//
N
N#define I2C_SLAVE_INTERRUPT_STATUS_NONE         	0
N#define I2C_SLAVE_INTERRUPT_STATUS_START			1
N#define I2C_SLAVE_INTERRUPT_STATUS_STOP				2
N#define I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER	3
N#define I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH		4
N
N#define I2C_SLAVE_FSM_STATUS_IDLE					0x0001
N#define I2C_SLAVE_FSM_STATUS_WAIT_NEG				0x0002
N#define I2C_SLAVE_FSM_STATUS_SLV_ADDR				0x0004
N#define I2C_SLAVE_FSM_STATUS_ADDR_CHK				0x0008
N#define I2C_SLAVE_FSM_STATUS_SLV_ACK				0x0010
N#define I2C_SLAVE_FSM_STATUS_SLV_DLY				0x0020
N#define I2C_SLAVE_FSM_STATUS_READ					0x0040
N#define I2C_SLAVE_FSM_STATUS_READ_ACK				0x0080
N#define I2C_SLAVE_FSM_STATUS_READ_WAIT				0x0100
N#define I2C_SLAVE_FSM_STATUS_READ_DLY				0x0200
N#define I2C_SLAVE_FSM_STATUS_READ_END				0x0400
N#define I2C_SLAVE_FSM_STATUS_WRITE					0x0800
N#define I2C_SLAVE_FSM_STATUS_WRITE_ACK				0x1000
N#define I2C_SLAVE_FSM_STATUS_WRITE_DLY				0x2000
N
N
N#define I2C_REPORT_REGISTER				0x0021
N#define I2C_COMMAND_REGISTER			0x0022
N#define I2C_DATA_REGISTER				0x0023
N#define I2C_INPUT_REGISTER				0x0024
N#define I2C_OUTPUT_REGISTER				0x0025
N
N#define I2C_DATA_LENGTH					0x40
N#define I2C_MAX_INPUT_LENGTH			(0x02 + I2C_DATA_LENGTH) // Length 2Bytes + Data 64Bytes
N#define I2C_MAX_OUTPUT_LENGTH			(0x04 + I2C_DATA_LENGTH) // Register 2Bytes + Length 2Bytes + Data 64Bytes
N
N#define I2C_VENDORID					UNIQUE_VID
N#define I2C_PRODUCTID					UNIQUE_APP_PID
N#define I2C_VERSION						(I2C__MAJOR << 8 | I2C__MINOR << 4 | I2C__BUILD)	// I2C F/W Version
N
N// Interrupt
N#define I2C_STR_ITRPT					1
N#define I2C_STP_ITRPT					2
N#define I2C_BYTE_ITRPT					3
N#define I2C_ADDR_ITRPT					4
N#define I2C_MST_ITRPT					5
N#define I2C_SCL_HOLD_ITRPT				6
N
N
N// GPIO Interrupt
N#define I2C_GPB10__LOW					0x00
N#define I2C_GPB10__HIGH					0x01
N
N// Command    Touch, Custom, Pen   
N#define I2C_DELAY_TIME					1000 // (0.1 sec)
N
N// Ready
N#define I2C_NOT_READY					0 // Default
N#define I2C_READY						1
N
N// Connect Status
N#define I2C_CONNECT_PC					0
N#define I2C_CONNECT_TOOL				1 // Default
N#define I2C_CONNECT_TOOL_0x150			2
N
N// Reset
N#define I2C_NORMAL						0 // Default
N#define I2C_RESET						1
N
N// GPIO
N#define I2C_GPIO_NORMAL					0 // Default
N#define I2C_GPIO_DISABLE				1
N
N
Ntypedef struct _I2C_HID_DESCRIPTOR
N{
N	//uint16_t	DescLength; // I2C_IRQHandler  2        
N	uint16_t	BCDVersion;
N	uint16_t	ReportLength;
N	uint16_t	ReportRegister;
N	uint16_t	InputRegister;
N	uint16_t	MaxInputLength;
N	uint16_t	OutputRegister;
N	uint16_t	MaxOutputLength;
N	uint16_t	CommandRegister;
N	uint16_t	DataRegister;
N	uint16_t	VendorID;
N	uint16_t	ProductID;
N	uint16_t	VersionID;
N	uint32_t	Reserved;
N
N} I2C_HID_DESCRIPTOR, *PI2C_HID_DESCRIPTOR;
N
N
Ntypedef struct _I2C_REQUEST_COMMON
N{
N	uint8_t ReportID : 4;
N	uint8_t ReportType : 2;
N	uint8_t Reserved_1 : 2;
N
N} I2C_REQUEST_COMMON, *PI2C_REQUEST_COMMON;
N
Ntypedef struct _I2C_REQUEST_POWER
N{
N	uint8_t PowerState : 4;
N	uint8_t ReportType : 2;
N	uint8_t Reserved_1 : 2;
N
N} I2C_REQUEST_POWER, *PI2C_REQUEST_POWER;
N
N
Ntypedef struct _I2C__REQUEST
N{
N	uint16_t	CommandRegister;
N
N	union
N	{
N		I2C_REQUEST_COMMON	I2C_Request_Common;
N		I2C_REQUEST_POWER	I2C_Request_Power;
N	};
N
N	uint8_t OpCode : 4;
N	uint8_t Reserved_2 : 4;
N
N	uint16_t DataRegister;
N	uint16_t DataLength;
N	uint8_t  Data[1];
N
N} I2C__REQUEST, *PI2C__REQUEST;
N
Ntypedef struct _I2C__OUTPUT
N{
N	uint16_t	CommandRegister;
N	uint16_t	DataLength;
N	uint8_t		ReportID;
N	uint8_t		Data[1];
N} I2C__OUTPUT, *PI2C__OUTPUT;
N
Ntypedef enum _I2C__REQUEST_OPCODE
N{
N	I2C__REQUEST_OPCODE__RESERVED = 0x0,
N	I2C__REQUEST_OPCODE__RESET = 0x1,
N	I2C__REQUEST_OPCODE__GET_REPORT = 0x2,
N	I2C__REQUEST_OPCODE__SET_REPORT = 0x3,
N	I2C__REQUEST_OPCODE__GET_IDLE = 0x4,
N	I2C__REQUEST_OPCODE__SET_IDLE = 0x5,
N	I2C__REQUEST_OPCODE__GET_PROTOCOL = 0x6,
N	I2C__REQUEST_OPCODE__SET_PROTOCOL = 0x7,
N	I2C__REQUEST_OPCODE__SET_POWER = 0x8,
N	I2C__REQUEST_OPCODE__VENDOR = 0xE,
N
N} I2C_REQUEST__OPCODE;
N
N
Ntypedef enum _I2C__REQUEST_REPORT_TYPE
N{
N	I2C__REQUEST_REPORT_TYPE__NONE = 0x0,
N	I2C__REQUEST_REPORT_TYPE__INPUT = 0x1,
N	I2C__REQUEST_REPORT_TYPE__OUTPUT = 0x2,
N	I2C__REQUEST_REPORT_TYPE__FEATURE = 0x3,
N
N} I2C__REQUEST_REPORT_TYPE;
N
N
Ntypedef enum _I2C__REQUEST_REPORT_ID
N{
N	I2C__REQUEST_REPORT_ID__NONE = 0x0,
N
N} I2C__REQUEST_REPORT_ID;
N
N
Ntypedef enum _I2C__REQUEST_POWER_STATE
N{
N	I2C__REQUEST_REPORT_POWER_STATE__ON = 0x0,
N	I2C__REQUEST_REPORT_POWER_STATE__SLEEP = 0x1,
N
N} I2C__REQUEST_REPORT_POWER_STATE;
N
N
N
N
N
N
N
N
N
N
N
N//
N// USB
N//
N
N// DMA Ready
N#define DMA_NOT_READY					0
N#define DMA_READY						1
N
N
N//      
N#ifdef ADD_TOUCH
N#define TOUCH_ENABLE					1
N#else
S#define TOUCH_ENABLE					0
N#endif
N
N#ifdef ADD_PEN
S#define PEN_ENABLE						1
N#else
N#define PEN_ENABLE						0
N#endif
N
N#ifdef ADD_CUSTOM
N#define CUSTOM_ENABLE					1
N#else
S#define CUSTOM_ENABLE					0
N#endif
N
N#ifdef ADD_BULK_CUSTOM
S#define BULK_CUSTOM_ENABLE				1
N#else
N#define BULK_CUSTOM_ENABLE				0
N#endif
N
N
N
N// Interface 
N#define INTERFACE_COUNT					(TOUCH_ENABLE + PEN_ENABLE + CUSTOM_ENABLE + BULK_CUSTOM_ENABLE)
N
N// Device Desc
N#define DEVICE_CLASS					0XEF
N#define DEVICE_SUB_CLASS				0X02
N#define DEVICE_PROTOCOL					0X01
N#define DEVICE_MANUFACTURER				0X02
N#define DEVICE_PRODUCT					0X01
N#define DEVICE_SERIALNUMBER				0X00
N#define DEVICE_CONFIG_NUMBER			0X01
N
N// VID, PID
N#define DEVICE_USB_SPEC_VER				0x0200 // 0X0110
N#define DEVICE_VENDOR_ID				UNIQUE_VID
N#define DEVICE_PRODUCT_ID				UNIQUE_APP_PID
N#define DEVICE_DEVICE_RELEASE_NO		(USB_BCDDEVICE__MAJOR << 8 | USB_BCDDEVICE__MINOR << 4 | USB_BCDDEVICE__BUILD)
N
N
N// Descriptor Types
N#define DT_DEVICE						1
N#define DT_CONFIGURATION				2
N#define DT_STRING						3
N#define DT_INTERFACE					4
N#define DT_ENDPOINT						5
N#define DT_DEVICE_QUALIFIER				6
N#define DT_OTHER_SPEED_CONFIGURATION	7
N#define DT_INTERFACE_POWER				8
N#define DT_OTG							9 
N#define DT_IAD							11
N
N// EP
N#define EP_IN							0x80
N#define EP_OUT							0x00
N
N// EP Transfer Type
N#define EP_TRANSFER_TYPE__ISO			0x01
N#define EP_TRANSFER_TYPE__BULK			0x02
N#define EP_TRANSFER_TYPE__INTERRUPT		0x03
N
N// Class
N#define INTERFACE_CLASS__HID			0x03
N#define FUNCTION_CLASS__HID				0x03
N#define FUNCTION_CLASS__0xFF			0xFF
N
N// Sub Class
N#define INTERFACE_SUB_CLASS__NONE		0x00
N#define INTERFACE_SUB_CLASS__BOOT		0x01
N
N// Protocol
N#define INTERFACE_PROTOCOL__NONE		0x00
N#define INTERFACE_PROTOCOL__KEYBOARD	0x01
N#define INTERFACE_PROTOCOL__MOUSE		0x02
N
N// Attribute
N#define ATTRIBUTE_REMOTE_WAKE_UP		0x20	// Enable : 0x20, Disable : 0x00
N#define ATTRIBUTE_BUS_POWERD			0x40	// BusPowerd : 0x00, SelfPowerd : 0x40
N#define ATTRIBUTE_RESERVED				0x80
N
N// Max Power
N#define DEVICE_MAX_POWER				0x32 // (100 mA)
N
N// Descriptor Length
N#define STRING_LANG_IDS_LENGTH			4
N#define STRING_PRODUCT_LENGTH			50
N#define STRING_MANUFACTURER_LENGTH		26
N
N#define DEVICE_DESC_LENGTH				18
N#define CONFIG_LENGTH					9
N#define IAD_LENGTH						8
N#define INTERFACE_LENGTH				9
N#define HID_LENGTH						9
N#define ENDPOINT_LENGTH					7
N
N// HID Version (1.11)
N#define HID_VERSION						0x0111
N
N// Endpoint   
N
N#ifdef ADD_TOUCH
N#define TOUCH_IN_EP_ADD					1
N#define TOUCH_OUT_EP_ADD				0
N#else
S#define TOUCH_IN_EP_ADD					0
S#define TOUCH_OUT_EP_ADD				0
N#endif
N
N
N#ifdef ADD_PEN
S#define PEN_IN_EP_ADD					1
S#define PEN_OUT_EP_ADD					0
N#else
N#define PEN_IN_EP_ADD					0
N#define PEN_OUT_EP_ADD					0
N#endif
N
N#ifdef ADD_CUSTOM
N#define CUSTOM_IN_EP_ADD				1
N#define CUSTOM_OUT_EP_ADD				1
N#else
S#define CUSTOM_IN_EP_ADD				0
S#define CUSTOM_OUT_EP_ADD				0
N#endif
N
N#ifdef ADD_BULK_CUSTOM
S#define BULK_CUSTOM_IN_EP_ADD			1
S#define BULK_CUSTOM_OUT_EP_ADD			1
N#else
N#define BULK_CUSTOM_IN_EP_ADD			0
N#define BULK_CUSTOM_OUT_EP_ADD			0
N#endif
N
N
N
N
N// Endpoint Number
N#define TOUCH_OUT_EP_NUM				1
N#define TOUCH_IN_EP_NUM					2
N#define CUSTOM_OUT_EP_NUM				3
N#define CUSTOM_IN_EP_NUM				4
N#define PEN_OUT_EP_NUM					5
N#define PEN_IN_EP_NUM					6
N#define BULK_CUSTOM_OUT_EP_NUM			7
N#define BULK_CUSTOM_IN_EP_NUM			8
N
N// EP Size
N#define EP0_MAX_PACKET_SIZE				0x40
N#define EP1_MAX_PACKET_SIZE				0x40
N#define EP2_MAX_PACKET_SIZE				0x40
N#define EP3_MAX_PACKET_SIZE				0x40
N#define EP4_MAX_PACKET_SIZE				0x40
N#define EP5_MAX_PACKET_SIZE				0x40
N#define EP6_MAX_PACKET_SIZE				0x40
N#define EP7_MAX_PACKET_SIZE				0x40
N#define EP8_MAX_PACKET_SIZE				0x40
N
N// EP Max Packet Size
N#define TOUCH_OUT_EP_SIZE				EP1_MAX_PACKET_SIZE
N#define TOUCH_IN_EP_SIZE				EP2_MAX_PACKET_SIZE
N#define CUSTOM_OUT_EP_SIZE				EP3_MAX_PACKET_SIZE
N#define CUSTOM_IN_EP_SIZE				EP4_MAX_PACKET_SIZE
N#define PEN_OUT_EP_SIZE					EP5_MAX_PACKET_SIZE
N#define PEN_IN_EP_SIZE					EP6_MAX_PACKET_SIZE
N#define BULK_CUSTOM_OUT_EP_SIZE			EP7_MAX_PACKET_SIZE
N#define BULK_CUSTOM_IN_EP_SIZE			EP8_MAX_PACKET_SIZE
N
N// FIFO Number
N#define TOUCH_FIFO_IN					1
N#define CUSTOM_FIFO_IN					0
N#define CUSTOM_FIFO_OUT					2
N#define PEN_FIFO_IN						3
N#define BULK_CUSTOM_FIFO_IN				0
N#define BULK_CUSTOM_FIFO_OUT			2
N
N
N// Interfade Number
N#define TOUCH_INTERFACE_NUM				0
N#define CUSTOM_INTERFACE_NUM			1
N#define PEN_INTERFACE_NUM				2
N#define BULK_CUSTOM_INTERFACE_NUM		3
N
N
N#define TOUCH_ENDPOINT_COUNT			(TOUCH_IN_EP_ADD + TOUCH_OUT_EP_ADD)
N#define PEN_ENDPOINT_COUNT				(PEN_IN_EP_ADD + PEN_OUT_EP_ADD)
N#define CUSTOM_ENDPOINT_COUNT			(CUSTOM_IN_EP_ADD + CUSTOM_OUT_EP_ADD)
N#define BULK_CUSTOM_ENDPOINT_COUNT		(BULK_CUSTOM_IN_EP_ADD + BULK_CUSTOM_OUT_EP_ADD)
N
N
N#if TOUCH_ENABLE
X#if 1
N#define TOUCH_DESC_LENGTH				(IAD_LENGTH + INTERFACE_LENGTH + HID_LENGTH + (ENDPOINT_LENGTH * TOUCH_ENDPOINT_COUNT))
N#else
S#define TOUCH_DESC_LENGTH				0
N#endif
N
N#if PEN_ENABLE
X#if 0
S#define PEN_DESC_LENGTH					(IAD_LENGTH + INTERFACE_LENGTH + HID_LENGTH + (ENDPOINT_LENGTH * PEN_ENDPOINT_COUNT))
N#else
N#define PEN_DESC_LENGTH					0
N#endif
N
N#if CUSTOM_ENABLE
X#if 1
N#define CUSTOM_DESC_LENGTH				(IAD_LENGTH + INTERFACE_LENGTH + HID_LENGTH + (ENDPOINT_LENGTH * CUSTOM_ENDPOINT_COUNT))
N#else
S#define CUSTOM_DESC_LENGTH				0
N#endif
N
N#if BULK_CUSTOM_ENABLE
X#if 0
S#define BULK_CUSTOM_DESC_LENGTH			(IAD_LENGTH + INTERFACE_LENGTH + (ENDPOINT_LENGTH * BULK_CUSTOM_ENDPOINT_COUNT))
N#else
N#define BULK_CUSTOM_DESC_LENGTH			0
N#endif
N
N
N#define	CONFIG_DESC_LENGTH				(CONFIG_LENGTH + TOUCH_DESC_LENGTH + PEN_DESC_LENGTH + CUSTOM_DESC_LENGTH + BULK_CUSTOM_DESC_LENGTH)
N
N
N// Windows 10  1511      
N//define LATENCY_MODE
N#define LATENCY_MODE__NORMAL			0
N#define LATENCY_MODE__HIGH				1
N
N
N
N// Request Type
N#define SETUPPACKET_REQUEST_TYPE__STANDARD				0x00
N#define SETUPPACKET_REQUEST_TYPE__CLASS					0x01
N#define SETUPPACKET_REQUEST_TYPE__VENDOR				0x02
N
N// Standard Request
N#define SETUPPACKET_STANDARD_REQUEST__GET_STATUS		0x00
N#define SETUPPACKET_STANDARD_REQUEST__CLEAR_FEATURE		0x01
N#define SETUPPACKET_STANDARD_REQUEST__SET_FEATURE		0x03
N#define SETUPPACKET_STANDARD_REQUEST__SET_ADDRESS		0x05
N#define SETUPPACKET_STANDARD_REQUEST__GET_DESCRIPTOR	0x06
N#define SETUPPACKET_STANDARD_REQUEST__SET_DESCRIPTOR	0x07
N#define SETUPPACKET_STANDARD_REQUEST__GET_CONFIGURATION	0x08
N#define SETUPPACKET_STANDARD_REQUEST__SET_CONFIGURATION	0x09
N#define SETUPPACKET_STANDARD_REQUEST__GET_INTERFACE		0x0A
N#define SETUPPACKET_STANDARD_REQUEST__SET_INFERFACE		0x0B
N#define SETUPPACKET_STANDARD_REQUEST__SYNCH_FRAME		0x0C
N
N// Feature
N#define SETUPPACKET_FEATURE__ENDPOINT_HALT				0x00
N#define SETUPPACKET_FEATURE__DEVICE_REMOTE_WAKEUP		0x01
N
N// Host to Device
N#define SETUPPACKET_CLASS_REQUEST__GET_REPORT		0x01
N#define SETUPPACKET_CLASS_REQUEST__GET_IDLE			0x02
N#define SETUPPACKET_CLASS_REQUEST__GET_PROTOCOL		0x03
N#define SETUPPACKET_CLASS_REQUEST__SET_REPORT		0x09
N#define SETUPPACKET_CLASS_REQUEST__SET_IDLE			0x0A
N#define SETUPPACKET_CLASS_REQUEST__SET_PROTOCOL		0x0B
N
N
N// Descriptor
N#define SETUPPACKET_DESCRIPTOR__DEVICE					0x01
N#define SETUPPACKET_DESCRIPTOR__CONFIGURATION			0x02
N#define SETUPPACKET_DESCRIPTOR__STRING					0x03
N#define SETUPPACKET_DESCRIPTOR__HID						0x21
N#define SETUPPACKET_DESCRIPTOR__REPORT					0x22
N#define SETUPPACKET_DESCRIPTOR__BOS						0x0F
N#define SETUPPACKET_DESCRIPTOR__MS_OS					0xEE
N#define SETUPPACKET_DESCRIPTOR__MS_OS_2					0x03EE
N
N// MS OS Descriptor
N#define SETUPPACKET_DESCRIPTOR__MS_OS_VENDOR_CODE		0x98
N#define MS_OS_DESCRIPTOR_TYPE__COMPATIBLE_ID			0x04
N#define MS_OS_DESCRIPTOR_TYPE__PROPERTIES				0x05
N
N// DEVICE_ICON, DEVICE_LEBEL
N//#define MS_OS_EXT_PROP__ICON
N//#define MS_OS_EXT_PROP__LABEL
N#define MS_OS_EXT_PROP__WINUSB
N
N// FIFO Config
N#define FIFO_CONFIG_TYPE__RESERVED						0x00
N#define FIFO_CONFIG_TYPE__ISO							0x01
N#define FIFO_CONFIG_TYPE__BULK							0x02
N#define FIFO_CONFIG_TYPE__INT							0x03
N
N#define FIFO_CONFIG_BLOCK_NBUMBER__SINGLE				0x00
N#define FIFO_CONFIG_BLOCK_NBUMBER__DOUBLE				0x01
N#define FIFO_CONFIG_BLOCK_NBUMBER__TRIPLE				0x02
N#define FIFO_CONFIG_BLOCK_NBUMBER__RESERVED				0x03
N
N#define FIFO_CONFIG_BLOCK_SIZE__512						0x00
N#define FIFO_CONFIG_BLOCK_SIZE__1024					0x01
N
N#define FIFO_CONFIG__DISABLE							0x00
N#define FIFO_CONFIG__ENABLE								0x01
N
N#define FIFO_CONFIG_DIRECTION__OUT						0x00
N#define FIFO_CONFIG_DIRECTION__IN						0x01
N#define FIFO_CONFIG_DIRECTION__BIDIRECTIONAL			0x02
N#define FIFO_CONFIG_DIRECTION__NOT_ALLOWED				0x03
N
N
Ntypedef struct _USB20_EXT_DESCRIPTOR
N{
N	uint8_t	Length;
N	uint8_t	Type;
N	uint8_t	DevCapabilityType;
N	uint32_t	bmAttributes_Reserved0 : 1;
N	uint32_t	bmAttributes_LPM_Support : 1;
N	uint32_t	bmAttributes_BESL_Support : 1;
N	uint32_t	bmAttributes_BaseLineBESL : 1;
N	uint32_t	bmAttributes_DeepBESL : 1;
N	uint32_t	bmAttributes_Reserved1 : 3;
N	uint32_t	bmAttributes_BESL : 4;
N	uint32_t	bmAttributes_DBESL : 4;
N	uint32_t	bmAttributes_Reserved2 : 8;
N	uint32_t	bmAttributes_Reserved3 : 8;
N
N} USB20_EXT_DESCRIPTOR, *PUSB20_EXT_DESCRIPTOR;
N
Ntypedef struct _USB_SS_EXT_DESCRIPTOR
N{
N	uint8_t I_Dont_Know;
N
N} USB_SS_EXT_DESCRIPTOR, *PUSB_SS_EXT_DESCRIPTOR;
N
Ntypedef struct _BOS_DESCRIPTOR
N{
N	uint8_t	Length;
N	uint8_t	Type;
N	uint16_t	TotalLength;
N	uint8_t	NumCapability;
N	USB20_EXT_DESCRIPTOR Usb20ExtDesc;
N
N} BOS_DESCRIPTOR, *PBOS_DESCRIPTOR;
N
N// MS OS String Descriptor
Ntypedef struct _MS_OS_STRING_DESCRIPTOR
N{
N	uint8_t	Length;
N	uint8_t	Type;
N	uint8_t	Signature[14];
N	uint8_t	MSVendorCode;
N	uint8_t	Pad;
N
N} MS_OS_STRING_DESCRIPTOR, *PMS_OS_STRING_DESCRIPTOR;
N
Ntypedef struct _COMPATIBLE_ID_FEATURE_DESCRIPTOR
N{
N	uint32_t	Length;
N	uint16_t	bcdVersion;
N	uint16_t	Index;
N	uint8_t	Count;
N	uint8_t	Reserved1[7];
N	uint8_t	FirstInterfaceNumber;
N	uint8_t	Reserved2;
N	uint8_t	CompatibleID[8];
N	uint8_t	SubCompatibleID[8];
N	uint8_t	Reserved3[6];
N
N} COMPATIBLE_ID_FEATURE_DESCRIPTOR, *PCOMPATIBLE_ID_FEATURE_DESCRIPTOR;
N
N// Properties - Selective Suspend
N#define SELECTIVE_SUSPEND_STRING	"SelectiveSuspendEnabled"
Ntypedef struct _PROPERTY_SECTION__SELECTIVE_SUSPEND
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[48];
N	uint32_t	PropertyDataLength;
N	uint32_t	PropertyData;
N	
N} PROPERTY_SECTION__SELECTIVE_SUSPEND, *PPROPERTY_SECTION__SELECTIVE_SUSPEND;
N
N// Properties - DeviceInterfaceGUID (WinUSB)
N#define DEVICEINTERFACEGUID_STRING	"{8FE6D4D7-49DD-41E7-9486-49AFC6BFE470}"
N#define DEVICEINTERFACEGUID_NAME	"DeviceInterfaceGUID"
Ntypedef struct _PROPERTY_SECTION__DEVICEINTERFACEGUID
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[40];
N	uint32_t	PropertyDataLength;
N	uint8_t	PropertyData[78];
N
N} PROPERTY_SECTION__DEVICEINTERFACEGUID, *PPROPERTY_SECTION__DEVICEINTERFACEGUID;
N
N// Properties - DeviceIdleEnabled (WinUSB)
N#define DEVICEIDLEENABLED_NAME	"DeviceIdleEnabled"
Ntypedef struct _PROPERTY_SECTION__DEVICEIDLEENABLED
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[36];
N	uint32_t	PropertyDataLength;
N	uint32_t	PropertyData;
N
N} PROPERTY_SECTION__DEVICEIDLEENABLED, *PPROPERTY_SECTION__DEVICEIDLEENABLED;
N
N// Properties - DefaultIdleState (WinUSB)
N#define DEFAULTIDLESTATE_NAME	"DefaultIdleState"
Ntypedef struct _PROPERTY_SECTION__DEFAULTIDLESTATE
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[34];
N	uint32_t	PropertyDataLength;
N	uint32_t	PropertyData;
N
N} PROPERTY_SECTION__DEFAULTIDLESTATE, *PPROPERTY_SECTION__DEFAULTIDLESTATE;
N
N// Properties - DefaultIdleTimeout (WinUSB)
N#define DEFAULTIDLETIMEOUT_NAME	"DefaultIdleTimeout"
Ntypedef struct _PROPERTY_SECTION__DEFAULTIDLETIMEOUT
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[38];
N	uint32_t	PropertyDataLength;
N	uint32_t	PropertyData;
N
N} PROPERTY_SECTION__DEFAULTIDLETIMEOUT, *PPROPERTY_SECTION__DEFAULTIDLETIMEOUT;
N
N// Properties - UserSetDeviceIdleEnabled (WinUSB)
N#define USERSETDEVICEIDLEENABLED_NAME	"UserSetDeviceIdleEnabled"
Ntypedef struct _PROPERTY_SECTION__USERSETDEVICEIDLEENABLED
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[50];
N	uint32_t	PropertyDataLength;
N	uint32_t	PropertyData;
N
N} PROPERTY_SECTION__USERSETDEVICEIDLEENABLED, *PPROPERTY_SECTION__USERSETDEVICEIDLEENABLED;
N
N// Properties - SystemWakeEnabled (WinUSB)
N#define SYSTEMWAKEENABLED_NAME	"SystemWakeEnabled"
Ntypedef struct _PROPERTY_SECTION__SYSTEMWAKEENABLED
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[36];
N	uint32_t	PropertyDataLength;
N	uint32_t	PropertyData;
N
N} PROPERTY_SECTION__SYSTEMWAKEENABLED, *PPROPERTY_SECTION__SYSTEMWAKEENABLED;
N
N// Properties - Device Icon
N#define DEVICE_ICON_STRING	"%SystemRoot%\system32\shell32.dll,-230"
Ntypedef struct _PROPERTY_SECTION__DEVICE_ICON
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[12];
N	uint32_t	PropertyDataLength;
N	uint8_t	PropertyData[78];
N	
N} PROPERTY_SECTION__DEVICE_ICON, *PPROPERTY_SECTION__DEVICE_ICON;
N
N// Properties - Device Label
N#define DEVICE_LABEL_STRING	"Siliconworks"
Ntypedef struct _PROPERTY_SECTION__DEVICE_LABEL
N{
N	uint32_t	Size;
N	uint32_t	PropertyDataType;
N	uint16_t	PropertyNameLength;
N	uint8_t	PropertyName[12];
N	uint32_t	PropertyDataLength;
N	uint8_t	PropertyData[26];
N	
N} PROPERTY_SECTION__DEVICE_LABEL, *PPROPERTY_SECTION__DEVICE_LABEL;
N
Ntypedef struct _PROPERTIES_DESCRIPTOR_HEADER
N{
N	// Header
N	uint32_t	Length;
N	uint16_t	bcdVersion;
N	uint16_t	Index;
N	uint16_t	Count;
N
N} PROPERTIES_DESCRIPTOR_HEADER, *PPROPERTIES_DESCRIPTOR_HEADER;
N
Ntypedef struct _PROPERTIES_DESCRIPTOR
N{
N	// Header
N	PROPERTIES_DESCRIPTOR_HEADER	Header;
N
N	// Selective Suspend
N	PROPERTY_SECTION__SELECTIVE_SUSPEND 	SelectiveSuspend;
N	
N#ifdef MS_OS_EXT_PROP__WINUSB
N	// DeviceInterfaceGUID
N	PROPERTY_SECTION__DEVICEINTERFACEGUID		DeviceInterfaceGUID;
N	PROPERTY_SECTION__DEVICEIDLEENABLED			DeviceIdleEnabled;
N	PROPERTY_SECTION__DEFAULTIDLESTATE			DefaultIdleState;
N	PROPERTY_SECTION__DEFAULTIDLETIMEOUT		DefaultIdleTimeout;
N	PROPERTY_SECTION__USERSETDEVICEIDLEENABLED	UserSetDeviceIdleEnabled;
N	PROPERTY_SECTION__SYSTEMWAKEENABLED			SystemWakeEnabled;
N#endif
N
N#ifdef MS_OS_EXT_PROP__ICON
S	// Device Icon
S	PROPERTY_SECTION__DEVICE_ICON			DeviceIcon;
N#endif
N	
N#ifdef MS_OS_EXT_PROP__LABEL
S	// Device Label
S	PROPERTY_SECTION__DEVICE_LABEL			DeviceLabel;
N#endif
N
N
N} PROPERTIES_DESCRIPTOR, *PPROPERTIES_DESCRIPTOR;
N
N#define REG_SZ 			1
N#define REG_EXPAND_SZ	2
N#define REG_DWORD		4
N#define REG_MULTI_SZ	7
N
N
Ntypedef struct _SETUP_PACKET
N{
N	uint8_t	bmRequestType_Recipient : 5;
N	uint8_t	bmRequestType_Type : 2;
N	uint8_t	bmRequestType_Direction : 1;
N	uint8_t	bRequest;
N	uint16_t	wValue;
N	uint16_t	wIndex;
N	uint16_t	wLength;
N
N} SETUP_PACKET, *PSETUP_PACKET;
N
Ntypedef struct _SETUP_GET_STATUS
N{
N	union
N	{
N		struct
N		{
N			uint16_t	SelfPowered : 1;
N			uint16_t	RemoteWakeup : 1;
N			uint16_t	Reserved : 14;
N		} Global;
N
N		struct
N		{
N			uint16_t	EndPointHalt : 1;
N			uint16_t	Reserved : 15;
N
N		} EP;
N
N	} Status;
N
N} SETUP_GET_STATUS, *PSETUP_GET_STATUS;
N
Ntypedef enum _CXF_STATUS
N{
N	CXF_STATUS__NORMAL = 0,
N	CXF_STATUS__DOING = 1,
N	CXF_STATUS__NEED_TO_DONE = 2,
N	CXF_STATUS__COMPLETE_DONE = 3
N
N} CXF_STATUS;
N
N
N
N
N//
N// HID Descriptor
N//
N
Ntypedef struct _TOUCH_MAX_COUNT
N{
N	uint8_t		ReportID;
N	uint8_t		Count;
N	// uint8_t		Reserved; //    ??
N
N} TOUCH_MAX_COUNT, *PTOUCH_MAX_COUNT;
N
N// For USB
Ntypedef struct _SETUP_HID_DESCRIPTOR
N{
N	uint8_t	bLength;
N	uint8_t	bDescriptorType;
N	uint16_t	bcdHID;
N	uint8_t	bCountryCode;
N	uint8_t	bNumDescriptors;
N	uint8_t	bDescriptorType_Class;
N	uint16_t	wDescriptorLength;
N
N} SETUP_HID_DESCRIPTOR, *PSETUP_HID_DESCRIPTOR;
N#define HID_DESCRIPTOR_LENGTH			0x09
N
N
N
N// HID Report ID
N#define HID_REPORT_ID__MOUSE 			0x02
N#define HID_REPORT_ID__LATENCY_MODE		0x05
N#define HID_REPORT_ID__BLOB_CODE		0x06
N#define HID_REPORT_ID__DEVICE_MODE 		0x07
N#define HID_REPORT_ID__CONTACT_COUNT 	0x08
N#define HID_REPORT_ID__CUSTOM_OUT		0x09
N#define HID_REPORT_ID__CUSTOM_IN		0x0A
N#define HID_REPORT_ID__PEN				0x0B
N#define HID_REPORT_ID__PEN_SECOND		0x0C
N#define HID_REPORT_ID__MULTI_TOUCH 		0x10
N
N#define USE_USB_HID_TOUCH_DEBUG			(NO)
N
N//
N// Multi-Touch
N//
N
N#define HID_MAX_TOUCH 					0x0A
N#define HID_MAX_TOUCH_HYBRID			0x05
N
N#define	CONTACT_COUNT_LENGTH			12
N#define SCAN_TIME_LENGTH				25
N#define MAX_COUNT_LENGTH				12
N#define BLOB_CODE_LENGTH				19
N#define DEVICE_MODE_LENGTH				0 // 28
N#define MOUSE_LENGTH					0 // 58
N
N#ifdef LATENCY_MODE
S#define LATENCY_LENGTH					18
N#else
N#define LATENCY_LENGTH					0
N#endif
N
N
N
N#if USE_USB_HID_TOUCH_DEBUG
X#if ((1==0))
S#define TOUCH_DEBUG_LENGTH 				49
N#else
N#define TOUCH_DEBUG_LENGTH 				0
N#endif
N
N
N
N#define HID_MULTITOUCH_DESC_HEAD_LENGTH	(0x08)	
N#define HID_MULTITOUCH_DESC_MAIN_LENGTH	0x40 //0x3C
N#define HID_MULTITOUCH_DESC_TAIL_LENGTH	(CONTACT_COUNT_LENGTH + SCAN_TIME_LENGTH + MAX_COUNT_LENGTH + BLOB_CODE_LENGTH + LATENCY_LENGTH + DEVICE_MODE_LENGTH + MOUSE_LENGTH + TOUCH_DEBUG_LENGTH + 1)
N#if USE_USB_HID_TOUCH_DEBUG
X#if ((1==0))
S#define HID_MULTITOUCH_DESC_TOTAL_LENGTH (HID_MULTITOUCH_DESC_HEAD_LENGTH + (HID_MULTITOUCH_DESC_MAIN_LENGTH * HID_MAX_TOUCH_HYBRID) + HID_MULTITOUCH_DESC_TAIL_LENGTH)
N#else
N#define HID_MULTITOUCH_DESC_TOTAL_LENGTH (HID_MULTITOUCH_DESC_HEAD_LENGTH + (HID_MULTITOUCH_DESC_MAIN_LENGTH * HID_MAX_TOUCH) + HID_MULTITOUCH_DESC_TAIL_LENGTH)
N#endif
N#define HID_TOUCH_BLOB_LENGTH			0x101
N
N// Queue
N#define QUEUE_MAX_COUNT__TOUCH			10
N
N// Tip
N#define FINGER_STATUS__TIP_SWITCH		0x01
N
N// Device Mode
N#define DEVICE_MODE__MOUSE				0x00
N#define DEVICE_MODE__SINGLE_INPUT		0x01
N#define DEVICE_MODE__MULTI_INPUT		0x02
N
N
N// 27" LGD_MNT
N#define X_PHYSICAL_MAX					52704	//   (30.931 cm)
N#define Y_PHYSICAL_MAX					29646	//   (17.399 cm)
N
N// 14 "
N//#define X_PHYSICAL_MAX					30931	//   (30.931 cm)
N//#define Y_PHYSICAL_MAX					17399	//   (17.399 cm)
N// 13.3"
N// X, Y Physical Maximum
N//#define X_PHYSICAL_MAX					29376	//   (29.376 cm)
N//#define Y_PHYSICAL_MAX					16524	//   (16.524 cm)
N
N// X, Y Logical Maximum
N#define X_Y_LOGICAL_MAX					32767
N
N#define SCAN_TIME_MAX					65535
N
N#if USE_USB_HID_TOUCH_DEBUG
X#if ((1==0))
S#define HID_TOUCH__DEBUG1				0x04
S#define HID_TOUCH__DEBUG2				0x05
S#define HID_TOUCH__DEBUG3				0x06
S#define HID_TOUCH__DEBUG4			    0x07
S#define HID_TOUCH__DEBUG5				0x08
S#define HID_TOUCH__DEBUG6				0x09
S#define HID_TOUCH__DEBUG7				0x0A
S#define HID_TOUCH__DEBUG8				0x0B
N#endif
N
N
N
Ntypedef struct _SETREPORT_DEVICE_MODE
N{
N	uint8_t	ReportID;
N	uint8_t	DeviceMode;
N	uint8_t	DeviceIdentifier;
N
N} SETREPORT_DEVICE_MODE, *PSETREPORT_DEVICE_MODE;
N
Ntypedef struct _SETREPORT_LATENCY_MODE
N{
N	uint8_t	ReportID;
N	uint8_t	Mode : 1; // Normal 0, High 1
N	uint8_t	Reserved : 7;
N
N} SETREPORT_LATENCY_MODE, *PSETREPORT_LATENCY_MODE;
N
N// For I2C
Ntypedef struct _PROTOCOL_MOUSE_MODE
N{
N	uint8_t	ReportID;
N	uint8_t	Protocol;
N
N} PROTOCOL_MOUSE_MODE, *PPROTOCOL_MOUSE_MODE;
N
N
Ntypedef struct _HID_TOUCH
N{
N	uint8_t	Status;
N	uint8_t	ID;
N	uint16_t	x;
N	uint16_t	y;
N
N} HID_TOUCH, *PHID_TOUCH;
N
N
N// For USB
Ntypedef struct _HID_MULTITOUCH
N{
N	uint8_t		ReportID;
N	HID_TOUCH 	Touch[HID_MAX_TOUCH];
X	HID_TOUCH 	Touch[0x0A];
N	uint8_t		ContactCount;
N	uint16_t 		ScanTime;
N
N} HID_MULTITOUCH, *PHID_MULTITOUCH;
N
Ntypedef struct _HID_MULTITOUCH_HYBRID
N{
N	uint8_t		ReportID;
N	HID_TOUCH 	Touch[HID_MAX_TOUCH_HYBRID];
X	HID_TOUCH 	Touch[0x05];
N	uint8_t		ContactCount;
N	uint16_t 		ScanTime;
N    
N    #if USE_USB_HID_TOUCH_DEBUG
X    #if ((1==0))
S    // Debug
S	uint32_t 	Debug32bit[7];
S	uint16_t 	Debug16bit[1];
N    #endif
N
N} HID_MULTITOUCH_HYBRID, *PHID_MULTITOUCH_HYBRID;
N
N
N// For I2C
Ntypedef struct _HID_MULTITOUCH_I2C
N{
N	uint16_t					I2C_Length;
N	HID_MULTITOUCH			Data;
N
N} HID_MULTITOUCH_I2C, *PHID_MULTITOUCH_I2C;
N
N
N
N
N
N
N
N//
N// Custom
N//
N
N#define HID_CUSTOM_DESC_LENGTH			0x26
N//#define HID_CUSTOM_LOOP_BACK_TEST
N
Ntypedef struct _HID_CUSTOM
N{
N	uint8_t	ReportID;
N	uint8_t	MoveType;
N
N} HID_CUSTOM, *PHID_CUSTOM;
N
N// Callback
Ntypedef uint8_t(*PCOMPLETION_ROUTINE) (uint8_t* pContext, uint8_t nResult);
Ntypedef uint8_t(*PINPUT_REPORT_REQUEST_COMPLETE) (PCOMPLETION_ROUTINE pCompletionRoutine, uint8_t* pContext, uint8_t bCustom);
Ntypedef uint8_t(*POUTPUT_REPORT_REQUEST_COMPLETE) (PCOMPLETION_ROUTINE pCompletionRoutine, uint8_t* pContext, uint8_t bCustom);
Ntypedef uint8_t(*PSEND_REQUEST_COMPLETE) (PCOMPLETION_ROUTINE pCompletionRoutine, uint8_t* pContext);
N
Ntypedef struct _SILICONWORKS_HID_FRAMEWORK_RETURN_STRUCT
N{
N	PINPUT_REPORT_REQUEST_COMPLETE		pInputReportRequestComplete;
N	POUTPUT_REPORT_REQUEST_COMPLETE		pOutputReportRequestComplete;
N	PSEND_REQUEST_COMPLETE 				pSendRequestComplete;
N	uint8_t*								pControllBuffer;
N	uint32_t 								ControllBufferLength;
N	uint8_t*								pInputBuffer;
N	uint32_t								InputBufferLength;
N	uint8_t* 								pOutputBuffer;
N	uint32_t								OutputBufferLength;
N	uint8_t								TempBuffer[64];
N	uint16_t 								InputOffset;
N	uint16_t								OutputOffset;
N	bool_t 							bConnected;
N	bool_t								bSuspend;
N} SILICONWORKS_HID_FRAMEWORK_RETURN_STRUCT, *PSILICONWORKS_HID_FRAMEWORK_RETURN_STRUCT;
N
Ntypedef struct
N{
N	uint8_t PacketID;
N
N	struct
N	{
N		uint8_t bRead : 1;
N		uint8_t addr : 7;
N
N	} DeviceID_b;
N
N	uint16_t Length;
N	uint8_t Data[60];
N
N} HJ_HID_CONTROL_STRUCT, *PHJ_HID_CONTROL_STRUCT;
N
N
Ntypedef struct
N{
N	uint8_t ReportID;
N	uint8_t ReadWrtie;
N	uint16_t Address;
N	uint16_t Length;
N	uint8_t Data[58];
N} MNT_HID_TEST_STRUCT, *PMNT_HID_TEST_STRUCT;
N
N
N// For I2C
Ntypedef struct _HJ_HID_CONTROL_STRUCT_I2C
N{
N	uint16_t					I2C_Length;
N	HJ_HID_CONTROL_STRUCT	Data;
N
N} HJ_HID_CONTROL_STRUCT_I2C, *PHJ_HID_CONTROL_STRUCT_I2C;
N
N
N
N
N//
N// Pen
N//
N
N//#ifdef ADD_PEN
N//#define JOSH3_PEN_TEST
N//#endif
N
N#define HID_AZIMUTH_INPUT
N#define HID_PEN_SCAN_TIME
N
N#ifdef ADD_PEN_EXTRA
S#define PEN_EXTRA_LENGTH				(74)
N#else
N#define PEN_EXTRA_LENGTH				(0)
N#endif
N
N#ifdef HID_AZIMUTH_INPUT
N#define PEN_AZIMUTH_LENGTH				(26+24)
N#else
S#define PEN_AZIMUTH_LENGTH				(0)
N#endif
N
N#ifdef HID_PEN_SCAN_TIME
N#define HID_PEN_SCAN_TIME_LENGTH		23
N#else
S#define HID_PEN_SCAN_TIME_LENGTH		0
N#endif
N
N
N#ifdef ADD_DUAL_PEN
S	#define HID_PEN_COUNT 				2
N#else
N	#define HID_PEN_COUNT 				1
N#endif
N
N
N#define HID_PEN_DESC_LENGTH				(((0x94 + PEN_AZIMUTH_LENGTH + HID_PEN_SCAN_TIME_LENGTH)*HID_PEN_COUNT) + (PEN_EXTRA_LENGTH*HID_PEN_COUNT))
N
N// Queue
N#define QUEUE_MAX_COUNT__PEN			20
N
N#define HID_PEN_TIP						0x01
N#define HID_PEN_BARREL					0x02
N#define HID_PEN_INVERT					0x04
N#define HID_PEN_ERASER					0x08
N#define HID_PEN_INRANGE					0x20
N
N// Pen Extra
N#define HID_PEN__TRANSDUCER_TYPE		0x5B
N#define HID_PEN__TRANSDUCER_SERIAL_NUM	0x5C
N#define HID_PEN__BATTERY_LEVEL			0x3B
N#define HID_PEN__RESERVED				0x00
N
N// Pressure
N#define PRESSURE_MAX					4095
N
N// Tilt
N#define TILT_X_MIN						(-9000)
N#define TILT_Y_MIN						(-9000)
N#define TILT_X_MAX						9000
N#define TILT_Y_MAX						9000
N
N// Altitude
N#define ALTITUDE_MIN					(-9000)
N#define ALTITUDE_MAX					9000
N
N// Azimuth
N#define AZIMUTH_MAX						36000
N
N// Twist
N#define TWIST_MAX						36000
N 
N// Pen ID
N#define PEN_ID_19BIT(ID)				(ID & 0x7FFFF)
N#define PEN_ID_51BIT(ID)				(ID >> 19)
N
N
N// For USB
Ntypedef struct _HID_PEN
N{
N	uint8_t	ReportID;
N
N	union
N	{
N		struct
N		{
N			uint8_t		Tip : 1;
N			uint8_t		Barrel : 1;
N			uint8_t		Invert : 1;
N			uint8_t		Eraser : 1;
N			uint8_t		Reserved1 : 1;
N			uint8_t		InRange : 1;
N			uint8_t		Reserved2 : 2;
N		} u;
N
N		uint8_t Data;
N
N	} SwitchData;
N
N	uint16_t	x;
N	uint16_t	y;
N
N	uint16_t	Pressure;
N	int16_t  Tilt_x;
N	int16_t	Tilt_y;
N
N#ifdef HID_AZIMUTH_INPUT
N	int16_t	Altitude;
N	uint16_t	Azimuth;
N#endif
N
N	uint16_t	Twist;
N
N#ifdef HID_PEN_SCAN_TIME
N	uint16_t 	ScanTime;
N#endif
N
N#ifdef ADD_PEN_EXTRA
S	uint32_t	TransducerIndex_PenID : 13;
S	uint32_t	TransducerIndex_WacomID_LSB : 19;
S#ifdef ADD_WACOM_51BIT
S	uint32_t	TransducerIndex_WacomID_MSB;
S#endif
S	
S	uint32_t	SerialNumber;
S	uint8_t		VendorID;
S	uint8_t		BatteryStlength;
N#endif
N
N} HID_PEN, *PHID_PEN;
N
N// For I2C
Ntypedef struct _HID_PEN_I2C
N{
N	uint16_t	I2C_Length;
N	HID_PEN	Data;
N
N} HID_PEN_I2C, *PHID_PEN_I2C;
N
N
N
N
N
N
N//
N// Common (Touch + Pen)
N//
N
Ntypedef struct _HID_COMMON_USB
N{
N	uint8_t	Data[64];
N
N} HID_COMMON_USB, *PHID_COMMON_USB;
N
Ntypedef struct _HID_COMMON_I2C
N{
N	uint16_t	I2C_Length;
N	uint8_t	Data[64];
N
N} HID_COMMON_I2C, *PHID_COMMON_I2C;
N
N
N// Static Queue
N#define QUEUE_MAX_COUNT__COMMON			(30)
N#define QUEUE_BLOCK_SIZE				(66)
N#define QUEUE_SIGNATURE					"SIW4"
Ntypedef struct _STATIC_QUEUE
N{
N	uint8_t	Signature[4];
N	uint8_t	Buffer[QUEUE_BLOCK_SIZE * QUEUE_MAX_COUNT__COMMON];
X	uint8_t	Buffer[(66) * (30)];
N	uint8_t	PushPoint;
N	uint8_t	PopPoint;
N	uint32_t	Count;
N	uint8_t    Doing;
N	
N} STATIC_QUEUE, *PSTATIC_QUEUE;
N
Nuint8_t StaticQueue_Init(PSTATIC_QUEUE pQueue);
Nuint8_t StaticQueue_CheckInit(PSTATIC_QUEUE pQueue);
Nuint8_t StaticQueue_Push(PSTATIC_QUEUE pQueue, uint8_t* pData);
Nuint8_t StaticQueue_Pop(PSTATIC_QUEUE pQueue, uint8_t* pData);
Nuint8_t  StaticQueue_HeadDelete(PSTATIC_QUEUE pQueue);
Nuint8_t* StaticQueue_Get(PSTATIC_QUEUE pQueue);
Nuint8_t StaticQueue_CheckFull(PSTATIC_QUEUE pQueue);
Nuint8_t StaticQueue_CheckEmpty(PSTATIC_QUEUE pQueue);
N
N
N// I2C
Nvoid SendTouchData_I2C(PHID_MULTITOUCH_I2C pTouchData);
Nvoid SendPenData_I2C(PHID_PEN_I2C pPenData);
Nvoid QueueCommonData_I2C(void);
Nvoid GetCustomData_I2C(uint8_t* pData);
Nvoid SendCustomData_I2C(PHJ_HID_CONTROL_STRUCT_I2C pData);
Nvoid HidReadWrite__Read_I2C(PHJ_HID_CONTROL_STRUCT_I2C pHidControl);
N
N
N
N// USB
Nvoid USB_DevInit(void);
Nvoid ResumeSigal(void);
Nuint8_t CheckUsbConfig(void);
Nuint8_t CheckHIDReady(void);
Nuint8_t CheckRemoteWakeup(void);
Nvoid SendTouchData(void);
Nvoid SendTouchData_USB(uint8_t* pUserData);
Nvoid DMATouchData_USB(void);
Nvoid SendPenData(void);
Nvoid SendPenData_Multi(void);
Nvoid SendPenData_USB(PHID_PEN pUserData);
Nvoid DMAPenData_USB(void);
Nvoid QueueCommonData_USB(void);
Nvoid RecieveCustomData(uint8_t* pData);
Nvoid HidReadWrite__Read(PHJ_HID_CONTROL_STRUCT pOutBuffer);
Nvoid HidReadWrite__Write(PHJ_HID_CONTROL_STRUCT pHidControl);
Nvoid HidReadWrite_MNT_Test(PMNT_HID_TEST_STRUCT pOutBuffer);
N
N
N//uint8_t MNT_HID_Mapping_handler(uint8_t InData);
N
N#pragma pack()
N
N#endif /* _FOTG200_PERIPHERAL_H_  */
L 60 "..\..\Hal\hal_def.h" 2
N
N#include "hal_conf.h"
L 1 "..\..\Hal\hal_conf.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  hal_config.c
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _HAL_CONF_H_
N#define _HAL_CONF_H_
N
N
Ntypedef struct
N{
N	tMSPI_SCR_t tParam_SCR;
N	tMSPI_SPIENA_t tParam_SPIENA;
N
N} __PACKED tHalMspiCommonConf_t;
X} __attribute__ ((packed)) tHalMspiCommonConf_t;
N
Ntypedef struct
N{
N	tPWMDRV_GBL_t		tPWMDRV_GBL;
N	tPWMDRV_INTR_CFG_t  tPWMDRV_INTR_CFG;
N	uint32_t 			ulBeaconTable;
N	uint8_t 			ucSelTsyncOut;
N	uint16_t 			usPwmFreq;
N	uint8_t 			ucPwmPreNum;
N	uint8_t 			ucPwmSetNum;
N	uint8_t 			ucPwmFingerActNum;
N	uint8_t 			ucPwmFinger1LHBMuxNum;
N	uint8_t				ucPwmPenPosActNum;
N	uint8_t				ucPwmPenPos1LHBMuxNum;
N	uint8_t 			ucPwmPenDataActNum;
N	uint8_t 			ucPwmPenData1LHBMuxNum;
N	uint8_t 			ucPwmPenFingerActNum;
N	uint8_t 			ucPwmPenFinger1LHBMuxNum;
N	uint8_t				ucPwmLpwgActiveActNum;
N	uint8_t				ucPwmLpwgActive1LHBMuxNum;
N	uint8_t				ucPwmLpwgIdleActNum;
N	uint8_t				ucPwmLpwgIdle1LHBMuxNum;
N
N	uint16_t			usPwmNiFreq1;
N	uint8_t 			ucPwmNiActNum;
N	uint8_t 			ucPwmNi1LHBMuxNum;
N
N	uint16_t 			usFullFingerPWMIntervalDly;
N	uint16_t			usPenPositionPWMIntervalDly;
N	uint16_t 			usPenDataPWMIntervalDly;
N	uint16_t			usPenFingerPWMIntervalDly;
N	uint16_t			usLpwgActivePWMIntervalDly;
N	uint16_t			usLpwgIdlePWMIntervalDly;
N
N	tPWMDRV_PRE_0_t		tPWMDRV_PRE_0;
N	tPWMDRV_PRE_1_t		tPWMDRV_PRE_1;
N	tPWMDRV_PRE_2_t		tPWMDRV_PRE_2;
N	tPWMDRV_EPLG_0_t	tPWMDRV_EPLG_0;
N	tPWMDRV_EPLG_1_t	tPWMDRV_EPLG_1;
N	tPWMDRV_EPLG_2_t	tPWMDRV_EPLG_2;
N	tPWMDRV_PRLG_t		tPWMDRV_PRLG;
N
N	tPWMDRV_FG_0_t		tPWMDRV_FG_0;
N	tPWMDRV_FG_1_t		tPWMDRV_FG_1;
N
N	tPWMDRV_PN_0_t		tPWMDRV_PN_0;
N	tPWMDRV_PN_1_t		tPWMDRV_PN_1;
N
N	tPWMDRV_IN_CTRL_t   tPWMDRV_IN_CTRL;
N	tPWMDRV_ENA_PWM_t   tPWMDRV_ENA_PWM[ePWM_PARAM_MAX];
N
N} __PACKED tHalPwmdrvCommonConf_t;
X} __attribute__ ((packed)) tHalPwmdrvCommonConf_t;
N
Ntypedef struct
N{
N    uint8_t ucDeviceAddr;
N} __PACKED tHalI2CCommonConf_t;
X} __attribute__ ((packed)) tHalI2CCommonConf_t;
N
Ntypedef struct
N{
N    uint8_t ucDummy;
N} __PACKED tHalUSBCommonConf_t;
X} __attribute__ ((packed)) tHalUSBCommonConf_t;
N
Ntypedef struct
N{
N    tHalMspiCommonConf_t tMSPI_Conf;
N    tHalPwmdrvCommonConf_t tPWMDRV_Conf;
N    tHalI2CCommonConf_t tI2C_Conf;
N    tHalUSBCommonConf_t tUSB_Conf;
N} __PACKED tHalCommonConf_t;
X} __attribute__ ((packed)) tHalCommonConf_t;
N
N
Ntypedef struct
N{
N	eSENSING_CHANGE_MODE_t eSensingChangeMode;
N	eSENSING_MODE_t eSensingMode;
N
N#if USED_ECLK_ON_OFF_CONTROL
X#if ((0==0))
N	bool_t bIsECLKOnOffStart;
N	bool_t bIsECLKOnOffStartCheckCnt;
N#endif /* USED_ECLK_ON_OFF_CONTROL */
N
N#if USED_TPIC_MUXEN_ON_OFF_CONTROL
X#if ((0==0))
N	bool_t bIsTPICMuxEnOnOffStart;
N	bool_t bIsTPICMuxEnOnOfftartCheckCnt;
N#endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
N
N} tHalInfo_t;
N
Nextern void hal_SetCommonConfig(const tHalCommonConf_t * _p);
Nextern const tHalCommonConf_t *hal_GetCommonConfig(void);
Nextern const tHalMspiCommonConf_t *hal_mspi_GetCommonConfig(void);
Nextern const tHalPwmdrvCommonConf_t *hal_pwmdrv_GetCommonConfig(void);
Nextern tHalInfo_t *hal_GetInfo(void);
N
N#endif /* _HAL_CONF_H_ */
L 62 "..\..\Hal\hal_def.h" 2
N#include "hal.h"
L 1 "..\..\Hal\hal.h" 1
N/****************************************************************************************************//**
N* Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N*
N* file : hal.h
N* created on : 17. 4. 2017
N* Author : mhjang
N*
N* All rights reserved.
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions are met:
N* - Redistributions of source code must retain the above copyright
N*   notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*   notice, this list of conditions and the following disclaimer in the
N*   documentation and/or other materials provided with the distribution.
N* - Neither the name of SiW nor the names of its contributors may be used
N*   to endorse or promote products derived from this software without
N*   specific prior written permission.
N* *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N* ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N*******************************************************************************************************/
N
N#ifndef _HAL_H_
N#define _HAL_H_
N
N
N#define I2C_SLAVE_ADDR					(0x34)
N
N
N#define SVCall_IRQn_Priority									(1)
N#define PendSV_IRQn_Priority									((1UL << __NVIC_PRIO_BITS) - 1UL)
N/* -----------------------  MFTP Specific Interrupt Numbers  ----------------------- */
N#define WDT_IRQn_Priority										(4)
N#define EXTI0_IRQn_Priority										(1)//(3) // Operation Time of GPIO ISR is Must Short!!
N#define EXTI1_IRQn_Priority										(3)
N#define TIMER_IRQn_Priority										(5)
N#define I2C_IRQn_Priority										(1)
N#define TSPI_IRQn_Priority										(2)
N#define USB_IRQn_Priority										(0)
N#define PWMDRV_IRQn_Priority									(3)
N#define MSPI_IRQn_Priority										(0)
N#define GPDMA_IRQn_Priority										(4)
N#define DSP_A_IRQn_Priority										(3)
N#define DSP_B_IRQn_Priority										(3)
N#define PLL_IRQn_Priority										(1)
N#define FLITF_IRQn_Priority										(1)
N
N
Nenum enumIRQPriority 
N{
N    IRQ_PRIORITY_UWDT = 0,
N    IRQ_PRIORITY_EXTI0,
N    IRQ_PRIORITY_EXTI1,
N    IRQ_PRIORITY_TIMER0,
N    IRQ_PRIORITY_PWMDRV,
N    IRQ_PRIORITY_USB,
N    IRQ_PRIORITY_I2C,
N    IRQ_PRIORITY_BOD,
N    IRQ_PRIORITY_TSPI,
N    IRQ_PRIORITY_MSPI,
N    IRQ_PRIORITY_GPDMA,
N    IRQ_PRIORITY_HWACC,
N    IRQ_PRIORITY_FLITF,
N    IRQ_PRIORITY_UART,
N    IRQ_PRIORITY_TIMER123,
N};
N
N#define BLOCK_RESET_DELAY \
N			do {\
N				__NOP(); \
N				__NOP(); \
N				__NOP(); \
N				__NOP(); \
N				__NOP(); \
N			} while(0);
X#define BLOCK_RESET_DELAY 			do {				__NOP(); 				__NOP(); 				__NOP(); 				__NOP(); 				__NOP(); 			} while(0);
N
Nextern __IO tHalInterruptHandle_t tHalIntrHandle;;
Xextern volatile tHalInterruptHandle_t tHalIntrHandle;;
N
N//extern __IO uint32_t gTSyncInRisingCnt;
N//extern __IO uint32_t gMspiCounterPen;
N//extern __IO uint32_t isFirstFrame;
N//extern __IO uint32_t gDoneMSPI;
N//extern __IO uint32_t gSensingMode;
N//#if USED_IDLE_MODE_CONTROL
N//extern __IO eOP_CONTROL_MODE_t gOperationIntrHandle;
N//#endif /* USED_IDLE_MODE_CONTROL */
N
N
Nvoid initBoardGPIO(void);
Nvoid initMSPI_Pins(void);
Nextern void initECLK(void);
N#if USED_ECLK_ON_OFF_CONTROL
X#if ((0==0))
Nvoid HAL_SetECLKOnOffControl(bool_t bIsEn);
Nbool_t HAL_GetECLKOnOffControl(void);
Nvoid HAL_ECLK_On(void);
Nvoid HAL_ECLK_Off(void);
N#endif /* USED_ECLK_ON_OFF_CONTROL */
N
N#if USED_TPIC_MUXEN_ON_OFF_CONTROL
X#if ((0==0))
Nvoid HAL_SetTPICMuxEnControl(bool_t bIsEn);
Nbool_t HAL_GetTPICMuxEnControl(void);
N#endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
N
Nextern bool_t Hal_sric_start(bool_t cmuxoff);
Nextern void Hal_VccOff_State(void);
N
N#define NVIC_INT_CTRL_REG		SCB->ICSR
N#define NVIC_PENDSVSET_BIT		( 1UL << 28UL )
N
Nvoid callPendSV(void);
N
N/*
N * NOTE : New Function
N */
Nextern void HAL_Initialize(bool_t bIsLPWG);
N#if USED_PEN_MODE_OPERATION
X#if ((1==0))
Sextern void Interrupt_Init(void);
N#endif /* USED_PEN_MODE_OPERATION */
N
Nextern eSENSING_CHANGE_MODE_t HAL_GetSensingChangeMode(void);
Nextern void HAL_SetSensingChangeMode(eSENSING_CHANGE_MODE_t mode);
Nextern eSENSING_MODE_t HAL_GetSensingMode(void);
Nextern void HAL_SetSensingMode(eSENSING_MODE_t mode);
Nextern bool_t HAL_CheckSensningModeChange(eSENSING_CHANGE_MODE_t mode);
Nextern void HAL_SetLocalIndex(uint8_t index, uint8_t val);
Nextern uint16_t * HAL_GetBaseImagePointer(eSENSING_MODE_t mode, eBaseImageType_t type);
N
N#if USED_MCU_IDLE_LOW_PWR_CONTROL
X#if ((1==0))
Sextern uint32_t Hal_Exit_MCU_Sleep(void);
Sextern uint32_t Hal_Enter_MCU_Sleep(void);
N#endif /* USED_MCU_IDLE_LOW_PWR_CONTROL */
N
N#if USED_LPWG_MCU_SLEEP
X#if ((1==0) && (!((1==0))))
Sextern void Hal_WaitSampleDoneSleep(void);
Sextern void Hal_WaitModernStanbySleep(void);
N#endif /* USED_LPWG_MCU_SLEEP */
N
N#endif /* _HAL_H_ */
L 63 "..\..\Hal\hal_def.h" 2
N
N
N#endif /* _HAL_DEF_H_ */
L 38 "..\..\App\core_def.h" 2
N#include "app_def.h"
L 1 "..\..\App\app_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : app_def.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _APP_DEF_H_
N#define _APP_DEF_H_
N
N
N#include "env_def.h"
N#include "app_types.h"
L 1 "..\..\App\app_types.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : app_types.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _APP_TYPES_H_
N#define _APP_TYPES_H_
N
N
Ntypedef enum
N{
N	TOUCH_MAIN_OPERATION_ENTER = 0,
N	TOUCH_MAIN_OPERATION_NORMAL,
N	TOUCH_MAIN_OPERATION_NOISE,
N	TOUCH_MAIN_OPERATION_LPWG,
N	TOUCH_MAIN_OPERATION_DIAG,
N	TOUCH_MAIN_OPERATION_DFUP,
N	TOUCH_MAIN_OPERATION_RESET,
N	TOUCH_MAIN_OPERATION_EXIT,
N	TOUCH_MAIN_OPERATION_TEST = 0xFE,
N	TOUCH_MAIN_OPERATION_LGD_TEST = 0xFF,
N} eTouchOperMainState_t;
N
Ntypedef enum
N{
N	TOUCH_NORMAL_OPER_NONCHANGE = 0,
N	TOUCH_NORMAL_OPER_ENTER,
N#ifdef MODE_SMT
N	TOUCH_NORMAL_SMT_MODE,
N#endif /* MODE_SMT */
N	TOUCH_NORMAL_OPER_RESET_SYSTEM,
N	TOUCH_NORMAL_OPER_RESET_HAL,
N	TOUCH_NORMAL_OPER_RESET_MODULE,
N
N	TOUCH_NORMAL_OPER_RESET_REFERENCE,
N	TOUCH_NORMAL_OPER_RESET_REFERENCE_IDLE,
N	TOUCH_NORMAL_OPER_RESET_REFERENCE_FREQ1,
N	TOUCH_NORMAL_OPER_READY_REFERENCE_PEN,
N	TOUCH_NORMAL_OPER_RESET_REFERENCE_PEN,
N	TOUCH_NORMAL_OPER_NORMAL_READY,
N	TOUCH_NORMAL_OPER_NORMAL,
N
N	TOUCH_IDLE_OPER_READY_REFERENCE,
N	TOUCH_IDLE_OPER_RESET_REFERENCE,
N	TOUCH_NORMAL_OPER_IDLE_READY,
N	TOUCH_NORMAL_OPER_IDLE,
N
N	TOUCH_NORMAL_OPER_SWITCH_FREQ,
N	TOUCH_NORMAL_OPER_NORMAL_FREQ1_READY,
N	TOUCH_NORMAL_OPER_NORMAL_FREQ1,
N	TOUCH_NORMAL_OPER_LOCAL_READY,
N	TOUCH_NORMAL_OPER_LOCAL,
N	TOUCH_NORMAL_OPER_EXIT,
N} eNormalOperSubState_t;
N
Ntypedef enum
N{
N	TOUCH_NOISE_OPER_ENTER = 0,
N	TOUCH_NOISE_OPER_RESET_SYSTEM,
N	TOUCH_NOISE_OPER_RESET_HAL,
N	TOUCH_NOISE_OPER_RESET_MODULE,
N	TOUCH_NOISE_OPER_WAIT_FOR_MODULE_START,
N	TOUCH_NOISE_OPER_RESET_REFERENCE,
N	TOUCH_NOISE_OPER_NORMAL,
N	TOUCH_NOISE_OPER_EXIT,
N} eNoiseOperSubState_t;
N
Ntypedef enum
N{
N	TOUCH_LPWG_OPER_NONCHANGE = 0,
N	TOUCH_LPWG_OPER_ENTER,
N	TOUCH_LPWG_OPER_RESET_SYSTEM,
N	TOUCH_LPWG_OPER_RESET_HAL,
N	TOUCH_LPWG_OPER_RESET_MODULE,
N	TOUCH_LPWG_OPER_RESET_REFERENCE,
N	TOUCH_LPWG_OPER_NORMAL_READY,
N	TOUCH_LPWG_OPER_NORMAL,
N	TOUCH_LPWG_OPER_EXIT,
N} eLpwgOperSubState_t;
N
Ntypedef enum
N{
N	TOUCH_DFUP_OPER_ENTER = 0,
N	TOUCH_DFUP_OPER_INITIALISE,
N	TOUCH_DFUP_OPER_RESET_REFERENCE,
N	TOUCH_DFUP_OPER_NORMAL,
N	TOUCH_DFUP_OPER_EXIT,
N} eDfupOperSubState_t;
N
Ntypedef enum
N{
N	TOUCH_DIAG_OPER_ENTER = 0,
N	TOUCH_DIAG_OPER_INITIALISE,
N	TOUCH_DIAG_OPER_RESET_REFERENCE,
N	TOUCH_DIAG_OPER_NORMAL,
N	TOUCH_DIAG_OPER_WAIT,
N	TOUCH_DIAG_OPER_EXIT,
N} eDiagOperSubState_t;
N
N
N#endif /* _APP_TYPES_H_ */
L 39 "..\..\App\app_def.h" 2
N#if !defined(USE_BOOTLOADER_CODE)
X#if !0L
N#include "algorithm_def.h"
N#endif /* !defined(USE_BOOTLOADER_CODE) */
N#include "app_conf.h"
L 1 "..\..\App\app_conf.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : app_conf.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _APP_CONF_H_
N#define _APP_CONF_H_
N
N
N/*
N * Types
N */
Ntypedef struct
N{
N    char vcProductCode[16];//u8byteString_t uProductCode;
N
N	uint8_t ucFrameRate;
N	uint8_t ucIdleFrameRate;
N
N    /*
N     * Idle Mode.
N     */
N    bool_t bUsedIdleModeCtrl;
N    uint8_t ucIdleModeEnterSec;
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S    uint16_t HoppMainRollbackSec;
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N    /*
N     * Frequency Hopping Settings.
N     */
N    bool_t bUseFreqHopp;
N    eSENSING_FREQ_t MainFreq;
N    eSENSING_FREQ_t HoppFreq1;
N	eSENSING_FREQ_t HoppFreq2;
N
N} __PACKED tAppCommonConf_t;
X} __attribute__ ((packed)) tAppCommonConf_t;
N
Ntypedef struct
N{
N	int iFrameCnt;
N//	volatile int lEnterIdleModeCnt;
N	volatile bool_t bBlockESDDetection;
N
N	/*
N	* Idle Mode Handling
N	*/
N	ePowerConsumptionState_t ePCSMode;
N//	int iIdleModeFrameCnt;
N	int iFrameRate;
N
N	/*
N	* Noise Handling
N	*/
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	eSelectFREQ 		eSelectFreq;
S	eNoiseStatus_t 		eNoiseStatus;
S	eHoppingStatus_t 	eHoppingStatus;
S	uint8_t 			ucHoppFrameCnt;
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N} __PACKED tAppInfo_t;
X} __attribute__ ((packed)) tAppInfo_t;
N
N/*
N * Default Methods
N */
N
Nextern void app_SetCommonConfig(const tAppCommonConf_t *_p);
Nextern const tAppCommonConf_t *app_GetCommonConfig(void);
Nextern tAppInfo_t *app_GetInfo(void);
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
Sextern eSelectFREQ app_GetCurrentSelectFrequency(void);
Sextern void app_SetCurrentSelectFrequency(eSelectFREQ eSelFreq);
Sextern eSelectFREQ app_GetSelectFrequency(void);
Sextern void app_SetSelectFrequency(eSelectFREQ eSelFreq);
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N#endif /* _APP_CONF_H_ */
L 43 "..\..\App\app_def.h" 2
N#include "app_main.h"
L 1 "..\..\App\app_main.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : app_main.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _APP_MAIN_H_
N#define _APP_MAIN_H_
N
N
Nextern int app_MainProc(void);
Nextern eTouchOperMainState_t app_normal_oper_handler(void);
Nextern eTouchOperMainState_t app_noise_oper_handler(void);
Nextern eTouchOperMainState_t app_lpwg_oper_handler(void);
Nextern eTouchOperMainState_t app_dfup_oper_handler(void);
Nextern eTouchOperMainState_t app_diag_oper_handler(void);
N#if USED_TEST_OPERATION_ENABLE
X#if ((1==0))
Sextern eTouchOperMainState_t app_test_main_oper_handler(void);
N#endif /* USED_TEST_OPERATION_ENABLE */
N#ifdef _USE_APP_LGD_LIB_
Sextern eTouchOperMainState_t app_lgd_test_main_oper_handler(void);
N#endif /* USED_TEST_OPERATION_ENABLE */
N
N//extern void app_Init(void);
Nextern void app_CheckIdleState(void);
N
N#endif /* _APP_MAIN_H_ */
L 44 "..\..\App\app_def.h" 2
N
N
N#endif /* _APP_DEF_H_ */
L 39 "..\..\App\core_def.h" 2
N#include "algorithm_def.h"
N#include "module_def.h"
L 1 "..\..\Module\module_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : module_def.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MODULE_DEF_H_
N#define _MODULE_DEF_H_
N
N
N#include "env_def.h"
N
N#include "module_types.h"
N#include "app_types.h"
N
N#include "sric.h"
L 1 "..\..\Module\SRIC\sric.h" 1
N/****************************************************************************************************/ /**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : sric.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *	 notice, this list of conditions and the following disclaimer.
N *	 - Redistributions in binary form must reproduce the above copyright
N *	 notice, this list of conditions and the following disclaimer in the
N *	 documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *	 to endorse or promote products derived from this software without
N *	 specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef SRIC_H_
N#define SRIC_H_
N
N
N#include "_sric.h"
L 1 "..\..\Module\SRIC\_sric.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _sric.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __SRIC_H_
N#define __SRIC_H_
N
N
N#include "_sric_param.h"
L 1 "..\..\Module\SRIC\_sric_param.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : _sric_p.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef __SRIC_P_H_
N#define __SRIC_P_H_
N
N#if (CUSTOMER == MODEL_LGD_SW92400)
X#if (((3)) == (1))
Stypedef struct
S{
S	__IO uint16_t		CFGR_MD_IDLE;//CFGR_PRODUCT_ID;
S	__IO uint16_t		CFGR_SNSR_STR;//CFGR_SNSR_STR;
S	__IO uint16_t		CFGR_MD_GENERAL;//CFGR_MD_GENERAL;
S	__IO uint16_t		CFGR_AIP_ADC;//CFGR_AIP_ADC;
S	__IO uint16_t		CFGR_SSU_CTRL;//CFGR_SSU_CTRL;
S	__IO uint16_t		CFGR_CH01_CR;//CFGR_TSYNC_NUM0;
S	__IO uint16_t		CFGR_CH23_CR;//CFGR_TSYNC_NUM1;
S	__IO uint16_t		CFGR_CH45_CR;//CFGR_TSYNC_DMMY;
S	__IO uint16_t		CFGR_CH67_CR;//CFGR_PWM_NUM0;
S	__IO uint16_t		CFGR_CH89_CR;//CFGR_PWM_NUM1;
S	__IO uint16_t		CFGR_CH0_EDG_CR;//CFGR_CMUX_NORM;
S	__IO uint16_t		CFGR_CH1_EDG_CR;//CFGR_CHIP0_LEN;
S	__IO uint16_t		CFGR_CH2_EDG_CR;//CFGR_COL_NUM;
S	__IO uint16_t		CFGR_CH3_EDG_CR;//CFGR_OUTER;
S	__IO uint16_t		CFGR_CH4_EDG_CR;//CFGR_DIG_GAIN0;
S	__IO uint16_t		CFGR_CH5_EDG_CR;//CFGR_DIG_GAIN1;
S	__IO uint16_t		CFGR_CH6_EDG_CR;//CFGR_NIH_MIN0;
S	__IO uint16_t		CFGR_CH7_EDG_CR;//CFGR_NIH_MAX0;
S	__IO uint16_t		CFGR_CH8_EDG_CR;//CFGR_NIH_MIN1;
S	__IO uint16_t		CFGR_CH9_EDG_CR;//CFGR_NIH_MAX1;
S	__IO uint16_t		CFGR_TSYNC_NUM0;//CFGR_NIH_MIN2;
S	__IO uint16_t		CFGR_TSYNC_NUM1;//CFGR_NIH_MAX2;
S	__IO uint16_t		CFGR_TSYNC_DMMY;//CFGR_NIH_MIN3;
S	__IO uint16_t		CFGR_PWM_NUM0;//CFGR_NIH_MAX3;
S	__IO uint16_t		CFGR_PWM_NUM1;//CFGR_NIH_RDAT0;
S	__IO uint16_t		CFGR_CMUX_NORM;//CFGR_NIH_RDAT1;
S	__IO uint16_t		CFGR_CMUX_NOISE;//CFGR_NIH_RDAT2;
S	__IO uint16_t		CFGR_COL_NUM;//CFGR_NIH_RDAT3;
S	__IO uint16_t		CFGR_OUTER;//CFGR_NIH_STD;
S	__IO uint16_t		CFGR_DIG_GAIN0;//CFGR_SHA_STR;
S	__IO uint16_t		CFGR_DIG_GAIN1;//CFGR_DIG_GAIN2;
S	__IO uint16_t		CFGR_NIH_MIN0;//CFGR_RSTP_WIDTH;
S	__IO uint16_t		CFGR_NIH_MAX0;//CFGR_VCR_STR;
S	__IO uint16_t		CFGR_NIH_MIN1;//CFGR_VCR2_MD;
S	__IO uint16_t		CFGR_NIH_MAX1;//CFGR_VCR2_PHTCR;
S	__IO uint16_t		CFGR_NIH_MIN2;//CFGR_PHTH0_WIDTH;
S	__IO uint16_t		CFGR_NIH_MAX2;//CFGR_PHTH1_WIDTH;
S	__IO uint16_t		CFGR_NIH_MIN3;//CFGR_TEST_OPT;
S	__IO uint16_t		CFGR_NIH_MAX3;//CFGR_SSU_ON;
S	__IO uint16_t		CFGR_NIH_RDAT0;//CFGR_CMUX_NUM;
S	__IO uint16_t		CFGR_NIH_RDAT1;//CFGR_SSU_CR_I00;
S	__IO uint16_t		CFGR_NIH_RDAT2;//CFGR_SSU_CR_I04;
S	__IO uint16_t		CFGR_NIH_RDAT3;//CFGR_SSU_CR_I08;
S	__IO uint16_t		CFGR_NIH_STD;//CFGR_SSU_CR_I12;
S	__IO uint16_t		CFGR_SHA_STR;//CFGR_SSU_CR_I14;
S	__IO uint16_t		CFGR_DIG_GAIN2;//CFGR_SSU_CR_E00;
S	__IO uint16_t		CFGR_PHTH0_WIDTH;//CFGR_SSU_CR_E04;
S	__IO uint16_t		CFGR_PHT_SEL;//CFGR_SSU_CR_E08;
S	__IO uint16_t		CFGR_RSTP_WIDTH;//CFGR_SSU_CR_E12;
S	__IO uint16_t		CFGR_VCR_STR;//CFGR_SSU_CR_E14;
S	__IO uint16_t		CFGR_VCR_CTRL;//CFGR_DATA_CR_I00;
S	__IO uint16_t		CFGR_VCR_MD2;//CFGR_DATA_CR_I08;
S	__IO uint16_t		CFGR_CHIP0_LEN;//CFGR_DATA_CR_I16;
S	__IO uint16_t		CFGR_TEST_OPT;//CFGR_DATA_CR_I24;
S	__IO uint16_t		CFGR_DAC_IN;//CFGR_DATA_CR_I32;
S	__IO uint16_t		CFGR_DAC_CNT;//CFGR_DATA_CR_I40;
S	__IO uint16_t		CFGR_RSVD0;//CFGR_DATA_CR_E00;
S	__IO uint16_t		CFGR_RSVD1;//CFGR_DATA_CR_E08;
S	__IO uint16_t		CFGR_RSVD2;//CFGR_DATA_CR_E16;
S	__IO uint16_t		CFGR_RSVD3;//CFGR_DATA_CR_E24;
S} __PACKED tROIC_RegDef;
N#else /* (CUSTOMER == MODEL_LGD_SW92400) */
Ntypedef struct
N{
N	__IO uint16_t		SRIC_CFGR_00H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_00H[(4)];
N	__IO uint16_t		SRIC_CFGR_02H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_02H[(4)];
N	__IO uint16_t		SRIC_CFGR_04H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_04H[(4)];
N	__IO uint16_t		SRIC_CFGR_06H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_06H[(4)];
N	__IO uint16_t		SRIC_CFGR_08H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_08H[(4)];
N	__IO uint16_t		SRIC_CFGR_0AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_0AH[(4)];
N	__IO uint16_t		SRIC_CFGR_0CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_0CH[(4)];
N	__IO uint16_t		SRIC_CFGR_0EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_0EH[(4)];
N	__IO uint16_t		SRIC_CFGR_10H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_10H[(4)];
N	__IO uint16_t		SRIC_CFGR_12H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_12H[(4)];
N	__IO uint16_t		SRIC_CFGR_14H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_14H[(4)];
N	__IO uint16_t		SRIC_CFGR_16H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_16H[(4)];
N	__IO uint16_t		SRIC_CFGR_18H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_18H[(4)];
N	__IO uint16_t		SRIC_CFGR_1AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_1AH[(4)];
N	__IO uint16_t		SRIC_CFGR_1CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_1CH[(4)];
N	__IO uint16_t		SRIC_CFGR_1EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_1EH[(4)];
N	__IO uint16_t		SRIC_CFGR_20H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_20H[(4)];
N	__IO uint16_t		SRIC_CFGR_22H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_22H[(4)];
N	__IO uint16_t		SRIC_CFGR_24H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_24H[(4)];
N	__IO uint16_t		SRIC_CFGR_26H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_26H[(4)];
N	__IO uint16_t		SRIC_CFGR_28H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_28H[(4)];
N	__IO uint16_t		SRIC_CFGR_2AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_2AH[(4)];
N	__IO uint16_t		SRIC_CFGR_2CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_2CH[(4)];
N	__IO uint16_t		SRIC_CFGR_2EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_2EH[(4)];
N	__IO uint16_t		SRIC_CFGR_30H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_30H[(4)];
N	__IO uint16_t		SRIC_CFGR_32H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_32H[(4)];
N	__IO uint16_t		SRIC_CFGR_34H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_34H[(4)];
N	__IO uint16_t		SRIC_CFGR_36H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_36H[(4)];
N	__IO uint16_t		SRIC_CFGR_38H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_38H[(4)];
N	__IO uint16_t		SRIC_CFGR_3AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_3AH[(4)];
N	__IO uint16_t		SRIC_CFGR_3CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_3CH[(4)];
N	__IO uint16_t		SRIC_CFGR_3EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_3EH[(4)];
N	__IO uint16_t		SRIC_CFGR_40H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_40H[(4)];
N	__IO uint16_t		SRIC_CFGR_42H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_42H[(4)];
N	__IO uint16_t		SRIC_CFGR_44H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_44H[(4)];
N	__IO uint16_t		SRIC_CFGR_46H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_46H[(4)];
N	__IO uint16_t		SRIC_CFGR_48H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_48H[(4)];
N	__IO uint16_t		SRIC_CFGR_4AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_4AH[(4)];
N	__IO uint16_t		SRIC_CFGR_4CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_4CH[(4)];
N	__IO uint16_t		SRIC_CFGR_4EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_4EH[(4)];
N	__IO uint16_t		SRIC_CFGR_50H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_50H[(4)];
N	__IO uint16_t		SRIC_CFGR_52H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_52H[(4)];
N	__IO uint16_t		SRIC_CFGR_54H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_54H[(4)];
N	__IO uint16_t		SRIC_CFGR_56H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_56H[(4)];
N	__IO uint16_t		SRIC_CFGR_58H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_58H[(4)];
N	__IO uint16_t		SRIC_CFGR_5AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_5AH[(4)];
N	__IO uint16_t		SRIC_CFGR_5CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_5CH[(4)];
N	__IO uint16_t		SRIC_CFGR_5EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_5EH[(4)];
N	__IO uint16_t		SRIC_CFGR_60H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_60H[(4)];
N	__IO uint16_t		SRIC_CFGR_62H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_62H[(4)];
N	__IO uint16_t		SRIC_CFGR_64H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_64H[(4)];
N	__IO uint16_t		SRIC_CFGR_66H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_66H[(4)];
N	__IO uint16_t		SRIC_CFGR_68H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_68H[(4)];
N	__IO uint16_t		SRIC_CFGR_6AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_6AH[(4)];
N	__IO uint16_t		SRIC_CFGR_6CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_6CH[(4)];
N	__IO uint16_t		SRIC_CFGR_6EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_6EH[(4)];
N	__IO uint16_t		SRIC_CFGR_70H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_70H[(4)];
N	__IO uint16_t		SRIC_CFGR_72H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_72H[(4)];
N	__IO uint16_t		SRIC_CFGR_74H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_74H[(4)];
N	__IO uint16_t		SRIC_CFGR_76H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_76H[(4)];
N	__IO uint16_t		SRIC_CFGR_78H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_78H[(4)];
N	__IO uint16_t		SRIC_CFGR_7AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_7AH[(4)];
N	__IO uint16_t		SRIC_CFGR_7CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_7CH[(4)];
N	__IO uint16_t		SRIC_CFGR_7EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_7EH[(4)];
N	__IO uint16_t		SRIC_CFGR_80H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_80H[(4)];
N	__IO uint16_t		SRIC_CFGR_82H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_82H[(4)];
N	__IO uint16_t		SRIC_CFGR_84H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_84H[(4)];
N	__IO uint16_t		SRIC_CFGR_86H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_86H[(4)];
N	__IO uint16_t		SRIC_CFGR_88H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_88H[(4)];
N	__IO uint16_t		SRIC_CFGR_8AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_8AH[(4)];
N	__IO uint16_t		SRIC_CFGR_8CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_8CH[(4)];
N	__IO uint16_t		SRIC_CFGR_8EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_8EH[(4)];
N	__IO uint16_t		SRIC_CFGR_90H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_90H[(4)];
N	__IO uint16_t		SRIC_CFGR_92H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_92H[(4)];
N	__IO uint16_t		SRIC_CFGR_94H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_94H[(4)];
N	__IO uint16_t		SRIC_CFGR_96H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_96H[(4)];
N	__IO uint16_t		SRIC_CFGR_98H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_98H[(4)];
N	__IO uint16_t		SRIC_CFGR_9AH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_9AH[(4)];
N	__IO uint16_t		SRIC_CFGR_9CH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_9CH[(4)];
N	__IO uint16_t		SRIC_CFGR_9EH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_9EH[(4)];
N	__IO uint16_t		SRIC_CFGR_A0H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_A0H[(4)];
N	__IO uint16_t		SRIC_CFGR_A2H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_A2H[(4)];
N	__IO uint16_t		SRIC_CFGR_A4H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_A4H[(4)];
N	__IO uint16_t		SRIC_CFGR_A6H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_A6H[(4)];
N	__IO uint16_t		SRIC_CFGR_A8H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_A8H[(4)];
N	__IO uint16_t		SRIC_CFGR_AAH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_AAH[(4)];
N	__IO uint16_t		SRIC_CFGR_ACH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_ACH[(4)];
N	__IO uint16_t		SRIC_CFGR_AEH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_AEH[(4)];
N	__IO uint16_t		SRIC_CFGR_B0H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_B0H[(4)];
N	__IO uint16_t		SRIC_CFGR_B2H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_B2H[(4)];
N	__IO uint16_t		SRIC_CFGR_B4H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_B4H[(4)];
N	__IO uint16_t		SRIC_CFGR_B6H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_B6H[(4)];
N	__IO uint16_t		SRIC_CFGR_B8H[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_B8H[(4)];
N	__IO uint16_t		SRIC_CFGR_BAH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_BAH[(4)];
N	__IO uint16_t		SRIC_CFGR_BCH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_BCH[(4)];
N	__IO uint16_t		SRIC_CFGR_FAH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_FAH[(4)];
N	__IO uint16_t		SRIC_CFGR_FCH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_FCH[(4)];
N	__IO uint16_t		SRIC_CFGR_FEH[MSPI_NUM];
X	volatile uint16_t		SRIC_CFGR_FEH[(4)];
N} __PACKED tROIC_RegDef;
X} __attribute__ ((packed)) tROIC_RegDef;
N#endif /* (CUSTOMER == MODEL_LGD_SW92400) */
N
N#endif /* __SRIC_P_H_ */
L 38 "..\..\Module\SRIC\_sric.h" 2
N
N// LGD VBS SRIC SW92400 Register
Ntypedef struct
N{
N	__IO uint16_t		CFGR_MD_IDLE;//CFGR_PRODUCT_ID;
X	volatile uint16_t		CFGR_MD_IDLE;
N	__IO uint16_t		CFGR_SNSR_STR;//CFGR_SNSR_STR;
X	volatile uint16_t		CFGR_SNSR_STR;
N	__IO uint16_t		CFGR_MD_GENERAL;//CFGR_MD_GENERAL;
X	volatile uint16_t		CFGR_MD_GENERAL;
N	__IO uint16_t		CFGR_AIP_ADC;//CFGR_AIP_ADC;
X	volatile uint16_t		CFGR_AIP_ADC;
N	__IO uint16_t		CFGR_SSU_CTRL;//CFGR_SSU_CTRL;
X	volatile uint16_t		CFGR_SSU_CTRL;
N	__IO uint16_t		CFGR_CH01_CR;//CFGR_TSYNC_NUM0;
X	volatile uint16_t		CFGR_CH01_CR;
N	__IO uint16_t		CFGR_CH23_CR;//CFGR_TSYNC_NUM1;
X	volatile uint16_t		CFGR_CH23_CR;
N	__IO uint16_t		CFGR_CH45_CR;//CFGR_TSYNC_DMMY;
X	volatile uint16_t		CFGR_CH45_CR;
N	__IO uint16_t		CFGR_CH67_CR;//CFGR_PWM_NUM0;
X	volatile uint16_t		CFGR_CH67_CR;
N	__IO uint16_t		CFGR_CH89_CR;//CFGR_PWM_NUM1;
X	volatile uint16_t		CFGR_CH89_CR;
N	__IO uint16_t		CFGR_CH0_EDG_CR;//CFGR_CMUX_NORM;
X	volatile uint16_t		CFGR_CH0_EDG_CR;
N	__IO uint16_t		CFGR_CH1_EDG_CR;//CFGR_CHIP0_LEN;
X	volatile uint16_t		CFGR_CH1_EDG_CR;
N	__IO uint16_t		CFGR_CH2_EDG_CR;//CFGR_COL_NUM;
X	volatile uint16_t		CFGR_CH2_EDG_CR;
N	__IO uint16_t		CFGR_CH3_EDG_CR;//CFGR_OUTER;
X	volatile uint16_t		CFGR_CH3_EDG_CR;
N	__IO uint16_t		CFGR_CH4_EDG_CR;//CFGR_DIG_GAIN0;
X	volatile uint16_t		CFGR_CH4_EDG_CR;
N	__IO uint16_t		CFGR_CH5_EDG_CR;//CFGR_DIG_GAIN1;
X	volatile uint16_t		CFGR_CH5_EDG_CR;
N	__IO uint16_t		CFGR_CH6_EDG_CR;//CFGR_NIH_MIN0;
X	volatile uint16_t		CFGR_CH6_EDG_CR;
N	__IO uint16_t		CFGR_CH7_EDG_CR;//CFGR_NIH_MAX0;
X	volatile uint16_t		CFGR_CH7_EDG_CR;
N	__IO uint16_t		CFGR_CH8_EDG_CR;//CFGR_NIH_MIN1;
X	volatile uint16_t		CFGR_CH8_EDG_CR;
N	__IO uint16_t		CFGR_CH9_EDG_CR;//CFGR_NIH_MAX1;
X	volatile uint16_t		CFGR_CH9_EDG_CR;
N	__IO uint16_t		CFGR_TSYNC_NUM0;//CFGR_NIH_MIN2;
X	volatile uint16_t		CFGR_TSYNC_NUM0;
N	__IO uint16_t		CFGR_TSYNC_NUM1;//CFGR_NIH_MAX2;
X	volatile uint16_t		CFGR_TSYNC_NUM1;
N	__IO uint16_t		CFGR_TSYNC_DMMY;//CFGR_NIH_MIN3;
X	volatile uint16_t		CFGR_TSYNC_DMMY;
N	__IO uint16_t		CFGR_PWM_NUM0;//CFGR_NIH_MAX3;
X	volatile uint16_t		CFGR_PWM_NUM0;
N	__IO uint16_t		CFGR_PWM_NUM1;//CFGR_NIH_RDAT0;
X	volatile uint16_t		CFGR_PWM_NUM1;
N	__IO uint16_t		CFGR_CMUX_NORM;//CFGR_NIH_RDAT1;
X	volatile uint16_t		CFGR_CMUX_NORM;
N	__IO uint16_t		CFGR_CMUX_NOISE;//CFGR_NIH_RDAT2;
X	volatile uint16_t		CFGR_CMUX_NOISE;
N	__IO uint16_t		CFGR_COL_NUM;//CFGR_NIH_RDAT3;
X	volatile uint16_t		CFGR_COL_NUM;
N	__IO uint16_t		CFGR_OUTER;//CFGR_NIH_STD;
X	volatile uint16_t		CFGR_OUTER;
N	__IO uint16_t		CFGR_DIG_GAIN0;//CFGR_SHA_STR;
X	volatile uint16_t		CFGR_DIG_GAIN0;
N	__IO uint16_t		CFGR_DIG_GAIN1;//CFGR_DIG_GAIN2;
X	volatile uint16_t		CFGR_DIG_GAIN1;
N	__IO uint16_t		CFGR_NIH_MIN0;//CFGR_RSTP_WIDTH;
X	volatile uint16_t		CFGR_NIH_MIN0;
N	__IO uint16_t		CFGR_NIH_MAX0;//CFGR_VCR_STR;
X	volatile uint16_t		CFGR_NIH_MAX0;
N	__IO uint16_t		CFGR_NIH_MIN1;//CFGR_VCR2_MD;
X	volatile uint16_t		CFGR_NIH_MIN1;
N	__IO uint16_t		CFGR_NIH_MAX1;//CFGR_VCR2_PHTCR;
X	volatile uint16_t		CFGR_NIH_MAX1;
N	__IO uint16_t		CFGR_NIH_MIN2;//CFGR_PHTH0_WIDTH;
X	volatile uint16_t		CFGR_NIH_MIN2;
N	__IO uint16_t		CFGR_NIH_MAX2;//CFGR_PHTH1_WIDTH;
X	volatile uint16_t		CFGR_NIH_MAX2;
N	__IO uint16_t		CFGR_NIH_MIN3;//CFGR_TEST_OPT;
X	volatile uint16_t		CFGR_NIH_MIN3;
N	__IO uint16_t		CFGR_NIH_MAX3;//CFGR_SSU_ON;
X	volatile uint16_t		CFGR_NIH_MAX3;
N	__IO uint16_t		CFGR_NIH_RDAT0;//CFGR_CMUX_NUM;
X	volatile uint16_t		CFGR_NIH_RDAT0;
N	__IO uint16_t		CFGR_NIH_RDAT1;//CFGR_SSU_CR_I00;
X	volatile uint16_t		CFGR_NIH_RDAT1;
N	__IO uint16_t		CFGR_NIH_RDAT2;//CFGR_SSU_CR_I04;
X	volatile uint16_t		CFGR_NIH_RDAT2;
N	__IO uint16_t		CFGR_NIH_RDAT3;//CFGR_SSU_CR_I08;
X	volatile uint16_t		CFGR_NIH_RDAT3;
N	__IO uint16_t		CFGR_NIH_STD;//CFGR_SSU_CR_I12;
X	volatile uint16_t		CFGR_NIH_STD;
N	__IO uint16_t		CFGR_SHA_STR;//CFGR_SSU_CR_I14;
X	volatile uint16_t		CFGR_SHA_STR;
N	__IO uint16_t		CFGR_DIG_GAIN2;//CFGR_SSU_CR_E00;
X	volatile uint16_t		CFGR_DIG_GAIN2;
N	__IO uint16_t		CFGR_PHTH0_WIDTH;//CFGR_SSU_CR_E04;
X	volatile uint16_t		CFGR_PHTH0_WIDTH;
N	__IO uint16_t		CFGR_PHT_SEL;//CFGR_SSU_CR_E08;
X	volatile uint16_t		CFGR_PHT_SEL;
N	__IO uint16_t		CFGR_RSTP_WIDTH;//CFGR_SSU_CR_E12;
X	volatile uint16_t		CFGR_RSTP_WIDTH;
N	__IO uint16_t		CFGR_VCR_STR;//CFGR_SSU_CR_E14;
X	volatile uint16_t		CFGR_VCR_STR;
N	__IO uint16_t		CFGR_VCR_CTRL;//CFGR_DATA_CR_I00;
X	volatile uint16_t		CFGR_VCR_CTRL;
N	__IO uint16_t		CFGR_VCR_MD2;//CFGR_DATA_CR_I08;
X	volatile uint16_t		CFGR_VCR_MD2;
N	__IO uint16_t		CFGR_CHIP0_LEN;//CFGR_DATA_CR_I16;
X	volatile uint16_t		CFGR_CHIP0_LEN;
N	__IO uint16_t		CFGR_TEST_OPT;//CFGR_DATA_CR_I24;
X	volatile uint16_t		CFGR_TEST_OPT;
N	__IO uint16_t		CFGR_DAC_IN;//CFGR_DATA_CR_I32;
X	volatile uint16_t		CFGR_DAC_IN;
N	__IO uint16_t		CFGR_DAC_CNT;//CFGR_DATA_CR_I40;
X	volatile uint16_t		CFGR_DAC_CNT;
N	__IO uint16_t		CFGR_RSVD0;//CFGR_DATA_CR_E00;
X	volatile uint16_t		CFGR_RSVD0;
N	__IO uint16_t		CFGR_RSVD1;//CFGR_DATA_CR_E08;
X	volatile uint16_t		CFGR_RSVD1;
N	__IO uint16_t		CFGR_RSVD2;//CFGR_DATA_CR_E16;
X	volatile uint16_t		CFGR_RSVD2;
N	__IO uint16_t		CFGR_RSVD3;//CFGR_DATA_CR_E24;
X	volatile uint16_t		CFGR_RSVD3;
N} SRIC_TypeDef;
N
N#endif /* __SRIC_H_ */
L 38 "..\..\Module\SRIC\sric.h" 2
N
N//#include "LGD\parameter_sric.h"
N//#if USED_FINGER_ONLY
N//#include "SHARP\parameter_sric_finger.h"
N//#else /* USED_FINGER_ONLY */
N//#include "SHARP\parameter_sric_pen.h"
N//#endif /* USED_FINGER_ONLY */
N
N#define PEN_TSYNC_BEACON		(0)
N#define PEN_TSYNC_NOTUSED		(0)
N#define PEN_TSYNC_FINGER		(1)
N#define PEN_TSYNC_POSITION		(2)
N#define PEN_TSYNC_DATA			(3)
N
N//#define SRIC_ACCESS_REG_NUM 	(50)
N
N// SW92400 Register Table
N//typedef enum
N//{
N//	CFGR_PRODUCT_ID,
N//	CFGR_SNSR_STR,
N//	CFGR_MD_GENERAL,
N//	CFGR_AIP_ADC,
N//	CFGR_SSU_CTRL,
N//	CFGR_TSYNC_NUM0,
N//	CFGR_TSYNC_NUM1,
N//	CFGR_TSYNC_DMMY,
N//	CFGR_PWM_NUM0,
N//	CFGR_PWM_NUM1,
N//	CFGR_CMUX_NORM,
N//	CFGR_CHIP0_LEN,
N//	CFGR_COL_NUM,
N//	CFGR_OUTER,
N//	CFGR_DIG_GAIN0,
N//	CFGR_DIG_GAIN1,
N//	CFGR_NIH_MIN0,
N//	CFGR_NIH_MAX0,
N//	CFGR_NIH_MIN1,
N//	CFGR_NIH_MAX1,
N//	CFGR_NIH_MIN2,
N//	CFGR_NIH_MAX2,
N//	CFGR_NIH_MIN3,
N//	CFGR_NIH_MAX3,
N//	CFGR_NIH_RDAT0,
N//	CFGR_NIH_RDAT1,
N//	CFGR_NIH_RDAT2,
N//	CFGR_NIH_RDAT3,
N//	CFGR_NIH_STD,
N//	CFGR_SHA_STR,
N//	CFGR_DIG_GAIN2,
N//	CFGR_RSTP_WIDTH,
N//	CFGR_VCR_STR,
N//	CFGR_VCR2_MD,
N//	CFGR_VCR2_PHTCR,
N//	CFGR_PHTH0_WIDTH,
N//	CFGR_PHTH1_WIDTH,
N//	CFGR_TEST_OPT,
N//	CFGR_SSU_ON,
N//	CFGR_CMUX_NUM,
N//	CFGR_SSU_CR_I00,
N//	CFGR_SSU_CR_I04,
N//	CFGR_SSU_CR_I08,
N//	CFGR_SSU_CR_I12,
N//	CFGR_SSU_CR_I14,
N//	CFGR_SSU_CR_E00,
N//	CFGR_SSU_CR_E04,
N//	CFGR_SSU_CR_E08,
N//	CFGR_SSU_CR_E12,
N//	CFGR_SSU_CR_E14,
N//	CFGR_DATA_CR_I00,
N//	CFGR_DATA_CR_I08,
N//	CFGR_DATA_CR_I16,
N//	CFGR_DATA_CR_I24,
N//	CFGR_DATA_CR_I32,
N//	CFGR_DATA_CR_I40,
N//	CFGR_DATA_CR_E00,
N//	CFGR_DATA_CR_E08,
N//	CFGR_DATA_CR_E16,
N//	CFGR_DATA_CR_E24,
N//	CFGR_DATA_CR_E32,
N//	CFGR_DATA_CR_E40,
N//	CFGR_EDGE_CR_SEL,
N//	CFGR_SSU_GC,
N//	CFGR_CMUX_REMAP0,
N//	CFGR_CMUX_REMAP1,
N//	CFGR_CMUX_REMAP2,
N//	CFGR_TSYNC_NUM_PEN,
N//	CFGR_TSYNC_DMMY_PEN,
N//	CFGR_CMUX_NUM_PEN,
N//	CFGR_PEN_CTRL,
N//	CFGR_HALF_COPY,
N//	CFGR_PEN0_TSYNC0,
N//	CFGR_PEN0_TSYNC1,
N//	CFGR_PEN0_TSYNC2,
N//	CFGR_PEN0_TSYNC3,
N//	CFGR_PEN1_TSYNC0,
N//	CFGR_PEN1_TSYNC1,
N//	CFGR_PEN1_TSYNC2,
N//	CFGR_PEN1_TSYNC3,
N//	CFGR_PWM_NUM2,
N//	CFGR_PWM_NUM3,
N//	CFGR_PWM_NUM4,
N//	CFGR_PWM_NUM5,
N//	CFGR_PWM_NUM_NI,
N//	CFGR_CMUX_NI1,
N//	CFGR_CMUX_NI2,
N//	CFGR_CMUX_NI3,
N//	CFGR_CMUX_NI4,
N//	CFGR_AFE_DUM,
N//	CFGR_RSVD0,
N//	CFGR_RSVD1,
N//	CFGR_MD_IDLE,
N//	CFGR_MAX
N//} eROIC_ID;
N
Ntypedef enum {
N	ROIC_0 		= 0,
N	ROIC_1 		= 1,
N	ROIC_ALL 	= 2,
N	SM_ROIC_0 	= 3,
N	SM_ROIC_1 	= 4,
N	SM_ROIC_ALL = 5,
N	DEFAULT 	= 6
N} eROICSelect_t;
N
N#define SRIC_CFGR_SSU_CR_REG_NUM		(5)
Ntypedef enum {
N	CR_REG_MUX00 = 0,
N	CR_REG_MUX04 = 1,
N	CR_REG_MUX08 = 2,
N	CR_REG_MUX12 = 3,
N	CR_REG_MUX14 = 4,
N	CR_REG_MUX_LIMIT = SRIC_CFGR_SSU_CR_REG_NUM,
X	CR_REG_MUX_LIMIT = (5),
N
N} eROIC_CR_REG_t;
N
N#define SRIC_NUM_MAX								(6)
Ntypedef enum {
N	SRIC_IDX_0 = 0,
N	SRIC_IDX_1 = 1,
N	SRIC_IDX_2 = 2,
N	SRIC_IDX_3 = 3,
N	SRIC_IDX_4 = 4,
N	SRIC_IDX_5 = 5,
N	CR_REG_LIMIT = SRIC_NUM_MAX,
X	CR_REG_LIMIT = (6),
N
N} eSRIUC_INDEX_t;
N
N#define R0_str_Adr				(0x300)
N#define R1_str_Adr				(0x400)
N#define SM_R0_str_Adr			(0x1300)
N#define SM_R1_str_Adr			(0x1400)
N
N#define R0(Address)				((Address) + R0_str_Adr)
N#define R1(Address)				((Address) + R1_str_Adr)
N#define SM_R0(Address)			((Address) + SM_R0_str_Adr)
N#define SM_R1(Address)			((Address) + SM_R1_str_Adr)
N
N/*
N * SRIC Register Offset value
N */
N
N// Table 
N//#define PRODUCT_ID		0x00
N#define SNSR_STR		0x02
N#define MD_GENERAL		0x04
N#define AIP_ADC			0x06
N#define SSU_CTRL		0x08
N#define TSYNC_NUM0		0x0A
N#define TSYNC_NUM1		0x0C
N#define TSYNC_DMMY		0x0E
N#define PWM_NUM0		0x10
N#define PWM_NUM1		0x12
N#define CMUX_NORM		0x14
N#define CHIP0_LEN		0x16
N#define COL_NUM			0x18
N#define OUTER			0x1A
N#define DIG_GAIN0		0x1C
N#define DIG_GAIN1		0x1E
N#define NIH_MIN0		0x20
N#define NIH_MAX0		0x22
N#define NIH_MIN1		0x24
N#define NIH_MAX1		0x26
N#define NIH_MIN2		0x28
N#define NIH_MAX2		0x2A
N#define NIH_MIN3		0x2C
N#define NIH_MAX3		0x2E
N#define NIH_RDAT0		0x30
N#define NIH_RDAT1		0x32
N#define NIH_RDAT2		0x34
N#define NIH_RDAT3		0x36
N#define NIH_STD			0x38
N#define SHA_STR			0x3A
N#define DIG_GAIN2		0x3C
N#define RSTP_WIDTH		0x3E
N#define VCR_STR			0x40
N#define VCR2_MD			0x42
N#define VCR2_PHTCR		0x44
N#define PHTH0_WIDTH		0x46
N#define PHTH1_WIDTH		0x48
N#define TEST_OPT		0x4A
N#define SSU_ON			0x4C
N#define CMUX_NUM		0x4E
N#define SSU_CR_I00		0x50
N#define SSU_CR_I04		0x52
N#define SSU_CR_I08		0x54
N#define SSU_CR_I12		0x56
N#define SSU_CR_I14		0x58
N#define SSU_CR_E00		0x5A
N#define SSU_CR_E04		0x5C
N#define SSU_CR_E08		0x5E
N#define SSU_CR_E12		0x60
N#define SSU_CR_E14		0x62
N#define DATA_CR_I00		0x64
N#define DATA_CR_I08		0x66
N#define DATA_CR_I16		0x68
N#define DATA_CR_I24		0x6A
N#define DATA_CR_I32		0x6C
N#define DATA_CR_I40		0x6E
N#define DATA_CR_E00		0x70
N#define DATA_CR_E08		0x72
N#define DATA_CR_E16		0x74
N#define DATA_CR_E24		0x76
N#define DATA_CR_E32		0x78
N#define DATA_CR_E40		0x7A
N#define EDGE_CR_SEL		0x7C
N#define SSU_GC			0x7E
N#define CMUX_REMAP0		0x80
N#define CMUX_REMAP1		0x82
N#define CMUX_REMAP2		0x84
N#define TSYNC_NUM_PEN	0x86
N#define TSYNC_DMMY_PEN	0x88
N#define CMUX_NUM_PEN	0x8A
N#define PEN_CTRL		0x8C
N#define HALF_COPY		0x8E
N#define PEN0_TSYNC0		0x90
N#define PEN0_TSYNC1		0x92
N#define PEN0_TSYNC2		0x94
N#define PEN0_TSYNC3		0x96
N#define PEN1_TSYNC0		0x98
N#define PEN1_TSYNC1		0x9A
N#define PEN1_TSYNC2		0x9C
N#define PEN1_TSYNC3		0x9E
N#define PWM_NUM2		0xA0
N#define PWM_NUM3		0xA2
N#define PWM_NUM4		0xA4
N#define PWM_NUM5		0xA6
N#define PWM_NUM_NI		0xA8
N#define CMUX_NI1		0xAA
N#define CMUX_NI2		0xAC
N#define CMUX_NI3		0xAE
N#define CMUX_NI4		0xB0
N#define AFE_DUM			0xB2
N#define RSVD0			0xB4
N#define RSVD1			0xB6
N#define MD_IDLE			0xFE
N
N
Nextern void SRIC_Initialize(void);
Nextern void SW92400_Reset(eSENSING_MODE_t eSensingMode);
Nextern bool_t SRIC_Init(eSENSING_MODE_t eSensingMode);
Nextern void SRIC_Run(void);
Nextern bool_t SW92400_Check(uint32_t addr, uint16_t inputval, eROICSelect_t sel);
Nextern void SW92400_Set_CMUXOFF(bool_t bIsEnable);
Nextern bool_t SW92400_Set_FreqConfig(eSENSING_MODE_t eSensingMode);
N
N#if (CUSTOMER == MODEL_LGD_SW92400)
X#if (((3)) == (1))
Sextern void SRIC_Set_Register(uint32_t addr, uint16_t val, eROICSelect_t sel);
N#else /* (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405) */
Nextern void SRIC_Set_Register(uint32_t addr, uint16_t *WriteBuf, eROICSelect_t sel);
N#endif /* (CUSTOMER == MODEL_LGD_SW92400) */
N
Nextern uint16_t SW92400_Get_Register(uint8_t ch, uint32_t addr);
Nextern void SW92400_Each_Set_Register(uint32_t addr, uint16_t * pval, eROICSelect_t sel);
Nextern void SW92400_SetActiveIdleOperationMode(eSENSING_MODE_t eSensingMode);
N
Nextern void SRIC_Set_OS(uint16_t regAIP_ADC, uint16_t regTEST_OPT);
N
N#endif /* SRIC_H_ */
L 43 "..\..\Module\module_def.h" 2
N#include "module_conf.h"
L 1 "..\..\Module\module_conf.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  module_conf.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MODULE_CONF_H_
N#define _MODULE_CONF_H_
N
N
N#include "module.h"
L 1 "..\..\Module\module.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : module.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _MODULE_H_
N#define _MODULE_H_
N
N
Nextern void MODULE_Initialize(void);
Nextern bool_t module_Start(void);
Nextern void module_DIag_Start(void);
N
Nextern void module_CmuxOff_Start(void);
N
Nextern void module_read_full_NI_sample_data(void); // NOTE : warning
N
Nextern void module_Stop(void);
Nextern void module_Watch_Enable(void);
N
Nextern bool_t module_wait_full_sample_done(void);
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
Sextern bool_t module_wait_NI_sample_done(void);
N#endif /* USED_IDLE_MODE_CONTROL */
N//extern bool_t module_wait_lpwg_sample_done(void);
Nextern ePartialSensing_t module_wait_local_sample_done(void);
N#if USED_NOISE_HOPPING_FREQ	
X#if ((1==0))	
Sextern bool_t module_Switch_Freq(eSENSING_FREQ_t _Freq);
N#endif /* USED_NOISE_HOPPING_FREQ */
N//extern void module_SetPCSMode(ePowerConsumptionState_t _ePCSMode, int _iFrameRate);
Nextern bool_t module_IsChanged_VsyncRate(void);
N
N//extern void module_LocalStart(void);
Nextern void module_wait_Vsync_signal(eSensingMode_t _mode, int _waitCnt);
N
Nextern void hal_set_irq_flag(int _id);
Nextern void hal_clear_irq_flag(int _id);
Nextern bool_t hal_get_irq_flag(int _id);
N
Nextern void hal_set_overlap_pen(void); // NOTE : warning
Nextern void hal_clear_overlap_pen(void); // NOTE : warning
Nextern uint8_t hal_get_overlap_pen(void); // NOTE : warning
N
Nextern void SensingBufferInit(void);
N
Nextern void hal_set_LocalType_flag(ePartialSensing_t _id);
Nextern void hal_clear_LocalType_flag(void);
Nextern ePartialSensing_t hal_get_LocalType_flag(void);
N
N// NOTE :  Function   !!
Nextern void hal_set_SubState_flag(eNormalOperSubState_t _id);
Nextern void hal_clear_SubState_flag(void);
Nextern eNormalOperSubState_t hal_get_SubState_flag(void);
N
Nextern void hal_PendSVHandlerInitialize(void);
N
N
N
Nextern ePartialSensing_t module_read_local_sample_data(void);
N
Nextern bool_t module_Wait_LcdOn(void);
Nextern bool_t module_Check_LcdOn(bool_t bPullDownGPIO);
Nextern bool_t module_Init_TPEN(void);
Nextern bool_t module_Check_TPEN(void);
N
N#ifdef MODE_SMT
Nextern void module_Init_LcdOn(void);
Nextern void module_Tsync1_SignalBypass(void);
Nextern void module_Smt_Mode_Enter(void);
N#endif /* MODE_SMT */
N
Nextern bool_t module_Init_Signal(void);
Nextern bool_t module_Skip_Event(void);
Nextern void module_start_delay(void);
Nextern void module_Protocol_Init(void);
Nextern void module_HW_Init(void);
Nextern bool_t module_Defense_Recovery(void);
N
N#endif /* _MODULE_H_ */
L 38 "..\..\Module\module_conf.h" 2
N#include "_sric.h"
N
Ntypedef struct
N{
N	uint16_t ulFullSensing_Remap_Table[ROW_MAX][COL_MAX];
X	uint16_t ulFullSensing_Remap_Table[(48)][(96)];
N	uint16_t ulPartialSensing_RemapTable[16][COL_MAX];
X	uint16_t ulPartialSensing_RemapTable[16][(96)];
N} __PACKED tModuleFixedConf_t;
X} __attribute__ ((packed)) tModuleFixedConf_t;
N
N//typedef struct
N//{
N//	tROIC_RegDef R0_RegVal_Active;
N//	tROIC_RegDef R1_RegVal_Active;
N//#if USED_LPWG_MODE_CONTROL
N//	tROIC_RegDef R0_RegVal_LPWG;
N//	tROIC_RegDef R1_RegVal_LPWG;
N//#endif /* USED_LPWG_MODE_CONTROL */
N//} __PACKED tModuleSRICCommonConf_t;
N
Ntypedef struct
N{
N    //For memory Configurations
N    bool_t bIsSwapXY_;
N    bool_t bIsFlipX_;
N
N    uint8_t ucTxLessCol_;
N    uint8_t ucTxLessRow_;
N
N    uint8_t ucScreenCol_;
N    uint8_t ucScreenRow_;
N
N//    tModuleSRICCommonConf_t tSRIC_Conf;
N} __PACKED tModuleCommonConf_t;
X} __attribute__ ((packed)) tModuleCommonConf_t;
N
Ntypedef struct
N{
N    uint8_t ucOvrShift;
N	uint8_t ucIdleOvrShift;
N    uint8_t ucLocalOvrShift;
N} __PACKED tModuleModeConf_t;
X} __attribute__ ((packed)) tModuleModeConf_t;
N
N
Ntypedef struct
N{
N	uint8_t ucTxLessCol;
N	uint8_t ucTxLessRow;
N	uint8_t ucScreenCol;
N	uint8_t ucScreenRow;
N	uint8_t ucOvrShift;
N
N	uint32_t uiVSyncRateInit;
N	uint32_t uiVSyncChangeCnt;
N	uint32_t uiVSyncRateLcdOff;
N	uint8_t ucVSyncChangeCntThd;
N	uint8_t ucVSyncRateGapThd;
N
N	volatile bool_t bApplied;
N	volatile bool_t bContOrShot_Sensing;
N	volatile uint8_t ucVSyncSkipNum;
N	volatile uint8_t ucVSyncCnt;
N	volatile bool_t bLcdOff;
N
N} __PACKED tModuleInfo_t;
X} __attribute__ ((packed)) tModuleInfo_t;
N
N/*
N * Methods
N */
Nextern void module_SetFixedConfig(const tModuleFixedConf_t* p);
Nextern const tModuleFixedConf_t* module_GetFixedConfig(void);
Nextern void module_SetCommonConfig(const tModuleCommonConf_t * _p);
Nextern const tModuleCommonConf_t *module_GetCommonConfig(void);
N//extern const tModuleSRICCommonConf_t * module_SRIC_GetCommonConfig(void);
Nextern void module_SetModeConfig(const tModuleModeConf_t * _p);
Nextern const tModuleModeConf_t *module_GetModeConfig(void);
N
Nextern tModuleInfo_t *module_GetInfo(void);
N
N#endif /* _MODULE_CONF_H_ */
L 44 "..\..\Module\module_def.h" 2
N#include "module.h"
N
N
N#endif /* _MODULE_DEF_H_ */
L 41 "..\..\App\core_def.h" 2
N#include "protocol_def.h"
L 1 "..\..\Protocol\protocol_def.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  protocol_def.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _PROTOCOL_DEF_H_
N#define _PROTOCOL_DEF_H_
N
N
N#include "env_def.h"
N
N#include "protocol.h"
L 1 "..\..\Protocol\protocol.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file : protocol.h
N * created on : 17. 4. 2017
N * Author : mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _PROTOCOL_H_
N#define _PROTOCOL_H_
N
N
N//#include <stdint.h>
N//#include "env_model.h"
N
N
Ntypedef enum
N{
N    RS_READY    = 0xA0,
N    RS_NONE     = 0x05,
N    RS_LOG      = 0x77,
N    RS_IMAGE	= 0xAA
N} __PACKED eProtocolReadyStatus_t;
X} __attribute__ ((packed)) eProtocolReadyStatus_t;
N
Ntypedef enum
N{
N    ETT_NONE,
N    ETT_INTERRUPT,
N    ETT_REGISTER
N} eProtocolEventTriggerType_t;
N
N/*
N * Control Registers
N */
N
Ntypedef struct
N{
N    volatile eProtocolReadyStatus_t eReadyStatus;
N    __IO bool_t bEventReady;
X    volatile bool_t bEventReady;
N} __PACKED tProtocolGetter_t;
X} __attribute__ ((packed)) tProtocolGetter_t;
N
N#if USED_MNT_USB_CUSTOM_PROTOCOL
X#if ((1==0))
Stypedef enum
S{
S    M_TOUCH_NORMAL,
S	//M_TOUCH_DIAG,
S    M_TOUCH_DFUP,	//
S    M_TOUCH_DIAG,	//
S    M_PARAMETER,
S    M_TOUCH_LPWG,
S    M_CHECK_DNR,
S    M_CHECK_DRTIME,
S    M_CHECK_IRES,
S    M_CHECK_CM,
S    M_CHECK_STACK,
S    M_CHECK_HOPPING_VALIDITY,
S    M_CHECK_NOISE_SPECTRUM,
S    M_CHECK_RAWDATA_ON_DELAY,
S    M_GET_MAX_INTENSITY_ON_EACH_NODE,
S    M_GET_OVERSAMPLE_BUFFER,
S    M_GET_UNSORTED_OVERSAMPLE_BUFFER,
S    M_WAIT,
S    M_WATCH_DOG_RESET,
S    M_LIMIT
S} __PACKED eProtocolMode_t;
N#else
Ntypedef enum
N{
N    M_TOUCH_NORMAL,
N    M_TOUCH_DIAG,
N    M_TOUCH_DFUP,
N    M_PARAMETER,
N    M_TOUCH_LPWG,
N    M_CHECK_DNR,
N    M_CHECK_DRTIME,
N    M_CHECK_IRES,
N    M_CHECK_CM,
N    M_CHECK_STACK,
N    M_CHECK_HOPPING_VALIDITY,
N    M_CHECK_NOISE_SPECTRUM,
N    M_CHECK_RAWDATA_ON_DELAY,
N    M_GET_MAX_INTENSITY_ON_EACH_NODE,
N    M_GET_OVERSAMPLE_BUFFER,
N    M_GET_UNSORTED_OVERSAMPLE_BUFFER,
N    M_WAIT,
N    M_WATCH_DOG_RESET,
N    M_LIMIT
N} __PACKED eProtocolMode_t;
X} __attribute__ ((packed)) eProtocolMode_t;
N
N#endif
N
N
Ntypedef struct
N{
N    volatile eProtocolMode_t eMode;
N    volatile eProtocolEventTriggerType_t eEventTriggerType;
N    volatile bool_t bRecalibrate;
N    volatile ePowerConsumptionState_t ePowerConsumptionState;
N    volatile uint32_t ulGestureType;
N    volatile bool_t bDisableESDAlert;
N    volatile bool_t bChargerAttached;
N    volatile bool_t bGloveSensingEnable;
N    volatile bool_t bSensingOnWindowEnable;
N    volatile bool_t bPalmRejectionEnable;
N    volatile bool_t bDisableEdgeExpand;		
N    volatile bool_t bEnableHandShake;
N    volatile bool_t bApplyCoordinate;
N} __PACKED tProtocolSetter_t;
X} __attribute__ ((packed)) tProtocolSetter_t;
N
Ntypedef struct
N{
N    const void* pGeneralBuffer;
N    void* pParameterBuffer;
N} __PACKED tProtocolBufferPointers_t;
X} __attribute__ ((packed)) tProtocolBufferPointers_t;
N
Ntypedef struct
N{
N    tProtocolGetter_t* getter;
N    tProtocolSetter_t* setter;
N} __PACKED tProtocolCtrl_t;
X} __attribute__ ((packed)) tProtocolCtrl_t;
N
Nextern tProtocolBufferPointers_t vtProtocolBufferPointers;
Nextern tProtocolCtrl_t tProtocolCtrl;
N
Nextern uint8_t * (*protocol_GetMappedPointer)(uint16_t _addr);
Nextern void (*protocol_ClearInterrupt)(uint16_t _addr);
N
Nextern void protocol_init(void);
N
N
N#endif /* _PROTOCOL_H_ */
L 40 "..\..\Protocol\protocol_def.h" 2
N#if defined(USE_BOOTLOADER_CODE)
X#if 0L
S#include "protocol_swip.h"
S#include "protocol_dfup.h"
N#else /* USE_BOOTLOADER_CODE */
N#include "protocol_swip.h"
L 1 "..\..\Protocol\protocol_swip.h" 1
N/*
N * protocol_swip.h
N *
N *  Created on: 2015. 3. 12.
N *      Author: parkyj2
N */
N
N#ifndef __PROTOCOL_SWIP_H__
N#define __PROTOCOL_SWIP_H__
N
N
N#include "protocol_swip_regmap.h"
L 1 "..\..\Protocol\protocol_swip_regmap.h" 1
N/*
N * mip4d0.h
N *
N *  Created on: 2015. 3. 16.
N *      Author: parkyj2
N */
N
N#ifndef __SWIP_REGMAP_H__
N#define __SWIP_REGMAP_H__
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
S#define SWIP_REG_ADDR_ANDR_BASE_INFO             0x0000
S#define SWIP_REG_ADDR_SPR_CHIP_ID                0x0000
S#define SWIP_REG_ADDR_TC_VERSION                 0x0001
S#define SWIP_REG_ADDR_CHIP_VERSION               0x0002
S#define SWIP_REG_ADDR_TC_PRODUCT_ID              0x0003
N#endif
N
N#define SWIP_REG_ADDR_INFO                       0x0100
N#define SWIP_REG_ADDR_INFO_PANEL                 0x0100
N#define SWIP_REG_ADDR_INFO_SECTION_VERSION       0x0120
N#define SWIP_REG_ADDR_INFO_SECTION_ADDR          0x0130
N#define SWIP_REG_ADDR_INFO_INTEGRITY             0x0140//0x0148//0x0148
N#define SWIP_REG_ADDR_INFO_INTERFACE             0x0150
N#define SWIP_REG_ADDR_INFO_EXTRA                 0x0170
N#define SWIP_REG_ADDR_INFO_TRIMCODE_1            0x01A0
N#define SWIP_REG_ADDR_INFO_TRIMCODE_2            0x01C0
N
N#define SWIP_REG_ADDR_EVENT                      0x0200
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S//#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0200
S//#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
S#define SWIP_REG_ADDR_EVENT_PACKET_FORMAT	     0x0200
S#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0208
S#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x020C
N#else /* USED_MOBILE_I2C_PROTOCOL */
N#define SWIP_REG_ADDR_EVENT_FORMAT               0x0200
N#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0210
N#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
S#define SWIP_REG_ADDR_ANDROID_EVENT              0x0300
S#define SWIP_REG_ADDR_ANDROID_IC_STATUS          0x0300
S#define SWIP_REG_ADDR_ANDROID_TC_STATUS          0x0301
S#define SWIP_REG_ADDR_ANDROID_TOUCH_INFO         0x0302
S#define SWIP_REG_ADDR_ANDROID_PACKET_DATA        0x0303
S
S#define SWIP_REG_ADDR_SPR_CHIP_INFO              0x0400
S#define SWIP_REG_ADDR_SPR_CHIP_TEST              0x0400
S#define SWIP_REG_ADDR_SPR_BOOT_STS               0x0401
S#define SWIP_REG_ADDR_TC_DEVICE_CTL              0x0402
S#define SWIP_REG_ADDR_TC_INTERRUPT_CTL           0x0403
S#define SWIP_REG_ADDR_IME_STATE                  0x0404
S#define SWIP_REG_ADDR_TCI_ENABLE_W               0x0405
S#define SWIP_REG_ADDR_SWIPE_ENABLE_W             0x0406
S#define SWIP_REG_ADDR_SPR_SUBDISP_STS            0x0407
S#define SWIP_REG_ADDR_TC_DRIVE_CTL               0x0408
N#endif
N
N#define SWIP_REG_ADDR_CTRL                       0x0600
N#define SWIP_REG_ADDR_CTRL_GETTER                0x0600
N#define SWIP_REG_ADDR_CTRL_SETTER                0x0610
N
N#define SWIP_REG_ADDR_PARAMETER                  0x0800
N#define SWIP_REG_ADDR_PARAMETER_INFO             0x0800
N//#define SWIP_REG_ADDR_PARAMETER_CONTROL          0x0810
N
N#define SWIP_REG_ADDR_TEST                       0x0A00
N#define SWIP_REG_ADDR_TEST_CM_INFO               0x0A00
N#define SWIP_REG_ADDR_TEST_CM_CONTROL            0x0A10
N#define SWIP_REG_ADDR_TEST_CM_DATA_FORMAT        0x0A20
N
N#define SWIP_REG_ADDR_IMAGE                      0x0C00
N#define SWIP_REG_ADDR_IMAGE_INFO                 0x0C00
N#define SWIP_REG_ADDR_IMAGE_CONTROL              0x0C10
N#define SWIP_REG_ADDR_IMAGE_DATA_FORMAT          0x0C20
N#define SWIP_REG_ADDR_IMAGE_FINGER_NUM           0x0C30
N#define SWIP_REG_ADDR_IMAGE_FINGER_AREA          0x0C31
N
N#define SWIP_REG_ADDR_LOG                        0x1000
N#define SWIP_REG_ADDR_LOG_INFO                   0x1000
N#define SWIP_REG_ADDR_LOG_CONTROL                0x1010
N#define SWIP_REG_ADDR_LOG_DATA_FORMAT            0x1020
N
N#define SWIP_REG_ADDR_SPECIAL_ACTION             0x1200
N#define SWIP_REG_ADDR_CONTROL_FOR_TUNING         0x1200
N#define SWIP_REG_ADDR_PWMDRV_FOR_TUNING          0x1210
N#define SWIP_REG_ADDR_DRIVER_FOR_TUNING          0x1230
N
N#define SWIP_REG_ADDR_FLASH_IAP_CTRL			 0x1400
N#define SWIP_REG_ADDR_FLASH_IAP_CTRL_CMD		 0x1400
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_STATUS	 	 0x1401
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_SIZE		 0x1402
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_ADDR		 0x1404
N//#define SWIP_REG_ADDR_FLASH_IAP_CTRL_BUFFER		 0x1408
N
N#define SWIP_REG_ADDR_GENERAL_BUFFER             0x2000
N#define SWIP_REG_ADDR_PARAMETER_BUFFER           0x6000
N#define SWIP_REG_ADDR_RESERVED                   0xF000
N
N#endif /* __SWIP_REGMAP_H__ */
L 13 "..\..\Protocol\protocol_swip.h" 2
N#include "protocol_log.h"
L 1 "..\..\Protocol\protocol_log.h" 1
N/****************************************************************************************************//**
N * Copyright (c) 2017 - 2025 SiliconWorks LIMITED
N *
N * file :  protocol_log.h
N * created on :  17. 4. 2017
N * Author :  mhjang
N *
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N * - Redistributions of source code must retain the above copyright
N *   notice, this list of conditions and the following disclaimer.
N *   - Redistributions in binary form must reproduce the above copyright
N *   notice, this list of conditions and the following disclaimer in the
N *   documentation and/or other materials provided with the distribution.
N * - Neither the name of SiW nor the names of its contributors may be used
N *   to endorse or promote products derived from this software without
N *   specific prior written permission.
N * *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************************************/
N
N#ifndef _PROTOCOL_LOG_H_
N#define _PROTOCOL_LOG_H_
N
N
N/*
N * Log Registers
N */
N#define SWIP_LOG_PROTOCOL_ID                     0x0001
N
Ntypedef enum
N{
N    LT_DIAGNOSIS,
N    LT_PRE_RAWDATA,
N    LT_RAWDATA_TXLESS,
N    LT_RAWDATA,
N    LT_INTENSITY,
N    LT_OVERSAMPLE_BUFFER,
N    LT_REFERENCE,
N    LT_FILTERED_INTENSITY,
N    LT_GROUP,
N    LT_FILTERED_GROUP,
N    LT_DELAY,
N    LT_RECAL_INFO,
N    LT_HOVER_INFO,
N    LT_SPLIT_INFO,
N    LT_MERGE_INFO,
N    LT_COORD_INFO,
N    LT_NOISE_INFO,
N    LT_SCREEN_BENDING_INFO,
N    LT_PALM_INFO,
N    LT_GNDNOISE_INFO,
N    LT_STYLUS_INFO,
N    LT_STYLUS_PALM_REJECT_INFO,
N    LT_CONTACT_THRESHOLD_TUNING,
N    LT_DEBUG,
N    LT_DEBUG2,
N    LT_PENPOS_RAWDATA = 25,
N    LT_PENDATA_RAWDATA = 26,
N    LT_PENPOS_INTENSITY = 27,
N    LT_PENDATA_INTENSITY = 28,
N	LT_NI_RAW			 = 29,
N	LT_NI_INT			 = 30,
N    LT_LIMIT
N} eLogType_t;
N
Ntypedef enum
N{
N    LTR_NONE,
N    LTR_TRIG,
N    LTR_WAIT = 255
N} eLogTriggerType_t; // NOTE : warning
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tLogInfo_t;
X} __attribute__ ((packed)) tLogInfo_t;
N
Ntypedef struct
N{
N    uint32_t ulLogMask;
N//    volatile enum
N//    {
N//        LTR_NONE,
N//        LTR_TRIG,
N//        LTR_WAIT = 255
N//    } __PACKED eTrigger; // NOTE : warning
N     __PACKED volatile eLogTriggerType_t eTrigger;
X     __attribute__ ((packed)) volatile eLogTriggerType_t eTrigger;
N} __PACKED tLogControl_t;
X} __attribute__ ((packed)) tLogControl_t;
N
Ntypedef struct
N{
N    uint8_t ucRow_;
N    uint8_t ucCol_;
N    uint8_t ucBufferCol_;
N    tSignedByteDataType_t tDataType;
N    uint8_t ucLogIndex_;
N    struct
N    {
N        uint8_t b6Rightshift_   :6;
N        uint8_t bBitfieldData   :1;
N        uint8_t bIsRotated      :1;
N    } __PACKED tOptions;
X    } __attribute__ ((packed)) tOptions;
N} __PACKED tLogDataFormat_t;
X} __attribute__ ((packed)) tLogDataFormat_t;
N
Ntypedef struct
N{
N    tLogInfo_t* ptInfo;
N    tLogControl_t* ptControl;
N    const tLogDataFormat_t* ptDataFormat;
N} __PACKED tProtocolLog_t;
X} __attribute__ ((packed)) tProtocolLog_t;
N
N/*
N * Image Registers
N */
N#define LOG_IMAGE_PROTOCOL_ID                   0x0001
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tImageInfo_t;
X} __attribute__ ((packed)) tImageInfo_t;
N
Ntypedef enum
N{
N    IT_NONE = 0,
N    IT_RAW_IMAGE,
N    IT_BASELINE_IMAGE,
N    IT_DELTA_IMAGE,
N    IT_LABEL_IMAGE,
N    IT_FILTERED_DELTA_IMAGE,
N    IT_WAIT = 0xFF
N} __PACKED eImageType_t;
X} __attribute__ ((packed)) eImageType_t;
N
Ntypedef struct
N{
N    volatile eImageType_t eImageType;
N} __PACKED tImageControl_t;
X} __attribute__ ((packed)) tImageControl_t;
N
Ntypedef struct
N{
N    uint8_t ucRow_;
N    uint8_t ucCol_;
N    uint8_t ucBufferCol_;
N    bool_t bIsRotated;
N    uint8_t ucKey_;
N    tSignedByteDataType_t tDataType;
N} __PACKED tImageDataFmt_t;
X} __attribute__ ((packed)) tImageDataFmt_t;
N
Ntypedef struct
N{
N    tImageInfo_t* ptInfo;
N    tImageControl_t* ptCtrl;
N    const tImageDataFmt_t* ptFormat;
N    uint8_t* pucFinger_;
N    tRect_t* ptRect;
N} __PACKED tProtocolImage_t;
X} __attribute__ ((packed)) tProtocolImage_t;
N
N#define protocol_LogCode(LogType, Code)    \
N		protocol_Log((LogType),  \
N			&(const tLogDataFormat_t)   \
N		{   \
N			.ucRow_ = 0,    \
N			.ucLogIndex_ = (Code),    \
N		}, (void*)0)
X#define protocol_LogCode(LogType, Code)    		protocol_Log((LogType),  			&(const tLogDataFormat_t)   		{   			.ucRow_ = 0,    			.ucLogIndex_ = (Code),    		}, (void*)0)
N
N// #define protocol_LogVectorRshift(LogType, datanum, data, Code, shift) \
N// 		protocol_Log((LogType),   \
N//             &(const tLogDataFormat_t)   \
N// 		{   \
N// 			.ucRow_ = 1, \
N// 			.ucCol_ = (datanum), \
N// 			.ucBufferCol_ = 1,    \
N// 			.tDataType = datatypeof((data)[0]),  \
N// 			.ucLogIndex_ = (Code), \
N// 			.tOptions = {.bIsRotated = ptMemConf->bSwapXY, .b6Rightshift_ = (shift)},  \
N// 		}, (void*)(data))
X
N
N//#define protocol_LogVector(LogType, datanum, data, Code) \
N//        protocol_LogVectorRshift(LogType, datanum, data, Code, 0)
X
N
N// #define protocol_LogBit(LogType, datanum, data, iRamCol_, row, Code)\
N//         protocol_Log((LogType),   \
N// 				&(const tLogDataFormat_t)   \
N// 		{   \
N// 			.ucRow_ = 1, \
N// 			.ucCol_ = (datanum), \
N// 			.ucBufferCol_ = 1,    \
N// 			.tDataType = datatypeof(data[0]),  \
N// 			.ucLogIndex_ = (Code), \
N// 			.tOptions = {.bIsRotated = ptMemConf->bSwapXY, .bBitfieldData = YES},  \
N// 		}, (void*)(data))
X
N
N#define _protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, bTranspose) \
N		protocol_Log((LogType),   \
N                &(const tLogDataFormat_t)   \
N        {   \
N            .ucRow_ = (row), \
N            .ucCol_ = (datanum), \
N            .ucBufferCol_ = (iRamCol_),    \
N            .tDataType = datatypeof((data)[0]),  \
N            .ucLogIndex_ = (Code), \
N            .tOptions = {.bIsRotated = bTranspose, .b6Rightshift_ = (Shift_)},  \
N        }, (void*)(data))
X#define _protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, bTranspose) 		protocol_Log((LogType),                   &(const tLogDataFormat_t)           {               .ucRow_ = (row),             .ucCol_ = (datanum),             .ucBufferCol_ = (iRamCol_),                .tDataType = datatypeof((data)[0]),              .ucLogIndex_ = (Code),             .tOptions = {.bIsRotated = bTranspose, .b6Rightshift_ = (Shift_)},          }, (void*)(data))
N
N#define protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, NO)
X#define protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, NO)
N
N#define protocol_LogMatrixTranspose(LogType, datanum, data, iRamCol_, row, Code) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, YES)
X#define protocol_LogMatrixTranspose(LogType, datanum, data, iRamCol_, row, Code) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, 0, YES)
N
N#define protocol_LogMatrixRshift(LogType, datanum, data, iRamCol_, row, Code, Shift_) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, NO)
X#define protocol_LogMatrixRshift(LogType, datanum, data, iRamCol_, row, Code, Shift_) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, NO)
N
N#define protocol_LogMatrixRshiftTranspose(LogType, datanum, data, iRamCol_, row, Code, Shift_) \
N		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, YES)
X#define protocol_LogMatrixRshiftTranspose(LogType, datanum, data, iRamCol_, row, Code, Shift_) 		_protocol_LogMatrix(LogType, datanum, data, iRamCol_, row, Code, Shift_, YES)
N
N#define protocol_LogPaddedMatrix(LogType, datanum, data, iRamCol_, row, Code) \
N		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, PAD_, PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
X#define protocol_LogPaddedMatrix(LogType, datanum, data, iRamCol_, row, Code) 		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, PAD_, PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
N
N#define protocol_LogOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) \
N		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_, row_offset, col_offset), iRamCol_, row, Code, 0, NO)
X#define protocol_LogOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) 		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_, row_offset, col_offset), iRamCol_, row, Code, 0, NO)
N
N#define protocol_LogPaddedOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) \
N		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, row_offset + PAD_, col_offset + PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
X#define protocol_LogPaddedOffsetMatrix(LogType, datanum, data, iRamCol_, row, col_offset, row_offset, Code) 		_protocol_LogMatrix(LogType, datanum, &ACCESS_MATRIX(data, iRamCol_ + 2*PAD_, row_offset + PAD_, col_offset + PAD_), iRamCol_ + 2*PAD_, row, Code, 0, NO)
N
N  
N
N 
Ntypedef struct
N{
N uint16_t VALUE[92][2];
N} __PACKED tDRIVERSetting_t;
X} __attribute__ ((packed)) tDRIVERSetting_t;
N 
Ntypedef enum
N{
N    SW9502_REG_ADDR_MDIDLE = 0,     // MdIdle   0
N    SW9502_REG_ADDR_SNRSTR,         // SnrStr   2
N    SW9502_REG_ADDR_MDGNRL,         // MdGnrl   4
N    SW9502_REG_ADDR_AIPADC,         // AipAdc   6
N    SW9502_REG_ADDR_SSUCTRL,        // SsuCtrl  8
N    SW9502_REG_ADDR_TSYNCNUM0,      // TsyncNum0 10
N    SW9502_REG_ADDR_TSYNCNUM1,      // TsyncNum1 12
N    SW9502_REG_ADDR_TSYNCDMY1,      // TsyncDmy1 14
N    SW9502_REG_ADDR_PWMNUM0,        // PwmNum0   16
N    SW9502_REG_ADDR_PWMNUM1,        // PwmNum1   18
N    SW9502_REG_ADDR_CMUXNRM,        // CmuxNrm   20
N    SW9502_REG_ADDR_CMUXNSE,        // CmuxNse   22
N    SW9502_REG_ADDR_COLNUM,         // ColNum    24
N    SW9502_REG_ADDR_ROWNUM,         // RowNum    26
N    SW9502_REG_ADDR_DIGGAIN0,       // DigGain0  28
N    SW9502_REG_ADDR_DIGGAIN1,       // DigGain1  30
N    SW9502_REG_ADDR_NIHMIN0,        // NihMin0   32
N    SW9502_REG_ADDR_NIHMAX0,        // NihMax0   34
N    SW9502_REG_ADDR_NIHMIN1,        // NihMin1   36
N    SW9502_REG_ADDR_NIHMAX1,        // NihMax1   38
N    SW9502_REG_ADDR_NIHMIN2,        // NihMin2   40
N    SW9502_REG_ADDR_NIHMAX2,        // NihMax2   42
N    SW9502_REG_ADDR_NIHMIN3,        // NihMin3   44
N    SW9502_REG_ADDR_NIHMAX3,        // NihMax3   46
N    SW9502_REG_ADDR_NIHRDAT0,       // NihRdat0  48
N    SW9502_REG_ADDR_NIHRDAT1,       // NihRdat1  50
N    SW9502_REG_ADDR_NIHRDAT2,       // NihRdat2  52
N    SW9502_REG_ADDR_NIHRDAT3,       // NihRdat3  54
N    SW9502_REG_ADDR_MDSPCL,         // MdSpcl    56
N    SW9502_REG_ADDR_SHASTR0,        // ShaStr0   58
N    SW9502_REG_ADDR_SHASTR1,        // ShaStr1   60
N    SW9502_REG_ADDR_SHASTR2,        // ShaStr2   62
N    SW9502_REG_ADDR_VCRSTR,         // VcrStr    64
N    SW9502_REG_ADDR_VCRNUM0,        // VcrNum0   66
N    SW9502_REG_ADDR_VCRNUM1,        // VcrNum1   68
N    SW9502_REG_ADDR_VCRNUM2,        // VcrNum2   70
N    SW9502_REG_ADDR_VCRNUM3,        // VcrNum3   72
N    SW9502_REG_ADDR_VCRNUM4,        // VcrNum4   74
N    SW9502_REG_ADDR_VCRNUM5,        // VcrNum5   76
N    SW9502_REG_ADDR_RESERVED0,      // 78
N    SW9502_REG_ADDR_RESERVED1,      // 80
N    SW9502_REG_ADDR_RESERVED2,      // 82
N    SW9502_REG_ADDR_RESERVED3,      // 84
N    SW9502_REG_ADDR_RESERVED4,      // 86
N    SW9502_REG_ADDR_RESERVED5,      // 88
N    SW9502_REG_ADDR_RESERVED6,      // 90
N    SW9502_REG_ADDR_MAX
N} eSW9502_RegMap_t;
N
Ntypedef struct
N{
N uint16_t TSYNC_NUM;
N uint16_t LINE_NUM;
N uint16_t INTV_PERIOD;
N uint16_t OFFSET0_PERIOD;
N uint16_t OFFSET1_PERIOD;
N uint16_t OFFSET2_PERIOD;
N uint16_t PRE_NUM;
N uint16_t PRE_LOW;
N uint16_t PRE_PERIOD;
N uint16_t PRE_ITV_PERIOD;
N uint16_t F0_ACT0_NUM;
N uint16_t F0_ACT1_NUM;
N uint16_t F0_ACT_LOW;
N uint16_t F0_ACT_PERIOD;
N uint16_t F1_ACT_PERIOD;
N uint16_t F1_ACT_LOW;
N uint16_t F2_ACT_PERIOD;
N uint16_t F2_ACT_LOW;
N uint16_t F1_ACT_NUM;
N uint16_t F2_ACT_NUM;
N uint16_t F1_LINE_NUM;
N uint16_t F2_LINE_NUM;
N} __PACKED tPWMDRVSetting_t;
X} __attribute__ ((packed)) tPWMDRVSetting_t;
N
N
Nextern tProtocolImage_t tProtocolImage;
Nextern tProtocolLog_t tProtocolLog;
N
Nextern void protocol_Log(eLogType_t eLogType, const tLogDataFormat_t* _ptDataFormat, const void* _pBuf);
Nextern void protocol_LogImage(eImageType_t _type, const tImageDataFmt_t* _ptDataFormat, uint8_t ucFinger_, tRect_t rect[ucFinger_], const void* _pBuf);
Nextern uint32_t protocol_log_get_mode(void);
Nextern void protocol_log_set_mode(eLogTriggerType_t _m);
N
N
N#endif /* _PROTOCOL_LOG_H_ */
L 14 "..\..\Protocol\protocol_swip.h" 2
N#include "protocol.h"
N
N
N
N/*
N * Information Registers
N */
N#define PRODUCT_NAME_                       16
N#define TEST_DEVICE_READ_PACKED             0x0030//0x0042
N
Ntypedef struct
N{
N    char vcProductName[PRODUCT_NAME_];
X    char vcProductName[16];
N    uint16_t usXResolution;
N    uint16_t usYResolution;
N    uint8_t ucXNode_;
N    uint8_t ucYNode_;
N} __PACKED tSWIPPanel_t;
X} __attribute__ ((packed)) tSWIPPanel_t;
N
Ntypedef struct
N{
N    uint16_t bcdBootVer;
N    uint16_t bcdCoreVer;
N    uint16_t bcdAppVer;
N    uint16_t bcdParaVer;
N} __PACKED tSWIPFirmwareSectionVersion_t;
X} __attribute__ ((packed)) tSWIPFirmwareSectionVersion_t;
N
Ntypedef struct
N{
N    uint8_t ucBootStartAddr;
N    uint8_t ucBootEndAddr;
N    uint8_t ucAppStartAddr;
N    uint8_t ucAppEndAddr;
N    uint8_t ucParamlStartAddr;
N    uint8_t ucParamlEndAddr;
N} __PACKED tSWIPFirmwareSectionAddress_t;
X} __attribute__ ((packed)) tSWIPFirmwareSectionAddress_t;
N
Ntypedef struct
N{
N//	uint32_t ulBootCRC;
N//	uint32_t ulAppCRC;
N//	uint32_t ulParamCRC;
N	uint8_t usCalculateCRC1;
N	uint8_t usCalculateCRC2;
N	uint8_t usCalculateCRC3;
N	uint8_t usCalculateCRC4;
N
N} __PACKED tSWIPFirmwareIntegrity_t;
X} __attribute__ ((packed)) tSWIPFirmwareIntegrity_t;
N
N#define PROTOCOL_NAME_                       8
N
Ntypedef struct
N{
N    char vcProtocolName[PROTOCOL_NAME_];
X    char vcProtocolName[8];
N    uint16_t bcdProtocolVersion;
N	uint16_t I2C_VID;
N	uint16_t I2C_PID;
N} __PACKED tSWIPInterface_t;
X} __attribute__ ((packed)) tSWIPInterface_t;
N
Ntypedef struct
N{
N	uint16_t usPWMTxFrequecy;
N} __PACKED tSWIPExtra_t;
X} __attribute__ ((packed)) tSWIPExtra_t;
N
Ntypedef struct
N{
N	uint16_t ulTrimCode[14];
N	uint32_t ulTrimCRC;
N} __PACKED tSWIPTrimCode_t;
X} __attribute__ ((packed)) tSWIPTrimCode_t;
N
Ntypedef struct
N{
N	tSWIPTrimCode_t tTrimCode_1Set;
N	tSWIPTrimCode_t tTrimCode_2Set;
N} __PACKED tSWIPTrimCodeSet_t;
X} __attribute__ ((packed)) tSWIPTrimCodeSet_t;
N
N/*
N * Event Registers
N */
Ntypedef enum
N{
N    PF_NORMAL = 0,
N    PF_ANGLE_WITHOUT_STRENGTH = 1,
N    PF_SNR_MODE = 2,
N    PF_LIMIT,
N    PF_FOR_SIZEFIX = 0xFFFF,
N} __PACKED eSWIPPacketFormatId_t;
X} __attribute__ ((packed)) eSWIPPacketFormatId_t;
N
Ntypedef struct
N{
N    uint32_t reserved;
N    eSWIPPacketFormatId_t ePacketFormatId;
N    uint8_t ucTouchPacketItemSize;
N} __PACKED tSWIPEventFormat_t;
X} __attribute__ ((packed)) tSWIPEventFormat_t;
N
Ntypedef struct
N{
N    struct
N    {
N        uint8_t b4FingerID :4;
N        uint8_t bPalm :1;
N        uint8_t bHover :1;
N        uint8_t bScreen :1;
N        uint8_t bTouch :1;
N    } __PACKED tInfo;
X    } __attribute__ ((packed)) tInfo;
N    uint8_t ucXHigh;
N    uint8_t ucYHigh;
N    uint8_t ucXLow;
N    uint8_t ucYLow;
N    uint8_t ucWidth;
N    uint16_t usStrength;
N	uint8_t  ucRowStart;
N} __PACKED tSWIPTouchItem00_t;
X} __attribute__ ((packed)) tSWIPTouchItem00_t;
N
Ntypedef struct
N{
N	struct
N	{
N		uint8_t b4FingerID  :4;
N		uint8_t bPalm       :1;
N		uint8_t bHover      :1;
N		uint8_t bScreen     :1;
N		uint8_t bTouch      :1;
N	} __PACKED tInfo;
X	} __attribute__ ((packed)) tInfo;
N	uint8_t ucXHigh;
N	uint8_t ucYHigh;
N	uint8_t ucXLow;
N	uint8_t ucYLow;
N	uint8_t ucWidth;
N	int8_t cAngle;
N	uint8_t ucMajorLength;
N	uint8_t ucMinorLength;
N} __PACKED tSWIPTouchItem01_t;
X} __attribute__ ((packed)) tSWIPTouchItem01_t;
N
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S/*
S * @ TouchItem02
S *
S * SW42102 - Only Use Sharp protocol Format
S *
S * */
Stypedef enum {
S	TOUCH_STATUS_RELEASE = 0,
S	TOUCH_STATUS_PRESS,
S	TOUCH_STATUS_REMAIN,
S	TOUCH_STATUS_MOVE,
S	TOUCH_STATUS_LIMIT
S} eTouchItemInfo;
S
Stypedef enum {
S	TOUCH_TYPE_FINGER = 0,
S	TOUCH_TYPE_GLOVE,
S	TOUCH_TYPE_HOVER,
S	TOUCH_TYPE_PASSIVE_STYLUS,
S	TOUCH_TYPE_ACTIVE_STYLUS,
S	TOUCH_TYPE_ACTIVE_STYLUS_HOVER
S} eTouchItemStatus;
S
Stypedef struct {
S	uint8_t finger;
S	uint8_t glove;
S	uint8_t hover;
S	uint8_t passive_stylus;
S	uint8_t active_stylus;
S	uint8_t active_stylus_hover;
S} tTouchItemType_t;
S
Stypedef struct
S{
S	struct
S	{
S		uint8_t b4FingerID 		:4;
S		uint8_t b1Status		:1;
S		uint8_t b6Type			:6;
S		uint8_t b4Reserved		:5;
S	} __PACKED tInfo;	// 2byte
S    uint8_t ucXHigh;
S    uint8_t ucYHigh;
S    uint8_t ucXLow;
S    uint8_t ucYLow;
S    uint8_t ucWidth;
S    uint16_t usStrength;
S    uint8_t  ucRowStart;
S} __PACKED tSWIPTouchItem02_t;
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N
Ntypedef union
N{
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S	tSWIPTouchItem02_t tItem00;
N#else /* USED_SHARP_SPECIFIC_PROTOCOL */
N	tSWIPTouchItem00_t tItem00;
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N    tSWIPTouchItem01_t tItem01;		
N} uSWIPTouchItem_t;
N
N
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S
S//typedef union
S//{
S//    struct
S//    {
S//        unsigned wakeUpType    :  8;
S//        unsigned touch_cnt     :  5;
S//        unsigned buttonCnt     :  3;
S//        unsigned palmBit       : 16;
S//    } b;
S//} tTouchInfo_t;
S//
S//typedef struct
S//{
S//    unsigned tool_type   : 4;
S//    unsigned event       : 4;
S//    unsigned track_id    : 8;
S//    unsigned x           : 16;
S//    unsigned y           : 16;
S//    unsigned pressure    : 8;
S//    unsigned angle       : 8;
S//    unsigned width_major : 16;
S//    unsigned width_minor : 16;
S//} tTouchData_t;
S
Stypedef struct
S{
S	uint32_t ulDummy[2];
S	struct
S	{
S		unsigned wakeUpType    :  8;
S		unsigned touch_cnt     :  8;
S		unsigned palmBit       : 16;
S	} __PACKED tTouchinfo;
S
S	struct
S	{
S	    unsigned event       : 4;
S	    unsigned tool_type   : 4;
S	    unsigned track_id    : 8;
S	    unsigned x           : 16;
S	    unsigned y           : 16;
S	    unsigned pressure    : 8;
S	    unsigned angle       : 8;
S	    unsigned width_major : 16;
S	    unsigned width_minor : 16;
S	} __PACKED tTouchData[MAX_TOUCH_];
S//    tTouchInfo_t tTouchinfo;
S//    tTouchData_t tTouchData[MAX_TOUCH_];
S	uint8_t   ucContactCnt;
S	uint16_t  RowStart;
S} __PACKED tSWIPPacketInfo_t;
S
N#else /* USED_MOBILE_I2C_PROTOCOL */
Ntypedef struct
N{
N	uint16_t ReportSize;
N	uint8_t  ReportID;
N	
N	struct
N	{
N		uint8_t  Status;
N		uint8_t  ID;
N		uint16_t ucX;
N		uint16_t ucY;
N	} __PACKED tTouchInfo[MAX_TOUCH_];
X	} __attribute__ ((packed)) tTouchInfo[(10)];
N
N	uint8_t   ucContactCnt;
N	uint16_t  RowStart;
N} __PACKED tSWIPPacketInfo_t;
X} __attribute__ ((packed)) tSWIPPacketInfo_t;
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
Stypedef struct
S{
S		unsigned  running_sts        : 5;	
S		unsigned  device_checked_sts : 1;
S		unsigned  code_valid         : 1;
S		unsigned  cfg_valid          : 1;//10
S		unsigned  font_valid         : 1;
S		unsigned  abnormal_sts       : 1;
S		unsigned  esd_error_sts      : 1;
S		unsigned  reserved0          : 2;	
S		unsigned  disp_mode_mismatch : 1;		
S		unsigned  reserved1          : 1;			
S		unsigned  interrupt_sts      : 1;//10	
S		unsigned  interrupt_type     : 4;//10	
S		unsigned  touch_int_en_sts   : 1;
S		unsigned  dwatch_int_en_sts  : 1;			
S		unsigned  tc_drv_valid       : 1;		
S		unsigned  tc_cfg_load_type   : 2;
S		unsigned  dic_disp_sts       : 2;
S		unsigned  model_id_load_flag : 1;
S		unsigned  pt_info_error      : 1;
S		unsigned  reserved2          : 3;
S} __PACKED t_tc_status;
S
S
S	
Stypedef struct
S{
S		unsigned wakeUpType    :  8;
S		unsigned touch_cnt     :  5;
S		unsigned buttonCnt     :  3;
S		unsigned palmBit       : 16;
S} __PACKED tTouchInfo_t;
S
Stypedef struct
S{
S    unsigned tool_type   : 4;
S    unsigned event       : 4;
S    unsigned track_id    : 8;
S    unsigned x           : 16;
S    unsigned y           : 16;
S    unsigned pressure    : 8;
S    unsigned angle       : 8;
S    unsigned width_major : 16;
S    unsigned width_minor : 16;
S} __PACKED tTouchData_t;
S
Stypedef struct
S{    
S    uint32_t       _ic_status;
S  	t_tc_status    _tc_status;		
S    tTouchInfo_t   _info;
S		tTouchData_t   _data[10];
S}tAndroidDevInfo_t;
S
S
Stypedef struct
S{
S    uint32_t*     ic_status;
S    t_tc_status*  tc_status;
S    tTouchInfo_t* info;
S    tTouchData_t* data;
S} __PACKED tReportPacket_t;
S
N#endif
N
N
N//static __inline__ int protocol_swip_GetPacketSize(eSWIPPacketFormatId_t id)
N//{
N//    return ((int [])
N//    {
N//        sizeof(tSWIPTouchItem00_t), sizeof(tSWIPTouchItem01_t)
N//    })[id];
N//}
N
N//static __inline__ int protocol_swip_GetFormattedStr(char* p, eSWIPPacketFormatId_t id)
N//{
N//    // charactor 8.
N//    switch( id )
N//    {
N//        case PF_NORMAL:
N//        {
N//            const char fmt[] = "[%2d]={%4d,%4d,%3d,%4d},";
N//            strcpy(p, fmt);
N//            return 26;
N//        }
N//        case PF_ANGLE_WITHOUT_STRENGTH:
N//        {
N//            const char fmt[] = "[%2d]={%4d,%4d,%3d,%3d,%3d,%3d},";
N//            strcpy(p, fmt);
N//            return 31;
N//        }
N//    }
N//    return 0; //NOTE : warning... 0     !!
N//}
N
N
Ntypedef enum
N{
N    GT_NONE
N} eSWIPGestureType_t;
N
Ntypedef struct
N{
N    enum
N    {
N        NT_NONE = 0,
N        NT_ESD,
N        NT_WAKEUP_GESTURE_DETECTED
N    } eNotificationType;
N    union
N    {
N        struct
N        {
N            uint8_t ucFrameCnt;
N        } __PACKED tESDAlertPacket;
X        } __attribute__ ((packed)) tESDAlertPacket;
N        struct
N        {
N            eSWIPGestureType_t eGestureType;
N        } __PACKED tWakeupGestureAlertPacket;
X        } __attribute__ ((packed)) tWakeupGestureAlertPacket;
N    } __PACKED uData;
X    } __attribute__ ((packed)) uData;
N} __PACKED tSWIPAlertPacket_t;
X} __attribute__ ((packed)) tSWIPAlertPacket_t;
N
N/*
N * Parameter Mode Registers
N */
N#define SWIP_PARAMETER_PROTOCOL_ID               0x0001
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tSWIPParameterInfo_t;
X} __attribute__ ((packed)) tSWIPParameterInfo_t;
N
N/*
N * Cm Test Mode Registers
N */
N#define SWIP_TEST_PROTOCOL_ID                 	0x0001
N
Ntypedef struct
N{
N    uint16_t usBufferAddr;
N    uint16_t usProtocolId;
N} __PACKED tSWIPTestInfo_t;
X} __attribute__ ((packed)) tSWIPTestInfo_t;
N
N#if USED_MNT_USB_CUSTOM_PROTOCOL
X#if ((1==0))
Stypedef enum
S{
S    CTT_RESERVED0	= 0,
S	CTT_RESERVED1	= 1,
S	CTT_ABS			= 2,
S	CTT_JITTER		= 3,
S	CTT_SHORT		= 4,
S	CTT_CRC_CHECK	= 5,
S	CTT_NONE		= 0xFF,
S} __PACKED eSWIPTestType_t;
N#else
Ntypedef enum
N{
N    CTT_RESERVED	= 0,
N    CTT_ABS			= 1,
N	CTT_JITTER		= 2,
N	CTT_ABS_DIFF	= 3,
N	CTT_DC_ABS		= 4,
N	CTT_CRC_CHECK	= 5,
N	CTT_EVENODD_SHORT		= 6,
N	CTT_OPEN_SHORT	= 7,
N	CTT_NONE		= 0xFF,
N} __PACKED eSWIPTestType_t;
X} __attribute__ ((packed)) eSWIPTestType_t;
N#endif
N
Ntypedef struct
N{
N    volatile eSWIPTestType_t eTestType;
N    volatile uint8_t ucABSDiffCount;
N	volatile uint8_t ucABSCount;
N	volatile uint8_t ucDCABSCount;
N	volatile uint8_t ucJitterAVGCount;
N	volatile uint8_t ucJitterMAXCount;
N	volatile uint32_t lCRCValue;
N} __attribute__ ((packed)) tSWIPTestControl_t;
N
Ntypedef struct
N{
N    uint8_t ucRow_;
N    uint8_t ucCol_;
N    uint8_t ucBufferCol_;
N    bool_t bIsRotated;
N    uint8_t ucKey_;
N    tSignedByteDataType_t tDataType;
N} __PACKED tSWIPTestDataFmt_t;
X} __attribute__ ((packed)) tSWIPTestDataFmt_t;
N
Ntypedef struct
N{
N    struct
N    {
N        tSWIPTestInfo_t* ptInfo;
N        tSWIPTestControl_t* ptCtrl;
N        const tSWIPTestDataFmt_t* ptFormat;
N    } __PACKED  tTest;
X    } __attribute__ ((packed))  tTest;
N} __PACKED tSWIPTest_t;
X} __attribute__ ((packed)) tSWIPTest_t;
N
Ntypedef struct
N{
N    bool_t bGNDNoiseStatus;
N    bool_t bLCDNoiseStatus;
N    uint8_t ucOscVal;
N
N    bool_t bReadModuleConfig;
N} __PACKED tSWIPControlForTuning_t;
X} __attribute__ ((packed)) tSWIPControlForTuning_t;
N
Ntypedef struct
N{
N    tSWIPPanel_t* ptPanel;
N    tSWIPFirmwareSectionVersion_t* ptVersion;
N    tSWIPFirmwareSectionAddress_t* ptSectionAddress;
N    tSWIPFirmwareIntegrity_t* ptIntegrity;
N    tSWIPInterface_t* ptInterface;
N    tSWIPExtra_t* ptExtra;
N    tSWIPTrimCodeSet_t* ptTrimCode;
N
N} __PACKED tSWIPInfo_t;
X} __attribute__ ((packed)) tSWIPInfo_t;
N
N#if defined(SUPPORT_ANDROID)
X#if 0L
Stypedef struct  
S{
S		uint8_t minor;
S		uint8_t major:4;
S		uint8_t build:4;
S		uint8_t chip;
S		uint8_t protocol:4;
S		uint8_t rsvd;
S} __PACKED tc_version_t;
S
Stypedef struct  
S{
S		uint16_t boot;
S		uint16_t core;
S} __PACKED chip_version_t;
S
S
Stypedef struct
S{
S    u4byteString_t*    ptSprChipID;
S    tc_version_t*      ptTcVersion;
S    chip_version_t*    ptChipVersion;
S    u8byteString_t*    ptTcProductId;
S} __PACKED tSWIPAndroidBaseInfo_t;
S
Stypedef struct
S{
S    uint32_t*          ptSprChipTest;    //0x400
S		uint32_t* 				 ptSprBootSts;     //0x401
S		uint32_t* 				 ptTcDeviceCtl;    //0x402
S		uint32_t* 				 ptTcInterruptCtl; //0x403
S		uint32_t* 				 ptImeState;       //0x404
S		uint32_t* 				 ptTciEnableW;     //0x405
S		uint32_t* 				 ptSwipeEnableW;   //0x406
S		uint32_t* 				 ptSprSubDispSts;  //0x407
S		uint32_t* 				 ptTcDriveCtl;     //0x408
S} __PACKED tSWIPAndroidSprChipInfo_t;
N#endif
N
N
Ntypedef struct
N{
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S//    tSWIPEventFormat_t* ptEventFormat;
S    tSWIPPacketInfo_t* ptPacketInfo;
N#else /* USED_MOBILE_I2C_PROTOCOL */
N    tSWIPEventFormat_t* ptEventFormat;
N    tSWIPPacketInfo_t* ptPacketInfo;
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N} __PACKED tSWIPEvent_t;
X} __attribute__ ((packed)) tSWIPEvent_t;
N
Ntypedef struct
N{
N    tSWIPControlForTuning_t* ptControlForTuning;
N    tPWMDRVSetting_t*        ptPWMDRVParam;
N    tDRIVERSetting_t*        ptROICParam;
N} __PACKED tSWIPSpecialAction_t;
X} __attribute__ ((packed)) tSWIPSpecialAction_t;
N
Ntypedef struct
N{
N    tSWIPParameterInfo_t* ptInfo;
N} __PACKED tSWIPParameter_t;
X} __attribute__ ((packed)) tSWIPParameter_t;
N
Ntypedef struct
N{
N    uint8_t** ppucBuffer;
N    uint16_t* vusStartAddr;
N    int iSize;
N} __PACKED tSWIPBufferInfo_t;
X} __attribute__ ((packed)) tSWIPBufferInfo_t;
N
Ntypedef struct
N{
N    uint8_t** ppucData;//Pointer of array of pointers.
N    uint8_t* vucStartLAddr;
N    int iSize;
N} __PACKED tSWIPSubsetInfo_t;
X} __attribute__ ((packed)) tSWIPSubsetInfo_t;
N
N/*
N * Interfaces
N */
N
N/* Define Functions */
N
Nextern void protocol_swip_Init(void);
Nextern eProtocolMode_t protocol_swip_GetMode(void);
Nextern void protocol_swip_SetMode(eProtocolMode_t _eMode);
N
Nextern bool_t protocol_swip_GetRecalibrate(void);
Nextern void protocol_swip_SetRecalibrate(bool_t _bRecalibrate);
Nextern ePowerConsumptionState_t protocol_swip_GetPowerConsumptionState(void);
Nextern void protocol_swip_SetPowerConsumptionState(ePowerConsumptionState_t _eState);
Nextern uint32_t protocol_swip_GetGestureType(void);
Nextern void protocol_swip_SetGestureType(uint32_t _ulGestureType);
Nextern bool_t protocol_swip_GetDisableESDAlert(void);
Nextern void protocol_swip_SetDiableESDAlert(bool_t _bVal);
Nextern bool_t protocol_swip_GetChargerAttached(void);
Nextern void protocol_swip_SetChargetAttached(bool_t _bVal);
Nextern bool_t protocol_swip_GetSensingOnWindowEnable(void);
Nextern void protocol_swip_SetSensingOnWindowEnable(bool_t _bVal);
Nextern bool_t protocol_swip_GetGloveSensingEnable(void);
Nextern void protocol_swip_SetGloveSensingEnable(bool_t _bVal);
Nextern bool_t protocol_swip_GetPalmRejectionEnable(void);
Nextern void protocol_swip_SetPalmRejectionEnable(bool_t _bVal);
Nextern bool_t protocol_swip_GetDisableEdgeExpand(void);
Nextern void protocol_swip_SetDisableEdgeExpand(bool_t _bVal);
Nextern uint8_t protocol_swip_GetABSDiffCount(void);
Nextern uint8_t protocol_swip_GetABSCount(void);
Nextern uint8_t protocol_swip_GetDCABSCount(void);
Nextern uint8_t protocol_swip_GetJitterAVGCount(void);
Nextern uint8_t protocol_swip_GetJitterMAXCount(void);
N//extern uint32_t protocol_swip_GetCRCValue(void);
N//extern void protocol_swip_SetCRCValue(uint32_t _lCRCValue);
Nextern void protocol_swip_PendReadyStatus(void);
Nextern void protocol_swip_PendReadyStatusCustom(eProtocolReadyStatus_t data); // NOTE : warning
Nextern void protocol_swip_SetParameterBuffer(void* p);
Nextern void protocol_swip_SetTestType(eSWIPTestType_t _t);
Nextern eSWIPTestType_t protocol_swip_GetTestType(void);
Nextern void protocol_swip_PendTestResult(const tSWIPTestDataFmt_t* _ptDataFormat, const void* _pBuf);
Nextern eSWIPPacketFormatId_t protocol_swip_GetPacketFormatId(void);
Nextern void protocol_swip_InitTouchEventBuffer(void);
Nextern void protocol_swip_PushTouchEvent(const uSWIPTouchItem_t* _kptItem);
Nextern void protocol_swip_SendTouchEvent(void);
Nextern void protocol_swip_SendPenEvent(void);
N#if defined(SUPPORT_ANDROID)
X#if 0L
Sextern void protocol_Android_PushTouchEvent(const uSWIPTouchItem_t* _kptItem);
N#endif
N
Nextern bool_t protocol_swip_GetGNDNoiseHandlingStatus(void);
Nextern void protocol_swip_SetGNDNoiseHandlingStatus(bool_t _bStatus);
Nextern bool_t protocol_swip_GetLCDNoiseHandlingStatus(void);
Nextern void protocol_swip_SetLCDNoiseHandlingStatus(bool_t _bStatus);
Nextern uint8_t protocol_swip_GetOscVal(void);
Nextern void protocol_swip_SetOscVal(uint8_t oscval);
Nextern bool_t protocol_swip_GetReadModuleConfigStatus(void);
Nextern void protocol_swip_SetReadModuleConfigStatus(bool_t _bStatus);
N
Nextern uint8_t* protocol_swip_GetMappedPointer(uint16_t _addr);
Nextern void protocol_swip_ClearInterrupt(uint16_t _addr);
Nextern bool_t protocol_swip_GetEventIntrType(void);
N#if defined(SUPPORT_ANDROID)
X#if 0L
Sextern bool_t protocol_android_SetEventIntrType(void);
Sextern bool_t protocol_android_SetDevCtlSts(void);
N#endif
N#endif /* __PROTOCOL_SWIP_H__ */
L 45 "..\..\Protocol\protocol_def.h" 2
N#include "protocol_dfup.h"
L 1 "..\..\Protocol\protocol_dfup.h" 1
N/*
N * protocol_dfup.h
N *
N *  Created on: 2015. 4. 30.
N *      Author: parkyj2
N */
N
N#ifndef __PROTOCOL_DFUP_H__
N#define __PROTOCOL_DFUP_H__
N
N#include "protocol_dfup_regmap.h"
L 1 "..\..\Protocol\protocol_dfup_regmap.h" 1
N/*
N * mip4d0.h
N *
N *  Created on: 2015. 3. 16.
N *      Author: parkyj2
N */
N
N#ifndef __DFUP_REGMAP_H__
N#define __DFUP_REGMAP_H__
N
N#define SWIP_REG_ADDR_INFO                       0x0100
N#define SWIP_REG_ADDR_INFO_PANEL                 0x0100
N#define SWIP_REG_ADDR_INFO_SECTION_VERSION       0x0120
N#define SWIP_REG_ADDR_INFO_SECTION_ADDR          0x0130
N#define SWIP_REG_ADDR_INFO_INTEGRITY             0x0140
N#define SWIP_REG_ADDR_INFO_INTERFACE             0x0150
N#define SWIP_REG_ADDR_INFO_EXTRA                 0x0170
N#define SWIP_REG_ADDR_INFO_TRIMCODE_1            0x01A0
N#define SWIP_REG_ADDR_INFO_TRIMCODE_2            0x01C0
N
N#define SWIP_REG_ADDR_EVENT                      0x0200
N#if USED_MOBILE_I2C_PROTOCOL
X#if ((1==0))
S//#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0200
S//#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
S#define SWIP_REG_ADDR_EVENT_PACKET_FORMAT	     0x0200
S#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0208
S#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x020C
N#else /* USED_MOBILE_I2C_PROTOCOL */
N#define SWIP_REG_ADDR_EVENT_FORMAT               0x0200
N#define SWIP_REG_ADDR_EVENT_PACKET_INFO          0x0210
N#define SWIP_REG_ADDR_EVENT_PACKET_CONTENT       0x0211
N#endif /* USED_MOBILE_I2C_PROTOCOL */
N
N#define DFUP_REG_ADDR_FLASH_CTRL			 	 0x0300
N#define DFUP_REG_ADDR_FLASH_CTRL_CMD			 0x0300
N#define DFUP_REG_ADDR_FLASH_CTRL_STATUS 		 0x0310
N
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL			 0x1400
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_CMD		 0x1400
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_STATUS	 	 0x1401
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_SIZE		 0x1402
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_ADDR		 0x1404
N#define DFUP_REG_ADDR_FLASH_IAP_CTRL_BUFFER		 0x1408
N
N#define SWIP_REG_ADDR_CTRL                       0x0600
N#define SWIP_REG_ADDR_CTRL_GETTER                0x0600
N#define SWIP_REG_ADDR_CTRL_SETTER                0x0610
N
N#define SWIP_REG_ADDR_PARAMETER                  0x0800
N#define SWIP_REG_ADDR_PARAMETER_INFO             0x0800
N#define SWIP_REG_ADDR_PARAMETER_CONTROL          0x0810
N
N#define SWIP_REG_ADDR_TEST                       0x0A00
N#define SWIP_REG_ADDR_TEST_CM_INFO               0x0A00
N#define SWIP_REG_ADDR_TEST_CM_CONTROL            0x0A10
N#define SWIP_REG_ADDR_TEST_CM_DATA_FORMAT        0x0A20
N
N#define SWIP_REG_ADDR_IMAGE                      0x0C00
N#define SWIP_REG_ADDR_IMAGE_INFO                 0x0C00
N#define SWIP_REG_ADDR_IMAGE_CONTROL              0x0C10
N#define SWIP_REG_ADDR_IMAGE_DATA_FORMAT          0x0C20
N#define SWIP_REG_ADDR_IMAGE_FINGER_NUM           0x0C30
N#define SWIP_REG_ADDR_IMAGE_FINGER_AREA          0x0C31
N
N#define SWIP_REG_ADDR_LOG                        0x1000
N#define SWIP_REG_ADDR_LOG_INFO                   0x1000
N#define SWIP_REG_ADDR_LOG_CONTROL                0x1010
N#define SWIP_REG_ADDR_LOG_DATA_FORMAT            0x1020
N
N#define SWIP_REG_ADDR_SPECIAL_ACTION             0x1200
N#define SWIP_REG_ADDR_CONTROL_FOR_TUNING         0x1200
N
N#define SWIP_REG_ADDR_GENERAL_BUFFER             0x2000
N#define SWIP_REG_ADDR_PARAMETER_BUFFER           0x6000
N#define SWIP_REG_ADDR_RESERVED                   0xF000
N
N#endif /* __SWIP_REGMAP_H__ */
L 12 "..\..\Protocol\protocol_dfup.h" 2
N
N/*
N * Control Registers
N */
N
N#define PROTOCOL_NAME_                       8
N
Ntypedef struct
N{
N    uint16_t bcdBootVer;
N    uint16_t bcdCoreVer;
N    uint16_t bcdAppVer;
N    uint16_t bcdParaVer;
N} __PACKED tDFUPFirmwareSectionVersion_t;
X} __attribute__ ((packed)) tDFUPFirmwareSectionVersion_t;
N
Ntypedef struct
N{
N    uint8_t ucBootStartAddr;
N    uint8_t ucBootEndAddr;
N    uint8_t ucAppStartAddr;
N    uint8_t ucAppEndAddr;
N    uint8_t ucParamlStartAddr;
N    uint8_t ucParamlEndAddr;
N} __PACKED tDFUPFirmwareSectionAddress_t;
X} __attribute__ ((packed)) tDFUPFirmwareSectionAddress_t;
N
Ntypedef struct
N{
N	uint32_t ulBootCRC;
N	uint32_t ulAppCRC;
N	uint32_t ulParamCRC;
N} __PACKED tDFUPFirmwareIntegrity_t;
X} __attribute__ ((packed)) tDFUPFirmwareIntegrity_t;
N
Ntypedef struct
N{
N    char vcProtocolName[PROTOCOL_NAME_];
X    char vcProtocolName[8];
N    uint16_t bcdProtocolVersion;
N    uint16_t I2C_VID;
N    uint16_t I2C_PID;
N} __PACKED tDFUPInterface_t;
X} __attribute__ ((packed)) tDFUPInterface_t;
N
Ntypedef struct
N{
N	uint16_t ulTrimCode[14];
N	uint32_t ulTrimCRC;
N} __PACKED tDFUPTrimCode_t;
X} __attribute__ ((packed)) tDFUPTrimCode_t;
N
Ntypedef struct
N{
N	tDFUPTrimCode_t tTrimCode_1Set;
N	tDFUPTrimCode_t tTrimCode_2Set;
N} __PACKED tDFUPTrimCodeSet_t;
X} __attribute__ ((packed)) tDFUPTrimCodeSet_t;
N
Ntypedef struct
N{
N	tDFUPFirmwareSectionVersion_t* ptVersion;
N	tDFUPFirmwareSectionAddress_t* ptSectionAddress;
N	tDFUPFirmwareIntegrity_t* ptIntegrity;
N    tDFUPInterface_t* ptInterface;
N    tDFUPTrimCodeSet_t* ptTrimCode;
N} __PACKED tDFUPInfo_t;
X} __attribute__ ((packed)) tDFUPInfo_t;
N
N/*
N * Event Registers
N */
N
Ntypedef struct
N{
N    uint8_t b7Length    :7;
N    uint8_t bAlert      :1;
N} __PACKED tDFUPPacketInfo_t;
X} __attribute__ ((packed)) tDFUPPacketInfo_t;
N
Ntypedef enum
N{
N    DFUP_PF_NORMAL = 0,
N    DFUP_PF_ANGLE_WITHOUT_STRENGTH = 1,
N    DFUP_PF_LIMIT,
N    DFUP_PF_FOR_SIZEFIX = 0xFFFF,
N} __PACKED eDFUPPacketFormatId_t;
X} __attribute__ ((packed)) eDFUPPacketFormatId_t;
N
Ntypedef struct
N{
N    uint32_t reserved;
N    eDFUPPacketFormatId_t ePacketFormatId;
N    uint8_t ucTouchPacketItemSize;
N} __PACKED tDFUPEventFormat_t;
X} __attribute__ ((packed)) tDFUPEventFormat_t;
N
Ntypedef struct
N{
N    tDFUPEventFormat_t* ptEventFormat;
N    tDFUPPacketInfo_t* ptPacketInfo;
N    uint8_t* vucPacketContent;
N} __PACKED tDFUPEvent_t;
X} __attribute__ ((packed)) tDFUPEvent_t;
N
Ntypedef struct
N{
N    uint8_t** ppucBuffer;
N    uint16_t* vusStartAddr;
N    int iSize;
N} __PACKED tDFUPBufferInfo_t;
X} __attribute__ ((packed)) tDFUPBufferInfo_t;
N
Ntypedef struct
N{
N    uint8_t** ppucData;//Pointer of array of pointers.
N    uint8_t* vucStartLAddr;
N    int iSize;
N} __PACKED tDFUPSubsetInfo_t;
X} __attribute__ ((packed)) tDFUPSubsetInfo_t;
N
Nextern void protocol_dfup_Init(void);
Nextern uint8_t* protocol_dfup_GetMappedPointer(uint16_t _addr);
Nextern void protocol_dfup_ClearInterrupt(uint16_t _addr);
Nextern void protocol_dfup_PendReadyStatus(void);
Nextern eProtocolMode_t protocol_dfup_GetMode(void);
N
N#endif /* __PROTOCOL_DFUP_H__ */
L 46 "..\..\Protocol\protocol_def.h" 2
N#endif /* USE_BOOTLOADER_CODE */
N#include "protocol_log.h"
N#include "protocol_conf.h"
L 1 "..\..\Protocol\protocol_conf.h" 1
N/*
N * protocol_conf.h
N *
N *  Created on: 2015. 3. 20.
N *      Author: parkyj2
N */
N
N#ifndef __PROTOCOL_CONF_H__
N#define __PROTOCOL_CONF_H__
N
N#include "protocol.h"
N/*
N * Types
N */
Ntypedef struct
N{
N    eSWIPPacketFormatId_t ePacketFormatId;
N//    int iMaxFinger_;
N} __PACKED tProtocolCommonConf_t;
X} __attribute__ ((packed)) tProtocolCommonConf_t;
N
N//typedef struct
N//{
N//	int t;
N//} __PACKED tProtocolConf_t;
N
Ntypedef struct
N{
N	eProtocolEventTriggerType_t eEventTriggerType;
N	bool_t bEnableHandShake;
N	bool_t bApplyCoordinate;
N	int iEventPacket_;
N} __PACKED tProtocolInfo_t;
X} __attribute__ ((packed)) tProtocolInfo_t;
N
N
N/*
N * Default Methods
N */
Nextern void protocol_SetCommonConfig(const tProtocolCommonConf_t * _p);
Nextern const tProtocolCommonConf_t *protocol_GetCommonConfig(void);
Nextern tProtocolInfo_t *protocol_GetInfo(void);
N
N
N#endif /* __PROTOCOL_CONF_H__ */
L 49 "..\..\Protocol\protocol_def.h" 2
N
N
N#endif /* __PROTOCOL_DEF_H__ */
L 42 "..\..\App\core_def.h" 2
N
N
N#endif /* _CORE_DEF_H_ */
L 34 "..\..\App\Algorithm\algorithm.c" 2
N#include "Protocol_swip.h"
N#include "FOTG200_peripheral.h"
N
N
Nstatic const tModuleModeConf_t * ptModuleModeConf = NULL;
Xstatic const tModuleModeConf_t * ptModuleModeConf = 0;
Nstatic const tAlgorithmModeConf_t * thisModeConf = NULL;
Xstatic const tAlgorithmModeConf_t * thisModeConf = 0;
Nstatic tAlgorithmInfo_t * thisInfo = NULL;
Xstatic tAlgorithmInfo_t * thisInfo = 0;
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
Sstatic tAppInfo_t * ptAppInfo = NULL;
Sextern uint16_t* g_pFingerHop1BaseImage;
N#endif /* USED_NOISE_HOPPING_FREQ */
NtAlgorithmInfo_t * DebugAlgorithmInfo = NULL;
XtAlgorithmInfo_t * DebugAlgorithmInfo = 0;
N//uint8_t HoppingInitFlag = 0;
N
Nuint8_t DoReportOrgPos = 0, ErrorFrameProcessMode = 0;
Nextern uint16_t* g_pFingerBaseImage;
N
N#if 1 // O0    include    data  .. .c 
N#ifdef GetAngleLookUpHighResolution
Sextern int32_t ArcTanLookUp[1001]      =
S{
S0,57, 114, 171, 229, 286, 343, 401, 458, 515, 572, 630, 687, 744, 802, 859, 916, 973, 1031, 1088, 1145,
S1203, 1260, 1317, 1374, 1432, 1489, 1546, 1603, 1661, 1718, 1775, 1832, 1890, 1947, 2004, 2061, 2119, 2176, 2233,
S2290, 2347, 2405, 2462, 2519, 2576, 2633, 2690, 2748, 2805, 2862, 2919, 2976, 3033, 3091, 3148, 3205, 3262, 3319,
S3376, 3433, 3490, 3547, 3604, 3661, 3719, 3776, 3833, 3890, 3947, 4004, 4061, 4118, 4175, 4232, 4289, 4346, 4403,
S4460, 4517, 4573, 4630, 4687, 4744, 4801, 4858, 4915, 4972, 5029, 5085, 5142, 5199, 5256, 5313, 5370, 5426, 5483,
S5540, 5597, 5653, 5710, 5767, 5824, 5880, 5937, 5994, 6050, 6107, 6164, 6220, 6277, 6333, 6390, 6447, 6503, 6560,
S6616, 6673, 6729, 6786, 6842, 6899, 6955, 7012, 7068, 7125, 7181, 7237, 7294, 7350, 7406, 7463, 7519, 7575, 7632,
S7688, 7744, 7801, 7857, 7913, 7969, 8025, 8082, 8138, 8194, 8250, 8306, 8362, 8418, 8474, 8530, 8586, 8642, 8698,
S8754, 8810, 8866, 8922, 8978, 9034, 9090, 9146, 9202, 9257, 9313, 9369, 9425, 9480, 9536, 9592, 9648, 9703, 9759,
S9815, 9870, 9926, 9981, 10037, 10092, 10148, 10204, 10259, 10314, 10370, 10425, 10481, 10536, 10592, 10647, 10702, 10758, 10813,
S10868, 10923, 10979, 11034, 11089, 11144, 11199, 11254, 11309, 11365, 11420, 11475, 11530, 11585, 11640, 11695, 11750, 11804, 11859,
S11914, 11969, 12024, 12079, 12133, 12188, 12243, 12298, 12352, 12407, 12462, 12516, 12571, 12625, 12680, 12734, 12789, 12843, 12898,
S12952, 13007, 13061, 13115, 13170, 13224, 13278, 13333, 13387, 13441, 13495, 13549, 13604, 13658, 13712, 13766, 13820, 13874, 13928,
S13982, 14036, 14090, 14144, 14197, 14251, 14305, 14359, 14413, 14466, 14520, 14574, 14627, 14681, 14735, 14788, 14842, 14895, 14949,
S15002, 15056, 15109, 15163, 15216, 15269, 15323, 15376, 15429, 15482, 15535, 15589, 15642, 15695, 15748, 15801, 15854, 15907, 15960,
S16013, 16066, 16119, 16172, 16225, 16277, 16330, 16383, 16436, 16488, 16541, 16594, 16646, 16699, 16751, 16804, 16856, 16909, 16961,
S17014, 17066, 17118, 17171, 17223, 17275, 17327, 17380, 17432, 17484, 17536, 17588, 17640, 17692, 17744, 17796, 17848, 17900, 17952,
S18004, 18056, 18107, 18159, 18211, 18262, 18314, 18366, 18417, 18469, 18520, 18572, 18623, 18675, 18726, 18778, 18829, 18880, 18932,
S18983, 19034, 19085, 19136, 19187, 19239, 19290, 19341, 19392, 19443, 19494, 19544, 19595, 19646, 19697, 19748, 19798, 19849, 19900,
S19950, 20001, 20052, 20102, 20153, 20203, 20254, 20304, 20354, 20405, 20455, 20505, 20556, 20606, 20656, 20706, 20756, 20806, 20856,
S20906, 20956, 21006, 21056, 21106, 21156, 21206, 21256, 21305, 21355, 21405, 21454, 21504, 21554, 21603, 21653, 21702, 21752, 21801,
S21850, 21900, 21949, 21998, 22047, 22097, 22146, 22195, 22244, 22293, 22342, 22391, 22440, 22489, 22538, 22587, 22636, 22684, 22733,
S22782, 22831, 22879, 22928, 22976, 23025, 23074, 23122, 23170, 23219, 23267, 23316, 23364, 23412, 23460, 23509, 23557, 23605, 23653,
S23701, 23749, 23797, 23845, 23893, 23941, 23989, 24036, 24084, 24132, 24180, 24227, 24275, 24323, 24370, 24418, 24465, 24513, 24560,
S24607, 24655, 24702, 24749, 24796, 24844, 24891, 24938, 24985, 25032, 25079, 25126, 25173, 25220, 25267, 25314, 25361, 25407, 25454,
S25501, 25547, 25594, 25641, 25687, 25734, 25780, 25827, 25873, 25919, 25966, 26012, 26058, 26104, 26151, 26197, 26243, 26289, 26335,
S26381, 26427, 26473, 26519, 26565, 26610, 26656, 26702, 26748, 26793, 26839, 26885, 26930, 26976, 27021, 27067, 27112, 27157, 27203,
S27248, 27293, 27339, 27384, 27429, 27474, 27519, 27564, 27609, 27654, 27699, 27744, 27789, 27834, 27878, 27923, 27968, 28013, 28057,
S28102, 28146, 28191, 28235, 28280, 28324, 28369, 28413, 28457, 28502, 28546, 28590, 28634, 28678, 28722, 28766, 28810, 28854, 28898,
S28942, 28986, 29030, 29074, 29117, 29161, 29205, 29248, 29292, 29336, 29379, 29423, 29466, 29509, 29553, 29596, 29639, 29683, 29726,
S29769, 29812, 29855, 29898, 29941, 29984, 30027, 30070, 30113, 30156, 30199, 30242, 30284, 30327, 30370, 30412, 30455, 30498, 30540,
S30583, 30625, 30667, 30710, 30752, 30794, 30837, 30879, 30921, 30963, 31005, 31047, 31090, 31132, 31173, 31215, 31257, 31299, 31341,
S31383, 31424, 31466, 31508, 31549, 31591, 31633, 31674, 31716, 31757, 31798, 31840, 31881, 31922, 31964, 32005, 32046, 32087, 32128,
S32169, 32210, 32251, 32292, 32333, 32374, 32415, 32456, 32497, 32537, 32578, 32619, 32659, 32700, 32741, 32781, 32822, 32862, 32902,
S32943, 32983, 33023, 33064, 33104, 33144, 33184, 33224, 33264, 33304, 33344, 33384, 33424, 33464, 33504, 33544, 33584, 33623, 33663,
S33703, 33742, 33782, 33822, 33861, 33901, 33940, 33980, 34019, 34058, 34098, 34137, 34176, 34215, 34254, 34294, 34333, 34372, 34411,
S34450, 34489, 34528, 34566, 34605, 34644, 34683, 34722, 34760, 34799, 34837, 34876, 34915, 34953, 34992, 35030, 35068, 35107, 35145,
S35183, 35222, 35260, 35298, 35336, 35374, 35412, 35450, 35488, 35526, 35564, 35602, 35640, 35678, 35716, 35753, 35791, 35829, 35866,
S35904, 35942, 35979, 36017, 36054, 36092, 36129, 36166, 36204, 36241, 36278, 36315, 36353, 36390, 36427, 36464, 36501, 36538, 36575,
S36612, 36649, 36686, 36722, 36759, 36796, 36833, 36869, 36906, 36943, 36979, 37016, 37052, 37089, 37125, 37162, 37198, 37234, 37271,
S37307, 37343, 37379, 37416, 37452, 37488, 37524, 37560, 37596, 37632, 37668, 37704, 37739, 37775, 37811, 37847, 37882, 37918, 37954,
S37989, 38025, 38060, 38096, 38131, 38167, 38202, 38238, 38273, 38308, 38344, 38379, 38414, 38449, 38484, 38519, 38554, 38589, 38624,
S38659, 38694, 38729, 38764, 38799, 38834, 38868, 38903, 38938, 38972, 39007, 39042, 39076, 39111, 39145, 39180, 39214, 39248, 39283,
S39317, 39351, 39386, 39420, 39454, 39488, 39522, 39556, 39590, 39624, 39658, 39692, 39726, 39760, 39794, 39828, 39861, 39895, 39929,
S39963, 39996, 40030, 40063, 40097, 40130, 40164, 40197, 40231, 40264, 40297, 40331, 40364, 40397, 40431, 40464, 40497, 40530, 40563,
S40596, 40629, 40662, 40695, 40728, 40761, 40794, 40827, 40859, 40892, 40925, 40958, 40990, 41023, 41055, 41088, 41121, 41153, 41185,
S41218, 41250, 41283, 41315, 41347, 41380, 41412, 41444, 41476, 41508, 41540, 41573, 41605, 41637, 41669, 41701, 41733, 41764, 41796,
S41828, 41860, 41892, 41923, 41955, 41987, 42018, 42050, 42082, 42113, 42145, 42176, 42208, 42239, 42270, 42302, 42333, 42364, 42396,
S42427, 42458, 42489, 42520, 42551, 42583, 42614, 42645, 42676, 42707, 42737, 42768, 42799, 42830, 42861, 42892, 42922, 42953, 42984,
S43014, 43045, 43076, 43106, 43137, 43167, 43198, 43228, 43258, 43289, 43319, 43350, 43380, 43410, 43440, 43470, 43501, 43531, 43561,
S43591, 43621, 43651, 43681, 43711, 43741, 43771, 43801, 43830, 43860, 43890, 43920, 43949, 43979, 44009, 44038, 44068, 44098, 44127,
S44157, 44186, 44216, 44245, 44274, 44304, 44333, 44362, 44392, 44421, 44450, 44479, 44508, 44537, 44567, 44596, 44625, 44654, 44683,
S44712, 44741, 44769, 44798, 44827, 44856, 44885, 44913, 44942, 44971, 45000,
S};
N#else
Nextern int16_t sucArcTanLookUpTable[101]      =
N{
N0,
N57,115,172,229,286,343,400,457,514,571,
N628,684,741,797,853,909,965,1020,1076,1131,
N1186,1241,1295,1350,1404,1457,1511,1564,1617,1670,
N1722,1774,1826,1878,1929,1980,2030,2081,2131,2180,
N2229,2278,2327,2375,2423,2470,2517,2564,2610,2657,
N2702,2747,2792,2837,2881,2925,2968,3011,3054,3096,
N3138,3180,3221,3262,3302,3342,3382,3422,3461,3499,
N3537,3575,3613,3650,3687,3723,3760,3795,3831,3866,
N3901,3935,3969,4003,4036,4070,4102,4135,4167,4199,
N4230,4261,4292,4323,4353,4383,4413,4442,4471,4500,
N};
N#endif
N
N#ifdef COVER_GLASS_USE
Sextern int8_t ArcSinLookUpTable[128]  =
S{
S0,
S1,2,2,3,4,5,6,7,7,8,
S9,10,10,11,12,13,14,15,16,16,
S17,17,18,19,20,21,22,23,24,25,
S26,27,28,29,30,31,32,33,34,35,
S36,37,38,38,39,40,41,42,43,44,
S45,45,46,47,48,49,50,51,51,52,
S53,54,56,57,58,60,61,62,64,65,
S67,68,70,72,74,76,78,80,82,85,
S87,90,92,95,97,100,102,105,107,109,
S111,112,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113,113,113,113,
S113,113,113,113,113,113,113
S};
N#else
Nextern int8_t ArcSinLookUpTable[128] = {
N0,
N1,2,3,3,4,5,6,7,8,9,
N10,11,12,13,14,15,16,17,18,19,
N20,21,22,23,24,25,26,27,28,29,
N30,31,32,33,34,35,36,37,38,40,
N41,42,43,44,45,46,47,47,48,49,
N51,52,53,54,55,56,57,59,60,61,
N62,64,65,67,68,70,72,73,75,76,
N78,79,81,82,84,86,88,90,92,93,
N96,98,100,103,104,105,107,109,111,113,
N113,113,113,113,113,113,113,113,113,113,
N113,113,113,113,113,113,113,113,113,113,
N113,113,113,113,113,113,113,113,113,113,
N113,113,113,113,113,113,113
N};
N#endif
N
Nextern int8_t CosLookUpTable[114]  =
N{
N	100,
N	100,100,100,100,100,100,100,100,100,100,
N	99,99,99,99,99,99,99,98,98,98,
N	98,98,97,97,97,97,96,96,96,96,
N	95,95,95,94,94,94,93,93,92,92,
N	92,91,91,90,90,90,89,89,88,88,
N	87,87,86,86,85,85,84,84,83,83,
N	82,81,81,80,80,79,78,78,77,76,
N	76,75,75,74,73,72,72,71,70,70,
N	69,68,67,67,66,65,64,64,63,62,
N	61,61,60,59,58,57,57,56,55,54,
N	53,52,51,51,50,49,48,47,46,45,
N	44,44,43
N};
N#endif /* #if 1 */
N
NtAlgorithmInfo_t * tTempAlgorithmInfoDebug;
Nvoid algorithm_init(void)
N{
N#if (USED_IDLE_MODE_CONTROL || USED_NOISE_HOPPING_FREQ || USED_FRAME_SKIP_IDLE_MODE_CONTROL)
X#if (((1==0)) || ((1==0)) || ((0==0)))
N	const tAppCommonConf_t * _ptAppCommonConf = NULL;
X	const tAppCommonConf_t * _ptAppCommonConf = 0;
N	_ptAppCommonConf = app_GetCommonConfig();
N#endif /* (USED_IDLE_MODE_CONTROL || USED_NOISE_HOPPING_FREQ || USED_FRAME_SKIP_IDLE_MODE_CONTROL) */
N	
N	algorithm_init_param();
N	thisInfo = algorithm_GetInfo();
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	ptAppInfo = app_GetInfo();
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N	DebugAlgorithmInfo = thisInfo;
N	tTempAlgorithmInfoDebug = thisInfo;
N
N#if (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL)
X#if (((1==0)) || ((0==0)))
N	#if USED_ENTER_IDLE_REAL_TIME_CHECK
S		thisInfo->ulIdleModeEnterFrameCntTHD = _ptAppCommonConf->ucIdleModeEnterSec;
N	#else
N		thisInfo->ulIdleModeEnterFrameCntTHD = _ptAppCommonConf->ucIdleModeEnterSec * _ptAppCommonConf->ucFrameRate;
N	#endif /* USED_ENTER_IDLE_REAL_TIME_CHECK */
N	thisInfo->ulIdleModeEnterCheckCount = 0;
N#endif /* (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL) */
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	thisInfo->ulHopFrqIdleModeFrameCntTHD = thisInfo->ulIdleModeEnterFrameCntTHD;
S	thisInfo->ulHoppMainRollbackFrameCntTHD = _ptAppCommonConf->HoppMainRollbackSec * _ptAppCommonConf->ucFrameRate;
S	thisInfo->ulHoppMainRollbackCheckCount = 0;
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N	algorithm_baseline_init();
N	algorithm_label_init();
N	algorithm_coord_init();
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	algorithm_noise_init();
N#endif /* USED_NOISE_HOPPING_FREQ */
N}
N
Nvoid algorithm_init_param(void)
N{
N	ptModuleModeConf = module_GetModeConfig();
N	thisModeConf = algorithm_GetModeConfig();
N	algorithm_baseline_init_param();
W "..\..\App\Algorithm\algorithm.c" 226 2 function "algorithm_label_init_param" declared implicitly
N	algorithm_label_init_param();
N//	algorithm_coord_init();
N	algorithm_coord_init_param();
N}
N#if (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL)
X#if (((1==0)) || ((0==0)))
Nbool_t algorithm_CheckFingerIdleModeControl(void)
N{
N	eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
N
N	if(IS_ACTIVE_MODE(eSensingMode))
X	if((eSensingMode & SM_CHECK_ACTIVE))
N	{
N		if(thisInfo->bTouchExpect)
N		{
N			thisInfo->ulIdleModeEnterCheckCount = 0;
N		}
N		else
N		{
N			thisInfo->ulIdleModeEnterCheckCount++;
N
N			if(thisInfo->ulIdleModeEnterCheckCount > thisInfo->ulIdleModeEnterFrameCntTHD)
N			{
N				thisInfo->ulIdleModeEnterCheckCount = 0;
N				HAL_SetSensingChangeMode(SM_CHANGE_IDLE_MODE);
N				return YES;
X				return (0==0);
N			}
N		}
N	}
N#if (USED_ONLY_IDLE_MODE == NO)
X#if (((1==0)) == (1==0))
N	else if(IS_IDLE_MODE(eSensingMode))
X	else if((eSensingMode & SM_CHECK_IDLE))
N	{
N		if(thisInfo->bTouchExpect)
N		{
N			/*
N			 * NOTE : Idle -> Active Is Always Normal Frequency Operation
N			 */
N			HAL_SetSensingChangeMode(SM_CHANGE_ACTIVE_FRQ_MAIN_MODE);
N#if USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE
X#if ((1==0))
S			thisInfo->bIsIdleToActive = YES;
N#endif /* USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE */
N
N			return YES;
X			return (0==0);
N		}
N	}
N#endif /* (USED_ONLY_IDLE_MODE == NO) */
N
N	return NO;
X	return (1==0);
N}
N#endif /* (USED_IDLE_MODE_CONTROL || USED_FRAME_SKIP_IDLE_MODE_CONTROL) */
N
Nint32_t algorithm_calc_sqrt(int32_t d)
N{
N    uint32_t x = 1;
N
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N    x = (x + d/x)>>1;
N
N    return x;
N}
N
N#ifdef GetAngleLookUpHighResolution
Sint32_t algorithm_calc_angle_inter_2points_HighResolution(int diff_x, int diff_y)
S{
S	int angle = 0;
S
S//	int diff_x, diff_y;
S
S//	diff_x = _tPos2.x - _tPos1.x;
S//	diff_y = _tPos2.y - _tPos1.y;
S	
S	if( diff_x > 0  )
S	{
S		if( diff_y > 0 )
S		{
S			if( diff_x >= diff_y ){
S				//angle = sucArcTanLookUpTable[(diff_y << 6)/diff_x];
S				angle = ArcTanLookUp[MIN(1000,MAX(0,(int)((double)diff_y/(double)diff_x * 1000)))];
S			}
S			else
S				//angle = 90 - sucArcTanLookUpTable[(diff_x << 6)/diff_y];
S				angle = 90000 - ArcTanLookUp[MIN(1000,MAX(0,(int)((double)diff_x/(double)diff_y * 1000)))];
S		}
S		else if( diff_y < 0 )
S		{
S			if( diff_x >= -(diff_y) )
S				//angle = 360 - sucArcTanLookUpTable[(-diff_y << 6)/diff_x];
S				angle = 360000 - ArcTanLookUp[MIN(1000,MAX(0,(int)((double)-diff_y/(double)diff_x * 1000)))];
S			else
S				//angle = 270 + sucArcTanLookUpTable[(diff_x << 6)/-diff_y];
S				angle = 270000 - ArcTanLookUp[MIN(1000,MAX(0,(int)((double)diff_x/(double)-diff_y * 1000)))];
S		}
S		else
S		{
S			angle = 0;
S		}
S	}
S	else if( diff_x < 0 )
S	{
S		if( diff_y > 0 )
S		{
S			if( -diff_x < diff_y )
S				//angle = 90 + sucArcTanLookUpTable[(-diff_x << 6)/diff_y];
S				angle = 90000 + ArcTanLookUp[MIN(1000,MAX(0,(int)((double)-diff_x/(double)diff_y * 1000)))];
S			else
S				//angle = 180 - sucArcTanLookUpTable[(diff_y << 6)/-diff_x];
S				angle = 180000 - ArcTanLookUp[MIN(1000,MAX(0,(int)((double)diff_y/(double)-diff_x * 1000)))];
S		}
S		else if( diff_y < 0 )
S		{
S			if( -diff_x >= -diff_y )
S				//angle = 180 + sucArcTanLookUpTable[(-diff_y << 6)/-diff_x];
S				angle = 180000 + ArcTanLookUp[MIN(1000,MAX(0,(int)((double)-diff_y/(double)-diff_x * 1000)))];
S			else
S				//angle = 270 - sucArcTanLookUpTable[(-diff_x << 6)/-diff_y];
S				angle = 270000 - ArcTanLookUp[MIN(1000,MAX(0,(int)((double)-diff_x/(double)-diff_y * 1000)))];
S		}
S		else
S		{
S			angle = 180000;
S		}
S	}
S	else
S	{
S		if( diff_y > 0 )
S			angle = 90000;
S		else if( diff_y < 0 )
S		{
S			angle = 270000;
S		}
S	}
S
S	return angle;
S}
N#else
Nint32_t algorithm_calc_angle_inter_2points(int diff_x, int diff_y)
N{
N	int angle = 0;
N
N//	int diff_x, diff_y;
N
N//	diff_x = _tPos2.x - _tPos1.x;
N//	diff_y = _tPos2.y - _tPos1.y;
N
N	if( diff_x > 0  )
N	{
N		if( diff_y > 0 )
N		{
N			if( diff_x >= diff_y )
N				angle = sucArcTanLookUpTable[(diff_y * 100)/diff_x];
N			else
N				angle = 9000 - sucArcTanLookUpTable[(diff_x * 100)/diff_y];
N		}
N		else if( diff_y < 0 )
N		{
N			if( diff_x >= -(diff_y) )
N				angle = 36000 - sucArcTanLookUpTable[(-diff_y * 100)/diff_x];
N			else
N				angle = 27000 + sucArcTanLookUpTable[(diff_x * 100)/-diff_y];
N		}
N		else
N		{
N			angle = 0;
N		}
N	}
N	else if( diff_x < 0 )
N	{
N		if( diff_y > 0 )
N		{
N			if( -diff_x < diff_y )
N				angle = 9000 + sucArcTanLookUpTable[(-diff_x * 100)/diff_y];
N			else
N				angle = 18000 - sucArcTanLookUpTable[(diff_y * 100)/-diff_x];
N		}
N		else if( diff_y < 0 )
N		{
N			if( -diff_x >= -diff_y )
N				angle = 18000 + sucArcTanLookUpTable[(-diff_y * 100)/-diff_x];
N			else
N				angle = 27000 - sucArcTanLookUpTable[(-diff_x * 100)/-diff_y];
N		}
N		else
N		{
N			angle = 18000;
N		}
N	}
N	else
N	{
N		if( diff_y > 0 )
N			angle = 9000;
N		else if( diff_y < 0 )
N		{
N			angle = 27000;
N		}
N	}
N
N	return angle;
N}
N#if 0
Sint32_t algorithm_calc_angle_inter_2points(tXY_t _tPos1, tXY_t _tPos2)
S{
S	int angle = 0;
S
S	int diff_x, diff_y;
S
S	diff_x = _tPos2.x - _tPos1.x;
S	diff_y = _tPos2.y - _tPos1.y;
S
S	if( diff_x > 0  )
S	{
S		if( diff_y > 0 )
S		{
S			if( diff_x >= diff_y )
S				angle = sucArcTanLookUpTable[(diff_y << 6)/diff_x];
S			else
S				angle = 90 - sucArcTanLookUpTable[(diff_x << 6)/diff_y];
S		}
S		else if( diff_y < 0 )
S		{
S			if( diff_x >= -(diff_y) )
S				angle = 360 - sucArcTanLookUpTable[(-diff_y << 6)/diff_x];
S			else
S				angle = 270 + sucArcTanLookUpTable[(diff_x << 6)/-diff_y];
S		}
S		else
S		{
S			angle = 0;
S		}
S	}
S	else if( diff_x < 0 )
S	{
S		if( diff_y > 0 )
S		{
S			if( -diff_x < diff_y )
S				angle = 90 + sucArcTanLookUpTable[(-diff_x << 6)/diff_y];
S			else
S				angle = 180 - sucArcTanLookUpTable[(diff_y << 6)/-diff_x];
S		}
S		else if( diff_y < 0 )
S		{
S			if( -diff_x >= -diff_y )
S				angle = 180 + sucArcTanLookUpTable[(-diff_y << 6)/-diff_x];
S			else
S				angle = 270 - sucArcTanLookUpTable[(-diff_x << 6)/-diff_y];
S		}
S		else
S		{
S			angle = 180;
S		}
S	}
S	else
S	{
S		if( diff_y > 0 )
S			angle = 90;
S		else if( diff_y < 0 )
S		{
S			angle = 270;
S		}
S	}
S
S	return angle;
S}
N#endif
N#endif
N
N#if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
X#if ((1==0))
Sextern bool_t bBigFingerEdgeTestFlag[4];
Suint8_t ucBigFingerEdgeTest_MoveEventTHD_Change = 0;
Sextern bool_t bBigFingerEdgeTestEn[4];
Sextern bool_t bReportDelayFlag;
Suint8_t ucReportDelayCnt = 0;
StXY_t ReportDelayTmpPos;
Sextern STATIC_QUEUE	g_Queue_Common;
Sextern uint8_t	g_Touch[QUEUE_BLOCK_SIZE];
Svoid algorithm_EdgeReportDelay(void)
S{
S	int i, distX, distY;
S	static uint8_t ucTmpEdgeReportDelayCnt =0;
S	
S	if(thisModeConf->EdgeExpand.ucEdgeReportDelayCnt)
S	{
S		if(thisInfo->tCoord.tPastPos[0].vusS[0] == 0 && thisInfo->tCoord.tPos.vusS[0] && thisInfo->tCoord.tPos.sFinger_ == 1)
S		{
S			int8_t edge_type = algorithm_coord_IsEdgeArea(&thisInfo->tCoord.tPos.tXY[0],UNIT_DIST>>1);
S			if(edge_type)
S			{
S				distY = distX = 0;
S				if(thisInfo->tCoord.tPos.tXY[0].y < (UNIT_DIST+(UNIT_DIST>>1)))
S				{
S					for(i = thisInfo->tCoord.tPos.rect[0].cs; i < thisInfo->tCoord.tPos.rect[0].ce; i++)
S					{
S						distY += HAL_READ_DELTA_IMAGE(0,i);
S					}
S				}
S				else if(thisInfo->tCoord.tPos.tXY[0].y > thisInfo->tCoord.iInternalYRes-(UNIT_DIST+(UNIT_DIST>>1)))
S				{
S					for(i = thisInfo->tCoord.tPos.rect[0].cs; i <= thisInfo->tCoord.tPos.rect[0].ce; i++)
S					{
S						distY += HAL_READ_DELTA_IMAGE(ROW_MAX-1,i);
S					}
S				}
S
S				if(thisInfo->tCoord.tPos.tXY[0].x < (UNIT_DIST+(UNIT_DIST>>1)))
S				{
S					for(i = thisInfo->tCoord.tPos.rect[0].rs; i <= thisInfo->tCoord.tPos.rect[0].re; i++)
S					{
S						distX += HAL_READ_DELTA_IMAGE(i,0);
S					}
S				}
S				else if(thisInfo->tCoord.tPos.tXY[0].x > thisInfo->tCoord.iInternalXRes-(UNIT_DIST+(UNIT_DIST>>1)))
S				{
S					for(i = thisInfo->tCoord.tPos.rect[0].cs; i <= thisInfo->tCoord.tPos.rect[0].ce; i++)
S					{
S						distX += HAL_READ_DELTA_IMAGE(i,COL_MAX-1);
S					}
S				}
S				
S				if(distX > 30 || distY > 30)
S				{
S					bReportDelayFlag=1;
S					ucReportDelayCnt = 0;
S					ReportDelayTmpPos = thisInfo->tCoord.tPos.tXY[0];
S					ucTmpEdgeReportDelayCnt = thisModeConf->EdgeExpand.ucEdgeReportDelayCnt;
S					if(edge_type==2)ucTmpEdgeReportDelayCnt+=5;
S				}
S			}
S		}
S		
S		if(bReportDelayFlag)
S		{
S//			if(thisInfo->tCoord.tPastPos[0].vusS[0])
S			{
S				if(algorithm_coord_calc_distance(thisInfo->tCoord.tFirstPos.tXY[0],thisInfo->tCoord.tPos.tXY[0]) > 512 || ucReportDelayCnt > ucTmpEdgeReportDelayCnt)
S				{
S					bReportDelayFlag = 0;
S					ucReportDelayCnt = 0;
S				}
S				else
S				{
S					if(ucReportDelayCnt == ucTmpEdgeReportDelayCnt)
S					{
S						for(i = 0; i < thisModeConf->EdgeExpand.ucEdgeReportDelayCnt; i++)
S							StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Touch);
S					}
S					ucReportDelayCnt++;
S					
S				}
S			}
S		}
S	}
S}
S
Svoid algorithm_BigFingerEdgeAccTest(tXY_t *pos1, tXY_t *pos2,bool_t EndEventMode)
S{
S	int distX, distY;
S	tXY_t pos, old_pos;
S	static uint8_t end_cliping_flag = 0;
S
S	old_pos.x = pos2->x;
S	old_pos.y = pos2->y;
S	pos.x = pos1->x;
S	pos.y = pos1->y;
S	if(EndEventMode == 0)
S	{
S		if(thisInfo->tCoord.tPastSentPos.vusS[0])
S		{
S			distX = old_pos.x - pos.x;
S			distY = old_pos.y - pos.y;
S			if(distX<0)distX=-distX;
S			if(distY<0)distY=-distY;
S
S			if(ucBigFingerEdgeTest_MoveEventTHD_Change != 0 || bBigFingerEdgeTestFlag[0] != 0 || bBigFingerEdgeTestFlag[1] != 0 || bBigFingerEdgeTestFlag[2] != 0 || bBigFingerEdgeTestFlag[3] != 0)
S			{
S				if(!algorithm_coord_IsEdgeArea(&thisInfo->tCoord.tPos.tXY[0],150))
S				{
S					ucBigFingerEdgeTest_MoveEventTHD_Change = 0;
S					bBigFingerEdgeTestFlag[0]=bBigFingerEdgeTestFlag[1]=bBigFingerEdgeTestFlag[2]=bBigFingerEdgeTestFlag[3]=0;
S					bBigFingerEdgeTestEn[0]=bBigFingerEdgeTestEn[1]=bBigFingerEdgeTestEn[2]=bBigFingerEdgeTestEn[3]=1;
S				}
S			}
S			
S			if(end_cliping_flag > 0 && end_cliping_flag < 5 && algorithm_coord_IsEdgeArea_Cell(thisInfo->tLabel.tValidMaxPos[0].r,thisInfo->tLabel.tValidMaxPos[0].c,0) != 2)
S				end_cliping_flag = 5;
S			
S			if(distY > thisModeConf->EdgeExpand.usBigFingerEdgeTest_MoveEventTHD_Y || distX > thisModeConf->EdgeExpand.usBigFingerEdgeTest_MoveEventTHD_X)
S			{
S				ucBigFingerEdgeTest_MoveEventTHD_Change=0;
S			}
S
S			if(ucBigFingerEdgeTest_MoveEventTHD_Change == 3)
S			{
S				pos.x = old_pos.x;
S				pos.y = old_pos.y;
S			}
S			
S			if(bBigFingerEdgeTestFlag[0] != 0 || bBigFingerEdgeTestFlag[1] != 0 || bBigFingerEdgeTestFlag[2] != 0 || bBigFingerEdgeTestFlag[3] != 0)
S			{						
S				if(distX > 196 || distY > 365)
S				{
S					bBigFingerEdgeTestFlag[0]=bBigFingerEdgeTestFlag[1]=bBigFingerEdgeTestFlag[2]=bBigFingerEdgeTestFlag[3]=0;
S					bBigFingerEdgeTestEn[0]=bBigFingerEdgeTestEn[1]=bBigFingerEdgeTestEn[2]=bBigFingerEdgeTestEn[3]=1;
S				}
S			}
S		}
S					
S//		if(bBigFingerEdgeTestFlag[0] && pos.y > thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop)pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S//		if(bBigFingerEdgeTestFlag[1] && pos.y < 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom)pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S//		if(bBigFingerEdgeTestFlag[2] && pos.x > thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft)pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S//		if(bBigFingerEdgeTestFlag[3] && pos.x < 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight)pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S			
S		if(bBigFingerEdgeTestFlag[0])
S		{
S			if(bBigFingerEdgeTestFlag[2])
S			{
S				pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S				pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S//				if(pos.x < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft)pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S//				if(pos.y < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop) pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S			}
S			else if(bBigFingerEdgeTestFlag[3])
S			{
S				pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S				//if(pos.x > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight)pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				//if(pos.y < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop)		  pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S			}
S		}
S		else if(bBigFingerEdgeTestFlag[1])
S		{
S			if(bBigFingerEdgeTestFlag[2])
S			{
S				pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S				pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S				//if(pos.x < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft)		   pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S				//if(pos.y > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom)pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S			}
S			else if(bBigFingerEdgeTestFlag[3])
S			{
S				pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S				//if(pos.x > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight) pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				//if(pos.y > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom)pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S			}
S		}		
S
S//		if(bBigFingerEdgeTestFlag[0])
S//		{
S//			pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S//		}
S//		else if(bBigFingerEdgeTestFlag[1])
S//		{
S//			pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S//		}
S//			
S//		if(bBigFingerEdgeTestFlag[2])
S//		{
S//			pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S//		}
S//		else if(bBigFingerEdgeTestFlag[3])
S//		{
S//			pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S//		}
S
S		if(end_cliping_flag == 0)
S		{
S			if(!bBigFingerEdgeTestEn[0] && !bBigFingerEdgeTestEn[1] && !bBigFingerEdgeTestEn[2] && !bBigFingerEdgeTestEn[3] && thisModeConf->EdgeExpand.bFingerCornerTestClippingOn)
S			{
S				if(algorithm_coord_IsEdgeArea(&thisInfo->tCoord.tFirstPos.tXY[0],0) == 2 && thisInfo->tCoord.tPos.sFinger_ == 1)
S				{
S					if(algorithm_coord_IsEdgeArea_Cell(thisInfo->tLabel.tValidMaxPos[0].r,thisInfo->tLabel.tValidMaxPos[0].c,0) == 2)
S					{
S						if(thisInfo->tLabel.tValidMaxPos[0].r == 0)
S						{
S							if(thisInfo->tLabel.tValidMaxPos[0].c == 0)
S							{
S								if(pos.x < 196)pos.x = 196;
S								if(pos.y < 365)pos.y = 365;
S								end_cliping_flag = 1;
S							}
S							else
S							{
S								if(pos.x > 32767-196)pos.x = 32767-196;
S								if(pos.y < 365)pos.y = 365;
S								end_cliping_flag = 2;
S							}
S						}
S						else
S						{
S							if(thisInfo->tLabel.tValidMaxPos[0].c == 0)
S							{
S								if(pos.x < 196)pos.x = 196;
S								if(pos.y > 32767-365)pos.y = 32767-365;
S								end_cliping_flag = 3;
S							}
S							else
S							{
S								if(pos.x > 32767-196)pos.x = 32767-196;
S								if(pos.y > 32767-365)pos.y = 32767-365;
S								end_cliping_flag = 4;
S							}
S						}
S					}
S				}
S			}
S		}
S		
S		 pos1->x=pos.x;
S		 pos1->y=pos.y;
S	}
S	else
S	{
S//		if(bBigFingerEdgeTestFlag[0] && old_pos.y > thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop)old_pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S//		if(bBigFingerEdgeTestFlag[1] && old_pos.y < 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom)old_pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S//		if(bBigFingerEdgeTestFlag[2] && old_pos.x > thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft)old_pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S//		if(bBigFingerEdgeTestFlag[3] && old_pos.x < 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight)old_pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;		
S			
S		if(bBigFingerEdgeTestFlag[0])
S		{
S			if(bBigFingerEdgeTestFlag[2])
S			{
S				old_pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S				old_pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S				//if(old_pos.x < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft)old_pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S				//if(old_pos.y < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop) old_pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S			}
S			else if(bBigFingerEdgeTestFlag[3])
S			{
S				old_pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				old_pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S				//if(old_pos.x > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight)old_pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				//if(old_pos.y < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop)		  old_pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S			}
S		}
S		else if(bBigFingerEdgeTestFlag[1])
S		{
S			if(bBigFingerEdgeTestFlag[2])
S			{
S				old_pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S				old_pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S				//if(old_pos.x < thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft)		   old_pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S				//if(old_pos.y > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom)old_pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S			}
S			else if(bBigFingerEdgeTestFlag[3])
S			{
S				old_pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				old_pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S				//if(old_pos.x > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight) old_pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S				//if(old_pos.y > 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom)old_pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S			}
S		}
S
S//		if(bBigFingerEdgeTestFlag[0])
S//		{
S//			old_pos.y = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingTop;
S//		}
S//		else if(bBigFingerEdgeTestFlag[1])
S//		{
S//			old_pos.y = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingBottom;
S//		}
S//			
S//		if(bBigFingerEdgeTestFlag[2])
S//		{
S//			old_pos.x = thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingLeft;
S//		}
S//		else if(bBigFingerEdgeTestFlag[3])
S//		{
S//			old_pos.x = 32767-thisModeConf->EdgeExpand.usBigFingerEdgeTestClippingRight;
S//		}
S	
S		if(end_cliping_flag == 1)
S		{
S			if(old_pos.x < 196)old_pos.x = 196;
S			if(old_pos.y < 365)old_pos.y = 365;
S		}
S		else if(end_cliping_flag == 2)
S		{
S			if(old_pos.x > 32767-196)old_pos.x = 32767-196;
S			if(old_pos.y < 365)old_pos.y = 365;
S		}						
S		else if(end_cliping_flag == 3)
S		{
S			if(old_pos.x < 196)old_pos.x = 196;
S			if(old_pos.y > 32767-365)old_pos.y = 32767-365;
S		}
S		else if(end_cliping_flag == 4)
S		{
S			if(old_pos.x > 32767-196)old_pos.x = 32767-196;
S			if(old_pos.y > 32767-365)old_pos.y = 32767-365;
S		}	
S
S		pos2->x=old_pos.x;
S		pos2->y=old_pos.y;
S		
S		if(bReportDelayFlag)bReportDelayFlag=0;	
S	}
S}
N#endif
N
Nextern int hid_index;
Nextern int HID_status[];
Nextern int HID_id[];
Nextern int HID_x[];
Nextern int HID_y[];
Nextern void protocol_hid_PushTouchEvent(const uSWIPTouchItem_t* _kptItem);
N//extern uint8_t	g_ConnectedDevice;
Nvoid algorithm_PendTouchEvent(void)
N{
N	int i;
N	int distX, distY;
N	tXY_t pos, old_pos;
N	uint8_t ucMoveTHD_X,ucMoveTHD_Y;
N
N#if (ID_MAPPING_CHANGE)
X#if (((1==0)))
Sstatic uint8_t NewID = 50;
Sstatic uint8_t Id_Map[MAX_TOUCH_] = {0,};
Sstatic uint16_t NonTouchCnt = 0;
N#endif
N
N	hal_set_overlap_pen();
N
N	memset(HID_status,0,HID_MAX_TOUCH);
X	memset(HID_status,0,0x0A);
N	memset(HID_id,0,HID_MAX_TOUCH);
X	memset(HID_id,0,0x0A);
N	memset(HID_x,0,HID_MAX_TOUCH);
X	memset(HID_x,0,0x0A);
N	memset(HID_y,0,HID_MAX_TOUCH);
X	memset(HID_y,0,0x0A);
N
N	eSWIPPacketFormatId_t id = protocol_swip_GetPacketFormatId();
N#define SET_POS(tItem, pos)  \
N	do{    \
N			(tItem).tItem00.ucXHigh = ((pos).x >> 8) & 0xFF;    \
N			(tItem).tItem00.ucYHigh = ((pos).y >> 8) & 0xFF;    \
N			(tItem).tItem00.ucXLow = (pos).x & 0xFF;    \
N			(tItem).tItem00.ucYLow = (pos).y & 0xFF;    \
N		} while(0)
X#define SET_POS(tItem, pos)  	do{    			(tItem).tItem00.ucXHigh = ((pos).x >> 8) & 0xFF;    			(tItem).tItem00.ucYHigh = ((pos).y >> 8) & 0xFF;    			(tItem).tItem00.ucXLow = (pos).x & 0xFF;    			(tItem).tItem00.ucYLow = (pos).y & 0xFF;    		} while(0)
N
N	//if(g_ConnectedDevice == I2C_CONNECT_PC)
N	{
N		protocol_swip_InitTouchEventBuffer();
N		//    protocol_hid_InitTouchEventBuffer();
N	}
N	
N	hid_index=0;
N	
N#if (SWIP_QUEUE_MODE)
X#if ((2))
N	thisInfo->bQueueStart 	= 0;
N	#if (SWIP_QUEUE_MODE == 2)
X	#if ((2) == 2)
N		thisInfo->bTouchOffFlag	= 0;
N	#endif
N#endif
N
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S	tTouchItemType_t touchItemType;
S	memset(&touchItemType, 0, sizeof(tTouchItemType_t));
S	/*
S	 * TODO : finger mode  .
S	 * algorithm   touch type  flag setting  .
S	 */
S	touchItemType.active_stylus_hover = YES;
S	touchItemType.active_stylus = YES;
S	touchItemType.passive_stylus = YES;
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N
N	if(thisModeConf->Palm.bPalm_WholeTouchRemove && thisInfo->bIsPalm == YES)
X	if(thisModeConf->Palm.bPalm_WholeTouchRemove && thisInfo->bIsPalm == (0==0))
N	{
N		for( i=MAX_TOUCH_; i--; )thisInfo->tCoord.tPos.vusS[i] = 0;
X		for( i=(10); i--; )thisInfo->tCoord.tPos.vusS[i] = 0;
N	}
N
N#if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN	
X#if ((1==0))	
S	algorithm_EdgeReportDelay();
N#endif
N	
N	for (i = 0; i < MAX_TOUCH_; i++)
X	for (i = 0; i < (10); i++)
N	{
N		//        bool_t bIsHover = NO;
N		if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0)
N		{
N//			old_pos = thisInfo->tCoord.tPastSentPos.tXY[i];
N//			alogorithm_coord_modify_pos(&old_pos,&old_pos, i);
N			old_pos.x = thisInfo->tCoord.tRealPastSentPos.tXY[i].x;
N			old_pos.y = thisInfo->tCoord.tRealPastSentPos.tXY[i].y;
N		}
N
N		if (thisInfo->tCoord.tPos.vusS[i] > 0)
N		{
N			pos = thisInfo->tCoord.tPos.tXY[i];
N			
N//			if(thisModeConf->Palm.ucPalmDrawingOn > 1)
N//				algorithm_width_height_calculation(i);
N
N			if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0)
N				alogorithm_coord_modify_pos(&old_pos,&pos, i);
N			else
N				alogorithm_coord_modify_pos(&pos, &pos, i);
N		}
N		
N		if (thisInfo->tCoord.tPos.vusS[i] > 0)
N		{
N#if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
X#if ((1==0))
S			if(i == 0)algorithm_BigFingerEdgeAccTest(&pos,&old_pos,0);
N#endif
N			
N			distX = pos.x - old_pos.x;
N			distY = pos.y - old_pos.y;
N			if (distY < 0)
N			distY = -distY;
N			if (distX < 0)
N			distX = -distX;
N
N			if (!thisInfo->tCoord.bFirstLongDistanceMoved[i])
N			{
N				ucMoveTHD_X = thisModeConf->Coord.ucFirstMoveEventTHD;
N				ucMoveTHD_Y = thisModeConf->Coord.ucFirstMoveEventTHD;
N			}
N			else
N			{
N				ucMoveTHD_X = thisModeConf->Coord.ucMoveEventTHD;
N				ucMoveTHD_Y = thisModeConf->Coord.ucMoveEventTHD;
N			}
N			
N			if (thisInfo->tCoord.tPastSentPos.vusS[i] == 0 || (distY >= ucMoveTHD_Y) || (distX >= ucMoveTHD_X))
N			{
N#if (ID_MAPPING_CHANGE)
X#if (((1==0)))
S				if (thisInfo->tCoord.tPastSentPos.vusS[i] == 0 )
S				{
S					NewID++;
S					if(NewID > 30)NewID=1;
S					Id_Map[i] = NewID;
S				}
N#endif				
N				uSWIPTouchItem_t tItem;
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S				tItem.tItem00.tInfo.b4FingerID = i + 1;					// id
S				tItem.tItem00.tInfo.b1Status = TOUCH_STATUS_PRESS;		// status
S				tItem.tItem00.tInfo.b6Type = (touchItemType.finger << TOUCH_TYPE_FINGER) |
S									  (touchItemType.glove << TOUCH_TYPE_GLOVE) |
S									  (touchItemType.hover << TOUCH_TYPE_HOVER) |
S									  (touchItemType.passive_stylus << TOUCH_TYPE_PASSIVE_STYLUS) |
S									  (touchItemType.active_stylus << TOUCH_TYPE_ACTIVE_STYLUS) |
S									  (touchItemType.active_stylus_hover << TOUCH_TYPE_ACTIVE_STYLUS_HOVER);
N#else /* USED_SHARP_SPECIFIC_PROTOCOL */
N				tItem.tItem00.tInfo.bTouch = YES;
X				tItem.tItem00.tInfo.bTouch = (0==0);
N				tItem.tItem00.tInfo.bHover = NO;
X				tItem.tItem00.tInfo.bHover = (1==0);
N				tItem.tItem00.tInfo.bScreen = YES;
X				tItem.tItem00.tInfo.bScreen = (0==0);
N				tItem.tItem00.tInfo.bPalm = thisInfo->bIsPalm;
N	#if (ID_MAPPING_CHANGE)
X	#if (((1==0)))
S				tItem.tItem00.tInfo.b4FingerID = Id_Map[i];
N	#else
N				tItem.tItem00.tInfo.b4FingerID = i + 1;
N	#endif
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N				tItem.tItem00.ucRowStart = 0;
N
N				SET_POS(tItem, pos);
X				do{ (tItem). tItem00 . ucXHigh = ((pos). x >> 8) & 0xFF; (tItem). tItem00 . ucYHigh = ((pos). y >> 8) & 0xFF; (tItem). tItem00 . ucXLow = (pos). x & 0xFF; (tItem). tItem00 . ucYLow = (pos). y & 0xFF; } while(0);
N				tItem.tItem00.ucWidth = MIN(thisInfo->tCoord.tPos.vusR[i], UINT8_MAX);
X				tItem.tItem00.ucWidth = ( ( ( thisInfo->tCoord . tPos . vusR[i] ) < ( 255 ) ) ? ( thisInfo->tCoord . tPos . vusR[i] ) : ( 255 ) );
N				//                tItem.tItem00.ucWidth = thisInfo->tCoord.cScreenDebCnt[i];
N				
N//				tItem.tItem02.usWidth = thisInfo->tCoord.tPos.vusW[i];
N//				tItem.tItem02.usHeight = thisInfo->tCoord.tPos.vusH[i];
N				
N				if(id == 0)
N				{
N					tItem.tItem00.usStrength = thisInfo->tCoord.tPos.vusS[i];
N				}
N#if !(ID_MAPPING_CHANGE)
X#if !(((1==0)))
N				protocol_swip_PushTouchEvent(&tItem);
N#endif				
N				protocol_hid_PushTouchEvent(&tItem);
N
N				if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0 && ((distY >= ucMoveTHD_Y) || (distX >= ucMoveTHD_X)) ) //distance moved.
N				{
N					thisInfo->tCoord.bFirstLongDistanceMoved[i] = YES;
X					thisInfo->tCoord.bFirstLongDistanceMoved[i] = (0==0);
N				}
N				else //1st touch.
N				{
N					thisInfo->tCoord.bFirstLongDistanceMoved[i] = NO;
X					thisInfo->tCoord.bFirstLongDistanceMoved[i] = (1==0);
N				}
N
N				thisInfo->tCoord.tPastSentPos.tXY[i].x = thisInfo->tCoord.tPos.tXY[i].x;
N				thisInfo->tCoord.tPastSentPos.tXY[i].y = thisInfo->tCoord.tPos.tXY[i].y;
N				thisInfo->tCoord.tPastSentPos.vusS[i] = thisInfo->tCoord.tPos.vusS[i];
N				thisInfo->tCoord.tPastSentPos.vusR[i] = thisInfo->tCoord.tPos.vusR[i];
N//				thisInfo->tCoord.tPastSentPos.vusW[i] = thisInfo->tCoord.tPos.vusW[i];
N//				thisInfo->tCoord.tPastSentPos.vusH[i] = thisInfo->tCoord.tPos.vusH[i];
N				
N#if (REMOVE_EDGE_EN == YES)
X#if (((1==0)) == (0==0))
S				thisInfo->tCoord.tRealPastSentPos1.tXY[i].x = thisInfo->tCoord.tRealPastSentPos.tXY[i].x;
S				thisInfo->tCoord.tRealPastSentPos1.tXY[i].y = thisInfo->tCoord.tRealPastSentPos.tXY[i].y;
N#endif
N				
N				thisInfo->tCoord.tRealPastSentPos.tXY[i].x = pos.x;
N				thisInfo->tCoord.tRealPastSentPos.tXY[i].y = pos.y;
N			}
N			else
N			{
N				uSWIPTouchItem_t tItem;
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S				tItem.tItem00.tInfo.b4FingerID = i + 1;					// id
S				tItem.tItem00.tInfo.b1Status = TOUCH_STATUS_PRESS;		// status
S				tItem.tItem00.tInfo.b6Type = (touchItemType.finger << TOUCH_TYPE_FINGER) |
S									  (touchItemType.glove << TOUCH_TYPE_GLOVE) |
S									  (touchItemType.hover << TOUCH_TYPE_HOVER) |
S									  (touchItemType.passive_stylus << TOUCH_TYPE_PASSIVE_STYLUS) |
S									  (touchItemType.active_stylus << TOUCH_TYPE_ACTIVE_STYLUS) |
S									  (touchItemType.active_stylus_hover << TOUCH_TYPE_ACTIVE_STYLUS_HOVER);
N#else /* USED_SHARP_SPECIFIC_PROTOCOL */
N				tItem.tItem00.tInfo.bTouch = YES;
X				tItem.tItem00.tInfo.bTouch = (0==0);
N				tItem.tItem00.tInfo.bHover = NO;
X				tItem.tItem00.tInfo.bHover = (1==0);
N				tItem.tItem00.tInfo.bScreen = YES;
X				tItem.tItem00.tInfo.bScreen = (0==0);
N				tItem.tItem00.tInfo.bPalm = thisInfo->bIsPalm;
N	#if (ID_MAPPING_CHANGE)
X	#if (((1==0)))
S				tItem.tItem00.tInfo.b4FingerID = Id_Map[i];
N	#else
N				tItem.tItem00.tInfo.b4FingerID = i + 1;
N	#endif
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N				tItem.tItem00.ucRowStart = 0;
N				SET_POS(tItem, old_pos);
X				do{ (tItem). tItem00 . ucXHigh = ((old_pos). x >> 8) & 0xFF; (tItem). tItem00 . ucYHigh = ((old_pos). y >> 8) & 0xFF; (tItem). tItem00 . ucXLow = (old_pos). x & 0xFF; (tItem). tItem00 . ucYLow = (old_pos). y & 0xFF; } while(0);
N				tItem.tItem00.ucWidth = MIN(thisInfo->tCoord.tPos.vusR[i], UINT8_MAX);
X				tItem.tItem00.ucWidth = ( ( ( thisInfo->tCoord . tPos . vusR[i] ) < ( 255 ) ) ? ( thisInfo->tCoord . tPos . vusR[i] ) : ( 255 ) );
N
N				//To do	-> Old Width, Height
N//				tItem.tItem02.usWidth = thisInfo->tCoord.tPos.vusW[i];
N//				tItem.tItem02.usHeight = thisInfo->tCoord.tPos.vusH[i];
N				
N				if(id == 0)
N				{
N					tItem.tItem00.usStrength = thisInfo->tCoord.tPos.vusS[i];
N				}
N#if !(ID_MAPPING_CHANGE)
X#if !(((1==0)))
N				protocol_swip_PushTouchEvent(&tItem);
N#endif				
N				protocol_hid_PushTouchEvent(&tItem);
N				
N			}
N#if USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE
X#if ((1==0))
S			thisInfo->bIsIdleToActive = NO;
N#endif /* USED_IDLE_CORNER_EDGE_DEBOUNC_DISABLE */
N		}
N		else if (thisInfo->tCoord.tPastSentPos.vusS[i] > 0)
N		{
N			
N		#if (SWIP_QUEUE_MODE == 2)
X		#if ((2) == 2)
N			thisInfo->bTouchOffFlag = 1;
N		#endif
N			
N			uSWIPTouchItem_t tItem;
N#if USED_SHARP_SPECIFIC_PROTOCOL
X#if ((1==0))
S			tItem.tItem00.tInfo.b4FingerID = i + 1;					// id
S			tItem.tItem00.tInfo.b1Status = TOUCH_STATUS_RELEASE;		// status
S			tItem.tItem00.tInfo.b6Type = (touchItemType.finger << TOUCH_TYPE_FINGER) |
S								  (touchItemType.glove << TOUCH_TYPE_GLOVE) |
S								  (touchItemType.hover << TOUCH_TYPE_HOVER) |
S								  (touchItemType.passive_stylus << TOUCH_TYPE_PASSIVE_STYLUS) |
S								  (touchItemType.active_stylus << TOUCH_TYPE_ACTIVE_STYLUS) |
S								  (touchItemType.active_stylus_hover << TOUCH_TYPE_ACTIVE_STYLUS_HOVER);
N#else /* USED_SHARP_SPECIFIC_PROTOCOL */
N			tItem.tItem00.tInfo.bTouch = NO;
X			tItem.tItem00.tInfo.bTouch = (1==0);
N			tItem.tItem00.tInfo.bHover = NO;
X			tItem.tItem00.tInfo.bHover = (1==0);
N			tItem.tItem00.tInfo.bScreen = YES;
X			tItem.tItem00.tInfo.bScreen = (0==0);
N			tItem.tItem00.tInfo.bPalm = thisInfo->bIsPalm;
N	#if (ID_MAPPING_CHANGE)
X	#if (((1==0)))
S			tItem.tItem00.tInfo.b4FingerID = Id_Map[i];
N	#else
N			tItem.tItem00.tInfo.b4FingerID = i + 1;
N	#endif
N#endif /* USED_SHARP_SPECIFIC_PROTOCOL */
N			tItem.tItem00.ucRowStart = 0;
N
N#if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
X#if ((1==0))
S			if(i == 0)algorithm_BigFingerEdgeAccTest(&pos,&old_pos,1);			
N#endif
N			
N			SET_POS(tItem, old_pos);	
X			do{ (tItem). tItem00 . ucXHigh = ((old_pos). x >> 8) & 0xFF; (tItem). tItem00 . ucYHigh = ((old_pos). y >> 8) & 0xFF; (tItem). tItem00 . ucXLow = (old_pos). x & 0xFF; (tItem). tItem00 . ucYLow = (old_pos). y & 0xFF; } while(0);	
N			tItem.tItem00.ucWidth = 0;
N			//			thisInfo->bGhostState = NO;
N
N			if(id == 0)
N			{
N				tItem.tItem00.usStrength =thisInfo->tCoord.tPos.vusS[i];
N			}
N
N			thisInfo->tCoord.bFirstLongDistanceMoved[i] = NO;
X			thisInfo->tCoord.bFirstLongDistanceMoved[i] = (1==0);
N#if !(ID_MAPPING_CHANGE)
X#if !(((1==0)))
N			protocol_swip_PushTouchEvent(&tItem);
N#endif
N			protocol_hid_PushTouchEvent(&tItem);
N		}
N		thisInfo->tCoord.tPastSentPos.vusS[i] = thisInfo->tCoord.tPos.vusS[i];
N	}
N#if (SWIP_QUEUE_MODE)
X#if ((2))
N	if(thisInfo->bQueueStart == 1){
N	#if (SWIP_QUEUE_MODE == 2)
X	#if ((2) == 2)
N		if(thisInfo->QueueFront == thisInfo->QueueRear || thisInfo->bTouchOffFlag )
N	#endif
N		{
N			thisInfo->QueueRear++;
N			thisInfo->QueueRear = (thisInfo->QueueRear) % SWIP_QUEUE_SIZE;
X			thisInfo->QueueRear = (thisInfo->QueueRear) % (7);
N		}
N	}
N#endif	
N	//uA A I AI.
N	thisInfo->tCoord.tPastSentPos.sFinger_ = thisInfo->tCoord.tPos.sFinger_;
N//	thisInfo->bWasPalm = thisInfo->bIsPalm;
N
N//	if ((CheckI2CReady() == 0))
N#if !(ID_MAPPING_CHANGE)
X#if !(((1==0)))
N	protocol_swip_SendTouchEvent(); //  
N#endif
N//	 protocol_hid_SendTouchEvent();
N
N#ifdef JOSH3_PEN_TEST
S	SendPenData();
N#else
N#ifdef ADD_TOUCH
N	SendTouchData();  // Touch en (choigs)
N#endif
N#endif
N#if (ID_MAPPING_CHANGE)	
X#if (((1==0)))	
S	if(thisInfo->tCoord.tPos.sFinger_ == 0 && thisInfo->tCoord.tPastPos[0].sFinger_ == 0){if(NonTouchCnt++ > 32767)NonTouchCnt=30;}
S	else NonTouchCnt = 0;
S	
S	if(NonTouchCnt >= 30)
S	{
S		NewID = 30;
S		memset(Id_Map,0,sizeof(Id_Map));
S	}
N#endif	
N	hal_clear_overlap_pen();
N
N#if BIG_FINGER_EDGE_ACC_TEST_ALGO_EN
X#if ((1==0))
S	if(thisInfo->tCoord.tPos.sFinger_==0 || thisInfo->tCoord.tPos.sFinger_>1)
S	{
S		if(bBigFingerEdgeTestEn[0] || bBigFingerEdgeTestEn[1] || bBigFingerEdgeTestEn[2] || bBigFingerEdgeTestEn[3])
S		{
S			ucBigFingerEdgeTest_MoveEventTHD_Change=0;
S			memset(bBigFingerEdgeTestFlag,0,sizeof(bBigFingerEdgeTestFlag));
S			if(thisInfo->tCoord.tPos.sFinger_==0)bBigFingerEdgeTestEn[0]=bBigFingerEdgeTestEn[1]=bBigFingerEdgeTestEn[2]=bBigFingerEdgeTestEn[3]=0;
S		}
S	}	
N#endif	
N}
N
N#if USED_ESD_RECOVERY_CODE
X#if ((1==0))
Sbool_t algorithm_check_abnormal_rawdata(void)
S{
S	uint8_t	 RoicCnt, MuxCnt, RowIdx, ColIdx, ColCnt;
S	uint16_t RefVal;
S	
S	if(thisInfo->usAbnormalRawdataNodeCnt >= ABNORMAL_RAWDATA_CNT_THD
S	|| thisInfo->usAbnormalRawdataFrameCnt1 >= ABNORMAL_RAWDATA_FRAME_THD
S	|| thisInfo->usAbnormalRawdataFrameCnt2 >= ABNORMAL_RAWDATA_FRAME_THD)
S	{
S		return YES;
S	}
S
S	for(RoicCnt = 0; RoicCnt < 2*SRIC_NUM; RoicCnt++)
S	{
S		ColIdx = RoicCnt * R0_ALIGNED_COL_LEN;
S		RefVal = HAL_READ_RAW_IMAGE(0, ColIdx);
S		for(MuxCnt = 1; MuxCnt < FINGER_MUX_NUM; MuxCnt++)
S		{
S			RowIdx = MuxCnt * R0_ALIGNED_ROW_LEN;
S			if(HAL_READ_RAW_IMAGE(RowIdx, ColIdx) != RefVal)
S			{
S				break;
S			}
S			else if(MuxCnt == FINGER_MUX_NUM - 1)
S			{
S				return YES;
S			}
S		}
S		
S		for(MuxCnt = 1; MuxCnt < FINGER_MUX_NUM; MuxCnt++)
S		{
S			RowIdx = MuxCnt * R0_ALIGNED_ROW_LEN;
S			for(ColCnt = 1; ColCnt < R0_ALIGNED_COL_LEN; ColCnt++)
S			{
S				if(HAL_READ_RAW_IMAGE(RowIdx, ColIdx) != HAL_READ_RAW_IMAGE(RowIdx, ColIdx + ColCnt))
S				{
S					break;
S				}
S				else if(ColCnt == R0_ALIGNED_COL_LEN - 1)
S				{
S					return YES;
S				}
S			}
S		}
S	}
S	return NO;
S}
N#endif /* USED_ESD_RECOVERY_CODE */ 
N
N#if USED_RF_NOISE_RECOVERY_CODE
X#if ((1==0))
Sbool_t algorithm_check_abnormal_deltadata(void)
S{	
S	if(thisInfo->usAbnormalDeltaFrameCnt1 >= ABNORMAL_DELTA_FRAME_THD)
S	{
S		return YES;
S	}
S
S	if(thisInfo->usAbnormalDeltaFrameCnt2 < ABNORMAL_DELTA_CHECK_FRAME_NUM)
S	{
S		thisInfo->usAbnormalDeltaFrameCnt2++;
S		if(thisInfo->tDelta.iMaxStrength > ABNORMAL_DELTA_THD_FOR_RECAL)
S		{
S			return YES;
S		}
S	}
S	return NO;
S}
N#endif /* USED_RF_NOISE_RECOVERY_CODE */
N
Nvoid algorithm_check_recal_cond(void)
N{
N	thisInfo->bIsRecalCond  = NO;
X	thisInfo->bIsRecalCond  = (1==0);
N	thisInfo->bIsRecalCond2 = NO;
X	thisInfo->bIsRecalCond2 = (1==0);
N
N	thisInfo->bIsRecalCond = (
N			   (thisInfo->tDelta.iPosSum >= thisModeConf->BaseLine.iRecalCond1_PosSum_Thd)
N			&& ((thisInfo->tDelta.iNegSum + thisInfo->tDelta.iPosSum) < thisModeConf->BaseLine.iRecalCond1_AccSum_Thd)
N	);
N	thisInfo->bIsRecalCond2 = (
N			   (thisInfo->bTouchExpect == NO)
X			   (thisInfo->bTouchExpect == (1==0))
N			&& (thisInfo->tDelta.iNegSum < thisModeConf->BaseLine.iRecalCond2_AccSum_Thd)
N	);
N}
N
Nbool_t algorithm_is_recalibrate(void)
N{
N  
N    /*
N     * Debouncing.
N     */
N    if (thisInfo->bIsRecalCond)
N    {
N        if (thisInfo->iRecalCondCnt <= thisModeConf->BaseLine.ucRecalCond1_WaitCnt)
N        {
N            thisInfo->iRecalCondCnt++;
N        }
N        else
N        {
N            thisInfo->iRecalCondCnt = 0;   // added
N            return YES;
X            return (0==0);
N        }
N    }
N    else if (thisInfo->bIsRecalCond2)
N    {
N        if (thisInfo->iRecalCond2Cnt <= thisModeConf->BaseLine.ucRecalCond2_WaitCnt)     // 300 msec
N        {
N        	thisInfo->iRecalCond2Cnt++;
N        }
N        else
N        {
N        	thisInfo->iRecalCond2Cnt = 0;   // added
N            return YES;
X            return (0==0);
N        }
N    }
N    else
N    {
N        thisInfo->iRecalCondCnt = 0;
N        thisInfo->iRecalCond2Cnt = 0;
N    }
N
N    return NO;
X    return (1==0);
N}
N
N#define PALM_VALID_AREA		(22 << POS_BOOST_SHIFT_)
N#define PALM_KEEP_FRM		(10)
Nvoid public_func_PalmTouch_handler(void)
N{
N	static uint8_t ucFrameCnt[POSBUF_]  = {0,};
X	static uint8_t ucFrameCnt[10]  = {0,};
N//	static uint16_t usPrevMaxCellNum[POSBUF_]  = {0,}; // NOTE : Not used!!
N	static uint8_t ucPalmContCnt[POSBUF_]  = {0,};
X	static uint8_t ucPalmContCnt[10]  = {0,};
N	static uint8_t ucParNum[POSBUF_]  = {0,};
X	static uint8_t ucParNum[10]  = {0,};
N	static tXY_t ucPalmPos[POSBUF_] ;
X	static tXY_t ucPalmPos[10] ;
N	static tRect_t ucPalmRect[POSBUF_] ;
X	static tRect_t ucPalmRect[10] ;
N	uint8_t ucParCnt[POSBUF_] = {0,};
X	uint8_t ucParCnt[10] = {0,};
N	uint8_t ucParBF[POSBUF_] = {0,};
X	uint8_t ucParBF[10] = {0,};
N	bool_t bIsPalm[POSBUF_] = {0,};
X	bool_t bIsPalm[10] = {0,};
N	uint8_t ucPalmExpect[POSBUF_] = {0,};
X	uint8_t ucPalmExpect[10] = {0,};
N	int cl;
N	
N//    if(!sptPalmTouchConf->bEnable) return;
N
N//	tMemConf_t       * ptMemConf = (tMemConf_t *)param1;
N//	tAlgorithmInfo_t * ptInfo     = (tAlgorithmInfo_t *)param2;
N
N//	sptPalmTouchConf->bPalmExpect = NO;
N
N	thisInfo->bIsPalm = NO;
X	thisInfo->bIsPalm = (1==0);
N	
N	for( cl=MAX_TOUCH_; cl--; )
X	for( cl=(10); cl--; )
N	{
N		if(thisInfo->tCoord.tPos.vusR[cl] != 0)
N		{
N			if(thisInfo->tCoord.tPos.vusR[cl] > thisModeConf->Palm.usPalmLevel)
N			{
N				bIsPalm[cl] = YES;
X				bIsPalm[cl] = (0==0);
N				ucParNum[cl] = cl;
N				ucPalmPos[cl] = thisInfo->tCoord.tPos.tXY[cl];
N			}
N//			else if(ucFrameCnt[cl] < 10
N//				&& ((thisInfo->tCoord.tPos.vusR[cl] > 10
N//				&& (int16_t)(thisInfo->tCoord.tPos.vusR[cl] - usPrevMaxCellNum[cl]) > 3 )
N//				|| ((int16_t)(thisInfo->tCoord.tPos.vusR[cl] - usPrevMaxCellNum[cl]) > (3*2+1))))
N//			{
N//				thisInfo->tCoord.tPos.vusS[cl] = 0;
N//				ucPalmExpect[cl] = 1;
N//			}
N			else
N			{
N				int pl, i;
N				uint8_t ucOverlap[POSBUF_] = {0,};
X				uint8_t ucOverlap[10] = {0,};
N				uint8_t ucOverlapCnt = 0;
N
N				for( pl=MAX_TOUCH_; pl--; )
X				for( pl=(10); pl--; )
N				{
N					if(ucPalmContCnt[pl] != 0)
N					{
N						if(ucPalmRect[pl].rs <= thisInfo->tCoord.tPos.rect[cl].re && thisInfo->tCoord.tPos.rect[cl].rs <= ucPalmRect[pl].re)
N						{
N							if(ucPalmRect[pl].cs <= thisInfo->tCoord.tPos.rect[cl].ce && thisInfo->tCoord.tPos.rect[cl].cs <= ucPalmRect[pl].ce)
N								ucOverlap[ucOverlapCnt++] = pl;
N						}
N					}
N				}
N
N				if(ucOverlapCnt != 0)
N				{
N					if(ucOverlapCnt > 1)
N					{
N						int palm_dist;
N						int min_dist = INT32_MAX;
X						int min_dist = 2147483647;
N
N						for(i=0; i<ucOverlapCnt; i++)
N						{
N							palm_dist = algorithm_coord_calc_distance(ucPalmPos[ucOverlap[i]], thisInfo->tCoord.tPos.tXY[cl]);
N							if(min_dist > palm_dist)
N								min_dist = palm_dist, pl = ucOverlap[i];
N						}
N					}
N					else
N						pl = ucOverlap[0];
N
N					bIsPalm[cl] = YES;
X					bIsPalm[cl] = (0==0);
N					ucParCnt[pl]++;
N					ucParBF[pl] |= _BV(cl);
X					ucParBF[pl] |= ( 1 << (cl) );
N					if(ucPalmContCnt[cl] == 0)
N						ucParNum[cl] = ucParNum[pl];
N
N					ucPalmPos[cl] = thisInfo->tCoord.tPos.tXY[cl];
N				}
N			}
N
N			if( ucFrameCnt[cl] < 10 )
N				ucFrameCnt[cl]++;
N		}
N		else
N			ucFrameCnt[cl] = 0;
N	}
N
N	for( cl=MAX_TOUCH_; cl--;)
X	for( cl=(10); cl--;)
N	{
N		if(ucParCnt[cl] > 1)
N		{
N			int max_palm_num = -1;
N			int max_palm_size = 0;
N
N			if(bIsPalm[cl] == NO)
X			if(bIsPalm[cl] == (1==0))
N			{
N				int pl;
N
N				for( pl=MAX_TOUCH_; pl--;)
X				for( pl=(10); pl--;)
N				{
N					if((ucParBF[cl] & _BV(pl)) != 0)
X					if((ucParBF[cl] & ( 1 << (pl) )) != 0)
N					{
N						if(max_palm_size < thisInfo->tCoord.tPos.vusR[pl])
N						{
N							max_palm_num = pl;
N							max_palm_size = thisInfo->tCoord.tPos.vusR[pl];
N						}
N					}
N				}
N
N				for( pl=MAX_TOUCH_; pl--;)
X				for( pl=(10); pl--;)
N				{
N					if((ucParBF[cl] & _BV(pl)) != 0)
X					if((ucParBF[cl] & ( 1 << (pl) )) != 0)
N						ucParNum[pl] = max_palm_num;
N				}
N
N				ucPalmContCnt[cl] = 0;
N			}
N		}
N	}
N
N	for( cl=MAX_TOUCH_; cl--;)
X	for( cl=(10); cl--;)
N	{
N		if(bIsPalm[cl] == YES)
X		if(bIsPalm[cl] == (0==0))
N		{
N			if(ucParNum[cl] != cl)
N			{
N				int pl = ucParNum[cl];
N				int palm_dist;
N
N				if(thisInfo->tCoord.tPos.vusR[pl] == 0 && ucPalmContCnt[cl] != 0)
N				{
N					int pcl;
N					int max_palm_num = -1;
N					int max_palm_size = 0;
N
N					for( pcl=MAX_TOUCH_; pcl--;)
X					for( pcl=(10); pcl--;)
N					{
N						if(pcl != cl && bIsPalm[pcl] == YES)
X						if(pcl != cl && bIsPalm[pcl] == (0==0))
N						{
N							if(ucPalmRect[pl].rs <= thisInfo->tCoord.tPos.rect[pcl].re && thisInfo->tCoord.tPos.rect[pcl].rs <= ucPalmRect[pl].re)
N							{
N								if(max_palm_size < thisInfo->tCoord.tPos.vusR[pcl])
N									max_palm_size = thisInfo->tCoord.tPos.vusR[pcl], max_palm_num = pcl;
N							}
N						}
N					}
N
N					if(max_palm_num != -1)
N					{
N
N						ucParNum[cl] = max_palm_num;
N						for( pcl=MAX_TOUCH_; pcl--;)
X						for( pcl=(10); pcl--;)
N						{
N							if(ucPalmContCnt[pcl] != 0)
N							{
N								if(ucParNum[pcl] == pl)
N									ucParNum[pcl] = max_palm_num;
N							}
N						}
N					}
N					else
N						ucParNum[cl] = cl;
N				}
N
N				if(ucPalmContCnt[pl] != 0)
N				{
N					palm_dist = algorithm_coord_calc_distance(ucPalmPos[pl], ucPalmPos[cl]);
N					if(PALM_VALID_AREA < palm_dist)
X					if((22 << (8)) < palm_dist)
N						bIsPalm[cl] = NO;
X						bIsPalm[cl] = (1==0);
N				}
N				else
N					bIsPalm[cl] = NO;
X					bIsPalm[cl] = (1==0);
N			}
N		}
N
N		if(bIsPalm[cl] == YES)
X		if(bIsPalm[cl] == (0==0))
N		{
N			ucPalmExpect[cl] = 1;
N			ucPalmContCnt[cl] = PALM_KEEP_FRM;
X			ucPalmContCnt[cl] = (10);
N			ucPalmRect[cl] = thisInfo->tCoord.tPos.rect[cl];
N			ucPalmPos[cl] = thisInfo->tCoord.tPos.tXY[cl];
N			thisInfo->tCoord.tPos.vusS[cl] = 0;
N
N			if(ucPalmRect[cl].rs > 0)
N				ucPalmRect[cl].rs--;
N			if(ucPalmRect[cl].re < (ROW_MAX - 1))
X			if(ucPalmRect[cl].re < ((48) - 1))
N				ucPalmRect[cl].re++;
N			if(ucPalmRect[cl].cs > 0)
N				ucPalmRect[cl].cs--;
N			if(ucPalmRect[cl].ce < (COL_MAX - 1))
X			if(ucPalmRect[cl].ce < ((96) - 1))
N				ucPalmRect[cl].ce++;
N			
N			thisInfo->bIsPalm = YES;
X			thisInfo->bIsPalm = (0==0);
N			thisInfo->tCoord.tPos.sFinger_--;
N		}
N	}
N
N	for( cl=MAX_TOUCH_; cl--;)
X	for( cl=(10); cl--;)
N	{
N		if(ucPalmExpect[cl] != 0)
N		{
N			int pl;
N//			tRect_t ori_rect, cmp_rect; // NOTE : not used
N			tRect_t ori_rect;
N
N			int offset = 1;
N			
N            if(thisInfo->tCoord.tPos.rect[cl].rs > (offset-1))
N				ori_rect.rs = thisInfo->tCoord.tPos.rect[cl].rs - offset;
N            else
N                ori_rect.rs = 0;
N			if(thisInfo->tCoord.tPos.rect[cl].re < (ROW_MAX - offset))
X			if(thisInfo->tCoord.tPos.rect[cl].re < ((48) - offset))
N				ori_rect.re = thisInfo->tCoord.tPos.rect[cl].re + offset;
N            else
N                ori_rect.re = ROW_MAX - 1;
X                ori_rect.re = (48) - 1;
N			if(thisInfo->tCoord.tPos.rect[cl].cs > (offset-1))
N				ori_rect.cs = thisInfo->tCoord.tPos.rect[cl].cs - offset;
N            else
N                ori_rect.cs = 0;
N			if(thisInfo->tCoord.tPos.rect[cl].ce < (COL_MAX - offset))
X			if(thisInfo->tCoord.tPos.rect[cl].ce < ((96) - offset))
N				ori_rect.ce = thisInfo->tCoord.tPos.rect[cl].ce + offset;
N            else
N                ori_rect.ce = COL_MAX - 1;
X                ori_rect.ce = (96) - 1;
N            
N            for( pl=MAX_TOUCH_; pl--;)
X            for( pl=(10); pl--;)
N			{
N				if(thisInfo->tCoord.tPos.vusS[pl])
N				{
N					if(ori_rect.rs <= thisInfo->tCoord.tPos.rect[pl].re+1 && thisInfo->tCoord.tPos.rect[pl].rs-1 <= ori_rect.re)
N					{
N						if(ori_rect.cs <= thisInfo->tCoord.tPos.rect[pl].ce+1 && thisInfo->tCoord.tPos.rect[pl].cs-1 <= ori_rect.ce)
N						{
N							thisInfo->tCoord.tPos.vusS[pl] = 0;
N						}
N					}
N				}
N			}
N		}
N
N		if(ucPalmContCnt[cl] != 0)
N			ucPalmContCnt[cl]--;
N
N//		usPrevMaxCellNum[cl] = thisInfo->tCoord.tPos.vusR[cl];  // NOTE : Not used!!		
N	}
N
N//	public_protocol_LogCode(LT_DIAGNOSIS, (220)/*System is Entered!*/);
N}
N
Nint16_t sLFOffsetRow[ROW_MAX] = {0,};
Xint16_t sLFOffsetRow[(48)] = {0,};
N/*
N *  Line Even Col Filter   , 951usec  
N */
Nvoid alogorithm_linefilter_2(void)
N{
N	uint32_t r, c;
N	uint32_t i, j;
N	int16_t d;
N	int16_t SortBufCol[COL_MAX], TempBuf;
X	int16_t SortBufCol[(96)], TempBuf;
N	uint8_t sort_cnt, sort_range;
N	int16_t sub_offset;
N	uint16_t * pBaseImage;
N	int Max_Val, Min_Val;
N	int lDiff, lDiffSum = 0, lDiffSumCnt = 0;
N	int min_delta_th = (thisModeConf->SensingFilter.ucMinDeltaTh << ptModuleModeConf->ucOvrShift);
N	int lUpperTHD = thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift, lLowTHD = thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
N//	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
N
N#if (ROW_MAX == 36)
X#if ((48) == 36)
S	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35};
S#elif (ROW_MAX == 45)
X#elif ((48) == 45)
S	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44};
S#elif (ROW_MAX == 47)
X#elif ((48) == 47)
S	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46};
N#elif (ROW_MAX == 48)
X#elif ((48) == 48)
N	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47};
N#elif (ROW_MAX == 50)
S	uint8_t do_row[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49};
N#endif
N	uint8_t row_cnt = sizeof(do_row);
N	uint8_t real_row;
N	
N	sort_cnt = 4;//(uint8_t)(((int)COL_MAX * 5)/100);
N	sort_range = COL_MAX/4 + COL_MAX%4;
X	sort_range = (96)/4 + (96)%4;
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
S	{
S		pBaseImage = g_pFingerBaseImage;
S	}
S	else
S	{
S		pBaseImage = g_pFingerHop1BaseImage;
S	}
N#else /* USED_NOISE_HOPPING_FREQ */
N	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
N#endif /* USED_NOISE_HOPPING_FREQ */
N	
N	for(r = 0; r < row_cnt; r++)
N	{
N		real_row = do_row[r];
N		lDiffSum = 0, lDiffSumCnt = 0;
N		Max_Val = INT16_MIN, Min_Val = INT16_MAX;
X		Max_Val = -32768, Min_Val = 32767;
N		for( c = 0; c < sort_range; c++ )
N		{
N			SortBufCol[c] = lDiff = (int16_t)HAL_READ_RAW_IMAGE(real_row, (c*4)) - (int16_t)pBaseImage[real_row*COL_MAX + c*4];
X			SortBufCol[c] = lDiff = (int16_t)FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[real_row][(c*4)] - (int16_t)pBaseImage[real_row*(96) + c*4];
N			
N			if(lDiff < lUpperTHD && lDiff > lLowTHD)
N			{
N				if(Max_Val < lDiff)Max_Val = lDiff;
N				if(Min_Val > lDiff)Min_Val = lDiff;
N				lDiffSum += lDiff;
N				lDiffSumCnt++;
N			}
N		}
N		
N		if(min_delta_th && Min_Val < -min_delta_th && thisInfo->tLabel.ucPalmCnt < 10)
N		{
N			if(lDiffSumCnt > 3)
N			{
N				sLFOffsetRow[real_row] = lDiffSum / ((int16_t)lDiffSumCnt);
N			}
N		}
N		else
N		{
N			for( i=0; i<=(sort_cnt); i++ )
N			{
N				for( j=(i+1); j<sort_range; j++ )
N				{
N					if( SortBufCol[i] > SortBufCol[j] )
N					{
N						TempBuf = SortBufCol[i];
N						SortBufCol[i] = SortBufCol[j];
N						SortBufCol[j] = TempBuf;
N					}
N				}
N			}
N			TempBuf = SortBufCol[sort_cnt];
N			
N			sLFOffsetRow[real_row] = TempBuf;
N		}
N	}
N
N#if !FAST_LF_EN		
X#if !((1==0))		
N	for(r = 0; r < row_cnt; r++)
N	{
N		real_row = do_row[r];
N		for( c=0; c<COL_MAX; c++ )
X		for( c=0; c<(96); c++ )
N		{
N			d = (int16_t)HAL_READ_RAW_IMAGE(real_row, c);
X			d = (int16_t)FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[real_row][c];
N			sub_offset = sLFOffsetRow[real_row];
N			d = d - sub_offset;
N			if(d < 0)
N			{
N				d = 0;
N			}
N			HAL_WRITE_RAW_IMAGE(real_row, c, (uint16_t)d);
X			FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[real_row][c] = (uint16_t)d;
N		}
N	}
N#endif
N}
N#if FINGER_LF_VER1_EN
X#if ((1==0))
Svoid alogorithm_linefilter(eSENSING_MODE_t eSensingMode)
S{
S	uint32_t r, c;
S	uint16_t r_pos;
S	int16_t LINE_FILTER_UPPER_LIMIT			= thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
S	int16_t LINE_FILTER_LOWER_LIMIT			= thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
S	uint8_t LINE_FILTER_COL_OFFSET			= (thisModeConf->SensingFilter.ucLineFilterColOffset);
S	
S	int16_t lDiff;
S	int16_t lDiffSum = 0, lDiffSum2 = 0;
S	uint32_t lDiffSumCnt = 0, lDiffSumCnt2 = 0;
S	int32_t lLowTHD, lUpperTHD;
S	uint16_t * pBaseImage;
S	uint16_t rawdata;
S	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
S
S	lUpperTHD = LINE_FILTER_UPPER_LIMIT;
S	lLowTHD = LINE_FILTER_LOWER_LIMIT;
S
S#if USED_NOISE_HOPPING_FREQ
S	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
S	{
S		pBaseImage = g_pFingerBaseImage;
S	}
S	else
S	{
S		pBaseImage = g_pFingerHop1BaseImage;
S	}
S//	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
S#else /* USED_NOISE_HOPPING_FREQ */
S	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
S#endif /* USED_NOISE_HOPPING_FREQ */
S
S	int Max_Val, Min_Val;
S	int LineFilterRepeatTH = thisModeConf->SensingFilter.ucLineFilterRepeatTH << ptModuleModeConf->ucOvrShift;
S	for(r=0; r<ROW_MAX; r++)
S	{
S		lDiffSumCnt2 = 0;
S		lDiffSum2 = 0;
S		
S		Max_Val = 0;
S//		Avg_Val = 0;
S		Min_Val = 32767;
S		r_pos = r*COL_MAX;
S		for(c = 0; c < COL_MAX; c+=LINE_FILTER_COL_OFFSET)
S		{
S			rawdata = HAL_READ_RAW_IMAGE(r, c);
S			{
S				lDiff = (int16_t)(rawdata - pBaseImage[r_pos+c]);
S				//pBaseImage += LINE_FILTER_COL_OFFSET;
S				if(lDiff < lUpperTHD && lDiff > lLowTHD)
S				{
S					if(Max_Val < lDiff)Max_Val = lDiff;
S					if(Min_Val > lDiff)Min_Val = lDiff;
S					lDiffSum2 += lDiff;
S					lDiffSumCnt2++;
S				}
S			}
S		}
S
S		if(LineFilterRepeatTH > 0 && Max_Val - Min_Val > LineFilterRepeatTH  &&
S				(eLocalFingerOPType!=ACTIVEPEN_TYPE_LOCAL_MS || (eLocalFingerOPType==ACTIVEPEN_TYPE_LOCAL_MS && hal_Info_GetPenDectionEnable() == NO))
S				&& Min_Val > thisModeConf->SensingFilter.cLineFilterMinTH<<ptModuleModeConf->ucOvrShift && thisInfo->bLineFilterRepeatCheck)
S		{
S			lDiffSumCnt = 0;
S			lDiffSum = 0;
S			for(c = 0; c < COL_MAX; c+=LINE_FILTER_COL_OFFSET)
S			{
S				rawdata = HAL_READ_RAW_IMAGE(r, c);
S				{
S					lDiff = (int16_t)(rawdata - pBaseImage[r_pos+c]);
S					if(lDiff < lUpperTHD && lDiff > lLowTHD)
S					{
S						if(abs(Max_Val - lDiff) > abs(Min_Val - lDiff))
S						{
S							lDiffSum += lDiff;
S							lDiffSumCnt++;
S						}
S					}
S				}
S			}
S		}
S		else
S		{
S			lDiffSumCnt = lDiffSumCnt2;
S			lDiffSum = lDiffSum2;
S		}
S		
S		if(lDiffSumCnt > 3)
S		{
S			sLFOffsetRow[r] = lDiffSum / ((int16_t)lDiffSumCnt);
S
S#if !FAST_LF_EN			
S			for(c = 0; c < COL_MAX; c++)
S			{
S				rawdata = HAL_READ_RAW_IMAGE(r, c);
S				if(rawdata > sLFOffsetRow[r])
S				{
S					lDiff = (((int16_t)rawdata) - sLFOffsetRow[r]);
S					if(lDiff < 0)lDiff = 0;
S					HAL_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
S				}
S			}
S#endif
S		}
S	}
S}
N#endif
Nvoid alogorithm_linefilter_simple(eSENSING_MODE_t eSensingMode)
N{
N	uint32_t r, c, pos;
N	int16_t LINE_FILTER_UPPER_LIMIT			= thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
N	int16_t LINE_FILTER_LOWER_LIMIT			= thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
N	uint8_t LINE_FILTER_COL_OFFSET			= (thisModeConf->SensingFilter.ucLineFilterColOffset);
N	
N	int16_t lDiff;
N	int16_t lDiffSum = 0;//, lDiffSum2 = 0;
N	uint32_t lDiffSumCnt = 0;//, lDiffSumCnt2 = 0;
N	int32_t lLowTHD, lUpperTHD;
N	uint16_t * pBaseImage;
N//	uint16_t rawdata;
N//	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
N
N	lUpperTHD = LINE_FILTER_UPPER_LIMIT;
N	lLowTHD = LINE_FILTER_LOWER_LIMIT;
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
S	{
S		pBaseImage = g_pFingerBaseImage;
S	}
S	else
S	{
S		pBaseImage = g_pFingerHop1BaseImage;
S	}
S//	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
N#else /* USED_NOISE_HOPPING_FREQ */
N	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N	pos = 0;
N	for(r=0; r< ROW_MAX; r++, pos += COL_MAX)
X	for(r=0; r< (48); r++, pos += (96))
N	{
N		lDiffSumCnt = 0;
N		lDiffSum = 0;
N
N		for(c = 0; c < COL_MAX; c+=LINE_FILTER_COL_OFFSET)
X		for(c = 0; c < (96); c+=LINE_FILTER_COL_OFFSET)
N		{
N			lDiff = (int16_t)(HAL_READ_RAW_IMAGE(r, c) - pBaseImage[pos+c]);
X			lDiff = (int16_t)(FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c] - pBaseImage[pos+c]);
N			if(lDiff < lUpperTHD && lDiff > lLowTHD)
N			{
N				lDiffSum += lDiff;
N				lDiffSumCnt++;
N			}
N		}
N
N		if(lDiffSumCnt > 3)
N		{
N			sLFOffsetRow[r] = lDiffSum / ((int16_t)lDiffSumCnt);
N#if !FAST_LF_EN		
X#if !((1==0))		
N			for(c = 0; c < COL_MAX; c++)
X			for(c = 0; c < (96); c++)
N			{
N				lDiff = (((int16_t)HAL_READ_RAW_IMAGE(r, c)) - sLFOffsetRow[r]);
X				lDiff = (((int16_t)FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c]) - sLFOffsetRow[r]);
N				if(lDiff<0)lDiff=0;
N				HAL_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
X				FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c] = (uint16_t)lDiff;
N			}
N#endif
N		}
N	}
N}
N
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
Svoid alogorithm_linefilter_idle(void)
S{
S	int32_t r, c;
S	int16_t LINE_FILTER_UPPER_LIMIT			= (thisModeConf->SensingFilter.sLineFilterUpLimit_Idle) << ptModuleModeConf->ucIdleOvrShift; //thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
S	int16_t LINE_FILTER_LOWER_LIMIT			= (thisModeConf->SensingFilter.sLineFilterLowLimit_Idle) << ptModuleModeConf->ucIdleOvrShift; //thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
S	uint8_t LINE_FILTER_COL_OFFSET			= (thisModeConf->SensingFilter.ucLineFilterColOffset);
S	int16_t sDiff;
S	int16_t sDiffSum = 0;
S	uint32_t ulDiffSumCnt = 0;
S
S	uint16_t *pBaseImage, *pRawImage;
S
S	pRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
S	pBaseImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
S
S	for(r = 0; r < NI_ROW_MAX; r++)
S	{
S		sDiffSum = 0;
S		ulDiffSumCnt = 0;
S		for(c = 0; c < COL_MAX; c+=LINE_FILTER_COL_OFFSET)
S		{
S			sDiff = (int16_t)(pRawImage[r*COL_MAX+c] - pBaseImage[r*COL_MAX+c]);
S			if(sDiff < LINE_FILTER_UPPER_LIMIT || sDiff > LINE_FILTER_LOWER_LIMIT)
S			{
S				sDiffSum += sDiff;
S				ulDiffSumCnt++;
S			}
S		}
S
S		if(ulDiffSumCnt > 3)
S		{
S			sLFOffsetRow[r] = sDiffSum / ((int16_t)ulDiffSumCnt);
S
S			for(c = 0; c < COL_MAX; c++)
S			{
S				sDiff = (int16_t)pRawImage[r*COL_MAX+c] - sLFOffsetRow[r];
S				if(sDiff < 0)
S					sDiff = 0;
S				pRawImage[r*COL_MAX+c] = (uint16_t)sDiff;
S			}
S		}
S	}
S}
N#endif /* USED_IDLE_MODE_CONTROL */
N
N#if USED_MNT_S3_MODE_FUNCTION
Svoid alogorithm_linefilter_S3(void)
S{
S#define IDLE_LINE_FILTER_UPPER_LIMIT		((50)<<ptModuleModeConf->ucIdleOvrShift) //((16)<<ptModuleModeConf->ucOvrShift)
S#define IDLE_LINE_FILTER_LOWER_LIMIT		(-((50)<<ptModuleModeConf->ucIdleOvrShift)) //(-((16)<<ptModuleModeConf->ucOvrShift))
S
S	uint32_t r, c;	
S	int16_t lDiff;
S	int16_t lDiffSum = 0;
S	uint32_t lDiffSumCnt = 0;
S	int32_t lLowTHD, lUpperTHD;
S	uint16_t * pIdleBaseImage;
S
S	lUpperTHD = IDLE_LINE_FILTER_UPPER_LIMIT;
S	lLowTHD = IDLE_LINE_FILTER_LOWER_LIMIT;
S	pIdleBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
S
S	for(r=0; r<NI_ROW_MAX; r++)
S	{
S		lDiffSumCnt = 0;
S		lDiffSum = 0;
S
S		for(c = 0; c < COL_MAX; c+=2)
S		{
S			lDiff = (int16_t)HAL_NI_READ_RAW_IMAGE(r, c) - (int16_t)(*(pIdleBaseImage));
S			pIdleBaseImage += 2;
S			if(lDiff < lUpperTHD && lDiff > lLowTHD)
S			{
S				lDiffSum += lDiff;
S				lDiffSumCnt++;
S			}
S		}
S
S		if(lDiffSumCnt > 3)
S		{
S			sLFOffsetRow[r] = lDiffSum / ((int16_t)lDiffSumCnt);
S
S			for(c = 0; c < COL_MAX; c++)
S			{
S				lDiff = (((int16_t)HAL_NI_READ_RAW_IMAGE(r, c)) - sLFOffsetRow[r]);
S				if(lDiff<0)lDiff=0;
S				HAL_NI_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
S			}
S		}
S	}
S}
N#endif /* USED_MNT_S3_MODE_FUNCTION */
N
Nint16_t sLFOffsetCol[COL_MAX];
Xint16_t sLFOffsetCol[(96)];
Nvoid alogorithm_vertical_linefilter(eSENSING_MODE_t eSensingMode)
N{
N	uint32_t r, c;
N	int16_t LINE_FILTER_UPPER_LIMIT			= ((15)<<ptModuleModeConf->ucOvrShift); //thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
N	int16_t LINE_FILTER_LOWER_LIMIT			= (-((15)<<ptModuleModeConf->ucOvrShift)); //thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
N	uint8_t LINE_FILTER_ROW_OFFSET			= 3;//(thisModeConf->SensingFilter.ucLineFilterColOffset);
N
N	int16_t lDiff;
N	int16_t lDiffSum = 0;
N	uint32_t lDiffSumCnt = 0;
N	int32_t lLowTHD, lUpperTHD;
N	uint16_t * pBaseImage;
N
N	lUpperTHD = (LINE_FILTER_UPPER_LIMIT>>1);
N	lLowTHD = (LINE_FILTER_LOWER_LIMIT>>1);
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
S	{
S		pBaseImage = g_pFingerBaseImage;
S	}
S	else
S	{
S		pBaseImage = g_pFingerHop1BaseImage;
S	}
S//	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
N#else /* USED_NOISE_HOPPING_FREQ */
N	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N	for(c=0; c<COL_MAX; c++)
X	for(c=0; c<(96); c++)
N	{
N		lDiffSumCnt = 0;
N		lDiffSum = 0;
N		for(r = 0; r < ROW_MAX; r+=LINE_FILTER_ROW_OFFSET)
X		for(r = 0; r < (48); r+=LINE_FILTER_ROW_OFFSET)
N		{
N			lDiff = (int16_t)(HAL_READ_RAW_IMAGE(r, c) - pBaseImage[(r*COL_MAX)+c]);
X			lDiff = (int16_t)(FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c] - pBaseImage[(r*(96))+c]);
N			if(lDiff < lUpperTHD && lDiff > lLowTHD)
N			{
N				lDiffSum += lDiff;
N				lDiffSumCnt++;
N			}
N			else
N			{
N				if(lDiff > lUpperTHD)
N				{
N					lDiff += lUpperTHD;
N					lDiffSumCnt++;
N				}
N				else if(lDiff < lLowTHD)
N				{
N					lDiff += lLowTHD;
N					lDiffSumCnt++;
N				}
N			}
N		}
N
N		if(lDiffSumCnt > 3)
N		{
N			sLFOffsetCol[c] = lDiffSum / ((int16_t)lDiffSumCnt);
N#if !FAST_LF_EN		
X#if !((1==0))		
N			for(r = 0; r < ROW_MAX; r++)
X			for(r = 0; r < (48); r++)
N			{
N				lDiff = (((int16_t)HAL_READ_RAW_IMAGE(r, c)) - sLFOffsetCol[c]);
X				lDiff = (((int16_t)FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c]) - sLFOffsetCol[c]);
N				if(lDiff<0)
N					lDiff=0;
N				HAL_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
X				FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c] = (uint16_t)lDiff;
N			}
N#endif
N		}
N	}
N}
N
Nvoid alogorithm_vertical_linefilter_simple(eSENSING_MODE_t eSensingMode)
N{
N	uint32_t r, c, pos;
N	int16_t LINE_FILTER_UPPER_LIMIT			= thisModeConf->SensingFilter.sLineFilterUpLimit<<ptModuleModeConf->ucOvrShift;
N	int16_t LINE_FILTER_LOWER_LIMIT			= thisModeConf->SensingFilter.sLineFilterLowLimit<<ptModuleModeConf->ucOvrShift;
N//	uint8_t LINE_FILTER_COL_OFFSET			= (thisModeConf->SensingFilter.ucLineFilterColOffset);
N	
N	int16_t sLFOffsetCol[COL_MAX] = {0};
X	int16_t sLFOffsetCol[(96)] = {0};
N	int16_t lDiff;
N	int16_t lDiffSum = 0;
N	uint32_t lDiffSumCnt = 0;
N	int32_t lLowTHD, lUpperTHD;
N	uint16_t * pBaseImage;
N//	uint16_t rawdata;
N//	eActivePenType_t eLocalFingerOPType = hal_Info_GetControlLocalFingerOPType();
N
N	lUpperTHD = LINE_FILTER_UPPER_LIMIT;
N	lLowTHD = LINE_FILTER_LOWER_LIMIT;
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
S	{
S		pBaseImage = g_pFingerBaseImage;
S	}
S	else
S	{
S		pBaseImage = g_pFingerHop1BaseImage;
S	}
S//	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
N#else /* USED_NOISE_HOPPING_FREQ */
N	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N	for(c=0; c<COL_MAX; c++)
X	for(c=0; c<(96); c++)
N	{
N		lDiffSumCnt = 0;
N		lDiffSum = 0;
N		
N		pos = c;
N		for(r = 0; r < ROW_MAX; r+=2,pos += (COL_MAX<<1))
X		for(r = 0; r < (48); r+=2,pos += ((96)<<1))
N		{
N			lDiff = (int16_t)(HAL_READ_RAW_IMAGE(r, c) - pBaseImage[pos]);
X			lDiff = (int16_t)(FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c] - pBaseImage[pos]);
N			if(lDiff < lUpperTHD && lDiff > lLowTHD)
N			{
N				lDiffSum += lDiff;
N				lDiffSumCnt++;
N			}
N		}
N
N		if(lDiffSumCnt > 3)
N		{
N			sLFOffsetCol[c] = lDiffSum / ((int16_t)lDiffSumCnt);
N#if !FAST_LF_EN		
X#if !((1==0))		
N			for(r = 0; r < ROW_MAX; r++)
X			for(r = 0; r < (48); r++)
N			{
N				lDiff = (((int16_t)HAL_READ_RAW_IMAGE(r, c)) - sLFOffsetCol[c]);
X				lDiff = (((int16_t)FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c]) - sLFOffsetCol[c]);
N				if(lDiff<0)lDiff=0;
N				HAL_WRITE_RAW_IMAGE(r, c, (uint16_t)lDiff);
X				FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw[r][c] = (uint16_t)lDiff;
N			}
N#endif
N		}
N	}
N}
N
N#if USED_NORMAL_NI_SENSING
X#if ((1==0))
Sbool_t algorithm_process_ni(void)
S{
S	bool_t bIsRecalState = NO;
S	protocol_LogMatrix(LT_NI_RAW, thisInfo->ucScreenCol, HAL_NI_GET_RAW_IMAGE_PTR(), COL_MAX, NI_ROW_MAX, 84/*Raw Data*/);
S
S	algorithm_baseline_calculate_delta_ni();
S
S	protocol_LogPaddedMatrix(LT_NI_INT, thisInfo->ucScreenCol, HAL_NI_GET_DELTA_IMAGE_PTR(), COL_MAX, NI_ROW_MAX, 81/*MAX Intensity*/);
S
S	return (bIsRecalState == NO);
S}
N#endif /* USED_NORMAL_NI_SENSING */
N
N#define DELTA_MAX 200
N#if LGD_ERROR_FRAME_PROCESS_EN
X#if ((1==0))
Sbool_t LGD_error_frame_process(void)
S{
S	int r,c;
S	bool_t error_flag = 0;
S	static int pre_raw_sum=0;
S	int raw_sum = 0;
S	int rawdata=0, baseline=0;
S	
S	if(thisModeConf->Noise.ucErrorFrameProcess != 1)
S		return NO;
S
S	for(r = 0; r < ROW_MAX; r++)
S	for(c = 0; c < COL_MAX; c++){
S			raw_sum += HAL_READ_RAW_IMAGE(r,c);
S	}
S
S	raw_sum /= (ROW_MAX * COL_MAX);
S	if(pre_raw_sum != 0 && raw_sum - pre_raw_sum > 200)
S		error_flag = YES;
S	else
S		error_flag = NO;
S	
S//	//Raw data recovery	//LBJ_CHECK
S//	{
S//		int delta = 0;
S//		for(r= 0 ; r < ROW_MAX; r++)
S//		for(c = 0; c < COL_MAX; c++){
S//			rawdata = HAL_READ_RAW_IMAGE(r,c);
S//			baseline = HAL_READ_BASELINE_IMAGE(r,c);
S//			delta = rawdata - baseline;
S//			if(delta > DELTA_MAX)		delta = DELTA_MAX;
S//			else if(delta < -DELTA_MAX)	delta = -DELTA_MAX;
S//			rawdata -= delta;
S//			if(error_flag)
S//				HAL_WRITE_RAW_IMAGE(r,c,rawdata);
S//		}
S//		error_flag = NO;
S//	}
S
S	pre_raw_sum = raw_sum;
S	return error_flag;
S}
N#endif
N
Nbool_t algorithm_process(uint8_t mode)
N{
N	bool_t bIsRecalState = NO;
X	bool_t bIsRecalState = (1==0);
N	eSENSING_MODE_t eSensingMode;
N	eSensingMode = HAL_GetSensingMode();
N#if (INTERPOLATION_VER1_En == YES || INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES) 
X#if (((1==0)) == (0==0) || ((1==0)) == (0==0) || ((1==0)) == (0==0)) 
S	uint8_t ucInterpolation_Ver = 0;
N#endif
N	
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S	{
S#define RAWDATA_STABLE_CNT		(2)
S		if (ptAppInfo->eHoppingStatus == FREQ_HOPPING_CHANGED)
S		{
S			ptAppInfo->ucHoppFrameCnt++;
S
S			if (ptAppInfo->ucHoppFrameCnt > RAWDATA_STABLE_CNT)
S			{
S				ptAppInfo->eHoppingStatus = FREQ_HOPPING_NONE;
S			}
S			else
S			{
S				return YES;
S			}
S		}
S	}
N#endif /* USED_NOISE_HOPPING_FREQ */
N	
N#if (INTERPOLATION_VER1_En == YES || INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES) 
X#if (((1==0)) == (0==0) || ((1==0)) == (0==0) || ((1==0)) == (0==0)) 
S	//LBJ_CHECK : ucLocalFingerInterpolation_On
S	if( (thisModeConf->Coord.ucFullFingerInterpolation_On > 0 && mode == FULL_MODE)/* || (thisModeConf->Coord.ucLocalFingerInterpolation_On > 0 && mode == LOCAL_FINGER_MODE)*/ )
S	{
S		if(mode == FULL_MODE)	ucInterpolation_Ver = thisModeConf->Coord.ucFullFingerInterpolation_On;
S		//else ucInterpolation_Ver = thisModeConf->Coord.ucLocalFingerInterpolation_On;
S	}
S	
S#if !USED_DO_NOT_FINGER_TOUCH_REPORT
S	if(ucInterpolation_Ver > 0)
S	{
S
S#if (INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES)
S		if(ucInterpolation_Ver == 2 || ucInterpolation_Ver == 3)
S		{
S	#if (PEN_FINGER_1TOUCH_REPORT == NO)
S			algorithm_PendTouchEvent();
S	#endif
S			algorithm_coord_UpdatePosHistoryInfo();
S		}
S#endif
S		
S		thisInfo->tCoord.bInterpolation_On = YES;
S		
S#if (INTERPOLATION_VER1_En == YES)
S		if(ucInterpolation_Ver == 1)
S		{
S			algorithm_coord_interpolation(ucInterpolation_Ver);
S	#if (PEN_FINGER_1TOUCH_REPORT == NO)
S			algorithm_PendTouchEvent();
S	#endif
S			algorithm_coord_UpdatePosHistoryInfo();
S		}
S#endif
S	}
S	else
S#endif /* !USED_DO_NOT_FINGER_TOUCH_REPORT */
S	{
S		thisInfo->tCoord.bInterpolation_On = NO;
S	}
N#endif
N	
N	algorithm_coord_initialise_pos_buffer();
N
N	memset(sLFOffsetRow, 0, sizeof(sLFOffsetRow));
N	memset(sLFOffsetCol, 0, sizeof(sLFOffsetCol));
N
N	if(!IS_S3_MODE(eSensingMode))
X	if(!(eSensingMode & SM_CHECK_S3_MODE))
N	{
N	#if FINGER_LF_VER1_EN
X	#if ((1==0))
S		if(thisModeConf->SensingFilter.ucLineFilter == 1)
S		{
S			alogorithm_linefilter(eSensingMode);
S		}
N	#endif
N	#if FINGER_LF_VER2_EN
X	#if ((1==0))
S		if(thisModeConf->SensingFilter.ucLineFilter == 2)
S		{
S			alogorithm_linefilter_2();
S		}
N	#endif
N	#if FINGER_LF_VER4_EN
X	#if ((1==0))
S		if(thisModeConf->SensingFilter.ucLineFilter == 4)
S		{
S			alogorithm_linefilter_simple(eSensingMode);
S			alogorithm_vertical_linefilter_simple(eSensingMode);
S		}
N	#endif
N	}
N	// lx98405 check
N	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_GET_RAW_IMAGE_PTR(), COL_MAX, ROW_MAX, 84/*Raw Data*/);
X	protocol_Log((LT_RAWDATA), &(const tLogDataFormat_t) { . ucRow_ = ((48)), . ucCol_ = ((96)), . ucBufferCol_ = ((96)), . tDataType = { . b7Size = sizeof(((uint16_t *)FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw)[0]), . b1Sign = 1 }, . ucLogIndex_ = (84), . tOptions = {. bIsRotated = (1==0), . b6Rightshift_ = (0)}, }, (void*)((uint16_t *)FullSharedBuff . FULLBUF . MatrixU16_FullfingerRaw));
N
N	algorithm_baseline_calculate_delta(mode);
N
N	protocol_LogPaddedMatrix(LT_INTENSITY, COL_MAX, HAL_GET_DELTA_IMAGE_PTR(), COL_MAX, ROW_MAX, 81/*MAX Intensity*/);  // check
X	protocol_Log((LT_INTENSITY), &(const tLogDataFormat_t) { . ucRow_ = ((48)), . ucCol_ = ((96)), . ucBufferCol_ = ((96) + 2*(1)), . tDataType = { . b7Size = sizeof((&(*(((int16_t *)FullSharedBuff . MatrixS16_FingerDelta)+((96) + 2*(1))*((1))+((1)))))[0]), . b1Sign = 1 }, . ucLogIndex_ = (81), . tOptions = {. bIsRotated = (1==0), . b6Rightshift_ = (0)}, }, (void*)(&(*(((int16_t *)FullSharedBuff . MatrixS16_FingerDelta)+((96) + 2*(1))*((1))+((1))))));  
N
N//	algorithm_check_recal_cond();
N//	bIsRecalState = algorithm_is_recalibrate();
N
N#if (USED_FRAME_SKIP_IDLE_MODE_CONTROL == NO)
X#if (((0==0)) == (1==0))
S	if(IS_S3_MODE(eSensingMode) && IS_IDLE_MODE(eSensingMode))
S	{
S		algorithm_baseline_tracking_continuous(mode);
S	}
S	else
N#endif /* (USED_FRAME_SKIP_IDLE_MODE_CONTROL == NO) */
N	{
N		if(bIsRecalState == NO)
X		if(bIsRecalState == (1==0))
N		{
N			// process label image from delta image
N			algorithm_label_process(mode);
N			algorithm_coord_process(FULL_MODE);
N#if (INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES)
X#if (((1==0)) == (0==0) || ((1==0)) == (0==0))
S			if(ucInterpolation_Ver >= 2)
S			{		
S				algorithm_coord_interpolation_v02(ucInterpolation_Ver);
S			}
N#endif
N		}
N
N#if USED_NOISE_HOPPING_FREQ
X#if ((1==0))
S		algorithm_noise_process(eSensingMode);
N#endif /* USED_NOISE_HOPPING_FREQ */
N
N#if PALM_VER1_EN
X#if ((1==0))
S		if(thisModeConf->Palm.ucPalmDetectionOn == 1 || (thisModeConf->Palm.ucPalmDetectionOn == 3 && thisInfo->bNewVersionPalm == 0))
S			public_func_PalmTouch_handler();
S		
S		if(thisInfo->bIsPalm || thisInfo->tCoord.tPos.sFinger_ > 5) thisInfo->bNewVersionPalm = 1;
S		if(!thisInfo->bTouchExpect) thisInfo->bNewVersionPalm = 0;
N#endif
N		if(thisInfo->bIsPalm)
N		{
N			if(thisInfo->tLabel.ucPalmCnt < 100)
N				thisInfo->tLabel.ucPalmCnt++;
N		}
N		else
N			thisInfo->tLabel.ucPalmCnt = 0;
N	
N#if !USED_DO_NOT_FINGER_TOUCH_REPORT
X#if !((1==0))
N#if (INTERPOLATION_VER2_En == YES || INTERPOLATION_VER3_En == YES) 
X#if (((1==0)) == (0==0) || ((1==0)) == (0==0)) 
S		if(ucInterpolation_Ver < 2)
N#endif
N		{
N	#if (FINGER_Latency_Test_ByFW == YES)
X	#if (((1==0)) == (0==0))
S			algorithm_coord_latency_cal_test();
N	#endif
N			algorithm_PendTouchEvent();
N			algorithm_coord_UpdatePosHistoryInfo();
N		}
N#endif /* !USED_DO_NOT_FINGER_TOUCH_REPORT */
N		
N		if(thisModeConf->BaseLine.bFingerBaseTracking == 1 && ((mode == FULL_MODE && thisModeConf->BaseLine.bFullFingerBaseTracking == 1) || (mode == LOCAL_FINGER_MODE)))
N			algorithm_baseline_tracking_continuous(mode);
N	}
N
N	return (bIsRecalState == NO);
X	return (bIsRecalState == (1==0));
N}
N
N#if USED_MNT_S3_MODE_FUNCTION
S#if USED_S3_WAKEUP_DEBUGING
Sextern uint32_t ulTestS3RawDataRead;
S#endif
Sextern uint8_t g_RemoteWakeup;
Sbool_t algorithm_process_S3(void)
S{
S	bool_t bIsRecalState = NO;
S
S	alogorithm_linefilter_S3();
S	algorithm_baseline_calculate_delta_S3();
S
S//	algorithm_baseline_tracking_continuous_local_S3();
S
S	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_NI_GET_RAW_IMAGE_PTR(), COL_MAX, NI_ROW_MAX, 84/*MAX Intensity*/);
S	protocol_LogMatrix(LT_INTENSITY, COL_MAX, HAL_NI_GET_DELTA_IMAGE_PTR(), COL_MAX, NI_ROW_MAX, 84/*MAX Intensity*/);
S
S	if(thisInfo->tS3DeltaInfo.bIsSendResumeSignal == YES && g_RemoteWakeup == 0)
S	{
S#if !USED_S3_WAKEUP_DEBUGING
S		algorithm_PendTouchEvent();
S		algorithm_coord_UpdatePosHistoryInfo();
S		algorithm_baseline_tracking_continuous_S3();
S#endif
S	}
S
S	if((thisInfo->bTouchExpect == YES) && (g_RemoteWakeup == 1))
S	{
S		thisInfo->tCoord.tPos.vusR[0] = 100;
S		thisInfo->tCoord.tPos.vusS[0] = 100;
S		thisInfo->tCoord.tPos.tXY[0].x = 5000;
S		thisInfo->tCoord.tPos.tXY[0].y = 5000;
S
S		if(thisInfo->tS3DeltaInfo.bIsSendResumeSignal == NO &&
S			IS_GPIO_PIN(_GPIO_S3_POWER_IN) == GPIO_DATA_LOW)
S		{
S			thisInfo->tS3DeltaInfo.bIsSendResumeSignal = YES;
S#if USED_S3_WAKEUP_DEBUGING
S			ulTestS3RawDataRead = NO;
S#else
S			ResumeSigal();
S#endif
S		}
S	}
S
S	return (bIsRecalState == NO);
S}
N#endif /* USED_MNT_S3_MODE_FUNCTION */
N
N#if USED_IDLE_MODE_CONTROL
X#if ((1==0))
Sbool_t algorithm_process_Idle(void)
S{
S	bool_t bIsRecalState = NO;
S
S	memset(sLFOffsetRow, 0, sizeof(sLFOffsetRow));
S	memset(sLFOffsetCol, 0, sizeof(sLFOffsetCol));
S	alogorithm_linefilter_idle();
S	algorithm_baseline_calculate_delta_idle();
S	algorithm_baseline_tracking_continuous_idle();
S
S	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_NI_GET_RAW_IMAGE_PTR(), COL_MAX, NI_ROW_MAX, 84/*MAX Intensity*/);
S	protocol_LogMatrix(LT_INTENSITY, COL_MAX, HAL_NI_GET_DELTA_IMAGE_PTR(), COL_MAX, NI_ROW_MAX, 84/*MAX Intensity*/);
S
S	return (bIsRecalState == NO);
S}
N#endif /* USED_IDLE_MODE_CONTROL */
N
N//extern uint8_t inrange_cnt;		// USB    
N#ifdef TILT_ON
Sextern int16_t  MatrixS16_Tilt4Delta					[ROW_MAX][COL_MAX ];
N#endif
Nbool_t algorithm_process_LocalFinger(void)
N{
N	bool_t bIsRecalState = NO;
X	bool_t bIsRecalState = (1==0);
N	algorithm_coord_initialise_pos_buffer();	
N
N//	protocol_LogMatrix(LT_RAWDATA, COL_MAX, HAL_GET_LOCAL_RAW_IMAGE_PTR(), COL_MAX, 8, 84/*MAX Intensity*/);
N
N
N//	protocol_LogMatrix(LT_RAWDATA, thisInfo->ucScreenCol, HAL_GET_LOCAL_FINGER_RAW_IMAGE_PTR(), COL_MAX, thisInfo->ucScreenRow, 84/*MAX Intensity*/);
N	memset(sLFOffsetRow, 0, sizeof(sLFOffsetRow));
N//			alogorithm_linefilter(); //     
N
N	//	if(thisModeConf->BaseLine.bDSP_A)
N	//	algorithm_baseline_calculate_delta_DSP(FULL_MODE);
N	//	else
N	algorithm_baseline_calculate_delta_localFinger(LOCAL_FINGER_MODE);
N
N	algorithm_check_recal_cond();
N	
N//	protocol_LogPaddedMatrix(LT_INTENSITY, COL_MAX, HAL_GET_LOCAL_DELTA_IMAGE_PTR(), COL_MAX, 8, 81/*MAX Intensity*/);	
N//	protocol_LogPaddedMatrix(LT_INTENSITY, thisInfo->ucScreenCol, HAL_GET_LOCAL_FINGER_DELTA_IMAGE_PTR(), COL_MAX, thisInfo->ucScreenRow, 81/*MAX Intensity*/);			
N
N	bIsRecalState = algorithm_is_recalibrate();
N	if(bIsRecalState == NO)
X	if(bIsRecalState == (1==0))
N	{
N		// process label image from delta image
N		algorithm_label_process(LOCAL_FINGER_MODE);
N		algorithm_coord_process(FULL_MODE);
N	}	
N
N	public_func_PalmTouch_handler();
N	
N#ifdef DC_BASE
S	if(gDCFullMode == 1)
S	{
S		int cl, tCheck = 0;
S		for(cl=0; cl < ptMemConf->iMaxTouch_; cl++)
S		{
S			if(thisInfo->tCoord.tPos.vusS[cl] != 0)
S			{
S				if(thisInfo->tCoord.ucIdMappedCnt[cl] < 3 && tCheck != 0)
S				{
S					thisInfo->tCoord.tPos.vusR[cl] = 0;
S					thisInfo->tCoord.tPos.vusS[cl] = 0;
S					thisInfo->tCoord.tPos.sFinger_--;
S					thisInfo->tCoord.ucIdMappedCnt[cl] = 0;
S					thisInfo->tCoord.tOrgPos.vusR[cl] = 0;
S					thisInfo->tCoord.tOrgPos.vusS[cl] = 0;
S					thisInfo->tCoord.tOrgPos.sFinger_--;
S				}
S				else
S					thisInfo->tCoord.ucIdMappedCnt[cl] = 1;
S				
S				tCheck++;
S			}
S		}
S		
S		if(tCheck != 0)
S		{
S			gDCFullMode = 2;
S//			inrange_cnt = 0;		// USB    
S		}
S	}
N#endif
N	
N	algorithm_PendTouchEvent();
N	algorithm_coord_UpdatePosHistoryInfo();
N	algorithm_baseline_tracking_continuous_local_finger();
N
N	#ifdef TILT_ON
S	protocol_LogMatrix(LT_INTENSITY, COL_MAX, *MatrixS16_Tilt4Delta, COL_MAX, ROW_MAX, 84/*MAX Intensity*/);
N	#else
N//	protocol_LogPaddedMatrix(LT_INTENSITY, COL_MAX, HAL_GET_LOCAL_DELTA_IMAGE_PTR(), COL_MAX, 8, 81/*MAX Intensity*/);
N//	protocol_LogPaddedMatrix(LT_INTENSITY, COL_MAX, HAL_GET_LOCAL_DELTA_IMAGE_PTR(), COL_MAX, 8, 84/*MAX Intensity*/);
N	#endif
N	return (bIsRecalState == NO);
X	return (bIsRecalState == (1==0));
N}
