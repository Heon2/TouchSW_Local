; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\algorithm_baseline.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\algorithm_baseline.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\algorithm_baseline.crf ..\..\App\Algorithm\Baseline\algorithm_baseline.c]
                          THUMB

                          AREA ||i.abnormal_rawdata_detection_for_hopping||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_detection_for_hopping PROC
;;;322    
;;;323    bool_t abnormal_rawdata_detection_for_hopping(bool_t SET)
000000  4907              LDR      r1,|L1.32|
;;;324    {
;;;325    	static uint32_t AbnormalCnt  = 0;
;;;326    	uint32_t lAbnormalCnt = 0;
;;;327    
;;;328    	if( SET )
000002  2800              CMP      r0,#0
000004  690a              LDR      r2,[r1,#0x10]
;;;329    	{
;;;330    		AbnormalCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  6108              STRNE    r0,[r1,#0x10]  ; AbnormalCnt
00000c  d105              BNE      |L1.26|
;;;331    	}
;;;332    	else
;;;333    	{
;;;334    		lAbnormalCnt = AbnormalCnt;
;;;335    		AbnormalCnt = 0;
00000e  2000              MOVS     r0,#0
;;;336    
;;;337    		if(lAbnormalCnt > 0)
000010  6108              STR      r0,[r1,#0x10]  ; AbnormalCnt
000012  2a00              CMP      r2,#0
;;;338    		{
;;;339    			return TRUE;
000014  bf1c              ITT      NE
000016  2001              MOVNE    r0,#1
;;;340    		}
;;;341    	}
;;;342    	return FALSE;
;;;343    }
000018  4770              BXNE     lr
                  |L1.26|
00001a  2000              MOVS     r0,#0                 ;342
00001c  4770              BX       lr
;;;344    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||

                          AREA ||i.abnormal_rawdata_temp||, CODE, READONLY, ALIGN=2

                  abnormal_rawdata_temp PROC
;;;299    
;;;300    bool_t abnormal_rawdata_temp(bool_t SET)
000000  4907              LDR      r1,|L2.32|
;;;301    {
;;;302    	static uint32_t dataCnt = 0;
;;;303    	uint32_t ldataCnt = 0;
;;;304    
;;;305    	if(SET)
000002  2800              CMP      r0,#0
000004  68ca              LDR      r2,[r1,#0xc]
;;;306    	{
;;;307    		dataCnt++;
000006  bf1c              ITT      NE
000008  1c50              ADDNE    r0,r2,#1
00000a  60c8              STRNE    r0,[r1,#0xc]  ; dataCnt
00000c  d105              BNE      |L2.26|
;;;308    	}
;;;309    	else
;;;310    	{
;;;311    		ldataCnt = dataCnt;
;;;312    		dataCnt = 0;
00000e  2000              MOVS     r0,#0
;;;313    
;;;314    		if(ldataCnt > 5)
000010  60c8              STR      r0,[r1,#0xc]  ; dataCnt
000012  2a05              CMP      r2,#5
;;;315    		{
;;;316    			return TRUE;
000014  bf84              ITT      HI
000016  2001              MOVHI    r0,#1
;;;317    		}
;;;318    	}
;;;319    
;;;320    	return FALSE;
;;;321    }
000018  4770              BXHI     lr
                  |L2.26|
00001a  2000              MOVS     r0,#0                 ;320
00001c  4770              BX       lr
;;;322    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_calculate_delta||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta PROC
;;;390    #endif
;;;391    bool_t algorithm_baseline_calculate_delta(int mode)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;392    {
;;;393    	int r, c,idx;
;;;394    	int delta;	
;;;395    //	int local_rs;
;;;396    //	int pen_touch_data = 0;
;;;397    	uint16_t read_raw_data;
;;;398    //	tCell_t pen_pos;
;;;399    //	int pen_touch_data2 = 0;
;;;400    	tOrigDeltaInfo_t * temp_delta;
;;;401    	uint16_t * pBaseImage;
;;;402    	tAppInfo_t * ptAppInfo = app_GetInfo();
000004  f7fffffe          BL       app_GetInfo
;;;403    	
;;;404    //	uint16_t AbnormalDeltaCntBuf[8] = {0}, AbnormalRegionCnt = 0;
;;;405    	
;;;406    	//Adaptive SeedBase LYB_200819
;;;407    	uint16_t AdaptiveSeedBase = 0;
;;;408    
;;;409    #if USED_RF_NOISE_RECOVERY_CODE
;;;410    	thisInfo->usAbnormalDeltaNodeCnt = 0;
;;;411    #endif /* USED_RF_NOISE_RECOVERY_CODE */	
;;;412    
;;;413    #if USED_NOISE_HOPPING_FREQ
;;;414    	uint8_t DeltaDivider;
;;;415    	if(IS_ACTIVE_MODE_FRQ_MAIN(HAL_GetSensingMode()))	DeltaDivider = 1<<ptModuleModeConf->ucOvrShift;
;;;416    	else												DeltaDivider = ((1<<ptModuleModeConf->ucOvrShift) + (1<<(ptModuleModeConf->ucOvrShift-1)))>>1;
;;;417    #endif /* USED_NOISE_HOPPING_FREQ */	
;;;418    
;;;419    #if CPI_TEST_EN
;;;420    	uint16_t AbnormalRawCnt = 0;	
;;;421    	uint32_t RawPartSum[COL_MAX/5+1] = {0};
;;;422    	uint16_t RawPartSumCnt[COL_MAX/5+1] = {0};
;;;423    	uint16_t AbnormalDeltaCntInMux[COL_MAX/5+1] = {0};
;;;424    	int DeltaEdgeCntInMux = 0;
;;;425    	uint8_t PhoneNoiseConditionCnt = 0;
;;;426    #endif
;;;427    #if LGD_ERROR_FRAME_PROCESS_EN
;;;428    	int EvenDelta = 0, OddDelta = 0;
;;;429    #endif
;;;430    	thisInfo->bBlockTracking = NO;
000008  4d60              LDR      r5,|L3.396|
00000a  2600              MOVS     r6,#0
;;;431    //	local_rs = 0;
;;;432    	temp_delta = &thisInfo->tDelta;
;;;433    
;;;434    	memset((void *)temp_delta, 0x00, sizeof(tOrigDeltaInfo_t));
00000c  212e              MOVS     r1,#0x2e
00000e  68ac              LDR      r4,[r5,#8]            ;430  ; thisInfo
000010  f8046b0c          STRB     r6,[r4],#0xc          ;430
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       __aeabi_memclr
;;;435    	temp_delta->tValidRect.cs = COL_MAX - 1; temp_delta->tValidRect.ce = 0;
00001a  205f              MOVS     r0,#0x5f
00001c  70a0              STRB     r0,[r4,#2]
00001e  70e6              STRB     r6,[r4,#3]
;;;436    	temp_delta->tValidRect.rs = ROW_MAX - 1; temp_delta->tValidRect.re = 0;
000020  202f              MOVS     r0,#0x2f
000022  7020              STRB     r0,[r4,#0]
000024  7066              STRB     r6,[r4,#1]
;;;437    #if USED_NOISE_HOPPING_FREQ
;;;438    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;439    	{
;;;440    		pBaseImage = g_pFingerBaseImage;
;;;441    	}
;;;442    	else
;;;443    	{
;;;444    		pBaseImage = g_pFingerHop1BaseImage;
;;;445    	}
;;;446    //	pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;447    #else /* USED_NOISE_HOPPING_FREQ */
;;;448    	pBaseImage = g_pFingerBaseImage;//HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;449    #endif /* USED_NOISE_HOPPING_FREQ */
;;;450    	
;;;451    	temp_delta->iPosCnt = 0;
000026  f8d5c014          LDR      r12,[r5,#0x14]  ; g_pFingerBaseImage
00002a  6166              STR      r6,[r4,#0x14]
;;;452    	temp_delta->iNegCnt = 0;
00002c  61e6              STR      r6,[r4,#0x1c]
;;;453    
;;;454    #if (LABEL_FAST_EN)	
;;;455    	memset(thisInfo->tLabel.ucLabel_Check,0,sizeof(thisInfo->tLabel.ucLabel_Check));
;;;456    	#if (LABEL_FAST_EN == 2)
;;;457    	memset(LABELIMAGE,0,sizeof(LABELIMAGE));
;;;458    	g_label_num = 0;
;;;459    	memset((void *)g_ucEqTbl, 0x00, sizeof(uint8_t)*LOOSE_POSBUF_);
;;;460    	uint8_t u_val, l_val, ul_val, ur_val, max_val1, max_val2, max_val3, min_val1, min_val2, min_val3, map_val, remap_index;
;;;461    	#endif
;;;462    #endif
;;;463    	{
;;;464    		
;;;465    #if ADAPTIVE_SEEDBASE
;;;466    		//Adaptive SeedBase LYB_200819
;;;467    		if(thisInfo->bIsPalm)	AdaptiveSeedBase = (thisModeConf->Label.usSeedBase>>1);
;;;468    		else					AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
;;;469    #else
;;;470    		AdaptiveSeedBase = thisModeConf->Label.usSeedBase;
00002e  686b              LDR      r3,[r5,#4]  ; thisModeConf
000030  9300              STR      r3,[sp,#0]
;;;471    #endif
;;;472    		
;;;473    		for( r=0; r<ROW_MAX; r++ )
;;;474    		{
;;;475    #if LGD_ERROR_FRAME_PROCESS_EN
;;;476    			if(thisModeConf->Noise.ucErrorFrameProcess == 2){
;;;477    				EvenDelta = 0, OddDelta = 0;
;;;478    			}
;;;479    #endif
;;;480    //			memset(AbnormalDeltaCntBuf,0,sizeof(AbnormalDeltaCntBuf));
;;;481    			for( c=0; c<COL_MAX; c++ )
;;;482    			{
;;;483    #if FAST_LF_EN
;;;484    				read_raw_data = HAL_READ_RAW_IMAGE(r,c) - sLFOffsetRow[r];
;;;485    #else
;;;486    				read_raw_data = HAL_READ_RAW_IMAGE(r, c);
;;;487    #endif
;;;488    				
;;;489    #if CPI_TEST_EN
;;;490    				if(thisModeConf->Noise.ucCPITestOn){
;;;491    					RawPartSum[c/5] += read_raw_data;
;;;492    					RawPartSumCnt[c/5]++;
;;;493    					if(read_raw_data <= 0)	AbnormalRawCnt++;
;;;494    				}
;;;495    #endif
;;;496    				
;;;497    				delta = (signed)read_raw_data - (signed)(*(pBaseImage++));
;;;498    #if 0
;;;499    				if(mode == FULL_MODE)
;;;500    				{							
;;;501    					if(read_raw_data < MINRAWDATA_MARGIN)
;;;502    					{
;;;503    						abnormal_rawdata_temp(TRUE);
;;;504    					}
;;;505    #if USED_NOISE_HOPPING_FREQ
;;;506    					if( read_raw_data < thisModeConf->Noise.usRawDataThd )
;;;507    					{
;;;508    						if( HAL_READ_DELTA_IMAGE(r,c) < thisModeConf->Noise.sDeltaDataThd )
;;;509    						{
;;;510    							abnormal_rawdata_detection_for_hopping(TRUE);
;;;511    						}
;;;512    					}
;;;513    
;;;514    #endif /* USED_NOISE_HOPPING_FREQ */
;;;515    				}
;;;516    #endif
;;;517    #if NORMALIZE_DELTA_EN
;;;518    				//Normalize Active 190612 limyb
;;;519    				if(thisModeConf->BaseLine.cNormalizeDelta != 0 && delta > (AdaptiveSeedBase>>1))
;;;520    				{
;;;521    	//				int left_top = 1;
;;;522    	//				int right_bottom = 128;
;;;523    					int nDelta = delta;
;;;524    					
;;;525    	//				nDelta = nDelta * (2*ROW_MAX + r) * (2*COL_MAX + c) / (ROW_MAX * COL_MAX);
;;;526    	//				delta = nDelta * ( ((ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta)<<1) - r) / (ROW_MAX-thisModeConf->BaseLine.cNormalizeDelta);
;;;527    					delta = nDelta * (ROW_MAX + ((ROW_MAX - r)>>2)) / ROW_MAX;
;;;528    				}
;;;529    #endif
;;;530    				
;;;531    #if USED_NOISE_HOPPING_FREQ
;;;532    				delta /= DeltaDivider;
;;;533    #else /* USED_NOISE_HOPPING_FREQ */
;;;534    				delta >>= ptModuleModeConf->ucOvrShift;
000032  f8d59000          LDR      r9,[r5,#0]  ; ptModuleModeConf
000036  f8b36039          LDRH     r6,[r3,#0x39]         ;470
00003a  2200              MOVS     r2,#0                 ;473
                  |L3.60|
00003c  4d54              LDR      r5,|L3.400|
00003e  eb020042          ADD      r0,r2,r2,LSL #1       ;486
000042  2100              MOVS     r1,#0                 ;481
000044  eb051880          ADD      r8,r5,r0,LSL #6       ;486
000048  f1c20030          RSB      r0,r2,#0x30           ;527
00004c  2730              MOVS     r7,#0x30              ;527
00004e  eb070ba0          ADD      r11,r7,r0,ASR #2      ;527
;;;535    #endif /* USED_NOISE_HOPPING_FREQ */
;;;536    				HAL_WRITE_DELTA_IMAGE(r, c, delta);
000052  eb021002          ADD      r0,r2,r2,LSL #4
000056  eb001042          ADD      r0,r0,r2,LSL #5
00005a  eb050780          ADD      r7,r5,r0,LSL #2
;;;537    				
;;;538    #if USED_RF_NOISE_RECOVERY_CODE
;;;539    				if(delta >= ABNORMAL_DELTA_PLUS_THD)
;;;540    				{
;;;541    					thisInfo->usAbnormalDeltaNodeCnt++;
;;;542    				}
;;;543    #endif /* USED_RF_NOISE_RECOVERY_CODE */				
;;;544    				
;;;545    #if LGD_ERROR_FRAME_PROCESS_EN
;;;546    				//LGD Kiosk error data rejection
;;;547    				if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;548    				{
;;;549    					if(c%2 == 0)	EvenDelta += delta;
;;;550    					else			OddDelta += delta;
;;;551    				}
;;;552    #endif
;;;553    				
;;;554    				//Mux baundary
;;;555    #if CPI_TEST_EN
;;;556    				if(thisModeConf->Noise.ucCPITestOn){
;;;557    					if(c != 0 && c < COL_MAX-1)
;;;558    					{
;;;559    						if(c%5 == 0){
;;;560    							if( abs(delta) > 10 && abs(delta - HAL_READ_DELTA_IMAGE(r,c-1)) > (abs(delta - HAL_READ_DELTA_IMAGE(r,c+1))<<1) )
;;;561    								DeltaEdgeCntInMux++;
;;;562    						}
;;;563    					}
;;;564    				
;;;565    					if(c%5 == 0)	PhoneNoiseConditionCnt = 0;
;;;566    					if(delta < -100)	PhoneNoiseConditionCnt++;
;;;567    					if(PhoneNoiseConditionCnt == 5)	AbnormalDeltaCntInMux[c/5] += 200;
;;;568    				}
;;;569    #endif
;;;570    				
;;;571    				if( delta > 0 )
;;;572    				{	
;;;573    					if( delta > thisModeConf->BaseLine.sAccumPosSumThd )
;;;574    					{
;;;575    #if CPI_TEST_EN
;;;576    						if(thisModeConf->Noise.ucCPITestOn){
;;;577    							if(delta > 511)	AbnormalDeltaCntInMux[c/5] += 200;
;;;578    						}
;;;579    #endif
;;;580    						{
;;;581    							temp_delta->iPosCnt++;
;;;582    							temp_delta->iPosSum += delta - thisModeConf->BaseLine.sAccumPosSumThd;
;;;583    //							AbnormalDeltaCntBuf[c/10]++;
;;;584    						}
;;;585    					}
;;;586    
;;;587    //					if( delta > thisModeConf->Label.usSeedBase )
;;;588    					if( delta > AdaptiveSeedBase )
;;;589    					{
;;;590    						if( temp_delta->tValidRect.cs > c )
;;;591    							temp_delta->tValidRect.cs = c;
;;;592    						if( temp_delta->tValidRect.ce < c )
;;;593    							temp_delta->tValidRect.ce = c;
;;;594    						if( temp_delta->tValidRect.rs > r )
;;;595    							temp_delta->tValidRect.rs = r;
;;;596    						if( temp_delta->tValidRect.re < r )
;;;597    							temp_delta->tValidRect.re = r;
;;;598    
;;;599    						temp_delta->iGroupedCellCnt++;						
;;;600    #if LABEL_FAST_EN
;;;601    						int idx_r = r/ROW_IN_ARRAY;
;;;602    						int idx_c = c/COL_IN_ARRAY;
;;;603    						if(thisInfo->tLabel.ucLabel_Check[idx_r][idx_c]==0)thisInfo->tLabel.ucLabel_Check[idx_r][idx_c] = 1;
;;;604    #if (LABEL_FAST_EN == 2)
;;;605    	#if (PAD_ == 0)
;;;606    						if(r == 0)
;;;607    						{
;;;608    							u_val  = 0;
;;;609    							ul_val = 0;
;;;610    							ur_val = 0;
;;;611    						}
;;;612    						else
;;;613    						{
;;;614    							u_val  = HAL_READ_LABEL_IMAGE(r-1, c  );
;;;615    							if(c == 0)
;;;616    								ul_val = 0;
;;;617    							else 
;;;618    								ul_val = HAL_READ_LABEL_IMAGE(r-1, c-1);
;;;619    							
;;;620    							if(c == COL_MAX-1)
;;;621    								ur_val = 0;
;;;622    							else 
;;;623    								ur_val = HAL_READ_LABEL_IMAGE(r-1, c+1);
;;;624    						}
;;;625    						
;;;626    						if(c == 0)
;;;627    							l_val  = 0;
;;;628    						else
;;;629    							l_val  = HAL_READ_LABEL_IMAGE(r  , c-1);
;;;630    	#else
;;;631    						u_val  = HAL_READ_LABEL_IMAGE(r-1, c  );
;;;632    						ul_val = HAL_READ_LABEL_IMAGE(r-1, c-1);
;;;633    						ur_val = HAL_READ_LABEL_IMAGE(r-1, c+1);
;;;634    						l_val  = HAL_READ_LABEL_IMAGE(r  , c-1);
;;;635    	#endif
;;;636    						max_val1 = MAX(ul_val, l_val);
;;;637    						max_val2 = MAX(u_val, ur_val);
;;;638    						max_val3 = MAX(max_val1, max_val2);
;;;639    
;;;640    						if (max_val3 != 0)
;;;641    						{
;;;642    							if (u_val == 0)  u_val  = 127;
;;;643    							if (l_val == 0)  l_val  = 127;
;;;644    							if (ul_val == 0) ul_val = 127;
;;;645    							if (ur_val == 0) ur_val = 127;
;;;646    
;;;647    							min_val1 = MIN(u_val, l_val);
;;;648    							min_val2 = MIN(ul_val, ur_val);
;;;649    							min_val3 = MIN(min_val1, min_val2);
;;;650    
;;;651    							if (min_val3 != max_val3)
;;;652    							{
;;;653    								map_val = min_val3;
;;;654    								//*(thisInfo->ucEqTbl+max_val3) = min_val3;
;;;655    
;;;656    								if(u_val != 127)
;;;657    								{
;;;658    									remap_index = u_val;
;;;659    									while(remap_index != g_ucEqTbl[remap_index])
;;;660    									{
;;;661    										remap_index = g_ucEqTbl[remap_index];
;;;662    										if(min_val3 < remap_index)
;;;663    											g_ucEqTbl[remap_index] = min_val3;
;;;664    									}
;;;665    
;;;666    									if( g_ucEqTbl[u_val] > min_val3 )
;;;667    										g_ucEqTbl[u_val] = min_val3;
;;;668    								}
;;;669    								if(l_val != 127)
;;;670    								{
;;;671    									remap_index = l_val;
;;;672    									while(remap_index != g_ucEqTbl[remap_index])
;;;673    									{
;;;674    										remap_index = g_ucEqTbl[remap_index];
;;;675    										if(min_val3 < remap_index)
;;;676    											g_ucEqTbl[remap_index] = min_val3;
;;;677    									}
;;;678    
;;;679    									if( g_ucEqTbl[l_val] > min_val3 )
;;;680    										g_ucEqTbl[l_val] = min_val3;
;;;681    								}
;;;682    								if(ul_val != 127)
;;;683    								{
;;;684    									remap_index = ul_val;
;;;685    									while(remap_index != g_ucEqTbl[remap_index])
;;;686    									{
;;;687    										remap_index = g_ucEqTbl[remap_index];
;;;688    										if(min_val3 < remap_index)
;;;689    											g_ucEqTbl[remap_index] = min_val3;
;;;690    									}
;;;691    
;;;692    									if( g_ucEqTbl[ul_val] > min_val3 )
;;;693    										g_ucEqTbl[ul_val] = min_val3;
;;;694    								}
;;;695    								if(ur_val != 127)
;;;696    								{
;;;697    									remap_index = ur_val;
;;;698    									while(remap_index != g_ucEqTbl[remap_index])
;;;699    									{
;;;700    										remap_index = g_ucEqTbl[remap_index];
;;;701    										if(min_val3 < remap_index)
;;;702    											g_ucEqTbl[remap_index] = min_val3;
;;;703    									}
;;;704    
;;;705    									if( g_ucEqTbl[ur_val] > min_val3 )
;;;706    										g_ucEqTbl[ur_val] = min_val3;
;;;707    								}
;;;708    							}
;;;709    							else
;;;710    							{
;;;711    								map_val = max_val3;
;;;712    							}
;;;713    						}
;;;714    						else
;;;715    						{
;;;716    							if( g_label_num < LOOSE_POSBUF_ )
;;;717    							{
;;;718    								g_label_num++;
;;;719    							}
;;;720    
;;;721    							map_val = g_label_num;
;;;722    							g_ucEqTbl[g_label_num] = g_label_num;
;;;723    						}
;;;724    						
;;;725    						HAL_WRITE_LABEL_IMAGE(r, c, map_val);
;;;726    	#endif
;;;727    #endif
;;;728    					}
;;;729    
;;;730    					if( temp_delta->iMaxStrength < delta )
;;;731    					{
;;;732    						temp_delta->iMaxStrength = delta;
;;;733    					}
;;;734    				}
;;;735    				else
;;;736    				{
;;;737    					if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;738    					{
;;;739    #if CPI_TEST_EN
;;;740    						if(thisModeConf->Noise.ucCPITestOn){
;;;741    							AbnormalDeltaCntInMux[c/5]+=5;
;;;742    							if(delta < -300)	AbnormalDeltaCntInMux[c/5] += 200;
;;;743    						}
;;;744    #endif
;;;745    						{						
;;;746    							temp_delta->iNegCnt++;
;;;747    							temp_delta->iNegSum += delta - thisModeConf->BaseLine.sAccumNegSumThd;
;;;748    //							AbnormalDeltaCntBuf[c/10]++;
;;;749    						}
;;;750    					}
;;;751    
;;;752    					if( temp_delta->iMinStrength > delta )
;;;753    					{
;;;754    						temp_delta->iMinStrength = delta;
;;;755    						temp_delta->tMinCellPos.r = r;
00005e  fa4ffa82          SXTB     r10,r2
000062  bf00              NOP                            ;486
                  |L3.100|
000064  eb080041          ADD      r0,r8,r1,LSL #1       ;486
000068  f5003080          ADD      r0,r0,#0x10000        ;486
00006c  f83c5b02          LDRH     r5,[r12],#2           ;497
000070  f8b00294          LDRH     r0,[r0,#0x294]        ;486
000074  1b40              SUBS     r0,r0,r5              ;497
000076  781d              LDRB     r5,[r3,#0]            ;519
000078  2d00              CMP      r5,#0                 ;519
00007a  bf18              IT       NE                    ;519
00007c  ebb00f56          CMPNE    r0,r6,LSR #1          ;519
000080  dd07              BLE      |L3.146|
000082  fb0bf500          MUL      r5,r11,r0             ;527
000086  4843              LDR      r0,|L3.404|
000088  fb805005          SMULL    r5,r0,r0,r5           ;527
00008c  10c5              ASRS     r5,r0,#3              ;527
00008e  eba570e0          SUB      r0,r5,r0,ASR #31      ;527
                  |L3.146|
000092  f8995000          LDRB     r5,[r9,#0]            ;534
000096  4128              ASRS     r0,r0,r5              ;534
000098  eb070541          ADD      r5,r7,r1,LSL #1       ;536
00009c  f5054530          ADD      r5,r5,#0xb000         ;536
0000a0  2800              CMP      r0,#0                 ;571
0000a2  f8a50956          STRH     r0,[r5,#0x956]        ;536
0000a6  dd30              BLE      |L3.266|
0000a8  f9b3500a          LDRSH    r5,[r3,#0xa]          ;573
0000ac  42a8              CMP      r0,r5                 ;573
0000ae  dd09              BLE      |L3.196|
0000b0  6965              LDR      r5,[r4,#0x14]         ;581
0000b2  1c6d              ADDS     r5,r5,#1              ;581
0000b4  6165              STR      r5,[r4,#0x14]         ;581
0000b6  f9b3e00a          LDRSH    lr,[r3,#0xa]          ;582
0000ba  69a5              LDR      r5,[r4,#0x18]         ;582
0000bc  eba00e0e          SUB      lr,r0,lr              ;582
0000c0  4475              ADD      r5,r5,lr              ;582
0000c2  61a5              STR      r5,[r4,#0x18]         ;582
                  |L3.196|
0000c4  42b0              CMP      r0,r6                 ;588
0000c6  dd1a              BLE      |L3.254|
0000c8  f9945002          LDRSB    r5,[r4,#2]            ;591
0000cc  428d              CMP      r5,r1                 ;591
0000ce  bfc8              IT       GT                    ;591
0000d0  460d              MOVGT    r5,r1                 ;591
0000d2  70a5              STRB     r5,[r4,#2]            ;591
0000d4  f9945003          LDRSB    r5,[r4,#3]            ;593
0000d8  428d              CMP      r5,r1                 ;593
0000da  bfd8              IT       LE                    ;593
0000dc  460d              MOVLE    r5,r1                 ;593
0000de  70e5              STRB     r5,[r4,#3]            ;593
0000e0  f9945000          LDRSB    r5,[r4,#0]            ;595
0000e4  4295              CMP      r5,r2                 ;595
0000e6  bfc8              IT       GT                    ;595
0000e8  4615              MOVGT    r5,r2                 ;595
0000ea  7025              STRB     r5,[r4,#0]            ;595
0000ec  f9945001          LDRSB    r5,[r4,#1]            ;597
0000f0  4295              CMP      r5,r2                 ;597
0000f2  bfd8              IT       LE                    ;597
0000f4  4615              MOVLE    r5,r2                 ;597
0000f6  7065              STRB     r5,[r4,#1]            ;597
0000f8  6865              LDR      r5,[r4,#4]            ;599
0000fa  1c6d              ADDS     r5,r5,#1              ;599
0000fc  6065              STR      r5,[r4,#4]            ;599
                  |L3.254|
0000fe  68a5              LDR      r5,[r4,#8]            ;732
000100  4285              CMP      r5,r0                 ;732
000102  bfc8              IT       GT                    ;732
000104  4628              MOVGT    r0,r5                 ;732
000106  60a0              STR      r0,[r4,#8]            ;732
000108  e015              B        |L3.310|
                  |L3.266|
00010a  f9b3500c          LDRSH    r5,[r3,#0xc]          ;737
00010e  42a8              CMP      r0,r5                 ;737
000110  da09              BGE      |L3.294|
000112  69e5              LDR      r5,[r4,#0x1c]         ;746
000114  1c6d              ADDS     r5,r5,#1              ;746
000116  61e5              STR      r5,[r4,#0x1c]         ;746
000118  f9b3e00c          LDRSH    lr,[r3,#0xc]          ;747
00011c  6a25              LDR      r5,[r4,#0x20]         ;747
00011e  eba00e0e          SUB      lr,r0,lr              ;747
000122  4475              ADD      r5,r5,lr              ;747
000124  6225              STR      r5,[r4,#0x20]         ;747
                  |L3.294|
000126  6a65              LDR      r5,[r4,#0x24]         ;752
000128  4285              CMP      r5,r0                 ;752
00012a  dd04              BLE      |L3.310|
00012c  6260              STR      r0,[r4,#0x24]         ;754
00012e  f884a02b          STRB     r10,[r4,#0x2b]
;;;756    						temp_delta->tMinCellPos.c = c;
000132  f884102a          STRB     r1,[r4,#0x2a]
                  |L3.310|
000136  1c49              ADDS     r1,r1,#1
000138  2960              CMP      r1,#0x60
00013a  db93              BLT      |L3.100|
00013c  1c52              ADDS     r2,r2,#1
00013e  2a30              CMP      r2,#0x30
000140  f6ffaf7c          BLT      |L3.60|
;;;757    	//					pen_touch_data = -delta;
;;;758    //						pen_pos.r = r;
;;;759    //						pen_pos.c = c;
;;;760    					}
;;;761    				}
;;;762    			}
;;;763    			//Phone Noise
;;;764    //			for(c = 1 ; c < 7; c++)
;;;765    //				if(AbnormalDeltaCntBuf[c-1] == 0 && AbnormalDeltaCntBuf[c] == 10 && AbnormalDeltaCntBuf[c+1] == 0)
;;;766    //					AbnormalRegionCnt++;
;;;767    			
;;;768    #if LGD_ERROR_FRAME_PROCESS_EN
;;;769    			//LGD Kiosk error data rejection
;;;770    			if(thisModeConf->Noise.ucErrorFrameProcess == 2)
;;;771    			{
;;;772    				if(COL_MAX>1)
;;;773    				{
;;;774    					EvenDelta /= ( (COL_MAX+1)>>1);
;;;775    					OddDelta /= (COL_MAX>>1);
;;;776    					if(abs(EvenDelta - OddDelta) > 5)
;;;777    					{
;;;778    						for( c=0; c<COL_MAX; c++ ){
;;;779    							delta = HAL_READ_DELTA_IMAGE(r,c);
;;;780    							if(c%2 == 0)
;;;781    								delta = (delta - EvenDelta < 0) ? 0 : delta - EvenDelta;
;;;782    							else
;;;783    								delta = (delta - OddDelta < 0) ? 0 : delta - OddDelta;
;;;784    							HAL_WRITE_DELTA_IMAGE(r,c,delta);
;;;785    						}
;;;786    						
;;;787    					}
;;;788    				}
;;;789    			}
;;;790    #endif			
;;;791    		}
;;;792    
;;;793    #if USED_RF_NOISE_RECOVERY_CODE
;;;794    		if(thisInfo->usAbnormalDeltaNodeCnt >= ABNORMAL_DELTA_PLUS_CNT_THD || temp_delta->iMinStrength <= ABNORMAL_DELTA_MINUS_THD)
;;;795    		{
;;;796    			thisInfo->usAbnormalDeltaFrameCnt1++;
;;;797    			thisInfo->usDebounceFrmaeCnt = DEBOUNCE_FRAME_NUM;
;;;798    		}
;;;799    		else
;;;800    		{
;;;801    			thisInfo->usAbnormalDeltaFrameCnt1 = 0;
;;;802    			if(thisInfo->usDebounceFrmaeCnt > 0)
;;;803    			{
;;;804    				thisInfo->usDebounceFrmaeCnt--;
;;;805    			}
;;;806    		}
;;;807    #endif /* USED_RF_NOISE_RECOVERY_CODE */			
;;;808    		
;;;809    		#if 0
;;;810    		//Phone noise
;;;811    		if(thisInfo->PhoneNoiseFrmCnt < PHONE_NOISE_RESET_CNT_MAX)
;;;812    		{
;;;813    			if(temp_delta->iNegCnt >= 2 && AbnormalRegionCnt >= 2)
;;;814    				thisInfo->PhoneNoiseFrmCnt++;
;;;815    			else if(temp_delta->iNegCnt == 0 && temp_delta->iPosCnt == 0)
;;;816    				thisInfo->PhoneNoiseFrmCnt = 0;
;;;817    			
;;;818    			if(temp_delta->iNegCnt >= 2)
;;;819    				thisInfo->PhoneNoiseDebEnable = YES;
;;;820    			else
;;;821    				thisInfo->PhoneNoiseDebEnable = NO;
;;;822    			
;;;823    		}
;;;824    		else if(thisInfo->PhoneNoiseFrmCnt == PHONE_NOISE_RESET_CNT_MAX){
;;;825    			thisInfo->PhoneNoiseFrmCnt = 1;
;;;826    			SRIC_reset_flag = YES;
;;;827    		}
;;;828    		#endif
;;;829    		thisInfo->bTouchExpect = (temp_delta->iGroupedCellCnt > 0);
000144  6860              LDR      r0,[r4,#4]
000146  2800              CMP      r0,#0
000148  bf18              IT       NE
00014a  2001              MOVNE    r0,#1
00014c  490f              LDR      r1,|L3.396|
00014e  2301              MOVS     r3,#1
000150  6889              LDR      r1,[r1,#8]  ; thisInfo
000152  f5015280          ADD      r2,r1,#0x1000
000156  f8820f8b          STRB     r0,[r2,#0xf8b]
00015a  b128              CBZ      r0,|L3.360|
;;;830    	}
;;;831    
;;;832    	if(thisInfo->bTouchExpect && !thisInfo->bLineFilterRepeatCheck)thisInfo->bLineFilterRepeatCheck = 1;
00015c  f8920fb7          LDRB     r0,[r2,#0xfb7]
000160  2800              CMP      r0,#0
000162  bf08              IT       EQ
000164  f8823fb7          STRBEQ   r3,[r2,#0xfb7]
                  |L3.360|
;;;833    
;;;834    #if CPI_TEST_EN
;;;835    	//LGD Phone noise
;;;836    	if(thisModeConf->Noise.ucCPITestOn)
;;;837    	{
;;;838    		if(!thisInfo->WinCertMode && thisInfo->tCoord.cScreenDebCnt[0]<COORD_HISTORY_NUM){
;;;839    			for(idx=0;idx<COL_MAX/5;idx++){
;;;840    				if(RawPartSumCnt[idx] != 0)
;;;841    					RawPartSum[idx] /= RawPartSumCnt[idx];
;;;842    				if(idx>0){
;;;843    					if(abs(RawPartSum[idx] - RawPartSum[idx-1])>1000)
;;;844    						AbnormalRawCnt = RawPartSumCnt[idx];
;;;845    				}
;;;846    				
;;;847    				if(AbnormalDeltaCntInMux[idx] > 50 || DeltaEdgeCntInMux > (ROW_MAX>>1) )
;;;848    					thisInfo->UnstableStateFrm = 400;
;;;849    		//		if(AbnormalDeltaCntInMux[idx] >= 200)
;;;850    		//			thisInfo->UnstableStateFrm = 400;
;;;851    			}
;;;852    			
;;;853    			if(thisInfo->UnstableStateFrm && wdt_init)
;;;854    			{
;;;855    				KICK_DOG();
;;;856    				Hal_WDT_DeInit();
;;;857    			}
;;;858    			
;;;859    			if(AbnormalRawCnt >= 5){
;;;860    				memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;861    				GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;862    				thisInfo->UnstableStateFrm = 0;
;;;863    			}
;;;864    			
;;;865    			{
;;;866    				static uint16_t AbnormalFrmCnt = 0;
;;;867    				static uint8_t ResetDelayCount = 0;
;;;868    
;;;869    				if(thisInfo->UnstableStateFrm){
;;;870    					memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
;;;871    					if(ResetDelayCount++ > 10){
;;;872    						GoToThisState = TOUCH_NORMAL_OPER_RESET_HAL;
;;;873    					}	
;;;874    				}
;;;875    				if(GoToThisState == TOUCH_NORMAL_OPER_RESET_HAL)
;;;876    				{
;;;877    					thisInfo->UnstableStateFrm = 0;
;;;878    					AbnormalFrmCnt = 0;
;;;879    					ResetDelayCount = 0;
;;;880    				}
;;;881    			}
;;;882    		}
;;;883    	}
;;;884    #endif
;;;885    	
;;;886    	if(temp_delta->iMaxStrength > thisModeConf->BaseLine.sBlockPosThd)
000168  68a2              LDR      r2,[r4,#8]
00016a  9800              LDR      r0,[sp,#0]
00016c  f9b00006          LDRSH    r0,[r0,#6]
000170  4282              CMP      r2,r0
;;;887    	{
;;;888    		thisInfo->bBlockTracking = YES;
000172  bfc8              IT       GT
000174  700b              STRBGT   r3,[r1,#0]
;;;889    	}
;;;890    	
;;;891    	if(temp_delta->iMinStrength < thisModeConf->BaseLine.sBlockNegThd)
000176  6a62              LDR      r2,[r4,#0x24]
000178  9800              LDR      r0,[sp,#0]
00017a  f9b00008          LDRSH    r0,[r0,#8]
00017e  4282              CMP      r2,r0
;;;892    	{
;;;893    		thisInfo->bBlockTracking = YES;
000180  bfb8              IT       LT
000182  700b              STRBLT   r3,[r1,#0]
;;;894    	}
;;;895    	
;;;896    	return thisInfo->bBlockTracking;
000184  7808              LDRB     r0,[r1,#0]
;;;897    }
000186  e8bd8ff8          POP      {r3-r11,pc}
;;;898    
                          ENDP

00018a  0000              DCW      0x0000
                  |L3.396|
                          DCD      ||.data||
                  |L3.400|
                          DCD      FullSharedBuff
                  |L3.404|
                          DCD      0x2aaaaaab

                          AREA ||i.algorithm_baseline_calculate_delta_localFinger||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_calculate_delta_localFinger PROC
;;;898    
;;;899    bool_t algorithm_baseline_calculate_delta_localFinger(int mode)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;900    {
;;;901    	int r, c;
;;;902    	int delta;	
;;;903    	uint16_t read_raw_data;
;;;904    	tCell_t pen_pos;
;;;905    	tOrigDeltaInfo_t	*temp_delta;
;;;906    //	uint16_t * pRawImage;
;;;907    	uint16_t * pBaseImage;
;;;908    	
;;;909    	thisInfo->bBlockTracking = NO;
000004  4e63              LDR      r6,|L4.404|
000006  2500              MOVS     r5,#0
;;;910    
;;;911    	temp_delta = &thisInfo->tDelta;
;;;912    
;;;913    	memset((void *)temp_delta, 0x00, sizeof(tOrigDeltaInfo_t));
000008  212e              MOVS     r1,#0x2e
00000a  68b4              LDR      r4,[r6,#8]            ;909  ; thisInfo
00000c  f8045b0c          STRB     r5,[r4],#0xc          ;909
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       __aeabi_memclr
;;;914    	temp_delta->tValidRect.cs = COL_MAX - 1; temp_delta->tValidRect.ce = 0;
000016  205f              MOVS     r0,#0x5f
000018  70a0              STRB     r0,[r4,#2]
00001a  70e5              STRB     r5,[r4,#3]
;;;915    	temp_delta->tValidRect.rs = ROW_MAX - 1; temp_delta->tValidRect.re = 0;
00001c  202f              MOVS     r0,#0x2f
00001e  7020              STRB     r0,[r4,#0]
000020  7065              STRB     r5,[r4,#1]
;;;916    
;;;917    	pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
000022  f7fffffe          BL       HAL_GetSensingMode
000026  2100              MOVS     r1,#0
000028  f7fffffe          BL       HAL_GetBaseImagePointer
;;;918    
;;;919    	for( r=0; r<ROW_MAX; r++ )
;;;920    	{
;;;921    		for( c=0; c<COL_MAX; c++ )
;;;922    		{
;;;923    			read_raw_data = HAL_READ_LOCAL_FINGER_RAW_IMAGE(r,c);
00002c  e9d69200          LDRD     r9,r2,[r6,#0]
000030  f8dfb164          LDR      r11,|L4.408|
000034  4605              MOV      r5,r0                 ;917
000036  2300              MOVS     r3,#0                 ;919
                  |L4.56|
;;;924    			delta = (signed)read_raw_data - (signed)pBaseImage[(r*COL_MAX) + c];
;;;925    
;;;926    //			if(/*HAL_READ_RAW_IMAGE(r,c) > MAXRAWDATA_MARGIN || */read_raw_data < MINRAWDATA_MARGIN)
;;;927    //			{
;;;928    //                abnormal_rawdata_temp(TRUE);
;;;929    //			}
;;;930    
;;;931    			delta >>= ptModuleModeConf->ucOvrShift;
;;;932    			HAL_WRITE_LOCAL_FINGER_DELTA_IMAGE(r, c, delta);
000038  eb031003          ADD      r0,r3,r3,LSL #4
00003c  eb030843          ADD      r8,r3,r3,LSL #1       ;923
000040  eb001043          ADD      r0,r0,r3,LSL #5
000044  2100              MOVS     r1,#0                 ;921
000046  eb0b1788          ADD      r7,r11,r8,LSL #6      ;923
00004a  eb0b0680          ADD      r6,r11,r0,LSL #2
;;;933    
;;;934    			if( delta > 0 )
;;;935    			{
;;;936    //				if( delta > thisModeConf->BaseLine.sBlockPosThd )
;;;937    //				{
;;;938    //					thisInfo->bBlockTracking = YES;
;;;939    //				}
;;;940    
;;;941    				if( delta > thisModeConf->BaseLine.sAccumPosSumThd )
;;;942    				{
;;;943    					temp_delta->iPosCnt++;
;;;944    					temp_delta->iPosSum += delta - thisModeConf->BaseLine.sAccumPosSumThd;
;;;945    				}
;;;946    
;;;947    				if( delta > thisModeConf->Label.usSeedBase )
;;;948    				{
;;;949    					if( temp_delta->tValidRect.cs > c )
;;;950    						temp_delta->tValidRect.cs = c;
;;;951    					if( temp_delta->tValidRect.ce < c )
;;;952    						temp_delta->tValidRect.ce = c;
;;;953    					if( temp_delta->tValidRect.rs > r )
;;;954    						temp_delta->tValidRect.rs = r;
;;;955    					if( temp_delta->tValidRect.re < r )
;;;956    						temp_delta->tValidRect.re = r;
;;;957    
;;;958    					temp_delta->iGroupedCellCnt++;
;;;959    				}
;;;960    
;;;961    				if( temp_delta->iMaxStrength < delta )
;;;962    				{
;;;963    					temp_delta->iMaxStrength = delta;
;;;964    				}
;;;965    			}
;;;966    			else
;;;967    			{
;;;968    //				if( delta < thisModeConf->BaseLine.sBlockNegThd )
;;;969    //				{
;;;970    //					thisInfo->bBlockTracking = YES;
;;;971    //				}
;;;972    
;;;973    				if( delta < thisModeConf->BaseLine.sAccumNegSumThd )
;;;974    				{
;;;975    					temp_delta->iNegCnt++;
;;;976    					temp_delta->iNegSum += delta - thisModeConf->BaseLine.sAccumNegSumThd;
;;;977    				}
;;;978    
;;;979    				if( temp_delta->iMinStrength > delta )
;;;980    				{
;;;981    					temp_delta->iMinStrength = delta;
;;;982    
;;;983    //					pen_touch_data = -delta;
;;;984    					pen_pos.r = r;
00004e  fa4ffa83          SXTB     r10,r3
000052  bf00              NOP                            ;923
                  |L4.84|
000054  eb070041          ADD      r0,r7,r1,LSL #1       ;923
000058  f5003080          ADD      r0,r0,#0x10000        ;923
00005c  eb011c48          ADD      r12,r1,r8,LSL #5      ;924
000060  f8b00294          LDRH     r0,[r0,#0x294]        ;923
000064  f835c01c          LDRH     r12,[r5,r12,LSL #1]   ;924
000068  eba0000c          SUB      r0,r0,r12             ;924
00006c  f899c000          LDRB     r12,[r9,#0]           ;931
000070  fa40f00c          ASR      r0,r0,r12             ;931
000074  eb060c41          ADD      r12,r6,r1,LSL #1      ;932
000078  f50c4c30          ADD      r12,r12,#0xb000       ;932
00007c  2800              CMP      r0,#0                 ;934
00007e  f8ac0956          STRH     r0,[r12,#0x956]       ;932
000082  dd3f              BLE      |L4.260|
000084  f9b2c00a          LDRSH    r12,[r2,#0xa]         ;941
000088  4560              CMP      r0,r12                ;941
00008a  dd0e              BLE      |L4.170|
00008c  f8d4c014          LDR      r12,[r4,#0x14]        ;943
000090  f10c0c01          ADD      r12,r12,#1            ;943
000094  f8c4c014          STR      r12,[r4,#0x14]        ;943
000098  f9b2e00a          LDRSH    lr,[r2,#0xa]          ;944
00009c  f8d4c018          LDR      r12,[r4,#0x18]        ;944
0000a0  eba00e0e          SUB      lr,r0,lr              ;944
0000a4  44f4              ADD      r12,r12,lr            ;944
0000a6  f8c4c018          STR      r12,[r4,#0x18]        ;944
                  |L4.170|
0000aa  f8b2c039          LDRH     r12,[r2,#0x39]        ;947
0000ae  4584              CMP      r12,r0                ;947
0000b0  da21              BGE      |L4.246|
0000b2  f994c002          LDRSB    r12,[r4,#2]           ;950
0000b6  4561              CMP      r1,r12                ;950
0000b8  bfb8              IT       LT                    ;950
0000ba  468c              MOVLT    r12,r1                ;950
0000bc  f884c002          STRB     r12,[r4,#2]           ;950
0000c0  f994c003          LDRSB    r12,[r4,#3]           ;952
0000c4  458c              CMP      r12,r1                ;952
0000c6  bfd8              IT       LE                    ;952
0000c8  468c              MOVLE    r12,r1                ;952
0000ca  f884c003          STRB     r12,[r4,#3]           ;952
0000ce  f994c000          LDRSB    r12,[r4,#0]           ;954
0000d2  459c              CMP      r12,r3                ;954
0000d4  bfc8              IT       GT                    ;954
0000d6  469c              MOVGT    r12,r3                ;954
0000d8  f884c000          STRB     r12,[r4,#0]           ;954
0000dc  f994c001          LDRSB    r12,[r4,#1]           ;956
0000e0  459c              CMP      r12,r3                ;956
0000e2  bfd8              IT       LE                    ;956
0000e4  469c              MOVLE    r12,r3                ;956
0000e6  f884c001          STRB     r12,[r4,#1]           ;956
0000ea  f8d4c004          LDR      r12,[r4,#4]           ;958
0000ee  f10c0c01          ADD      r12,r12,#1            ;958
0000f2  f8c4c004          STR      r12,[r4,#4]           ;958
                  |L4.246|
0000f6  f8d4c008          LDR      r12,[r4,#8]           ;963
0000fa  4560              CMP      r0,r12                ;963
0000fc  bfb8              IT       LT                    ;963
0000fe  4660              MOVLT    r0,r12                ;963
000100  60a0              STR      r0,[r4,#8]            ;963
000102  e01b              B        |L4.316|
                  |L4.260|
000104  f9b2c00c          LDRSH    r12,[r2,#0xc]         ;973
000108  4560              CMP      r0,r12                ;973
00010a  da0e              BGE      |L4.298|
00010c  f8d4c01c          LDR      r12,[r4,#0x1c]        ;975
000110  f10c0c01          ADD      r12,r12,#1            ;975
000114  f8c4c01c          STR      r12,[r4,#0x1c]        ;975
000118  f9b2e00c          LDRSH    lr,[r2,#0xc]          ;976
00011c  f8d4c020          LDR      r12,[r4,#0x20]        ;976
000120  eba00e0e          SUB      lr,r0,lr              ;976
000124  44f4              ADD      r12,r12,lr            ;976
000126  f8c4c020          STR      r12,[r4,#0x20]        ;976
                  |L4.298|
00012a  f8d4c024          LDR      r12,[r4,#0x24]        ;979
00012e  4584              CMP      r12,r0                ;979
000130  dd04              BLE      |L4.316|
000132  6260              STR      r0,[r4,#0x24]         ;981
000134  f88da001          STRB     r10,[sp,#1]
;;;985    					pen_pos.c = c;
000138  f88d1000          STRB     r1,[sp,#0]
                  |L4.316|
00013c  1c49              ADDS     r1,r1,#1
00013e  2960              CMP      r1,#0x60
000140  db88              BLT      |L4.84|
000142  1c5b              ADDS     r3,r3,#1
000144  2b30              CMP      r3,#0x30
000146  f6ffaf77          BLT      |L4.56|
;;;986    				}
;;;987    			}
;;;988    		}
;;;989    	}
;;;990    
;;;991    	if(  temp_delta->iMaxStrength > thisModeConf->BaseLine.sBlockPosThd )
00014a  68a3              LDR      r3,[r4,#8]
00014c  f9b2c006          LDRSH    r12,[r2,#6]
000150  4810              LDR      r0,|L4.404|
;;;992    	{
;;;993    		thisInfo->bBlockTracking = YES;
000152  2101              MOVS     r1,#1
000154  4563              CMP      r3,r12                ;991
000156  bfc4              ITT      GT
000158  6883              LDRGT    r3,[r0,#8]  ; thisInfo
00015a  7019              STRBGT   r1,[r3,#0]
;;;994    	}
;;;995    	
;;;996    	if( temp_delta->iMinStrength < thisModeConf->BaseLine.sBlockNegThd )
00015c  6a63              LDR      r3,[r4,#0x24]
00015e  f9b22008          LDRSH    r2,[r2,#8]
000162  4293              CMP      r3,r2
;;;997    	{
;;;998    		thisInfo->bBlockTracking = YES;
000164  bfbc              ITT      LT
000166  6882              LDRLT    r2,[r0,#8]  ; thisInfo
000168  7011              STRBLT   r1,[r2,#0]
;;;999    	}
;;;1000   	
;;;1001   	thisInfo->sLFingerMinVal = temp_delta->iMinStrength;
00016a  8ca2              LDRH     r2,[r4,#0x24]
00016c  6880              LDR      r0,[r0,#8]  ; thisInfo
00016e  f5005180          ADD      r1,r0,#0x1000
000172  f8a12f98          STRH     r2,[r1,#0xf98]
;;;1002   	thisInfo->tLFingerMinCell = pen_pos;
000176  f50052e0          ADD      r2,r0,#0x1c00
00017a  f8bd3000          LDRH     r3,[sp,#0]
00017e  f8a2339a          STRH     r3,[r2,#0x39a]
;;;1003   	
;;;1004   	thisInfo->bTouchExpect = (temp_delta->iGroupedCellCnt >0);
000182  6862              LDR      r2,[r4,#4]
000184  2a00              CMP      r2,#0
000186  bf18              IT       NE
000188  2201              MOVNE    r2,#1
00018a  f8812f8b          STRB     r2,[r1,#0xf8b]
;;;1005   
;;;1006   	return thisInfo->bBlockTracking;
00018e  7800              LDRB     r0,[r0,#0]
;;;1007   }
000190  e8bd8ff8          POP      {r3-r11,pc}
;;;1008   #if (USED_IDLE_MODE_CONTROL && !USED_NORMAL_NI_SENSING)
                          ENDP

                  |L4.404|
                          DCD      ||.data||
                  |L4.408|
                          DCD      FullSharedBuff

                          AREA ||i.algorithm_baseline_init||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init PROC
;;;53     extern __IO bool_t wdt_init;
;;;54     void algorithm_baseline_init(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c08              LDR      r4,|L5.40|
000008  6060              STR      r0,[r4,#4]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
;;;55     {
;;;56     	algorithm_baseline_init_param();
;;;57     	thisInfo = algorithm_GetInfo();
00000e  6020              STR      r0,[r4,#0]  ; ptModuleModeConf
000010  f7fffffe          BL       algorithm_GetInfo
000014  60a0              STR      r0,[r4,#8]  ; thisInfo
000016  4805              LDR      r0,|L5.44|
;;;58     #if USED_NOISE_HOPPING_FREQ
;;;59     	ptAppInfo = app_GetInfo();
;;;60     #endif /* USED_NOISE_HOPPING_FREQ */
;;;61     	algorithm_baseline_init_FingerPoint();	
;;;62     	memset(DELTAIMAGE,0,sizeof(DELTAIMAGE));
000018  6160              STR      r0,[r4,#0x14]  ; g_pFingerBaseImage
00001a  e8bd4010          POP      {r4,lr}
00001e  f2426148          MOV      r1,#0x2648
000022  4803              LDR      r0,|L5.48|
000024  f7ffbffe          B.W      __aeabi_memclr4
;;;63     }
;;;64     
                          ENDP

                  |L5.40|
                          DCD      ||.data||
                  |L5.44|
                          DCD      FullSharedBuff
                  |L5.48|
                          DCD      FullSharedBuff+0xb890

                          AREA ||i.algorithm_baseline_init_FingerPoint||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_FingerPoint PROC
;;;70     
;;;71     void algorithm_baseline_init_FingerPoint(void)
000000  4902              LDR      r1,|L6.12|
;;;72     {
;;;73     	g_pFingerBaseImage = HAL_GET_BASELINE_IMAGE_PTR();
000002  4801              LDR      r0,|L6.8|
000004  6148              STR      r0,[r1,#0x14]  ; g_pFingerBaseImage
;;;74     #if USED_NOISE_HOPPING_FREQ
;;;75     	g_pFingerHop1BaseImage = HAL_GET_HOPP1_BASELINE_IMAGE_PTR();
;;;76     #endif /* USED_NOISE_HOPPING_FREQ */
;;;77     }
000006  4770              BX       lr
;;;78     #ifdef SHORT_COMPENSATION
                          ENDP

                  |L6.8|
                          DCD      FullSharedBuff
                  |L6.12|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_init_param||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_init_param PROC
;;;64     
;;;65     void algorithm_baseline_init_param(void)
000000  b510              PUSH     {r4,lr}
;;;66     {
;;;67     	thisModeConf  = algorithm_GetModeConfig();
000002  f7fffffe          BL       algorithm_GetModeConfig
000006  4c03              LDR      r4,|L7.20|
;;;68     	ptModuleModeConf = module_GetModeConfig();
000008  6060              STR      r0,[r4,#4]  ; thisModeConf
00000a  f7fffffe          BL       module_GetModeConfig
00000e  6020              STR      r0,[r4,#0]  ; ptModuleModeConf
;;;69     }
000010  bd10              POP      {r4,pc}
;;;70     
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      ||.data||

                          AREA ||i.algorithm_baseline_tracking_continuous||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous PROC
;;;208    extern int16_t sLFOffsetCol[COL_MAX];
;;;209    void algorithm_baseline_tracking_continuous(uint8_t mode)
000000  e92d07f0          PUSH     {r4-r10}
;;;210    {
;;;211    	uint32_t ulIdx;
;;;212    	uint32_t ulFullIdxNum;
;;;213    	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;214    	static bool_t traking_en = 0;
;;;215    #if USED_NORMAL_NI_SENSING
;;;216    	uint32_t ulNiIdxNum;
;;;217    	uint16_t * pNiRawImage;
;;;218    	uint16_t * pNiBaseImage;
;;;219    #endif /* USED_NORMAL_NI_SENSING */
;;;220    	uint16_t * pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;221    #if USED_NOISE_HOPPING_FREQ
;;;222    	uint16_t * pBaseImage;
;;;223    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;224    	{
;;;225    		pBaseImage = g_pFingerBaseImage;
;;;226    	}
;;;227    	else
;;;228    	{
;;;229    		pBaseImage = g_pFingerHop1BaseImage;
;;;230    	}
;;;231    //	uint16_t * pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;232    #else /* USED_NOISE_HOPPING_FREQ */
;;;233    	uint16_t * pBaseImage = g_pFingerBaseImage;
000004  4b26              LDR      r3,|L8.160|
000006  4a25              LDR      r2,|L8.156|
;;;234    #endif /* USED_NOISE_HOPPING_FREQ */
;;;235        if(thisInfo->bIsPalm == 0 && thisInfo->bBlockTracking == NO)
000008  689c              LDR      r4,[r3,#8]  ; thisInfo
00000a  6959              LDR      r1,[r3,#0x14]  ; g_pFingerBaseImage
00000c  f5045c80          ADD      r12,r4,#0x1000
000010  f89c5f87          LDRB     r5,[r12,#0xf87]
000014  2d00              CMP      r5,#0
000016  bf07              ITTEE    EQ
000018  7824              LDRBEQ   r4,[r4,#0]
00001a  2c00              CMPEQ    r4,#0
;;;236    	{
;;;237    		if(mode == FULL_MODE && thisInfo->bLocal_sensing == NO)
;;;238    		{
;;;239    			alpha = thisModeConf->BaseLine.usIIRCoef;
;;;240    
;;;241    			//pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;242    			//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
;;;243    			ulFullIdxNum = ROW_MAX * COL_MAX;
;;;244    			for(ulIdx = 0; ulIdx < ulFullIdxNum; ulIdx++)
;;;245    			{
;;;246    				curr_rawdata = (*(pRawImage++));
;;;247    #if !FAST_LF_EN	
;;;248    				curr_rawdata += (sLFOffsetRow[ulIdx / COL_MAX] + sLFOffsetCol[ulIdx % COL_MAX]);
;;;249    #endif
;;;250    				prev_baseline = *(pBaseImage);
;;;251    				curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;252    				*(pBaseImage++) = (uint16_t)curr_baseline;
;;;253    			}
;;;254    				
;;;255    #if USED_NORMAL_NI_SENSING
;;;256    	    	pNiRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
;;;257    	    	pNiBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
;;;258    	    	ulNiIdxNum = NI_ROW_MAX * thisInfo->ucScreenCol;
;;;259    	    	for(ulIdx = ulNiIdxNum; ulIdx--; )
;;;260    	    	{
;;;261    	    		prev_baseline = *(pNiBaseImage);
;;;262    	    		curr_rawdata = *(pNiRawImage++);
;;;263    	    		curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;264    	    		*(pNiBaseImage++) = (uint16_t)curr_baseline;
;;;265    	    	}
;;;266    #endif /* USED_NORMAL_NI_SENSING */
;;;267    		}
;;;268        }
;;;269    }
00001c  e8bd07f0          POPNE    {r4-r10}
000020  4770              BXNE     lr
000022  2800              CMP      r0,#0                 ;237
000024  bf07              ITTEE    EQ                    ;237
000026  f89c0f8e          LDRBEQ   r0,[r12,#0xf8e]       ;237
00002a  2800              CMPEQ    r0,#0                 ;237
00002c  e8bd07f0          POPNE    {r4-r10}
000030  4770              BXNE     lr
000032  6858              LDR      r0,[r3,#4]            ;239  ; thisModeConf
000034  f44f5390          MOV      r3,#0x1200            ;244
000038  f8b0c004          LDRH     r12,[r0,#4]           ;239
00003c  4e19              LDR      r6,|L8.164|
00003e  4f1a              LDR      r7,|L8.168|
000040  f8df8068          LDR      r8,|L8.172|
000044  f8df9068          LDR      r9,|L8.176|
000048  f04f0000          MOV      r0,#0                 ;244
00004c  f1cc0564          RSB      r5,r12,#0x64          ;252
                  |L8.80|
000050  fba6a400          UMULL    r10,r4,r6,r0          ;248
000054  ea4f1a94          LSR      r10,r4,#6             ;248
000058  1e5b              SUBS     r3,r3,#1              ;252
00005a  f937401a          LDRSH    r4,[r7,r10,LSL #1]    ;248
00005e  ebaa0a8a          SUB      r10,r10,r10,LSL #2    ;248
000062  eb001a4a          ADD      r10,r0,r10,LSL #5     ;248
000066  f1000001          ADD      r0,r0,#1              ;252
00006a  f938a01a          LDRSH    r10,[r8,r10,LSL #1]   ;248
00006e  4454              ADD      r4,r4,r10             ;248
000070  f832ab02          LDRH     r10,[r2],#2           ;248
000074  4454              ADD      r4,r4,r10             ;248
000076  f8b1a000          LDRH     r10,[r1,#0]           ;252
00007a  fb0afa0c          MUL      r10,r10,r12           ;252
00007e  fb05a404          MLA      r4,r5,r4,r10          ;252
000082  fb89a404          SMULL    r10,r4,r9,r4          ;252
000086  ea4f1a64          ASR      r10,r4,#5             ;252
00008a  ebaa74e4          SUB      r4,r10,r4,ASR #31     ;252
00008e  f8214b02          STRH     r4,[r1],#2            ;252
000092  d1dd              BNE      |L8.80|
000094  e8bd07f0          POP      {r4-r10}
000098  4770              BX       lr
;;;270    
                          ENDP

00009a  0000              DCW      0x0000
                  |L8.156|
                          DCD      FullSharedBuff+0x10294
                  |L8.160|
                          DCD      ||.data||
                  |L8.164|
                          DCD      0xaaaaaaab
                  |L8.168|
                          DCD      sLFOffsetRow
                  |L8.172|
                          DCD      sLFOffsetCol
                  |L8.176|
                          DCD      0x51eb851f

                          AREA ||i.algorithm_baseline_tracking_continuous_local_finger||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_continuous_local_finger PROC
;;;272    
;;;273    void algorithm_baseline_tracking_continuous_local_finger(void)
000000  483b              LDR      r0,|L9.240|
;;;274    {
;;;275    	int r, c;
;;;276    	int prev_baseline, curr_baseline, curr_rawdata, alpha;
;;;277    
;;;278        if( thisInfo->bBlockTracking == NO)
000002  6881              LDR      r1,[r0,#8]  ; thisInfo
000004  7809              LDRB     r1,[r1,#0]
000006  2900              CMP      r1,#0
;;;279        {
;;;280    		alpha = (100 - thisModeConf->BaseLine.usIIRCoef)*120/120;//ptAppInfo->iFrameRate;
;;;281    		alpha = (100 - alpha);
;;;282    
;;;283        	for( r=0; r<ROW_MAX; r++ )
;;;284    		{
;;;285    			for( c=0; c<COL_MAX; c++ )
;;;286    			{
;;;287    				prev_baseline = HAL_READ_LOCAL_FINGER_BASELINE_IMAGE(r,c);
;;;288    				curr_rawdata = HAL_READ_LOCAL_FINGER_RAW_IMAGE(r,c)+sLFOffsetRow[r];
;;;289    				
;;;290    				curr_baseline = (alpha * prev_baseline + (BASELINE_TRACKING_RESOLUTION-alpha) * curr_rawdata)/BASELINE_TRACKING_RESOLUTION;
;;;291    
;;;292    				HAL_WRITE_LOCAL_FINGER_BASELINE_IMAGE(r, c, (uint16_t)curr_baseline);
;;;293    			}
;;;294    		}
;;;295    
;;;296    //    	protocol_LogMatrix(LT_REFERENCE, thisInfo->ucScreenCol, HAL_GET_BASELINE_IMAGE_PTR(), COL_MAX, thisInfo->ucScreenRow, 80/*MAX Intensity*/);
;;;297        }
;;;298    }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  e92d0ff0          PUSH     {r4-r11}              ;274
000010  6840              LDR      r0,[r0,#4]            ;280  ; thisModeConf
000012  4938              LDR      r1,|L9.244|
000014  f8dfb0e0          LDR      r11,|L9.248|
000018  8880              LDRH     r0,[r0,#4]            ;280
00001a  f8df90e0          LDR      r9,|L9.252|
00001e  f1c00064          RSB      r0,r0,#0x64           ;280
000022  ebc01000          RSB      r0,r0,r0,LSL #4       ;280
000026  00c0              LSLS     r0,r0,#3              ;280
000028  fb811000          SMULL    r1,r0,r1,r0           ;280
00002c  eba070e0          SUB      r0,r0,r0,ASR #31      ;280
000030  f1c00c64          RSB      r12,r0,#0x64          ;281
000034  4b32              LDR      r3,|L9.256|
000036  2100              MOVS     r1,#0                 ;283
000038  f1cc0464          RSB      r4,r12,#0x64          ;281
                  |L9.60|
00003c  eb010041          ADD      r0,r1,r1,LSL #1       ;285
000040  eb0b1080          ADD      r0,r11,r0,LSL #6      ;285
000044  f5003280          ADD      r2,r0,#0x10000        ;285
000048  f5027225          ADD      r2,r2,#0x294          ;285
00004c  f9398011          LDRSH    r8,[r9,r1,LSL #1]     ;292
000050  8816              LDRH     r6,[r2,#0]            ;292
000052  4607              MOV      r7,r0                 ;285
000054  4446              ADD      r6,r6,r8              ;292
000056  f8b08000          LDRH     r8,[r0,#0]            ;292
00005a  4366              MULS     r6,r4,r6              ;292
00005c  fb0c6608          MLA      r6,r12,r8,r6          ;292
000060  fb838606          SMULL    r8,r6,r3,r6           ;292
000064  ea4f1866          ASR      r8,r6,#5              ;292
000068  eba876e6          SUB      r6,r8,r6,ASR #31      ;292
00006c  8006              STRH     r6,[r0,#0]            ;292
00006e  8856              LDRH     r6,[r2,#2]
000070  f05f052f          MOVS.W   r5,#0x2f              ;285
                  |L9.116|
000074  f939a011          LDRSH    r10,[r9,r1,LSL #1]    ;292
000078  f8328f04          LDRH     r8,[r2,#4]!
00007c  4456              ADD      r6,r6,r10             ;292
00007e  4366              MULS     r6,r4,r6              ;292
000080  f830af02          LDRH     r10,[r0,#2]!          ;292
000084  1e6d              SUBS     r5,r5,#1              ;292
000086  fb0c660a          MLA      r6,r12,r10,r6         ;292
00008a  fb83a606          SMULL    r10,r6,r3,r6          ;292
00008e  ea4f1a66          ASR      r10,r6,#5             ;292
000092  ebaa76e6          SUB      r6,r10,r6,ASR #31     ;292
000096  f8206b02          STRH     r6,[r0],#2            ;292
00009a  f939a011          LDRSH    r10,[r9,r1,LSL #1]    ;292
00009e  8856              LDRH     r6,[r2,#2]            ;292
0000a0  44d0              ADD      r8,r8,r10             ;292
0000a2  f8b0a000          LDRH     r10,[r0,#0]           ;292
0000a6  fb04f808          MUL      r8,r4,r8              ;292
0000aa  fb0c880a          MLA      r8,r12,r10,r8         ;292
0000ae  fb83a808          SMULL    r10,r8,r3,r8          ;292
0000b2  ea4f1a68          ASR      r10,r8,#5             ;292
0000b6  ebaa78e8          SUB      r8,r10,r8,ASR #31     ;292
0000ba  f8a08000          STRH     r8,[r0,#0]            ;292
0000be  d1d9              BNE      |L9.116|
0000c0  4a10              LDR      r2,|L9.260|
0000c2  f9395011          LDRSH    r5,[r9,r1,LSL #1]     ;292
0000c6  f8b700be          LDRH     r0,[r7,#0xbe]         ;292
0000ca  5bd2              LDRH     r2,[r2,r7]            ;292
0000cc  fb00f00c          MUL      r0,r0,r12             ;292
0000d0  442a              ADD      r2,r2,r5              ;292
0000d2  fb040002          MLA      r0,r4,r2,r0           ;292
0000d6  fb832000          SMULL    r2,r0,r3,r0           ;292
0000da  1142              ASRS     r2,r0,#5              ;292
0000dc  eba270e0          SUB      r0,r2,r0,ASR #31      ;292
0000e0  1c49              ADDS     r1,r1,#1              ;292
0000e2  f8a700be          STRH     r0,[r7,#0xbe]         ;292
0000e6  2930              CMP      r1,#0x30              ;292
0000e8  dba8              BLT      |L9.60|
0000ea  e8bd0ff0          POP      {r4-r11}
0000ee  4770              BX       lr
;;;299    
                          ENDP

                  |L9.240|
                          DCD      ||.data||
                  |L9.244|
                          DCD      0x02222223
                  |L9.248|
                          DCD      FullSharedBuff
                  |L9.252|
                          DCD      sLFOffsetRow
                  |L9.256|
                          DCD      0x51eb851f
                  |L9.260|
                          DCD      0x00010352

                          AREA ||i.algorithm_baseline_tracking_initial||, CODE, READONLY, ALIGN=2

                  algorithm_baseline_tracking_initial PROC
;;;81     #endif
;;;82     void algorithm_baseline_tracking_initial(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;83     {
;;;84     	uint32_t ulFrameNum, ulIdx;
;;;85     	uint32_t ulFullIdxNum;
;;;86     #if USED_NORMAL_NI_SENSING
;;;87     	uint32_t ulNiIdxNum;
;;;88     #endif /* USED_NORMAL_NI_SENSING */
;;;89         uint16_t temp_data, raw_val = 500;
;;;90     #ifdef SHORT_COMPENSATION
;;;91         int diff;
;;;92     	uint32_t raw_avg = 0;
;;;93         uint16_t raw_diff_thd = 500;
;;;94     	short_cnt = 0;
;;;95     	memset(short_pos, 0, sizeof(short_pos));
;;;96     #endif
;;;97     	uint16_t * pRawImage;
;;;98     	uint16_t * pInitRawImage;
;;;99     	uint16_t * pBaseImage;
;;;100    	uint16_t * pInitBaseImage;
;;;101    #if USED_NORMAL_NI_SENSING
;;;102    	uint16_t * pNiRawImage;
;;;103    	uint16_t * pNiInitRawImage;
;;;104    	uint16_t * pNiBaseImage;
;;;105    	uint16_t * pNiInitBaseImage;
;;;106    #endif /* USED_NORMAL_NI_SENSING */
;;;107    	
;;;108        for (ulFrameNum = 0; ulFrameNum < thisModeConf->BaseLine.ucDiscardFrameNum; ulFrameNum++)
000004  4e24              LDR      r6,|L10.152|
000006  2400              MOVS     r4,#0
000008  6870              LDR      r0,[r6,#4]  ; thisModeConf
00000a  7880              LDRB     r0,[r0,#2]
00000c  2800              CMP      r0,#0
00000e  d906              BLS      |L10.30|
                  |L10.16|
;;;109    	{
;;;110    		module_wait_full_sample_done();
000010  f7fffffe          BL       module_wait_full_sample_done
000014  6870              LDR      r0,[r6,#4]  ; thisModeConf
000016  1c64              ADDS     r4,r4,#1
000018  7880              LDRB     r0,[r0,#2]
00001a  42a0              CMP      r0,r4
00001c  d8f8              BHI      |L10.16|
                  |L10.30|
;;;111    	}
;;;112    
;;;113    #ifdef MODE_WDT				
;;;114    	KICK_DOG();
00001e  f7fffffe          BL       Hal_Kick_DOG
;;;115    #endif
;;;116    
;;;117    	pInitRawImage = pRawImage = HAL_GET_RAW_IMAGE_PTR();
;;;118    #if USED_NOISE_HOPPING_FREQ
;;;119    	if(ptAppInfo->eSelectFreq == FREQ_MAIN)
;;;120    	{
;;;121    		pInitBaseImage = pBaseImage = g_pFingerBaseImage;
;;;122    	}
;;;123    	else
;;;124    	{
;;;125    		pInitBaseImage = pBaseImage = g_pFingerHop1BaseImage ;
;;;126    	}
;;;127    //	pInitBaseImage = pBaseImage = HAL_GET_FREQ_BASELINE_PTR(ptAppInfo->eSelectFreq);
;;;128    #else /* USED_NOISE_HOPPING_FREQ */
;;;129    	pInitBaseImage = pBaseImage = g_pFingerBaseImage;//pBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_FULL);
000022  6970              LDR      r0,[r6,#0x14]  ; g_pFingerBaseImage
000024  4d1d              LDR      r5,|L10.156|
000026  4604              MOV      r4,r0
;;;130    #endif /* USED_NOISE_HOPPING_FREQ */
;;;131    	memset((void*)pBaseImage, 0x00, sizeof(uint16_t)*(ROW_MAX * COL_MAX));
000028  f44f5110          MOV      r1,#0x2400
00002c  f7fffffe          BL       __aeabi_memclr
;;;132    	ulFullIdxNum = ROW_MAX * COL_MAX;
;;;133    #if USED_NORMAL_NI_SENSING
;;;134    	pNiInitRawImage = pNiRawImage = HAL_NI_GET_RAW_IMAGE_PTR();
;;;135    	pNiInitBaseImage = pNiBaseImage = HAL_GetBaseImagePointer(HAL_GetSensingMode(), BASELINE_TYPE_NI);
;;;136        memset((void*)pNiBaseImage, 0x00, sizeof(uint16_t)*(NI_ROW_MAX * COL_MAX));
;;;137        ulNiIdxNum = NI_ROW_MAX * thisInfo->ucCol;
;;;138    #endif /* USED_NORMAL_NI_SENSING */
;;;139    
;;;140        for(ulFrameNum = thisModeConf->BaseLine.ucInitialFrameNum; ulFrameNum--; )
000030  6870              LDR      r0,[r6,#4]  ; thisModeConf
000032  78c0              LDRB     r0,[r0,#3]
000034  1e47              SUBS     r7,r0,#1
000036  d317              BCC      |L10.104|
                  |L10.56|
;;;141        {
;;;142    		module_wait_full_sample_done();
000038  f7fffffe          BL       module_wait_full_sample_done
;;;143    		pRawImage = pInitRawImage;
;;;144    		pBaseImage = pInitBaseImage;
;;;145    		for(ulIdx = ulFullIdxNum; ulIdx--; )
00003c  1ea1              SUBS     r1,r4,#2
00003e  1eaa              SUBS     r2,r5,#2
000040  f44f6310          MOV      r3,#0x900
                  |L10.68|
;;;146    		{
;;;147    			raw_val = *(pRawImage++);
;;;148    			temp_data = *(pBaseImage) + raw_val;
;;;149    			*(pBaseImage++) = temp_data;
000044  f8310f02          LDRH     r0,[r1,#2]!
000048  f8b2c002          LDRH     r12,[r2,#2]
00004c  1e5b              SUBS     r3,r3,#1
00004e  4460              ADD      r0,r0,r12
000050  f8210b02          STRH     r0,[r1],#2
000054  f832cf04          LDRH     r12,[r2,#4]!
000058  8808              LDRH     r0,[r1,#0]
00005a  4460              ADD      r0,r0,r12
00005c  8008              STRH     r0,[r1,#0]
00005e  d1f1              BNE      |L10.68|
;;;150    #ifdef SHORT_COMPENSATION
;;;151    			raw_avg += raw_val;
;;;152    #endif
;;;153    		}
;;;154    
;;;155    #if USED_NORMAL_NI_SENSING
;;;156    		pNiRawImage = pNiInitRawImage;
;;;157    		pNiBaseImage = pNiInitBaseImage;
;;;158    		for(ulIdx = ulNiIdxNum; ulIdx--; )
;;;159    		{
;;;160    			raw_val = *(pNiRawImage++);
;;;161    			temp_data = *(pNiBaseImage) + raw_val;
;;;162    			*(pNiBaseImage++) = temp_data;
;;;163    		}
;;;164    #endif /* USED_NORMAL_NI_SENSING */
;;;165    
;;;166    #ifdef MODE_WDT				
;;;167    		KICK_DOG();
000060  f7fffffe          BL       Hal_Kick_DOG
000064  1e7f              SUBS     r7,r7,#1
000066  d2e7              BCS      |L10.56|
                  |L10.104|
;;;168    #endif
;;;169        }
;;;170    
;;;171    #ifdef SHORT_COMPENSATION
;;;172    	raw_avg /= (ROW_MAX*COL_MAX*thisModeConf->BaseLine.ucInitialFrameNum);
;;;173    #endif
;;;174    
;;;175    	pBaseImage = pInitBaseImage;
;;;176    	for(ulIdx = ulFullIdxNum; ulIdx--; )
;;;177    	{
;;;178    		temp_data = (*pBaseImage);
;;;179    		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
000068  6871              LDR      r1,[r6,#4]  ; thisModeConf
00006a  1ea0              SUBS     r0,r4,#2              ;176
00006c  f44f6210          MOV      r2,#0x900             ;176
                  |L10.112|
000070  f8303f02          LDRH     r3,[r0,#2]!
000074  f891c003          LDRB     r12,[r1,#3]
;;;180    		(*pBaseImage++) = temp_data;
000078  1e52              SUBS     r2,r2,#1
00007a  fbb3f3fc          UDIV     r3,r3,r12             ;179
00007e  f8203b02          STRH     r3,[r0],#2
000082  f891c003          LDRB     r12,[r1,#3]           ;179
000086  8803              LDRH     r3,[r0,#0]            ;179
000088  fbb3f3fc          UDIV     r3,r3,r12             ;179
00008c  8003              STRH     r3,[r0,#0]
00008e  d1ef              BNE      |L10.112|
;;;181    #ifdef SHORT_COMPENSATION
;;;182    		diff = raw_avg - temp_data;
;;;183    		if( diff > raw_diff_thd && short_cnt < SHORT_NUM )
;;;184    		{
;;;185    			short_pos[short_cnt].c = c;
;;;186    			short_pos[short_cnt].r = r;
;;;187    			short_cnt++;
;;;188    		}
;;;189    #endif
;;;190    	}
;;;191    
;;;192    #if USED_NORMAL_NI_SENSING
;;;193    	pNiBaseImage = pNiInitBaseImage;
;;;194    	for(ulIdx = ulNiIdxNum; ulIdx--; )
;;;195    	{
;;;196    		temp_data = (*pNiBaseImage);
;;;197    		temp_data /= thisModeConf->BaseLine.ucInitialFrameNum;
;;;198    		(*pNiBaseImage++) = temp_data;
;;;199    	}
;;;200    #endif /* USED_NORMAL_NI_SENSING */
;;;201    
;;;202    #ifdef MODE_WDT				
;;;203    	KICK_DOG();
000090  e8bd41f0          POP      {r4-r8,lr}
000094  f7ffbffe          B.W      Hal_Kick_DOG
;;;204    #endif
;;;205    }
;;;206    
                          ENDP

                  |L10.152|
                          DCD      ||.data||
                  |L10.156|
                          DCD      FullSharedBuff+0x10294

                          AREA ||.data||, DATA, ALIGN=2

                  ptModuleModeConf
                          DCD      0x00000000
                  thisModeConf
                          DCD      0x00000000
                  thisInfo
                          DCD      0x00000000
                  dataCnt
                          DCD      0x00000000
                  AbnormalCnt
                          DCD      0x00000000
                  g_pFingerBaseImage
                          DCD      0x00000000

                          AREA ||area_number.14||, DATA, ALIGN=0

                          EXPORTAS ||area_number.14||, ||.data||
                  SRIC_reset_flag
000000  00                DCB      0x00

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  full_hover_cnt
                          DCD      0x00000000

                          AREA ||area_number.16||, DATA, ALIGN=0

                          EXPORTAS ||area_number.16||, ||.data||
                  max_cell_pos
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  max_cell_data
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\App\\Algorithm\\Baseline\\algorithm_baseline.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_dda81209____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___20_algorithm_baseline_c_dda81209____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_dda81209____REVSH|
#line 402
|__asm___20_algorithm_baseline_c_dda81209____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_algorithm_baseline_c_dda81209____RRX|
#line 587
|__asm___20_algorithm_baseline_c_dda81209____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
