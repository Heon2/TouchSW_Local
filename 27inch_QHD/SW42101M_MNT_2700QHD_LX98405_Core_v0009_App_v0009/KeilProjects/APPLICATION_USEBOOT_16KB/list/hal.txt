; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\hal.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\hal.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\hal.crf ..\..\Hal\hal.c]
                          THUMB

                          AREA ||i.HAL_CheckSensningModeChange||, CODE, READONLY, ALIGN=2

                  HAL_CheckSensningModeChange PROC
;;;601    
;;;602    bool_t HAL_CheckSensningModeChange(eSENSING_CHANGE_MODE_t mode)
000000  b570              PUSH     {r4-r6,lr}
;;;603    {
;;;604    	bool_t bIsModeChange = YES;
;;;605    	eSENSING_MODE_t ePastSensingMode = HAL_GetSensingMode();
000002  4d12              LDR      r5,|L1.76|
000004  0001              MOVS     r1,r0                 ;603
000006  f04f0401          MOV      r4,#1                 ;604
00000a  6828              LDR      r0,[r5,#0]  ; ptHalInfo
00000c  8840              LDRH     r0,[r0,#2]
00000e  d008              BEQ      |L1.34|
;;;606    
;;;607    	switch(mode)
000010  2902              CMP      r1,#2
000012  d002              BEQ      |L1.26|
000014  2903              CMP      r1,#3
000016  d00f              BEQ      |L1.56|
000018  e003              B        |L1.34|
                  |L1.26|
;;;608    	{
;;;609    		case SM_CHANGE_ACTIVE_FRQ_MAIN_MODE:
;;;610    		{
;;;611    			if(ePastSensingMode == SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE)
00001a  f5a05180          SUB      r1,r0,#0x1000
00001e  3905              SUBS     r1,#5
000020  d001              BEQ      |L1.38|
                  |L1.34|
;;;612    			{
;;;613    				PWMDRV_Set_Pulse_Config(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
;;;614    				HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
;;;615    			}
;;;616    			else
;;;617    			{
;;;618    				bIsModeChange = NO;
000022  2400              MOVS     r4,#0
000024  e010              B        |L1.72|
                  |L1.38|
000026  f2410003          MOV      r0,#0x1003            ;613
00002a  f7fffffe          BL       PWMDRV_Set_Pulse_Config
00002e  6829              LDR      r1,[r5,#0]            ;613  ; ptHalInfo
000030  f2410003          MOV      r0,#0x1003            ;614
000034  8048              STRH     r0,[r1,#2]            ;614
000036  e007              B        |L1.72|
                  |L1.56|
;;;619    			}
;;;620    			break;
;;;621    		}
;;;622    		case SM_CHANGE_ACTIVE_FRQ_HOP1_MODE:
;;;623    		{
;;;624    			PWMDRV_Set_Pulse_Config(SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE);
000038  f2410005          MOV      r0,#0x1005
00003c  f7fffffe          BL       PWMDRV_Set_Pulse_Config
000040  6829              LDR      r1,[r5,#0]  ; ptHalInfo
;;;625    			HAL_SetSensingMode(SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE);
000042  f2410005          MOV      r0,#0x1005
000046  8048              STRH     r0,[r1,#2]
                  |L1.72|
;;;626    			break;
;;;627    		}
;;;628    		case SM_CHANGE_COMPLETE:
;;;629    		{
;;;630    			bIsModeChange = NO;
;;;631    			break;
;;;632    		}
;;;633    		default:
;;;634    		{
;;;635    			bIsModeChange = NO;
;;;636    			break;
;;;637    		}
;;;638    	}
;;;639    
;;;640    	return bIsModeChange;
000048  4620              MOV      r0,r4
;;;641    }
00004a  bd70              POP      {r4-r6,pc}
;;;642    
                          ENDP

                  |L1.76|
                          DCD      ||.data||

                          AREA ||i.HAL_ECLK_Off||, CODE, READONLY, ALIGN=1

                  HAL_ECLK_Off PROC
;;;232    
;;;233    void HAL_ECLK_Off(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;234    {
000004  b081              SUB      sp,sp,#4
000006  69c1              LDR      r1,[r0,#0x1c]
000008  9100              STR      r1,[sp,#0]
00000a  9900              LDR      r1,[sp,#0]
00000c  f0210104          BIC      r1,r1,#4
000010  9100              STR      r1,[sp,#0]
000012  9900              LDR      r1,[sp,#0]
000014  b289              UXTH     r1,r1
000016  f1016180          ADD      r1,r1,#0x4000000
00001a  f10171fd          ADD      r1,r1,#0x1fa0000
00001e  9100              STR      r1,[sp,#0]
000020  9900              LDR      r1,[sp,#0]
000022  61c1              STR      r1,[r0,#0x1c]
000024  6a41              LDR      r1,[r0,#0x24]
000026  9100              STR      r1,[sp,#0]
000028  9900              LDR      r1,[sp,#0]
00002a  f0210104          BIC      r1,r1,#4
00002e  9100              STR      r1,[sp,#0]
000030  9900              LDR      r1,[sp,#0]
000032  b289              UXTH     r1,r1
000034  f1016180          ADD      r1,r1,#0x4000000
000038  f10171fd          ADD      r1,r1,#0x1fa0000
00003c  9100              STR      r1,[sp,#0]
00003e  9900              LDR      r1,[sp,#0]
000040  6241              STR      r1,[r0,#0x24]
;;;235    	Timer_Clock_Off();
;;;236    }
000042  b001              ADD      sp,sp,#4
000044  4770              BX       lr
;;;237    #endif /* USED_ECLK_ON_OFF_CONTROL */
                          ENDP


                          AREA ||i.HAL_ECLK_On||, CODE, READONLY, ALIGN=1

                  HAL_ECLK_On PROC
;;;227    
;;;228    void HAL_ECLK_On(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;229    {
000004  b081              SUB      sp,sp,#4
000006  69c1              LDR      r1,[r0,#0x1c]
000008  9100              STR      r1,[sp,#0]
00000a  9900              LDR      r1,[sp,#0]
00000c  f0410104          ORR      r1,r1,#4
000010  9100              STR      r1,[sp,#0]
000012  9900              LDR      r1,[sp,#0]
000014  b289              UXTH     r1,r1
000016  f1016180          ADD      r1,r1,#0x4000000
00001a  f10171fd          ADD      r1,r1,#0x1fa0000
00001e  9100              STR      r1,[sp,#0]
000020  9900              LDR      r1,[sp,#0]
000022  61c1              STR      r1,[r0,#0x1c]
000024  6a41              LDR      r1,[r0,#0x24]
000026  9100              STR      r1,[sp,#0]
000028  9900              LDR      r1,[sp,#0]
00002a  f0410104          ORR      r1,r1,#4
00002e  9100              STR      r1,[sp,#0]
000030  9900              LDR      r1,[sp,#0]
000032  b289              UXTH     r1,r1
000034  f1016180          ADD      r1,r1,#0x4000000
000038  f10171fd          ADD      r1,r1,#0x1fa0000
00003c  9100              STR      r1,[sp,#0]
00003e  9900              LDR      r1,[sp,#0]
000040  6241              STR      r1,[r0,#0x24]
;;;230    	Timer_Clock_On();
;;;231    }
000042  b001              ADD      sp,sp,#4
000044  4770              BX       lr
;;;232    
                          ENDP


                          AREA ||i.HAL_GetBaseImagePointer||, CODE, READONLY, ALIGN=2

                  HAL_GetBaseImagePointer PROC
;;;649    
;;;650    uint16_t * HAL_GetBaseImagePointer(eSENSING_MODE_t mode, eBaseImageType_t type)
000000  4a0f              LDR      r2,|L4.64|
;;;651    {
;;;652    	uint16_t * pImage = NULL;
;;;653    
;;;654    	if(IS_ACTIVE_MODE(mode))
000002  f0100f01          TST      r0,#1
000006  d011              BEQ      |L4.44|
;;;655    	{
;;;656    		if(IS_ACTIVE_MODE_FRQ_HOP1(mode))
;;;657    		{
;;;658    			if(type == BASELINE_TYPE_FULL)
;;;659    			{
;;;660    				pImage = HAL_GET_HOPP1_BASELINE_IMAGE_PTR();
000008  4b0e              LDR      r3,|L4.68|
00000a  f0100f04          TST      r0,#4                 ;656
00000e  d005              BEQ      |L4.28|
000010  2900              CMP      r1,#0                 ;658
000012  bf04              ITT      EQ
000014  f5035010          ADDEQ    r0,r3,#0x2400
;;;661    			}
;;;662    			else
;;;663    			{
;;;664    				pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;665    			}
;;;666    		}
;;;667    		else if(IS_ACTIVE_MODE_FRQ_HOP2(mode))
;;;668    		{
;;;669    			if(type == BASELINE_TYPE_FULL)
;;;670    			{
;;;671    				pImage = HAL_GET_HOPP2_BASELINE_IMAGE_PTR();
;;;672    			}
;;;673    			else
;;;674    			{
;;;675    				pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;676    			}
;;;677    		}
;;;678    		else
;;;679    		{
;;;680    			if(type == BASELINE_TYPE_FULL)
;;;681    			{
;;;682    				pImage = HAL_GET_BASELINE_IMAGE_PTR();
;;;683    			}
;;;684    			else
;;;685    			{
;;;686    				pImage = HAL_NI_GET_HOP1_BASELINE_IMAGE_PTR();
;;;687    			}
;;;688    		}
;;;689    	}
;;;690    	else
;;;691    	{
;;;692    		pImage = HAL_NI_GET_BASELINE_IMAGE_PTR();
;;;693    	}
;;;694    
;;;695    	return pImage;
;;;696    }
000018  4770              BXEQ     lr
00001a  e007              B        |L4.44|
                  |L4.28|
00001c  f0100f08          TST      r0,#8                 ;667
000020  d006              BEQ      |L4.48|
000022  2900              CMP      r1,#0                 ;669
000024  bf04              ITT      EQ                    ;671
000026  f5034090          ADDEQ    r0,r3,#0x4800         ;671
00002a  4770              BXEQ     lr
                  |L4.44|
00002c  4610              MOV      r0,r2
00002e  4770              BX       lr
                  |L4.48|
000030  4804              LDR      r0,|L4.68|
000032  2900              CMP      r1,#0                 ;680
000034  bf1c              ITT      NE                    ;686
000036  f64f4194          MOVNE    r1,#0xfc94            ;686
00003a  4408              ADDNE    r0,r1                 ;686
00003c  4770              BX       lr
;;;697    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      FullSharedBuff+0xf994
                  |L4.68|
                          DCD      FullSharedBuff

                          AREA ||i.HAL_GetECLKOnOffControl||, CODE, READONLY, ALIGN=2

                  HAL_GetECLKOnOffControl PROC
;;;210    
;;;211    bool_t HAL_GetECLKOnOffControl(void)
000000  4806              LDR      r0,|L5.28|
;;;212    {
;;;213    	if(ptHalInfo->bIsECLKOnOffStartCheckCnt < ECLK_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7941              LDRB     r1,[r0,#5]
000006  290a              CMP      r1,#0xa
000008  d206              BCS      |L5.24|
00000a  1c49              ADDS     r1,r1,#1              ;212
;;;214    	{
;;;215    		ptHalInfo->bIsECLKOnOffStartCheckCnt++;
00000c  b2c9              UXTB     r1,r1
00000e  7141              STRB     r1,[r0,#5]
;;;216    	}
;;;217    
;;;218    	if(ptHalInfo->bIsECLKOnOffStartCheckCnt >= ECLK_ON_OFF_CONTROL_START_CNT_THD)
000010  290a              CMP      r1,#0xa
;;;219    	{
;;;220    		return ptHalInfo->bIsECLKOnOffStart;
;;;221    	}
;;;222    	else
;;;223    	{
;;;224    		return NO;
000012  bf3c              ITT      CC
000014  2000              MOVCC    r0,#0
;;;225    	}
;;;226    }
000016  4770              BXCC     lr
                  |L5.24|
000018  7900              LDRB     r0,[r0,#4]            ;220
00001a  4770              BX       lr
;;;227    
                          ENDP

                  |L5.28|
                          DCD      ||.data||

                          AREA ||i.HAL_GetSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_GetSensingChangeMode PROC
;;;570    
;;;571    eSENSING_CHANGE_MODE_t HAL_GetSensingChangeMode(void)
000000  4801              LDR      r0,|L6.8|
;;;572    {
;;;573    	return ptHalInfo->eSensingChangeMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  7800              LDRB     r0,[r0,#0]
;;;574    }
000006  4770              BX       lr
;;;575    
                          ENDP

                  |L6.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetSensingMode||, CODE, READONLY, ALIGN=2

                  HAL_GetSensingMode PROC
;;;587    
;;;588    eSENSING_MODE_t HAL_GetSensingMode(void)
000000  4801              LDR      r0,|L7.8|
;;;589    {
;;;590    	return ptHalInfo->eSensingMode;
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  8840              LDRH     r0,[r0,#2]
;;;591    }
000006  4770              BX       lr
;;;592    
                          ENDP

                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTPICMuxEnControl||, CODE, READONLY, ALIGN=2

                  HAL_GetTPICMuxEnControl PROC
;;;269    
;;;270    bool_t HAL_GetTPICMuxEnControl(void)
000000  4806              LDR      r0,|L8.28|
;;;271    {
;;;272    	if(ptHalInfo->bIsTPICMuxEnOnOfftartCheckCnt < TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD)
000002  6800              LDR      r0,[r0,#0]  ; ptHalInfo
000004  79c1              LDRB     r1,[r0,#7]
000006  290a              CMP      r1,#0xa
000008  d206              BCS      |L8.24|
00000a  1c49              ADDS     r1,r1,#1              ;271
;;;273    	{
;;;274    		ptHalInfo->bIsTPICMuxEnOnOfftartCheckCnt++;
00000c  b2c9              UXTB     r1,r1
00000e  71c1              STRB     r1,[r0,#7]
;;;275    	}
;;;276    
;;;277    	if(ptHalInfo->bIsTPICMuxEnOnOfftartCheckCnt >= TPIC_MUXEN_ON_OFF_CONTROL_START_CNT_THD)
000010  290a              CMP      r1,#0xa
;;;278    	{
;;;279    		return ptHalInfo->bIsTPICMuxEnOnOffStart;
;;;280    	}
;;;281    	else
;;;282    	{
;;;283    		return NO;
000012  bf3c              ITT      CC
000014  2000              MOVCC    r0,#0
;;;284    	}
;;;285    }
000016  4770              BXCC     lr
                  |L8.24|
000018  7980              LDRB     r0,[r0,#6]            ;279
00001a  4770              BX       lr
;;;286    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
                          ENDP

                  |L8.28|
                          DCD      ||.data||

                          AREA ||i.HAL_Initialize||, CODE, READONLY, ALIGN=2

                  HAL_Initialize PROC
;;;546     */
;;;547    void HAL_Initialize(bool_t bIsLPWG)
000000  b510              PUSH     {r4,lr}
;;;548    {
000002  4604              MOV      r4,r0
;;;549    	ptHalInfo = hal_GetInfo();
000004  f7fffffe          BL       hal_GetInfo
000008  4906              LDR      r1,|L9.36|
;;;550    #if (USED_LPWG_MODE_CONTROL == NO)
;;;551    #if USED_PEN_MODE_OPERATION
;;;552    #if USED_INIT_PEN_MODE
;;;553    	ptHalInfo->eSensingMode = SM_FINGER_PEN_ACTIVE_MODE;
;;;554    #else /* USED_INIT_PEN_MODE */
;;;555    	ptHalInfo->eSensingMode = SM_FINGER_PEN_SEARCH_ACTIVE_FRQ_MAIN_MODE;
;;;556    #endif /* USED_INIT_PEN_MODE */
;;;557    #else /* USED_PEN_MODE_OPERATION */
;;;558    	if(bIsLPWG)
00000a  2c00              CMP      r4,#0
00000c  6008              STR      r0,[r1,#0]  ; ptHalInfo
;;;559    	{
;;;560    		ptHalInfo->eSensingMode = SM_S3_ACTIVE_MODE;
00000e  bf14              ITE      NE
000010  f6400101          MOVNE    r1,#0x801
;;;561    	}
;;;562    	else
;;;563    	{
;;;564    		ptHalInfo->eSensingMode = SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE;
000014  f2410103          MOVEQ    r1,#0x1003
000018  8041              STRH     r1,[r0,#2]
;;;565    	}
;;;566    #endif /* USED_PEN_MODE_OPERATION */
;;;567    #endif /* (USED_LPWG_MODE_CONTROL == NO) */	
;;;568    	PWMDRV_Initialize();
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      PWMDRV_Initialize
;;;569    }
;;;570    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      ||.data||

                          AREA ||i.HAL_SetECLKOnOffControl||, CODE, READONLY, ALIGN=2

                  HAL_SetECLKOnOffControl PROC
;;;190    
;;;191    void HAL_SetECLKOnOffControl(bool_t bIsEn)
000000  4916              LDR      r1,|L10.92|
;;;192    {
000002  b081              SUB      sp,sp,#4
;;;193    	if(bIsEn == NO)
;;;194    	{
;;;195    		if(ptHalInfo->bIsECLKOnOffStart == YES)
000004  680a              LDR      r2,[r1,#0]
000006  7911              LDRB     r1,[r2,#4]
000008  b120              CBZ      r0,|L10.20|
;;;196    		{
;;;197    			HAL_ECLK_On();
;;;198    		}
;;;199    	}
;;;200    	else
;;;201    	{
;;;202    		if(ptHalInfo->bIsECLKOnOffStart == NO)
00000a  2900              CMP      r1,#0
;;;203    		{
;;;204    			ptHalInfo->bIsECLKOnOffStartCheckCnt = 0;
00000c  bf04              ITT      EQ
00000e  2100              MOVEQ    r1,#0
000010  7151              STRBEQ   r1,[r2,#5]
000012  e020              B        |L10.86|
                  |L10.20|
000014  2901              CMP      r1,#1                 ;195
000016  d11e              BNE      |L10.86|
000018  0789              LSLS     r1,r1,#30             ;195
00001a  69cb              LDR      r3,[r1,#0x1c]         ;195
00001c  9300              STR      r3,[sp,#0]            ;195
00001e  9b00              LDR      r3,[sp,#0]            ;195
000020  f0430304          ORR      r3,r3,#4              ;195
000024  9300              STR      r3,[sp,#0]            ;195
000026  9b00              LDR      r3,[sp,#0]            ;195
000028  b29b              UXTH     r3,r3                 ;195
00002a  f1036380          ADD      r3,r3,#0x4000000      ;195
00002e  f10373fd          ADD      r3,r3,#0x1fa0000      ;195
000032  9300              STR      r3,[sp,#0]            ;195
000034  9b00              LDR      r3,[sp,#0]            ;195
000036  61cb              STR      r3,[r1,#0x1c]         ;195
000038  6a4b              LDR      r3,[r1,#0x24]         ;195
00003a  9300              STR      r3,[sp,#0]            ;195
00003c  9b00              LDR      r3,[sp,#0]            ;195
00003e  f0430304          ORR      r3,r3,#4              ;195
000042  9300              STR      r3,[sp,#0]            ;195
000044  9b00              LDR      r3,[sp,#0]            ;195
000046  b29b              UXTH     r3,r3                 ;195
000048  f1036380          ADD      r3,r3,#0x4000000      ;195
00004c  f10373fd          ADD      r3,r3,#0x1fa0000      ;195
000050  9300              STR      r3,[sp,#0]            ;195
000052  9b00              LDR      r3,[sp,#0]            ;195
000054  624b              STR      r3,[r1,#0x24]         ;195
                  |L10.86|
;;;205    		}
;;;206    	}
;;;207    
;;;208    	ptHalInfo->bIsECLKOnOffStart = bIsEn;
000056  7110              STRB     r0,[r2,#4]
;;;209    }
000058  b001              ADD      sp,sp,#4
00005a  4770              BX       lr
;;;210    
                          ENDP

                  |L10.92|
                          DCD      ||.data||

                          AREA ||i.HAL_SetLocalIndex||, CODE, READONLY, ALIGN=2

                  HAL_SetLocalIndex PROC
;;;642    
;;;643    void HAL_SetLocalIndex(uint8_t index, uint8_t val)
000000  b510              PUSH     {r4,lr}
;;;644    {
;;;645    	MSPI_Set_TLPMODE();
000002  f7fffffe          BL       MSPI_Set_TLPMODE
000006  4803              LDR      r0,|L11.20|
000008  6800              LDR      r0,[r0,#0]  ; ptHalInfo
00000a  8840              LDRH     r0,[r0,#2]
;;;646    //	SW92400_Set_LocalPenSensingStatusCTRL(index, val);
;;;647    	MSPI_Set_AITMODE(HAL_GetSensingMode());
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      MSPI_Set_AITMODE
;;;648    }
;;;649    
                          ENDP

                  |L11.20|
                          DCD      ||.data||

                          AREA ||i.HAL_SetSensingChangeMode||, CODE, READONLY, ALIGN=2

                  HAL_SetSensingChangeMode PROC
;;;575    
;;;576    void HAL_SetSensingChangeMode(eSENSING_CHANGE_MODE_t mode)
000000  491e              LDR      r1,|L12.124|
;;;577    {
000002  b081              SUB      sp,sp,#4
000004  6809              LDR      r1,[r1,#0]
000006  b3a8              CBZ      r0,|L12.116|
000008  790a              LDRB     r2,[r1,#4]
;;;578    #if USED_ECLK_ON_OFF_CONTROL
;;;579    	// Mode 蹂�寃쎌떆 EClk On/Off Control�쓣 Disable�떆耳쒖빞 �븳�떎.
;;;580    	if(mode != SM_CHANGE_COMPLETE)
;;;581    	{
;;;582    		HAL_SetECLKOnOffControl(NO);
00000a  2300              MOVS     r3,#0
00000c  2a01              CMP      r2,#1
00000e  d130              BNE      |L12.114|
000010  0792              LSLS     r2,r2,#30
000012  f8d2c01c          LDR      r12,[r2,#0x1c]
000016  f8cdc000          STR      r12,[sp,#0]
00001a  f8ddc000          LDR      r12,[sp,#0]
00001e  f04c0c04          ORR      r12,r12,#4
000022  f8cdc000          STR      r12,[sp,#0]
000026  f8ddc000          LDR      r12,[sp,#0]
00002a  fa1ffc8c          UXTH     r12,r12
00002e  f10c6c80          ADD      r12,r12,#0x4000000
000032  f10c7cfd          ADD      r12,r12,#0x1fa0000
000036  f8cdc000          STR      r12,[sp,#0]
00003a  f8ddc000          LDR      r12,[sp,#0]
00003e  f8c2c01c          STR      r12,[r2,#0x1c]
000042  f8d2c024          LDR      r12,[r2,#0x24]
000046  f8cdc000          STR      r12,[sp,#0]
00004a  f8ddc000          LDR      r12,[sp,#0]
00004e  f04c0c04          ORR      r12,r12,#4
000052  f8cdc000          STR      r12,[sp,#0]
000056  f8ddc000          LDR      r12,[sp,#0]
00005a  fa1ffc8c          UXTH     r12,r12
00005e  f10c6c80          ADD      r12,r12,#0x4000000
000062  f10c7cfd          ADD      r12,r12,#0x1fa0000
000066  f8cdc000          STR      r12,[sp,#0]
00006a  f8ddc000          LDR      r12,[sp,#0]
00006e  f8c2c024          STR      r12,[r2,#0x24]
                  |L12.114|
000072  710b              STRB     r3,[r1,#4]
                  |L12.116|
;;;583    	}
;;;584    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;585    	ptHalInfo->eSensingChangeMode = mode;
000074  7008              STRB     r0,[r1,#0]
;;;586    }
000076  b001              ADD      sp,sp,#4
000078  4770              BX       lr
;;;587    
                          ENDP

00007a  0000              DCW      0x0000
                  |L12.124|
                          DCD      ||.data||

                          AREA ||i.HAL_SetSensingMode||, CODE, READONLY, ALIGN=2

                  HAL_SetSensingMode PROC
;;;592    
;;;593    void HAL_SetSensingMode(eSENSING_MODE_t mode)
000000  4901              LDR      r1,|L13.8|
;;;594    {
;;;595    	ptHalInfo->eSensingMode = mode;
000002  6809              LDR      r1,[r1,#0]  ; ptHalInfo
000004  8048              STRH     r0,[r1,#2]
;;;596    }
000006  4770              BX       lr
;;;597    
                          ENDP

                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.HAL_SetTPICMuxEnControl||, CODE, READONLY, ALIGN=2

                  HAL_SetTPICMuxEnControl PROC
;;;239    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;240    void HAL_SetTPICMuxEnControl(bool_t bIsEn)
000000  4904              LDR      r1,|L14.20|
;;;241    {
;;;242    #if (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405)
;;;243    	if(bIsEn)
;;;244    	{
;;;245    		if(ptHalInfo->bIsTPICMuxEnOnOffStart == NO)
000002  6809              LDR      r1,[r1,#0]
000004  b120              CBZ      r0,|L14.16|
000006  798a              LDRB     r2,[r1,#6]
000008  2a00              CMP      r2,#0
;;;246    		{
;;;247    			ptHalInfo->bIsTPICMuxEnOnOfftartCheckCnt = 0;
00000a  bf04              ITT      EQ
00000c  2200              MOVEQ    r2,#0
00000e  71ca              STRBEQ   r2,[r1,#7]
                  |L14.16|
;;;248    		}
;;;249    	}
;;;250    #else /* (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405) */
;;;251    	if(bIsEn == NO)
;;;252    	{
;;;253    		if(ptHalInfo->bIsTPICMuxEnOnOffStart == YES)
;;;254    		{
;;;255    			GPIO->tGPIO_DATA_1._GPIO_TPIC_MUX_EN = 1;
;;;256    		}
;;;257    	}
;;;258    	else
;;;259    	{
;;;260    		if(ptHalInfo->bIsTPICMuxEnOnOffStart == NO)
;;;261    		{
;;;262    			ptHalInfo->bIsTPICMuxEnOnOfftartCheckCnt = 0;
;;;263    		}
;;;264    	}
;;;265    #endif /* (CUSTOMER == MODEL_LGD_SW92400) */
;;;266    
;;;267    	ptHalInfo->bIsTPICMuxEnOnOffStart = bIsEn;
000010  7188              STRB     r0,[r1,#6]
;;;268    }
000012  4770              BX       lr
;;;269    
                          ENDP

                  |L14.20|
                          DCD      ||.data||

                          AREA ||i.Hal_VccOff_State||, CODE, READONLY, ALIGN=2

                  Hal_VccOff_State PROC
;;;412    
;;;413    void Hal_VccOff_State(void)
000000  b510              PUSH     {r4,lr}
;;;414    {
;;;415    	// ECLK OFF
;;;416    	SCRB->ECLK_CFG.ulBulk = ( SCB_VECTKEY
000002  f04f4180          MOV      r1,#0x40000000
000006  48b9              LDR      r0,|L15.748|
000008  63c8              STR      r0,[r1,#0x3c]
;;;417    	| 0         << 0
;;;418    	| 7         << 4
;;;419    	| 0  << 9 );
;;;420    
;;;421    	//Tsync Pull-Down
;;;422    	//Out
;;;423    	GPIO->tGPIO_AFIO_2._GPIO_TSYNC_OUT = 0x0;
00000a  4cb9              LDR      r4,|L15.752|
00000c  6ea0              LDR      r0,[r4,#0x68]
00000e  f02000c0          BIC      r0,r0,#0xc0
000012  66a0              STR      r0,[r4,#0x68]
;;;424    	GPIO->tGPIO_DIR_1._GPIO_TSYNC_OUT  = 0x1;  // OUTPUT
000014  68e0              LDR      r0,[r4,#0xc]
000016  f0400008          ORR      r0,r0,#8
00001a  60e0              STR      r0,[r4,#0xc]
;;;425    	GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x0;
00001c  6860              LDR      r0,[r4,#4]
00001e  f0200008          BIC      r0,r0,#8
000022  6060              STR      r0,[r4,#4]
;;;426    
;;;427    	//In
;;;428    	GPIO->tGPIO_AFIO_1._GPIO_TSYNC_IN = 0x0;
000024  6e60              LDR      r0,[r4,#0x64]
000026  f4200040          BIC      r0,r0,#0xc00000
00002a  6660              STR      r0,[r4,#0x64]
;;;429    	GPIO->tGPIO_DIR_0._GPIO_TSYNC_IN  = 0x1;  // OUTPUT
00002c  68a0              LDR      r0,[r4,#8]
00002e  f0406000          ORR      r0,r0,#0x8000000
000032  60a0              STR      r0,[r4,#8]
;;;430    	GPIO->tGPIO_DATA_0._GPIO_TSYNC_IN = 0x0;
000034  6820              LDR      r0,[r4,#0]
000036  f0206000          BIC      r0,r0,#0x8000000
00003a  6020              STR      r0,[r4,#0]
;;;431    
;;;432    	//Vsync Pull-Down
;;;433    	GPIO->tGPIO_AFIO_1._GPIO_VSYNC = 0x0; // VSYNC
00003c  6e60              LDR      r0,[r4,#0x64]
00003e  f4201040          BIC      r0,r0,#0x300000
000042  6660              STR      r0,[r4,#0x64]
;;;434    	GPIO->tGPIO_DIR_0._GPIO_VSYNC  = 0x1;  // OUTPUT
000044  68a0              LDR      r0,[r4,#8]
000046  f0406080          ORR      r0,r0,#0x4000000
00004a  60a0              STR      r0,[r4,#8]
;;;435    	GPIO->tGPIO_DATA_0._GPIO_VSYNC = 0x0;
00004c  6820              LDR      r0,[r4,#0]
00004e  f0206080          BIC      r0,r0,#0x4000000
000052  6020              STR      r0,[r4,#0]
;;;436    
;;;437    	//MSPI Pull-Down
;;;438    	initGPIO(PIN_MSPI_SSN_0,GPIO_Mode0_GPIO,Output);
000054  2100              MOVS     r1,#0
000056  2201              MOVS     r2,#1
000058  4608              MOV      r0,r1
00005a  f7fffffe          BL       initGPIO
;;;439    	initGPIO(PIN_MSPI_SSN_1,GPIO_Mode0_GPIO,Output);
00005e  2201              MOVS     r2,#1
000060  2100              MOVS     r1,#0
000062  2004              MOVS     r0,#4
000064  f7fffffe          BL       initGPIO
;;;440    	initGPIO(PIN_MSPI_SSN_2,GPIO_Mode0_GPIO,Output);
000068  2201              MOVS     r2,#1
00006a  2100              MOVS     r1,#0
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       initGPIO
;;;441    	initGPIO(PIN_MSPI_SSN_3,GPIO_Mode0_GPIO,Output);
000072  2201              MOVS     r2,#1
000074  2100              MOVS     r1,#0
000076  200c              MOVS     r0,#0xc
000078  f7fffffe          BL       initGPIO
;;;442    	initGPIO(PIN_MSPI_SSN_4,GPIO_Mode0_GPIO,Output);
00007c  2201              MOVS     r2,#1
00007e  2100              MOVS     r1,#0
000080  2010              MOVS     r0,#0x10
000082  f7fffffe          BL       initGPIO
;;;443    	initGPIO(PIN_MSPI_SSN_5,GPIO_Mode0_GPIO,Output);
000086  2201              MOVS     r2,#1
000088  2100              MOVS     r1,#0
00008a  2014              MOVS     r0,#0x14
00008c  f7fffffe          BL       initGPIO
;;;444    
;;;445    	initGPIO(PIN_MSPI_MOSI_0,GPIO_Mode0_GPIO,Output);
000090  2201              MOVS     r2,#1
000092  2100              MOVS     r1,#0
000094  2002              MOVS     r0,#2
000096  f7fffffe          BL       initGPIO
;;;446    	initGPIO(PIN_MSPI_MOSI_1,GPIO_Mode0_GPIO,Output);
00009a  2201              MOVS     r2,#1
00009c  2100              MOVS     r1,#0
00009e  2006              MOVS     r0,#6
0000a0  f7fffffe          BL       initGPIO
;;;447    	initGPIO(PIN_MSPI_MOSI_2,GPIO_Mode0_GPIO,Output);
0000a4  2201              MOVS     r2,#1
0000a6  2100              MOVS     r1,#0
0000a8  200a              MOVS     r0,#0xa
0000aa  f7fffffe          BL       initGPIO
;;;448    	initGPIO(PIN_MSPI_MOSI_3,GPIO_Mode0_GPIO,Output);
0000ae  2201              MOVS     r2,#1
0000b0  2100              MOVS     r1,#0
0000b2  200e              MOVS     r0,#0xe
0000b4  f7fffffe          BL       initGPIO
;;;449    	initGPIO(PIN_MSPI_MOSI_4,GPIO_Mode0_GPIO,Output);
0000b8  2201              MOVS     r2,#1
0000ba  2100              MOVS     r1,#0
0000bc  2012              MOVS     r0,#0x12
0000be  f7fffffe          BL       initGPIO
;;;450    	initGPIO(PIN_MSPI_MOSI_5,GPIO_Mode0_GPIO,Output);
0000c2  2201              MOVS     r2,#1
0000c4  2100              MOVS     r1,#0
0000c6  2016              MOVS     r0,#0x16
0000c8  f7fffffe          BL       initGPIO
;;;451    
;;;452    	initGPIO(PIN_MSPI_MISO_0,GPIO_Mode0_GPIO,Output);
0000cc  2201              MOVS     r2,#1
0000ce  2100              MOVS     r1,#0
0000d0  2003              MOVS     r0,#3
0000d2  f7fffffe          BL       initGPIO
;;;453    	initGPIO(PIN_MSPI_MISO_1,GPIO_Mode0_GPIO,Output);
0000d6  2201              MOVS     r2,#1
0000d8  2100              MOVS     r1,#0
0000da  2007              MOVS     r0,#7
0000dc  f7fffffe          BL       initGPIO
;;;454    	initGPIO(PIN_MSPI_MISO_2,GPIO_Mode0_GPIO,Output);
0000e0  2201              MOVS     r2,#1
0000e2  2100              MOVS     r1,#0
0000e4  200b              MOVS     r0,#0xb
0000e6  f7fffffe          BL       initGPIO
;;;455    	initGPIO(PIN_MSPI_MISO_3,GPIO_Mode0_GPIO,Output);
0000ea  2201              MOVS     r2,#1
0000ec  2100              MOVS     r1,#0
0000ee  200f              MOVS     r0,#0xf
0000f0  f7fffffe          BL       initGPIO
;;;456    	initGPIO(PIN_MSPI_MISO_4,GPIO_Mode0_GPIO,Output);
0000f4  2201              MOVS     r2,#1
0000f6  2100              MOVS     r1,#0
0000f8  2013              MOVS     r0,#0x13
0000fa  f7fffffe          BL       initGPIO
;;;457    	initGPIO(PIN_MSPI_MISO_5,GPIO_Mode0_GPIO,Output);
0000fe  2201              MOVS     r2,#1
000100  2100              MOVS     r1,#0
000102  2017              MOVS     r0,#0x17
000104  f7fffffe          BL       initGPIO
;;;458    
;;;459    	writeBitToGPIO( PIN_MSPI_SSN_0, LOW);
000108  2100              MOVS     r1,#0
00010a  4608              MOV      r0,r1
00010c  f7fffffe          BL       writeBitToGPIO
;;;460    	writeBitToGPIO( PIN_MSPI_SSN_1, LOW);
000110  2100              MOVS     r1,#0
000112  2004              MOVS     r0,#4
000114  f7fffffe          BL       writeBitToGPIO
;;;461    	writeBitToGPIO( PIN_MSPI_SSN_2, LOW);
000118  2100              MOVS     r1,#0
00011a  2008              MOVS     r0,#8
00011c  f7fffffe          BL       writeBitToGPIO
;;;462    	writeBitToGPIO( PIN_MSPI_SSN_3, LOW);
000120  2100              MOVS     r1,#0
000122  200c              MOVS     r0,#0xc
000124  f7fffffe          BL       writeBitToGPIO
;;;463    	writeBitToGPIO( PIN_MSPI_SSN_4, LOW);
000128  2100              MOVS     r1,#0
00012a  2010              MOVS     r0,#0x10
00012c  f7fffffe          BL       writeBitToGPIO
;;;464    	writeBitToGPIO( PIN_MSPI_SSN_5, LOW);
000130  2100              MOVS     r1,#0
000132  2014              MOVS     r0,#0x14
000134  f7fffffe          BL       writeBitToGPIO
;;;465    
;;;466    	writeBitToGPIO( PIN_MSPI_MOSI_0, LOW);
000138  2100              MOVS     r1,#0
00013a  2002              MOVS     r0,#2
00013c  f7fffffe          BL       writeBitToGPIO
;;;467    	writeBitToGPIO( PIN_MSPI_MOSI_1, LOW);
000140  2100              MOVS     r1,#0
000142  2006              MOVS     r0,#6
000144  f7fffffe          BL       writeBitToGPIO
;;;468    	writeBitToGPIO( PIN_MSPI_MOSI_2, LOW);
000148  2100              MOVS     r1,#0
00014a  200a              MOVS     r0,#0xa
00014c  f7fffffe          BL       writeBitToGPIO
;;;469    	writeBitToGPIO( PIN_MSPI_MOSI_3, LOW);
000150  2100              MOVS     r1,#0
000152  200e              MOVS     r0,#0xe
000154  f7fffffe          BL       writeBitToGPIO
;;;470    	writeBitToGPIO( PIN_MSPI_MOSI_4, LOW);
000158  2100              MOVS     r1,#0
00015a  2012              MOVS     r0,#0x12
00015c  f7fffffe          BL       writeBitToGPIO
;;;471    	writeBitToGPIO( PIN_MSPI_MOSI_5, LOW);
000160  2100              MOVS     r1,#0
000162  2016              MOVS     r0,#0x16
000164  f7fffffe          BL       writeBitToGPIO
;;;472    
;;;473    	writeBitToGPIO( PIN_MSPI_MISO_0, LOW);
000168  2100              MOVS     r1,#0
00016a  2003              MOVS     r0,#3
00016c  f7fffffe          BL       writeBitToGPIO
;;;474    	writeBitToGPIO( PIN_MSPI_MISO_1, LOW);
000170  2100              MOVS     r1,#0
000172  2007              MOVS     r0,#7
000174  f7fffffe          BL       writeBitToGPIO
;;;475    	writeBitToGPIO( PIN_MSPI_MISO_2, LOW);
000178  2100              MOVS     r1,#0
00017a  200b              MOVS     r0,#0xb
00017c  f7fffffe          BL       writeBitToGPIO
;;;476    	writeBitToGPIO( PIN_MSPI_MISO_3, LOW);
000180  2100              MOVS     r1,#0
000182  200f              MOVS     r0,#0xf
000184  f7fffffe          BL       writeBitToGPIO
;;;477    	writeBitToGPIO( PIN_MSPI_MISO_4, LOW);
000188  2100              MOVS     r1,#0
00018a  2013              MOVS     r0,#0x13
00018c  f7fffffe          BL       writeBitToGPIO
;;;478    	writeBitToGPIO( PIN_MSPI_MISO_5, LOW);
000190  2100              MOVS     r1,#0
000192  2017              MOVS     r0,#0x17
000194  f7fffffe          BL       writeBitToGPIO
;;;479    
;;;480    	//TP EN -> GPIO -> Low
;;;481    	GPIO->tGPIO_DATA_1._GPIO_TP_EN = 0x00;
000198  6860              LDR      r0,[r4,#4]
00019a  f4204000          BIC      r0,r0,#0x8000
00019e  6060              STR      r0,[r4,#4]
;;;482    	GPIO->tGPIO_DIR_1._GPIO_TP_EN = 0x1;  // OUTPUT
0001a0  68e0              LDR      r0,[r4,#0xc]
0001a2  f4404000          ORR      r0,r0,#0x8000
0001a6  60e0              STR      r0,[r4,#0xc]
;;;483    	GPIO->tGPIO_AFIO_2._GPIO_TP_EN = 0x0;
0001a8  6ea0              LDR      r0,[r4,#0x68]
0001aa  f0204040          BIC      r0,r0,#0xc0000000
0001ae  66a0              STR      r0,[r4,#0x68]
;;;484    
;;;485    	//PWM Pull-Down
;;;486    	GPIO->tGPIO_AFIO_1._GPIO_PWM_SRIC = 0x0; // PWM_TX
0001b0  6e60              LDR      r0,[r4,#0x64]
0001b2  f0207040          BIC      r0,r0,#0x3000000
0001b6  6660              STR      r0,[r4,#0x64]
;;;487    	GPIO->tGPIO_DIR_0._GPIO_PWM_SRIC  = 0x1;  // output
0001b8  68a0              LDR      r0,[r4,#8]
0001ba  f0405080          ORR      r0,r0,#0x10000000
0001be  60a0              STR      r0,[r4,#8]
;;;488    	GPIO->tGPIO_DATA_0._GPIO_PWM_SRIC = 0x0;
0001c0  6820              LDR      r0,[r4,#0]
0001c2  f0205080          BIC      r0,r0,#0x10000000
0001c6  6020              STR      r0,[r4,#0]
;;;489    #if USED_TEST_OPERATION_ENABLE
;;;490    	GPIO->tGPIO_AFIO_1._GPIO_PWM_TPIC = 0x0; // LFD
;;;491    	GPIO->tGPIO_DIR_0._GPIO_PWM_TPIC  = 0x1;  // output
;;;492    	GPIO->tGPIO_DATA_0._GPIO_PWM_TPIC = 0x0;
;;;493    #endif
;;;494    	//SCLK Pull-Down
;;;495    	GPIO->tGPIO_AFIO_0._GPIO_MSPI_0_SCLK = 0x0; // 0:GPIO, 1:MSPI0_MST_SCLK
0001c8  6e20              LDR      r0,[r4,#0x60]
0001ca  f020000c          BIC      r0,r0,#0xc
0001ce  6620              STR      r0,[r4,#0x60]
;;;496    	GPIO->tGPIO_DIR_0._GPIO_MSPI_0_SCLK  = 0x1;  // output
0001d0  68a0              LDR      r0,[r4,#8]
0001d2  f0400002          ORR      r0,r0,#2
0001d6  60a0              STR      r0,[r4,#8]
;;;497    	GPIO->tGPIO_DATA_0._GPIO_MSPI_0_SCLK = 0x0;
0001d8  6820              LDR      r0,[r4,#0]
0001da  f0200002          BIC      r0,r0,#2
0001de  6020              STR      r0,[r4,#0]
;;;498    
;;;499    	GPIO->tGPIO_AFIO_0._GPIO_MSPI_1_SCLK = 0x0; // 0:GPIO, 1:MSPI1_MST_SCLK
0001e0  6e20              LDR      r0,[r4,#0x60]
0001e2  f4206040          BIC      r0,r0,#0xc00
0001e6  6620              STR      r0,[r4,#0x60]
;;;500    	GPIO->tGPIO_DIR_0._GPIO_MSPI_1_SCLK  = 0x1;  // output
0001e8  68a0              LDR      r0,[r4,#8]
0001ea  f0400020          ORR      r0,r0,#0x20
0001ee  60a0              STR      r0,[r4,#8]
;;;501    	GPIO->tGPIO_DATA_0._GPIO_MSPI_1_SCLK = 0x0;
0001f0  6820              LDR      r0,[r4,#0]
0001f2  f0200020          BIC      r0,r0,#0x20
0001f6  6020              STR      r0,[r4,#0]
;;;502    
;;;503    	GPIO->tGPIO_AFIO_0._GPIO_MSPI_2_SCLK = 0x0; // 0:GPIO, 1:MSPI2_MST_SCLK
0001f8  6e20              LDR      r0,[r4,#0x60]
0001fa  f4202040          BIC      r0,r0,#0xc0000
0001fe  6620              STR      r0,[r4,#0x60]
;;;504    	GPIO->tGPIO_DIR_0._GPIO_MSPI_2_SCLK  = 0x1;  // output
000200  68a0              LDR      r0,[r4,#8]
000202  f4407000          ORR      r0,r0,#0x200
000206  60a0              STR      r0,[r4,#8]
;;;505    	GPIO->tGPIO_DATA_0._GPIO_MSPI_2_SCLK = 0x0;
000208  6820              LDR      r0,[r4,#0]
00020a  f4207000          BIC      r0,r0,#0x200
00020e  6020              STR      r0,[r4,#0]
;;;506    
;;;507    	GPIO->tGPIO_AFIO_0._GPIO_MSPI_3_SCLK = 0x0; // 0:GPIO, 1:MSPI3_MST_SCLK
000210  6e20              LDR      r0,[r4,#0x60]
000212  f0206040          BIC      r0,r0,#0xc000000
000216  6620              STR      r0,[r4,#0x60]
;;;508    	GPIO->tGPIO_DIR_0._GPIO_MSPI_3_SCLK  = 0x1;  // output
000218  68a0              LDR      r0,[r4,#8]
00021a  f4405000          ORR      r0,r0,#0x2000
00021e  60a0              STR      r0,[r4,#8]
;;;509    	GPIO->tGPIO_DATA_0._GPIO_MSPI_3_SCLK = 0x0;
000220  6820              LDR      r0,[r4,#0]
000222  f4205000          BIC      r0,r0,#0x2000
000226  6020              STR      r0,[r4,#0]
;;;510    
;;;511    	GPIO->tGPIO_AFIO_1._GPIO_MSPI_4_SCLK = 0x0; // 0:GPIO, 1:MSPI4_MST_SCLK
000228  6e60              LDR      r0,[r4,#0x64]
00022a  f020000c          BIC      r0,r0,#0xc
00022e  6660              STR      r0,[r4,#0x64]
;;;512    	GPIO->tGPIO_DIR_0._GPIO_MSPI_4_SCLK  = 0x1;  // output
000230  68a0              LDR      r0,[r4,#8]
000232  f4403000          ORR      r0,r0,#0x20000
000236  60a0              STR      r0,[r4,#8]
;;;513    	GPIO->tGPIO_DATA_0._GPIO_MSPI_4_SCLK = 0x0;
000238  6820              LDR      r0,[r4,#0]
00023a  f4203000          BIC      r0,r0,#0x20000
00023e  6020              STR      r0,[r4,#0]
;;;514    
;;;515    	GPIO->tGPIO_AFIO_1._GPIO_MSPI_5_SCLK = 0x0; // 0:GPIO, 1:MSPI5_MST_SCLK
000240  6e60              LDR      r0,[r4,#0x64]
000242  f4206040          BIC      r0,r0,#0xc00
000246  6660              STR      r0,[r4,#0x64]
;;;516    	GPIO->tGPIO_DIR_0._GPIO_MSPI_5_SCLK  = 0x1;  // output
000248  68a0              LDR      r0,[r4,#8]
00024a  f4401000          ORR      r0,r0,#0x200000
00024e  60a0              STR      r0,[r4,#8]
;;;517    	GPIO->tGPIO_DATA_0._GPIO_MSPI_5_SCLK = 0x0;
000250  6820              LDR      r0,[r4,#0]
000252  f4201000          BIC      r0,r0,#0x200000
000256  6020              STR      r0,[r4,#0]
;;;518    
;;;519    	//ECLK Pull-Down
;;;520    	GPIO->tGPIO_AFIO_1._GPIO_ECLK_0 = 0x0;  // ECLK0
000258  6e60              LDR      r0,[r4,#0x64]
00025a  f4203040          BIC      r0,r0,#0x30000
00025e  6660              STR      r0,[r4,#0x64]
;;;521    	GPIO->tGPIO_DIR_0._GPIO_ECLK_0  = 0x1;  // output
000260  68a0              LDR      r0,[r4,#8]
000262  f0407080          ORR      r0,r0,#0x1000000
000266  60a0              STR      r0,[r4,#8]
;;;522    	GPIO->tGPIO_DATA_0._GPIO_ECLK_0 = 0x0;
000268  6820              LDR      r0,[r4,#0]
00026a  f0207080          BIC      r0,r0,#0x1000000
00026e  6020              STR      r0,[r4,#0]
;;;523    
;;;524    	GPIO->tGPIO_AFIO_1._GPIO_ECLK_1 = 0x0;  // ECLK1
000270  6e60              LDR      r0,[r4,#0x64]
000272  f4202040          BIC      r0,r0,#0xc0000
000276  6660              STR      r0,[r4,#0x64]
;;;525    	GPIO->tGPIO_DIR_0._GPIO_ECLK_1  = 0x1;  // output
000278  68a0              LDR      r0,[r4,#8]
00027a  f0407000          ORR      r0,r0,#0x2000000
00027e  60a0              STR      r0,[r4,#8]
;;;526    	GPIO->tGPIO_DATA_0._GPIO_ECLK_1 = 0x0;
000280  6820              LDR      r0,[r4,#0]
000282  f0207000          BIC      r0,r0,#0x2000000
000286  6020              STR      r0,[r4,#0]
;;;527    	
;;;528    	GPIO->tGPIO_PU_0._GPIO_TSYNC_IN	= 0x0;	// OUTPUT
000288  69a0              LDR      r0,[r4,#0x18]
00028a  f0206000          BIC      r0,r0,#0x8000000
00028e  61a0              STR      r0,[r4,#0x18]
;;;529    	GPIO->tGPIO_PU_0._GPIO_VSYNC	= 0x0;	// OUTPUT
000290  69a0              LDR      r0,[r4,#0x18]
000292  f0206080          BIC      r0,r0,#0x4000000
000296  61a0              STR      r0,[r4,#0x18]
;;;530    	GPIO->tGPIO_PU_1._GPIO_LCD_ON  = 0x0;	// Input
000298  69e0              LDR      r0,[r4,#0x1c]
00029a  f0200004          BIC      r0,r0,#4
00029e  61e0              STR      r0,[r4,#0x1c]
;;;531    
;;;532    	GPIO->tGPIO_PU_0._GPIO_MSPI_0_MISO = 0x0; // 0:GPIO, 1:MSPI0_MST_MISO
0002a0  69a0              LDR      r0,[r4,#0x18]
0002a2  f0200008          BIC      r0,r0,#8
0002a6  61a0              STR      r0,[r4,#0x18]
;;;533    	GPIO->tGPIO_PU_0._GPIO_MSPI_1_MISO = 0x0; // 0:GPIO, 1:MSPI1_MST_MISO
0002a8  69a0              LDR      r0,[r4,#0x18]
0002aa  f0200080          BIC      r0,r0,#0x80
0002ae  61a0              STR      r0,[r4,#0x18]
;;;534    	GPIO->tGPIO_PU_0._GPIO_MSPI_2_MISO = 0x0; // 0:GPIO, 1:MSPI2_MST_MISO
0002b0  69a0              LDR      r0,[r4,#0x18]
0002b2  f4206000          BIC      r0,r0,#0x800
0002b6  61a0              STR      r0,[r4,#0x18]
;;;535    	GPIO->tGPIO_PU_0._GPIO_MSPI_3_MISO = 0x0; // 0:GPIO, 1:MSPI3_MST_MISO
0002b8  69a0              LDR      r0,[r4,#0x18]
0002ba  f4204000          BIC      r0,r0,#0x8000
0002be  61a0              STR      r0,[r4,#0x18]
;;;536    	GPIO->tGPIO_PU_0._GPIO_MSPI_4_MISO = 0x0; // 0:GPIO, 1:MSPI4_MST_MISO
0002c0  69a0              LDR      r0,[r4,#0x18]
0002c2  f4202000          BIC      r0,r0,#0x80000
0002c6  61a0              STR      r0,[r4,#0x18]
;;;537    	GPIO->tGPIO_PU_0._GPIO_MSPI_5_MISO = 0x0; // 0:GPIO, 1:MSPI5_MST_MISO
0002c8  69a0              LDR      r0,[r4,#0x18]
0002ca  f4200000          BIC      r0,r0,#0x800000
0002ce  61a0              STR      r0,[r4,#0x18]
;;;538    
;;;539    	GPIO->tGPIO_AFIO_3._GPIO_TP_INTR = 0x0;
0002d0  6ee0              LDR      r0,[r4,#0x6c]
0002d2  f0200003          BIC      r0,r0,#3
0002d6  66e0              STR      r0,[r4,#0x6c]
;;;540    	GPIO->tGPIO_DIR_1._GPIO_TP_INTR = 0x1;
0002d8  68e0              LDR      r0,[r4,#0xc]
0002da  f4403080          ORR      r0,r0,#0x10000
0002de  60e0              STR      r0,[r4,#0xc]
;;;541    	GPIO->tGPIO_DATA_1._GPIO_TP_INTR = I2C_GPB10__HIGH;
0002e0  6860              LDR      r0,[r4,#4]
0002e2  f4403080          ORR      r0,r0,#0x10000
0002e6  6060              STR      r0,[r4,#4]
;;;542    }
0002e8  bd10              POP      {r4,pc}
;;;543    
                          ENDP

0002ea  0000              DCW      0x0000
                  |L15.748|
                          DCD      0x05fa0070
                  |L15.752|
                          DCD      0x40007000

                          AREA ||i.Hal_sric_start||, CODE, READONLY, ALIGN=2

                  Hal_sric_start PROC
;;;298    
;;;299    bool_t Hal_sric_start(bool_t cmuxoff)
000000  b5f8              PUSH     {r3-r7,lr}
;;;300    {
;;;301    	int InitFail;
;;;302    	static int fail; 
;;;303    	eSENSING_MODE_t eSensingMode;
;;;304    	eSensingMode = HAL_GetSensingMode();
000002  4d38              LDR      r5,|L16.228|
000004  6828              LDR      r0,[r5,#0]  ; ptHalInfo
000006  8846              LDRH     r6,[r0,#2]
;;;305    
;;;306    #if USED_OPERATION_STAND_ALONE
;;;307    	if(!IS_S3_MODE(eSensingMode))
;;;308    	{
;;;309    		while(GPIO->tGPIO_DATA_0._GPIO_TSYNC_IN == 0);
;;;310    		while(GPIO->tGPIO_DATA_0._GPIO_TSYNC_IN == 1);
;;;311    	}
;;;312    #endif /* !USED_OPERATION_STAND_ALONE */
;;;313    
;;;314    #if (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405)
;;;315    	PWMDRV_Init(SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE);
000008  f2410003          MOV      r0,#0x1003
00000c  f7fffffe          BL       PWMDRV_Init
;;;316    #else /* (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405) */
;;;317    	PWMDRV_Init(eSensingMode);
;;;318    #endif /* (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405) */
;;;319    //	SW92400_Reset(eSensingMode);
;;;320    	GPIO->tGPIO_DATA_0._GPIO_RSTN_0 = 0;
000010  4c35              LDR      r4,|L16.232|
000012  6820              LDR      r0,[r4,#0]
000014  f0204080          BIC      r0,r0,#0x40000000
000018  6020              STR      r0,[r4,#0]
;;;321    	GPIO->tGPIO_DATA_0._GPIO_RSTN_1 = 0;
00001a  6820              LDR      r0,[r4,#0]
00001c  f0204000          BIC      r0,r0,#0x80000000
000020  6020              STR      r0,[r4,#0]
;;;322    	delay_ms(50);
000022  2032              MOVS     r0,#0x32
000024  f7fffffe          BL       delay_ms
;;;323    	GPIO->tGPIO_DATA_0._GPIO_RSTN_0 = 1;
000028  6820              LDR      r0,[r4,#0]
00002a  f0404080          ORR      r0,r0,#0x40000000
00002e  6020              STR      r0,[r4,#0]
;;;324    	GPIO->tGPIO_DATA_0._GPIO_RSTN_1 = 1;
000030  6820              LDR      r0,[r4,#0]
000032  f0404000          ORR      r0,r0,#0x80000000
000036  6020              STR      r0,[r4,#0]
;;;325    
;;;326    	delay_ms(100);
000038  2064              MOVS     r0,#0x64
00003a  f7fffffe          BL       delay_ms
;;;327    	MSPI_Reset();
00003e  f7fffffe          BL       MSPI_Reset
;;;328    	MSPI_Initialize();
000042  f7fffffe          BL       MSPI_Initialize
;;;329    	MSPI_Set_TLPMODE();
000046  f7fffffe          BL       MSPI_Set_TLPMODE
                  |L16.74|
;;;330    	
;;;331    #if USED_LPWG_MODE_CONTROL
;;;332    	if(module_Check_LcdOn(NO) == NO)
;;;333    	{
;;;334    		delay_ms(10);
;;;335    	}
;;;336    	else
;;;337    	{
;;;338    		while(GPIO->tGPIO_DATA_0._GPIO_TSYNC_IN == 0x0);
;;;339    		while(GPIO->tGPIO_DATA_0._GPIO_TSYNC_IN == 0x1);
;;;340    	}
;;;341    #else /* USED_LPWG_MODE_CONTROL */
;;;342    	while(GPIO->tGPIO_DATA_0._GPIO_TSYNC_IN == 0x0);
00004a  6820              LDR      r0,[r4,#0]
00004c  f0106f00          TST      r0,#0x8000000
000050  d0fb              BEQ      |L16.74|
                  |L16.82|
;;;343    	while(GPIO->tGPIO_DATA_0._GPIO_TSYNC_IN == 0x1);
000052  6820              LDR      r0,[r4,#0]
000054  f0106f00          TST      r0,#0x8000000
000058  d1fb              BNE      |L16.82|
;;;344    #endif /* USED_LPWG_MODE_CONTROL */
;;;345    	
;;;346    	if(SRIC_Init(eSensingMode)==FALSE)
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       SRIC_Init
000060  2800              CMP      r0,#0
;;;347    		return FALSE;
;;;348    
;;;349    #if USED_OPERATION_STAND_ALONE
;;;350    	if(!IS_S3_MODE(eSensingMode))
;;;351    	{
;;;352    		while(gTSyncInRisingCnt != 16);
;;;353    	}
;;;354    #endif /* !USED_OPERATION_STAND_ALONE */
;;;355    
;;;356    	//Skip 1st dummy data of SRIC
;;;357    #if USED_LPWG_MODE_CONTROL
;;;358    	if(IS_LPWG_MODE(HAL_GetSensingMode()))
;;;359    	{	
;;;360    		SRIC_Run();
;;;361    		MSPI_Set_AITMODE(eSensingMode);
;;;362    		MSPI_Cmd(ENABLE);
;;;363    		HAL_Timer_Set_Count_us(TIM_Channel_0, 50000);
;;;364    		HAL_Timer_Enable(TIM_Channel_0, ENABLE);
;;;365    		GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x1;
;;;366    		GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x0;
;;;367    		delay_us(3000);
;;;368    	}
;;;369    	else
;;;370    	{
;;;371    		while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 1);
;;;372    		while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 0);
;;;373    		SRIC_Run();
;;;374    		MSPI_Set_AITMODE(eSensingMode);
;;;375    		MSPI_Cmd(ENABLE);
;;;376    		while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 1);
;;;377    		while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 0);
;;;378    	}
;;;379    #else /* USED_LPWG_MODE_CONTROL */
;;;380    	while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 1);
;;;381    	while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 0);
;;;382    	SRIC_Run();
;;;383    	MSPI_Set_AITMODE(eSensingMode);
;;;384    	MSPI_Cmd(ENABLE);
;;;385    	while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 1);
;;;386    	while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 0);
;;;387    #endif /* USED_LPWG_MODE_CONTROL */
;;;388    	
;;;389    	MSPI_Cmd(ENABLE);
;;;390    	PWMDRV_Cmd(ENABLE);
;;;391    	MSPI_ITConfig(ENABLE);	
;;;392    
;;;393    //	PWMDRV_Cmd(ENABLE);
;;;394    #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;395    	HAL_SetTPICMuxEnControl(YES);
;;;396    #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;397    #if USED_TSYNC2_INPUT_CONTROL
;;;398    	GPIO->tGPIO_PU_1._GPIO_TSYNC2_IN = 0x0;	// Input
;;;399    	init_EXIT(PIN_GPA37, EDGE_DETECTION_GPIO, BOTH_EDGE_GPIO, POSITIVE_HIGH_GPIO, ENABLE_GPIO);
;;;400    	NVIC_SetPriority(EXTI0_IRQn, EXTI0_IRQn_Priority);
;;;401    	NVIC_EnableIRQ(EXTI0_IRQn);
;;;402    #endif /* USED_TSYNC2_INPUT_CONTROL */
;;;403    
;;;404    #if USED_NEW_TCON_BOARD
;;;405    	PWMDRV->FW_CTRL_b.VSYNC_IN = 1;
;;;406    ////	while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 0);
;;;407    ////	while(GPIO->tGPIO_DATA_0._GPIO_VSYNC == 1);
;;;408    #endif /* USED_NEW_TCON_BOARD */
;;;409    
;;;410    	return YES;
;;;411    }
000062  bf08              IT       EQ
000064  bdf8              POPEQ    {r3-r7,pc}
                  |L16.102|
000066  6820              LDR      r0,[r4,#0]            ;380
000068  f0106f80          TST      r0,#0x4000000         ;380
00006c  d1fb              BNE      |L16.102|
                  |L16.110|
00006e  6820              LDR      r0,[r4,#0]            ;381
000070  f0106f80          TST      r0,#0x4000000         ;381
000074  d0fb              BEQ      |L16.110|
000076  f7fffffe          BL       SRIC_Run
00007a  4630              MOV      r0,r6                 ;383
00007c  f7fffffe          BL       MSPI_Set_AITMODE
000080  2001              MOVS     r0,#1                 ;384
000082  f7fffffe          BL       MSPI_Cmd
                  |L16.134|
000086  6820              LDR      r0,[r4,#0]            ;385
000088  f0106f80          TST      r0,#0x4000000         ;385
00008c  d1fb              BNE      |L16.134|
                  |L16.142|
00008e  6820              LDR      r0,[r4,#0]            ;386
000090  f0106f80          TST      r0,#0x4000000         ;386
000094  d0fb              BEQ      |L16.142|
000096  2001              MOVS     r0,#1                 ;389
000098  f7fffffe          BL       MSPI_Cmd
00009c  2001              MOVS     r0,#1                 ;390
00009e  f7fffffe          BL       PWMDRV_Cmd
0000a2  2001              MOVS     r0,#1                 ;391
0000a4  f7fffffe          BL       MSPI_ITConfig
0000a8  6828              LDR      r0,[r5,#0]            ;391  ; ptHalInfo
0000aa  2101              MOVS     r1,#1                 ;395
0000ac  2200              MOVS     r2,#0                 ;395
0000ae  7983              LDRB     r3,[r0,#6]            ;395
0000b0  2b00              CMP      r3,#0                 ;395
0000b2  bf08              IT       EQ                    ;395
0000b4  71c2              STRBEQ   r2,[r0,#7]            ;395
0000b6  7181              STRB     r1,[r0,#6]            ;395
0000b8  69e0              LDR      r0,[r4,#0x1c]         ;398
0000ba  f0200020          BIC      r0,r0,#0x20           ;398
0000be  61e0              STR      r0,[r4,#0x1c]         ;398
0000c0  2001              MOVS     r0,#1                 ;399
0000c2  4603              MOV      r3,r0                 ;399
0000c4  4602              MOV      r2,r0                 ;399
0000c6  9000              STR      r0,[sp,#0]            ;399
0000c8  2100              MOVS     r1,#0                 ;399
0000ca  2025              MOVS     r0,#0x25              ;399
0000cc  f7fffffe          BL       init_EXIT
0000d0  4906              LDR      r1,|L16.236|
0000d2  2020              MOVS     r0,#0x20              ;399
0000d4  f8810400          STRB     r0,[r1,#0x400]        ;399
0000d8  2002              MOVS     r0,#2                 ;399
0000da  1e49              SUBS     r1,r1,#1              ;399
0000dc  f8c10100          STR      r0,[r1,#0x100]        ;399
0000e0  2001              MOVS     r0,#1                 ;410
0000e2  bdf8              POP      {r3-r7,pc}
;;;412    
                          ENDP

                  |L16.228|
                          DCD      ||.data||
                  |L16.232|
                          DCD      0x40007000
                  |L16.236|
                          DCD      0xe000e001

                          AREA ||i.callPendSV||, CODE, READONLY, ALIGN=2

                  callPendSV PROC
;;;287    
;;;288    void callPendSV(void)
000000  4904              LDR      r1,|L17.20|
;;;289    {
;;;290    	// Set a PendSV to request processing
;;;291    	NVIC_INT_CTRL_REG = NVIC_PENDSVSET_BIT;
000002  f04f5080          MOV      r0,#0x10000000
000006  6008              STR      r0,[r1,#0]
;;;292    	/* Barriers are normally not required but do ensure the code is completely	within the specified behaviour for the architecture. */
;;;293    	__asm volatile( "dsb" );
000008  f3bf8f4f          DSB      
;;;294    	__asm volatile( "isb" );
00000c  f3bf8f6f          ISB      
;;;295    }
000010  4770              BX       lr
;;;296    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0xe000ed04

                          AREA ||i.initBoardGPIO||, CODE, READONLY, ALIGN=2

                  initBoardGPIO PROC
;;;43     
;;;44     void initBoardGPIO(void)
000000  4829              LDR      r0,|L18.168|
;;;45     {
;;;46     #if (USED_LPWG_MODE_CONTROL == NO)
;;;47     	// TSYNCN_OUT
;;;48     	GPIO->tGPIO_DATA_1._GPIO_TSYNC_OUT = 0x01;
000002  6841              LDR      r1,[r0,#4]
000004  f0410108          ORR      r1,r1,#8
000008  6041              STR      r1,[r0,#4]
;;;49     	GPIO->tGPIO_DIR_1._GPIO_TSYNC_OUT = Output;  // OUTPUT
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  f0410108          ORR      r1,r1,#8
000010  60c1              STR      r1,[r0,#0xc]
;;;50     	GPIO->tGPIO_AFIO_2._GPIO_TSYNC_OUT = 0x0;
000012  6e81              LDR      r1,[r0,#0x68]
000014  f02101c0          BIC      r1,r1,#0xc0
000018  6681              STR      r1,[r0,#0x68]
;;;51     #endif /* (USED_LPWG_MODE_CONTROL == NO) */
;;;52     	
;;;53     	// All DC
;;;54     #ifdef _ALL_PWM_DC_
;;;55     	GPIO->tGPIO_AFIO_1._GPIO_PWM_TPIC = 0x0; // PWM_DATA (PWM_LFD)
;;;56     	GPIO->tGPIO_DIR_0._GPIO_PWM_TPIC = Output;  // OUTPUT
;;;57     	GPIO->tGPIO_DATA_0._GPIO_PWM_TPIC = 1;
;;;58     #endif
;;;59     
;;;60     #if USED_TPIC_MUXEN_ON_OFF_CONTROL
;;;61     	GPIO->tGPIO_DATA_1._GPIO_TPIC_MUX_EN = 0x0;
00001a  6841              LDR      r1,[r0,#4]
00001c  f0210110          BIC      r1,r1,#0x10
000020  6041              STR      r1,[r0,#4]
;;;62     	GPIO->tGPIO_DIR_1._GPIO_TPIC_MUX_EN  = 0x1;  // OUTPUT
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0410110          ORR      r1,r1,#0x10
000028  60c1              STR      r1,[r0,#0xc]
;;;63     	GPIO->tGPIO_AFIO_2._GPIO_TPIC_MUX_EN = 0x0;
00002a  6e81              LDR      r1,[r0,#0x68]
00002c  f4217140          BIC      r1,r1,#0x300
000030  6681              STR      r1,[r0,#0x68]
;;;64     #else /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;65     	GPIO->tGPIO_AFIO_2._GPIO_TPIC_MUX_EN = 0x0;
;;;66     	GPIO->tGPIO_DIR_1._GPIO_TPIC_MUX_EN  = 0x1;  // OUTPUT
;;;67     	GPIO->tGPIO_DATA_1._GPIO_TPIC_MUX_EN = 0x1;
;;;68     #endif /* USED_TPIC_MUXEN_ON_OFF_CONTROL */
;;;69     
;;;70     	GPIO->tGPIO_AFIO_2._GPIO_TSYNC2_IN = 0x0;
000032  6e81              LDR      r1,[r0,#0x68]
000034  f4216140          BIC      r1,r1,#0xc00
000038  6681              STR      r1,[r0,#0x68]
;;;71     
;;;72     #if USED_TSYNC2_INPUT_CONTROL
;;;73     	GPIO->tGPIO_DIR_1._GPIO_TSYNC2_IN = Input;  // OUTPUT
00003a  68c1              LDR      r1,[r0,#0xc]
00003c  f0210120          BIC      r1,r1,#0x20
000040  60c1              STR      r1,[r0,#0xc]
;;;74     #else /* USED_TSYNC2_INPUT_CONTROL */
;;;75     	GPIO->tGPIO_DIR_1._GPIO_TSYNC2_IN = Output;  // OUTPUT
;;;76     	GPIO->tGPIO_DATA_1._GPIO_TSYNC2_IN = 0;
;;;77     #endif /* USED_TSYNC2_INPUT_CONTROL */
;;;78     
;;;79     	GPIO->tGPIO_AFIO_3.tBit.GPB11 = 0; // SWV
000042  6ec1              LDR      r1,[r0,#0x6c]
000044  f021010c          BIC      r1,r1,#0xc
000048  66c1              STR      r1,[r0,#0x6c]
;;;80     	GPIO->tGPIO_DIR_1.tBit.GPB11 = Output; // SWV
00004a  68c1              LDR      r1,[r0,#0xc]
00004c  f4413100          ORR      r1,r1,#0x20000
000050  60c1              STR      r1,[r0,#0xc]
;;;81     	GPIO->tGPIO_DATA_1.tBit.GPB11 = 1; // SWV
000052  6841              LDR      r1,[r0,#4]
000054  f4413100          ORR      r1,r1,#0x20000
000058  6041              STR      r1,[r0,#4]
;;;82     	GPIO->tGPIO_DATA_1.tBit.GPB11 = 0;
00005a  6841              LDR      r1,[r0,#4]
00005c  f4213100          BIC      r1,r1,#0x20000
000060  6041              STR      r1,[r0,#4]
;;;83     
;;;84     	GPIO->tGPIO_AFIO_2._GPIO_TOGGLE = 0;
000062  6e81              LDR      r1,[r0,#0x68]
000064  f021010c          BIC      r1,r1,#0xc
000068  6681              STR      r1,[r0,#0x68]
;;;85     	GPIO->tGPIO_DIR_1._GPIO_TOGGLE = 1;
00006a  68c1              LDR      r1,[r0,#0xc]
00006c  f0410102          ORR      r1,r1,#2
000070  60c1              STR      r1,[r0,#0xc]
;;;86     	GPIO->tGPIO_DATA_1._GPIO_TOGGLE = 0;
000072  6841              LDR      r1,[r0,#4]
000074  f0210102          BIC      r1,r1,#2
000078  6041              STR      r1,[r0,#4]
;;;87     	
;;;88     #if (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405)
;;;89     	GPIO->tGPIO_DATA_1._GPIO_SLEEP_RST = 0x1;
00007a  6841              LDR      r1,[r0,#4]
00007c  f4414180          ORR      r1,r1,#0x4000
000080  6041              STR      r1,[r0,#4]
;;;90     	GPIO->tGPIO_DIR_1._GPIO_SLEEP_RST  = 0x1;
000082  68c1              LDR      r1,[r0,#0xc]
000084  f4414180          ORR      r1,r1,#0x4000
000088  60c1              STR      r1,[r0,#0xc]
;;;91     	GPIO->tGPIO_AFIO_2._GPIO_SLEEP_RST = 0x0;
00008a  6e81              LDR      r1,[r0,#0x68]
00008c  f0215140          BIC      r1,r1,#0x30000000
000090  6681              STR      r1,[r0,#0x68]
;;;92     #endif /* (CUSTOMER == MODEL_LGD_SW97400B || CUSTOMER == MODEL_LGD_LX98405) */
;;;93     	
;;;94     	GPIO->tGPIO_AFIO_2._GPIO_VTSP18 = 0x1; // VTSP18
000092  6e81              LDR      r1,[r0,#0x68]
000094  f0210103          BIC      r1,r1,#3
000098  1c49              ADDS     r1,r1,#1
00009a  6681              STR      r1,[r0,#0x68]
;;;95     	GPIO->tGPIO_DIR_1._GPIO_VTSP18 = Input;	// Input
00009c  68c1              LDR      r1,[r0,#0xc]
00009e  f0210101          BIC      r1,r1,#1
0000a2  60c1              STR      r1,[r0,#0xc]
;;;96     //	GPIO->tGPIO_DATA_1._GPIO_VTSP18 = 0;	// Input
;;;97     
;;;98     }
0000a4  4770              BX       lr
;;;99     
                          ENDP

0000a6  0000              DCW      0x0000
                  |L18.168|
                          DCD      0x40007000

                          AREA ||i.initECLK||, CODE, READONLY, ALIGN=2

                  initECLK PROC
;;;99     
;;;100    void initECLK(void)
000000  4814              LDR      r0,|L19.84|
;;;101    {
;;;102    	// 8. ECLK Configuration  
;;;103    	GPIO->tGPIO_AFIO_1._GPIO_ECLK_0 = 0x1;  // ECLK0
000002  f8501f64          LDR      r1,[r0,#0x64]!
000006  f4213140          BIC      r1,r1,#0x30000
00000a  f5013180          ADD      r1,r1,#0x10000
00000e  6001              STR      r1,[r0,#0]
;;;104    	GPIO->tGPIO_AFIO_1._GPIO_ECLK_1 = 0x1;  // ECLK1
000010  6801              LDR      r1,[r0,#0]
000012  f4212140          BIC      r1,r1,#0xc0000
000016  f5012180          ADD      r1,r1,#0x40000
00001a  6001              STR      r1,[r0,#0]
;;;105    
;;;106    
;;;107    	GPIO->tGPIO_P1_0._GPIO_ECLK_0 = ECLK_DRIVING_STRENGTH_0;
00001c  69c1              LDR      r1,[r0,#0x1c]
00001e  f0417180          ORR      r1,r1,#0x1000000
000022  61c1              STR      r1,[r0,#0x1c]
;;;108    	GPIO->tGPIO_P2_0._GPIO_ECLK_0 = ECLK_DRIVING_STRENGTH_1;
000024  6941              LDR      r1,[r0,#0x14]
000026  f0417180          ORR      r1,r1,#0x1000000
00002a  6141              STR      r1,[r0,#0x14]
;;;109    	GPIO->tGPIO_P1_0._GPIO_ECLK_1 = ECLK_DRIVING_STRENGTH_0;
00002c  69c1              LDR      r1,[r0,#0x1c]
00002e  f0417100          ORR      r1,r1,#0x2000000
000032  61c1              STR      r1,[r0,#0x1c]
;;;110    	GPIO->tGPIO_P2_0._GPIO_ECLK_1 = ECLK_DRIVING_STRENGTH_1;
000034  6941              LDR      r1,[r0,#0x14]
000036  f0417100          ORR      r1,r1,#0x2000000
00003a  6141              STR      r1,[r0,#0x14]
;;;111    
;;;112    //	GPIO->tGPIO_P1_0._GPIO_ECLK_0 = 0x0;
;;;113    //	GPIO->tGPIO_P2_0._GPIO_ECLK_0 = 0x0;
;;;114    //	GPIO->tGPIO_P1_0._GPIO_ECLK_1 = 0x0;
;;;115    //	GPIO->tGPIO_P2_0._GPIO_ECLK_1 = 0x0;
;;;116    
;;;117    	/* =================================================================
;;;118    	  @ eclk source
;;;119    
;;;120    	    Set the output of ECLK
;;;121    
;;;122    		0 : Off
;;;123    		1 : External OSC (12MHz)
;;;124    		2 : System Clock (Internal or External OSC selected by GPIOM_03)
;;;125    		3 : Intenral OSC (12MHz)
;;;126    		4 : Internal OSC (1.25MHz / 40kHz)
;;;127    		5 : USB Clock (30MHz)
;;;128    		6 : PRE_CCLK (Clock selected by CCLK[1:0])
;;;129    		7 : FCLK
;;;130    		8 : HCLK_COR (HCLK for CM3)
;;;131    		9 : PCLK
;;;132    		10 : SSCG_FIN (Input Clock of SSCG)
;;;133    		11 : SSCG_FOUT (Output Clock of SSCG)
;;;134    		12 : TOUCH_CLK
;;;135    		13 : WDT_CLK
;;;136    		14 : TIMCLK_1
;;;137    		15 : Not Used (Clock selected by USB_CLK_SEL)
;;;138    	 */
;;;139    	SCRB->ECLK_CFG.ulBulk = (
00003c  f04f4180          MOV      r1,#0x40000000
000040  4805              LDR      r0,|L19.88|
000042  63c8              STR      r0,[r1,#0x3c]
;;;140    		SCB_VECTKEY
;;;141    #if USED_ECLK_ON_OFF_CONTROL
;;;142    		| 14         << 0		// ECLK_SEL ( Tim clock )
;;;143    #else /* USED_ECLK_ON_OFF_CONTROL */
;;;144    		| 2         << 0		// ECLK_SEL ( 12 mhz : system clock )
;;;145    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;146    		| 0         << 4		// ECLK_DIV
;;;147    //		| 1         << 4		// ECLK_DIV ( divided clock = input clock / eclk_div + 1 )
;;;148    		| 0		  	<< 7		// USB_CLK_SEL
;;;149    		| 0  		<< 9		// USB_CLK_SEL
;;;150    	);
;;;151    #if USED_ECLK_ON_OFF_CONTROL
;;;152    	TIMER->Timer0_CR_b.Timer0_En = 1;
000044  4805              LDR      r0,|L19.92|
000046  6881              LDR      r1,[r0,#8]
000048  f0410101          ORR      r1,r1,#1
00004c  6081              STR      r1,[r0,#8]
;;;153    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;154    
;;;155    __NOP();
00004e  bf00              NOP      
;;;156    }
000050  4770              BX       lr
;;;157    
                          ENDP

000052  0000              DCW      0x0000
                  |L19.84|
                          DCD      0x40007000
                  |L19.88|
                          DCD      0x05fa000e
                  |L19.92|
                          DCD      0x40006000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  testbuff
                          %        12

                          AREA ||area_number.22||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.bss||
                  tHalIntrHandle
                          %        36

                          AREA ||.data||, DATA, ALIGN=2

                  ptHalInfo
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_c0dbe184____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___5_hal_c_c0dbe184____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_c0dbe184____REVSH|
#line 402
|__asm___5_hal_c_c0dbe184____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_hal_c_c0dbe184____RRX|
#line 587
|__asm___5_hal_c_c0dbe184____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
