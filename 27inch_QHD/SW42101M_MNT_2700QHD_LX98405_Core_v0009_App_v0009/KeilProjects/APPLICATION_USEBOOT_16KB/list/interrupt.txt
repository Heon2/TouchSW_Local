; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\interrupt.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\interrupt.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\interrupt.crf ..\..\Hal\interrupt.c]
                          THUMB

                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L1.0|
;;;62     #if 1
;;;63     void HardFault_Handler(void)
000000  e7fe              B        |L1.0|
;;;64     {
;;;65     	while (1);
;;;66     }
;;;67     #else
                          ENDP


                          AREA ||i.PendSV_InterruptHandler||, CODE, READONLY, ALIGN=2

                  PendSV_InterruptHandler PROC
;;;121    int Pen_Coord_Cnt = 0;
;;;122    void PendSV_InterruptHandler(void)
000000  4803              LDR      r0,|L2.16|
;;;123    {
000002  b510              PUSH     {r4,lr}
;;;124    	dbg_interrupt[0]++;
000004  8801              LDRH     r1,[r0,#0]  ; dbg_interrupt
000006  1c49              ADDS     r1,r1,#1
000008  8001              STRH     r1,[r0,#0]
;;;125    	eSENSING_MODE_t eSensingMode = HAL_GetSensingMode();
00000a  f7fffffe          BL       HAL_GetSensingMode
;;;126    #if USED_PEN_MODE_OPERATION
;;;127    	switch(eSensingMode)
;;;128    	{
;;;129    		case SM_FINGER_PEN_ACTIVE_MODE:
;;;130    		case SM_FINGER_PEN_IDLE_MODE:
;;;131    		case SM_FINGER_PEN_HOVER_ACTIVE_MODE:
;;;132    		case SM_FINGER_PEN_HOVER_IDLE_MODE:
;;;133    		{
;;;134    			dbg_interrupt[1]++;
;;;135    			ePartialSensing_t RetVal = PARTIAL_PEN_BEACON;
;;;136    			tAlgorithmInfo_t * ptAlgorithmInfo = algorithm_GetInfo();  // NOTE : Global Variable로 선언하여 Hal쪽에서 Initialize하면 사용 할 수 있도록 변경하자!! IRQ각 Hal쪽으로 위치 이동!!
;;;137    
;;;138    			RetVal = module_read_local_sample_data();
;;;139    
;;;140    			hal_set_LocalType_flag(RetVal);
;;;141    
;;;142    			if(TEST_LOCAL_STATE == 1)
;;;143    			{
;;;144    				switch(RetVal)
;;;145    				{
;;;146    //					case PARTIAL_PEN_COORD1:
;;;147    					case PARTIAL_PEN_COORD2:
;;;148    					case PARTIAL_PEN_COORD3:
;;;149    					case PARTIAL_PEN_COORD4:
;;;150    					{
;;;151    						dbg_interrupt[2]++;
;;;152    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;153    //						algorithm_local_dsp_process(1,RetVal, LOCAL_MODE);
;;;154    //						algorithm_hover_full_search();
;;;155    
;;;156    						/*
;;;157    						if (gDCFullMode == 0) // local hover & local
;;;158    						{
;;;159    							if (Pen_Coord_Cnt == 0)
;;;160    							{
;;;161    								algorithm_coord_init_local_DSP();
;;;162    							}
;;;163    
;;;164    							algorithm_local_dsp_process(1, RetVal, LOCAL_MODE);
;;;165    
;;;166    							if (Pen_Coord_Cnt++ > 32760)
;;;167    								Pen_Coord_Cnt = 10;
;;;168    						}
;;;169    						*/
;;;170    #if 1
;;;171    							if(gDCFullMode == 0) // local hover & local
;;;172    							{
;;;173    								sptAlgorithmInfo->tPenInfo.bPenContact = 1;
;;;174    
;;;175    								dbg_interrupt[3]++;
;;;176    								if(Pen_Coord_Cnt == 0)
;;;177    								{
;;;178    									dbg_interrupt[4]++;
;;;179    									algorithm_coord_init_local_DSP();
;;;180    								}
;;;181    
;;;182    								algorithm_local_dsp_process(1,RetVal, LOCAL_MODE);
;;;183    
;;;184    //								if(sptAlgorithmInfo->tPenInfo.bPenContact == YES || sptAlgorithmInfo->tPenInfo.bPrevPenContact == YES)
;;;185    //								{
;;;186    //									dbg_interrupt[18]++;
;;;187    //									algorithm_local_dsp_process(1,RetVal, LOCAL_MODE);
;;;188    //								}
;;;189    //								else
;;;190    //								{
;;;191    //									dbg_interrupt[19]++;
;;;192    //									algorithm_local_dsp_process(1,RetVal, LOCAL_HOVER_MODE);
;;;193    //								}
;;;194    
;;;195    								if(Pen_Coord_Cnt++>32760)
;;;196    									Pen_Coord_Cnt = 10;
;;;197    							}
;;;198    							else
;;;199    							{
;;;200    								sptAlgorithmInfo->tPenInfo.bPenContact = 0;
;;;201    								dbg_interrupt[5]++;
;;;202    //								g_RetVal = RetVal;
;;;203    									algorithm_hover_full_search();
;;;204    
;;;205    								Pen_Coord_Cnt = 0;
;;;206    							}
;;;207    #endif
;;;208    					}
;;;209    					break;
;;;210    					case PARTIAL_PEN_DATA1:
;;;211    					case PARTIAL_PEN_DATA2:
;;;212    					case PARTIAL_PEN_DATA3:
;;;213    					case PARTIAL_PEN_DATA4:
;;;214    					case PARTIAL_PEN_DATA5:
;;;215    					{
;;;216    						dbg_interrupt[6]++;
;;;217    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;218    						// TODO : Data Parser Function
;;;219    //						algorithm_data_local_process(RetVal);
;;;220    
;;;221    						switch(RetVal)
;;;222    						{
;;;223    							case PARTIAL_PEN_DATA1:
;;;224    							case PARTIAL_PEN_DATA4:
;;;225    							{
;;;226    								p_currentRowStart = currentRowStart;
;;;227    								currentRowStart = sensingRowStart;
;;;228    								currentColStart = sptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;229    							}
;;;230    							break;
;;;231    						}
;;;232    					}
;;;233    					break;
;;;234    					case PARTIAL_FINGER6:
;;;235    					{
;;;236    						dbg_interrupt[7]++;
;;;237    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;238    					}
;;;239    					break;
;;;240    					case PARTIAL_MAX:
;;;241    					{
;;;242    						while(1);
;;;243    					}
;;;244    
;;;245    					default:
;;;246    					break;
;;;247    				}
;;;248    			}
;;;249    			else
;;;250    			{
;;;251    				switch(RetVal)
;;;252    				{
;;;253    		//			case PARTIAL_PEN_COORD1:
;;;254    					case PARTIAL_PEN_COORD2:
;;;255    					case PARTIAL_PEN_COORD3:
;;;256    					case PARTIAL_PEN_COORD4:
;;;257    					case PARTIAL_PEN_DATA1:
;;;258    					case PARTIAL_PEN_DATA2:
;;;259    					case PARTIAL_PEN_DATA3:
;;;260    					case PARTIAL_PEN_DATA4:
;;;261    					case PARTIAL_PEN_DATA5:
;;;262    					case PARTIAL_FINGER1:
;;;263    					case PARTIAL_FINGER2:
;;;264    					case PARTIAL_FINGER3:
;;;265    					case PARTIAL_FINGER4:
;;;266    					case PARTIAL_FINGER5:
;;;267    					case PARTIAL_FINGER6:
;;;268    					{
;;;269    						dbg_interrupt[8]++;
;;;270    						hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;271    					}
;;;272    					break;
;;;273    
;;;274    					default:
;;;275    					break;
;;;276    				}
;;;277    			}
;;;278    
;;;279    			break;
;;;280    		}
;;;281    		case SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE:
;;;282    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE:
;;;283    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP2_MODE:
;;;284    		case SM_FINGER_ONLY_IDLE_MODE:
;;;285    		case SM_FINGER_PEN_SEARCH_ACTIVE_MODE:
;;;286    		case SM_FINGER_PEN_SEARCH_IDLE_MODE:
;;;287    		{
;;;288    			dbg_interrupt[9]++;
;;;289    			break;
;;;290    		}
;;;291    	}
;;;292    
;;;293    #else /* USED_PEN_MODE_OPERATION */
;;;294    
;;;295    	switch(eSensingMode)
;;;296    	{
;;;297    		case SM_FINGER_PEN_ACTIVE_MODE:
;;;298    		case SM_FINGER_PEN_IDLE_MODE:
;;;299    		case SM_FINGER_PEN_HOVER_ACTIVE_MODE:
;;;300    		case SM_FINGER_PEN_HOVER_IDLE_MODE:
;;;301    		{
;;;302    			break;
;;;303    		}
;;;304    		case SM_S3_ACTIVE_MODE:
;;;305    		case SM_S3_IDLE_MODE:
;;;306    		{
;;;307    			break;
;;;308    		}
;;;309    		case SM_FINGER_ONLY_ACTIVE_FRQ_MAIN_MODE:
;;;310    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP1_MODE:
;;;311    		case SM_FINGER_ONLY_ACTIVE_FRQ_HOP2_MODE:
;;;312    		case SM_FINGER_ONLY_IDLE_MODE:
;;;313    		{
;;;314    			break;
;;;315    		}
;;;316    		default:
;;;317    		{
;;;318    			break;
;;;319    		}
;;;320    	}
;;;321    #endif /* USED_PEN_MODE_OPERATION */
;;;322    
;;;323    //	int sensingMode = getSensingMode();
;;;324    //	tAlgorithmInfo_t * ptAlgorithmInfo = algorithm_GetInfo();  // NOTE : Global Variable로 선언하여 Hal쪽에서 Initialize하면 사용 할 수 있도록 변경하자!! IRQ각 Hal쪽으로 위치 이동!!
;;;325    //
;;;326    //	if((sensingMode) ==	SM_FINGER_MODE)
;;;327    //	{
;;;328    //		if (gFrameCnt == NI_FRAME)
;;;329    //		{
;;;330    //			module_read_full_NI_sample_data();
;;;331    //		}
;;;332    //	}
;;;333    #if (!USED_FINGER_ONLY)
;;;334    	else
;;;335    	{
;;;336    		RetVal = module_read_local_sample_data();
;;;337    
;;;338    		hal_set_LocalType_flag(RetVal);
;;;339    
;;;340    		if(TEST_LOCAL_STATE == 1)
;;;341    		{
;;;342    			switch(RetVal)
;;;343    			{
;;;344    			case PARTIAL_PEN_COORD1:
;;;345    			case PARTIAL_PEN_COORD2:
;;;346    			case PARTIAL_PEN_COORD3:
;;;347    			case PARTIAL_PEN_COORD4:
;;;348    				{
;;;349    					hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;350    #ifdef DC_BASE
;;;351    					if(gDCFullMode == 0)
;;;352    #endif
;;;353    					{
;;;354    						if(Pen_Coord_Cnt==0){
;;;355    					#ifdef TILT_ON
;;;356    							algorithm_coord_init_local_DSP(); 
;;;357    							HID_TILT_X = 0;
;;;358    							HID_TILT_Y = 0;
;;;359    							ReportSkip = 0;
;;;360    							if(RetVal==PARTIAL_PEN_COORD2 && sptAlgorithmInfo->tPenInfo.bPenContact == YES)ReportSkip=1;
;;;361    					#endif
;;;362    						}
;;;363    						if(Pen_Coord_Cnt++>32760)Pen_Coord_Cnt=10;
;;;364    						
;;;365    						if(ptAlgorithmInfo->tPenInfo.bPenContact == YES || ptAlgorithmInfo->tPenInfo.bPrevPenContact == YES)
;;;366    						algorithm_local_dsp_process(1,RetVal, LOCAL_MODE);
;;;367    						else
;;;368    						algorithm_local_dsp_process(1,RetVal, LOCAL_HOVER_MODE);
;;;369    					}
;;;370    #ifdef DC_BASE
;;;371    					else
;;;372    					{
;;;373    						if(ptAlgorithmInfo->bDiagMode == NO)
;;;374    						algorithm_hover_full_search();
;;;375    						
;;;376    						Pen_Coord_Cnt = 0;
;;;377    					}
;;;378    #endif
;;;379    				}
;;;380    				break;
;;;381    
;;;382    			case PARTIAL_PEN_DATA1:
;;;383    			case PARTIAL_PEN_DATA2:
;;;384    			case PARTIAL_PEN_DATA3:
;;;385    				//				case PARTIAL_PEN_DATA4:
;;;386    				//				case PARTIAL_PEN_DATA5:
;;;387    			case LOCAL_PEN_DATA6:
;;;388    			case LOCAL_PEN_DATA7:
;;;389    				{
;;;390    					//					hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;391    					
;;;392    					algorithm_data_local_process(RetVal);
;;;393    					switch(RetVal)
;;;394    					{
;;;395    					case PARTIAL_PEN_DATA1:
;;;396    					case PARTIAL_PEN_DATA3:
;;;397    						//						case PARTIAL_PEN_DATA5:
;;;398    					case LOCAL_PEN_DATA7:
;;;399    						{
;;;400    							p_currentRowStart = currentRowStart;
;;;401    							currentRowStart = sensingRowStart;
;;;402    							currentColStart = ptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;403    						}
;;;404    						break;
;;;405    
;;;406    					default:
;;;407    						break;
;;;408    					}
;;;409    				}
;;;410    				break;
;;;411    				
;;;412    			case PARTIAL_FINGER3:
;;;413    				{
;;;414    					p_currentRowStart = currentRowStart;
;;;415    					currentRowStart = sensingRowStart;
;;;416    					currentColStart = ptAlgorithmInfo->tPenInfo.ucCurrentColumnStart;
;;;417    				}
;;;418    				break;
;;;419    
;;;420    			case PARTIAL_FINGER4:
;;;421    				{
;;;422    					hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;423    				}
;;;424    				break;
;;;425    
;;;426    			case PARTIAL_MAX:
;;;427    				{
;;;428    					while(1);
;;;429    				}
;;;430    				/* no break */
;;;431    
;;;432    			default:
;;;433    				break;
;;;434    			}
;;;435    		}
;;;436    		else
;;;437    		{
;;;438    			switch(RetVal)
;;;439    			{
;;;440    			case PARTIAL_PEN_COORD1:
;;;441    			case PARTIAL_PEN_COORD2:
;;;442    			case PARTIAL_PEN_COORD3:
;;;443    			case PARTIAL_PEN_COORD4:
;;;444    			case PARTIAL_PEN_DATA1:
;;;445    			case PARTIAL_PEN_DATA2:
;;;446    			case PARTIAL_PEN_DATA3:
;;;447    				//					case PARTIAL_PEN_DATA4:
;;;448    				//					case PARTIAL_PEN_DATA5:
;;;449    			case LOCAL_PEN_DATA6:
;;;450    			case LOCAL_PEN_DATA7:
;;;451    			case PARTIAL_FINGER3:
;;;452    			case PARTIAL_FINGER4:
;;;453    				{
;;;454    					hal_set_irq_flag(IRQ_ID_LOCAL_SAMPLE);
;;;455    				}
;;;456    				break;
;;;457    
;;;458    			default:
;;;459    				break;
;;;460    			}
;;;461    		}
;;;462    	}
;;;463    #endif /* (!USED_FINGER_ONLY) */
;;;464    }
00000e  bd10              POP      {r4,pc}
;;;465    
                          ENDP

                  |L2.16|
                          DCD      ||.bss||

                          AREA ||i.SensingBufferInit||, CODE, READONLY, ALIGN=2

                  SensingBufferInit PROC
;;;474    
;;;475    void SensingBufferInit(void)
000000  490c              LDR      r1,|L3.52|
;;;476    {
000002  b510              PUSH     {r4,lr}
;;;477    	//	usRegAddr	= 0; // NOTE : I2C와 USB IRQ함수에서 Address를 받을 때 각각 static으로 선언후 사용.. 여기서는 불필요!!
;;;478    	//	i2c_sent_byte	= 0; // NOTE : I2C와 USB IRQ함수에서 Address를 받을 때 각각 static으로 선언후 사용.. 여기서는 불필요!!
;;;479    	//	i2c_received_byte	= 0; // NOTE : I2C와 USB IRQ함수에서 Address를 받을 때 각각 static으로 선언후 사용.. 여기서는 불필요!!
;;;480    
;;;481    	gMspiCounterPen =			0;
000004  2000              MOVS     r0,#0
000006  6088              STR      r0,[r1,#8]  ; gMspiCounterPen
;;;482    	isFirstFrame =				1;
000008  2201              MOVS     r2,#1
00000a  60ca              STR      r2,[r1,#0xc]  ; isFirstFrame
;;;483    //	gDoneMSPI =					0;
;;;484    //	gSensingMode =				0;
;;;485    //	gFrameCnt =					0;
;;;486    
;;;487    	p_currentRowStart =			0;
00000c  8008              STRH     r0,[r1,#0]
;;;488    	sensingRowStart =			0;
00000e  8048              STRH     r0,[r1,#2]
;;;489    	currentRowStart =			0;
000010  8088              STRH     r0,[r1,#4]
;;;490    
;;;491    	nextTSync =					0;
000012  6108              STR      r0,[r1,#0x10]  ; nextTSync
;;;492    	PenCoordIdx =				0;
000014  4a08              LDR      r2,|L3.56|
;;;493    
;;;494    	pFreqHoppingAndModeTest =	0;
000016  6010              STR      r0,[r2,#0]  ; PenCoordIdx
000018  6148              STR      r0,[r1,#0x14]  ; pFreqHoppingAndModeTest
;;;495    
;;;496    
;;;497    	tHalIntrHandle.ulMSPIIntrCnt = 0;
00001a  4908              LDR      r1,|L3.60|
00001c  6008              STR      r0,[r1,#0]  ; tHalIntrHandle
;;;498    	tHalIntrHandle.ulInitFirstFrame = 0;
00001e  6188              STR      r0,[r1,#0x18]  ; tHalIntrHandle
;;;499    	tHalIntrHandle.ulVSyncFlag = 0;
000020  6088              STR      r0,[r1,#8]  ; tHalIntrHandle
;;;500    	tHalIntrHandle.ulTSyncInFallingCnt = 0;
000022  6108              STR      r0,[r1,#0x10]  ; tHalIntrHandle
;;;501    
;;;502    #ifdef MODE_WDT				
;;;503    	Hal_WDT_DeInit();
000024  f7fffffe          BL       Hal_WDT_DeInit
;;;504    #endif /* MODE_WDT */
;;;505    	
;;;506    #if USED_ECLK_ON_OFF_CONTROL
;;;507    	HAL_SetECLKOnOffControl(NO);
000028  e8bd4010          POP      {r4,lr}
00002c  2000              MOVS     r0,#0
00002e  f7ffbffe          B.W      HAL_SetECLKOnOffControl
;;;508    #endif /* USED_ECLK_ON_OFF_CONTROL */
;;;509    }
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      ||.data||
                  |L3.56|
                          DCD      PenCoordIdx
                  |L3.60|
                          DCD      tHalIntrHandle

                          AREA ||i.hal_PendSVHandlerInitialize||, CODE, READONLY, ALIGN=2

                  hal_PendSVHandlerInitialize PROC
;;;465    
;;;466    void hal_PendSVHandlerInitialize(void)
000000  4904              LDR      r1,|L4.20|
;;;467    {
;;;468    	/*
;;;469    	* NOTE : PendSV_IRQn를 Enable시키지 않고.. 왜 priority만 설정하고 있지?
;;;470    	*/
;;;471    	Fncp_PendSV_IRQHandler = &PendSV_InterruptHandler;
000002  4803              LDR      r0,|L4.16|
000004  6008              STR      r0,[r1,#0]  ; Fncp_PendSV_IRQHandler
000006  4904              LDR      r1,|L4.24|
000008  20e0              MOVS     r0,#0xe0
00000a  f8810d14          STRB     r0,[r1,#0xd14]
;;;472    	NVIC_SetPriority(PendSV_IRQn, PendSV_IRQn_Priority);
;;;473    }
00000e  4770              BX       lr
;;;474    
                          ENDP

                  |L4.16|
                          DCD      PendSV_InterruptHandler
                  |L4.20|
                          DCD      Fncp_PendSV_IRQHandler
                  |L4.24|
                          DCD      0xe000e00e

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  dbg_interrupt
                          %        40

                          AREA ||.data||, DATA, ALIGN=2

                  p_currentRowStart
000000  0000              DCW      0x0000
                  sensingRowStart
000002  0000              DCW      0x0000
                  currentRowStart
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  gMspiCounterPen
                          DCD      0x00000000
                  isFirstFrame
                          DCD      0x00000001
                  nextTSync
                          DCD      0x00000000
                  pFreqHoppingAndModeTest
                          DCD      0x00000000

                          AREA ||area_number.9||, DATA, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.data||
                  Pen_Coord_Cnt
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\interrupt.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_e7478fdd____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___11_interrupt_c_e7478fdd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_e7478fdd____REVSH|
#line 402
|__asm___11_interrupt_c_e7478fdd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_interrupt_c_e7478fdd____RRX|
#line 587
|__asm___11_interrupt_c_e7478fdd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
