; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\bin\pe_usb.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\bin\pe_usb.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\App -I..\..\App\Algorithm -I..\..\App\Algorithm\Baseline -I..\..\App\Algorithm\Coord -I..\..\App\Algorithm\Label -I..\..\App\Algorithm\Noise -I..\..\Env -I..\..\Hal -I..\..\Hal\system -I..\..\Hal\system\CMSIS -I..\..\Hal\gpio -I..\..\Hal\i2c -I..\..\Hal\pwmdrv -I..\..\Hal\timer -I..\..\Hal\wdgt -I..\..\Hal\spi -I..\..\Hal\dspA -I..\..\Hal\dspB -I..\..\Hal\scrb -I..\..\Hal\usb -I..\..\Hal\usb\FWOTG210_F000 -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral -I..\..\Hal\usb\FWOTG210_F000\OTG_peripheral_Config -I..\..\Module -I..\..\Module\SRIC -I..\..\Protocol -I..\..\Hal\dma -I..\..\Tool_BinCvt\BinToolApp\src -I..\..\Boot -I..\..\Parameter -I..\..\Hal\misc -I..\..\Hal\flitf -I..\..\Env\env_model_L -I..\..\Env\env_model_L\customer\DEFAULT -I..\..\Env -I.\RTE\_MFTP_FPGA -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DARMCM3 -D_USE_APP_80K_ -DUSE_BOOTLOADER_16KB --wchar32 --omf_browse=.\bin\pe_usb.crf ..\..\Hal\usb\FWOTG210_F000\Pe_usb.c]
                          THUMB

                          AREA ||i.CheckHIDReady||, CODE, READONLY, ALIGN=2

                  CheckHIDReady PROC
;;;269    // Touch G Contact Count Ø¦ Host ß¡Ü­ Pß® Ð¬Õ‚Â¶ È®N (Touch Ø¦ Ü§à «È’ Â˜Û±Ð¡ Ö‡ßºÕ™Ñ­ Ç‡Õœ)
;;;270    uint8_t CheckHIDReady(void)
000000  4801              LDR      r0,|L1.8|
;;;271    {
;;;272    	return g_HIDReady;
000002  7840              LDRB     r0,[r0,#1]  ; g_HIDReady
;;;273    }
000004  4770              BX       lr
;;;274    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.CheckRemoteWakeup||, CODE, READONLY, ALIGN=2

                  CheckRemoteWakeup PROC
;;;274    
;;;275    uint8_t CheckRemoteWakeup(void)
000000  4801              LDR      r0,|L2.8|
;;;276    {
;;;277    	return g_RemoteWakeup;
000002  78c0              LDRB     r0,[r0,#3]  ; g_RemoteWakeup
;;;278    }
000004  4770              BX       lr
;;;279    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.CheckUsbConfig||, CODE, READONLY, ALIGN=2

                  CheckUsbConfig PROC
;;;263    // USB eÄ¡Ø¦ Ü§à «È’ Â˜Û±Ð¡ Ö‡ß® VÕ‚Â¶ È®N
;;;264    uint8_t CheckUsbConfig(void)
000000  4801              LDR      r0,|L3.8|
;;;265    {
;;;266    	return g_Configuration;
000002  7800              LDRB     r0,[r0,#0]  ; g_Configuration
;;;267    }
000004  4770              BX       lr
;;;268    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.DMABulkData_USB||, CODE, READONLY, ALIGN=2

                  DMABulkData_USB PROC
;;;1975   // Device to Host
;;;1976   void DMABulkData_USB(void)
000000  480d              LDR      r0,|L4.56|
;;;1977   {
;;;1978   #ifndef MODE_I2C
;;;1979   	// Virtual DMA Mask - Bulk Custom IN
;;;1980   	mUsbEXIntDmaErrEn(BULK_CUSTOM_FIFO_IN);
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4213100          BIC      r1,r1,#0x20000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
;;;1981   	mUsbEXIntDmaFinishEn(BULK_CUSTOM_FIFO_IN);
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210102          BIC      r1,r1,#2
000016  f8c0132c          STR      r1,[r0,#0x32c]
;;;1982   
;;;1983   	// Virtual DMA Start !!!!
;;;1984   	mUsbEXDmaConfig(BULK_CUSTOM_FIFO_IN, MX_PA_SZ_64, DIRECTION_IN);
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01308          STR      r1,[r0,#0x308]
;;;1985   	mUsbEXDmaAddr(BULK_CUSTOM_FIFO_IN, (uint32_t)g_BulkCustomBuffer);
000022  4906              LDR      r1,|L4.60|
000024  f8c0130c          STR      r1,[r0,#0x30c]
;;;1986   	mUsbEXDmaStart(BULK_CUSTOM_FIFO_IN);
000028  f8d01308          LDR      r1,[r0,#0x308]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01308          STR      r1,[r0,#0x308]
;;;1987   #endif
;;;1988   	return;
;;;1989   }
000034  4770              BX       lr
;;;1990   
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      0x40030000
                  |L4.60|
                          DCD      ||.bss||+0x2835

                          AREA ||i.DMACustomData_USB||, CODE, READONLY, ALIGN=2

                  DMACustomData_USB PROC
;;;1067   // Device to Host
;;;1068   void DMACustomData_USB()
000000  480d              LDR      r0,|L5.56|
;;;1069   {
;;;1070   #ifndef MODE_I2C
;;;1071   	// Virtual DMA Mask - Custom IN
;;;1072   	mUsbEXIntDmaErrEn(CUSTOM_FIFO_IN);
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4213100          BIC      r1,r1,#0x20000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
;;;1073   	mUsbEXIntDmaFinishEn(CUSTOM_FIFO_IN);
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210102          BIC      r1,r1,#2
000016  f8c0132c          STR      r1,[r0,#0x32c]
;;;1074   
;;;1075   	// Virtual DMA Start !!!!
;;;1076   	mUsbEXDmaConfig(CUSTOM_FIFO_IN, MX_PA_SZ_64, DIRECTION_IN);
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01308          STR      r1,[r0,#0x308]
;;;1077   	mUsbEXDmaAddr(CUSTOM_FIFO_IN, (uint32_t)g_CustomBuffer);
000022  4906              LDR      r1,|L5.60|
000024  f8c0130c          STR      r1,[r0,#0x30c]
;;;1078   	mUsbEXDmaStart(CUSTOM_FIFO_IN);
000028  f8d01308          LDR      r1,[r0,#0x308]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01308          STR      r1,[r0,#0x308]
;;;1079   #endif
;;;1080   	return;
;;;1081   }
000034  4770              BX       lr
;;;1082   
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40030000
                  |L5.60|
                          DCD      ||.bss||+0x27f5

                          AREA ||i.DMATouchData_USB||, CODE, READONLY, ALIGN=2

                  DMATouchData_USB PROC
;;;597    
;;;598    void DMATouchData_USB(void)
000000  480d              LDR      r0,|L6.56|
;;;599    {
;;;600    #ifndef MODE_I2C
;;;601    	// Virtual DMA Mask - MultiTouch
;;;602    	mUsbEXIntDmaErrEn(TOUCH_FIFO_IN);
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4212180          BIC      r1,r1,#0x40000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
;;;603    	mUsbEXIntDmaFinishEn(TOUCH_FIFO_IN);
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210104          BIC      r1,r1,#4
000016  f8c0132c          STR      r1,[r0,#0x32c]
;;;604    
;;;605    	// Virtual DMA Start !!!!
;;;606    	mUsbEXDmaConfig(TOUCH_FIFO_IN, sizeof(HID_MULTITOUCH), DIRECTION_IN);
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01310          STR      r1,[r0,#0x310]
;;;607    	mUsbEXDmaAddr(TOUCH_FIFO_IN, (uint32_t)&g_Touch);
000022  4906              LDR      r1,|L6.60|
000024  f8c01314          STR      r1,[r0,#0x314]
;;;608    	mUsbEXDmaStart(TOUCH_FIFO_IN);
000028  f8d01310          LDR      r1,[r0,#0x310]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01310          STR      r1,[r0,#0x310]
;;;609    #endif
;;;610    	return;
;;;611    }
000034  4770              BX       lr
;;;612    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40030000
                  |L6.60|
                          DCD      ||.bss||+0x11a

                          AREA ||i.EP0_SetupPacket||, CODE, READONLY, ALIGN=2

                  EP0_SetupPacket PROC
;;;2435   
;;;2436   void EP0_SetupPacket(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2437   {
;;;2438   	uint8_t	bStall = TRUE;
;;;2439   
;;;2440   	if (mUsbOTGHighSpeedST())
000004  4cff              LDR      r4,|L7.1028|
000006  f04f0c01          MOV      r12,#1                ;2438
00000a  f8d40100          LDR      r0,[r4,#0x100]
00000e  f0100f40          TST      r0,#0x40
;;;2441   	{
;;;2442   		return;
;;;2443   	}
;;;2444   
;;;2445   	// Device to Host
;;;2446   	switch (g_pSetupPacket->bmRequestType_Type)
;;;2447   	{
;;;2448   		case SETUPPACKET_REQUEST_TYPE__STANDARD:
;;;2449   		{
;;;2450   			// Standard
;;;2451   			switch (g_pSetupPacket->bRequest)
;;;2452   			{
;;;2453   				case SETUPPACKET_STANDARD_REQUEST__GET_STATUS:
;;;2454   				{					
;;;2455   					g_EP0_BufferAddr = (uint8_t*)&g_Status[g_pSetupPacket->wIndex];
;;;2456   					g_EP0_BufferLength = sizeof(SETUP_GET_STATUS);
;;;2457   
;;;2458   					// Tx
;;;2459   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2460   					bStall = FALSE;
;;;2461   					break;
;;;2462   				}
;;;2463   
;;;2464   				case SETUPPACKET_STANDARD_REQUEST__CLEAR_FEATURE:
;;;2465   				{
;;;2466   					switch (g_pSetupPacket->wValue & 0x00FF)
;;;2467   					{
;;;2468   						case SETUPPACKET_FEATURE__ENDPOINT_HALT:
;;;2469   						{
;;;2470   							g_Status[g_pSetupPacket->wIndex].Status.EP.EndPointHalt = 0;
;;;2471   							break;
;;;2472   						}
;;;2473   
;;;2474   						case SETUPPACKET_FEATURE__DEVICE_REMOTE_WAKEUP:
;;;2475   						{
;;;2476   							g_Status[g_pSetupPacket->wIndex].Status.Global.RemoteWakeup = 0;
;;;2477   							break;
;;;2478   						}
;;;2479   					}
;;;2480   
;;;2481   					mUsbEP0DoneSet();
;;;2482   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2483   					bStall = FALSE;
;;;2484   					break;
;;;2485   				}
;;;2486   
;;;2487   				case SETUPPACKET_STANDARD_REQUEST__SET_FEATURE:
;;;2488   				{
;;;2489   					
;;;2490   					switch (g_pSetupPacket->wValue & 0x00FF)
;;;2491   					{
;;;2492   						case SETUPPACKET_FEATURE__ENDPOINT_HALT:
;;;2493   						{
;;;2494   							g_Status[g_pSetupPacket->wIndex].Status.EP.EndPointHalt = 1;
;;;2495   
;;;2496   							if (g_pSetupPacket->wIndex & 0x0080)
;;;2497   							{
;;;2498   								mUsbEPinRsTgClr(g_pSetupPacket->wIndex & 0x000F);
;;;2499   							}
;;;2500   							else
;;;2501   							{
;;;2502   								mUsbEPoutRsTgClr(g_pSetupPacket->wIndex & 0x000F);
;;;2503   							}
;;;2504   
;;;2505   							mUsbEP0DoneSet();
;;;2506   							g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2507   							bStall = FALSE;
;;;2508   							break;
;;;2509   						}
;;;2510   
;;;2511   						case SETUPPACKET_FEATURE__DEVICE_REMOTE_WAKEUP:
;;;2512   						{
;;;2513   							mUsbEP0DoneSet();
;;;2514   							
;;;2515   							g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2516   							g_Status[g_pSetupPacket->wIndex].Status.Global.RemoteWakeup = 1;
;;;2517   							bStall = FALSE;
;;;2518   							break;
;;;2519   						}
;;;2520   					}
;;;2521   					
;;;2522   					
;;;2523   					break;
;;;2524   				}
;;;2525   
;;;2526   				case SETUPPACKET_STANDARD_REQUEST__SET_ADDRESS:
;;;2527   				{
;;;2528   					mUsbDevAddrSet(g_pSetupPacket->wValue);
;;;2529   					mUsbEP0DoneSet();
;;;2530   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2531   					bStall = FALSE;
;;;2532   					break;
;;;2533   				}
;;;2534   
;;;2535   				case SETUPPACKET_STANDARD_REQUEST__GET_DESCRIPTOR:
;;;2536   				{
;;;2537   					EP0_SetupPacket_GetDescriptor();
;;;2538   					bStall = FALSE;
;;;2539   					break;
;;;2540   				}
;;;2541   
;;;2542   				case SETUPPACKET_STANDARD_REQUEST__SET_DESCRIPTOR:
;;;2543   				{
;;;2544   					break;
;;;2545   				}
;;;2546   
;;;2547   				case SETUPPACKET_STANDARD_REQUEST__GET_CONFIGURATION:
;;;2548   				{
;;;2549   					g_EP0_BufferAddr = &g_Configuration;
;;;2550   					g_EP0_BufferLength = 1;
;;;2551   
;;;2552   					// Tx
;;;2553   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2554   					bStall = FALSE;
;;;2555   					break;
;;;2556   				}
;;;2557   
;;;2558   				case SETUPPACKET_STANDARD_REQUEST__SET_CONFIGURATION:
;;;2559   				{
;;;2560   					// EP à  FIFO ß¬Ñ¡
;;;2561   					mUsbEPMap(EP2, TOUCH_FIFO_IN);				// MultiTouch IN
;;;2562   					mUsbEPMap(EP3, CUSTOM_FIFO_OUT << 4);		// Custom OUT 
;;;2563   					mUsbEPMap(EP4, CUSTOM_FIFO_IN);				// Custom IN
;;;2564   					mUsbEPMap(EP6, PEN_FIFO_IN);				// Pen IN
;;;2565   					//mUsbEPMap(EP7, BULK_CUSTOM_FIFO_OUT << 4);	// Bulk Custom OUT 
;;;2566   					//mUsbEPMap(EP8, BULK_CUSTOM_FIFO_IN);		// Bulk Custom IN
;;;2567   
;;;2568   					// FIFO Ü³d
;;;2569   					mUsbFIFOMap(TOUCH_FIFO_IN, EP2 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2570   					mUsbFIFOMap(CUSTOM_FIFO_OUT, EP3 | (FIFO_CONFIG_DIRECTION__OUT << 4));
;;;2571   					mUsbFIFOMap(CUSTOM_FIFO_IN, EP4 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2572   					mUsbFIFOMap(PEN_FIFO_IN, EP6 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2573   					//mUsbFIFOMap(BULK_CUSTOM_FIFO_OUT, EP7 | (FIFO_CONFIG_DIRECTION__OUT << 4));
;;;2574   					//mUsbFIFOMap(BULK_CUSTOM_FIFO_IN, EP8 | (FIFO_CONFIG_DIRECTION__IN << 4));
;;;2575   
;;;2576   					// Max Packet Size
;;;2577   					mUsbEPMxPtSz(EP2, DIRECTION_IN, MX_PA_SZ_64);
;;;2578   					mUsbEPMxPtSz(EP3, DIRECTION_OUT, MX_PA_SZ_64);
;;;2579   					mUsbEPMxPtSz(EP4, DIRECTION_IN, MX_PA_SZ_64);
;;;2580   					mUsbEPMxPtSz(EP6, DIRECTION_IN, MX_PA_SZ_64);
;;;2581   					//mUsbEPMxPtSz(EP7, DIRECTION_OUT, MX_PA_SZ_64);
;;;2582   					//mUsbEPMxPtSz(EP8, DIRECTION_IN, MX_PA_SZ_64);
;;;2583   
;;;2584   					// FIFO Config
;;;2585   					mUsbFIFOConfig(TOUCH_FIFO_IN, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2586   					mUsbFIFOConfig(CUSTOM_FIFO_OUT, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2587   					mUsbFIFOConfig(CUSTOM_FIFO_IN, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2588   					mUsbFIFOConfig(PEN_FIFO_IN, FIFO_CONFIG_TYPE__INT | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2589   					//mUsbFIFOConfig(BULK_CUSTOM_FIFO_OUT, FIFO_CONFIG_TYPE__BULK | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2590   					//mUsbFIFOConfig(BULK_CUSTOM_FIFO_IN, FIFO_CONFIG_TYPE__BULK | (FIFO_CONFIG_BLOCK_NBUMBER__SINGLE << 2) | (FIFO_CONFIG_BLOCK_SIZE__512 << 4) | (FIFO_CONFIG__ENABLE << 5));
;;;2591   
;;;2592   					// Custom OUT
;;;2593   					RecieveCustomData_DMA();
;;;2594   
;;;2595   					// Bulk Custom OUT
;;;2596   					RecieveBulkCustomData_DMA();
;;;2597   
;;;2598   					// Toggle
;;;2599   					mUsbEPinRsTgClr(EP2);
;;;2600   					mUsbEPoutRsTgClr(EP3);
;;;2601   					mUsbEPinRsTgClr(EP4);
;;;2602   					mUsbEPinRsTgClr(EP6);
;;;2603   					//mUsbEPoutRsTgClr(EP7);
;;;2604   					//mUsbEPinRsTgClr(EP8);
;;;2605   
;;;2606   					// SOF
;;;2607   					mUsbSOFMaskFS();
;;;2608   
;;;2609   					// Done !!
;;;2610   					mUsbEP0DoneSet();
;;;2611   
;;;2612   					// After Set Configuration
;;;2613   					mUsbCfgSet();
;;;2614   
;;;2615   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2616   					g_Configuration = (uint8_t)(g_pSetupPacket->wValue & 0x00FF);
;;;2617   					g_HIDReady = 1;
;;;2618   					bStall = FALSE;
;;;2619   					break;
;;;2620   				}
;;;2621   
;;;2622   				case SETUPPACKET_STANDARD_REQUEST__GET_INTERFACE:
;;;2623   				{
;;;2624   					uint8_t AlterInterface = 0;
;;;2625   
;;;2626   					g_EP0_BufferAddr = &AlterInterface;
;;;2627   					g_EP0_BufferLength = 1;
;;;2628   
;;;2629   					// Tx
;;;2630   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2631   					bStall = FALSE;
;;;2632   					break;
;;;2633   				}
;;;2634   
;;;2635   				case SETUPPACKET_STANDARD_REQUEST__SET_INFERFACE:
;;;2636   				{
;;;2637   					switch (g_pSetupPacket->wIndex)
;;;2638   					{
;;;2639   						// MultiTouch
;;;2640   						case TOUCH_INTERFACE_NUM:
;;;2641   						{
;;;2642   							mUsbEPinRsTgClr(EP2);
;;;2643   							break;
;;;2644   						}
;;;2645   
;;;2646   						// Custom
;;;2647   						case CUSTOM_INTERFACE_NUM:
;;;2648   						{
;;;2649   							mUsbEPoutRsTgClr(EP3);
;;;2650   							mUsbEPinRsTgClr(EP4);
;;;2651   							break;
;;;2652   						}
;;;2653   
;;;2654   						// Pen
;;;2655   						case PEN_INTERFACE_NUM:
;;;2656   						{
;;;2657   							mUsbEPinRsTgClr(EP6);
;;;2658   							break;
;;;2659   						}
;;;2660   					}
;;;2661   
;;;2662   					mUsbEP0DoneSet();
;;;2663   					g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2664   					bStall = FALSE;
;;;2665   					break;
;;;2666   				}
;;;2667   
;;;2668   				case SETUPPACKET_STANDARD_REQUEST__SYNCH_FRAME:
;;;2669   				{
;;;2670   					break;
;;;2671   				}
;;;2672   
;;;2673   				default:
;;;2674   				{
;;;2675   					break;
;;;2676   				}
;;;2677   			}
;;;2678   
;;;2679   			break;
;;;2680   		}
;;;2681   
;;;2682   		case SETUPPACKET_REQUEST_TYPE__CLASS:
;;;2683   		{
;;;2684   			switch (g_pSetupPacket->bRequest)
;;;2685   			{
;;;2686   				// Get Report
;;;2687   				case SETUPPACKET_CLASS_REQUEST__GET_REPORT:
;;;2688   				{
;;;2689   					// Feature
;;;2690   					if ((g_pSetupPacket->wValue & 0xFF00) == 0x0300)
;;;2691   					{
;;;2692   						switch (g_pSetupPacket->wValue & 0x00FF)
;;;2693   						{
;;;2694   #ifdef ADD_TOUCH
;;;2695   							// Contact count Mamimum
;;;2696   							case HID_REPORT_ID__CONTACT_COUNT:
;;;2697   							{
;;;2698   								g_MaxTouchCount.ReportID = HID_REPORT_ID__CONTACT_COUNT;
;;;2699   								g_MaxTouchCount.Count = HID_MAX_TOUCH;
;;;2700   								//g_MaxTouchCount.Reserved = 0;
;;;2701   
;;;2702   								g_EP0_BufferAddr = (uint8_t*)&g_MaxTouchCount;
;;;2703   								g_EP0_BufferLength = sizeof(TOUCH_MAX_COUNT);
;;;2704   
;;;2705   								// Tx
;;;2706   								EP0_TxRx_Proc(DIRECTION_IN);
;;;2707   								bStall = FALSE;
;;;2708   								break;
;;;2709   							}
;;;2710   
;;;2711   							case HID_REPORT_ID__BLOB_CODE:
;;;2712   							{
;;;2713   								g_EP0_BufferAddr = &u8_HID_Touch_Blob[g_EP0_Offset];
;;;2714   								g_EP0_BufferLength = HID_TOUCH_BLOB_LENGTH;
;;;2715   
;;;2716   								// Tx
;;;2717   								EP0_TxRx_Proc(DIRECTION_IN);
;;;2718   								bStall = FALSE;
;;;2719   								break;
;;;2720   							}
;;;2721   #endif
;;;2722   						}
;;;2723   					}
;;;2724   					break;
;;;2725   				}
;;;2726   
;;;2727   				// Set Report
;;;2728   				case SETUPPACKET_CLASS_REQUEST__SET_REPORT:
;;;2729   				{
;;;2730   					// Feature
;;;2731   					if ((g_pSetupPacket->wValue & 0xFF00) == 0x0300)
;;;2732   					{
;;;2733   #ifdef ADD_TOUCH
;;;2734   						// Device Mode
;;;2735   						if ((g_pSetupPacket->wValue & 0x00FF) == HID_REPORT_ID__DEVICE_MODE)
;;;2736   						{
;;;2737   							g_EP0_BufferAddr = (uint8_t*)&g_DeviceMode;
;;;2738   							g_EP0_BufferLength = g_pSetupPacket->wLength;
;;;2739   
;;;2740   							// Rx
;;;2741   							EP0_TxRx_Proc(DIRECTION_OUT);
;;;2742   							bStall = FALSE;
;;;2743   						}
;;;2744   #endif
;;;2745   
;;;2746   						// Latency Mode
;;;2747   						if ((g_pSetupPacket->wValue & 0x00FF) == HID_REPORT_ID__LATENCY_MODE)
;;;2748   						{
;;;2749   							g_EP0_BufferAddr = (uint8_t*)&g_LatencyMode;
;;;2750   							g_EP0_BufferLength = g_pSetupPacket->wLength;
;;;2751   
;;;2752   							// Rx
;;;2753   							EP0_TxRx_Proc(DIRECTION_OUT);
;;;2754   							bStall = FALSE;
;;;2755   						}
;;;2756   					}
;;;2757   
;;;2758   					break;
;;;2759   				}
;;;2760   
;;;2761   				// Set Idle
;;;2762   				case SETUPPACKET_CLASS_REQUEST__SET_IDLE:
;;;2763   				{
;;;2764   					uint8_t	ReportID = 0;
;;;2765   					uint8_t	Duration = 0;
;;;2766   
;;;2767   					ReportID = (uint8_t)(g_pSetupPacket->wValue & 0x00FF);
;;;2768   					Duration = (uint8_t)((g_pSetupPacket->wValue & 0xFF00) >> 8);
;;;2769   
;;;2770   					// All
;;;2771   					if (ReportID == 0)
;;;2772   					{
;;;2773   						mUsbEP0StallSet();
;;;2774   						mUsbEP0DoneSet();
;;;2775   						g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2776   						bStall = FALSE;
;;;2777   					}
;;;2778   					// Other Report
;;;2779   					else
;;;2780   					{
;;;2781   						g_IdleDuration[ReportID] = Duration;
;;;2782   						mUsbEP0DoneSet();
;;;2783   						g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;2784   						bStall = FALSE;
;;;2785   					}
;;;2786   
;;;2787   					break;
;;;2788   				}
;;;2789   
;;;2790   				// Get Idle
;;;2791   				case SETUPPACKET_CLASS_REQUEST__GET_IDLE:
;;;2792   				{
;;;2793   					uint8_t	ReportID = 0;
;;;2794   
;;;2795   					ReportID = (uint8_t)(g_pSetupPacket->wValue & 0x00FF);
;;;2796   
;;;2797   					g_EP0_BufferAddr = (uint8_t*)&g_IdleDuration[ReportID];
;;;2798   					g_EP0_BufferLength = 1;
;;;2799   
;;;2800   					// Rx
;;;2801   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2802   					bStall = FALSE;
;;;2803   					break;
;;;2804   				}
;;;2805   			}
;;;2806   
;;;2807   			break;
;;;2808   		}
;;;2809   
;;;2810   		case SETUPPACKET_REQUEST_TYPE__VENDOR:
;;;2811   		{
;;;2812   			switch (g_pSetupPacket->bRequest)
;;;2813   			{
;;;2814   				// MS OS Descriptor
;;;2815   				case SETUPPACKET_DESCRIPTOR__MS_OS_VENDOR_CODE:
;;;2816   				{
;;;2817   					switch (g_pSetupPacket->wIndex)
;;;2818   					{
;;;2819   
;;;2820   						case MS_OS_DESCRIPTOR_TYPE__COMPATIBLE_ID:
;;;2821   						{
;;;2822   #ifdef ADD_BULK_CUSTOM
;;;2823   							MS_OS_CompatibleID.Length = sizeof(COMPATIBLE_ID_FEATURE_DESCRIPTOR);
;;;2824   							MS_OS_CompatibleID.bcdVersion = 0x0100;
;;;2825   							MS_OS_CompatibleID.Index = MS_OS_DESCRIPTOR_TYPE__COMPATIBLE_ID;
;;;2826   							MS_OS_CompatibleID.Count = 0x01;
;;;2827   							MS_OS_CompatibleID.FirstInterfaceNumber = BULK_CUSTOM_INTERFACE_NUM;
;;;2828   
;;;2829   							// WINUSB
;;;2830   							MS_OS_CompatibleID.CompatibleID[0] = 'W';
;;;2831   							MS_OS_CompatibleID.CompatibleID[1] = 'I';
;;;2832   							MS_OS_CompatibleID.CompatibleID[2] = 'N';
;;;2833   							MS_OS_CompatibleID.CompatibleID[3] = 'U';
;;;2834   							MS_OS_CompatibleID.CompatibleID[4] = 'S';
;;;2835   							MS_OS_CompatibleID.CompatibleID[5] = 'B';
;;;2836   							MS_OS_CompatibleID.CompatibleID[6] = 0;
;;;2837   							MS_OS_CompatibleID.CompatibleID[7] = 0;
;;;2838   
;;;2839   							g_EP0_BufferAddr = (uint8_t*)&MS_OS_CompatibleID;
;;;2840   							g_EP0_BufferLength = sizeof(COMPATIBLE_ID_FEATURE_DESCRIPTOR);
;;;2841   
;;;2842   							// Rx
;;;2843   							EP0_TxRx_Proc(DIRECTION_IN);
;;;2844   							bStall = FALSE;
;;;2845   #endif
;;;2846   							break;
;;;2847   						}
;;;2848   
;;;2849   						case MS_OS_DESCRIPTOR_TYPE__PROPERTIES:
;;;2850   						{
;;;2851   #ifdef USB_SELECTIVE_SUSPEND
;;;2852   							uint32_t	i = 0;
;;;2853   							uint8_t*	pString = 0;
;;;2854   							uint8_t*	pBuffer = (uint8_t*)&MS_OS_Property;
;;;2855   
;;;2856   							MS_OS_Property.Header.Length = sizeof(PROPERTIES_DESCRIPTOR_HEADER);
;;;2857   							MS_OS_Property.Header.bcdVersion = 0x0100;
;;;2858   							MS_OS_Property.Header.Index = MS_OS_DESCRIPTOR_TYPE__PROPERTIES;
;;;2859   							MS_OS_Property.Header.Count = 0;
;;;2860   							
;;;2861   							// SelectiveSuspend
;;;2862   							pString = SELECTIVE_SUSPEND_STRING;
;;;2863   							MS_OS_Property.SelectiveSuspend.Size = sizeof(PROPERTY_SECTION__SELECTIVE_SUSPEND);
;;;2864   							MS_OS_Property.SelectiveSuspend.PropertyDataType = REG_DWORD;
;;;2865   							MS_OS_Property.SelectiveSuspend.PropertyNameLength = 48;
;;;2866   							for (i = 0; i < (MS_OS_Property.SelectiveSuspend.PropertyNameLength/2); i++)
;;;2867   							{
;;;2868   								MS_OS_Property.SelectiveSuspend.PropertyName[i*2] = pString[i];
;;;2869   							}
;;;2870   							MS_OS_Property.SelectiveSuspend.PropertyDataLength = 0x04;
;;;2871   							MS_OS_Property.SelectiveSuspend.PropertyData = 0x01;
;;;2872   							MS_OS_Property.Header.Count += 1;
;;;2873   							MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__SELECTIVE_SUSPEND);
;;;2874   
;;;2875   #ifdef ADD_BULK_CUSTOM
;;;2876   #ifdef MS_OS_EXT_PROP__WINUSB
;;;2877   							if (InterfaceNumber == BULK_CUSTOM_INTERFACE_NUM)
;;;2878   							{
;;;2879   								// DeviceInterfaceGUID
;;;2880   								MS_OS_Property.DeviceInterfaceGUID.Size = sizeof(PROPERTY_SECTION__DEVICEINTERFACEGUID);
;;;2881   								MS_OS_Property.DeviceInterfaceGUID.PropertyDataType = REG_SZ;
;;;2882   								pString = DEVICEINTERFACEGUID_NAME;
;;;2883   								MS_OS_Property.DeviceInterfaceGUID.PropertyNameLength = 40;
;;;2884   								for (i = 0; i < (MS_OS_Property.DeviceInterfaceGUID.PropertyNameLength / 2); i++)
;;;2885   								{
;;;2886   									MS_OS_Property.DeviceInterfaceGUID.PropertyName[i * 2] = pString[i];
;;;2887   								}
;;;2888   								pString = DEVICEINTERFACEGUID_STRING;
;;;2889   								MS_OS_Property.DeviceInterfaceGUID.PropertyDataLength = 78;
;;;2890   								for (i = 0; i < (MS_OS_Property.DeviceInterfaceGUID.PropertyDataLength / 2); i++)
;;;2891   								{
;;;2892   									MS_OS_Property.DeviceInterfaceGUID.PropertyData[i * 2] = pString[i];
;;;2893   								}
;;;2894   								MS_OS_Property.Header.Count += 1;
;;;2895   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICEINTERFACEGUID);
;;;2896   
;;;2897   
;;;2898   								// DeviceIdleEnabled
;;;2899   								pString = DEVICEIDLEENABLED_NAME;
;;;2900   								MS_OS_Property.DeviceIdleEnabled.Size = sizeof(PROPERTY_SECTION__DEVICEIDLEENABLED);
;;;2901   								MS_OS_Property.DeviceIdleEnabled.PropertyDataType = REG_DWORD;
;;;2902   								MS_OS_Property.DeviceIdleEnabled.PropertyNameLength = 36;
;;;2903   								for (i = 0; i < (MS_OS_Property.DeviceIdleEnabled.PropertyNameLength / 2); i++)
;;;2904   								{
;;;2905   									MS_OS_Property.DeviceIdleEnabled.PropertyName[i * 2] = pString[i];
;;;2906   								}
;;;2907   								MS_OS_Property.DeviceIdleEnabled.PropertyDataLength = 0x04;
;;;2908   								MS_OS_Property.DeviceIdleEnabled.PropertyData = 0x01;
;;;2909   								MS_OS_Property.Header.Count += 1;
;;;2910   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICEIDLEENABLED);
;;;2911   
;;;2912   
;;;2913   								// DefaultIdleState
;;;2914   								pString = DEFAULTIDLESTATE_NAME;
;;;2915   								MS_OS_Property.DefaultIdleState.Size = sizeof(PROPERTY_SECTION__DEFAULTIDLESTATE);
;;;2916   								MS_OS_Property.DefaultIdleState.PropertyDataType = REG_DWORD;
;;;2917   								MS_OS_Property.DefaultIdleState.PropertyNameLength = 34;
;;;2918   								for (i = 0; i < (MS_OS_Property.DefaultIdleState.PropertyNameLength / 2); i++)
;;;2919   								{
;;;2920   									MS_OS_Property.DefaultIdleState.PropertyName[i * 2] = pString[i];
;;;2921   								}
;;;2922   								MS_OS_Property.DefaultIdleState.PropertyDataLength = 0x04;
;;;2923   								MS_OS_Property.DefaultIdleState.PropertyData = 0x01;
;;;2924   								MS_OS_Property.Header.Count += 1;
;;;2925   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEFAULTIDLESTATE);
;;;2926   
;;;2927   
;;;2928   								// DefaultIdleTimeout
;;;2929   								pString = DEFAULTIDLETIMEOUT_NAME;
;;;2930   								MS_OS_Property.DefaultIdleTimeout.Size = sizeof(PROPERTY_SECTION__DEFAULTIDLETIMEOUT);
;;;2931   								MS_OS_Property.DefaultIdleTimeout.PropertyDataType = REG_DWORD;
;;;2932   								MS_OS_Property.DefaultIdleTimeout.PropertyNameLength = 38;
;;;2933   								for (i = 0; i < (MS_OS_Property.DefaultIdleTimeout.PropertyNameLength / 2); i++)
;;;2934   								{
;;;2935   									MS_OS_Property.DefaultIdleTimeout.PropertyName[i * 2] = pString[i];
;;;2936   								}
;;;2937   								MS_OS_Property.DefaultIdleTimeout.PropertyDataLength = 0x04;
;;;2938   								MS_OS_Property.DefaultIdleTimeout.PropertyData = 0x00001388; // 5000 ms
;;;2939   								MS_OS_Property.Header.Count += 1;
;;;2940   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEFAULTIDLETIMEOUT);
;;;2941   
;;;2942   
;;;2943   								// UserSetDeviceIdleEnabled
;;;2944   								pString = USERSETDEVICEIDLEENABLED_NAME;
;;;2945   								MS_OS_Property.UserSetDeviceIdleEnabled.Size = sizeof(PROPERTY_SECTION__USERSETDEVICEIDLEENABLED);
;;;2946   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyDataType = REG_DWORD;
;;;2947   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyNameLength = 50;
;;;2948   								for (i = 0; i < (MS_OS_Property.UserSetDeviceIdleEnabled.PropertyNameLength / 2); i++)
;;;2949   								{
;;;2950   									MS_OS_Property.UserSetDeviceIdleEnabled.PropertyName[i * 2] = pString[i];
;;;2951   								}
;;;2952   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyDataLength = 0x04;
;;;2953   								MS_OS_Property.UserSetDeviceIdleEnabled.PropertyData = 0x01;
;;;2954   								MS_OS_Property.Header.Count += 1;
;;;2955   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__USERSETDEVICEIDLEENABLED);
;;;2956   
;;;2957   
;;;2958   								// SystemWakeEnabled
;;;2959   								pString = SYSTEMWAKEENABLED_NAME;
;;;2960   								MS_OS_Property.SystemWakeEnabled.Size = sizeof(PROPERTY_SECTION__SYSTEMWAKEENABLED);
;;;2961   								MS_OS_Property.SystemWakeEnabled.PropertyDataType = REG_DWORD;
;;;2962   								MS_OS_Property.SystemWakeEnabled.PropertyNameLength = 36;
;;;2963   								for (i = 0; i < (MS_OS_Property.SystemWakeEnabled.PropertyNameLength / 2); i++)
;;;2964   								{
;;;2965   									MS_OS_Property.SystemWakeEnabled.PropertyName[i * 2] = pString[i];
;;;2966   								}
;;;2967   								MS_OS_Property.SystemWakeEnabled.PropertyDataLength = 0x04;
;;;2968   								MS_OS_Property.SystemWakeEnabled.PropertyData = 0x01;
;;;2969   								MS_OS_Property.Header.Count += 1;
;;;2970   								MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__SYSTEMWAKEENABLED);
;;;2971   							}
;;;2972   #endif
;;;2973   #endif
;;;2974   							
;;;2975   #ifdef MS_OS_EXT_PROP__ICON
;;;2976   							// DeviceIcon
;;;2977   							pString = DEVICE_ICON_STRING;
;;;2978   							MS_OS_Property.DeviceIcon.Size = sizeof(PROPERTY_SECTION__DEVICE_ICON);
;;;2979   							MS_OS_Property.DeviceIcon.PropertyDataType = REG_MULTI_SZ;
;;;2980   							MS_OS_Property.DeviceIcon.PropertyNameLength = 12;
;;;2981   							MS_OS_Property.DeviceIcon.PropertyName[0] = 'I';
;;;2982   							MS_OS_Property.DeviceIcon.PropertyName[2] = 'c';
;;;2983   							MS_OS_Property.DeviceIcon.PropertyName[4] = 'o';
;;;2984   							MS_OS_Property.DeviceIcon.PropertyName[6] = 'n';
;;;2985   							MS_OS_Property.DeviceIcon.PropertyName[8] = 's';
;;;2986   							MS_OS_Property.DeviceIcon.PropertyDataLength = 78;
;;;2987   							for (i = 0; i < (MS_OS_Property.DeviceIcon.PropertyDataLength/2); i++)
;;;2988   							{
;;;2989   								MS_OS_Property.DeviceIcon.PropertyData[i*2] = pString[i];
;;;2990   							}
;;;2991   							MS_OS_Property.Header.Count += 1;
;;;2992   							MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICE_ICON);
;;;2993   #endif
;;;2994   							
;;;2995   #ifdef MS_OS_EXT_PROP__LABEL
;;;2996   							// DeviceLabel
;;;2997   							pString = DEVICE_LABEL_STRING;
;;;2998   							MS_OS_Property.DeviceLabel.Size = sizeof(PROPERTY_SECTION__DEVICE_LABEL);
;;;2999   							MS_OS_Property.DeviceLabel.PropertyDataType = REG_SZ;
;;;3000   							MS_OS_Property.DeviceLabel.PropertyNameLength = 12;
;;;3001   							MS_OS_Property.DeviceLabel.PropertyName[0] = 'L';
;;;3002   							MS_OS_Property.DeviceLabel.PropertyName[2] = 'a';
;;;3003   							MS_OS_Property.DeviceLabel.PropertyName[4] = 'b';
;;;3004   							MS_OS_Property.DeviceLabel.PropertyName[6] = 'e';
;;;3005   							MS_OS_Property.DeviceLabel.PropertyName[8] = 'l';
;;;3006   							MS_OS_Property.DeviceLabel.PropertyDataLength = 26;
;;;3007   							for (i = 0; i < (MS_OS_Property.DeviceLabel.PropertyDataLength/2); i++)
;;;3008   							{
;;;3009   								MS_OS_Property.DeviceLabel.PropertyData[i*2] = pString[i];
;;;3010   							}
;;;3011   							MS_OS_Property.Header.Count += 1;
;;;3012   							MS_OS_Property.Header.Length += sizeof(PROPERTY_SECTION__DEVICE_LABEL);
;;;3013   #endif
;;;3014   							
;;;3015   							
;;;3016   							
;;;3017   							g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;3018   							g_EP0_BufferLength = MS_OS_Property.Header.Length;
;;;3019   
;;;3020   							// Rx
;;;3021   							EP0_TxRx_Proc(DIRECTION_IN);
;;;3022   							bStall = FALSE;
;;;3023   #endif
;;;3024   							break;
;;;3025   						}
;;;3026   
;;;3027   					}
;;;3028   
;;;3029   					break;
;;;3030   				}
;;;3031   			}
;;;3032   			break;
;;;3033   		}
;;;3034   	}
;;;3035   
;;;3036   
;;;3037   	if (bStall == TRUE)
;;;3038   	{
;;;3039   		mUsbEP0StallSet();
;;;3040   		mUsbEP0DoneSet();
;;;3041   		g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;3042   	}
;;;3043   
;;;3044   	return;
;;;3045   }
000012  bf18              IT       NE
000014  e8bd83f8          POPNE    {r3-r9,pc}
000018  4dfb              LDR      r5,|L7.1032|
00001a  2301              MOVS     r3,#1                 ;2438
00001c  2208              MOVS     r2,#8                 ;2451
00001e  69e8              LDR      r0,[r5,#0x1c]         ;2446  ; g_pSetupPacket
000020  2603              MOVS     r6,#3                 ;2451
000022  f04f0802          MOV      r8,#2                 ;2456
000026  7801              LDRB     r1,[r0,#0]            ;2446
000028  f3c11941          UBFX     r9,r1,#5,#2           ;2446
00002c  2100              MOVS     r1,#0                 ;2456
00002e  f1b90f00          CMP      r9,#0                 ;2446
000032  d00d              BEQ      |L7.80|
000034  270a              MOVS     r7,#0xa               ;2451
000036  f1b90f01          CMP      r9,#1                 ;2446
00003a  f000813d          BEQ.W    |L7.696|
00003e  f1b90f02          CMP      r9,#2                 ;2446
000042  bf04              ITT      EQ                    ;2812
000044  7842              LDRBEQ   r2,[r0,#1]            ;2812
000046  2a98              CMPEQ    r2,#0x98              ;2812
000048  f00081a4          BEQ.W    |L7.916|
00004c  f000b992          B.W      |L7.884|
                  |L7.80|
000050  f890c001          LDRB     r12,[r0,#1]           ;2451
000054  f1bc0f0c          CMP      r12,#0xc              ;2451
000058  f080818c          BCS.W    |L7.884|
00005c  e8dff00c          TBB      [pc,r12]              ;2451
000060  0612fe31          DCB      0x06,0x12,0xfe,0x31
000064  fe7276fe          DCB      0xfe,0x72,0x76,0xfe
000068  7a81fdfc          DCB      0x7a,0x81,0xfd,0xfc
00006c  8880              LDRH     r0,[r0,#4]            ;2455
00006e  49e7              LDR      r1,|L7.1036|
000070  eb010040          ADD      r0,r1,r0,LSL #1       ;2455
000074  6228              STR      r0,[r5,#0x20]         ;2456  ; g_EP0_BufferAddr
000076  f8a5800c          STRH     r8,[r5,#0xc]          ;2456
00007a  e8bd43f8          POP      {r3-r9,lr}            ;2459
00007e  2000              MOVS     r0,#0                 ;2459
000080  f7ffbffe          B.W      EP0_TxRx_Proc
000084  7881              LDRB     r1,[r0,#2]            ;2466
000086  f01101ff          ANDS     r1,r1,#0xff           ;2466
00008a  d002              BEQ      |L7.146|
00008c  2901              CMP      r1,#1                 ;2466
00008e  d007              BEQ      |L7.160|
000090  e00e              B        |L7.176|
                  |L7.146|
000092  8881              LDRH     r1,[r0,#4]            ;2470
000094  48dd              LDR      r0,|L7.1036|
000096  f8102011          LDRB     r2,[r0,r1,LSL #1]     ;2470
00009a  f0220201          BIC      r2,r2,#1              ;2470
00009e  e005              B        |L7.172|
                  |L7.160|
0000a0  8881              LDRH     r1,[r0,#4]            ;2476
0000a2  48da              LDR      r0,|L7.1036|
0000a4  f8102011          LDRB     r2,[r0,r1,LSL #1]     ;2476
0000a8  f0220202          BIC      r2,r2,#2              ;2476
                  |L7.172|
0000ac  f8002011          STRB     r2,[r0,r1,LSL #1]     ;2470
                  |L7.176|
0000b0  f8d40120          LDR      r0,[r4,#0x120]        ;2481
0000b4  f0400001          ORR      r0,r0,#1              ;2481
0000b8  f8c40120          STR      r0,[r4,#0x120]        ;2481
0000bc  70ae              STRB     r6,[r5,#2]            ;2482
0000be  e8bd83f8          POP      {r3-r9,pc}
0000c2  7881              LDRB     r1,[r0,#2]            ;2490
0000c4  f01101ff          ANDS     r1,r1,#0xff           ;2490
0000c8  d003              BEQ      |L7.210|
0000ca  2901              CMP      r1,#1                 ;2490
0000cc  d029              BEQ      |L7.290|
0000ce  f000b951          B.W      |L7.884|
                  |L7.210|
0000d2  8882              LDRH     r2,[r0,#4]            ;2494
0000d4  49cd              LDR      r1,|L7.1036|
0000d6  f8113012          LDRB     r3,[r1,r2,LSL #1]     ;2494
0000da  f0430301          ORR      r3,r3,#1              ;2494
0000de  f8013012          STRB     r3,[r1,r2,LSL #1]     ;2494
0000e2  8880              LDRH     r0,[r0,#4]            ;2496
0000e4  f0100f80          TST      r0,#0x80              ;2496
0000e8  f000010e          AND      r1,r0,#0xe            ;2502
0000ec  d00c              BEQ      |L7.264|
0000ee  f44f70b0          MOV      r0,#0x160             ;2498
0000f2  eb000081          ADD      r0,r0,r1,LSL #2       ;2498
0000f6  f4403040          ORR      r0,r0,#0x30000        ;2498
0000fa  f0404080          ORR      r0,r0,#0x40000000     ;2498
0000fe  6801              LDR      r1,[r0,#0]            ;2498
000100  f4215180          BIC      r1,r1,#0x1000         ;2498
000104  6001              STR      r1,[r0,#0]            ;2498
000106  e7d3              B        |L7.176|
                  |L7.264|
000108  f44f70c0          MOV      r0,#0x180             ;2502
00010c  eb000081          ADD      r0,r0,r1,LSL #2       ;2502
000110  f4403040          ORR      r0,r0,#0x30000        ;2502
000114  f0404080          ORR      r0,r0,#0x40000000     ;2502
000118  6801              LDR      r1,[r0,#0]            ;2502
00011a  f4215180          BIC      r1,r1,#0x1000         ;2502
00011e  6001              STR      r1,[r0,#0]            ;2502
000120  e7c6              B        |L7.176|
                  |L7.290|
000122  f8d41120          LDR      r1,[r4,#0x120]        ;2513
000126  f0410101          ORR      r1,r1,#1              ;2513
00012a  f8c41120          STR      r1,[r4,#0x120]        ;2513
00012e  70ae              STRB     r6,[r5,#2]            ;2515
000130  8881              LDRH     r1,[r0,#4]            ;2516
000132  48b6              LDR      r0,|L7.1036|
000134  f8102011          LDRB     r2,[r0,r1,LSL #1]     ;2516
000138  f0420202          ORR      r2,r2,#2              ;2516
00013c  f8002011          STRB     r2,[r0,r1,LSL #1]     ;2516
000140  e8bd83f8          POP      {r3-r9,pc}
000144  8840              LDRH     r0,[r0,#2]            ;2528
000146  f8c40104          STR      r0,[r4,#0x104]        ;2528
00014a  e7b1              B        |L7.176|
00014c  e8bd43f8          POP      {r3-r9,lr}            ;2537
000150  f7ffbffe          B.W      EP0_SetupPacket_GetDescriptor
000154  622d              STR      r5,[r5,#0x20]         ;2549  ; g_EP0_BufferAddr
000156  81ab              STRH     r3,[r5,#0xc]          ;2550
000158  e8bd43f8          POP      {r3-r9,lr}            ;2553
00015c  2000              MOVS     r0,#0                 ;2553
00015e  f7ffbffe          B.W      EP0_TxRx_Proc
000162  f88431a1          STRB     r3,[r4,#0x1a1]        ;2561
000166  f04f0c20          MOV      r12,#0x20             ;2562
00016a  f884c1a2          STRB     r12,[r4,#0x1a2]       ;2562
00016e  f88411a3          STRB     r1,[r4,#0x1a3]        ;2563
000172  f88461a5          STRB     r6,[r4,#0x1a5]        ;2564
000176  2112              MOVS     r1,#0x12              ;2569
000178  f88411a9          STRB     r1,[r4,#0x1a9]        ;2569
00017c  f88461aa          STRB     r6,[r4,#0x1aa]        ;2570
000180  2114              MOVS     r1,#0x14              ;2571
000182  f88411a8          STRB     r1,[r4,#0x1a8]        ;2571
000186  2116              MOVS     r1,#0x16              ;2572
000188  f88411ab          STRB     r1,[r4,#0x1ab]        ;2572
00018c  2140              MOVS     r1,#0x40              ;2577
00018e  f8c41164          STR      r1,[r4,#0x164]        ;2577
000192  f8c41188          STR      r1,[r4,#0x188]        ;2578
000196  f8c4116c          STR      r1,[r4,#0x16c]        ;2579
00019a  f8c41174          STR      r1,[r4,#0x174]        ;2580
00019e  2123              MOVS     r1,#0x23              ;2585
0001a0  f88411ad          STRB     r1,[r4,#0x1ad]        ;2585
0001a4  f88411ae          STRB     r1,[r4,#0x1ae]        ;2586
0001a8  f88411ac          STRB     r1,[r4,#0x1ac]        ;2587
0001ac  f88411af          STRB     r1,[r4,#0x1af]        ;2588
0001b0  f8c42328          STR      r2,[r4,#0x328]        ;2588
0001b4  f8d4132c          LDR      r1,[r4,#0x32c]        ;2588
0001b8  f4412100          ORR      r1,r1,#0x80000        ;2588
0001bc  f8c4132c          STR      r1,[r4,#0x32c]        ;2588
0001c0  f8d4132c          LDR      r1,[r4,#0x32c]        ;2588
0001c4  f0410108          ORR      r1,r1,#8              ;2588
0001c8  f8c4132c          STR      r1,[r4,#0x32c]        ;2588
0001cc  f8d4132c          LDR      r1,[r4,#0x32c]        ;2588
0001d0  f4212100          BIC      r1,r1,#0x80000        ;2588
0001d4  f8c4132c          STR      r1,[r4,#0x32c]        ;2588
0001d8  f8d4132c          LDR      r1,[r4,#0x32c]        ;2588
0001dc  f0210108          BIC      r1,r1,#8              ;2588
0001e0  f8c4132c          STR      r1,[r4,#0x32c]        ;2588
0001e4  f44f4180          MOV      r1,#0x4000            ;2588
0001e8  f8c41318          STR      r1,[r4,#0x318]        ;2588
0001ec  4988              LDR      r1,|L7.1040|
0001ee  f8c4131c          STR      r1,[r4,#0x31c]        ;2588
0001f2  f8d41318          LDR      r1,[r4,#0x318]        ;2588
0001f6  f0410101          ORR      r1,r1,#1              ;2588
0001fa  f8c41318          STR      r1,[r4,#0x318]        ;2588
0001fe  f8d41164          LDR      r1,[r4,#0x164]        ;2599
000202  f4215180          BIC      r1,r1,#0x1000         ;2599
000206  f8c41164          STR      r1,[r4,#0x164]        ;2599
00020a  f8d41188          LDR      r1,[r4,#0x188]        ;2600
00020e  f4215180          BIC      r1,r1,#0x1000         ;2600
000212  f8c41188          STR      r1,[r4,#0x188]        ;2600
000216  f8d4116c          LDR      r1,[r4,#0x16c]        ;2601
00021a  f4215180          BIC      r1,r1,#0x1000         ;2601
00021e  f8c4116c          STR      r1,[r4,#0x16c]        ;2601
000222  f8d41174          LDR      r1,[r4,#0x174]        ;2602
000226  f4215180          BIC      r1,r1,#0x1000         ;2602
00022a  f8c41174          STR      r1,[r4,#0x174]        ;2602
00022e  f2427110          MOV      r1,#0x2710            ;2607
000232  f8c41110          STR      r1,[r4,#0x110]        ;2607
000236  f8d41120          LDR      r1,[r4,#0x120]        ;2610
00023a  f0410101          ORR      r1,r1,#1              ;2610
00023e  f8c41120          STR      r1,[r4,#0x120]        ;2610
000242  f8d41104          LDR      r1,[r4,#0x104]        ;2613
000246  f0410180          ORR      r1,r1,#0x80           ;2613
00024a  f8c41104          STR      r1,[r4,#0x104]        ;2613
00024e  70ae              STRB     r6,[r5,#2]            ;2615
000250  7880              LDRB     r0,[r0,#2]            ;2616
000252  7028              STRB     r0,[r5,#0]            ;2616
000254  706b              STRB     r3,[r5,#1]            ;2617
                  |L7.598|
000256  e002              B        |L7.606|
000258  e00c              B        |L7.628|
00025a  e002              B        |L7.610|
00025c  e08a              B        |L7.884|
                  |L7.606|
00025e  e8bd83f8          POP      {r3-r9,pc}
                  |L7.610|
000262  f88d1000          STRB     r1,[sp,#0]            ;2624
000266  f8c5d020          STR      sp,[r5,#0x20]         ;2626  ; g_EP0_BufferAddr
00026a  81ab              STRH     r3,[r5,#0xc]          ;2627
00026c  2000              MOVS     r0,#0                 ;2630
00026e  f7fffffe          BL       EP0_TxRx_Proc
000272  e7f0              B        |L7.598|
                  |L7.628|
000274  8880              LDRH     r0,[r0,#4]            ;2637
000276  b158              CBZ      r0,|L7.656|
000278  2801              CMP      r0,#1                 ;2637
00027a  d010              BEQ      |L7.670|
00027c  2802              CMP      r0,#2                 ;2637
00027e  f47faf17          BNE      |L7.176|
000282  f8d40174          LDR      r0,[r4,#0x174]        ;2657
000286  f4205080          BIC      r0,r0,#0x1000         ;2657
00028a  f8c40174          STR      r0,[r4,#0x174]        ;2657
00028e  e70f              B        |L7.176|
                  |L7.656|
000290  f8d40164          LDR      r0,[r4,#0x164]        ;2642
000294  f4205080          BIC      r0,r0,#0x1000         ;2642
000298  f8c40164          STR      r0,[r4,#0x164]        ;2642
00029c  e708              B        |L7.176|
                  |L7.670|
00029e  f8d40188          LDR      r0,[r4,#0x188]        ;2649
0002a2  f4205080          BIC      r0,r0,#0x1000         ;2649
0002a6  f8c40188          STR      r0,[r4,#0x188]        ;2649
0002aa  f8d4016c          LDR      r0,[r4,#0x16c]        ;2650
0002ae  f4205080          BIC      r0,r0,#0x1000         ;2650
0002b2  f8c4016c          STR      r0,[r4,#0x16c]        ;2650
0002b6  e6fb              B        |L7.176|
                  |L7.696|
0002b8  f8909001          LDRB     r9,[r0,#1]            ;2684
0002bc  f1b90f01          CMP      r9,#1                 ;2684
0002c0  d00a              BEQ      |L7.728|
0002c2  4954              LDR      r1,|L7.1044|
0002c4  f1b90f02          CMP      r9,#2                 ;2684
0002c8  d05b              BEQ      |L7.898|
0002ca  f1b90f09          CMP      r9,#9                 ;2684
0002ce  d025              BEQ      |L7.796|
0002d0  f1b90f0a          CMP      r9,#0xa               ;2684
0002d4  d045              BEQ      |L7.866|
0002d6  e04d              B        |L7.884|
                  |L7.728|
0002d8  8840              LDRH     r0,[r0,#2]            ;2690
0002da  f400417f          AND      r1,r0,#0xff00         ;2690
0002de  f5b17f40          CMP      r1,#0x300             ;2690
0002e2  d147              BNE      |L7.884|
0002e4  b2c0              UXTB     r0,r0                 ;2692
0002e6  2806              CMP      r0,#6                 ;2692
0002e8  d00c              BEQ      |L7.772|
0002ea  2808              CMP      r0,#8                 ;2692
0002ec  d142              BNE      |L7.884|
0002ee  484a              LDR      r0,|L7.1048|
0002f0  7002              STRB     r2,[r0,#0]            ;2698
0002f2  7047              STRB     r7,[r0,#1]            ;2699
0002f4  6228              STR      r0,[r5,#0x20]         ;2703  ; g_EP0_BufferAddr
0002f6  f8a5800c          STRH     r8,[r5,#0xc]          ;2703
0002fa  e8bd43f8          POP      {r3-r9,lr}            ;2706
0002fe  2000              MOVS     r0,#0                 ;2706
000300  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.772|
000304  4845              LDR      r0,|L7.1052|
000306  6a69              LDR      r1,[r5,#0x24]         ;2713  ; g_EP0_Offset
000308  4408              ADD      r0,r0,r1              ;2713
00030a  6228              STR      r0,[r5,#0x20]         ;2714  ; g_EP0_BufferAddr
00030c  f2401001          MOV      r0,#0x101             ;2714
000310  81a8              STRH     r0,[r5,#0xc]          ;2714
000312  e8bd43f8          POP      {r3-r9,lr}            ;2717
000316  2000              MOVS     r0,#0                 ;2717
000318  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.796|
00031c  8841              LDRH     r1,[r0,#2]            ;2731
00031e  f401427f          AND      r2,r1,#0xff00         ;2731
000322  f5b27f40          CMP      r2,#0x300             ;2731
000326  d125              BNE      |L7.884|
000328  b2c9              UXTB     r1,r1                 ;2735
00032a  2907              CMP      r1,#7                 ;2735
00032c  d108              BNE      |L7.832|
00032e  493c              LDR      r1,|L7.1056|
000330  6229              STR      r1,[r5,#0x20]         ;2738  ; g_EP0_BufferAddr
000332  88c0              LDRH     r0,[r0,#6]            ;2738
000334  81a8              STRH     r0,[r5,#0xc]          ;2738
000336  2001              MOVS     r0,#1                 ;2741
000338  f7fffffe          BL       EP0_TxRx_Proc
00033c  f04f0c00          MOV      r12,#0                ;2742
                  |L7.832|
000340  69e8              LDR      r0,[r5,#0x1c]         ;2747  ; g_pSetupPacket
000342  7881              LDRB     r1,[r0,#2]            ;2747
000344  2905              CMP      r1,#5                 ;2747
000346  d003              BEQ      |L7.848|
000348  f1bc0f00          CMP      r12,#0                ;3037
00034c  d083              BEQ      |L7.598|
00034e  e011              B        |L7.884|
                  |L7.848|
000350  4934              LDR      r1,|L7.1060|
000352  6229              STR      r1,[r5,#0x20]         ;2750  ; g_EP0_BufferAddr
000354  88c0              LDRH     r0,[r0,#6]            ;2750
000356  81a8              STRH     r0,[r5,#0xc]          ;2750
000358  e8bd43f8          POP      {r3-r9,lr}            ;2753
00035c  2001              MOVS     r0,#1                 ;2753
00035e  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.866|
000362  8842              LDRH     r2,[r0,#2]            ;2767
000364  f01200ff          ANDS     r0,r2,#0xff           ;2767
000368  ea4f2212          LSR      r2,r2,#8              ;2768
00036c  bf18              IT       NE                    ;2781
00036e  540a              STRBNE   r2,[r1,r0]            ;2781
000370  f47fae9e          BNE      |L7.176|
                  |L7.884|
000374  f8d40120          LDR      r0,[r4,#0x120]        ;2773
000378  f0400004          ORR      r0,r0,#4              ;2773
00037c  f8c40120          STR      r0,[r4,#0x120]        ;2773
000380  e696              B        |L7.176|
                  |L7.898|
000382  7880              LDRB     r0,[r0,#2]            ;2795
000384  4408              ADD      r0,r0,r1              ;2797
000386  6228              STR      r0,[r5,#0x20]         ;2798  ; g_EP0_BufferAddr
000388  81ab              STRH     r3,[r5,#0xc]          ;2798
00038a  e8bd43f8          POP      {r3-r9,lr}            ;2801
00038e  2000              MOVS     r0,#0                 ;2801
000390  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L7.916|
000394  8880              LDRH     r0,[r0,#4]            ;2817
000396  2804              CMP      r0,#4                 ;2817
000398  d0ec              BEQ      |L7.884|
00039a  2805              CMP      r0,#5                 ;2817
00039c  d1ea              BNE      |L7.884|
00039e  4c22              LDR      r4,|L7.1064|
0003a0  f44f7080          MOV      r0,#0x100             ;2857
0003a4  46a4              MOV      r12,r4                ;2856
0003a6  2604              MOVS     r6,#4                 ;2864
0003a8  f8cc7000          STR      r7,[r12,#0]           ;2856  ; MS_OS_Property
0003ac  f8ac0004          STRH     r0,[r12,#4]           ;2857
0003b0  2005              MOVS     r0,#5                 ;2858
0003b2  f8ac0006          STRH     r0,[r12,#6]           ;2858
0003b6  f8ac1008          STRH     r1,[r12,#8]           ;2859
0003ba  2142              MOVS     r1,#0x42              ;2863
0003bc  f8cc100a          STR      r1,[r12,#0xa]         ;2863  ; MS_OS_Property
0003c0  2130              MOVS     r1,#0x30              ;2865
0003c2  a01a              ADR      r0,|L7.1068|
0003c4  f8cc600e          STR      r6,[r12,#0xe]         ;2864  ; MS_OS_Property
0003c8  f8ac1012          STRH     r1,[r12,#0x12]        ;2865
0003cc  1e42              SUBS     r2,r0,#1              ;2866
0003ce  f10c0112          ADD      r1,r12,#0x12          ;2866
0003d2  200c              MOVS     r0,#0xc               ;2866
                  |L7.980|
0003d4  7857              LDRB     r7,[r2,#1]            ;2868
0003d6  708f              STRB     r7,[r1,#2]            ;2868
0003d8  f8127f02          LDRB     r7,[r2,#2]!           ;2868
0003dc  f8017f04          STRB     r7,[r1,#4]!           ;2868
0003e0  1e40              SUBS     r0,r0,#1              ;2868
0003e2  d1f7              BNE      |L7.980|
0003e4  f8cc6044          STR      r6,[r12,#0x44]        ;2870  ; MS_OS_Property
0003e8  f8cc3048          STR      r3,[r12,#0x48]        ;2871  ; MS_OS_Property
0003ec  f8bc0008          LDRH     r0,[r12,#8]           ;2872  ; MS_OS_Property
0003f0  1c40              ADDS     r0,r0,#1              ;2872
0003f2  f8ac0008          STRH     r0,[r12,#8]           ;2872
0003f6  f8dc0000          LDR      r0,[r12,#0]           ;2873  ; MS_OS_Property
0003fa  3042              ADDS     r0,r0,#0x42           ;2873
0003fc  f8cc0000          STR      r0,[r12,#0]           ;2873  ; MS_OS_Property
000400  6a69              LDR      r1,[r5,#0x24]         ;3017  ; g_EP0_Offset
000402  e01f              B        |L7.1092|
                  |L7.1028|
                          DCD      0x40030000
                  |L7.1032|
                          DCD      ||.data||
                  |L7.1036|
                          DCD      ||.bss||
                  |L7.1040|
                          DCD      ||.bss||+0x27f5
                  |L7.1044|
                          DCD      ||.bss||+0x12
                  |L7.1048|
                          DCD      ||.data||+0x10
                  |L7.1052|
                          DCD      u8_HID_Touch_Blob
                  |L7.1056|
                          DCD      ||.data||+0x18
                  |L7.1060|
                          DCD      ||.data||+0xe
                  |L7.1064|
                          DCD      MS_OS_Property
                  |L7.1068|
00042c  53656c65          DCB      "SelectiveSuspendEnabled",0
000430  63746976
000434  65537573
000438  70656e64
00043c  456e6162
000440  6c656400
                  |L7.1092|
000444  4421              ADD      r1,r1,r4              ;3017
000446  6229              STR      r1,[r5,#0x20]         ;3018  ; g_EP0_BufferAddr
000448  81a8              STRH     r0,[r5,#0xc]          ;3018
00044a  e8bd43f8          POP      {r3-r9,lr}            ;3021
00044e  2000              MOVS     r0,#0                 ;3021
000450  f7ffbffe          B.W      EP0_TxRx_Proc
;;;3046   
                          ENDP


                          AREA ||i.EP0_SetupPacket_GetDescriptor||, CODE, READONLY, ALIGN=2

                  EP0_SetupPacket_GetDescriptor PROC
;;;2166   
;;;2167   void EP0_SetupPacket_GetDescriptor(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2168   {
;;;2169   	uint8_t	bStall = TRUE;
;;;2170   
;;;2171   	switch ((g_pSetupPacket->wValue & 0xFF00) >> 8)
000004  4f8a              LDR      r7,|L8.560|
000006  2200              MOVS     r2,#0
000008  2401              MOVS     r4,#1                 ;2169
00000a  69f9              LDR      r1,[r7,#0x1c]  ; g_pSetupPacket
;;;2172   	{
;;;2173   		case SETUPPACKET_DESCRIPTOR__DEVICE:
;;;2174   		{
;;;2175   			g_EP0_BufferAddr = &u8_FS_DeviceDesc[0];
;;;2176   			g_EP0_BufferLength = DEVICE_DESC_LENGTH;
;;;2177   
;;;2178   			// Tx
;;;2179   			EP0_TxRx_Proc(DIRECTION_IN);
;;;2180   			bStall = FALSE;
;;;2181   			break;
;;;2182   		}
;;;2183   
;;;2184   		case SETUPPACKET_DESCRIPTOR__CONFIGURATION:
;;;2185   		{
;;;2186   			g_EP0_BufferAddr = &u8_FS_ConfigDesc[g_EP0_Offset];
;;;2187   			g_EP0_BufferLength = CONFIG_DESC_LENGTH;
;;;2188   
;;;2189   			// Tx
;;;2190   			EP0_TxRx_Proc(DIRECTION_IN);
;;;2191   			bStall = FALSE;
;;;2192   			break;
;;;2193   		}
;;;2194   
;;;2195   		case SETUPPACKET_DESCRIPTOR__STRING:
;;;2196   		{
;;;2197   			switch (g_pSetupPacket->wValue & 0x00FF)
;;;2198   			{
;;;2199   				// Lang IDs
;;;2200   				case 0:
;;;2201   				{
;;;2202   					g_EP0_BufferAddr = &u8O_StrDesc_LangIDs[g_EP0_Offset];
;;;2203   					g_EP0_BufferLength = STRING_LANG_IDS_LENGTH;
;;;2204   
;;;2205   					// Tx
;;;2206   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2207   					bStall = FALSE;
;;;2208   					break;
;;;2209   				}
;;;2210   
;;;2211   				// Product String
;;;2212   				case DEVICE_PRODUCT:
;;;2213   				{
;;;2214   					g_EP0_BufferAddr = &u8O_StrDesc_Product[g_EP0_Offset];
;;;2215   					g_EP0_BufferLength = STRING_PRODUCT_LENGTH;
;;;2216   
;;;2217   					// Tx
;;;2218   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2219   					bStall = FALSE;
;;;2220   					break;
;;;2221   				}
;;;2222   				
;;;2223   				// Manufacturer
;;;2224   				case DEVICE_MANUFACTURER:
;;;2225   				{
;;;2226   					g_EP0_BufferAddr = &u8O_StrDesc_Manufacturer[g_EP0_Offset];
;;;2227   					g_EP0_BufferLength = STRING_MANUFACTURER_LENGTH;
;;;2228   
;;;2229   					// Tx
;;;2230   					EP0_TxRx_Proc(DIRECTION_IN);
;;;2231   					bStall = FALSE;
;;;2232   					break;
;;;2233   				}
;;;2234   
;;;2235   				// String Microsoft OS
;;;2236   				case SETUPPACKET_DESCRIPTOR__MS_OS:
;;;2237   				{
;;;2238   					if (g_pSetupPacket->wValue == SETUPPACKET_DESCRIPTOR__MS_OS_2)
;;;2239   					{
;;;2240   #ifdef USB_SELECTIVE_SUSPEND
;;;2241   						uint8_t* pBuffer = (uint8_t*)&MS_OS_Descriptor;
;;;2242   
;;;2243   						MS_OS_Descriptor.Length = sizeof(MS_OS_STRING_DESCRIPTOR);
;;;2244   						MS_OS_Descriptor.Type = SETUPPACKET_DESCRIPTOR__STRING;
00000c  f04f0c03          MOV      r12,#3
000010  8848              LDRH     r0,[r1,#2]            ;2171
000012  0a05              LSRS     r5,r0,#8              ;2171
000014  2d0f              CMP      r5,#0xf               ;2171
000016  f00080e7          BEQ.W    |L8.488|
00001a  dc08              BGT      |L8.46|
00001c  f04f0112          MOV      r1,#0x12              ;2176
000020  2d01              CMP      r5,#1                 ;2171
000022  d00a              BEQ      |L8.58|
000024  2d02              CMP      r5,#2                 ;2171
000026  d010              BEQ      |L8.74|
000028  2d03              CMP      r5,#3                 ;2171
00002a  d019              BEQ      |L8.96|
00002c  e026              B        |L8.124|
                  |L8.46|
;;;2245   						MS_OS_Descriptor.Signature[0] = 'M';
;;;2246   						MS_OS_Descriptor.Signature[2] = 'S';
;;;2247   						MS_OS_Descriptor.Signature[4] = 'F';
;;;2248   						MS_OS_Descriptor.Signature[6] = 'T';
;;;2249   						MS_OS_Descriptor.Signature[8] = '1';
;;;2250   						MS_OS_Descriptor.Signature[10] = '0';
;;;2251   						MS_OS_Descriptor.Signature[12] = '0';
;;;2252   						MS_OS_Descriptor.MSVendorCode = SETUPPACKET_DESCRIPTOR__MS_OS_VENDOR_CODE;
;;;2253   						MS_OS_Descriptor.Pad = 0x00;
;;;2254   
;;;2255   						g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;2256   						g_EP0_BufferLength = sizeof(MS_OS_STRING_DESCRIPTOR);
;;;2257   						
;;;2258   						// Tx
;;;2259   						EP0_TxRx_Proc(DIRECTION_IN);
;;;2260   						bStall = FALSE;
;;;2261   #endif
;;;2262   					}
;;;2263   
;;;2264   					break;
;;;2265   				}
;;;2266   			}
;;;2267   
;;;2268   			break;
;;;2269   		}
;;;2270   
;;;2271   		case SETUPPACKET_DESCRIPTOR__HID:
;;;2272   		{
;;;2273   			UINT8	i = 0;
;;;2274   			UINT8*	pBuffer = (UINT8*)&g_HID_Descriptor;
;;;2275   
;;;2276   			g_HID_Descriptor.bLength = HID_DESCRIPTOR_LENGTH;
;;;2277   			g_HID_Descriptor.bDescriptorType = SETUPPACKET_DESCRIPTOR__HID;
;;;2278   			g_HID_Descriptor.bcdHID = HID_VERSION;
;;;2279   			g_HID_Descriptor.bCountryCode = 0;
;;;2280   			g_HID_Descriptor.bNumDescriptors = 1;
;;;2281   			g_HID_Descriptor.bDescriptorType_Class = SETUPPACKET_DESCRIPTOR__REPORT;
;;;2282   	
;;;2283   			switch (g_pSetupPacket->wIndex)
;;;2284   			{
;;;2285   #ifdef ADD_TOUCH
;;;2286   				// Multi-Touch
;;;2287   				case TOUCH_INTERFACE_NUM:
;;;2288   				{
;;;2289   					g_HID_Descriptor.wDescriptorLength = HID_MULTITOUCH_DESC_HEAD_LENGTH;
;;;2290   					#if USE_USB_HID_TOUCH_DEBUG
;;;2291   					for (i = 0; i < HID_MAX_TOUCH_HYBRID; i++)
;;;2292   					#else
;;;2293   					for (i = 0; i < HID_MAX_TOUCH; i++)
;;;2294   					#endif
;;;2295   					{
;;;2296   						g_HID_Descriptor.wDescriptorLength += HID_MULTITOUCH_DESC_MAIN_LENGTH;
;;;2297   					}
;;;2298   
;;;2299   					g_HID_Descriptor.wDescriptorLength += HID_MULTITOUCH_DESC_TAIL_LENGTH;
;;;2300   					break;
;;;2301   				}
;;;2302   #endif
;;;2303   
;;;2304   #ifdef ADD_CUSTOM
;;;2305   				// Custom
;;;2306   				case CUSTOM_INTERFACE_NUM:
;;;2307   				{
;;;2308   					g_HID_Descriptor.wDescriptorLength = HID_CUSTOM_DESC_LENGTH;
00002e  2326              MOVS     r3,#0x26
000030  2d21              CMP      r5,#0x21              ;2171
000032  d07d              BEQ      |L8.304|
000034  2d22              CMP      r5,#0x22              ;2171
000036  d07c              BEQ      |L8.306|
000038  e020              B        |L8.124|
                  |L8.58|
00003a  487e              LDR      r0,|L8.564|
00003c  6238              STR      r0,[r7,#0x20]         ;2176  ; g_EP0_BufferAddr
00003e  81b9              STRH     r1,[r7,#0xc]          ;2176
000040  e8bd41f0          POP      {r4-r8,lr}            ;2179
000044  2000              MOVS     r0,#0                 ;2179
000046  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.74|
00004a  487b              LDR      r0,|L8.568|
00004c  6a79              LDR      r1,[r7,#0x24]         ;2186  ; g_EP0_Offset
00004e  4408              ADD      r0,r0,r1              ;2186
000050  6238              STR      r0,[r7,#0x20]         ;2187  ; g_EP0_BufferAddr
000052  2052              MOVS     r0,#0x52              ;2187
000054  81b8              STRH     r0,[r7,#0xc]          ;2187
000056  e8bd41f0          POP      {r4-r8,lr}            ;2190
00005a  2000              MOVS     r0,#0                 ;2190
00005c  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.96|
000060  f01003ff          ANDS     r3,r0,#0xff           ;2197
000064  d01b              BEQ      |L8.158|
000066  2b01              CMP      r3,#1                 ;2197
000068  d024              BEQ      |L8.180|
00006a  2b02              CMP      r3,#2                 ;2197
00006c  d02d              BEQ      |L8.202|
00006e  2bee              CMP      r3,#0xee              ;2197
000070  bf04              ITT      EQ                    ;2238
000072  f5a07300          SUBEQ    r3,r0,#0x200          ;2238
000076  f5b373f7          SUBSEQ   r3,r3,#0x1ee          ;2238
00007a  d031              BEQ      |L8.224|
                  |L8.124|
;;;2309   					break;
;;;2310   				}
;;;2311   #endif
;;;2312   
;;;2313   #ifdef ADD_PEN
;;;2314   				// Pen
;;;2315   				case PEN_INTERFACE_NUM:
;;;2316   				{
;;;2317   					g_HID_Descriptor.wDescriptorLength = HID_PEN_DESC_LENGTH;
;;;2318   					break;
;;;2319   				}
;;;2320   #endif
;;;2321   			}
;;;2322   
;;;2323   			g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;2324   			g_EP0_BufferLength = HID_DESCRIPTOR_LENGTH;
;;;2325   
;;;2326   			// Tx
;;;2327   			EP0_TxRx_Proc(DIRECTION_IN);
;;;2328   			bStall = FALSE;
;;;2329   			break;
;;;2330   		}
;;;2331   
;;;2332   		case SETUPPACKET_DESCRIPTOR__REPORT:
;;;2333   		{
;;;2334   			switch (g_pSetupPacket->wIndex)
;;;2335   			{
;;;2336   #ifdef ADD_TOUCH
;;;2337   				// Multi-Touch
;;;2338   				case TOUCH_INTERFACE_NUM:
;;;2339   				{
;;;2340   					uint8_t	i = 0;
;;;2341   					uint16_t	Offset = 0;
;;;2342   
;;;2343   					// Head
;;;2344   					memcpy(&u8_HID_MultiTouchReportDesc_Temp[Offset], u8_HID_MultiTouch_Descriptor_Head, HID_MULTITOUCH_DESC_HEAD_LENGTH);
;;;2345   					Offset += HID_MULTITOUCH_DESC_HEAD_LENGTH;
;;;2346   
;;;2347   					// Main
;;;2348   					#if USE_USB_HID_TOUCH_DEBUG
;;;2349   					for (i = 0; i < HID_MAX_TOUCH_HYBRID; i++)
;;;2350   					#else
;;;2351   					for (i = 0; i < HID_MAX_TOUCH; i++)
;;;2352   					#endif
;;;2353   					{
;;;2354   						memcpy(&u8_HID_MultiTouchReportDesc_Temp[Offset], u8_HID_MultiTouch_Descriptor_Main, HID_MULTITOUCH_DESC_MAIN_LENGTH);
;;;2355   						Offset += HID_MULTITOUCH_DESC_MAIN_LENGTH;
;;;2356   					}
;;;2357   
;;;2358   					// Tail
;;;2359   					memcpy(&u8_HID_MultiTouchReportDesc_Temp[Offset], u8_HID_MultiTouch_Descriptor_Tail, HID_MULTITOUCH_DESC_TAIL_LENGTH);
;;;2360   					Offset += HID_MULTITOUCH_DESC_TAIL_LENGTH;
;;;2361   					
;;;2362   
;;;2363   					g_EP0_BufferAddr = &u8_HID_MultiTouchReportDesc_Temp[g_EP0_Offset];
;;;2364   					g_EP0_BufferLength = Offset;
;;;2365   					break;
;;;2366   				}
;;;2367   #endif
;;;2368   
;;;2369   #ifdef ADD_CUSTOM
;;;2370   				// Custom
;;;2371   				case CUSTOM_INTERFACE_NUM:
;;;2372   				{
;;;2373   					g_EP0_BufferAddr = &u8_HID_Custom_Descriptor[g_EP0_Offset];
;;;2374   					g_EP0_BufferLength = HID_CUSTOM_DESC_LENGTH;
;;;2375   					break;
;;;2376   				}
;;;2377   #endif
;;;2378   
;;;2379   #ifdef ADD_PEN
;;;2380   				// Pen
;;;2381   				case PEN_INTERFACE_NUM:
;;;2382   				{
;;;2383   					g_EP0_BufferAddr = &u8_HID_Pen_Descriptor[g_EP0_Offset];
;;;2384   					g_EP0_BufferLength = HID_PEN_DESC_LENGTH;
;;;2385   					break;
;;;2386   				}
;;;2387   #endif
;;;2388   			}
;;;2389   
;;;2390   			// Tx
;;;2391   			EP0_TxRx_Proc(DIRECTION_IN);
;;;2392   			bStall = FALSE;
;;;2393   			break;
;;;2394   		}
;;;2395   
;;;2396   #ifdef USB_SELECTIVE_SUSPEND
;;;2397   		case SETUPPACKET_DESCRIPTOR__BOS:
;;;2398   		{
;;;2399   			uint8_t*	pBuffer = (uint8_t*)&BOS_Descriptor;
;;;2400   
;;;2401   			BOS_Descriptor.Length = 5;
;;;2402   			BOS_Descriptor.Type = SETUPPACKET_DESCRIPTOR__BOS;
;;;2403   			BOS_Descriptor.TotalLength = sizeof(BOS_DESCRIPTOR);
;;;2404   			BOS_Descriptor.NumCapability = 1;
;;;2405   			BOS_Descriptor.Usb20ExtDesc.Length = sizeof(USB20_EXT_DESCRIPTOR);
;;;2406   			BOS_Descriptor.Usb20ExtDesc.Type = 0x10;
;;;2407   			BOS_Descriptor.Usb20ExtDesc.DevCapabilityType = 0x02;
;;;2408   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_LPM_Support = 1;
;;;2409   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_BESL_Support = 1;
;;;2410   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_BaseLineBESL = 1;
;;;2411   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_DeepBESL = 1;
;;;2412   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_BESL = 10;
;;;2413   			BOS_Descriptor.Usb20ExtDesc.bmAttributes_DBESL = 11;
;;;2414   
;;;2415   			g_EP0_BufferAddr = (uint8_t*)&pBuffer[g_EP0_Offset];
;;;2416   			g_EP0_BufferLength = sizeof(BOS_DESCRIPTOR);
;;;2417   			EP0_TxRx_Proc(DIRECTION_IN);
;;;2418   			bStall = FALSE;
;;;2419   			break;
;;;2420   		}
;;;2421   #endif
;;;2422   	}
;;;2423   
;;;2424   
;;;2425   	if (bStall == TRUE)
;;;2426   	{
;;;2427   		mUsbEP0StallSet();
00007c  486f              LDR      r0,|L8.572|
00007e  f8d01120          LDR      r1,[r0,#0x120]
000082  f0410104          ORR      r1,r1,#4
000086  f8c01120          STR      r1,[r0,#0x120]
;;;2428   		mUsbEP0DoneSet();
00008a  f8d01120          LDR      r1,[r0,#0x120]
00008e  f0410101          ORR      r1,r1,#1
000092  f8c01120          STR      r1,[r0,#0x120]
;;;2429   		g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
000096  f887c002          STRB     r12,[r7,#2]
;;;2430   	}
;;;2431   
;;;2432   	return;
;;;2433   }
00009a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.158|
00009e  4868              LDR      r0,|L8.576|
0000a0  6a79              LDR      r1,[r7,#0x24]         ;2202  ; g_EP0_Offset
0000a2  4408              ADD      r0,r0,r1              ;2202
0000a4  6238              STR      r0,[r7,#0x20]         ;2203  ; g_EP0_BufferAddr
0000a6  2004              MOVS     r0,#4                 ;2203
0000a8  81b8              STRH     r0,[r7,#0xc]          ;2203
0000aa  e8bd41f0          POP      {r4-r8,lr}            ;2206
0000ae  2000              MOVS     r0,#0                 ;2206
0000b0  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.180|
0000b4  4863              LDR      r0,|L8.580|
0000b6  6a79              LDR      r1,[r7,#0x24]         ;2214  ; g_EP0_Offset
0000b8  4408              ADD      r0,r0,r1              ;2214
0000ba  6238              STR      r0,[r7,#0x20]         ;2215  ; g_EP0_BufferAddr
0000bc  2032              MOVS     r0,#0x32              ;2215
0000be  81b8              STRH     r0,[r7,#0xc]          ;2215
0000c0  e8bd41f0          POP      {r4-r8,lr}            ;2218
0000c4  2000              MOVS     r0,#0                 ;2218
0000c6  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.202|
0000ca  485f              LDR      r0,|L8.584|
0000cc  6a79              LDR      r1,[r7,#0x24]         ;2226  ; g_EP0_Offset
0000ce  4408              ADD      r0,r0,r1              ;2226
0000d0  6238              STR      r0,[r7,#0x20]         ;2227  ; g_EP0_BufferAddr
0000d2  201a              MOVS     r0,#0x1a              ;2227
0000d4  81b8              STRH     r0,[r7,#0xc]          ;2227
0000d6  e8bd41f0          POP      {r4-r8,lr}            ;2230
0000da  2000              MOVS     r0,#0                 ;2230
0000dc  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.224|
0000e0  4b5a              LDR      r3,|L8.588|
0000e2  4618              MOV      r0,r3                 ;2243
0000e4  7001              STRB     r1,[r0,#0]            ;2243
0000e6  f880c001          STRB     r12,[r0,#1]           ;2244
0000ea  f04f0c4d          MOV      r12,#0x4d             ;2245
0000ee  f880c002          STRB     r12,[r0,#2]           ;2245
0000f2  f04f0c53          MOV      r12,#0x53             ;2246
0000f6  f880c004          STRB     r12,[r0,#4]           ;2246
0000fa  f04f0c46          MOV      r12,#0x46             ;2247
0000fe  f880c006          STRB     r12,[r0,#6]           ;2247
000102  f04f0c54          MOV      r12,#0x54             ;2248
000106  f880c008          STRB     r12,[r0,#8]           ;2248
00010a  f04f0c31          MOV      r12,#0x31             ;2249
00010e  f880c00a          STRB     r12,[r0,#0xa]         ;2249
000112  f04f0c30          MOV      r12,#0x30             ;2250
000116  f880c00c          STRB     r12,[r0,#0xc]         ;2250
00011a  f880c00e          STRB     r12,[r0,#0xe]         ;2251
00011e  f04f0c98          MOV      r12,#0x98             ;2252
000122  f880c010          STRB     r12,[r0,#0x10]        ;2252
000126  7442              STRB     r2,[r0,#0x11]         ;2253
000128  6a78              LDR      r0,[r7,#0x24]         ;2255  ; g_EP0_Offset
00012a  4418              ADD      r0,r0,r3              ;2255
00012c  6238              STR      r0,[r7,#0x20]         ;2256  ; g_EP0_BufferAddr
00012e  e001              B        |L8.308|
                  |L8.304|
000130  e006              B        |L8.320|
                  |L8.306|
000132  e02a              B        |L8.394|
                  |L8.308|
000134  81b9              STRH     r1,[r7,#0xc]          ;2256
000136  e8bd41f0          POP      {r4-r8,lr}            ;2259
00013a  2000              MOVS     r0,#0                 ;2259
00013c  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.320|
000140  4d43              LDR      r5,|L8.592|
000142  f04f0c09          MOV      r12,#9                ;2276
000146  4628              MOV      r0,r5                 ;2276
000148  2621              MOVS     r6,#0x21              ;2277
00014a  f880c000          STRB     r12,[r0,#0]           ;2276
00014e  7046              STRB     r6,[r0,#1]            ;2277
000150  f2401611          MOV      r6,#0x111             ;2278
000154  8046              STRH     r6,[r0,#2]            ;2278
000156  7102              STRB     r2,[r0,#4]            ;2279
000158  7144              STRB     r4,[r0,#5]            ;2280
00015a  2222              MOVS     r2,#0x22              ;2281
00015c  7182              STRB     r2,[r0,#6]            ;2281
00015e  8889              LDRH     r1,[r1,#4]            ;2283
000160  2900              CMP      r1,#0                 ;2283
000162  bf04              ITT      EQ                    ;2299
000164  f24021cd          MOVEQ    r1,#0x2cd             ;2299
000168  f8a01007          STRHEQ   r1,[r0,#7]            ;2299
00016c  d003              BEQ      |L8.374|
00016e  2901              CMP      r1,#1                 ;2283
000170  bf08              IT       EQ                    ;2308
000172  f8a03007          STRHEQ   r3,[r0,#7]            ;2308
                  |L8.374|
000176  6a78              LDR      r0,[r7,#0x24]         ;2323  ; g_EP0_Offset
000178  4428              ADD      r0,r0,r5              ;2323
00017a  6238              STR      r0,[r7,#0x20]         ;2324  ; g_EP0_BufferAddr
00017c  f8a7c00c          STRH     r12,[r7,#0xc]         ;2324
000180  e8bd41f0          POP      {r4-r8,lr}            ;2327
000184  2000              MOVS     r0,#0                 ;2327
000186  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.394|
00018a  8888              LDRH     r0,[r1,#4]            ;2334
00018c  b110              CBZ      r0,|L8.404|
00018e  2801              CMP      r0,#1                 ;2334
000190  d020              BEQ      |L8.468|
000192  e024              B        |L8.478|
                  |L8.404|
000194  4830              LDR      r0,|L8.600|
000196  4c2f              LDR      r4,|L8.596|
000198  2600              MOVS     r6,#0                 ;2340
00019a  6801              LDR      r1,[r0,#0]            ;2344  ; u8_HID_MultiTouch_Descriptor_Head
00019c  6021              STR      r1,[r4,#0]            ;2344
00019e  6840              LDR      r0,[r0,#4]            ;2344  ; u8_HID_MultiTouch_Descriptor_Head
0001a0  2508              MOVS     r5,#8                 ;2345
0001a2  6060              STR      r0,[r4,#4]            ;2345
                  |L8.420|
0001a4  1960              ADDS     r0,r4,r5              ;2354
0001a6  2240              MOVS     r2,#0x40              ;2354
0001a8  492c              LDR      r1,|L8.604|
0001aa  f7fffffe          BL       __aeabi_memcpy
0001ae  f1050040          ADD      r0,r5,#0x40           ;2355
0001b2  b285              UXTH     r5,r0                 ;2355
0001b4  1c70              ADDS     r0,r6,#1              ;2355
0001b6  b2c6              UXTB     r6,r0                 ;2355
0001b8  2e0a              CMP      r6,#0xa               ;2355
0001ba  d3f3              BCC      |L8.420|
0001bc  1960              ADDS     r0,r4,r5              ;2359
0001be  2245              MOVS     r2,#0x45              ;2359
0001c0  4927              LDR      r1,|L8.608|
0001c2  f7fffffe          BL       __aeabi_memcpy
0001c6  6a79              LDR      r1,[r7,#0x24]         ;2363  ; g_EP0_Offset
0001c8  f1050045          ADD      r0,r5,#0x45           ;2360
0001cc  4421              ADD      r1,r1,r4              ;2363
0001ce  6239              STR      r1,[r7,#0x20]         ;2364  ; g_EP0_BufferAddr
0001d0  81b8              STRH     r0,[r7,#0xc]          ;2364
0001d2  e004              B        |L8.478|
                  |L8.468|
0001d4  4823              LDR      r0,|L8.612|
0001d6  6a79              LDR      r1,[r7,#0x24]         ;2373  ; g_EP0_Offset
0001d8  4408              ADD      r0,r0,r1              ;2373
0001da  6238              STR      r0,[r7,#0x20]         ;2374  ; g_EP0_BufferAddr
0001dc  81bb              STRH     r3,[r7,#0xc]          ;2374
                  |L8.478|
0001de  e8bd41f0          POP      {r4-r8,lr}            ;2391
0001e2  2000              MOVS     r0,#0                 ;2391
0001e4  f7ffbffe          B.W      EP0_TxRx_Proc
                  |L8.488|
0001e8  4a1f              LDR      r2,|L8.616|
0001ea  2105              MOVS     r1,#5                 ;2401
0001ec  4610              MOV      r0,r2                 ;2401
0001ee  2307              MOVS     r3,#7                 ;2405
0001f0  7001              STRB     r1,[r0,#0]            ;2401
0001f2  210f              MOVS     r1,#0xf               ;2402
0001f4  7041              STRB     r1,[r0,#1]            ;2402
0001f6  210c              MOVS     r1,#0xc               ;2403
0001f8  8041              STRH     r1,[r0,#2]            ;2403
0001fa  7104              STRB     r4,[r0,#4]            ;2404
0001fc  7143              STRB     r3,[r0,#5]            ;2405
0001fe  2310              MOVS     r3,#0x10              ;2406
000200  7183              STRB     r3,[r0,#6]            ;2406
000202  2302              MOVS     r3,#2                 ;2407
000204  71c3              STRB     r3,[r0,#7]            ;2407
000206  7a03              LDRB     r3,[r0,#8]            ;2408  ; BOS_Descriptor
000208  f043031e          ORR      r3,r3,#0x1e           ;2411
00020c  7203              STRB     r3,[r0,#8]            ;2411
00020e  7a43              LDRB     r3,[r0,#9]            ;2412  ; BOS_Descriptor
000210  f023030f          BIC      r3,r3,#0xf            ;2412
000214  330a              ADDS     r3,r3,#0xa            ;2412
000216  f02303f0          BIC      r3,r3,#0xf0           ;2413
00021a  33b0              ADDS     r3,r3,#0xb0           ;2413
00021c  7243              STRB     r3,[r0,#9]            ;2413
00021e  6a78              LDR      r0,[r7,#0x24]         ;2415  ; g_EP0_Offset
000220  4410              ADD      r0,r0,r2              ;2415
000222  6238              STR      r0,[r7,#0x20]         ;2416  ; g_EP0_BufferAddr
000224  81b9              STRH     r1,[r7,#0xc]          ;2416
000226  e8bd41f0          POP      {r4-r8,lr}            ;2417
00022a  2000              MOVS     r0,#0                 ;2417
00022c  f7ffbffe          B.W      EP0_TxRx_Proc
;;;2434   
                          ENDP

                  |L8.560|
                          DCD      ||.data||
                  |L8.564|
                          DCD      u8_FS_DeviceDesc
                  |L8.568|
                          DCD      u8_FS_ConfigDesc
                  |L8.572|
                          DCD      0x40030000
                  |L8.576|
                          DCD      u8O_StrDesc_LangIDs
                  |L8.580|
                          DCD      u8O_StrDesc_Product
                  |L8.584|
                          DCD      u8O_StrDesc_Manufacturer
                  |L8.588|
                          DCD      MS_OS_Descriptor
                  |L8.592|
                          DCD      ||.bss||+0x111
                  |L8.596|
                          DCD      ||.bss||+0x2528
                  |L8.600|
                          DCD      u8_HID_MultiTouch_Descriptor_Head
                  |L8.604|
                          DCD      u8_HID_MultiTouch_Descriptor_Main
                  |L8.608|
                          DCD      u8_HID_MultiTouch_Descriptor_Tail
                  |L8.612|
                          DCD      u8_HID_Custom_Descriptor
                  |L8.616|
                          DCD      BOS_Descriptor

                          AREA ||i.EP0_TxRx_Proc||, CODE, READONLY, ALIGN=2

                  EP0_TxRx_Proc PROC
;;;2120   
;;;2121   void EP0_TxRx_Proc(uint8_t Dirction)
000000  4b1d              LDR      r3,|L9.120|
;;;2122   {
;;;2123   	uint16_t wLength = 0;
;;;2124   
;;;2125   	// Ã³= Õ¥LÆØ¦ Ã³Ø®ÈÕ‚ Ñ¦à ¬
;;;2126   	if (g_EP0_Remain == 0)
000002  461a              MOV      r2,r3
000004  6a99              LDR      r1,[r3,#0x28]         ;2122  ; g_EP0_Remain
;;;2127   	{
;;;2128   		if (g_pSetupPacket->wLength >= g_EP0_BufferLength)
000006  8992              LDRH     r2,[r2,#0xc]
000008  b121              CBZ      r1,|L9.20|
;;;2129   		{
;;;2130   			wLength = (g_EP0_BufferLength >= MX_PA_SZ_64) ? MX_PA_SZ_64 : g_EP0_BufferLength;
;;;2131   		}
;;;2132   		else
;;;2133   		{
;;;2134   			wLength = g_pSetupPacket->wLength;
;;;2135   		}
;;;2136   	}
;;;2137   	// Lß®Ü­ Õ¥LÆØ¦ Ã³Ø®ÈÕ‚ Ñ¦à ¬
;;;2138   	else
;;;2139   	{
;;;2140   		if (g_EP0_Remain >= MX_PA_SZ_64)
00000a  2940              CMP      r1,#0x40
;;;2141   		{
;;;2142   			wLength = MX_PA_SZ_64;
;;;2143   		}
;;;2144   		else
;;;2145   		{
;;;2146   			wLength = g_EP0_Remain;
00000c  bf38              IT       CC
00000e  b289              UXTHCC   r1,r1
000010  d208              BCS      |L9.36|
000012  e008              B        |L9.38|
                  |L9.20|
000014  69d9              LDR      r1,[r3,#0x1c]         ;2128  ; g_pSetupPacket
000016  88c9              LDRH     r1,[r1,#6]            ;2128
000018  4291              CMP      r1,r2                 ;2128
00001a  d304              BCC      |L9.38|
00001c  2a40              CMP      r2,#0x40              ;2130
00001e  bf38              IT       CC                    ;2130
000020  4611              MOVCC    r1,r2                 ;2130
000022  d300              BCC      |L9.38|
                  |L9.36|
000024  2140              MOVS     r1,#0x40              ;2130
                  |L9.38|
;;;2147   		}
;;;2148   	}
;;;2149   
;;;2150   	
;;;2151   
;;;2152   	g_EP0_Offset += wLength;
000026  f8d3c024          LDR      r12,[r3,#0x24]  ; g_EP0_Offset
00002a  448c              ADD      r12,r12,r1
;;;2153   	g_EP0_Remain = g_EP0_BufferLength - g_EP0_Offset;
00002c  eba2020c          SUB      r2,r2,r12
;;;2154   	g_EP0_Check = 1;
000030  f8c3c024          STR      r12,[r3,#0x24]  ; g_EP0_Offset
000034  629a              STR      r2,[r3,#0x28]  ; g_EP0_Remain
000036  2201              MOVS     r2,#1
000038  715a              STRB     r2,[r3,#5]
;;;2155   
;;;2156   	// Virtual DMA
;;;2157   	mUsbCXIntDmaErrEn();
00003a  4a10              LDR      r2,|L9.124|
00003c  f8d2c32c          LDR      r12,[r2,#0x32c]
000040  f42c3c80          BIC      r12,r12,#0x10000
000044  f8c2c32c          STR      r12,[r2,#0x32c]
;;;2158   	mUsbCXIntDmaFinishEn();
000048  f8d2c32c          LDR      r12,[r2,#0x32c]
00004c  f02c0c01          BIC      r12,r12,#1
000050  f8c2c32c          STR      r12,[r2,#0x32c]
;;;2159   
;;;2160   	mUsbCXDmaConfig(wLength, Dirction);
000054  0209              LSLS     r1,r1,#8
000056  f1c00001          RSB      r0,r0,#1
00005a  ea410040          ORR      r0,r1,r0,LSL #1
00005e  f8c20300          STR      r0,[r2,#0x300]
;;;2161   	mUsbCXDmaAddr((uint32_t)g_EP0_BufferAddr);
000062  6a18              LDR      r0,[r3,#0x20]  ; g_EP0_BufferAddr
000064  f8c20304          STR      r0,[r2,#0x304]
;;;2162   	mUsbCXDmaStart();
000068  f8d20300          LDR      r0,[r2,#0x300]
00006c  f0400001          ORR      r0,r0,#1
000070  f8c20300          STR      r0,[r2,#0x300]
;;;2163   	return;
;;;2164   }
000074  4770              BX       lr
;;;2165   
                          ENDP

000076  0000              DCW      0x0000
                  |L9.120|
                          DCD      ||.data||
                  |L9.124|
                          DCD      0x40030000

                          AREA ||i.GetScanTime||, CODE, READONLY, ALIGN=2

                  GetScanTime PROC
;;;550    
;;;551    uint16_t GetScanTime(uint64_t* StartTime, uint32_t* ScanTime)
000000  b570              PUSH     {r4-r6,lr}
;;;552    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  e9d60100          LDRD     r0,r1,[r6,#0]
00000a  2400              MOVS     r4,#0
;;;553    	uint16_t Temp = 0;
;;;554    
;;;555    	if (*StartTime == 0)
00000c  ea500201          ORRS     r2,r0,r1
000010  d00e              BEQ      |L10.48|
;;;556    	{
;;;557    		goto GETSCANTIME__GOTO_END;
;;;558    	}
;;;559    
;;;560    	// getLongSysTick() È”Ý¶Ø¦ Æ«È˜Ü­ Ñ¸È‘ Ðª: Ñ¨Ý“ [ß†Â¸Õ™.
;;;561    	// OÚ{N Tick Count à Õ‚ Õ™Ø¥ Ö­...
;;;562    	Temp = (uint16_t)(getElapsedUS(*StartTime) / 100);
000012  f7fffffe          BL       getElapsedLongSYSTICK
000016  4a0f              LDR      r2,|L10.84|
000018  6812              LDR      r2,[r2,#0]  ; _core_clock_
00001a  4623              MOV      r3,r4
00001c  f7fffffe          BL       __aeabi_uldivmod
000020  2264              MOVS     r2,#0x64
000022  2300              MOVS     r3,#0
000024  f7fffffe          BL       __aeabi_uldivmod
;;;563    	*ScanTime += Temp;
000028  6829              LDR      r1,[r5,#0]
00002a  b280              UXTH     r0,r0                 ;562
00002c  4408              ADD      r0,r0,r1
00002e  6028              STR      r0,[r5,#0]
                  |L10.48|
;;;564    
;;;565    GETSCANTIME__GOTO_END:
;;;566    
;;;567    	*StartTime = (uint64_t)getLongSysTick();
000030  4809              LDR      r0,|L10.88|
000032  6800              LDR      r0,[r0,#0]  ; _systick_high_rank_count_
000034  0422              LSLS     r2,r4,#16
000036  ea424110          ORR      r1,r2,r0,LSR #16
00003a  0402              LSLS     r2,r0,#16
00003c  f04f20e0          MOV      r0,#0xe000e000
000040  6980              LDR      r0,[r0,#0x18]
000042  b280              UXTH     r0,r0
000044  4310              ORRS     r0,r0,r2
000046  4321              ORRS     r1,r1,r4
000048  e9c60100          STRD     r0,r1,[r6,#0]
;;;568    	return *ScanTime;
00004c  8828              LDRH     r0,[r5,#0]
00004e  b280              UXTH     r0,r0
;;;569    }
000050  bd70              POP      {r4-r6,pc}
;;;570    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      _core_clock_
                  |L10.88|
                          DCD      _systick_high_rank_count_

                          AREA ||i.HidReadWrite_MNT_Test||, CODE, READONLY, ALIGN=2

                  HidReadWrite_MNT_Test PROC
;;;1206   
;;;1207   void HidReadWrite_MNT_Test(PMNT_HID_TEST_STRUCT pOutBuffer)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1208   {
000004  4607              MOV      r7,r0
;;;1209   	uint32_t i,j;
;;;1210   	uint8_t * pDataBuf;
;;;1211   	uint8_t bSendUSB = FALSE;
;;;1212   	uint16_t nLength = 0;
;;;1213   	uint32_t nRemainLength = 0;
;;;1214   	uint32_t nSendLength = 0;
;;;1215   	uint8_t nLoopCnt = 0;
;;;1216   
;;;1217   	if(pOutBuffer->ReadWrtie == 0x02 || pOutBuffer->ReadWrtie == 0x00)
000006  7840              LDRB     r0,[r0,#1]
000008  2600              MOVS     r6,#0                 ;1211
00000a  b083              SUB      sp,sp,#0xc            ;1208
00000c  2802              CMP      r0,#2
00000e  bf14              ITE      NE
000010  2800              CMPNE    r0,#0
;;;1218   	{
;;;1219   		bSendUSB = TRUE;
000012  2601              MOVEQ    r6,#1
;;;1220   	}
;;;1221   
;;;1222   	nLength = pOutBuffer->Length;
000014  88b8              LDRH     r0,[r7,#4]
;;;1223   	usRegAddr = pOutBuffer->Address;
000016  4c82              LDR      r4,|L11.544|
000018  9000              STR      r0,[sp,#0]
00001a  8878              LDRH     r0,[r7,#2]
00001c  8260              STRH     r0,[r4,#0x12]
;;;1224   
;;;1225   	pDataBuf = &pOutBuffer->Data[0];
;;;1226   //	MNT_HID_Mapping_handler(pOutBuffer);
;;;1227   
;;;1228   	/*
;;;1229   	 * Address matching
;;;1230   	 */
;;;1231   	if (protocol_GetMappedPointer != NULL)
00001e  4881              LDR      r0,|L11.548|
000020  f1070506          ADD      r5,r7,#6              ;1225
000024  6801              LDR      r1,[r0,#0]            ;1208  ; protocol_GetMappedPointer
000026  2900              CMP      r1,#0                 ;1208
;;;1232   	{
;;;1233   		ulDebugIndex++;
;;;1234   		if(ulDebugIndex > 99)
;;;1235   			ulDebugIndex = 99;
;;;1236   		if(usRegAddr == 0x0600 && tDebug[ulDebugIndex-1].ulAddr == 0x0600)
;;;1237   		{
;;;1238   			ulDebugIndex--;
;;;1239   		}
;;;1240   		tDebug[ulDebugIndex].ulAddr = usRegAddr;
;;;1241   
;;;1242   		rmi_read_ptr = rmi_write_ptr = (*protocol_GetMappedPointer)(usRegAddr);
;;;1243   		usb_sent_byte = usb_received_byte = 0;
;;;1244   
;;;1245   		/*
;;;1246   		 * read, write êµ¬ë¶„
;;;1247   		 */
;;;1248   		if(bSendUSB)
;;;1249   		{
;;;1250   			if(rmi_read_ptr != NULL)
;;;1251   			{
;;;1252   				tDebug[ulDebugIndex].ulRW = 0;
;;;1253   				/*
;;;1254   				 * read functionêµ¬í˜„
;;;1255   				 */
;;;1256   				tDebug[ulDebugIndex].length = nLength;
;;;1257   				nLoopCnt = ((nLength - 1) / 58) + 1;
;;;1258   //				memset(pDataBuf, 0, sizeof(pDataBuf));
;;;1259   
;;;1260   				for(j = 0; j < nLoopCnt; ++j)
;;;1261   				{
;;;1262   					nRemainLength = nLength - (58 * j);
;;;1263   					nSendLength = ((nRemainLength > 58) ? 58 : nRemainLength);
;;;1264   					pDataBuf = &pOutBuffer->Data[0];
;;;1265   					for(i = 0; i < nSendLength; i++)
;;;1266   					{
;;;1267   						tDebug[ulDebugIndex].data[usb_sent_byte] = *(rmi_read_ptr);
;;;1268   
;;;1269   						*(pDataBuf++) = *(rmi_read_ptr++);
;;;1270   						if(protocol_ClearInterrupt != NULL)
;;;1271   						{
;;;1272   							(*protocol_ClearInterrupt)(usRegAddr + usb_sent_byte);
;;;1273   						}
;;;1274   						usb_sent_byte++;
;;;1275   					}
;;;1276   
;;;1277   					pOutBuffer->ReportID = HID_REPORT_ID__CUSTOM_IN;
;;;1278   
;;;1279   					if(j+1 >= nLoopCnt)
;;;1280   					{
;;;1281   						pOutBuffer->ReadWrtie = 0x02;
;;;1282   					}
;;;1283   					else
;;;1284   					{
;;;1285   						pOutBuffer->ReadWrtie = 0x00;
;;;1286   					}
;;;1287   					// Send
;;;1288   					SendCustomData_USB((uint8_t*)pOutBuffer);
;;;1289   				}
;;;1290   
;;;1291   //				if(pOutBuffer->Address == 0x2000)
;;;1292   //				{
;;;1293   //					pOutBuffer->ReadWrtie = 0x00;
;;;1294   //					pOutBuffer->Length = 58;
;;;1295   //					SendCustomData_USB((uint8_t*)pOutBuffer);
;;;1296   //
;;;1297   //					pOutBuffer->ReadWrtie = 0x00;
;;;1298   //					pOutBuffer->Length = 58;
;;;1299   //					SendCustomData_USB((uint8_t*)pOutBuffer);
;;;1300   //
;;;1301   //					pOutBuffer->ReadWrtie = 0x02;
;;;1302   //					pOutBuffer->Length = 44;
;;;1303   //					SendCustomData_USB((uint8_t*)pOutBuffer);
;;;1304   //				}
;;;1305   			}
;;;1306   		}
;;;1307   		else
;;;1308   		{
;;;1309   			if(rmi_write_ptr != NULL)
;;;1310   			{
;;;1311   				tDebug[ulDebugIndex].ulRW = 1;
;;;1312   
;;;1313   				/*
;;;1314   				 * write functionêµ¬í˜„
;;;1315   				 */
;;;1316   				tDebug[ulDebugIndex].length = nLength;
;;;1317   				for(i=0; i<nLength; i++)
;;;1318   				{
;;;1319   					tDebug[ulDebugIndex].data[usb_received_byte] = *(pDataBuf);
;;;1320   
;;;1321   					*(rmi_write_ptr++) = *(pDataBuf++);
;;;1322   					usb_received_byte++;
;;;1323   				}
;;;1324   			}
;;;1325   		}
;;;1326   	}
;;;1327   
;;;1328   //	switch(pOutBuffer->Address)
;;;1329   //	{
;;;1330   //		case 0x0A00:
;;;1331   //		{
;;;1332   //			MNT_HID_Mapping_handler()
;;;1333   //			TempData[0] = 11;
;;;1334   //			TempData[1] = 22;
;;;1335   //			break;
;;;1336   //		}
;;;1337   //
;;;1338   //		default:
;;;1339   //		{
;;;1340   //			break;
;;;1341   //		}
;;;1342   //
;;;1343   //	}
;;;1344   //	if(bSendUSB == TRUE)
;;;1345   //	{
;;;1346   //		pOutBuffer->ReportID = HID_REPORT_ID__CUSTOM_IN;
;;;1347   //		memcpy(pOutBuffer->Data, TempData, nLength);
;;;1348   //
;;;1349   //		// Send
;;;1350   //		SendCustomData_USB((uint8_t*)pOutBuffer);
;;;1351   //	}
;;;1352   }
000028  bf04              ITT      EQ
00002a  b003              ADDEQ    sp,sp,#0xc
00002c  e8bd8ff0          POPEQ    {r4-r11,pc}
000030  6e20              LDR      r0,[r4,#0x60]         ;1233  ; ulDebugIndex
000032  f1000001          ADD      r0,r0,#1              ;1233
000036  6620              STR      r0,[r4,#0x60]         ;1235  ; ulDebugIndex
000038  2863              CMP      r0,#0x63              ;1235
00003a  f20080ed          BHI.W    |L11.536|
                  |L11.62|
00003e  8a60              LDRH     r0,[r4,#0x12]         ;1236  ; usRegAddr
000040  f8df91e4          LDR      r9,|L11.552|
000044  f5b06fc0          CMP      r0,#0x600             ;1236
000048  d10d              BNE      |L11.102|
00004a  6e20              LDR      r0,[r4,#0x60]         ;1236  ; ulDebugIndex
00004c  ebc002c0          RSB      r2,r0,r0,LSL #3       ;1236
000050  eb020282          ADD      r2,r2,r2,LSL #2       ;1236
000054  eb090242          ADD      r2,r9,r2,LSL #1       ;1236
000058  f8322c46          LDRH     r2,[r2,#-0x46]        ;1236
00005c  f5b26fc0          CMP      r2,#0x600             ;1236
000060  bf04              ITT      EQ                    ;1236
000062  1e40              SUBEQ    r0,r0,#1              ;1236
000064  6620              STREQ    r0,[r4,#0x60]         ;1238  ; ulDebugIndex
                  |L11.102|
000066  8a60              LDRH     r0,[r4,#0x12]         ;1240  ; usRegAddr
000068  6e22              LDR      r2,[r4,#0x60]         ;1240  ; ulDebugIndex
00006a  ebc202c2          RSB      r2,r2,r2,LSL #3       ;1240
00006e  eb020282          ADD      r2,r2,r2,LSL #2       ;1240
000072  f8290012          STRH     r0,[r9,r2,LSL #1]     ;1240
000076  8a60              LDRH     r0,[r4,#0x12]         ;1242  ; usRegAddr
000078  4788              BLX      r1                    ;1242
00007a  65e0              STR      r0,[r4,#0x5c]         ;1242  ; rmi_write_ptr
00007c  2300              MOVS     r3,#0                 ;1243
00007e  65a0              STR      r0,[r4,#0x58]         ;1243  ; rmi_read_ptr
000080  82e3              STRH     r3,[r4,#0x16]         ;1243
000082  2201              MOVS     r2,#1                 ;1219
000084  82a3              STRH     r3,[r4,#0x14]         ;1243
000086  2e00              CMP      r6,#0                 ;1248
000088  d07e              BEQ      |L11.392|
00008a  2800              CMP      r0,#0                 ;1250
00008c  bf04              ITT      EQ
00008e  b003              ADDEQ    sp,sp,#0xc
000090  e8bd8ff0          POPEQ    {r4-r11,pc}
000094  4619              MOV      r1,r3                 ;1252
000096  6e20              LDR      r0,[r4,#0x60]         ;1252  ; ulDebugIndex
000098  f04f0a00          MOV      r10,#0                ;1260
00009c  ebc000c0          RSB      r0,r0,r0,LSL #3       ;1252
0000a0  eb000080          ADD      r0,r0,r0,LSL #2       ;1252
0000a4  eb090040          ADD      r0,r9,r0,LSL #1       ;1252
0000a8  8043              STRH     r3,[r0,#2]            ;1252
0000aa  f8ddc000          LDR      r12,[sp,#0]           ;1256
0000ae  f8a0c044          STRH     r12,[r0,#0x44]        ;1256
0000b2  9800              LDR      r0,[sp,#0]            ;1257
0000b4  f8dfc174          LDR      r12,|L11.556|
0000b8  1e40              SUBS     r0,r0,#1              ;1257
0000ba  fbcc1000          SMLAL    r1,r0,r12,r0          ;1257
0000be  1141              ASRS     r1,r0,#5              ;1257
0000c0  eba170e0          SUB      r0,r1,r0,ASR #31      ;1257
0000c4  1c40              ADDS     r0,r0,#1              ;1257
0000c6  f01000ff          ANDS     r0,r0,#0xff           ;1257
0000ca  9001              STR      r0,[sp,#4]            ;1260
0000cc  bf12              ITEE     NE                    ;1270
0000ce  f8dfb160          LDRNE    r11,|L11.560|
0000d2  b003              ADDEQ    sp,sp,#0xc
0000d4  e8bd8ff0          POPEQ    {r4-r11,pc}
                  |L11.216|
0000d8  f06f001c          MVN      r0,#0x1c              ;1262
0000dc  fb0af100          MUL      r1,r10,r0             ;1262
0000e0  9800              LDR      r0,[sp,#0]            ;1262
0000e2  eb000841          ADD      r8,r0,r1,LSL #1       ;1262
0000e6  f1b80f3a          CMP      r8,#0x3a              ;1263
0000ea  bf88              IT       HI                    ;1263
0000ec  f04f083a          MOVHI    r8,#0x3a              ;1263
0000f0  1dbd              ADDS     r5,r7,#6              ;1264
0000f2  2600              MOVS     r6,#0                 ;1265
0000f4  f1b80f00          CMP      r8,#0                 ;1265
0000f8  d91d              BLS      |L11.310|
                  |L11.250|
0000fa  6da0              LDR      r0,[r4,#0x58]         ;1267  ; rmi_read_ptr
0000fc  7802              LDRB     r2,[r0,#0]            ;1267
0000fe  6e21              LDR      r1,[r4,#0x60]         ;1267  ; ulDebugIndex
000100  ebc101c1          RSB      r1,r1,r1,LSL #3       ;1267
000104  eb010181          ADD      r1,r1,r1,LSL #2       ;1267
000108  eb090341          ADD      r3,r9,r1,LSL #1       ;1267
00010c  8aa1              LDRH     r1,[r4,#0x14]         ;1267  ; usb_sent_byte
00010e  440b              ADD      r3,r3,r1              ;1267
000110  711a              STRB     r2,[r3,#4]            ;1267
000112  f8102b01          LDRB     r2,[r0],#1            ;1269
000116  f8052b01          STRB     r2,[r5],#1            ;1269
00011a  65a0              STR      r0,[r4,#0x58]         ;1270  ; rmi_read_ptr
00011c  f8db2000          LDR      r2,[r11,#0]           ;1270  ; protocol_ClearInterrupt
000120  b11a              CBZ      r2,|L11.298|
000122  8a60              LDRH     r0,[r4,#0x12]         ;1272  ; usRegAddr
000124  4408              ADD      r0,r0,r1              ;1272
000126  b280              UXTH     r0,r0                 ;1272
000128  4790              BLX      r2                    ;1272
                  |L11.298|
00012a  8aa0              LDRH     r0,[r4,#0x14]         ;1274  ; usb_sent_byte
00012c  1c76              ADDS     r6,r6,#1              ;1274
00012e  1c40              ADDS     r0,r0,#1              ;1274
000130  82a0              STRH     r0,[r4,#0x14]         ;1274
000132  4546              CMP      r6,r8                 ;1274
000134  d3e1              BCC      |L11.250|
                  |L11.310|
000136  200a              MOVS     r0,#0xa               ;1277
000138  7038              STRB     r0,[r7,#0]            ;1277
00013a  9801              LDR      r0,[sp,#4]            ;1279
00013c  f10a0101          ADD      r1,r10,#1             ;1279
000140  4288              CMP      r0,r1                 ;1279
000142  bf94              ITE      LS                    ;1281
000144  2002              MOVLS    r0,#2                 ;1281
000146  2000              MOVHI    r0,#0                 ;1285
000148  7078              STRB     r0,[r7,#1]            ;1285
00014a  483a              LDR      r0,|L11.564|
00014c  4639              MOV      r1,r7                 ;1288
00014e  f8d007c2          LDR      r0,[r0,#0x7c2]        ;1288
000152  281e              CMP      r0,#0x1e              ;1288
000154  d223              BCS      |L11.414|
000156  4d37              LDR      r5,|L11.564|
000158  b309              CBZ      r1,|L11.414|
00015a  2001              MOVS     r0,#1                 ;1279
00015c  f88507c6          STRB     r0,[r5,#0x7c6]        ;1279
000160  f89507c0          LDRB     r0,[r5,#0x7c0]        ;1279
000164  2242              MOVS     r2,#0x42              ;1279
000166  eb001040          ADD      r0,r0,r0,LSL #5       ;1279
00016a  eb050040          ADD      r0,r5,r0,LSL #1       ;1279
00016e  1d00              ADDS     r0,r0,#4              ;1279
000170  f7fffffe          BL       __aeabi_memcpy
000174  f8d507c2          LDR      r0,[r5,#0x7c2]        ;1279
000178  1c40              ADDS     r0,r0,#1              ;1279
00017a  f8c507c2          STR      r0,[r5,#0x7c2]        ;1279
00017e  f89507c0          LDRB     r0,[r5,#0x7c0]        ;1279
000182  1c40              ADDS     r0,r0,#1              ;1279
000184  b2c0              UXTB     r0,r0                 ;1279
000186  e000              B        |L11.394|
                  |L11.392|
000188  e011              B        |L11.430|
                  |L11.394|
00018a  f88507c0          STRB     r0,[r5,#0x7c0]        ;1279
00018e  281e              CMP      r0,#0x1e              ;1279
000190  bf24              ITT      CS                    ;1279
000192  2000              MOVCS    r0,#0                 ;1279
000194  f88507c0          STRBCS   r0,[r5,#0x7c0]        ;1279
000198  2000              MOVS     r0,#0                 ;1279
00019a  f88507c6          STRB     r0,[r5,#0x7c6]        ;1279
                  |L11.414|
00019e  9801              LDR      r0,[sp,#4]            ;1288
0001a0  f10a0a01          ADD      r10,r10,#1            ;1288
0001a4  4582              CMP      r10,r0                ;1288
0001a6  d397              BCC      |L11.216|
0001a8  b003              ADD      sp,sp,#0xc
0001aa  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.430|
0001ae  2800              CMP      r0,#0                 ;1309
0001b0  bf04              ITT      EQ
0001b2  b003              ADDEQ    sp,sp,#0xc
0001b4  e8bd8ff0          POPEQ    {r4-r11,pc}
0001b8  6e21              LDR      r1,[r4,#0x60]         ;1311  ; ulDebugIndex
0001ba  ebc101c1          RSB      r1,r1,r1,LSL #3       ;1311
0001be  eb010181          ADD      r1,r1,r1,LSL #2       ;1311
0001c2  eb090141          ADD      r1,r9,r1,LSL #1       ;1311
0001c6  804a              STRH     r2,[r1,#2]            ;1311
0001c8  9a00              LDR      r2,[sp,#0]            ;1316
0001ca  f8a12044          STRH     r2,[r1,#0x44]         ;1316
0001ce  9900              LDR      r1,[sp,#0]            ;1317
0001d0  2900              CMP      r1,#0                 ;1317
0001d2  bf18              IT       NE                    ;1317
0001d4  2200              MOVNE    r2,#0                 ;1317
0001d6  bf8e              ITEE     HI                    ;1317
0001d8  4601              MOVHI    r1,r0                 ;1317
0001da  b003              ADDLS    sp,sp,#0xc
0001dc  e8bd8ff0          POPLS    {r4-r11,pc}
                  |L11.480|
0001e0  782b              LDRB     r3,[r5,#0]            ;1319
0001e2  6e20              LDR      r0,[r4,#0x60]         ;1319  ; ulDebugIndex
0001e4  ebc000c0          RSB      r0,r0,r0,LSL #3       ;1319
0001e8  eb000080          ADD      r0,r0,r0,LSL #2       ;1319
0001ec  eb090c40          ADD      r12,r9,r0,LSL #1      ;1319
0001f0  8ae0              LDRH     r0,[r4,#0x16]         ;1319  ; usb_received_byte
0001f2  4484              ADD      r12,r12,r0            ;1319
0001f4  f88c3004          STRB     r3,[r12,#4]           ;1319
0001f8  f8153b01          LDRB     r3,[r5],#1            ;1321
0001fc  f8013b01          STRB     r3,[r1],#1            ;1321
000200  f1000001          ADD      r0,r0,#1              ;1321
000204  82e0              STRH     r0,[r4,#0x16]         ;1322
000206  9800              LDR      r0,[sp,#0]            ;1322
000208  f1020201          ADD      r2,r2,#1              ;1322
00020c  4290              CMP      r0,r2                 ;1322
00020e  d8e7              BHI      |L11.480|
000210  65e1              STR      r1,[r4,#0x5c]         ;1321  ; rmi_write_ptr
000212  b003              ADD      sp,sp,#0xc
000214  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.536|
000218  2063              MOVS     r0,#0x63              ;1235
00021a  6620              STR      r0,[r4,#0x60]         ;1235  ; ulDebugIndex
00021c  e70f              B        |L11.62|
;;;1353   
                          ENDP

00021e  0000              DCW      0x0000
                  |L11.544|
                          DCD      ||.data||
                  |L11.548|
                          DCD      protocol_GetMappedPointer
                  |L11.552|
                          DCD      ||.bss||+0x9d0
                  |L11.556|
                          DCD      0x8d3dcb09
                  |L11.560|
                          DCD      protocol_ClearInterrupt
                  |L11.564|
                          DCD      ||.bss||+0x208

                          AREA ||i.HidReadWrite__Read||, CODE, READONLY, ALIGN=2

                  HidReadWrite__Read PROC
;;;1178   
;;;1179   void HidReadWrite__Read(PHJ_HID_CONTROL_STRUCT pOutBuffer)
000000  b570              PUSH     {r4-r6,lr}
;;;1180   {
000002  4604              MOV      r4,r0
;;;1181   	uint16_t	index = 0;
;;;1182   	uint16_t	test_InputOffset = 0;
;;;1183   
;;;1184   	pOutBuffer->PacketID = HID_REPORT_ID__CUSTOM_IN;
000004  200a              MOVS     r0,#0xa
000006  7020              STRB     r0,[r4,#0]
;;;1185   	pOutBuffer->DeviceID_b.addr = 0x34;
000008  7860              LDRB     r0,[r4,#1]
00000a  2600              MOVS     r6,#0                 ;1181
00000c  f02000fe          BIC      r0,r0,#0xfe
000010  3068              ADDS     r0,r0,#0x68
;;;1186   	pOutBuffer->DeviceID_b.bRead = TRUE;
000012  f0400001          ORR      r0,r0,#1
000016  7060              STRB     r0,[r4,#1]
000018  4635              MOV      r5,r6                 ;1182
;;;1187   //	pOutBuffer->Length = pOutBuffer->Length;
;;;1188   	
;;;1189   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_START, 0, 0, 0);
00001a  4633              MOV      r3,r6
00001c  4632              MOV      r2,r6
00001e  4631              MOV      r1,r6
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;1190   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH, 0, 0, 0);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  4619              MOV      r1,r3
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;1191   
;;;1192   	for (index = 0; index<pOutBuffer->Length; index++)
000032  8860              LDRH     r0,[r4,#2]
000034  2800              CMP      r0,#0
000036  d90f              BLS      |L12.88|
                  |L12.56|
;;;1193   	{
;;;1194   		pOutBuffer->Data[test_InputOffset++] = protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER, 0, I2C_SLAVE_FSM_STATUS_READ_END, 0);
000038  2300              MOVS     r3,#0
00003a  f44f6280          MOV      r2,#0x400
00003e  4619              MOV      r1,r3
000040  2003              MOVS     r0,#3
000042  f7fffffe          BL       protocol_hid_mapping_emul_handler
000046  1961              ADDS     r1,r4,r5
000048  7108              STRB     r0,[r1,#4]
00004a  1c68              ADDS     r0,r5,#1
00004c  b285              UXTH     r5,r0
00004e  1c70              ADDS     r0,r6,#1              ;1192
000050  b286              UXTH     r6,r0                 ;1192
000052  8860              LDRH     r0,[r4,#2]            ;1192
000054  42b0              CMP      r0,r6                 ;1192
000056  d8ef              BHI      |L12.56|
                  |L12.88|
;;;1195   	}
;;;1196   
;;;1197   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_STOP, 0, 0, 0);
000058  2300              MOVS     r3,#0
00005a  461a              MOV      r2,r3
00005c  4619              MOV      r1,r3
00005e  2002              MOVS     r0,#2
000060  f7fffffe          BL       protocol_hid_mapping_emul_handler
000064  4815              LDR      r0,|L12.188|
;;;1198   
;;;1199   #ifdef ADD_CUSTOM
;;;1200   	SendCustomData_USB((uint8_t*)pOutBuffer);
000066  4621              MOV      r1,r4
000068  f8d007c2          LDR      r0,[r0,#0x7c2]
00006c  281e              CMP      r0,#0x1e
;;;1201   #endif
;;;1202   	return;
;;;1203   }
00006e  bf28              IT       CS
000070  bd70              POPCS    {r4-r6,pc}
000072  4c12              LDR      r4,|L12.188|
000074  2900              CMP      r1,#0
000076  bf08              IT       EQ
000078  bd70              POPEQ    {r4-r6,pc}
00007a  2001              MOVS     r0,#1
00007c  f88407c6          STRB     r0,[r4,#0x7c6]
000080  f89407c0          LDRB     r0,[r4,#0x7c0]
000084  2242              MOVS     r2,#0x42
000086  eb001040          ADD      r0,r0,r0,LSL #5
00008a  eb040040          ADD      r0,r4,r0,LSL #1
00008e  1d00              ADDS     r0,r0,#4
000090  f7fffffe          BL       __aeabi_memcpy
000094  f8d407c2          LDR      r0,[r4,#0x7c2]
000098  2100              MOVS     r1,#0
00009a  1c40              ADDS     r0,r0,#1
00009c  f8c407c2          STR      r0,[r4,#0x7c2]
0000a0  f89407c0          LDRB     r0,[r4,#0x7c0]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  b2c0              UXTB     r0,r0
0000a8  f88407c0          STRB     r0,[r4,#0x7c0]
0000ac  281e              CMP      r0,#0x1e
0000ae  bf28              IT       CS
0000b0  f88417c0          STRBCS   r1,[r4,#0x7c0]
0000b4  f88417c6          STRB     r1,[r4,#0x7c6]
0000b8  bd70              POP      {r4-r6,pc}
;;;1204   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L12.188|
                          DCD      ||.bss||+0x208

                          AREA ||i.HidReadWrite__Read_I2C||, CODE, READONLY, ALIGN=1

                  HidReadWrite__Read_I2C PROC
;;;1357   
;;;1358   void HidReadWrite__Read_I2C(PHJ_HID_CONTROL_STRUCT_I2C pHidControl)
000000  b570              PUSH     {r4-r6,lr}
;;;1359   {
000002  4604              MOV      r4,r0
;;;1360   	uint16_t	index = 0;
;;;1361   	uint16_t	test_InputOffset = 0;
;;;1362   
;;;1363   	pHidControl->Data.PacketID = HID_REPORT_ID__CUSTOM_IN;
000004  200a              MOVS     r0,#0xa
000006  70a0              STRB     r0,[r4,#2]
;;;1364   	pHidControl->Data.DeviceID_b.addr = 0x34;
000008  78e0              LDRB     r0,[r4,#3]
00000a  2600              MOVS     r6,#0                 ;1360
00000c  f02000fe          BIC      r0,r0,#0xfe
000010  3068              ADDS     r0,r0,#0x68
;;;1365   	pHidControl->Data.DeviceID_b.bRead = TRUE;
000012  f0400001          ORR      r0,r0,#1
000016  70e0              STRB     r0,[r4,#3]
000018  4635              MOV      r5,r6                 ;1361
;;;1366   //	pHidControl->Data.Length = pHidControl->Data.Length;
;;;1367   
;;;1368   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_START, 0, 0, 0);
00001a  4633              MOV      r3,r6
00001c  4632              MOV      r2,r6
00001e  4631              MOV      r1,r6
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;1369   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH, 0, 0, 0);
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  4619              MOV      r1,r3
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;1370   
;;;1371   	for (index = 0; index < pHidControl->Data.Length; index++)
000032  88a0              LDRH     r0,[r4,#4]
000034  2800              CMP      r0,#0
000036  d90f              BLS      |L13.88|
                  |L13.56|
;;;1372   	{
;;;1373   		pHidControl->Data.Data[test_InputOffset++] = protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER, 0, I2C_SLAVE_FSM_STATUS_READ_END, 0);
000038  2300              MOVS     r3,#0
00003a  f44f6280          MOV      r2,#0x400
00003e  4619              MOV      r1,r3
000040  2003              MOVS     r0,#3
000042  f7fffffe          BL       protocol_hid_mapping_emul_handler
000046  1961              ADDS     r1,r4,r5
000048  7188              STRB     r0,[r1,#6]
00004a  1c68              ADDS     r0,r5,#1
00004c  b285              UXTH     r5,r0
00004e  1c70              ADDS     r0,r6,#1              ;1371
000050  b286              UXTH     r6,r0                 ;1371
000052  88a0              LDRH     r0,[r4,#4]            ;1371
000054  42b0              CMP      r0,r6                 ;1371
000056  d8ef              BHI      |L13.56|
                  |L13.88|
;;;1374   	}
;;;1375   
;;;1376   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_STOP, 0, 0, 0);
000058  2300              MOVS     r3,#0
00005a  461a              MOV      r2,r3
00005c  4619              MOV      r1,r3
00005e  2002              MOVS     r0,#2
000060  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;1377   
;;;1378   	// Send
;;;1379   	SendCustomData_I2C(pHidControl);
000064  4620              MOV      r0,r4
000066  e8bd4070          POP      {r4-r6,lr}
00006a  f7ffbffe          B.W      SendCustomData_I2C
;;;1380   	return;
;;;1381   }
;;;1382   
                          ENDP


                          AREA ||i.HidReadWrite__Write||, CODE, READONLY, ALIGN=1

                  HidReadWrite__Write PROC
;;;1383   
;;;1384   void HidReadWrite__Write(PHJ_HID_CONTROL_STRUCT pHidControl)
000000  b570              PUSH     {r4-r6,lr}
;;;1385   {
;;;1386   	uint16_t index = 0;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;1385
;;;1387   
;;;1388   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_START, 0, 0, 0);
000006  4623              MOV      r3,r4
000008  4622              MOV      r2,r4
00000a  4621              MOV      r1,r4
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;1389   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH, 0, 0, 0);
000012  2300              MOVS     r3,#0
000014  461a              MOV      r2,r3
000016  4619              MOV      r1,r3
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       protocol_hid_mapping_emul_handler
;;;1390   
;;;1391   	for (index = 0; index < pHidControl->Length; index++)
00001e  8868              LDRH     r0,[r5,#2]
000020  2800              CMP      r0,#0
000022  d90c              BLS      |L14.62|
                  |L14.36|
;;;1392   	{
;;;1393   		protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER, index + 1, I2C_SLAVE_FSM_STATUS_WRITE_ACK, pHidControl->Data[index]);
000024  1928              ADDS     r0,r5,r4
000026  1c64              ADDS     r4,r4,#1
000028  7903              LDRB     r3,[r0,#4]
00002a  b2a1              UXTH     r1,r4
00002c  f44f5280          MOV      r2,#0x1000
000030  2003              MOVS     r0,#3
000032  f7fffffe          BL       protocol_hid_mapping_emul_handler
000036  8868              LDRH     r0,[r5,#2]            ;1391
000038  b2a4              UXTH     r4,r4                 ;1391
00003a  42a0              CMP      r0,r4                 ;1391
00003c  d8f2              BHI      |L14.36|
                  |L14.62|
;;;1394   	}
;;;1395   
;;;1396   	protocol_hid_mapping_emul_handler(I2C_SLAVE_INTERRUPT_STATUS_STOP, 0, 0, 0);
00003e  2300              MOVS     r3,#0
000040  e8bd4070          POP      {r4-r6,lr}
000044  461a              MOV      r2,r3
000046  4619              MOV      r1,r3
000048  2002              MOVS     r0,#2
00004a  f7ffbffe          B.W      protocol_hid_mapping_emul_handler
;;;1397   	return;
;;;1398   }
;;;1399   
                          ENDP


                          AREA ||i.QueueCommonData_USB||, CODE, READONLY, ALIGN=2

                  QueueCommonData_USB PROC
;;;2020   
;;;2021   void QueueCommonData_USB(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2022   {
000004  4c3b              LDR      r4,|L15.244|
000006  7820              LDRB     r0,[r4,#0]  ; g_Configuration
;;;2023   #ifndef MODE_I2C
;;;2024   	uint8_t* pCheckID = NULL;
;;;2025   
;;;2026   	if ((CheckUsbConfig() == 0) || (CheckHIDReady() == 0) || (g_CXF_Done != CXF_STATUS__COMPLETE_DONE))
000008  2800              CMP      r0,#0
00000a  bf1a              ITTE     NE
00000c  7860              LDRBNE   r0,[r4,#1]  ; g_HIDReady
00000e  2800              CMPNE    r0,#0
;;;2027   	{
;;;2028   		goto QUEUECOMMONDATA_USB__GOTO_END;
;;;2029   	}
;;;2030   	
;;;2031   	if (g_RemoteWakeup == 1)
;;;2032   	{
;;;2033   		goto QUEUECOMMONDATA_USB__GOTO_END;
;;;2034   	}
;;;2035   
;;;2036   	if (StaticQueue_CheckEmpty(&g_Queue_Common) == 0)
;;;2037   	{
;;;2038   		pCheckID = StaticQueue_Get(&g_Queue_Common);
;;;2039   		switch (pCheckID[0])
;;;2040   		{
;;;2041   			case HID_REPORT_ID__MULTI_TOUCH:
;;;2042   			{
;;;2043   #ifdef ADD_TOUCH
;;;2044   				if ((g_CheckVDMAComplete_Touch == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;2045   				{
;;;2046   					// Pop
;;;2047   					if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Touch) == TRUE)
;;;2048   					{
;;;2049   						g_CheckVDMAComplete_Touch = DMA_NOT_READY;
;;;2050   						mUsbIntF1INEn(); // Touch IN
;;;2051   					}
;;;2052   				}
;;;2053   #endif
;;;2054   
;;;2055   			break;
;;;2056   		}
;;;2057   
;;;2058   			case HID_REPORT_ID__PEN:
;;;2059   			case HID_REPORT_ID__PEN_SECOND:
;;;2060   			{
;;;2061   #ifdef ADD_PEN
;;;2062   				if ((g_CheckVDMAComplete_Pen == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;2063   				{
;;;2064   					// Pop
;;;2065   					if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_Pen) == TRUE)
;;;2066   					{
;;;2067   						mUsbIntF3INEn(); // Pen IN
;;;2068   						g_CheckVDMAComplete_Pen = DMA_NOT_READY;
;;;2069   					}
;;;2070   				}
;;;2071   #endif
;;;2072   
;;;2073   				break;
;;;2074   			}
;;;2075   
;;;2076   			// Custom or Bulk
;;;2077   			case HID_REPORT_ID__CUSTOM_IN:
;;;2078   			default:
;;;2079   			{
;;;2080   #ifdef ADD_CUSTOM
;;;2081   				if ((g_CheckVDMAComplete_Custom == DMA_READY) && ((g_CXF_Done == CXF_STATUS__COMPLETE_DONE)))
;;;2082   				{
;;;2083   					// Pop
;;;2084   					if (StaticQueue_Pop(&g_Queue_Common, (uint8_t*)&g_CustomBuffer) == TRUE)
;;;2085   					{
;;;2086   						g_CheckVDMAComplete_Custom = DMA_NOT_READY;
;;;2087   						mUsbIntF0INEn(); // Custom IN
;;;2088   
;;;2089   					}
;;;2090   				}
;;;2091   #endif
;;;2092   
;;;2093   				break;
;;;2094   			}
;;;2095   		}
;;;2096   	}
;;;2097   
;;;2098   QUEUECOMMONDATA_USB__GOTO_END:
;;;2099   
;;;2100   #endif
;;;2101   	return;
;;;2102   }
000010  e8bd81f0          POPEQ    {r4-r8,pc}
000014  78a0              LDRB     r0,[r4,#2]            ;2026  ; g_CXF_Done
000016  2803              CMP      r0,#3                 ;2026
000018  bf18              IT       NE
00001a  e8bd81f0          POPNE    {r4-r8,pc}
00001e  78e0              LDRB     r0,[r4,#3]            ;2031  ; g_RemoteWakeup
000020  2801              CMP      r0,#1                 ;2031
000022  bf08              IT       EQ
000024  e8bd81f0          POPEQ    {r4-r8,pc}
000028  4833              LDR      r0,|L15.248|
00002a  f8d007c2          LDR      r0,[r0,#0x7c2]        ;2036
00002e  2800              CMP      r0,#0                 ;2036
000030  bf08              IT       EQ
000032  e8bd81f0          POPEQ    {r4-r8,pc}
000036  4830              LDR      r0,|L15.248|
000038  f89017c1          LDRB     r1,[r0,#0x7c1]        ;2038
00003c  eb011141          ADD      r1,r1,r1,LSL #5       ;2038
000040  eb000241          ADD      r2,r0,r1,LSL #1       ;2038
000044  7913              LDRB     r3,[r2,#4]            ;2039
000046  2b0b              CMP      r3,#0xb               ;2039
000048  bf14              ITE      NE                    ;2039
00004a  2b0c              CMPNE    r3,#0xc               ;2039
00004c  e8bd81f0          POPEQ    {r4-r8,pc}
000050  4d2a              LDR      r5,|L15.252|
000052  4829              LDR      r0,|L15.248|
000054  f04f0700          MOV      r7,#0                 ;2036
000058  2b10              CMP      r3,#0x10              ;2039
00005a  f89017c6          LDRB     r1,[r0,#0x7c6]        ;2039
00005e  f8d007c2          LDR      r0,[r0,#0x7c2]        ;2039
000062  f1a00801          SUB      r8,r0,#1              ;2039
000066  d023              BEQ      |L15.176|
000068  7a60              LDRB     r0,[r4,#9]            ;2081  ; g_CheckVDMAComplete_Custom
00006a  2801              CMP      r0,#1                 ;2081
00006c  bf18              IT       NE
00006e  e8bd81f0          POPNE    {r4-r8,pc}
000072  4e21              LDR      r6,|L15.248|
000074  4822              LDR      r0,|L15.256|
000076  2901              CMP      r1,#1                 ;2084
000078  bf08              IT       EQ
00007a  e8bd81f0          POPEQ    {r4-r8,pc}
00007e  1d11              ADDS     r1,r2,#4
000080  2242              MOVS     r2,#0x42
000082  f7fffffe          BL       __aeabi_memcpy
000086  f8c687c2          STR      r8,[r6,#0x7c2]
00008a  f89607c1          LDRB     r0,[r6,#0x7c1]
00008e  1c40              ADDS     r0,r0,#1
000090  b2c0              UXTB     r0,r0
000092  f88607c1          STRB     r0,[r6,#0x7c1]
000096  281e              CMP      r0,#0x1e
000098  bf28              IT       CS
00009a  f88677c1          STRBCS   r7,[r6,#0x7c1]
00009e  7267              STRB     r7,[r4,#9]            ;2086
0000a0  f8d50138          LDR      r0,[r5,#0x138]        ;2087
0000a4  f4203080          BIC      r0,r0,#0x10000        ;2087
                  |L15.168|
0000a8  f8c50138          STR      r0,[r5,#0x138]        ;2050
0000ac  e8bd81f0          POP      {r4-r8,pc}
                  |L15.176|
0000b0  79a0              LDRB     r0,[r4,#6]            ;2044  ; g_CheckVDMAComplete_Touch
0000b2  2801              CMP      r0,#1                 ;2044
0000b4  bf18              IT       NE
0000b6  e8bd81f0          POPNE    {r4-r8,pc}
0000ba  4e0f              LDR      r6,|L15.248|
0000bc  2901              CMP      r1,#1                 ;2047
0000be  f1a600ee          SUB      r0,r6,#0xee           ;2047
0000c2  bf08              IT       EQ
0000c4  e8bd81f0          POPEQ    {r4-r8,pc}
0000c8  1d11              ADDS     r1,r2,#4
0000ca  2242              MOVS     r2,#0x42
0000cc  f7fffffe          BL       __aeabi_memcpy
0000d0  f8c687c2          STR      r8,[r6,#0x7c2]
0000d4  f89607c1          LDRB     r0,[r6,#0x7c1]
0000d8  1c40              ADDS     r0,r0,#1
0000da  b2c0              UXTB     r0,r0
0000dc  f88607c1          STRB     r0,[r6,#0x7c1]
0000e0  281e              CMP      r0,#0x1e
0000e2  bf28              IT       CS
0000e4  f88677c1          STRBCS   r7,[r6,#0x7c1]
0000e8  71a7              STRB     r7,[r4,#6]            ;2049
0000ea  f8d50138          LDR      r0,[r5,#0x138]        ;2050
0000ee  f4203000          BIC      r0,r0,#0x20000        ;2050
0000f2  e7d9              B        |L15.168|
;;;2103   
                          ENDP

                  |L15.244|
                          DCD      ||.data||
                  |L15.248|
                          DCD      ||.bss||+0x208
                  |L15.252|
                          DCD      0x40030000
                  |L15.256|
                          DCD      ||.bss||+0x27f5

                          AREA ||i.RecieveBulkCustomData||, CODE, READONLY, ALIGN=2

                  RecieveBulkCustomData PROC
;;;1992   // Host to Device
;;;1993   void RecieveBulkCustomData(uint8_t* pData)
000000  480d              LDR      r0,|L16.56|
000002  f8d0132c          LDR      r1,[r0,#0x32c]
000006  f4213100          BIC      r1,r1,#0x20000
00000a  f8c0132c          STR      r1,[r0,#0x32c]
00000e  f8d0132c          LDR      r1,[r0,#0x32c]
000012  f0210102          BIC      r1,r1,#2
000016  f8c0132c          STR      r1,[r0,#0x32c]
00001a  f2440102          MOV      r1,#0x4002
00001e  f8c01308          STR      r1,[r0,#0x308]
000022  4906              LDR      r1,|L16.60|
000024  f8c0130c          STR      r1,[r0,#0x30c]
000028  f8d01308          LDR      r1,[r0,#0x308]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c01308          STR      r1,[r0,#0x308]
;;;1994   {
;;;1995   #ifndef MODE_I2C
;;;1996   	// Something !!!
;;;1997   
;;;1998   	DMABulkData_USB();
;;;1999   
;;;2000   	// Something !!!
;;;2001   #endif
;;;2002   	return;
;;;2003   }
000034  4770              BX       lr
;;;2004   
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
                          DCD      0x40030000
                  |L16.60|
                          DCD      ||.bss||+0x2835

                          AREA ||i.RecieveBulkCustomData_DMA||, CODE, READONLY, ALIGN=1

                  RecieveBulkCustomData_DMA PROC
;;;1952   // Host to Device
;;;1953   void RecieveBulkCustomData_DMA(void)
000000  4770              BX       lr
;;;1954   {
;;;1955   #ifndef MODE_I2C
;;;1956   #ifdef ADD_BULK_CUSTOM
;;;1957   	// Bulk Custom OUT
;;;1958   	mUsbEXDmaFinishClr(BULK_CUSTOM_FIFO_OUT);
;;;1959   	mUsbEXIntDmaErrDis(BULK_CUSTOM_FIFO_OUT);
;;;1960   	mUsbEXIntDmaFinishDis(BULK_CUSTOM_FIFO_OUT);
;;;1961   
;;;1962   	// Virtual DMA Mask - Bulk Custom OUT
;;;1963   	mUsbEXIntDmaErrEn(BULK_CUSTOM_FIFO_OUT);
;;;1964   	mUsbEXIntDmaFinishEn(BULK_CUSTOM_FIFO_OUT);
;;;1965   
;;;1966   	// Virtual DMA Start !!!!
;;;1967   	mUsbEXDmaConfig(BULK_CUSTOM_FIFO_OUT, MX_PA_SZ_64, DIRECTION_OUT);
;;;1968   	mUsbEXDmaAddr(BULK_CUSTOM_FIFO_OUT, (uint32_t)g_BulkCustomBuffer);
;;;1969   	mUsbEXDmaStart(BULK_CUSTOM_FIFO_OUT);
;;;1970   #endif
;;;1971   #endif
;;;1972   	return;
;;;1973   }
;;;1974   
                          ENDP


                          AREA ||i.RecieveCustomData||, CODE, READONLY, ALIGN=1

                  RecieveCustomData PROC
;;;1403   // Host to Device
;;;1404   void RecieveCustomData(uint8_t* pData)
000000  b570              PUSH     {r4-r6,lr}
;;;1405   {
;;;1406   #if !USED_MNT_USB_CUSTOM_PROTOCOL
;;;1407   	switch (pData[0])
000002  7801              LDRB     r1,[r0,#0]
000004  2909              CMP      r1,#9
;;;1408   	{
;;;1409   		case HID_REPORT_ID__CUSTOM_OUT:
;;;1410   		{
;;;1411   			PHJ_HID_CONTROL_STRUCT  pHidControl = (PHJ_HID_CONTROL_STRUCT)pData;
;;;1412   			if (pHidControl->DeviceID_b.bRead)
;;;1413   			{
;;;1414   				HidReadWrite__Read(pHidControl);
;;;1415   			}
;;;1416   			else
;;;1417   			{
;;;1418   				HidReadWrite__Write((PHJ_HID_CONTROL_STRUCT)pData);
;;;1419   			}
;;;1420   
;;;1421   			break;
;;;1422   		}
;;;1423   	}
;;;1424   #else
;;;1425   	switch (pData[0])
;;;1426   	{
;;;1427   		case HID_REPORT_ID__CUSTOM_OUT:
;;;1428   		{
;;;1429   			PMNT_HID_TEST_STRUCT  pHidControl = (PMNT_HID_TEST_STRUCT)pData;
;;;1430   				HidReadWrite_MNT_Test(pHidControl);
;;;1431   
;;;1432   			break;
;;;1433   		}
;;;1434   	}
;;;1435   
;;;1436   #endif
;;;1437   	return;
;;;1438   }
000006  bf18              IT       NE
000008  bd70              POPNE    {r4-r6,pc}
00000a  7841              LDRB     r1,[r0,#1]            ;1412
00000c  f0110f01          TST      r1,#1                 ;1412
000010  d003              BEQ      |L18.26|
000012  e8bd4070          POP      {r4-r6,lr}            ;1414
000016  f7ffbffe          B.W      HidReadWrite__Read
                  |L18.26|
00001a  2500              MOVS     r5,#0                 ;1414
00001c  4604              MOV      r4,r0                 ;1418
00001e  462b              MOV      r3,r5                 ;1418
000020  462a              MOV      r2,r5                 ;1418
000022  4629              MOV      r1,r5                 ;1418
000024  2001              MOVS     r0,#1                 ;1418
000026  f7fffffe          BL       protocol_hid_mapping_emul_handler
00002a  2300              MOVS     r3,#0                 ;1418
00002c  461a              MOV      r2,r3                 ;1418
00002e  4619              MOV      r1,r3                 ;1418
000030  2004              MOVS     r0,#4                 ;1418
000032  f7fffffe          BL       protocol_hid_mapping_emul_handler
000036  8860              LDRH     r0,[r4,#2]            ;1418
000038  2800              CMP      r0,#0                 ;1418
00003a  d90c              BLS      |L18.86|
                  |L18.60|
00003c  1960              ADDS     r0,r4,r5              ;1418
00003e  1c6d              ADDS     r5,r5,#1              ;1418
000040  7903              LDRB     r3,[r0,#4]            ;1418
000042  b2a9              UXTH     r1,r5                 ;1418
000044  f44f5280          MOV      r2,#0x1000            ;1418
000048  2003              MOVS     r0,#3                 ;1418
00004a  f7fffffe          BL       protocol_hid_mapping_emul_handler
00004e  8860              LDRH     r0,[r4,#2]            ;1418
000050  b2ad              UXTH     r5,r5                 ;1418
000052  42a8              CMP      r0,r5                 ;1418
000054  d8f2              BHI      |L18.60|
                  |L18.86|
000056  2300              MOVS     r3,#0                 ;1418
000058  e8bd4070          POP      {r4-r6,lr}            ;1418
00005c  461a              MOV      r2,r3                 ;1418
00005e  4619              MOV      r1,r3                 ;1418
000060  2002              MOVS     r0,#2                 ;1418
000062  f7ffbffe          B.W      protocol_hid_mapping_emul_handler
;;;1439   
                          ENDP


                          AREA ||i.RecieveCustomData_DMA||, CODE, READONLY, ALIGN=2

                  RecieveCustomData_DMA PROC
;;;1082   
;;;1083   void RecieveCustomData_DMA(void)
000000  4814              LDR      r0,|L19.84|
;;;1084   {
;;;1085   #ifndef MODE_I2C
;;;1086   #ifdef ADD_CUSTOM
;;;1087   	// Custom OUT
;;;1088   	mUsbEXDmaFinishClr(CUSTOM_FIFO_OUT);
000002  2108              MOVS     r1,#8
000004  f8c01328          STR      r1,[r0,#0x328]
;;;1089   	mUsbEXIntDmaErrDis(CUSTOM_FIFO_OUT);
000008  f8d0132c          LDR      r1,[r0,#0x32c]
00000c  f4412100          ORR      r1,r1,#0x80000
000010  f8c0132c          STR      r1,[r0,#0x32c]
;;;1090   	mUsbEXIntDmaFinishDis(CUSTOM_FIFO_OUT);
000014  f8d0132c          LDR      r1,[r0,#0x32c]
000018  f0410108          ORR      r1,r1,#8
00001c  f8c0132c          STR      r1,[r0,#0x32c]
;;;1091   
;;;1092   	// Virtual DMA Mask - Custom OUT
;;;1093   	mUsbEXIntDmaErrEn(CUSTOM_FIFO_OUT);
000020  f8d0132c          LDR      r1,[r0,#0x32c]
000024  f4212100          BIC      r1,r1,#0x80000
000028  f8c0132c          STR      r1,[r0,#0x32c]
;;;1094   	mUsbEXIntDmaFinishEn(CUSTOM_FIFO_OUT);
00002c  f8d0132c          LDR      r1,[r0,#0x32c]
000030  f0210108          BIC      r1,r1,#8
000034  f8c0132c          STR      r1,[r0,#0x32c]
;;;1095   
;;;1096   	// Virtual DMA Start !!!!
;;;1097   	mUsbEXDmaConfig(CUSTOM_FIFO_OUT, MX_PA_SZ_64, DIRECTION_OUT);
000038  f44f4180          MOV      r1,#0x4000
00003c  f8c01318          STR      r1,[r0,#0x318]
;;;1098   	mUsbEXDmaAddr(CUSTOM_FIFO_OUT, (uint32_t)g_CustomBuffer);
000040  4905              LDR      r1,|L19.88|
000042  f8c0131c          STR      r1,[r0,#0x31c]
;;;1099   	mUsbEXDmaStart(CUSTOM_FIFO_OUT);
000046  f8d01318          LDR      r1,[r0,#0x318]
00004a  f0410101          ORR      r1,r1,#1
00004e  f8c01318          STR      r1,[r0,#0x318]
;;;1100   #endif
;;;1101   #endif
;;;1102   	return;
;;;1103   }
000052  4770              BX       lr
;;;1104   
                          ENDP

                  |L19.84|
                          DCD      0x40030000
                  |L19.88|
                          DCD      ||.bss||+0x27f5

                          AREA ||i.ResumeSigal||, CODE, READONLY, ALIGN=1

                  ResumeSigal PROC
;;;279    
;;;280    void ResumeSigal(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;281    {
;;;282    //	mUsbRemoteWakeUpSet_100();
;;;283    	if (mUsbRemoteWakeUpST() == 0)
000004  f890106c          LDRB     r1,[r0,#0x6c]
000008  f0110f02          TST      r1,#2
;;;284    	{
;;;285    //		while (mUsbRemoteWakeUpST_BIT4())
;;;286    //		{
;;;287    //
;;;288    //		}
;;;289    		mUsbRemoteWakeUpSet_SEL_WAKEUP();
;;;290    		mUsbRemoteWakeUpSet_1();
;;;291    
;;;292    //		delay_ms(15);
;;;293    //
;;;294    //		mUsbRemoteWakeUpSet_0();
;;;295    
;;;296    	}
;;;297    }
00000c  bf18              IT       NE
00000e  4770              BXNE     lr
000010  f890106c          LDRB     r1,[r0,#0x6c]         ;289
000014  f0210110          BIC      r1,r1,#0x10           ;289
000018  f880106c          STRB     r1,[r0,#0x6c]         ;289
00001c  f890106c          LDRB     r1,[r0,#0x6c]         ;290
000020  f0410102          ORR      r1,r1,#2              ;290
000024  f880106c          STRB     r1,[r0,#0x6c]         ;290
000028  4770              BX       lr
;;;298    
                          ENDP


                          AREA ||i.SendCustomData_USB||, CODE, READONLY, ALIGN=2

                  SendCustomData_USB PROC
;;;1050   
;;;1051   void SendCustomData_USB(uint8_t* pUserData)
000000  4915              LDR      r1,|L21.88|
000002  f8d117c2          LDR      r1,[r1,#0x7c2]
000006  291e              CMP      r1,#0x1e
;;;1052   {
;;;1053   	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
;;;1054   	{
;;;1055   		// Å¥G Ä–Õ«Ä¡Ø¦ Ô‘ß®Ð¡Ù©..  (Õ¥LÆ Ý•Þ‡)
;;;1056   		goto SENDCUSTOMDATA_USB__GOTO_END;
;;;1057   	}
;;;1058   
;;;1059   	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
;;;1060   
;;;1061   SENDCUSTOMDATA_USB__GOTO_END:
;;;1062   
;;;1063   	return;
;;;1064   }
000008  bf28              IT       CS
00000a  4770              BXCS     lr
00000c  b510              PUSH     {r4,lr}               ;1052
00000e  0001              MOVS     r1,r0                 ;1059
000010  4c11              LDR      r4,|L21.88|
000012  bf08              IT       EQ
000014  bd10              POPEQ    {r4,pc}
000016  2001              MOVS     r0,#1
000018  f88407c6          STRB     r0,[r4,#0x7c6]
00001c  f89407c0          LDRB     r0,[r4,#0x7c0]
000020  2242              MOVS     r2,#0x42
000022  eb001040          ADD      r0,r0,r0,LSL #5
000026  eb040040          ADD      r0,r4,r0,LSL #1
00002a  1d00              ADDS     r0,r0,#4
00002c  f7fffffe          BL       __aeabi_memcpy
000030  f8d407c2          LDR      r0,[r4,#0x7c2]
000034  2100              MOVS     r1,#0
000036  1c40              ADDS     r0,r0,#1
000038  f8c407c2          STR      r0,[r4,#0x7c2]
00003c  f89407c0          LDRB     r0,[r4,#0x7c0]
000040  1c40              ADDS     r0,r0,#1
000042  b2c0              UXTB     r0,r0
000044  f88407c0          STRB     r0,[r4,#0x7c0]
000048  281e              CMP      r0,#0x1e
00004a  bf28              IT       CS
00004c  f88417c0          STRBCS   r1,[r4,#0x7c0]
000050  f88417c6          STRB     r1,[r4,#0x7c6]
000054  bd10              POP      {r4,pc}
;;;1065   
                          ENDP

000056  0000              DCW      0x0000
                  |L21.88|
                          DCD      ||.bss||+0x208

                          AREA ||i.SendTouchData||, CODE, READONLY, ALIGN=2

                  SendTouchData PROC
;;;820    
;;;821    void SendTouchData(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;822    {
000004  b091              SUB      sp,sp,#0x44
;;;823    	uint8_t				i = 0;
;;;824    	uint8_t				ContactCount = 0;
000006  2500              MOVS     r5,#0
;;;825    	uint8_t				TouchDownCount = 0;
000008  462f              MOV      r7,r5
;;;826    	HID_MULTITOUCH_I2C	TouchData_I2C = { 0, };
00000a  2144              MOVS     r1,#0x44
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;827    	PHID_MULTITOUCH		TouchData = &TouchData_I2C.Data;
;;;828    
;;;829    //	if (module_Skip_Event())
;;;830    //	{
;;;831    //		goto SENDTOUCHDATA__GOTO_END;
;;;832    //	}
;;;833    
;;;834    	TouchData->ReportID = HID_REPORT_ID__MULTI_TOUCH;
000012  2010              MOVS     r0,#0x10
000014  f88d0002          STRB     r0,[sp,#2]
;;;835    
;;;836    	for (i = 0; i < HID_MAX_TOUCH; i++)
000018  488f              LDR      r0,|L22.600|
00001a  f10d0602          ADD      r6,sp,#2              ;827
00001e  f1000178          ADD      r1,r0,#0x78
000022  f1000c28          ADD      r12,r0,#0x28
000026  f1000350          ADD      r3,r0,#0x50
00002a  2200              MOVS     r2,#0
00002c  f04f080a          MOV      r8,#0xa
;;;837    	{
;;;838    		if (HID_id[i] != 0)
;;;839    		{
;;;840    			// Up Ã³Ø®Ø¦ dÈ®É· ÈÒ¢ 'È‘ [ß·
;;;841    			if (g_TouchTip[HID_id[i]] != HID_status[i])
000030  f1a0090c          SUB      r9,r0,#0xc
                  |L22.52|
000034  f8d0a000          LDR      r10,[r0,#0]           ;838
000038  f1ba0f00          CMP      r10,#0                ;838
00003c  d013              BEQ      |L22.102|
00003e  f819b00a          LDRB     r11,[r9,r10]
000042  680c              LDR      r4,[r1,#0]
000044  45a3              CMP      r11,r4
000046  d007              BEQ      |L22.88|
;;;842    			{
;;;843    				g_TouchTip[HID_id[i]] = HID_status[i];
000048  f809400a          STRB     r4,[r9,r10]
;;;844    				ContactCount += 1;
00004c  1c6c              ADDS     r4,r5,#1
00004e  b2e5              UXTB     r5,r4
;;;845    			}
;;;846    			else
;;;847    			{
;;;848    				if (HID_status[i] == FINGER_STATUS__TIP_SWITCH)
;;;849    				{
;;;850    					ContactCount += 1;
;;;851    				}
;;;852    			}
;;;853    
;;;854    			// ScanTime ; 'È˜Ü­ Touch Down G Ð³Ý¶Ø¦ È®NÈ‘Õ™.
;;;855    			if (HID_status[i] == FINGER_STATUS__TIP_SWITCH)
000050  680c              LDR      r4,[r1,#0]
000052  2c01              CMP      r4,#1
000054  d005              BEQ      |L22.98|
000056  e006              B        |L22.102|
                  |L22.88|
000058  2c01              CMP      r4,#1                 ;848
00005a  bf04              ITT      EQ                    ;850
00005c  1c6c              ADDEQ    r4,r5,#1              ;850
00005e  b2e5              UXTBEQ   r5,r4                 ;850
000060  d101              BNE      |L22.102|
                  |L22.98|
;;;856    			{
;;;857    				TouchDownCount += 1;
000062  1c7c              ADDS     r4,r7,#1
000064  b2e7              UXTB     r7,r4
                  |L22.102|
;;;858    			}
;;;859    		}
;;;860    
;;;861    		TouchData->Touch[i].Status = HID_status[i];
000066  eb020442          ADD      r4,r2,r2,LSL #1
00006a  eb060444          ADD      r4,r6,r4,LSL #1
00006e  f811ab04          LDRB     r10,[r1],#4
000072  f884a001          STRB     r10,[r4,#1]
;;;862    		TouchData->Touch[i].ID = HID_id[i];
000076  f810ab04          LDRB     r10,[r0],#4
00007a  f884a002          STRB     r10,[r4,#2]
;;;863    		TouchData->Touch[i].x = HID_x[i];
00007e  f83cab04          LDRH     r10,[r12],#4
000082  f8a4a003          STRH     r10,[r4,#3]
;;;864    		TouchData->Touch[i].y = HID_y[i];
000086  f833ab04          LDRH     r10,[r3],#4
00008a  1c52              ADDS     r2,r2,#1
00008c  f8a4a005          STRH     r10,[r4,#5]
000090  f1b80801          SUBS     r8,r8,#1
;;;865    	}
000094  d1ce              BNE      |L22.52|
;;;866    
;;;867    
;;;868    	for (i = 0; i < HID_MAX_TOUCH; i++)
000096  4871              LDR      r0,|L22.604|
000098  2400              MOVS     r4,#0
;;;869    	{
;;;870    		HID_status[i] = 0;
;;;871    		HID_id[i] = 0;
;;;872    		HID_x[i] = 0;
;;;873    		HID_y[i] = 0;
;;;874    	}
;;;875    
;;;876    
;;;877    
;;;878    
;;;879    	
;;;880    //	if (ContactCount == 0)
;;;881    //	{
;;;882    //		goto SENDTOUCHDATA__GOTO_END;
;;;883    //	}
;;;884    	
;;;885    	if (ContactCount)
;;;886    	{
;;;887    		TouchData->ContactCount = ContactCount;
;;;888    		TouchData->ScanTime = GetScanTime(&g_StartTime, &g_ScanTime);
;;;889    
;;;890    		// ScanTime Init
;;;891    		if (TouchDownCount == 0)
;;;892    		{
;;;893    			g_ScanTime = 0;
00009a  f8df81c4          LDR      r8,|L22.608|
00009e  f8c041e0          STR      r4,[r0,#0x1e0]        ;868  ; HID_status
0000a2  f8c041e4          STR      r4,[r0,#0x1e4]        ;868  ; HID_status
0000a6  f8c041e8          STR      r4,[r0,#0x1e8]        ;868  ; HID_status
0000aa  f8c041ec          STR      r4,[r0,#0x1ec]        ;868  ; HID_status
0000ae  f8c041f0          STR      r4,[r0,#0x1f0]        ;868  ; HID_status
0000b2  f8c041f4          STR      r4,[r0,#0x1f4]        ;868  ; HID_status
0000b6  f8c041f8          STR      r4,[r0,#0x1f8]        ;868  ; HID_status
0000ba  f8c041fc          STR      r4,[r0,#0x1fc]        ;868  ; HID_status
0000be  f8c04200          STR      r4,[r0,#0x200]        ;868  ; HID_status
0000c2  f8c04204          STR      r4,[r0,#0x204]        ;868  ; HID_status
0000c6  f8c04168          STR      r4,[r0,#0x168]        ;868  ; HID_id
0000ca  f8c0416c          STR      r4,[r0,#0x16c]        ;868  ; HID_id
0000ce  f8c04170          STR      r4,[r0,#0x170]        ;868  ; HID_id
0000d2  f8c04174          STR      r4,[r0,#0x174]        ;868  ; HID_id
0000d6  f8c04178          STR      r4,[r0,#0x178]        ;868  ; HID_id
0000da  f8c0417c          STR      r4,[r0,#0x17c]        ;868  ; HID_id
0000de  f8c04180          STR      r4,[r0,#0x180]        ;868  ; HID_id
0000e2  f8c04184          STR      r4,[r0,#0x184]        ;868  ; HID_id
0000e6  f8c04188          STR      r4,[r0,#0x188]        ;868  ; HID_id
0000ea  f8c0418c          STR      r4,[r0,#0x18c]        ;868  ; HID_id
0000ee  f8c04190          STR      r4,[r0,#0x190]        ;868  ; HID_x
0000f2  f8c04194          STR      r4,[r0,#0x194]        ;868  ; HID_x
0000f6  f8c04198          STR      r4,[r0,#0x198]        ;868  ; HID_x
0000fa  f8c0419c          STR      r4,[r0,#0x19c]        ;868  ; HID_x
0000fe  f8c041a0          STR      r4,[r0,#0x1a0]        ;868  ; HID_x
000102  f8c041a4          STR      r4,[r0,#0x1a4]        ;868  ; HID_x
000106  f8c041a8          STR      r4,[r0,#0x1a8]        ;868  ; HID_x
00010a  f8c041ac          STR      r4,[r0,#0x1ac]        ;868  ; HID_x
00010e  f8c041b0          STR      r4,[r0,#0x1b0]        ;868  ; HID_x
000112  f8c041b4          STR      r4,[r0,#0x1b4]        ;868  ; HID_x
000116  f8c041b8          STR      r4,[r0,#0x1b8]        ;868  ; HID_y
00011a  f8c041bc          STR      r4,[r0,#0x1bc]        ;868  ; HID_y
00011e  f8c041c0          STR      r4,[r0,#0x1c0]        ;868  ; HID_y
000122  f8c041c4          STR      r4,[r0,#0x1c4]        ;868  ; HID_y
000126  f8c041c8          STR      r4,[r0,#0x1c8]        ;868  ; HID_y
00012a  f8c041cc          STR      r4,[r0,#0x1cc]        ;868  ; HID_y
00012e  f8c041d0          STR      r4,[r0,#0x1d0]        ;868  ; HID_y
000132  f8c041d4          STR      r4,[r0,#0x1d4]        ;868  ; HID_y
000136  f8c041d8          STR      r4,[r0,#0x1d8]        ;868  ; HID_y
00013a  f8c041dc          STR      r4,[r0,#0x1dc]        ;885  ; HID_y
00013e  b175              CBZ      r5,|L22.350|
000140  f1080140          ADD      r1,r8,#0x40           ;888
000144  f886503d          STRB     r5,[r6,#0x3d]         ;887
000148  f1010038          ADD      r0,r1,#0x38           ;888
00014c  f7fffffe          BL       GetScanTime
000150  87f0              STRH     r0,[r6,#0x3e]         ;888
000152  b927              CBNZ     r7,|L22.350|
000154  2100              MOVS     r1,#0
000156  f8c84040          STR      r4,[r8,#0x40]  ; g_ScanTime
00015a  e9c8111e          STRD     r1,r1,[r8,#0x78]
                  |L22.350|
;;;894    			g_StartTime = 0;
;;;895    		}
;;;896    	}
;;;897    
;;;898    	
;;;899    
;;;900    #ifndef MODE_I2C
;;;901    #ifdef USB_SELECTIVE_SUSPEND
;;;902    
;;;903    			
;;;904    	//for (i = 0; i < HID_MAX_TOUCH; i++)
;;;905    	{
;;;906    		//if (TouchData->Touch[i].Status != 0)
;;;907    		{
;;;908    			if (abnormalUSBOperating)
00015e  4841              LDR      r0,|L22.612|
000160  f04f0901          MOV      r9,#1                 ;841
000164  7801              LDRB     r1,[r0,#0]  ; abnormalUSBOperating
;;;909    			{
;;;910    				mUsbRemoteWakeUpSet_SEL_WAKEUP();
000166  f04f4080          MOV      r0,#0x40000000
00016a  b1c1              CBZ      r1,|L22.414|
00016c  f890106c          LDRB     r1,[r0,#0x6c]
000170  f0210110          BIC      r1,r1,#0x10
000174  f880106c          STRB     r1,[r0,#0x6c]
;;;911    				mUsbRemoteWakeUpSet_0();
000178  f890106c          LDRB     r1,[r0,#0x6c]
00017c  f0210102          BIC      r1,r1,#2
000180  f880106c          STRB     r1,[r0,#0x6c]
;;;912    
;;;913    				g_ScanTime_Recovery = 0;
000184  2000              MOVS     r0,#0
000186  f8c84044          STR      r4,[r8,#0x44]  ; g_ScanTime_Recovery
00018a  e9c80020          STRD     r0,r0,[r8,#0x80]
;;;914    				g_StartTime_Recovery = 0;
;;;915    				GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus);
00018e  4936              LDR      r1,|L22.616|
000190  f1010040          ADD      r0,r1,#0x40
000194  f7fffffe          BL       GetScanTime
;;;916    				Recovery_ClearSus_Flag = 1;
000198  f8889008          STRB     r9,[r8,#8]
00019c  e046              B        |L22.556|
                  |L22.414|
;;;917    			}
;;;918    			else
;;;919    			{
;;;920    				if ((g_RemoteWakeup == 1) && (g_Status[0].Status.Global.RemoteWakeup == 1))
00019e  f8981003          LDRB     r1,[r8,#3]  ; g_RemoteWakeup
0001a2  2901              CMP      r1,#1
0001a4  d142              BNE      |L22.556|
0001a6  4f2d              LDR      r7,|L22.604|
0001a8  7839              LDRB     r1,[r7,#0]  ; g_Status
0001aa  f0110f02          TST      r1,#2
0001ae  d03d              BEQ      |L22.556|
;;;921    				{
;;;922    					if (ContactCount)
0001b0  b1fd              CBZ      r5,|L22.498|
0001b2  f890106c          LDRB     r1,[r0,#0x6c]
0001b6  f0110f02          TST      r1,#2
0001ba  d10b              BNE      |L22.468|
0001bc  f890106c          LDRB     r1,[r0,#0x6c]
0001c0  f0210110          BIC      r1,r1,#0x10
0001c4  f880106c          STRB     r1,[r0,#0x6c]
0001c8  f890106c          LDRB     r1,[r0,#0x6c]
0001cc  f0410102          ORR      r1,r1,#2
0001d0  f880106c          STRB     r1,[r0,#0x6c]
                  |L22.468|
;;;923    					{
;;;924    						ResumeSigal();
;;;925    						wakeupSignalEn = YES;
0001d4  4825              LDR      r0,|L22.620|
0001d6  f8809000          STRB     r9,[r0,#0]
;;;926    
;;;927    //						if (g_bMouse == TRUE)
;;;928    //						{
;;;929    //							uint8_t 				MouseBuffer[QUEUE_BLOCK_SIZE] = { 0, };
;;;930    //							PHID_ABSOLUTE_MOUSE		pMouse = (PHID_ABSOLUTE_MOUSE)MouseBuffer;
;;;931    //
;;;932    //							pMouse->ReportID = HID_REPORT_ID__MOUSE;
;;;933    //							pMouse->X = (TouchData->Touch[0].x * 4096) / X_Y_LOGICAL_MAX;
;;;934    //							pMouse->Y = (TouchData->Touch[0].y * 4096) / X_Y_LOGICAL_MAX;
;;;935    //							pMouse->Button1 = TouchData->Touch[0].Status;
;;;936    //
;;;937    //							SendTouchData_USB(MouseBuffer);
;;;938    //						}
;;;939    //						else
;;;940    						{
;;;941    							SendTouchData_USB((uint8_t*)TouchData);
0001da  4630              MOV      r0,r6
0001dc  f7fffffe          BL       SendTouchData_USB
0001e0  e9d81020          LDRD     r1,r0,[r8,#0x80]
;;;942    						}
;;;943    
;;;944    						if(g_StartTime_Recovery == 0)
0001e4  4308              ORRS     r0,r0,r1
0001e6  d104              BNE      |L22.498|
;;;945    						{
;;;946    	//						GPIO->GPIO_DATA1_b.GPB11 = 0;
;;;947    	//						GPIO->GPIO_DATA1_b.GPB11 = 1;
;;;948    							GetScanTime(&g_StartTime_Recovery, &g_ScanTime_Recovery);
0001e8  4921              LDR      r1,|L22.624|
0001ea  f101003c          ADD      r0,r1,#0x3c
0001ee  f7fffffe          BL       GetScanTime
                  |L22.498|
0001f2  e9d80120          LDRD     r0,r1,[r8,#0x80]
;;;949    						}
;;;950    					}
;;;951    
;;;952    					if(g_StartTime_Recovery > 0)
0001f6  4308              ORRS     r0,r0,r1
0001f8  d018              BEQ      |L22.556|
;;;953    					{
;;;954    						if (GetScanTime(&g_StartTime_Recovery, &g_ScanTime_Recovery) >= 20000)
0001fa  491d              LDR      r1,|L22.624|
0001fc  f101003c          ADD      r0,r1,#0x3c
000200  f7fffffe          BL       GetScanTime
000204  f6446120          MOV      r1,#0x4e20
000208  4281              CMP      r1,r0
00020a  d80f              BHI      |L22.556|
;;;955    						{
;;;956    //							abnormalOperating = YES;
;;;957    
;;;958    							g_RemoteWakeup = 0;
00020c  f8884003          STRB     r4,[r8,#3]
;;;959    							g_Status[0].Status.Global.RemoteWakeup = 0;
000210  7838              LDRB     r0,[r7,#0]  ; g_Status
000212  f0200002          BIC      r0,r0,#2
000216  7038              STRB     r0,[r7,#0]
;;;960    							g_ScanTime_Recovery = 0;
000218  2000              MOVS     r0,#0
00021a  f8c84044          STR      r4,[r8,#0x44]  ; g_ScanTime_Recovery
00021e  e9c80020          STRD     r0,r0,[r8,#0x80]
;;;961    							g_StartTime_Recovery = 0;
;;;962    							ResumeCnt = 0;
000222  f8884007          STRB     r4,[r8,#7]
;;;963    
;;;964    							// H/W Reset !!
;;;965    							module_Protocol_Init();
000226  f7fffffe          BL       module_Protocol_Init
                  |L22.554|
;;;966    	//						module_Protocol_Init_For_USB_Abnormal();
;;;967    
;;;968    	//						module_Watch_Enable();
;;;969    							while(1);
00022a  e7fe              B        |L22.554|
                  |L22.556|
;;;970    						}
;;;971    					}
;;;972    				}
;;;973    			}
;;;974    
;;;975    #if (CUSTOMER == NEC)
;;;976    			else if(g_Status[0].Status.Global.RemoteWakeup == 1 && Recovery_ClearSus_Flag == 1)
;;;977    			{
;;;978    				if(ResumeCnt==5)
;;;979    				{
;;;980    					while(1);
;;;981    				}
;;;982    				else if(GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus )> 200 && ResumeCnt < 5) 
;;;983    				{
;;;984    					mUsbGoSuspend();						
;;;985    					g_RemoteWakeup = 1;	
;;;986    					ResumeSigal();
;;;987    					ResumeCnt++;
;;;988    					g_StartTime_Recovery_ClearSus = g_ScanTime_Recovery_ClearSus =0;
;;;989    					Recovery_ClearSus_Flag = 0;
;;;990    				}
;;;991    			}
;;;992    #endif				
;;;993    		}
;;;994    	}
;;;995    #endif
;;;996    #endif
;;;997    
;;;998    	
;;;999    
;;;1000   	// USB
;;;1001   	if (ContactCount && g_RemoteWakeup==0)
00022c  2d00              CMP      r5,#0
;;;1002   	{
;;;1003   		if ((CheckUsbConfig() != 0) )//&& (CheckHIDReady() != 0))
;;;1004   		{
;;;1005   			SendTouchData_USB((uint8_t*)TouchData);
;;;1006   		}
;;;1007   #ifdef MODE_I2C
;;;1008   		// I2C
;;;1009   		else if (CheckI2CReady() != 0 && (custom_tool == 0))
;;;1010   		{
;;;1011   			TouchData_I2C.I2C_Length = sizeof(HID_MULTITOUCH_I2C);
;;;1012   			SendTouchData_I2C(&TouchData_I2C);
;;;1013   		}
;;;1014   #endif
;;;1015   	}
;;;1016   
;;;1017   SENDTOUCHDATA__GOTO_END:
;;;1018   
;;;1019   	return;
;;;1020   }
00022e  bf04              ITT      EQ
000230  b011              ADDEQ    sp,sp,#0x44
000232  e8bd8ff0          POPEQ    {r4-r11,pc}
000236  f8980003          LDRB     r0,[r8,#3]            ;1001  ; g_RemoteWakeup
00023a  2800              CMP      r0,#0                 ;1001
00023c  bf1c              ITT      NE
00023e  b011              ADDNE    sp,sp,#0x44
000240  e8bd8ff0          POPNE    {r4-r11,pc}
000244  f8980000          LDRB     r0,[r8,#0]            ;1003  ; g_Configuration
000248  2800              CMP      r0,#0                 ;1003
00024a  bf1c              ITT      NE                    ;1005
00024c  4630              MOVNE    r0,r6                 ;1005
00024e  f7fffffe          BLNE     SendTouchData_USB
000252  b011              ADD      sp,sp,#0x44
000254  e8bd8ff0          POP      {r4-r11,pc}
;;;1021   #endif
                          ENDP

                  |L22.600|
                          DCD      ||.bss||+0x168
                  |L22.604|
                          DCD      ||.bss||
                  |L22.608|
                          DCD      ||.data||
                  |L22.612|
                          DCD      abnormalUSBOperating
                  |L22.616|
                          DCD      ||.data||+0x48
                  |L22.620|
                          DCD      wakeupSignalEn
                  |L22.624|
                          DCD      ||.data||+0x44

                          AREA ||i.SendTouchData_USB||, CODE, READONLY, ALIGN=2

                  SendTouchData_USB PROC
;;;580    // /È¿È‘ Õ¥LÆÐ¡ V; Ö§Ø¸ È£Ä¢ ÖˆÕ™.
;;;581    void SendTouchData_USB(uint8_t* pUserData)
000000  b570              PUSH     {r4-r6,lr}
;;;582    {
;;;583    	if (StaticQueue_CheckFull(&g_Queue_Common) == 1)
000002  4921              LDR      r1,|L23.136|
000004  2301              MOVS     r3,#1
000006  2500              MOVS     r5,#0
000008  f8d117c2          LDR      r1,[r1,#0x7c2]
00000c  291e              CMP      r1,#0x1e
00000e  d313              BCC      |L23.56|
;;;584    	{
;;;585    		StaticQueue_HeadDelete(&g_Queue_Common);
000010  4a1d              LDR      r2,|L23.136|
000012  f88237c6          STRB     r3,[r2,#0x7c6]
000016  f8d217c2          LDR      r1,[r2,#0x7c2]
00001a  1e49              SUBS     r1,r1,#1
00001c  f8c217c2          STR      r1,[r2,#0x7c2]
000020  f89217c1          LDRB     r1,[r2,#0x7c1]
000024  1c49              ADDS     r1,r1,#1
000026  b2c9              UXTB     r1,r1
000028  f88217c1          STRB     r1,[r2,#0x7c1]
00002c  291e              CMP      r1,#0x1e
00002e  bf28              IT       CS
000030  f88257c1          STRBCS   r5,[r2,#0x7c1]
000034  f88257c6          STRB     r5,[r2,#0x7c6]
                  |L23.56|
;;;586    	}
;;;587    
;;;588    	StaticQueue_Push(&g_Queue_Common, (uint8_t*)pUserData);
000038  4c13              LDR      r4,|L23.136|
00003a  0001              MOVS     r1,r0
;;;589    
;;;590    //SENDTOUCHDATA_USB__GOTO_END:
;;;591    
;;;592    	return;
;;;593    }
00003c  bf08              IT       EQ
00003e  bd70              POPEQ    {r4-r6,pc}
000040  f8d407c2          LDR      r0,[r4,#0x7c2]
000044  281e              CMP      r0,#0x1e
000046  bf28              IT       CS
000048  bd70              POPCS    {r4-r6,pc}
00004a  f88437c6          STRB     r3,[r4,#0x7c6]
00004e  f89407c0          LDRB     r0,[r4,#0x7c0]
000052  2242              MOVS     r2,#0x42
000054  eb001040          ADD      r0,r0,r0,LSL #5
000058  eb040040          ADD      r0,r4,r0,LSL #1
00005c  1d00              ADDS     r0,r0,#4
00005e  f7fffffe          BL       __aeabi_memcpy
000062  f8d407c2          LDR      r0,[r4,#0x7c2]
000066  1c40              ADDS     r0,r0,#1
000068  f8c407c2          STR      r0,[r4,#0x7c2]
00006c  f89407c0          LDRB     r0,[r4,#0x7c0]
000070  1c40              ADDS     r0,r0,#1
000072  b2c0              UXTB     r0,r0
000074  f88407c0          STRB     r0,[r4,#0x7c0]
000078  281e              CMP      r0,#0x1e
00007a  bf28              IT       CS
00007c  f88457c0          STRBCS   r5,[r4,#0x7c0]
000080  f88457c6          STRB     r5,[r4,#0x7c6]
000084  bd70              POP      {r4-r6,pc}
;;;594    
                          ENDP

000086  0000              DCW      0x0000
                  |L23.136|
                          DCD      ||.bss||+0x208

                          AREA ||i.SetupPacket_AfterCheck||, CODE, READONLY, ALIGN=2

                  SetupPacket_AfterCheck PROC
;;;3111   
;;;3112   void SetupPacket_AfterCheck(PSETUP_PACKET pSetupPacket)
000000  4808              LDR      r0,|L24.36|
;;;3113   {
;;;3114   	switch (g_pSetupPacket->bRequest)
000002  69c1              LDR      r1,[r0,#0x1c]  ; g_pSetupPacket
000004  784a              LDRB     r2,[r1,#1]
000006  2a01              CMP      r2,#1
;;;3115   	{
;;;3116   		// Get Report
;;;3117   		case SETUPPACKET_CLASS_REQUEST__GET_REPORT:
;;;3118   		{
;;;3119   			// Feature
;;;3120   			if ((g_pSetupPacket->wValue & 0xFF00) == 0x0300)
;;;3121   			{
;;;3122   				switch (g_pSetupPacket->wValue & 0x00FF)
;;;3123   				{
;;;3124   					case HID_REPORT_ID__CONTACT_COUNT:
;;;3125   					{
;;;3126   						g_HIDReady = 1;
;;;3127   						break;
;;;3128   					}
;;;3129   				}
;;;3130   			}
;;;3131   
;;;3132   			break;
;;;3133   		}
;;;3134   	}
;;;3135   
;;;3136   	return;
;;;3137   }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  8849              LDRH     r1,[r1,#2]            ;3120
00000e  f401427f          AND      r2,r1,#0xff00         ;3120
000012  f5b27f40          CMP      r2,#0x300             ;3120
000016  bf01              ITTTT    EQ                    ;3122
000018  b2c9              UXTBEQ   r1,r1                 ;3122
00001a  2908              CMPEQ    r1,#8                 ;3122
00001c  2101              MOVEQ    r1,#1                 ;3126
00001e  7041              STRBEQ   r1,[r0,#1]            ;3126
000020  4770              BX       lr
;;;3138   #endif
                          ENDP

000022  0000              DCW      0x0000
                  |L24.36|
                          DCD      ||.data||

                          AREA ||i.StaticQueue_CheckEmpty||, CODE, READONLY, ALIGN=1

                  StaticQueue_CheckEmpty PROC
;;;507    
;;;508    uint8_t StaticQueue_CheckEmpty(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;509    {
000002  b120              CBZ      r0,|L25.14|
;;;510    	uint8_t nRet = 0;
;;;511    
;;;512    	if (pQueue == NULL)
;;;513    	{
;;;514    		goto STATICQUEUE_CHECKEMPTY__GOTO_END;
;;;515    	}
;;;516    
;;;517    	if (pQueue->Count <= 0)
000004  f8d007c2          LDR      r0,[r0,#0x7c2]
000008  2800              CMP      r0,#0
;;;518    	{
;;;519    		nRet = 1;
00000a  bf08              IT       EQ
00000c  2101              MOVEQ    r1,#1
                  |L25.14|
;;;520    	}
;;;521    
;;;522    STATICQUEUE_CHECKEMPTY__GOTO_END:
;;;523    
;;;524    	return nRet;
00000e  4608              MOV      r0,r1
;;;525    }
000010  4770              BX       lr
;;;526    
                          ENDP


                          AREA ||i.StaticQueue_CheckFull||, CODE, READONLY, ALIGN=1

                  StaticQueue_CheckFull PROC
;;;487    
;;;488    uint8_t StaticQueue_CheckFull(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;489    {
000002  b120              CBZ      r0,|L26.14|
;;;490    	uint8_t nRet = 0;
;;;491    
;;;492    	if (pQueue == NULL)
;;;493    	{
;;;494    		goto STATICQUEUE_CHECKFULL__GOTO_END;
;;;495    	}
;;;496    
;;;497    	if (pQueue->Count >= QUEUE_MAX_COUNT__COMMON)
000004  f8d007c2          LDR      r0,[r0,#0x7c2]
000008  281e              CMP      r0,#0x1e
;;;498    	{
;;;499    		nRet = 1;
00000a  bf28              IT       CS
00000c  2101              MOVCS    r1,#1
                  |L26.14|
;;;500    	}
;;;501    
;;;502    STATICQUEUE_CHECKFULL__GOTO_END:
;;;503    
;;;504    	return nRet;
00000e  4608              MOV      r0,r1
;;;505    }
000010  4770              BX       lr
;;;506    
                          ENDP


                          AREA ||i.StaticQueue_CheckInit||, CODE, READONLY, ALIGN=1

                  StaticQueue_CheckInit PROC
;;;336    
;;;337    uint8_t StaticQueue_CheckInit(PSTATIC_QUEUE pQueue)
000000  2101              MOVS     r1,#1
;;;338    {
000002  b138              CBZ      r0,|L27.20|
;;;339    	uint8_t	nRet = 1;
;;;340    	uint8_t*	pCompare = (uint8_t*)QUEUE_SIGNATURE;
;;;341    	uint8_t	i = 0;
;;;342    
;;;343    	if (pQueue == NULL)
;;;344    	{
;;;345    		goto  STATICQUEUE_CHECKINIT__GOTO_END;
;;;346    	}
;;;347    
;;;348    	for (i = 0; i < 4; i++)
;;;349    	{
;;;350    		if (pQueue->Signature[i] != pCompare[i])
000004  7802              LDRB     r2,[r0,#0]
000006  2a53              CMP      r2,#0x53
000008  bf04              ITT      EQ
00000a  7842              LDRBEQ   r2,[r0,#1]
00000c  2a49              CMPEQ    r2,#0x49
00000e  d003              BEQ      |L27.24|
                  |L27.16|
;;;351    		{
;;;352    			nRet = 0;
000010  f04f0100          MOV      r1,#0
                  |L27.20|
;;;353    			break;
;;;354    		}
;;;355    	}
;;;356    
;;;357    STATICQUEUE_CHECKINIT__GOTO_END:
;;;358    
;;;359    	return nRet;
000014  4608              MOV      r0,r1
;;;360    }
000016  4770              BX       lr
                  |L27.24|
000018  7882              LDRB     r2,[r0,#2]            ;350
00001a  2a57              CMP      r2,#0x57              ;350
00001c  bf04              ITT      EQ                    ;350
00001e  78c0              LDRBEQ   r0,[r0,#3]            ;350
000020  2834              CMPEQ    r0,#0x34              ;350
000022  d1f5              BNE      |L27.16|
000024  e7f6              B        |L27.20|
;;;361    
                          ENDP


                          AREA ||i.StaticQueue_Get||, CODE, READONLY, ALIGN=1

                  StaticQueue_Get PROC
;;;465    
;;;466    uint8_t* StaticQueue_Get(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;467    {
;;;468    	uint8_t* pRet = 0;
;;;469    
;;;470    	if (pQueue == NULL)
000002  2800              CMP      r0,#0
;;;471    	{
;;;472    		goto STATICQUEUE_GET__GOTO_END;
;;;473    	}
;;;474    
;;;475    	// Empty
;;;476    	if (pQueue->Count <= 0)
000004  bf1c              ITT      NE
000006  f8d027c2          LDRNE    r2,[r0,#0x7c2]
00000a  2a00              CMPNE    r2,#0
00000c  d007              BEQ      |L28.30|
;;;477    	{
;;;478    		goto STATICQUEUE_GET__GOTO_END;
;;;479    	}
;;;480    
;;;481    	pRet = &pQueue->Buffer[pQueue->PopPoint * QUEUE_BLOCK_SIZE];
00000e  f89017c1          LDRB     r1,[r0,#0x7c1]
000012  eb011141          ADD      r1,r1,r1,LSL #5
000016  eb000041          ADD      r0,r0,r1,LSL #1
00001a  f1000104          ADD      r1,r0,#4
                  |L28.30|
;;;482    
;;;483    STATICQUEUE_GET__GOTO_END:
;;;484    
;;;485    	return pRet;
00001e  4608              MOV      r0,r1
;;;486    }
000020  4770              BX       lr
;;;487    
                          ENDP


                          AREA ||i.StaticQueue_HeadDelete||, CODE, READONLY, ALIGN=1

                  StaticQueue_HeadDelete PROC
;;;431    
;;;432    uint8_t StaticQueue_HeadDelete(PSTATIC_QUEUE pQueue)
000000  2100              MOVS     r1,#0
;;;433    {
;;;434    	uint8_t nRet = 0;
;;;435    
;;;436    	if (pQueue == NULL)
000002  2800              CMP      r0,#0
;;;437    	{
;;;438    		goto STATICQUEUE_POP__GOTO_END;
;;;439    	}
;;;440    
;;;441    	// Empty
;;;442    	if (pQueue->Count <= 0)
000004  bf1c              ITT      NE
000006  f8d027c2          LDRNE    r2,[r0,#0x7c2]
00000a  2a00              CMPNE    r2,#0
00000c  d017              BEQ      |L29.62|
;;;443    	{
;;;444    		goto STATICQUEUE_POP__GOTO_END;
;;;445    	}
;;;446    
;;;447    	pQueue->Doing = TRUE;
00000e  f04f0101          MOV      r1,#1
000012  f88017c6          STRB     r1,[r0,#0x7c6]
;;;448    
;;;449    	pQueue->Count -= 1;
000016  f1a20101          SUB      r1,r2,#1
00001a  f8c017c2          STR      r1,[r0,#0x7c2]
;;;450    	pQueue->PopPoint += 1;
00001e  f89017c1          LDRB     r1,[r0,#0x7c1]
000022  f04f0200          MOV      r2,#0
000026  f1010101          ADD      r1,r1,#1
00002a  b2c9              UXTB     r1,r1
00002c  f88017c1          STRB     r1,[r0,#0x7c1]
;;;451    	if (pQueue->PopPoint >= QUEUE_MAX_COUNT__COMMON)
000030  291e              CMP      r1,#0x1e
;;;452    	{
;;;453    		pQueue->PopPoint = 0;
000032  bf28              IT       CS
000034  f88027c1          STRBCS   r2,[r0,#0x7c1]
;;;454    	}
;;;455    
;;;456    	nRet = 1;
000038  2101              MOVS     r1,#1
;;;457    	pQueue->Doing = FALSE;
00003a  f88027c6          STRB     r2,[r0,#0x7c6]
                  |L29.62|
;;;458    
;;;459    STATICQUEUE_POP__GOTO_END:
;;;460    
;;;461    	return nRet;
00003e  4608              MOV      r0,r1
;;;462    }
000040  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.StaticQueue_Init||, CODE, READONLY, ALIGN=2

                  StaticQueue_Init PROC
;;;311    
;;;312    uint8_t StaticQueue_Init(PSTATIC_QUEUE pQueue)
000000  b510              PUSH     {r4,lr}
;;;313    {
000002  0004              MOVS     r4,r0
;;;314    	uint8_t nRet = 0;
000004  f04f0000          MOV      r0,#0
;;;315    
;;;316    	if (pQueue == NULL)
;;;317    	{
;;;318    		goto STATICQUEUE_INIT__GOTO_END;
;;;319    	}
;;;320    
;;;321    	//InitializeCriticalSection(&g_cs);
;;;322    	memcpy(pQueue->Signature, (uint8_t*)QUEUE_SIGNATURE, 4);
;;;323    	memset(pQueue->Buffer, 0, QUEUE_BLOCK_SIZE * QUEUE_MAX_COUNT__COMMON);
;;;324    	pQueue->PushPoint = 0;
;;;325    	pQueue->PopPoint = 0;
;;;326    	pQueue->Count = 0;
;;;327    	pQueue->Doing = FALSE;
;;;328    
;;;329    	nRet = 1;
;;;330    
;;;331    STATICQUEUE_INIT__GOTO_END:
;;;332    
;;;333    	return nRet;
;;;334    }
000008  bf08              IT       EQ
00000a  bd10              POPEQ    {r4,pc}
00000c  a009              ADR      r0,|L30.52|
00000e  f24071bc          MOV      r1,#0x7bc             ;323
000012  6800              LDR      r0,[r0,#0]            ;322
000014  6020              STR      r0,[r4,#0]            ;322
000016  1d20              ADDS     r0,r4,#4              ;323
000018  f7fffffe          BL       __aeabi_memclr
00001c  2000              MOVS     r0,#0                 ;324
00001e  f88407c0          STRB     r0,[r4,#0x7c0]        ;324
000022  f88407c1          STRB     r0,[r4,#0x7c1]        ;325
000026  f8c407c2          STR      r0,[r4,#0x7c2]        ;326
00002a  f88407c6          STRB     r0,[r4,#0x7c6]        ;327
00002e  2001              MOVS     r0,#1                 ;329
000030  bd10              POP      {r4,pc}
;;;335    
                          ENDP

000032  0000              DCW      0x0000
                  |L30.52|
000034  53495734          DCB      "SIW4",0
000038  00      
000039  00                DCB      0
00003a  00                DCB      0
00003b  00                DCB      0

                          AREA ||i.StaticQueue_Pop||, CODE, READONLY, ALIGN=1

                  StaticQueue_Pop PROC
;;;395    
;;;396    uint8_t StaticQueue_Pop(PSTATIC_QUEUE pQueue, uint8_t* pData)
000000  b510              PUSH     {r4,lr}
;;;397    {
000002  0004              MOVS     r4,r0
000004  460b              MOV      r3,r1
;;;398    	uint8_t nRet = 0;
000006  f04f0000          MOV      r0,#0
;;;399    
;;;400    	if ((pQueue == NULL) || (pData == NULL))
00000a  bf14              ITE      NE
00000c  2b00              CMPNE    r3,#0
;;;401    	{
;;;402    		goto STATICQUEUE_POP__GOTO_END;
;;;403    	}
;;;404    
;;;405    	// Empty
;;;406    	if (pQueue->Count <= 0)
;;;407    	{
;;;408    		goto STATICQUEUE_POP__GOTO_END;
;;;409    	}
;;;410    
;;;411    	if (pQueue->Doing == TRUE)
;;;412        {
;;;413            goto STATICQUEUE_POP__GOTO_END;
;;;414        }
;;;415    
;;;416    	memcpy(pData, &pQueue->Buffer[pQueue->PopPoint * QUEUE_BLOCK_SIZE], QUEUE_BLOCK_SIZE);
;;;417    	pQueue->Count -= 1;
;;;418    	pQueue->PopPoint += 1;
;;;419    	if (pQueue->PopPoint >= QUEUE_MAX_COUNT__COMMON)
;;;420    	{
;;;421    		pQueue->PopPoint = 0;
;;;422    	}
;;;423    
;;;424    	nRet = 1;
;;;425    
;;;426    STATICQUEUE_POP__GOTO_END:
;;;427    
;;;428    	return nRet;
;;;429    }
00000e  bd10              POPEQ    {r4,pc}
000010  f8d417c2          LDR      r1,[r4,#0x7c2]        ;406
000014  2900              CMP      r1,#0                 ;406
000016  bf1a              ITTE     NE                    ;411
000018  f89417c6          LDRBNE   r1,[r4,#0x7c6]        ;411
00001c  2901              CMPNE    r1,#1                 ;411
00001e  bd10              POPEQ    {r4,pc}
000020  f89407c1          LDRB     r0,[r4,#0x7c1]        ;416
000024  f04f0242          MOV      r2,#0x42              ;416
000028  eb001040          ADD      r0,r0,r0,LSL #5       ;416
00002c  eb040040          ADD      r0,r4,r0,LSL #1       ;416
000030  f1000104          ADD      r1,r0,#4              ;416
000034  4618              MOV      r0,r3                 ;416
000036  f7fffffe          BL       __aeabi_memcpy
00003a  f8d407c2          LDR      r0,[r4,#0x7c2]        ;417
00003e  1e40              SUBS     r0,r0,#1              ;417
000040  f8c407c2          STR      r0,[r4,#0x7c2]        ;417
000044  f89407c1          LDRB     r0,[r4,#0x7c1]        ;418
000048  1c40              ADDS     r0,r0,#1              ;418
00004a  b2c0              UXTB     r0,r0                 ;418
00004c  f88407c1          STRB     r0,[r4,#0x7c1]        ;418
000050  281e              CMP      r0,#0x1e              ;419
000052  bf24              ITT      CS                    ;421
000054  2000              MOVCS    r0,#0                 ;421
000056  f88407c1          STRBCS   r0,[r4,#0x7c1]        ;421
00005a  2001              MOVS     r0,#1                 ;424
00005c  bd10              POP      {r4,pc}
;;;430    
                          ENDP


                          AREA ||i.StaticQueue_Push||, CODE, READONLY, ALIGN=1

                  StaticQueue_Push PROC
;;;361    
;;;362    uint8_t StaticQueue_Push(PSTATIC_QUEUE pQueue, uint8_t* pData)
000000  b510              PUSH     {r4,lr}
;;;363    {
000002  0004              MOVS     r4,r0
;;;364    	uint8_t nRet = 0;
000004  f04f0000          MOV      r0,#0
;;;365    
;;;366    	if ((pQueue == NULL) || (pData == NULL))
000008  bf14              ITE      NE
00000a  2900              CMPNE    r1,#0
;;;367    	{
;;;368    		goto STATICQUEUE_PUSH__GOTO_END;
;;;369    	}
;;;370    
;;;371    	// Full
;;;372    	if (pQueue->Count >= QUEUE_MAX_COUNT__COMMON)
;;;373    	{
;;;374    		goto STATICQUEUE_PUSH__GOTO_END;
;;;375    	}
;;;376    
;;;377    	pQueue->Doing = TRUE;
;;;378    
;;;379    	memcpy(&pQueue->Buffer[pQueue->PushPoint * QUEUE_BLOCK_SIZE], pData, QUEUE_BLOCK_SIZE);
;;;380    	pQueue->Count += 1;
;;;381    	pQueue->PushPoint += 1;
;;;382    	if (pQueue->PushPoint >= QUEUE_MAX_COUNT__COMMON)
;;;383    	{
;;;384    		pQueue->PushPoint = 0;
;;;385    	}
;;;386    
;;;387    	nRet = 1;
;;;388    	pQueue->Doing = FALSE;
;;;389    
;;;390    STATICQUEUE_PUSH__GOTO_END:
;;;391    
;;;392    	return nRet;
;;;393    }
00000c  bd10              POPEQ    {r4,pc}
00000e  f8d427c2          LDR      r2,[r4,#0x7c2]        ;372
000012  2a1e              CMP      r2,#0x1e              ;372
000014  bf28              IT       CS
000016  bd10              POPCS    {r4,pc}
000018  2001              MOVS     r0,#1                 ;377
00001a  f88407c6          STRB     r0,[r4,#0x7c6]        ;377
00001e  f89407c0          LDRB     r0,[r4,#0x7c0]        ;379
000022  2242              MOVS     r2,#0x42              ;379
000024  eb001040          ADD      r0,r0,r0,LSL #5       ;379
000028  eb040040          ADD      r0,r4,r0,LSL #1       ;379
00002c  1d00              ADDS     r0,r0,#4              ;379
00002e  f7fffffe          BL       __aeabi_memcpy
000032  f8d407c2          LDR      r0,[r4,#0x7c2]        ;380
000036  2100              MOVS     r1,#0                 ;381
000038  1c40              ADDS     r0,r0,#1              ;380
00003a  f8c407c2          STR      r0,[r4,#0x7c2]        ;380
00003e  f89407c0          LDRB     r0,[r4,#0x7c0]        ;381
000042  1c40              ADDS     r0,r0,#1              ;381
000044  b2c0              UXTB     r0,r0                 ;381
000046  f88407c0          STRB     r0,[r4,#0x7c0]        ;381
00004a  281e              CMP      r0,#0x1e              ;382
00004c  bf28              IT       CS                    ;384
00004e  f88417c0          STRBCS   r1,[r4,#0x7c0]        ;384
000052  2001              MOVS     r0,#1                 ;387
000054  f88417c6          STRB     r1,[r4,#0x7c6]        ;388
000058  bd10              POP      {r4,pc}
;;;394    
                          ENDP


                          AREA ||i.USB_DevInit||, CODE, READONLY, ALIGN=2

                  USB_DevInit PROC
;;;3519   
;;;3520   void USB_DevInit(void)
000000  493b              LDR      r1,|L33.240|
;;;3521   {
000002  b510              PUSH     {r4,lr}
;;;3522   #ifndef MODE_I2C
;;;3523   	Fncp_USB_IRQHandler = &USB_InterruptHandler;
000004  4839              LDR      r0,|L33.236|
;;;3524   	
;;;3525   	// suspend counter
;;;3526   	mUsbIdleCnt(7);
000006  6008              STR      r0,[r1,#0]  ; Fncp_USB_IRQHandler
000008  483a              LDR      r0,|L33.244|
00000a  2107              MOVS     r1,#7
00000c  f8c01124          STR      r1,[r0,#0x124]
;;;3527   
;;;3528   	mUsbUnPLGClr();
000010  f8d01114          LDR      r1,[r0,#0x114]
000014  f0210101          BIC      r1,r1,#1
000018  f8c01114          STR      r1,[r0,#0x114]
;;;3529   
;;;3530   	// Clear interrupt
;;;3531   	mUsbIntBusRstClr();
00001c  2101              MOVS     r1,#1
00001e  f8c0114c          STR      r1,[r0,#0x14c]
;;;3532   	mUsbIntSuspClr();
000022  2202              MOVS     r2,#2
000024  f8c0214c          STR      r2,[r0,#0x14c]
;;;3533   	mUsbIntResmClr();
000028  2204              MOVS     r2,#4
00002a  f8c0214c          STR      r2,[r0,#0x14c]
;;;3534   
;;;3535   	// Disable all fifo interrupt
;;;3536   	mUsbIntFIFO0_3OUTDis();
00002e  f8d02138          LDR      r2,[r0,#0x138]
000032  f04202ff          ORR      r2,r2,#0xff
000036  f8c02138          STR      r2,[r0,#0x138]
;;;3537   	mUsbIntFIFO0_3INDis();
00003a  f8d02138          LDR      r2,[r0,#0x138]
00003e  f4422270          ORR      r2,r2,#0xf0000
000042  f8c02138          STR      r2,[r0,#0x138]
;;;3538   
;;;3539   	// Clear all fifo
;;;3540   	mUsbClrAllFIFOSet();
000046  f8d02108          LDR      r2,[r0,#0x108]
00004a  f0420201          ORR      r2,r2,#1
00004e  f8c02108          STR      r2,[r0,#0x108]
;;;3541   
;;;3542   	mUsbIntWakebyVbusDis();
000052  f8d0213c          LDR      r2,[r0,#0x13c]
000056  f4426280          ORR      r2,r2,#0x400
00005a  f8c0213c          STR      r2,[r0,#0x13c]
;;;3543   	mUsbIntDevIdleDis();
00005e  f8d0213c          LDR      r2,[r0,#0x13c]
000062  f4427200          ORR      r2,r2,#0x200
000066  f8c0213c          STR      r2,[r0,#0x13c]
;;;3544   
;;;3545   	// Enable usb200 global interrupt
;;;3546   	mUsbGlobIntEnSet();
00006a  f8d02100          LDR      r2,[r0,#0x100]
00006e  f0420204          ORR      r2,r2,#4
000072  f8c02100          STR      r2,[r0,#0x100]
;;;3547   	mUsbChipEnSet();
000076  f8d02100          LDR      r2,[r0,#0x100]
00007a  f0420220          ORR      r2,r2,#0x20
00007e  f8c02100          STR      r2,[r0,#0x100]
;;;3548   	mUsbOTGDevFS();
000082  f8d02100          LDR      r2,[r0,#0x100]
000086  f4427200          ORR      r2,r2,#0x200
00008a  f8c02100          STR      r2,[r0,#0x100]
;;;3549   
;;;3550   	// Interrupt Mode
;;;3551   	mUsbIntPolarityLow();
00008e  f8502fc4          LDR      r2,[r0,#0xc4]!
000092  f0220208          BIC      r2,r2,#8
000096  f8402b0c          STR      r2,[r0],#0xc
;;;3552   
;;;3553   	
;;;3554   	// Virtual DMA
;;;3555   	mUsbVDMAEnable();
00009a  f8c01260          STR      r1,[r0,#0x260]
;;;3556   
;;;3557   	// Virtual DMA Mask - CXF Enable
;;;3558   	mUsbCXIntDmaErrEn();
00009e  f8d0125c          LDR      r1,[r0,#0x25c]
0000a2  f4213180          BIC      r1,r1,#0x10000
0000a6  f8c0125c          STR      r1,[r0,#0x25c]
;;;3559   	mUsbCXIntDmaFinishEn();
0000aa  f8d0125c          LDR      r1,[r0,#0x25c]
0000ae  f0210101          BIC      r1,r1,#1
0000b2  f8c0125c          STR      r1,[r0,#0x25c]
;;;3560   	
;;;3561   
;;;3562   	// RemoteWakeup
;;;3563   	mUsbRmWkupSet(); 
0000b6  6b01              LDR      r1,[r0,#0x30]
0000b8  f0410101          ORR      r1,r1,#1
0000bc  6301              STR      r1,[r0,#0x30]
;;;3564   
;;;3565   	// Clear Suspend
;;;3566   	mUsbClearSuspend();
0000be  6b01              LDR      r1,[r0,#0x30]
0000c0  f0210108          BIC      r1,r1,#8
0000c4  6301              STR      r1,[r0,#0x30]
0000c6  480d              LDR      r0,|L33.252|
;;;3567   #endif
;;;3568   
;;;3569   #ifdef ADD_PEN //ADD_CUSTOM // NOTE : PENO Ñ¦à ¬ß¡Ø¸ Ã¼vÈÑ­ V=..
;;;3570       sptAlgorithmInfo = algorithm_GetInfo();
;;;3571   #endif
;;;3572   
;;;3573   	// Queue
;;;3574   	StaticQueue_Init(&g_Queue_Common);
0000c8  4c0b              LDR      r4,|L33.248|
0000ca  f24071bc          MOV      r1,#0x7bc
0000ce  6800              LDR      r0,[r0,#0]
0000d0  6020              STR      r0,[r4,#0]
0000d2  1d20              ADDS     r0,r4,#4
0000d4  f7fffffe          BL       __aeabi_memclr
0000d8  2000              MOVS     r0,#0
0000da  f88407c0          STRB     r0,[r4,#0x7c0]
0000de  f88407c1          STRB     r0,[r4,#0x7c1]
0000e2  f8c407c2          STR      r0,[r4,#0x7c2]
0000e6  f88407c6          STRB     r0,[r4,#0x7c6]
;;;3575   	return;
;;;3576   }
0000ea  bd10              POP      {r4,pc}
;;;3577   
                          ENDP

                  |L33.236|
                          DCD      USB_InterruptHandler
                  |L33.240|
                          DCD      Fncp_USB_IRQHandler
                  |L33.244|
                          DCD      0x40030000
                  |L33.248|
                          DCD      ||.bss||+0x208
                  |L33.252|
                          DCD      ||i.StaticQueue_Init||+0x34

                          AREA ||i.USB_InterruptHandler||, CODE, READONLY, ALIGN=2

                  USB_InterruptHandler PROC
;;;3140   
;;;3141   void USB_InterruptHandler(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;3142   {
;;;3143   #ifndef MODE_I2C
;;;3144   	g_IntGroup = mUsbIntGroupRegRd();	// 0x140
000004  4efe              LDR      r6,|L34.1024|
000006  f8d60140          LDR      r0,[r6,#0x140]
00000a  f8dfb3f8          LDR      r11,|L34.1028|
;;;3145   //	F_GPB11();
;;;3146   	// EP0
;;;3147   	if (g_IntGroup & BIT0)
00000e  f0100f01          TST      r0,#1
;;;3148   	{
;;;3149   		g_IntEP0 = mUsbIntSrc0Rd(); // 0x144
;;;3150   
;;;3151   		if (g_IntEP0 & BIT0)
;;;3152   		{
;;;3153   			//if ((g_CheckVDMAComplete_Touch == DMA_READY) && (g_CheckVDMAComplete_Custom == DMA_READY) && (g_CheckVDMAComplete_Pen == DMA_READY))
;;;3154   			if ((g_CXF_Done == CXF_STATUS__NORMAL) || (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3155   			{
;;;3156   				g_CXF_Done = CXF_STATUS__DOING;
000012  f04f0801          MOV      r8,#1
000016  f8cb002c          STR      r0,[r11,#0x2c]        ;3142  ; g_IntGroup
00001a  d027              BEQ      |L34.108|
00001c  f8d61144          LDR      r1,[r6,#0x144]        ;3149
000020  f8cb1038          STR      r1,[r11,#0x38]        ;3151  ; g_IntEP0
000024  f0110f01          TST      r1,#1                 ;3151
000028  d020              BEQ      |L34.108|
00002a  f89b1002          LDRB     r1,[r11,#2]           ;3154  ; g_CXF_Done
00002e  2900              CMP      r1,#0                 ;3154
000030  bf18              IT       NE                    ;3154
000032  2903              CMPNE    r1,#3                 ;3154
000034  d11a              BNE      |L34.108|
000036  f88b8002          STRB     r8,[r11,#2]
;;;3157   
;;;3158   				mUsbCXIntDmaErrEn();
00003a  f8d6132c          LDR      r1,[r6,#0x32c]
00003e  f4213180          BIC      r1,r1,#0x10000
000042  f8c6132c          STR      r1,[r6,#0x32c]
;;;3159   				mUsbCXIntDmaFinishEn();
000046  f8d6132c          LDR      r1,[r6,#0x32c]
00004a  f0210101          BIC      r1,r1,#1
00004e  f8c6132c          STR      r1,[r6,#0x32c]
;;;3160   
;;;3161   				mUsbCXDmaConfig(8, DIRECTION_OUT); // Memory To FIFO
000052  f44f6100          MOV      r1,#0x800
000056  f8c61300          STR      r1,[r6,#0x300]
;;;3162   				mUsbCXDmaAddr((uint32_t)g_EP0_Packet);
00005a  49eb              LDR      r1,|L34.1032|
00005c  f8c61304          STR      r1,[r6,#0x304]
;;;3163   				mUsbCXDmaStart();
000060  f8d61300          LDR      r1,[r6,#0x300]
000064  f0410101          ORR      r1,r1,#1
000068  f8c61300          STR      r1,[r6,#0x300]
                  |L34.108|
;;;3164   			}
;;;3165   
;;;3166   		}
;;;3167   	}
;;;3168   
;;;3169   
;;;3170   
;;;3171   	// Virtual DMA 
;;;3172   	if (g_IntGroup & BIT3)
00006c  f0100f08          TST      r0,#8
;;;3173   	{
;;;3174   		g_IntVDMA = mUsbIntSrc3Rd();
;;;3175   
;;;3176   		// CXF Complete
;;;3177   		if (g_IntVDMA & BIT0)
;;;3178   		{
;;;3179   			// DMA [ß·L à Ø¡ Ö‡Ñ­ Ó­ Öšß¡ g_CXF_Done Ü³Æ‚ Ðª; CXF_STATUS__NEED_TO_DONE 8ØŽ Ú™Ó£ßŸ È‘Õ™.
;;;3180   			if (g_EP0_Check == 1)
;;;3181   			{
;;;3182   				// Buffer G Å©Ò¢ Ø¸Å­ Ã³Ø® ÈŸÑ…Óª Host G à ¤Ã» Å©Ò¢ Ø¸Å­ Ã³Ø® ÈŸ8Ù© Done !!
;;;3183   				if ((g_EP0_Offset == g_EP0_BufferLength) || (g_EP0_Offset == g_pSetupPacket->wLength))
;;;3184   				{
;;;3185   					// Cx Done!!!
;;;3186   					g_CXF_Done = CXF_STATUS__NEED_TO_DONE;
000070  f04f0902          MOV      r9,#2
000074  f04f0700          MOV      r7,#0
000078  f0008101          BEQ.W    |L34.638|
00007c  f8d60328          LDR      r0,[r6,#0x328]        ;3174
;;;3187   
;;;3188   					g_EP0_Offset = 0;
;;;3189   					g_EP0_Remain = 0;
;;;3190   					g_EP0_BufferLength = 0;
;;;3191   				}
;;;3192   
;;;3193   				g_EP0_Check = 0;
;;;3194   			}
;;;3195   
;;;3196   			if (g_CXF_Done == CXF_STATUS__NEED_TO_DONE)
;;;3197   			{
;;;3198   				mUsbCXDmaFinishClr();
;;;3199   				mUsbCXDmaErrClr();
000080  f44f3a80          MOV      r10,#0x10000
000084  f0100f01          TST      r0,#1                 ;3177
000088  f8cb0034          STR      r0,[r11,#0x34]        ;3177  ; g_IntVDMA
00008c  d01e              BEQ      |L34.204|
00008e  f89b1005          LDRB     r1,[r11,#5]           ;3180  ; g_EP0_Check
000092  2901              CMP      r1,#1                 ;3180
000094  d114              BNE      |L34.192|
000096  f8bb200c          LDRH     r2,[r11,#0xc]         ;3183  ; g_EP0_BufferLength
00009a  f8db1024          LDR      r1,[r11,#0x24]        ;3183  ; g_EP0_Offset
00009e  4291              CMP      r1,r2                 ;3183
0000a0  d004              BEQ      |L34.172|
0000a2  f8db201c          LDR      r2,[r11,#0x1c]        ;3183  ; g_pSetupPacket
0000a6  88d2              LDRH     r2,[r2,#6]            ;3183
0000a8  428a              CMP      r2,r1                 ;3183
0000aa  d107              BNE      |L34.188|
                  |L34.172|
0000ac  f88b9002          STRB     r9,[r11,#2]           ;3186
0000b0  f8cb7024          STR      r7,[r11,#0x24]        ;3189  ; g_EP0_Offset
0000b4  f8cb7028          STR      r7,[r11,#0x28]        ;3190  ; g_EP0_Remain
0000b8  f8ab700c          STRH     r7,[r11,#0xc]         ;3190
                  |L34.188|
0000bc  f88b7005          STRB     r7,[r11,#5]           ;3193
                  |L34.192|
0000c0  f89b1002          LDRB     r1,[r11,#2]           ;3196  ; g_CXF_Done
0000c4  2902              CMP      r1,#2                 ;3196
0000c6  d045              BEQ      |L34.340|
;;;3200   				mUsbCXIntDmaFinishDis();
;;;3201   				mUsbEP0DoneSet();
;;;3202   
;;;3203   				g_CXF_Done = CXF_STATUS__COMPLETE_DONE;
;;;3204   
;;;3205   				// DMA [ß·L à Ø¡ Ö‡Ñ­ Ó­ Öšß¡ Ñ¼Øƒ Flag Ø¦ Ú™Ó£ßŸ È‘Õ™.
;;;3206   				SetupPacket_AfterCheck(g_pSetupPacket);
;;;3207   
;;;3208   				memset(g_pSetupPacket, 0, sizeof(SETUP_PACKET));
;;;3209   				return;
;;;3210   			}
;;;3211   			else if (g_CXF_Done == CXF_STATUS__DOING)
0000c8  2901              CMP      r1,#1
0000ca  d069              BEQ      |L34.416|
                  |L34.204|
;;;3212   			{
;;;3213   				//if ((g_CheckVDMAComplete_Touch == DMA_READY) && (g_CheckVDMAComplete_Custom == DMA_READY) && (g_CheckVDMAComplete_Pen == DMA_READY))
;;;3214   				{
;;;3215   					mUsbCXDmaFinishClr();
;;;3216   					mUsbCXDmaErrClr();
;;;3217   					mUsbCXIntDmaFinishDis();
;;;3218   
;;;3219   					EP0_SetupPacket();
;;;3220   					return;
;;;3221   				}
;;;3222   			}
;;;3223   		}
;;;3224   
;;;3225   #ifdef ADD_TOUCH
;;;3226   		// FIFO Complete - MultiTouch
;;;3227   		if (g_IntVDMA & (BIT1 << TOUCH_FIFO_IN))
0000cc  f0100f04          TST      r0,#4
0000d0  d010              BEQ      |L34.244|
;;;3228   		{
;;;3229   			mUsbEXDmaFinishClr(TOUCH_FIFO_IN);
0000d2  2104              MOVS     r1,#4
0000d4  f8c61328          STR      r1,[r6,#0x328]
;;;3230   			mUsbEXIntDmaErrDis(TOUCH_FIFO_IN);
0000d8  f8d6132c          LDR      r1,[r6,#0x32c]
0000dc  f4412180          ORR      r1,r1,#0x40000
0000e0  f8c6132c          STR      r1,[r6,#0x32c]
;;;3231   			mUsbEXIntDmaFinishDis(TOUCH_FIFO_IN);
0000e4  f8d6132c          LDR      r1,[r6,#0x32c]
0000e8  f0410104          ORR      r1,r1,#4
0000ec  f8c6132c          STR      r1,[r6,#0x32c]
;;;3232   
;;;3233   			// Touch DMA Ã³Ø®Ð¡ à Ø¡ Ö‡ßº=; Ç¥ÞƒÈ‘Õ™.
;;;3234   			g_CheckVDMAComplete_Touch = DMA_READY;
0000f0  f88b8006          STRB     r8,[r11,#6]
                  |L34.244|
;;;3235   		}
;;;3236   #endif
;;;3237   		
;;;3238   		
;;;3239   #ifdef ADD_CUSTOM
;;;3240   		// FIFO Complete - Custom OUT
;;;3241   		if (g_IntVDMA & (BIT1 << CUSTOM_FIFO_OUT))
0000f4  f0100f08          TST      r0,#8
0000f8  d066              BEQ      |L34.456|
0000fa  2008              MOVS     r0,#8
0000fc  f8c60328          STR      r0,[r6,#0x328]
000100  f8d6032c          LDR      r0,[r6,#0x32c]
000104  f4402000          ORR      r0,r0,#0x80000
000108  f8c6032c          STR      r0,[r6,#0x32c]
00010c  f8d6032c          LDR      r0,[r6,#0x32c]
000110  f0400008          ORR      r0,r0,#8
000114  f8c6032c          STR      r0,[r6,#0x32c]
000118  f8d6032c          LDR      r0,[r6,#0x32c]
00011c  f4202000          BIC      r0,r0,#0x80000
000120  f8c6032c          STR      r0,[r6,#0x32c]
000124  f8d6032c          LDR      r0,[r6,#0x32c]
000128  f0200008          BIC      r0,r0,#8
00012c  f8c6032c          STR      r0,[r6,#0x32c]
000130  f44f4080          MOV      r0,#0x4000
000134  f8c60318          STR      r0,[r6,#0x318]
000138  48b4              LDR      r0,|L34.1036|
00013a  f8c6031c          STR      r0,[r6,#0x31c]
00013e  f8d60318          LDR      r0,[r6,#0x318]
000142  f0400001          ORR      r0,r0,#1
000146  f8c60318          STR      r0,[r6,#0x318]
;;;3242   		{
;;;3243   			// Custom OUT
;;;3244   			RecieveCustomData_DMA();
;;;3245   			
;;;3246   #ifdef JOSH3_LOOP_BACK_TEST
;;;3247   			g_CustomBuffer[0] = HID_REPORT_ID__CUSTOM_IN;
;;;3248   			SendCustomData_USB((UINT8*)g_CustomBuffer);
;;;3249   #else
;;;3250   			// App Call
;;;3251   			RecieveCustomData(g_CustomBuffer);
00014a  48b0              LDR      r0,|L34.1036|
00014c  7801              LDRB     r1,[r0,#0]
00014e  2909              CMP      r1,#9
000150  d034              BEQ      |L34.444|
000152  e05e              B        |L34.530|
                  |L34.340|
000154  f8c68328          STR      r8,[r6,#0x328]        ;3198
000158  f8c6a328          STR      r10,[r6,#0x328]       ;3199
00015c  f8d6032c          LDR      r0,[r6,#0x32c]        ;3200
000160  f0400001          ORR      r0,r0,#1              ;3200
000164  f8c6032c          STR      r0,[r6,#0x32c]        ;3200
000168  f8d60120          LDR      r0,[r6,#0x120]        ;3201
00016c  f0400001          ORR      r0,r0,#1              ;3201
000170  f8c60120          STR      r0,[r6,#0x120]        ;3201
000174  2003              MOVS     r0,#3                 ;3203
000176  f88b0002          STRB     r0,[r11,#2]           ;3203
00017a  f8db001c          LDR      r0,[r11,#0x1c]        ;3203  ; g_pSetupPacket
00017e  7841              LDRB     r1,[r0,#1]            ;3203
000180  2901              CMP      r1,#1                 ;3203
000182  d109              BNE      |L34.408|
000184  8841              LDRH     r1,[r0,#2]            ;3206
000186  f401427f          AND      r2,r1,#0xff00         ;3206
00018a  f5b27f40          CMP      r2,#0x300             ;3206
00018e  bf02              ITTT     EQ                    ;3206
000190  b2c9              UXTBEQ   r1,r1                 ;3206
000192  2908              CMPEQ    r1,#8                 ;3206
000194  f88b8001          STRBEQ   r8,[r11,#1]           ;3206
                  |L34.408|
000198  e8bd5ff0          POP      {r4-r12,lr}           ;3208
00019c  f7ffbffe          B.W      __ARM_common_memclr4_8
                  |L34.416|
0001a0  f8c68328          STR      r8,[r6,#0x328]        ;3215
0001a4  f8c6a328          STR      r10,[r6,#0x328]       ;3216
0001a8  f8d6032c          LDR      r0,[r6,#0x32c]        ;3217
0001ac  f0400001          ORR      r0,r0,#1              ;3217
0001b0  f8c6032c          STR      r0,[r6,#0x32c]        ;3217
0001b4  e8bd5ff0          POP      {r4-r12,lr}           ;3219
0001b8  f7ffbffe          B.W      EP0_SetupPacket
                  |L34.444|
0001bc  7841              LDRB     r1,[r0,#1]            ;3219
0001be  f0110f01          TST      r1,#1                 ;3219
0001c2  d002              BEQ      |L34.458|
0001c4  f7fffffe          BL       HidReadWrite__Read
                  |L34.456|
0001c8  e023              B        |L34.530|
                  |L34.458|
0001ca  2500              MOVS     r5,#0                 ;3219
0001cc  4604              MOV      r4,r0                 ;3219
0001ce  462b              MOV      r3,r5                 ;3219
0001d0  462a              MOV      r2,r5                 ;3219
0001d2  4629              MOV      r1,r5                 ;3219
0001d4  2001              MOVS     r0,#1                 ;3219
0001d6  f7fffffe          BL       protocol_hid_mapping_emul_handler
0001da  2300              MOVS     r3,#0                 ;3219
0001dc  461a              MOV      r2,r3                 ;3219
0001de  4619              MOV      r1,r3                 ;3219
0001e0  2004              MOVS     r0,#4                 ;3219
0001e2  f7fffffe          BL       protocol_hid_mapping_emul_handler
0001e6  8860              LDRH     r0,[r4,#2]            ;3219
0001e8  2800              CMP      r0,#0                 ;3219
0001ea  d90c              BLS      |L34.518|
                  |L34.492|
0001ec  1960              ADDS     r0,r4,r5              ;3219
0001ee  1c6d              ADDS     r5,r5,#1              ;3219
0001f0  7903              LDRB     r3,[r0,#4]            ;3219
0001f2  b2a9              UXTH     r1,r5                 ;3219
0001f4  f44f5280          MOV      r2,#0x1000            ;3219
0001f8  2003              MOVS     r0,#3                 ;3219
0001fa  f7fffffe          BL       protocol_hid_mapping_emul_handler
0001fe  8860              LDRH     r0,[r4,#2]            ;3219
000200  b2ad              UXTH     r5,r5                 ;3219
000202  42a8              CMP      r0,r5                 ;3219
000204  d8f2              BHI      |L34.492|
                  |L34.518|
000206  2300              MOVS     r3,#0                 ;3219
000208  461a              MOV      r2,r3                 ;3219
00020a  4619              MOV      r1,r3                 ;3219
00020c  2002              MOVS     r0,#2                 ;3219
00020e  f7fffffe          BL       protocol_hid_mapping_emul_handler
                  |L34.530|
;;;3252   #endif
;;;3253   		}
;;;3254   
;;;3255   		// FIFO Complete - Custom IN
;;;3256   		if (g_IntVDMA & (BIT1 << CUSTOM_FIFO_IN))
000212  f8db0034          LDR      r0,[r11,#0x34]  ; g_IntVDMA
000216  f0100f02          TST      r0,#2
00021a  d00f              BEQ      |L34.572|
;;;3257   		{
;;;3258   			mUsbEXDmaFinishClr(CUSTOM_FIFO_IN);
00021c  f8c69328          STR      r9,[r6,#0x328]
;;;3259   			mUsbEXIntDmaErrDis(CUSTOM_FIFO_IN);
000220  f8d6132c          LDR      r1,[r6,#0x32c]
000224  f4413100          ORR      r1,r1,#0x20000
000228  f8c6132c          STR      r1,[r6,#0x32c]
;;;3260   			mUsbEXIntDmaFinishDis(CUSTOM_FIFO_IN);
00022c  f8d6132c          LDR      r1,[r6,#0x32c]
000230  f0410102          ORR      r1,r1,#2
000234  f8c6132c          STR      r1,[r6,#0x32c]
;;;3261   
;;;3262   			// Custom DMA Ã³Ø®Ð¡ à Ø¡ Ö‡ßº=; Ç¥ÞƒÈ‘Õ™.
;;;3263   			g_CheckVDMAComplete_Custom = DMA_READY;
000238  f88b8009          STRB     r8,[r11,#9]
                  |L34.572|
;;;3264   		}
;;;3265   #endif
;;;3266   		
;;;3267   		
;;;3268   		
;;;3269   #ifdef ADD_PEN
;;;3270   		// FIFO Complete - Pen
;;;3271   		if (g_IntVDMA & (BIT1 << PEN_FIFO_IN))
;;;3272   		{
;;;3273   			mUsbEXDmaFinishClr(PEN_FIFO_IN);
;;;3274   			mUsbEXIntDmaErrDis(PEN_FIFO_IN);
;;;3275   			mUsbEXIntDmaFinishDis(PEN_FIFO_IN);
;;;3276   
;;;3277   			// Touch DMA Ã³Ø®Ð¡ à Ø¡ Ö‡ßº=; Ç¥ÞƒÈ‘Õ™.
;;;3278   			g_CheckVDMAComplete_Pen = DMA_READY;
;;;3279   		}
;;;3280   #endif
;;;3281   
;;;3282   
;;;3283   
;;;3284   #ifdef ADD_BULK_CUSTOM
;;;3285   		// FIFO Complete - Bulk Custom OUT
;;;3286   		if (g_IntVDMA & (BIT1 << BULK_CUSTOM_FIFO_OUT))
;;;3287   		{
;;;3288   			// Bulk Custom OUT
;;;3289   			RecieveBulkCustomData_DMA();
;;;3290   
;;;3291   			// App Call
;;;3292   			RecieveBulkCustomData(g_BulkCustomBuffer);
;;;3293   		}
;;;3294   
;;;3295   		// FIFO Complete - Bulk Custom IN
;;;3296   		if (g_IntVDMA & (BIT1 << BULK_CUSTOM_FIFO_IN))
;;;3297   		{
;;;3298   			mUsbEXDmaFinishClr(BULK_CUSTOM_FIFO_IN);
;;;3299   			mUsbEXIntDmaErrDis(BULK_CUSTOM_FIFO_IN);
;;;3300   			mUsbEXIntDmaFinishDis(BULK_CUSTOM_FIFO_IN);
;;;3301   
;;;3302   			// Bulk Custom DMA Ã³Ø®Ð¡ à Ø¡ Ö‡ßº=; Ç¥ÞƒÈ‘Õ™.
;;;3303   			g_CheckVDMAComplete_BulkCustom = DMA_READY;
;;;3304   		}
;;;3305   #endif
;;;3306   
;;;3307   
;;;3308   
;;;3309   		// CXF Error
;;;3310   		if (g_IntVDMA & BIT16)
00023c  f4103f80          TST      r0,#0x10000
;;;3311   		{
;;;3312   			mUsbCXDmaErrClr();
000240  bf18              IT       NE
000242  f8c6a328          STRNE    r10,[r6,#0x328]
;;;3313   		}
;;;3314   
;;;3315   		// FIFO 0 Error
;;;3316   		if (g_IntVDMA & BIT17)
000246  f4103f00          TST      r0,#0x20000
;;;3317   		{
;;;3318   			mUsbEXDmaErrClr(0);
00024a  bf1c              ITT      NE
00024c  f44f3100          MOVNE    r1,#0x20000
000250  f8c61328          STRNE    r1,[r6,#0x328]
;;;3319   		}
;;;3320   
;;;3321   		// FIFO 1 Error
;;;3322   		if (g_IntVDMA & BIT18)
000254  f4102f80          TST      r0,#0x40000
;;;3323   		{
;;;3324   			mUsbEXDmaErrClr(1);
000258  bf1c              ITT      NE
00025a  f44f2180          MOVNE    r1,#0x40000
00025e  f8c61328          STRNE    r1,[r6,#0x328]
;;;3325   		}
;;;3326   
;;;3327   		// FIFO 2 Error
;;;3328   		if (g_IntVDMA & BIT19)
000262  f4102f00          TST      r0,#0x80000
;;;3329   		{
;;;3330   			mUsbEXDmaErrClr(2);
000266  bf1c              ITT      NE
000268  f44f2100          MOVNE    r1,#0x80000
00026c  f8c61328          STRNE    r1,[r6,#0x328]
;;;3331   		}
;;;3332   
;;;3333   		// FIFO 3 Error
;;;3334   		if (g_IntVDMA & BIT20)
000270  f4101f80          TST      r0,#0x100000
;;;3335   		{
;;;3336   			mUsbEXDmaErrClr(3);
000274  bf1c              ITT      NE
000276  f44f1080          MOVNE    r0,#0x100000
00027a  f8c60328          STRNE    r0,[r6,#0x328]
                  |L34.638|
;;;3337   		}
;;;3338   	}
;;;3339   
;;;3340   
;;;3341   
;;;3342   	// USB Controll
;;;3343   	if (g_IntGroup & BIT2)
00027e  f89b002c          LDRB     r0,[r11,#0x2c]  ; g_IntGroup
000282  f0100f04          TST      r0,#4
000286  d07d              BEQ      |L34.900|
;;;3344   	{
;;;3345   		g_IntControl = mUsbIntSrc2Rd();
000288  f8d6014c          LDR      r0,[r6,#0x14c]
;;;3346   
;;;3347   		// USBRST_INT
;;;3348   		if (g_IntControl & BIT0)
;;;3349   		{
;;;3350   			g_RemoteWakeup = 0;
;;;3351   			g_Configuration = 0;
;;;3352   			g_HIDReady = 0;
;;;3353   
;;;3354   			// Clear
;;;3355   			mUsbIntBusRstClr();
;;;3356   
;;;3357   			// Addr
;;;3358   			mUsbDevAddrSet(0);
;;;3359   
;;;3360   			// FIFO
;;;3361   			mUsbClrAllFIFOSet();
;;;3362   
;;;3363   			// EP0 FIFO Clear
;;;3364   			mUsbCxFClr();
;;;3365   
;;;3366   			// Full Speed
;;;3367   			mUsbOTGDevFS();
;;;3368   
;;;3369   			// Init
;;;3370   			USB_ResetResume();
;;;3371   			
;;;3372   			// Queue
;;;3373   			StaticQueue_Init(&g_Queue_Common);
;;;3374   
;;;3375   			// SelfPowerd, RemoteWakeup Û±È°ÜºÈ­ Ü³Æ‚
;;;3376   			g_Status[0].Status.Global.SelfPowered = 1;
00028c  4d60              LDR      r5,|L34.1040|
;;;3377   			g_Status[0].Status.Global.RemoteWakeup = 0;
;;;3378   
;;;3379   			wakeupSignalEn = NO;
00028e  f8dfa184          LDR      r10,|L34.1044|
000292  f0100f01          TST      r0,#1                 ;3348
000296  f8cb0030          STR      r0,[r11,#0x30]        ;3348  ; g_IntControl
00029a  d03b              BEQ      |L34.788|
00029c  f88b7003          STRB     r7,[r11,#3]           ;3350
0002a0  f88b7000          STRB     r7,[r11,#0]           ;3351
0002a4  f88b7001          STRB     r7,[r11,#1]           ;3352
0002a8  f8c6814c          STR      r8,[r6,#0x14c]        ;3355
0002ac  f8c67104          STR      r7,[r6,#0x104]        ;3358
0002b0  f8d60108          LDR      r0,[r6,#0x108]        ;3361
0002b4  f0400001          ORR      r0,r0,#1              ;3361
0002b8  f8c60108          STR      r0,[r6,#0x108]        ;3361
0002bc  f8d60120          LDR      r0,[r6,#0x120]        ;3364
0002c0  f0400008          ORR      r0,r0,#8              ;3364
0002c4  f8c60120          STR      r0,[r6,#0x120]        ;3364
0002c8  f8d60100          LDR      r0,[r6,#0x100]        ;3367
0002cc  f4407000          ORR      r0,r0,#0x200          ;3367
0002d0  f8c60100          STR      r0,[r6,#0x100]        ;3367
0002d4  f7fffffe          BL       USB_ResetResume
0002d8  484f              LDR      r0,|L34.1048|
0002da  f5057402          ADD      r4,r5,#0x208          ;3373
0002de  f24071bc          MOV      r1,#0x7bc             ;3373
0002e2  6800              LDR      r0,[r0,#0]            ;3373
0002e4  6020              STR      r0,[r4,#0]            ;3373
0002e6  1d20              ADDS     r0,r4,#4              ;3373
0002e8  f7fffffe          BL       __aeabi_memclr
0002ec  f88477c0          STRB     r7,[r4,#0x7c0]        ;3373
0002f0  f88477c1          STRB     r7,[r4,#0x7c1]        ;3373
0002f4  f8c477c2          STR      r7,[r4,#0x7c2]        ;3373
0002f8  f88477c6          STRB     r7,[r4,#0x7c6]        ;3373
0002fc  7828              LDRB     r0,[r5,#0]            ;3376  ; g_Status
0002fe  f0200002          BIC      r0,r0,#2              ;3376
000302  f0400001          ORR      r0,r0,#1              ;3377
000306  7028              STRB     r0,[r5,#0]            ;3377
;;;3380   			frameCntForUSBAbnormal = 0;
000308  4844              LDR      r0,|L34.1052|
00030a  f88a7000          STRB     r7,[r10,#0]           ;3379
;;;3381   			abnormalUSBOperating = NO;
00030e  6007              STR      r7,[r0,#0]  ; frameCntForUSBAbnormal
000310  4843              LDR      r0,|L34.1056|
000312  7007              STRB     r7,[r0,#0]
                  |L34.788|
;;;3382   
;;;3383   //			g_ScanTime_Recovery = 0;
;;;3384   //			g_StartTime_Recovery = 0;
;;;3385   //			GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus);
;;;3386   //			Recovery_ClearSus_Flag = 1;
;;;3387   		}
;;;3388   
;;;3389   		// SUSP_INT
;;;3390   		if (g_IntControl & BIT1)
000314  f8db0030          LDR      r0,[r11,#0x30]  ; g_IntControl
000318  f0100f02          TST      r0,#2
00031c  d013              BEQ      |L34.838|
;;;3391   		{
;;;3392   			g_Configuration = 0;
00031e  f88b7000          STRB     r7,[r11,#0]
;;;3393   			g_HIDReady = 0;
000322  f88b7001          STRB     r7,[r11,#1]
;;;3394   
;;;3395   			mUsbIntSuspClr();
000326  f8c6914c          STR      r9,[r6,#0x14c]
;;;3396   
;;;3397   			if (g_Status[0].Status.Global.RemoteWakeup == 1)
00032a  7829              LDRB     r1,[r5,#0]  ; g_Status
00032c  f0110f02          TST      r1,#2
000330  d009              BEQ      |L34.838|
;;;3398   			{
;;;3399   				g_RemoteWakeup = 1;
000332  f88b8003          STRB     r8,[r11,#3]
;;;3400   				g_SuspendOn = 1;
000336  f88b8004          STRB     r8,[r11,#4]
;;;3401   
;;;3402   				// Suspend
;;;3403   				mUsbGoSuspend();
00033a  f8d61100          LDR      r1,[r6,#0x100]
00033e  f0410108          ORR      r1,r1,#8
000342  f8c61100          STR      r1,[r6,#0x100]
                  |L34.838|
;;;3404   			}
;;;3405   
;;;3406   		}
;;;3407   
;;;3408   		// RESM_INT
;;;3409   		if (g_IntControl & BIT2)
000346  f0100f04          TST      r0,#4
00034a  d02e              BEQ      |L34.938|
;;;3410   		{
;;;3411   			mUsbIntResmClr();
00034c  2004              MOVS     r0,#4
00034e  f8c6014c          STR      r0,[r6,#0x14c]
;;;3412   
;;;3413   //			if (g_RemoteWakeup == 1)
;;;3414   			{
;;;3415   				g_RemoteWakeup = 0;
;;;3416   
;;;3417   				mUsbRemoteWakeUpSet_SEL_WAKEUP();
000352  0700              LSLS     r0,r0,#28
000354  f88b7003          STRB     r7,[r11,#3]           ;3415
000358  f8101f6c          LDRB     r1,[r0,#0x6c]!
00035c  f0210110          BIC      r1,r1,#0x10
000360  7001              STRB     r1,[r0,#0]
;;;3418   				mUsbRemoteWakeUpSet_0();
000362  7801              LDRB     r1,[r0,#0]
000364  f0210102          BIC      r1,r1,#2
000368  7001              STRB     r1,[r0,#0]
;;;3419   
;;;3420   				g_ScanTime_Recovery = 0;
00036a  2100              MOVS     r1,#0
00036c  f8cb7044          STR      r7,[r11,#0x44]  ; g_ScanTime_Recovery
000370  e9cb1120          STRD     r1,r1,[r11,#0x80]
;;;3421   				g_StartTime_Recovery = 0;
;;;3422   				GetScanTime(&g_StartTime_Recovery_ClearSus, &g_ScanTime_Recovery_ClearSus);
000374  492b              LDR      r1,|L34.1060|
000376  f1010040          ADD      r0,r1,#0x40
00037a  f7fffffe          BL       GetScanTime
;;;3423   				Recovery_ClearSus_Flag = 1;
00037e  f88b8008          STRB     r8,[r11,#8]
;;;3424   
;;;3425   				wakeupSignalEn = NO;
000382  e000              B        |L34.902|
                  |L34.900|
000384  e01b              B        |L34.958|
                  |L34.902|
;;;3426   				frameCntForUSBAbnormal = 0;
000386  4825              LDR      r0,|L34.1052|
000388  f88a7000          STRB     r7,[r10,#0]           ;3425
;;;3427   				abnormalUSBOperating = NO;
00038c  6007              STR      r7,[r0,#0]  ; frameCntForUSBAbnormal
00038e  4824              LDR      r0,|L34.1056|
000390  7007              STRB     r7,[r0,#0]
;;;3428   
;;;3429   				// Clear Suspend
;;;3430   				mUsbClearSuspend();
000392  f8d60100          LDR      r0,[r6,#0x100]
000396  f0200008          BIC      r0,r0,#8
00039a  f8c60100          STR      r0,[r6,#0x100]
;;;3431   			}
;;;3432   
;;;3433   
;;;3434   			g_Configuration=1;
00039e  f88b8000          STRB     r8,[r11,#0]
;;;3435   			g_HIDReady=1;
0003a2  f88b8001          STRB     r8,[r11,#1]
;;;3436   
;;;3437   			// Init
;;;3438   			USB_ResetResume();
0003a6  f7fffffe          BL       USB_ResetResume
                  |L34.938|
;;;3439   		}
;;;3440   
;;;3441   		// DMA_COMPLT
;;;3442   		if (g_IntControl & BIT7)
0003aa  f89b0030          LDRB     r0,[r11,#0x30]  ; g_IntControl
0003ae  f0100f80          TST      r0,#0x80
0003b2  d004              BEQ      |L34.958|
;;;3443   		{
;;;3444   			// Finish
;;;3445   			mUsbIntDmaFinishClr();
0003b4  2080              MOVS     r0,#0x80
0003b6  f8c6014c          STR      r0,[r6,#0x14c]
;;;3446   
;;;3447   			// FIFO Control ÂŸÂ¶
;;;3448   			mUsbDMA2FIFOSel(0);
0003ba  f8c671c0          STR      r7,[r6,#0x1c0]
                  |L34.958|
;;;3449   		}
;;;3450   
;;;3451   	}
;;;3452   
;;;3453   
;;;3454   
;;;3455   
;;;3456   	if (g_IntGroup & BIT1)
0003be  f89b002c          LDRB     r0,[r11,#0x2c]  ; g_IntGroup
0003c2  f0100f02          TST      r0,#2
;;;3457   	{
;;;3458   		g_IntEP = mUsbIntSrc1Rd(); // 0x148
;;;3459   
;;;3460   #ifdef ADD_TOUCH
;;;3461   		// Multi Touch (IN)
;;;3462   		if (g_IntEP & (BIT16 << TOUCH_FIFO_IN))
;;;3463   		{
;;;3464   			if ((g_CheckVDMAComplete_Touch == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3465   			{
;;;3466   				mUsbIntF1INDis();
;;;3467   				DMATouchData_USB();
;;;3468   				return;
;;;3469   			}
;;;3470   		}
;;;3471   #endif
;;;3472   
;;;3473   #ifdef ADD_CUSTOM
;;;3474   		// Custom (IN)
;;;3475   		if (g_IntEP & (BIT16 << CUSTOM_FIFO_IN))
;;;3476   		{
;;;3477   			if ((g_CheckVDMAComplete_Custom == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3478   			{
;;;3479   				mUsbIntF0INDis();
;;;3480   				DMACustomData_USB();
;;;3481   				return;
;;;3482   			}
;;;3483   		}
;;;3484   #endif
;;;3485   
;;;3486   #ifdef ADD_PEN
;;;3487   		// Pen (IN)
;;;3488   		if (g_IntEP & (BIT16 << PEN_FIFO_IN))
;;;3489   		{
;;;3490   			if ((g_CheckVDMAComplete_Pen == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3491   			{
;;;3492   				mUsbIntF3INDis();
;;;3493   				DMAPenData_USB();
;;;3494   				return;
;;;3495   			}
;;;3496   		}
;;;3497   #endif
;;;3498   
;;;3499   #ifdef ADD_BULK_CUSTOM
;;;3500   		// Bulk Custom (IN)
;;;3501   		if (g_IntEP & (BIT16 << BULK_CUSTOM_FIFO_IN))
;;;3502   		{
;;;3503   			if ((g_CheckVDMAComplete_BulkCustom == DMA_NOT_READY) && (g_CXF_Done == CXF_STATUS__COMPLETE_DONE))
;;;3504   			{
;;;3505   				mUsbIntF0INDis();
;;;3506   				DMABulkData_USB();
;;;3507   				return;
;;;3508   			}
;;;3509   		}
;;;3510   #endif
;;;3511   
;;;3512   	}
;;;3513   
;;;3514   #endif
;;;3515   	return;
;;;3516   }
0003c6  bf08              IT       EQ
0003c8  e8bd9ff0          POPEQ    {r4-r12,pc}
0003cc  f8d60148          LDR      r0,[r6,#0x148]        ;3458
0003d0  f2440102          MOV      r1,#0x4002            ;3458
0003d4  f4103f00          TST      r0,#0x20000           ;3462
0003d8  f8cb003c          STR      r0,[r11,#0x3c]        ;3462  ; g_IntEP
0003dc  d007              BEQ      |L34.1006|
0003de  f89b2006          LDRB     r2,[r11,#6]           ;3464  ; g_CheckVDMAComplete_Touch
0003e2  2a00              CMP      r2,#0                 ;3464
0003e4  bf04              ITT      EQ                    ;3464
0003e6  f89b2002          LDRBEQ   r2,[r11,#2]           ;3464  ; g_CXF_Done
0003ea  2a03              CMPEQ    r2,#3                 ;3464
0003ec  d041              BEQ      |L34.1138|
                  |L34.1006|
0003ee  f4103f80          TST      r0,#0x10000           ;3475
0003f2  bf08              IT       EQ
0003f4  e8bd9ff0          POPEQ    {r4-r12,pc}
0003f8  f89b0009          LDRB     r0,[r11,#9]           ;3477  ; g_CheckVDMAComplete_Custom
0003fc  2800              CMP      r0,#0                 ;3477
0003fe  e013              B        |L34.1064|
                  |L34.1024|
                          DCD      0x40030000
                  |L34.1028|
                          DCD      ||.data||
                  |L34.1032|
                          DCD      ||.data||+0x6c
                  |L34.1036|
                          DCD      ||.bss||+0x27f5
                  |L34.1040|
                          DCD      ||.bss||
                  |L34.1044|
                          DCD      wakeupSignalEn
                  |L34.1048|
                          DCD      ||i.StaticQueue_Init||+0x34
                  |L34.1052|
                          DCD      frameCntForUSBAbnormal
                  |L34.1056|
                          DCD      abnormalUSBOperating
                  |L34.1060|
                          DCD      ||.data||+0x48
                  |L34.1064|
000428  bf06              ITTE     EQ                    ;3477
00042a  f89b0002          LDRBEQ   r0,[r11,#2]           ;3477  ; g_CXF_Done
00042e  2803              CMPEQ    r0,#3                 ;3477
000430  e8bd9ff0          POPNE    {r4-r12,pc}
000434  f8d60138          LDR      r0,[r6,#0x138]        ;3479
000438  f4403080          ORR      r0,r0,#0x10000        ;3479
00043c  f8c60138          STR      r0,[r6,#0x138]        ;3479
000440  f8d6032c          LDR      r0,[r6,#0x32c]        ;3479
000444  f4203000          BIC      r0,r0,#0x20000        ;3479
000448  f8c6032c          STR      r0,[r6,#0x32c]        ;3479
00044c  f8d6032c          LDR      r0,[r6,#0x32c]        ;3479
000450  f0200002          BIC      r0,r0,#2              ;3479
000454  f8c6032c          STR      r0,[r6,#0x32c]        ;3479
000458  f8c61308          STR      r1,[r6,#0x308]        ;3479
00045c  4814              LDR      r0,|L34.1200|
00045e  f8c6030c          STR      r0,[r6,#0x30c]        ;3479
000462  f8d60308          LDR      r0,[r6,#0x308]        ;3479
000466  f0400001          ORR      r0,r0,#1              ;3479
00046a  f8c60308          STR      r0,[r6,#0x308]        ;3479
00046e  e8bd9ff0          POP      {r4-r12,pc}
                  |L34.1138|
000472  f8d60138          LDR      r0,[r6,#0x138]        ;3466
000476  f4403000          ORR      r0,r0,#0x20000        ;3466
00047a  f8c60138          STR      r0,[r6,#0x138]        ;3466
00047e  f8d6032c          LDR      r0,[r6,#0x32c]        ;3466
000482  f4202080          BIC      r0,r0,#0x40000        ;3466
000486  f8c6032c          STR      r0,[r6,#0x32c]        ;3466
00048a  f8d6032c          LDR      r0,[r6,#0x32c]        ;3466
00048e  f0200004          BIC      r0,r0,#4              ;3466
000492  f8c6032c          STR      r0,[r6,#0x32c]        ;3466
000496  f8c61310          STR      r1,[r6,#0x310]        ;3466
00049a  4806              LDR      r0,|L34.1204|
00049c  f8c60314          STR      r0,[r6,#0x314]        ;3466
0004a0  f8d60310          LDR      r0,[r6,#0x310]        ;3466
0004a4  f0400001          ORR      r0,r0,#1              ;3466
0004a8  f8c60310          STR      r0,[r6,#0x310]        ;3466
0004ac  e8bd9ff0          POP      {r4-r12,pc}
;;;3517   
                          ENDP

                  |L34.1200|
                          DCD      ||.bss||+0x27f5
                  |L34.1204|
                          DCD      ||.bss||+0x11a

                          AREA ||i.USB_ResetResume||, CODE, READONLY, ALIGN=2

                  USB_ResetResume PROC
;;;3056   
;;;3057   void USB_ResetResume(void)
000000  482b              LDR      r0,|L35.176|
;;;3058   {
;;;3059   	// DMA
;;;3060   	mUsbVDMADisable();
000002  2100              MOVS     r1,#0
000004  f8c01330          STR      r1,[r0,#0x330]
;;;3061   	mUsbVDMAEnable();
000008  2101              MOVS     r1,#1
00000a  f8c01330          STR      r1,[r0,#0x330]
;;;3062   
;;;3063   #ifdef ADD_TOUCH
;;;3064   	mUsbEXDmaAbort(TOUCH_FIFO_IN);
00000e  f8d02310          LDR      r2,[r0,#0x310]
000012  f0420208          ORR      r2,r2,#8
000016  f8c02310          STR      r2,[r0,#0x310]
;;;3065   	mUsbEXDmaStop(TOUCH_FIFO_IN);
00001a  f8d02310          LDR      r2,[r0,#0x310]
00001e  f0220201          BIC      r2,r2,#1
000022  f8c02310          STR      r2,[r0,#0x310]
;;;3066   
;;;3067   	//g_ScanTime = 0;
;;;3068   	//g_StartTime = 0;
;;;3069   	g_CheckVDMAComplete_Touch = DMA_READY;
000026  4a23              LDR      r2,|L35.180|
000028  7191              STRB     r1,[r2,#6]
;;;3070   	mUsbIntF1INDis();
00002a  f8d03138          LDR      r3,[r0,#0x138]
00002e  f4433300          ORR      r3,r3,#0x20000
000032  f8c03138          STR      r3,[r0,#0x138]
;;;3071   #endif
;;;3072   
;;;3073   #ifdef ADD_PEN
;;;3074   	mUsbEXDmaAbort(PEN_FIFO_IN);
;;;3075   	mUsbEXDmaStop(PEN_FIFO_IN);
;;;3076   
;;;3077   	//g_ScanTime_Pen = 0;
;;;3078   	//g_StartTime_Pen = 0;
;;;3079   	g_CheckVDMAComplete_Pen = DMA_READY;
;;;3080   	mUsbIntF3INDis();
;;;3081   #endif
;;;3082   
;;;3083   #ifdef ADD_CUSTOM
;;;3084   	// Custom IN
;;;3085   	mUsbEXDmaAbort(CUSTOM_FIFO_IN);
000036  f8d03308          LDR      r3,[r0,#0x308]
00003a  f0430308          ORR      r3,r3,#8
00003e  f8c03308          STR      r3,[r0,#0x308]
;;;3086   	mUsbEXDmaStop(CUSTOM_FIFO_IN);
000042  f8d03308          LDR      r3,[r0,#0x308]
000046  f0230301          BIC      r3,r3,#1
00004a  f8c03308          STR      r3,[r0,#0x308]
;;;3087   
;;;3088   	g_CheckVDMAComplete_Custom = DMA_READY;
00004e  7251              STRB     r1,[r2,#9]
;;;3089   	mUsbIntF0INDis();
000050  f8d01138          LDR      r1,[r0,#0x138]
000054  f4413180          ORR      r1,r1,#0x10000
000058  f8c01138          STR      r1,[r0,#0x138]
00005c  2108              MOVS     r1,#8
00005e  f8c01328          STR      r1,[r0,#0x328]
000062  f8d0132c          LDR      r1,[r0,#0x32c]
000066  f4412100          ORR      r1,r1,#0x80000
00006a  f8c0132c          STR      r1,[r0,#0x32c]
00006e  f8d0132c          LDR      r1,[r0,#0x32c]
000072  f0410108          ORR      r1,r1,#8
000076  f8c0132c          STR      r1,[r0,#0x32c]
00007a  f8d0132c          LDR      r1,[r0,#0x32c]
00007e  f4212100          BIC      r1,r1,#0x80000
000082  f8c0132c          STR      r1,[r0,#0x32c]
000086  f8d0132c          LDR      r1,[r0,#0x32c]
00008a  f0210108          BIC      r1,r1,#8
00008e  f8c0132c          STR      r1,[r0,#0x32c]
000092  f44f4180          MOV      r1,#0x4000
000096  f8c01318          STR      r1,[r0,#0x318]
00009a  4907              LDR      r1,|L35.184|
00009c  f8c0131c          STR      r1,[r0,#0x31c]
0000a0  f8d01318          LDR      r1,[r0,#0x318]
0000a4  f0410101          ORR      r1,r1,#1
0000a8  f8c01318          STR      r1,[r0,#0x318]
;;;3090   
;;;3091   	// Custom OUT
;;;3092   	RecieveCustomData_DMA();
;;;3093   #endif
;;;3094   
;;;3095   #ifdef ADD_BULK_CUSTOM
;;;3096   	// Bulk Custom IN
;;;3097   	mUsbEXDmaAbort(BULK_CUSTOM_FIFO_IN);
;;;3098   	mUsbEXDmaStop(BULK_CUSTOM_FIFO_IN);
;;;3099   
;;;3100   	g_CheckVDMAComplete_BulkCustom = DMA_READY;
;;;3101   	mUsbIntF0INDis();
;;;3102   
;;;3103   	// Bulk Custom OUT
;;;3104   	RecieveBulkCustomData_DMA();
;;;3105   #endif
;;;3106   
;;;3107   	return;
;;;3108   }
0000ac  4770              BX       lr
;;;3109   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L35.176|
                          DCD      0x40030000
                  |L35.180|
                          DCD      ||.data||
                  |L35.184|
                          DCD      ||.bss||+0x27f5

                          AREA ||i.protocol_hid_PushPenEvent||, CODE, READONLY, ALIGN=2

                  protocol_hid_PushPenEvent PROC
;;;1473   
;;;1474   void protocol_hid_PushPenEvent(const uSWIPTouchItem_t* _kptItem)
000000  490c              LDR      r1,|L36.52|
;;;1475   {
;;;1476   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1477   	HID_PEN_STATUS = (_kptItem->tItem00.tInfo.b1Status & 0x01);
;;;1478   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1479   	HID_PEN_STATUS = sptAlgorithmInfo->bLocal_sensing | (sptAlgorithmInfo->tPenInfo.bPenContact<<1);
000002  6e4a              LDR      r2,[r1,#0x64]  ; sptAlgorithmInfo
000004  f5025280          ADD      r2,r2,#0x1000
000008  f8923f8e          LDRB     r3,[r2,#0xf8e]
00000c  f8922f94          LDRB     r2,[r2,#0xf94]
000010  ea430242          ORR      r2,r3,r2,LSL #1
;;;1480   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1481   	HID_PEN_X = _kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow;
000014  654a              STR      r2,[r1,#0x54]  ; HID_PEN_STATUS
000016  78c2              LDRB     r2,[r0,#3]
000018  7843              LDRB     r3,[r0,#1]
00001a  ea422203          ORR      r2,r2,r3,LSL #8
;;;1482   	HID_PEN_Y = _kptItem->tItem00.ucYHigh << 8 | _kptItem->tItem00.ucYLow;
00001e  64ca              STR      r2,[r1,#0x4c]  ; HID_PEN_X
000020  7902              LDRB     r2,[r0,#4]
000022  7880              LDRB     r0,[r0,#2]
000024  ea422000          ORR      r0,r2,r0,LSL #8
;;;1483   
;;;1484   	g_PenEventNum++;
000028  6508              STR      r0,[r1,#0x50]  ; HID_PEN_Y
00002a  7a88              LDRB     r0,[r1,#0xa]  ; g_PenEventNum
00002c  1c40              ADDS     r0,r0,#1
00002e  7288              STRB     r0,[r1,#0xa]
;;;1485   }
000030  4770              BX       lr
;;;1486   
                          ENDP

000032  0000              DCW      0x0000
                  |L36.52|
                          DCD      ||.data||

                          AREA ||i.protocol_hid_PushTouchEvent||, CODE, READONLY, ALIGN=2

                  protocol_hid_PushTouchEvent PROC
;;;1441   
;;;1442   void protocol_hid_PushTouchEvent(const uSWIPTouchItem_t* _kptItem)
000000  4914              LDR      r1,|L37.84|
;;;1443   {
;;;1444   	if (hid_index < HID_MAX_TOUCH)
000002  6e8a              LDR      r2,[r1,#0x68]  ; hid_index
000004  2a0a              CMP      r2,#0xa
;;;1445   	{
;;;1446   #if USED_SHARP_SPECIFIC_PROTOCOL
;;;1447   		HID_status[hid_index] = (_kptItem->tItem00.tInfo.b1Status & 0x01);
;;;1448   #else /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1449   		HID_status[hid_index] = _kptItem->tItem00.tInfo.bTouch;
;;;1450   #endif /* USED_SHARP_SPECIFIC_PROTOCOL */
;;;1451   		HID_id[hid_index] = _kptItem->tItem00.tInfo.b4FingerID;;
;;;1452   #if USED_POOR_PANEL_COLLINE_DISABLE
;;;1453   		uint32_t ulTempXPos;
;;;1454   		ulTempXPos = ((uint32_t)((_kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow) * 10145))/10000;
;;;1455   		if(ulTempXPos > I2C_X_RESOLUTION)
;;;1456   			ulTempXPos = I2C_X_RESOLUTION;
;;;1457   		HID_x[hid_index] = ulTempXPos;
;;;1458   #else /* USED_POOR_PANEL_COLLINE_DISABLE */
;;;1459   		HID_x[hid_index] = _kptItem->tItem00.ucXHigh << 8 | _kptItem->tItem00.ucXLow;
;;;1460   #endif /* USED_POOR_PANEL_COLLINE_DISABLE */
;;;1461   		HID_y[hid_index] = _kptItem->tItem00.ucYHigh << 8 | _kptItem->tItem00.ucYLow;
;;;1462   
;;;1463   		hid_index++;
;;;1464   	}
;;;1465   }
000006  bfa8              IT       GE
000008  4770              BXGE     lr
00000a  7802              LDRB     r2,[r0,#0]            ;1449
00000c  f8d1c068          LDR      r12,[r1,#0x68]        ;1449  ; hid_index
000010  09d2              LSRS     r2,r2,#7              ;1449
000012  4b11              LDR      r3,|L37.88|
000014  f843202c          STR      r2,[r3,r12,LSL #2]    ;1449
000018  7802              LDRB     r2,[r0,#0]            ;1451
00001a  f8d1c068          LDR      r12,[r1,#0x68]        ;1451  ; hid_index
00001e  f002020f          AND      r2,r2,#0xf            ;1451
000022  3b78              SUBS     r3,r3,#0x78           ;1451
000024  f843202c          STR      r2,[r3,r12,LSL #2]    ;1451
000028  78c2              LDRB     r2,[r0,#3]            ;1459
00002a  7843              LDRB     r3,[r0,#1]            ;1459
00002c  f8d1c068          LDR      r12,[r1,#0x68]        ;1459  ; hid_index
000030  ea422203          ORR      r2,r2,r3,LSL #8       ;1459
000034  4b09              LDR      r3,|L37.92|
000036  f843202c          STR      r2,[r3,r12,LSL #2]    ;1459
00003a  7902              LDRB     r2,[r0,#4]            ;1461
00003c  7880              LDRB     r0,[r0,#2]            ;1461
00003e  ea422000          ORR      r0,r2,r0,LSL #8       ;1461
000042  f1030228          ADD      r2,r3,#0x28           ;1461
000046  6e8b              LDR      r3,[r1,#0x68]         ;1461  ; hid_index
000048  f8420023          STR      r0,[r2,r3,LSL #2]     ;1461
00004c  6e88              LDR      r0,[r1,#0x68]         ;1463  ; hid_index
00004e  1c40              ADDS     r0,r0,#1              ;1463
000050  6688              STR      r0,[r1,#0x68]         ;1463  ; hid_index
000052  4770              BX       lr
;;;1466   
                          ENDP

                  |L37.84|
                          DCD      ||.data||
                  |L37.88|
                          DCD      ||.bss||+0x1e0
                  |L37.92|
                          DCD      ||.bss||+0x190

                          AREA ||i.protocol_hid_mapping_emul_handler||, CODE, READONLY, ALIGN=2

                  protocol_hid_mapping_emul_handler PROC
;;;1120   
;;;1121   uint8_t protocol_hid_mapping_emul_handler(uint8_t ucType, uint16_t nTransCnt, uint16_t state, uint8_t InData)
000000  b570              PUSH     {r4-r6,lr}
;;;1122   {
;;;1123   	uint8_t OutData = 0x00;
000002  2500              MOVS     r5,#0
;;;1124   	switch (ucType)
000004  2801              CMP      r0,#1
000006  bf18              IT       NE
000008  2802              CMPNE    r0,#2
00000a  d03d              BEQ      |L38.136|
00000c  2803              CMP      r0,#3
00000e  d13b              BNE      |L38.136|
;;;1125   	{
;;;1126   	case I2C_SLAVE_INTERRUPT_STATUS_START:
;;;1127   		break;
;;;1128   	case I2C_SLAVE_INTERRUPT_STATUS_BYTE_TRANSFER:
;;;1129   		if (state & (I2C_SLAVE_FSM_STATUS_WRITE_ACK))
;;;1130   		{
;;;1131   			if (nTransCnt == 1)
;;;1132   			{
;;;1133   				usRegAddr = InData;
000010  4c1e              LDR      r4,|L38.140|
000012  f4125f80          TST      r2,#0x1000            ;1129
000016  d023              BEQ      |L38.96|
000018  2901              CMP      r1,#1                 ;1131
00001a  d00c              BEQ      |L38.54|
;;;1134   				usRegAddr <<= 8;
;;;1135   			}
;;;1136   			else if (nTransCnt == 2)
00001c  2902              CMP      r1,#2
00001e  d012              BEQ      |L38.70|
;;;1137   			{
;;;1138   				usRegAddr |= InData;
;;;1139   				if (protocol_GetMappedPointer != NULL)
;;;1140   				{
;;;1141   					rmi_read_ptr = rmi_write_ptr = (*protocol_GetMappedPointer)(usRegAddr);
;;;1142   					usb_sent_byte = usb_received_byte = 0;
;;;1143   				}
;;;1144   			}
;;;1145   			else if (nTransCnt > 2)
000020  d932              BLS      |L38.136|
;;;1146   			{
;;;1147   				if (rmi_write_ptr != NULL)
000022  6de1              LDR      r1,[r4,#0x5c]  ; rmi_write_ptr
000024  2900              CMP      r1,#0
000026  d02f              BEQ      |L38.136|
;;;1148   				{
;;;1149   					*(rmi_write_ptr++) = InData;
000028  f8013b01          STRB     r3,[r1],#1
;;;1150   					usb_received_byte++;
00002c  65e1              STR      r1,[r4,#0x5c]  ; rmi_write_ptr
00002e  8ae0              LDRH     r0,[r4,#0x16]  ; usb_received_byte
000030  1c40              ADDS     r0,r0,#1
000032  82e0              STRH     r0,[r4,#0x16]
000034  e028              B        |L38.136|
                  |L38.54|
000036  8263              STRH     r3,[r4,#0x12]         ;1133
000038  8a60              LDRH     r0,[r4,#0x12]         ;1134  ; usRegAddr
00003a  f64f71ff          MOV      r1,#0xffff            ;1134
00003e  ea012000          AND      r0,r1,r0,LSL #8       ;1134
000042  8260              STRH     r0,[r4,#0x12]         ;1134
000044  e020              B        |L38.136|
                  |L38.70|
000046  8a60              LDRH     r0,[r4,#0x12]         ;1138  ; usRegAddr
000048  4318              ORRS     r0,r0,r3              ;1138
00004a  8260              STRH     r0,[r4,#0x12]         ;1138
00004c  4810              LDR      r0,|L38.144|
00004e  6801              LDR      r1,[r0,#0]            ;1139  ; protocol_GetMappedPointer
000050  b1d1              CBZ      r1,|L38.136|
000052  8a60              LDRH     r0,[r4,#0x12]         ;1141  ; usRegAddr
000054  4788              BLX      r1                    ;1141
000056  65e0              STR      r0,[r4,#0x5c]         ;1141  ; rmi_write_ptr
000058  65a0              STR      r0,[r4,#0x58]         ;1142  ; rmi_read_ptr
00005a  2000              MOVS     r0,#0                 ;1142
00005c  82e0              STRH     r0,[r4,#0x16]         ;1142
00005e  e012              B        |L38.134|
                  |L38.96|
;;;1151   				}
;;;1152   			}
;;;1153   		}
;;;1154   		else if (state & (I2C_SLAVE_FSM_STATUS_READ_WAIT | I2C_SLAVE_FSM_STATUS_READ_END))
000060  f4126fa0          TST      r2,#0x500
;;;1155   		{
;;;1156   			if (rmi_read_ptr)
000064  bf1c              ITT      NE
000066  6da1              LDRNE    r1,[r4,#0x58]  ; rmi_read_ptr
000068  2900              CMPNE    r1,#0
00006a  d00d              BEQ      |L38.136|
;;;1157   			{
;;;1158   				OutData = *(rmi_read_ptr++);
00006c  f8115b01          LDRB     r5,[r1],#1
;;;1159   				if (protocol_ClearInterrupt != NULL)
000070  4808              LDR      r0,|L38.148|
000072  65a1              STR      r1,[r4,#0x58]  ; rmi_read_ptr
000074  6801              LDR      r1,[r0,#0]  ; protocol_ClearInterrupt
000076  b121              CBZ      r1,|L38.130|
;;;1160   				{
;;;1161   					(*protocol_ClearInterrupt)(usRegAddr + usb_sent_byte);
000078  8a60              LDRH     r0,[r4,#0x12]  ; usRegAddr
00007a  8aa2              LDRH     r2,[r4,#0x14]  ; usb_sent_byte
00007c  4410              ADD      r0,r0,r2
00007e  b280              UXTH     r0,r0
000080  4788              BLX      r1
                  |L38.130|
;;;1162   				}
;;;1163   				usb_sent_byte++;
000082  8aa0              LDRH     r0,[r4,#0x14]  ; usb_sent_byte
000084  1c40              ADDS     r0,r0,#1
                  |L38.134|
000086  82a0              STRH     r0,[r4,#0x14]
                  |L38.136|
;;;1164   			}
;;;1165   		}
;;;1166   		break;
;;;1167   	case I2C_SLAVE_INTERRUPT_STATUS_ADDR_MATCH:
;;;1168   		break;
;;;1169   	case I2C_SLAVE_INTERRUPT_STATUS_STOP:
;;;1170   		break;
;;;1171   	default:
;;;1172   		break;
;;;1173   	}
;;;1174   
;;;1175   	return OutData;
000088  4628              MOV      r0,r5
;;;1176   }
00008a  bd70              POP      {r4-r6,pc}
;;;1177   
                          ENDP

                  |L38.140|
                          DCD      ||.data||
                  |L38.144|
                          DCD      protocol_GetMappedPointer
                  |L38.148|
                          DCD      protocol_ClearInterrupt

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Status
                          %        18
                  g_IdleDuration
                          %        255
                  g_HID_Descriptor
                          %        9
                  g_Touch
                          %        66
                  g_TouchTip
                          %        12
                  HID_id
                          %        40
                  HID_x
                          %        40
                  HID_y
                          %        40
                  HID_status
                          %        40
                  g_Queue_Common
                          %        1992
                  tDebug
                          %        7000
                  u8_HID_MultiTouchReportDesc_Temp
                          %        717
                  g_CustomBuffer
                          %        64
                  g_BulkCustomBuffer
                          %        66

                          AREA ||.data||, DATA, ALIGN=3

                  g_Configuration
000000  00                DCB      0x00
                  g_HIDReady
000001  00                DCB      0x00
                  g_CXF_Done
000002  00                DCB      0x00
                  g_RemoteWakeup
000003  00                DCB      0x00
                  g_SuspendOn
000004  00                DCB      0x00
                  g_EP0_Check
000005  00                DCB      0x00
                  g_CheckVDMAComplete_Touch
000006  01                DCB      0x01
                  ResumeCnt
000007  00                DCB      0x00
                  Recovery_ClearSus_Flag
000008  00                DCB      0x00
                  g_CheckVDMAComplete_Custom
000009  01                DCB      0x01
                  g_PenEventNum
00000a  0000              DCB      0x00,0x00
                  g_EP0_BufferLength
00000c  0000              DCW      0x0000
                  g_LatencyMode
00000e  0000              DCB      0x00,0x00
                  g_MaxTouchCount
000010  0000              DCB      0x00,0x00
                  usRegAddr
000012  0000              DCW      0x0000
                  usb_sent_byte
000014  0000              DCW      0x0000
                  usb_received_byte
000016  0000              DCW      0x0000
                  g_DeviceMode
000018  00000000          DCB      0x00,0x00,0x00,0x00
                  g_pSetupPacket
                          DCD      g_EP0_Packet
                  g_EP0_BufferAddr
                          DCD      0x00000000
                  g_EP0_Offset
                          DCD      0x00000000
                  g_EP0_Remain
                          DCD      0x00000000
                  g_IntGroup
                          DCD      0x00000000
                  g_IntControl
                          DCD      0x00000000
                  g_IntVDMA
                          DCD      0x00000000
                  g_IntEP0
                          DCD      0x00000000
                  g_IntEP
                          DCD      0x00000000
                  g_ScanTime
                          DCD      0x00000000
                  g_ScanTime_Recovery
                          DCD      0x00000000
                  g_ScanTime_Recovery_ClearSus
                          DCD      0x00000000
                  HID_PEN_X
                          DCD      0x00000000
                  HID_PEN_Y
                          DCD      0x00000000
                  HID_PEN_STATUS
                          DCD      0x00000000
                  rmi_read_ptr
                          DCD      0x00000000
                  rmi_write_ptr
                          DCD      0x00000000
                  ulDebugIndex
                          DCD      0x00000000
                  sptAlgorithmInfo
                          DCD      0x00000000
                  hid_index
                          DCD      0x00000000
                  g_EP0_Packet
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                  g_StartTime
000078  00000000          DCQ      0x0000000000000000
00007c  00000000
                  g_StartTime_Recovery
000080  00000000          DCQ      0x0000000000000000
000084  00000000
                  g_StartTime_Recovery_ClearSus
000088  00000000          DCQ      0x0000000000000000
00008c  00000000

                          AREA ||area_number.43||, DATA, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.data||
                  g_EP0_BufferAddr_Free
                          DCD      0x00000000

                          AREA ||area_number.44||, DATA, ALIGN=0

                          EXPORTAS ||area_number.44||, ||.data||
                  g_CheckVDMAComplete_Pen
000000  01                DCB      0x01

                          AREA ||area_number.45||, DATA, ALIGN=0

                          EXPORTAS ||area_number.45||, ||.data||
                  g_CheckVDMAComplete_BulkCustom
000000  01                DCB      0x01

                          AREA ||area_number.46||, DATA, ALIGN=0

                          EXPORTAS ||area_number.46||, ||.data||
                  abnormalOperating
000000  00                DCB      0x00

                          AREA ||area_number.47||, DATA, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.data||
                  i2c_sent_byte
                          DCD      0x00000000

                          AREA ||area_number.48||, DATA, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.data||
                  i2c_received_byte
                          DCD      0x00000000

                          AREA ||area_number.49||, DATA, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.data||
                  ulDataIndex
                          DCD      0x00000000

                          AREA ||area_number.50||, DATA, ALIGN=0

                          EXPORTAS ||area_number.50||, ||.data||
                  g_pen_button1
000000  00                DCB      0x00

                          AREA ||area_number.51||, DATA, ALIGN=0

                          EXPORTAS ||area_number.51||, ||.data||
                  g_pen_button2
000000  00                DCB      0x00

                          AREA ||i.__ARM_common_memclr4_8||, COMGROUP=__ARM_common_memclr4_8, CODE, READONLY, ALIGN=1

                  __ARM_common_memclr4_8 PROC
000000  2100              MOVS     r1,#0
000002  6001              STR      r1,[r0,#0]
000004  6041              STR      r1,[r0,#4]
000006  4770              BX       lr
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Hal\\usb\\FWOTG210_F000\\Pe_usb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____REV16|
#line 388 "..\\..\\Hal\\system\\CMSIS\\cmsis_armcc.h"
|__asm___8_Pe_usb_c_669b9ed5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____REVSH|
#line 402
|__asm___8_Pe_usb_c_669b9ed5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_Pe_usb_c_669b9ed5____RRX|
#line 587
|__asm___8_Pe_usb_c_669b9ed5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
